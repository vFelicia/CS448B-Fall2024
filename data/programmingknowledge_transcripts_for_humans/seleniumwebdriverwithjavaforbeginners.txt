With timestamps:

00:00 - in this tutorial we will learn about the
00:01 - selenium the selenium framework why is
00:03 - it called as a framework and
00:06 - what are its advantages and
00:07 - disadvantages and its components
00:10 - so let's get started now here as an
00:12 - automation tool we will be studying the
00:13 - selenium webdriver
00:15 - for this you need to have some prior
00:17 - knowledge about the java and i have also
00:20 - explained what are the requirements of
00:21 - an automation tester
00:23 - i will give the link in the description
00:24 - box
00:25 - so when you go for an interview as an
00:28 - automation tester the very first
00:29 - question that comes to you is what is
00:32 - selenium
00:33 - see this is very important before
00:35 - mastering your skills in selenium you
00:37 - need to know what is selenium is at
00:39 - components as advantages and
00:40 - disadvantages and what are the different
00:42 - types of frameworks so we will be
00:44 - studying about selenium today
00:48 - so first let us understand what is
00:50 - selenium
00:52 - selenium is a portable framework for
00:55 - testing web applications now here there
00:58 - are three terms to understand in this
01:01 - definition one is portable second is
01:04 - framework third is web application
01:08 - now what is portable
01:10 - portable in general uh it means to be
01:13 - easily transported or relocated that is
01:16 - the meaning of portable
01:18 - now what is framework
01:20 - framework
01:21 - we can divide the word framework into
01:23 - two parts frame plus work that is if we
01:27 - work in a frame like here you can see
01:31 - this house right
01:34 - this is a house frame or a basic
01:35 - structure or a supporting structure with
01:38 - the help of this structure we will be
01:40 - able to build a house
01:42 - so this is a framework
01:44 - so framework just gives us the basic
01:47 - structure
01:48 - which will uh add our code for greater
01:51 - functionality of the system now you must
01:54 - be thinking why do we use framework we
01:57 - use framework for reusability and we
01:59 - don't need to build things from scratch
02:02 - like suppose
02:04 - let us take up an example if you are
02:06 - making a dynamic web page and what will
02:08 - you do you will create folders like
02:10 - suppose
02:11 - index.html then style.css validate.php
02:16 - and etc see the problem here is not that
02:18 - you have to create folders but the
02:20 - problem is that you have to follow the
02:22 - same process again and again
02:25 - but if you use a framework we don't have
02:26 - to worry about that
02:28 - you just need to code your logic and
02:30 - that's it so that's framework
02:32 - framework just gives us the basic
02:34 - structure round
02:36 - which we will add our code for greater
02:39 - functionality of the system
02:41 - okay that's framework
02:44 - next we have web applications
02:47 - now there are basically three types of
02:48 - applications web-based application
02:51 - desktop application and mobile
02:53 - applications
02:55 - web-based applications are applications
02:57 - that can be accessed through browsers
02:59 - that is like the online forms the
03:01 - registration forms those are online
03:03 - based applications
03:05 - then we have the desktop application the
03:07 - desktop applications are the
03:08 - applications in which we we install in
03:12 - the local system for example the
03:14 - microsoft word excel powerpoint
03:17 - that's your desktop application
03:19 - mobile applications are application we
03:21 - install our mobile in our mobile through
03:23 - a play store we download some apps like
03:26 - whatsapp flipkart amazon those are
03:29 - mobile applications
03:30 - now selenium is a portable framework for
03:33 - testing only web applications selenium
03:35 - tests only web applications that is the
03:38 - application that can be accessed through
03:40 - browsers
03:44 - this also serves as a limitation but we
03:46 - will discuss that later
03:49 - so moving forward
03:51 - why selenium
03:55 - first thing
03:56 - we will choose linear because of cost
03:58 - selenium is free it is open source as
04:01 - compared to the other tools like qtp and
04:04 - uft they are a paid
04:07 - the second point is flexibility
04:10 - selenium supports multiple programming
04:12 - languages like java c sharp python ruby
04:15 - and many more whereas if you go to some
04:18 - other tool like qtp it supports only
04:20 - vbscript
04:22 - next is the multiple browsers
04:25 - selenium supports multiple browsers like
04:27 - chrome firefox safari and many more
04:30 - whereas if you take qtp as a selenium
04:32 - tool it supports only chrome
04:35 - it also supports multiple os like
04:38 - windows linux apple and many more
04:42 - the main important point is that why are
04:44 - we using selenium because it supports
04:46 - parallel testing now let me tell you
04:48 - what is parallel testing
04:51 - the browser will execute the commands in
04:53 - two ways
04:55 - one is the parallel execution second is
04:58 - the cross browser execution now here you
05:01 - see on the screen parallel execution let
05:03 - us understand that first parallel
05:05 - executions are execution in which the
05:07 - test scripts opens all the browser at
05:10 - the same time and executes at the same
05:12 - time it's called as parallel execution
05:15 - here you can see there's a test scripts
05:17 - then you can see there are three
05:19 - browsers over here the first one is
05:21 - chrome the second is the firefox the
05:22 - third is the internet explorer
05:25 - so the test script will open all the
05:27 - browser at the same time and executed at
05:29 - the same time this is parallel execution
05:32 - we will explain i will explain it with
05:35 - an example just wait first understand
05:37 - what is cross browser execution
05:41 - cross browser execution let us take up
05:42 - an example like suppose
05:44 - uh in the test script over here it is
05:47 - written to insert some value in the drop
05:50 - down menu
05:51 - so this command will be first executed
05:54 - in the chrome browser
05:55 - when the execution is finished that is
05:57 - when the value is inserted in the drop
06:00 - down menu
06:01 - then the firefox browser will be open
06:05 - and the command to insert the value in
06:07 - the drop down box will be executed
06:10 - and when that command is executed then
06:12 - the internet explorer will be opened and
06:15 - the command will be executed so this is
06:17 - called cross browser execution that
06:19 - means the test script will open the brow
06:21 - chrome browser first
06:23 - after two three minutes when the
06:24 - execution is done it opens the firefox
06:26 - browser and then after some time it will
06:29 - open the internet explorer browser this
06:31 - is cross browse execution cross browser
06:33 - execution
06:34 - whereas in parallel execution if we have
06:36 - the same command to insert some value in
06:39 - the drop down menu then this command
06:41 - will be executed in all the browsers at
06:43 - the same time this is parallel execution
06:47 - and selenium supports parallel execution
06:52 - now let's move a little deeper towards
06:54 - the selenium uh we will study the
06:56 - selenium components which come prices of
06:58 - the selenium suite total we have the
07:00 - four components like the ide rc web
07:03 - driver and grid
07:05 - let us discuss ide first
07:08 - now the selenium ide is the most
07:11 - simplest tool in the entire suites of
07:13 - selenium it is nothing but an integrated
07:16 - development environment
07:18 - see earlier this ide was simply just a
07:20 - firefox extension and
07:23 - it's just a play around tool like you
07:25 - know you just play record functionality
07:27 - mainly it is useful prototyping and it
07:29 - is used only for demo purposes
07:32 - you cannot use ide for creating
07:34 - automation real-time projects because of
07:36 - its some limitations we will discuss
07:38 - those limitations later then the next
07:40 - component is the rc that is the selenium
07:42 - remote control
07:45 - it is used to write web application test
07:48 - in different programming languages it
07:50 - interacts with the browser with the help
07:52 - of the rc server
07:55 - through which we can interact to the web
07:56 - browser but this rc server got
07:59 - deprecated in the selenium version 2
08:02 - and was replaced by the web driver in
08:04 - the selenium version 3. we will discuss
08:07 - that also why it happened
08:10 - the next component is the selenium web
08:12 - driver
08:14 - the selenium web driver is one of the
08:16 - most important component in the selenium
08:19 - suites
08:20 - it is an api to create and execute the
08:24 - test cases and it is a successor of rc
08:27 - basically the selenium web driver is a
08:29 - collection of open source api and which
08:31 - will be used to automate the testing of
08:34 - a web application as i said we will
08:37 - study the selenium web driver very
08:38 - deeply the next component is grid the
08:41 - selenium grid is used to run multiple
08:43 - test scripts simultaneously on the
08:46 - different browser and platforms and it
08:48 - supports parallel testing what is
08:50 - parallel testing i explained in the
08:51 - previous slide so because of a grid we
08:55 - can selenium supports parallel testing
08:57 - so these are the four components in
08:59 - selenium
09:01 - let us discuss the drawbacks of ide the
09:03 - first drawback selenium id is a
09:06 - mozzarella firefox plugin which means
09:08 - the tests can be recorded only in the
09:11 - firefox browser and not in any other
09:13 - browser second it's not suitable for
09:16 - dynamic web pages because it is just a
09:18 - prototyping tool which works well only
09:21 - with the static web pages and not with
09:23 - the dynamic web pages
09:25 - third data driven testing is not
09:28 - possible
09:29 - fourth cannot provide detailed test
09:31 - reports
09:32 - whereas rc the next version of ide can
09:35 - provide detailed reports
09:38 - then we cannot perform database testing
09:40 - through id same because it is just a
09:43 - prototyping tool it is used for demo and
09:45 - it is not used for automating web
09:47 - applications
09:48 - due to these drawbacks rc came into
09:51 - picture now we have discussed the
09:52 - components of selenium let's see the
09:54 - versions of selenium here we have total
09:57 - four versions selenium version one
09:59 - selenium version two three and four now
10:01 - see here we will dig into some history
10:03 - of the selenium here the selenium
10:05 - version one
10:06 - we have the selenium ide rc plus grid so
10:10 - when jason against introduces selenium
10:12 - the tool was called as a javascript
10:14 - program
10:16 - he called it as a javascript tester
10:19 - but he had one major issue that that is
10:22 - called as the same origin policy
10:25 - so now what is you must be thinking that
10:26 - what is this same origin policy
10:29 - this policy says that when javascript is
10:32 - executed in the domain
10:34 - it can access the web pages in that
10:37 - domain only and it cannot access any
10:40 - other web page in the another domain
10:43 - for example suppose like a web page in
10:46 - the google like if you have a domain
10:48 - google.com okay so you can access the
10:51 - search bar the email the drive
10:53 - but
10:54 - that can be accessible but nothing can
10:56 - be accessible outside the google.com
10:59 - like if you want to access you yahoo uh
11:02 - mantra or amazon or any other domain
11:04 - that cannot be accessible definitely
11:06 - this is because of some security reasons
11:09 - so that is why this is called as a same
11:11 - origin policy
11:13 - now to overcome this policy remote
11:15 - control server was designed that is the
11:18 - selenium rc now the main reason to
11:20 - create the server was to trick the
11:22 - browser in believing that the selenium
11:25 - code in which we are running the scripts
11:27 - and the web application under test are
11:30 - in the same domain
11:32 - now here this same origin policy is
11:34 - solved so this was the version one of
11:37 - selenium
11:38 - where we have the id rc and grid where
11:41 - the same
11:42 - origin policy was solved in the version
11:45 - one
11:46 - then comes the selenium version two
11:48 - here we have the ide the web driver the
11:51 - rc and the grid see in 2007 when this
11:54 - when siemens stewart he invented this
11:57 - web driver now why did he invent this
12:00 - web driver because the architecture of
12:02 - the rc was very complicated
12:05 - and in rc we need a separate server to
12:08 - talk to this like we need a separate
12:10 - server to talk to the browser so what he
12:12 - did is he removed the requirement of the
12:15 - separate server
12:17 - and this is the selenium version 2 where
12:19 - the web driver was introduced now why
12:21 - you must be thinking like why web driver
12:23 - and rc is uh introduced over here in the
12:25 - version 2 because the web driver was in
12:27 - the development phase and they were
12:29 - trying to implement it so that is the
12:31 - reason why we have uh in the selenium
12:34 - version 2 the ide the web driver the rc
12:36 - and the grid so in the selenium version
12:39 - 3 we had the ide web driver and grid
12:42 - here you see that the rc was completely
12:44 - deprecated and we only have the web
12:46 - driver currently we have the selenium
12:48 - version 4 that have many new features
12:51 - this is the new version of selenium 4
12:52 - and now it is still in development
12:55 - recently there was a version
12:56 - known as alpha version was introduced
12:59 - and this version was mainly introduced
13:01 - because of
13:03 - complete w3c protocol adoption but this
13:06 - change in protocol isn't going to impact
13:09 - any of the user because
13:11 - many major of the browser drivers like
13:13 - the firefox the chrome driver and they
13:15 - all are included in the selenium 3.8
13:18 - version which we are going to use and i
13:21 - will be also explaining i will be uh
13:22 - explaining some of the features of the
13:24 - selenium fourth version we will do that
13:27 - also like there are many ways to take
13:29 - screenshot in the selenium 4 version
13:31 - there are two to three methods
13:32 - so there are new apis added there are
13:35 - some ways to access the web elements
13:37 - also and there are some of the features
13:38 - that are very new
13:40 - introduced in the selenium version so
13:41 - mainly we will be studying about the
13:43 - selenium webdriver now you must be
13:45 - thinking why selenium webdriver
13:49 - now why are we studying the selenium
13:50 - webdriver for that we need to know the
13:52 - drawbacks of the
13:54 - selenium rc
13:59 - now this is the architecture of the
14:00 - selenium rc this is the main reason why
14:04 - we are studying the web driver
14:06 - so the selenium rc is a test tool that
14:09 - allows you to write automated web
14:12 - applications in various programming
14:14 - languages like java python ruby
14:17 - so let's see the architecture of
14:19 - selenium rc
14:21 - first we need to write the test scripts
14:24 - in supported languages like java python
14:26 - or any other supported language
14:29 - but before writing these test scripts
14:32 - the major requirement in rc is the rc
14:35 - server
14:36 - so first you need to start the rc server
14:38 - before you run a core and this rc server
14:41 - is a separate application
14:43 - this rc uh is uh responsible for
14:46 - receiving the selenius command from your
14:48 - test scripts
14:50 - it interprets them and then reports the
14:52 - result back to the script
14:55 - now i use the word selenius over here
14:57 - now what is the selenius commands they
14:59 - are nothing but the commands that are
15:00 - written in the test scripts are called
15:02 - as silence commands in id and rc they
15:05 - are called as syringes commands
15:07 - now let's look at the browser
15:10 - interaction how the browser interacts
15:13 - the browser interactions happens through
15:15 - the rc server
15:17 - this rc server is a simple http post and
15:21 - http get request to communicate okay it
15:25 - uses the simple http posts and get
15:27 - request to communicate to the browser
15:29 - now how this communication happens
15:32 - this rc server acts like a proxy now you
15:35 - see there is a complete cycle
15:38 - starting from your test script then the
15:40 - rc the rc server injects the javascript
15:43 - in the web browser
15:45 - runs your commands takes back the
15:47 - results sends it to the rc server
15:50 - and then the result is displayed this
15:52 - whole cycle gets repeated for each and
15:55 - every command which is written in the
15:57 - test scripts this is how the test case
16:00 - gets executed in the rc server like the
16:03 - selenium rc tool this is how the whole
16:07 - cycle goes for each and every test
16:09 - scripts
16:10 - now everything was good but why
16:13 - was rc not good enough to run test
16:15 - scripts let me tell you why what are
16:17 - those drawbacks
16:19 - first time taken for execution of
16:21 - command is locker why because there is
16:23 - an additional server rc to so it
16:25 - executes each and every command is
16:28 - executed through the rc so it takes a
16:30 - lot of time for execution
16:32 - the api supported by rc are redundant
16:35 - and confusing because
16:38 - one command means many meaning it has a
16:40 - lot of meaning for one command like
16:42 - suppose there is a command called as
16:44 - click and click at
16:46 - so which one to use it's very confusing
16:48 - for the developers then there is
16:50 - complicated architecture
16:53 - rc consists of an additional server that
16:55 - acts as a middleman
16:57 - also the mobile apps cannot be tested
17:00 - using rc so these are the drawbacks of
17:02 - rc
17:04 - now let's see how does selenium
17:06 - webdriver overcome these drawbacks for
17:08 - this we need to understand the
17:10 - architecture of the webdriver
17:13 - so in the webdriver architecture we have
17:15 - the test scripts
17:17 - the web browser and the web server
17:19 - however we do not have an additional
17:21 - server for communication like the rc
17:23 - server
17:24 - which we saw in the
17:27 - selenium rc which makes the architecture
17:29 - of the web driver very very easy because
17:32 - we don't have an additional server in
17:34 - this as you can see there are direct
17:36 - interactions with the web browser
17:39 - so as an advantage the selenium does not
17:42 - use an additional server and since there
17:44 - is no intermediate server
17:46 - there then the browser is controlled
17:49 - directly from the
17:51 - system
17:52 - due to this direct communication the
17:54 - overall cycle that we saw in the rc
17:57 - server was which was very indirect
17:59 - communication since this indirect
18:00 - communication made the execution very
18:02 - slow so that's why we have the web
18:05 - driver in which the execution is faster
18:07 - than the rc server
18:09 - as you can see the execution time for
18:11 - command is shorter due to the simple
18:14 - architecture now you have seen the
18:16 - architecture of rc and webdriver let's
18:19 - compare the selenium rc and the selenium
18:21 - webdriver
18:24 - let's see in terms of api
18:26 - now rc is less object oriented api
18:31 - now the api and rc is very confusing and
18:34 - redundant for example we have commands
18:36 - like click or click at commands
18:39 - which one to use so it was very
18:41 - confusing for the developers and the
18:43 - direct browsers
18:45 - interpreted different commands also
18:48 - which was very challenging for the
18:50 - developers working on different browsers
18:51 - for different browsers browsers there
18:53 - were different commands
18:55 - so it was very challenging
18:57 - whereas for selenium webdriver it is
18:59 - very simpler api and it is very easier
19:02 - to use for example we have the click
19:04 - function to click on the web element we
19:06 - have the send key command to send text
19:08 - on very on any web element in the web
19:10 - page so it has a very simpler api
19:14 - now let's see in terms of speed selenium
19:17 - rc is slow in execution
19:20 - and in terms of speed web driver is
19:23 - faster in execution
19:25 - because in selenium rc we have the rc
19:27 - server whereas in web driver there is no
19:29 - additional server
19:31 - next let's let's see in terms of browser
19:34 - support see rc and webdriver supports
19:36 - multiple browser but rc does not have
19:39 - support for html
19:41 - unit which is a headless browser
19:44 - now let's see what is this headless
19:46 - browser
19:47 - headless browser is a browser which does
19:50 - not have a ui
19:52 - this helps to make testing more faster
19:55 - because it does not need a real browser
19:57 - for testing it does not take
19:59 - time to load the web elements
20:01 - so and the headless browser is very
20:03 - quick so rc and webdriver the support
20:06 - multiple browser but rc does not support
20:09 - html unit that is the headless browser
20:12 - whereas the web driver supports the
20:14 - headless browser and it is and it makes
20:16 - the execution move faster next we have
20:18 - the uh comparison in terms of testing
20:21 - mobile applications selenium rc does not
20:24 - support testing of mobile applications
20:27 - whereas web driver selenium web driver
20:29 - it supports testing of mobile
20:30 - application there is an application name
20:32 - as apm through which we can test mobile
20:34 - applications so these were the
20:36 - difference between the rc and the web
20:38 - driver
20:40 - but every component has its own
20:42 - drawbacks so let us see the drawbacks of
20:45 - webdriver
20:47 - one
20:48 - cannot readily support new browsers but
20:51 - rc can
20:52 - and it does not have a built-in command
20:54 - for automatic generation of test results
20:57 - see uh it cannot readily support new
20:59 - browsers there are many new versions
21:01 - coming up
21:02 - so this challenge can be overcome
21:05 - second we don't have built-in commands
21:07 - for automatic generation of test results
21:09 - whereas in rc we have we can generate
21:11 - test results there's a proper format in
21:13 - rc
21:14 - whereas in web driver we don't but we
21:16 - can use a third-party tool we can
21:19 - integrate third-party tools for the
21:21 - test results generation so now we will
21:24 - discuss some advantages and
21:25 - disadvantages of selenium
21:28 - advantages of selenium
21:30 - selenium is an open source tool and it
21:33 - supports multiple operating system and
21:35 - multiple browsers like chrome safari
21:37 - internet explorer and many more it also
21:40 - supports multiple programming languages
21:42 - like java python c ruby etc apart from
21:46 - all this we can also integrate the third
21:48 - party tools in selenium like apache poi
21:51 - auto i t sql and why do we need to
21:53 - integrate this we will understand that
21:55 - in the next slide
21:56 - here you see the disadvantages of
21:58 - selenium the first disadvantage is that
22:01 - it cannot support window-based
22:03 - application
22:04 - it can only support the web-based
22:06 - application
22:08 - but to overcome this disadvantage we can
22:10 - use a third party tool that is the auto
22:12 - id or the sql tool the second is that it
22:15 - cannot support test reports but if we
22:17 - integrate test ng or extend reports
22:20 - through that we can generate test
22:21 - reports
22:23 - third cannot support excel files now you
22:26 - must be thinking why do we use excel
22:28 - files we use excel files while we doing
22:30 - uh while we are doing the
22:32 - uh data driven testing
22:34 - we use it because suppose there is a
22:36 - username and a password field and there
22:38 - are many test data to it like
22:41 - for user name you have the admin for
22:43 - password you have admin at the rate one
22:45 - two three that's one test data the
22:46 - second test data third fourth so like
22:48 - this there can be many test data to
22:51 - check the expected and the output result
22:53 - we will match it and then we will pass
22:55 - the status as
22:56 - fail or pass so matching those and
22:59 - results and
23:01 - communicating the test scripts to the
23:03 - excel files that selenium cannot support
23:05 - that
23:06 - but through apache pui we can do it next
23:08 - we have less or no technical support in
23:10 - selenium because selenium is an open
23:12 - source tool so there is very less or
23:14 - technical support but there are many
23:16 - forums and communities on internet
23:18 - whereas wherever you can uh
23:21 - write your queries and you can get your
23:23 - answers
23:25 - then writing test cases are sometimes
23:27 - very time consuming because it is just a
23:29 - programming interface and not an ide see
23:32 - whereas if you go in other tools like
23:33 - the qtp and uft though those are id as
23:37 - well as the programming interface that
23:38 - means you can
23:40 - record also you can record also the test
23:43 - scripts that you have written whereas
23:45 - over here it is just a programming
23:47 - interface each and every command needs
23:48 - to be written so at times it becomes
23:50 - very time consuming so these are the
23:52 - disadvantages of selenium till now we
23:55 - have learnt uh what is selenium why is
23:57 - it called as a framework we have learned
23:59 - the versions of selenium their
24:01 - components that drawbacks and why are we
24:03 - starting the
24:04 - web driver
24:05 - we have also learned what are the
24:07 - advantages and disadvantages so in the
24:09 - next tutorial in the next video we will
24:11 - learn the installation part of selenium
24:14 - and then we will start the
24:15 - implementation of selenium we are going
24:17 - to install the intellij idea ide and
24:20 - some drivers and jar files for selenium
24:22 - framework so let's get started
24:26 - so the first thing that you need to do
24:27 - is go to google and type
24:29 - intellij idea
24:34 - and here you see the first link that we
24:36 - have that is
24:38 - www.jetbrains.com
24:39 - simply just click on this link
24:42 - so this is the official website of the
24:44 - intellij idea ide so the intellij idea
24:48 - is an integrated development environment
24:50 - that is the ide written in java for
24:52 - developing computer software and it was
24:55 - developed by the jet brains
24:57 - apart from all this the
24:59 - intellij idea ide has many features like
25:03 - built-in tools then we then it supports
25:06 - the jvm languages like the java kotlin
25:09 - scala
25:10 - and it also has some frameworks like
25:12 - spring java double e and it also
25:14 - supports mobile development
25:16 - and some of the web development like the
25:19 - html css angular
25:21 - typescript javascript so these are some
25:24 - of the features of the intellij idea ide
25:27 - and in terms of system requirement we
25:29 - will need a
25:31 - ram of 2gb minimum and the disk space
25:34 - that we require is of 3gb of space
25:36 - we also need to install the java jdk
25:39 - first and then we will install the
25:41 - intellij idea ide
25:43 - so let's install the java jdk first all
25:46 - you need to do is just type java
25:49 - jdk download and
25:51 - the first link that you get is the
25:53 - www.oracle.com
25:55 - just click on this link
25:58 - and here you see there are different
26:00 - versions of jdk like we have the java sc
26:02 - 15 we have the java se14
26:05 - and java s11 we will download the latest
26:07 - version that is the java sc50
26:13 - click on jdk download
26:16 - and click on this windows x64 installer
26:19 - this one if you're using the mac os then
26:21 - click on this one but i'm using windows
26:24 - so i'll be clicking on jdk 15 windows
26:30 - now here you must accept the license
26:32 - agreement for java oracle sc which says
26:35 - that i reviewed and accept the oracle
26:37 - technology network license agreement for
26:40 - java oracle se simply just click on this
26:43 - check box and click on download jdk 50.
26:47 - so now here you can see that my jdk 15
26:49 - has been downloaded so let's install
26:51 - this
26:52 - simply just click on it
26:54 - click on next
26:56 - and
26:57 - your
26:58 - jdk will be installed in this file
27:02 - so just let it be that way just click on
27:05 - next
27:07 - and yeah it's installing now it might
27:09 - take some time
27:10 - so now you can see that my java jdk
27:14 - 15 has been successfully installed
27:17 - so let's check this out simply just
27:18 - click on close and over here just click
27:22 - cmd
27:24 - let's see if this has installed or not
27:26 - properly in our computer so we will
27:28 - check it through command prompt
27:31 - simply just type java
27:34 - space
27:35 - dash version
27:38 - so here you can see that we can see that
27:41 - we have downloaded our java jdk version
27:44 - 15. so once we have installed our jdk we
27:47 - have to set the environment variables
27:49 - all we need to do is just go here and
27:52 - write
27:53 - environment variable
27:55 - and here you can see edit the system
27:57 - environment variable click on this here
27:59 - you can see in the advanced tab there is
28:01 - environment variable click over here
28:04 - and in system variables go to
28:07 - path
28:09 - click edit and here we will edit the
28:12 - path how you gonna do that just simply
28:15 - go where you have installed your jdk
28:18 - that is
28:19 - c drive program files
28:22 - java
28:23 - jdk
28:25 - bin folder open your bin folder
28:28 - copy this path
28:31 - and place it over here
28:34 - and click on ok
28:37 - ok
28:40 - and over here also ok
28:42 - so you have set your environment
28:44 - variable path also
28:46 - now you will install the intellij idea
28:49 - id simply uh just go to the official
28:51 - website of the intellij idea ide and
28:53 - click on download over here so there are
28:55 - two versions over here ultimate in
28:57 - community we will download the community
28:59 - version
29:02 - click on download
29:06 - here you can see that it started
29:07 - downloading it might take some time so
29:10 - just wait now i have download the
29:12 - intellij idea ide the community version
29:15 - here you can see now let's install it
29:17 - simply just click it
29:19 - click on run
29:27 - click
29:27 - next
29:31 - next now over here uh
29:34 - create desktop shortcut yes
29:36 - for the 64-bit launcher and
29:39 - update context menu
29:42 - i'll click this check box create
29:45 - associations for now i don't want to
29:47 - create any association
29:49 - then update path variable restart needed
29:53 - yes i will add the launcher to the path
29:57 - i'll
29:58 - click this checkbox as well
30:00 - and then click on next
30:06 - click on install
30:09 - and here you can see that the intellij
30:11 - idea ide is getting installed
30:14 - now here you can see that my intellij
30:16 - idea community version has been
30:18 - installed
30:19 - so i'll just click on this
30:36 - simply click on new project then here uh
30:39 - just click on java and
30:42 - here you can see that the java version
30:45 - 15. this is the jdk
30:47 - that we have installed before
30:50 - simply just click on next create project
30:53 - from template i'll just name it as hello
30:57 - and finish
31:27 - i'll just change the interface of this
31:32 - ide
31:33 - all we need to do is simply just go to
31:35 - file
31:37 - go to settings and here in the
31:39 - appearance bar just change the theme to
31:42 - [Music]
31:43 - intellij light
31:48 - so this is how you can do it
31:50 - now let's run a program saying hello
31:52 - world
31:54 - simply just write s out and here you can
31:58 - see we have the system out.println so
32:02 - this intellij idea ide has a feature of
32:04 - autocompleting also just simply by
32:06 - writing s out it will be
32:08 - system.out.println
32:10 - and i'll write
32:12 - hello
32:14 - everyone
32:25 - i'll save it
32:29 - and i'll click on this button
32:32 - so here you can see the output that's
32:35 - hello everyone that's what i printed
32:37 - over here
32:38 - so our program has been successfully
32:40 - executed so this is all about the
32:42 - intellij idea id
32:44 - so now we have installed the intellij
32:46 - idea ide and the java jdk also so we
32:50 - will install some of the drivers and the
32:52 - java files that we require in the
32:54 - selenium so all you need to do is just
32:56 - you need to go to this official page of
32:58 - the selenium is
33:01 - selenium hq i will give all the links in
33:04 - the description box so it will be easier
33:05 - for you
33:09 - click on this link that is a
33:11 - selenium.div
33:14 - and go to downloads
33:17 - this is the official website of selenium
33:19 - and we will download all our drivers and
33:21 - jar files from this website only
33:25 - now here first we will download some of
33:27 - the selenium client and web driver
33:29 - language bindings now selenium supports
33:31 - many languages like ruby java python c
33:35 - we will be working on java you will be
33:37 - working with java so in order to create
33:40 - scripts of selenium webdriver you need
33:43 - to make use of language specific line
33:46 - drivers so these are the drivers
33:48 - of java
33:50 - see here there are some of the versions
33:52 - that i have told before as well there's
33:53 - a stable version that is a 3.141
33:58 - and the alpha version that is recently
34:00 - released i have discussed about the
34:02 - versions of selenium in the previous
34:04 - videos you can check out that
34:06 - for now uh to download these jar files
34:10 - we will
34:11 - click over here download
34:16 - and here you can see a zip file has been
34:19 - downloaded
34:21 - here you can see that it is downloaded
34:23 - simply click on this file
34:25 - just extract it
34:31 - and here you can
34:32 - see now see i would recommend you to
34:36 - make a separate folder for java files so
34:38 - it will be very easy and beneficial for
34:40 - you because we will be downloading many
34:42 - java files and drivers
34:44 - so it will be very confusing and here we
34:46 - will be giving the paths also in the
34:48 - program
34:48 - when we execute our test cases so it
34:51 - will be very difficult that which driver
34:53 - is placed where
34:54 - so it's better that you would make a
34:56 - separate folder for those drivers and
34:58 - jar files
35:00 - so here in d drive i'm making a separate
35:02 - folder named
35:05 - selenium
35:07 - jar
35:09 - and drivers
35:13 - okay
35:14 - so i'll be placing all my jar files and
35:16 - drivers in this file all i need to do is
35:19 - those
35:20 - files which i had downloaded here you
35:22 - can see that this is jar file this is
35:24 - executable jar files
35:26 - these two jar files i'll copy first
35:31 - and place it over here
35:36 - then the next i'll go in lips folder and
35:38 - over here all these jar files i will
35:41 - copy it and
35:43 - place it here
35:47 - okay
35:48 - so these are the java files which we
35:50 - downloaded now we will add all these jar
35:52 - files in the intellij idea ide
35:56 - so now we will add the jar files so
35:58 - simply just go on file
36:02 - go to project structure
36:10 - go to modules and go to the dependency
36:13 - tab
36:15 - you can see here add sign this plus sign
36:18 - click on this
36:20 - click on jar or directories
36:26 - then
36:27 - go to the file where your jar files are
36:30 - placed
36:36 - so here you can see all these jar files
36:38 - which i have pasted in the selenium jar
36:40 - and drivers
36:42 - just click all of them and
36:46 - add it
36:47 - click on ok
36:51 - and here you can see the jar file is
36:54 - added
36:56 - click on apply
36:59 - and click on ok
37:03 - just wait for a second here you can see
37:06 - indexing dependencies just wait for it
37:15 - so here you can see now those jar files
37:17 - are added
37:20 - so now we have installed the uh jdk we
37:24 - have set the path for it
37:26 - and then we have installed the intellij
37:28 - idea ide and we have added the jar files
37:31 - also
37:32 - so now let's install the drivers just go
37:34 - to the official website of selenium that
37:37 - is will be selenium.dave
37:39 - click on this
37:41 - and click on downloads
37:47 - so here you can see platform supported
37:50 - by selenium browsers
37:52 - now for various browsers we have various
37:54 - drivers for firefox we have the gecko
37:56 - driver we
37:58 - for the chrome we have the chrome driver
38:00 - for safari we have the safari driver so
38:02 - mainly i will be
38:04 - performing operations using the chrome
38:06 - driver
38:08 - so first we will download the chrome
38:11 - driver
38:12 - for chrome
38:13 - just simply before downloading open your
38:16 - chrome
38:17 - and be careful about the versions of
38:19 - chrome firefox and internet explorer you
38:22 - can do that by just going over here and
38:24 - click on settings
38:29 - click
38:30 - on about chrome and here you can see my
38:33 - version is 85.0.4183.121
38:38 - so i'll be installing the driver of this
38:40 - version only
38:41 - be very careful with your drivers
38:43 - because if you're uh having an old
38:46 - version of google chrome and you're
38:47 - downloading a driver of a different
38:49 - version so it won't work
38:50 - so it's better check out your version
38:52 - first update it and then download an
38:55 - updated driver
38:57 - so i'll just simply go and write your
39:00 - download
39:03 - chrome driver for
39:05 - 85.0.4183.21
39:11 - and here you can see
39:13 - i'll give the links in the description
39:15 - box so it'll be very easier for you to
39:17 - download
39:22 - see here the chrome driver for the
39:23 - latest is 86.0 but the latest version
39:27 - that is the stable version that i'm
39:29 - having is 85.0.4183
39:33 - so
39:34 - i'll be downloading this
39:37 - version
39:45 - now if you're having linux then click
39:47 - this one if you're having mac then click
39:49 - this one and if you're having windows
39:51 - then click this one i'm having windows
39:53 - so i'll be clicking chrome driver
39:55 - underscore windows 32
39:57 - zip folder
39:58 - and here you can see it has downloaded
40:01 - so here you can see this chrome driver
40:03 - it is a zip file i will extract it
40:06 - just simply click on extract all and it
40:10 - will start extracting it
40:12 - and here it is it is
40:16 - chrome driver all you need to do is just
40:18 - copy this driver
40:20 - and paste it the
40:25 - copy this driver and paste it in your
40:27 - folder that you have made
40:29 - so i have made different folders over
40:31 - here like for chrome driver firefox
40:33 - driver ie drivers and the jar files
40:36 - keep things making programs while
40:38 - implementing the selenium framework when
40:40 - you are implementing it we need to add
40:42 - many java files we need to have many
40:45 - drivers also so if you keep things very
40:47 - systematic it will be very easier for
40:49 - you
40:50 - so here for chrome driver i have added
40:53 - this
40:54 - now let's go and install the firefox
40:56 - driver
40:58 - simply just go on firefox again check
41:01 - your version you don't need to do
41:02 - anything just click on settings
41:04 - and go to general
41:08 - and here you can see
41:10 - my version is 81.0
41:13 - so
41:14 - i'll be downloading the
41:16 - driver for version 81.0 just type
41:20 - download
41:22 - firefox
41:26 - driver for version
41:30 - 81.0
41:37 - so here you can see the gecko driver
41:48 - and here you can see it's
41:51 - downloading it
42:01 - so here this is the driver for the
42:03 - firefox i will extract it
42:08 - and here it is again i will copy it
42:11 - and paste it over here
42:15 - in firefox driver
42:20 - so today we're going to install the
42:22 - intellij idea ide and some drivers and
42:25 - java files for selenium framework on
42:27 - windows 10.
42:29 - so let's get started
42:31 - so open your google and type intellij
42:35 - idea ide
42:38 - the very first link that we see is the
42:41 - www.jetbrains.com so click on this link
42:45 - the intellij idea is an integrated
42:48 - development environment that is the ide
42:50 - which is written in java for developing
42:52 - the computer software
42:54 - and it was developed by the jet trains
42:57 - now apart from
42:58 - all this
42:59 - intellij idea id also has features like
43:02 - we have the built-in tools we have the
43:04 - jvm languages like java kotlin scala
43:07 - groovy
43:08 - and also it supports some of the
43:10 - frameworks like the spring java double e
43:13 - and it's supposed to mobile development
43:15 - and web development as well like the
43:17 - html css angular node.js
43:20 - so these are some of the features of
43:22 - intellij idea id
43:24 - in terms of system requirement we need a
43:27 - ram of 2gb minimum and disk space that
43:29 - we require is of 3gb of space
43:33 - and also before installing the intellij
43:36 - idea ide we have to install the jdk
43:40 - first
43:40 - so what we need to do is first
43:43 - type jdk download
43:47 - now i haven't installed the jdk
43:50 - i'll show you
43:51 - go to cmd
43:54 - and i'll type
43:55 - java
43:56 - space
43:58 - dash version
44:00 - here you can see i haven't installed my
44:02 - jdk it says that java is not recognized
44:05 - as an internal or external command or
44:08 - operable program or batch file
44:10 - i will
44:12 - run this command again after installing
44:14 - my jdk so i'll close this and
44:17 - here you see we have the www.oracle.com
44:22 - on this link
44:24 - and we have different versions of java
44:26 - jdk we have the java sc 15 we have the
44:29 - java sc 14 and we have the java s11
44:32 - we're going to download the
44:34 - latest one click on jdk download
44:42 - now uh if you have mac os if you're
44:44 - using mac os you can install
44:47 - installer you can click this one and if
44:50 - you're using windows then you can click
44:52 - this one so i'll i'm using windows
44:56 - so i click
44:58 - this file
44:59 - now here you must accept the license
45:02 - agreement for oracle java se which says
45:06 - i reviewed and accept the oracle
45:08 - technology network license agreement for
45:11 - oracle java se
45:14 - you have to simply just click on this
45:16 - check box and click
45:19 - on download jdk 15.
45:21 - so now you can see that my java jdk has
45:24 - been downloaded so all i'll need to do
45:26 - is i'll just click on this
45:29 - so click on next
45:34 - so this is the place where your java jdk
45:37 - will be saved let it be this way and
45:40 - click on next
45:44 - and here you can see that it is getting
45:45 - installed
45:46 - it will take some time so
45:48 - wait for it
45:54 - so here you can see that my java
45:57 - sc development kit 15 has been
45:59 - successfully installed
46:01 - so i'll click close
46:03 - and here i'll type
46:05 - cmd again
46:08 - just simply type java space dash
46:12 - version and here you can see java
46:15 - version 15
46:16 - java sc runtime build 15
46:20 - is been installed
46:22 - this shows that you have successfully
46:23 - installed your java jdk 15 and if
46:27 - it's not coming this way and if you type
46:28 - this command and this is not the output
46:30 - of it uh you need to go through the
46:32 - steps again and install it again
46:35 - so now we have uh installed our java jdk
46:38 - on
46:40 - on our system so we're going to set the
46:42 - environment variable simply just type
46:44 - environment variable and here you can
46:45 - see edit the system environment variable
46:48 - click on this
46:51 - here you can see environment variable
46:54 - right
46:55 - click on environment variable
47:00 - here you'll see system variables in this
47:02 - system variable window
47:04 - click on path
47:07 - and click edit
47:11 - so click on new
47:13 - and here we're going to enter the part
47:14 - how we're going to do it
47:16 - so just go on
47:19 - c drive on c drive go to program files
47:24 - and here you can see java
47:27 - go to java
47:29 - go to jdk 15 go to the bin folder and
47:33 - copy this path
47:37 - and paste it over here
47:40 - so this is going to be the new system
47:42 - environment variable
47:46 - click ok
47:48 - and click
47:50 - ok
47:53 - and click ok so you have set your
47:56 - environment variables as well
47:58 - so we can install the intellij idea ide
48:01 - now
48:04 - simply go to the official website of
48:05 - intellij idea ide
48:07 - and go to download
48:10 - here we have two versions the ultimate
48:12 - version and the community version and if
48:14 - you're using windows go to windows and
48:15 - if you're using mac then click on mac
48:17 - and if you're using linux then click on
48:18 - linux so i'm i'm using windows so i'll
48:22 - be clicking on windows and we're going
48:24 - to download the community version simply
48:26 - just click on download
48:30 - and here you can see that my intellij
48:32 - idea become ide the community version is
48:34 - getting downloaded
48:38 - so now you can see that my intellij idea
48:40 - the community version has been
48:41 - downloaded so click on this
48:44 - click on next
48:47 - click next
48:49 - so here uh create desktop
48:52 - shortcut yes for the 64-bit
48:55 - and update context menu
48:58 - i'll click add open folder as a project
49:01 - then create associations i don't want to
49:03 - create any associations for now
49:06 - then update path variable that is the
49:08 - restart needed and add launchers did to
49:11 - the path
49:14 - i click
49:15 - on this checkbox as well
49:18 - and i'll click next
49:20 - then i click on install
49:24 - and here you can see that the intellij
49:26 - idea ide the community version is
49:28 - getting installed
49:32 - and just click on finish
49:35 - so here you can see
49:38 - so here you can see that the intellij
49:40 - idea id the community version has been
49:43 - installed and i have created a
49:47 - shortcut desktop icon over here so i'll
49:50 - just click on this
49:54 - and i'll click i confirm that i have
49:56 - read and accepted the terms of this user
49:59 - agreement and i click continue
50:03 - data sharing i'll just click don't sign
50:05 - i don't want to share data sharing
50:09 - so this is the ui theme i'll click the
50:11 - light one
50:13 - go to next
50:16 - just go to next
50:20 - or next
50:23 - okay so click on new project
50:30 - here click on java
50:32 - and here you can see that we have the
50:34 - java version 15 because you have
50:36 - downloaded the jdk
50:38 - so it will be visible here and if you
50:39 - have not downloaded the jdk it will show
50:42 - that a link to download jdk like here
50:45 - you can say see over here download jdk
50:48 - so
50:48 - i have downloaded so it's showing 15
50:51 - java version 15 has been downloaded jdk
50:54 - just click on next
50:56 - uh create project from template
50:59 - click next
51:01 - so i'll just write
51:03 - hello
51:05 - world
51:15 - so let's run a program over here
51:19 - i'll simply write s out
51:23 - and
51:25 - here you can see like if i write s out a
51:27 - system out dot println so this intellij
51:31 - idea id has a very cool feature of auto
51:33 - completing it like if i write s out it's
51:35 - in system order printer n and there are
51:38 - many more shortcuts to this we will
51:40 - learn as and on we keep on programming
51:42 - we'll keep learning it
51:44 - so i'll just write
51:46 - hello
51:48 - world and i'll click on this button that
51:52 - is the run main
51:54 - click on it
51:58 - and here you can see here it's hello
52:00 - world
52:02 - so we have installed the java jdk we
52:04 - have set the variable path also and then
52:07 - we have installed the intellij idea ide
52:09 - and we executed a program and it's
52:12 - successfully executed
52:14 - so we're done with the installation of
52:17 - the jdk and the intellij idea id now we
52:20 - have to install java files and
52:23 - some of the drivers that we require for
52:25 - the browsers for the selenium framework
52:29 - so all we need to do is
52:32 - just go to the official web page of
52:34 - selenium that is the selenium hq
52:38 - here you see we have the
52:39 - www.selenium.dev
52:42 - click on this
52:44 - click on downloads
52:46 - and here we have the selenium client and
52:50 - web driver language bindings
52:53 - see to create webdriver selenium web
52:56 - driver scripts you need to make use of
52:58 - language specific client drivers
53:01 - now as we know selenium supports many
53:03 - languages like ruby java python c-sharp
53:06 - and javascript so it for
53:09 - every language we have the specific
53:11 - client drivers for ruby we have some
53:13 - client drivers for java we have some
53:15 - client drivers so we'll be using uh java
53:19 - we'll be doing selenium with java so
53:22 - here you can see we have a stable
53:23 - version for java is 3.141.59
53:28 - the latest release that we have the
53:30 - alpha release for
53:31 - i have discussed about the selenium
53:33 - versions also in the previous tutorials
53:35 - so you can check out that
53:37 - so we're going to do with java selenium
53:39 - with java so simply click on download
53:43 - so here you can see we have this zip
53:45 - file of selenium java i'm going to
53:48 - extract it
53:56 - and here we have the executable jar
53:58 - files
53:59 - so it is recommended that
54:02 - you create a separate folder for the
54:05 - selenium jar files and the drivers so
54:08 - i'll be creating a separate folder of
54:10 - jar files and drivers just created on
54:13 - any drive like c drive or d drive or
54:15 - somewhere because we're going to
54:17 - download many jar files and many drivers
54:20 - so
54:21 - locating them and it will be placed in
54:24 - somewhere and then locating them and
54:26 - finding them at that point of time will
54:28 - be very hard so just simply make a
54:31 - folder over here
54:33 - i'll be naming selenium jars and drivers
54:37 - a folder in selenium jars and drivers
54:39 - i'll name it jars
54:43 - and i'll create a separate folder also
54:45 - name it drivers
54:48 - and in drivers we're going to install
54:50 - the chrome driver and the firefox driver
54:52 - so we'll make the folders for that as
54:54 - well
54:56 - let's make things very systematic
54:57 - because if you don't do it then it will
54:59 - be very
55:01 - problematic
55:03 - so these this way we have created a new
55:06 - folder in rd drive that is the selenium
55:09 - jars and drivers so we have downloaded
55:11 - jar files let's check that out
55:16 - we have the first two java files over
55:18 - here we're gonna copy it
55:20 - and place it over here
55:25 - then again over here go to libs
55:29 - and we have the jar files here also so
55:32 - we're going to copy it here
55:37 - and here it is
55:39 - so we're going to add these java files
55:41 - now to our
55:43 - id so just create a new
55:46 - project
55:48 - for selenium
55:52 - java next
55:55 - next i'll name it as
55:58 - selenium
56:02 - i'll change the package name to selenium
56:07 - and i'll click
56:14 - finish so here it is
56:18 - now we're going to add the jar files
56:19 - that we have downloaded simply go on
56:22 - file
56:23 - go to project structure
56:28 - must accept okay just click on accept
56:31 - and go to modules
56:34 - here
56:35 - you can see dependency tab called
56:37 - dependency
56:39 - and here you can see there's a plus sign
56:41 - right so click on this plus sign and
56:43 - here you see jars or directories click
56:46 - on jars or directories
56:50 - go to the
56:51 - drive where you have created your folder
56:54 - i've created a d drive and i have named
56:57 - as selenium jars and drivers
57:00 - for jars and select all those jars that
57:03 - you have downloaded
57:07 - and simply just click ok
57:11 - so here you can see that i have added my
57:13 - java file over here so just click on
57:15 - apply
57:17 - click ok
57:18 - so here you can see that
57:21 - i can see all my java files over here in
57:23 - external libraries
57:26 - okay
57:27 - so we have added the java files also so
57:30 - now
57:32 - let's download the drivers
57:35 - so what i need to do is
57:37 - same on selenium hq just go down and
57:40 - here you can see platforms supported by
57:43 - selenium
57:44 - browsers click on browsers and for
57:47 - different browsers we have different
57:48 - drivers like for firefox we have the
57:50 - gecko driver for internet expert we have
57:53 - the internet explorer driver for safari
57:54 - we have a safari driver for chrome we
57:57 - have the chrome driver so basically we
57:59 - will perform all our test cases in
58:02 - chrome driver we're going to launch the
58:04 - chrome driver frequently
58:06 - but in the next tutorial i will explain
58:09 - how to launch drivers like the firefox
58:11 - driver the chrome driver
58:13 - so for that we need to download the
58:15 - drivers for it
58:17 - so all we need to do is just click on
58:19 - documentation over here
58:23 - and here you can see
58:26 - the latest better version that we have
58:28 - is the chrome driver 86 and the stable
58:31 - version that we have the 85 now see over
58:34 - here you need to check your chrome
58:37 - browser version first so what you need
58:40 - to do is go on settings
58:42 - and
58:45 - go to about chrome
58:47 - and here you can see your version it's
58:49 - version 85 and if it is not updated then
58:52 - please update it and then download your
58:55 - driver
58:56 - because your driver version and your
58:58 - google browser this chrome browser
59:01 - should match and if it's not matching
59:03 - and then your browser will not be
59:05 - launched
59:07 - so here i have the stable version that
59:10 - is the 85 version so i'll be clicking
59:12 - over here
59:15 - and here you can see
59:17 - this page if you have linux click over
59:19 - here if you have mac click on this link
59:22 - and if you have windows then click on
59:23 - this link i'm having windows so i'll be
59:25 - clicking
59:26 - on this link
59:28 - here you can see this is the chrome
59:30 - driver this is the zip file i will
59:32 - extract it
59:35 - i have the exe file over here
59:39 - copy this file and paste it in the
59:41 - folder that you have created
59:45 - in chrome driver
59:47 - same way we're going to download the
59:49 - firefox driver
59:52 - go to documentation
59:57 - here we have different versions of gecko
59:59 - world driver so what you're going to do
60:01 - is just go to firefox
60:04 - and check out the version that you have
60:09 - simply go on settings
60:11 - or general
60:14 - and here you will see that you your
60:17 - updated version that is the version 81
60:19 - i'm having 81.0.1
60:22 - so my firefox is updated so i'm going to
60:24 - download the version 81.
60:29 - just go on gecko driver release
60:36 - and here you will see the driver
60:38 - versions
60:39 - now i'm having windows 64 64-bit so i'll
60:42 - be clicking this and if you have mac
60:43 - then click this and if you have linux so
60:46 - depending upon your operating system
60:47 - just click
60:49 - so here you can see we have the gecko
60:51 - driver it's a zip folder so we're going
60:53 - to extract files
60:58 - and here you can see it is an exe
61:01 - application we're going to simply copy
61:03 - it and
61:05 - paste it to the folder where you have
61:07 - created your
61:08 - drivers folder in firefox driver
61:11 - so today we are going to understand uh
61:13 - many topics like first we are going to
61:15 - create two sets of test cases
61:18 - we will learn how to launch the browser
61:21 - next we will learn how to navigate to a
61:23 - particular url we will understand the
61:25 - hierarchy of the interfaces and the
61:28 - classes in the selenium web driver also
61:30 - we will understand a particular command
61:32 - that is the chrome driver driver is
61:34 - equal to new chrome driver why is it not
61:36 - called the best practice okay
61:39 - so let's get started
61:41 - so as we know before automating any test
61:43 - script we have to prepare manual test
61:46 - cases first so first we will create two
61:48 - sets of test cases over here
61:51 - so the first set
61:54 - in the first set we will have three test
61:56 - cases
61:57 - the first test case is
61:59 - open
62:01 - the
62:02 - chrome
62:04 - browser
62:05 - or to launch the chrome browser now
62:07 - whenever we create the manual test cases
62:09 - to open the browser or to launch a
62:11 - browser is the first test case it's
62:13 - always the first test case okay
62:16 - next we're going to navigate
62:19 - navigate to
62:21 - the url
62:24 - that is the www.google.com
62:31 - third the third command is close the
62:35 - browser
62:36 - so these are the three test cases that
62:39 - we're going to execute one is the open
62:41 - the chrome browser that we're going to
62:42 - launch the chrome browser next we're
62:44 - going to navigate to the url
62:46 - www.google.com
62:48 - and the third we're going to close the
62:49 - browser
62:50 - that we are opening okay
62:53 - this is the first set in the second set
62:56 - we're going to launch the firefox
62:59 - browser
63:00 - open the
63:01 - firefox
63:03 - browser
63:06 - next
63:07 - we're going to navigate
63:09 - to the
63:11 - url
63:12 - that is the
63:14 - ww dot
63:18 - next is
63:19 - we're going to close the
63:21 - browser that is the firefox browser
63:24 - okay
63:25 - these are the two sets of test cases
63:29 - that we have prepared and we're going to
63:31 - execute these test cases today
63:34 - as we know uh that the selenium supports
63:36 - many browsers like the firefox browser
63:38 - the chrome browser the internet explorer
63:40 - browser safari browser
63:42 - as we have installed the exe file of the
63:45 - chrome driver and the firefox driver
63:47 - that we have uh installed in the
63:49 - previous lecture so we are going to uh
63:52 - launch the chrome driver and the firefox
63:54 - driver and since the process is very
63:56 - similar so once you understand how to
63:58 - launch a particular browser you can
64:00 - launch any other browser according to
64:02 - your requirement
64:03 - okay
64:05 - open intellij idea ide
64:08 - so in the previous tutorial we had
64:11 - included our jar files in a selenium
64:14 - project we had created a selenium
64:16 - project we included a jar files in that
64:18 - so we're going to continue in that
64:19 - project itself
64:21 - so yeah
64:23 - as we
64:24 - know yeah we have created two sets of
64:27 - test cases uh
64:29 - we are going to execute it how we gonna
64:31 - do that
64:33 - first thing
64:34 - we know for chrome browser
64:38 - the driver that we require is the chrome
64:42 - driver
64:43 - right that we have installed in our
64:45 - computers we have installed the chrome
64:47 - driver and the firefox driver so first
64:49 - we will execute for the chrome driver
64:51 - and then i will execute the test cases
64:54 - for the firefox driver
64:56 - okay for the chrome browser we require
64:58 - the chrome driver
65:00 - so now what we're going to do first the
65:03 - very first step that we are having is
65:05 - the
65:06 - open the
65:08 - chrome
65:10 - browser this is the first step right so
65:12 - how we're going to do that first thing
65:14 - we're going to create the object of
65:17 - chrome
65:19 - chrome driver
65:21 - okay we're going to create the object of
65:23 - chrome driver
65:24 - but how do we refer this chrome driver
65:27 - object we need to understand the
65:29 - hierarchy
65:31 - of the selenium webdriver which has the
65:32 - classes and the interfaces so let's
65:35 - understand that first
65:38 - so this is the diagram that we are
65:40 - having
65:41 - the selenium provides my number of
65:43 - classes and the interfaces and we need
65:45 - to understand the hierarchy of classes
65:47 - and interfaces
65:49 - now to understand this hierarchy we need
65:50 - to have a knowledge about the interfaces
65:52 - and the inheritance concept of java
65:56 - now here here you can see this diagram
65:58 - right uh in selenium web driver the
66:01 - search context the very first interface
66:04 - these yellow boxes are interfaces and
66:06 - the green boxes are the classes okay
66:10 - so this yellow box search context
66:13 - this is the super interface of the web
66:16 - driver and it contains only two methods
66:18 - that is the find element and the fine
66:20 - elements
66:21 - yes these two methods are different it
66:24 - is not just about a s in find elements
66:27 - they are different they are used to find
66:29 - the element on our web page the web
66:32 - elements that we have that is the text
66:34 - box the drop down menu
66:36 - they uh these commands help to find the
66:39 - web elements on the web page
66:41 - so we will understand that when we
66:43 - practically implement the test cases but
66:45 - for now let us understand that the
66:47 - search context this search context that
66:50 - we have is the super interface and is an
66:53 - interface that contains abstract methods
66:56 - now what are these abstract methods
66:59 - these methods are the these abstract
67:01 - methods are the methods that has no
67:04 - implementation they have only definition
67:06 - there is no implementation of abstract
67:08 - methods they just have the definition
67:11 - okay so this is the search context that
67:13 - is the super interface which has the
67:15 - abstract method find element and the
67:16 - find elements
67:18 - next we have the web driver interface
67:21 - okay the web driver interface which is
67:23 - extended from the search context okay it
67:26 - is extended from the search context this
67:29 - means
67:30 - that it contains the methods the
67:32 - abstract methods of
67:35 - find element and find elements method is
67:37 - also in the web driver apart from this
67:40 - it also has the other methods like the
67:42 - get method the quit method close get
67:45 - window handles and many other methods
67:47 - okay
67:48 - so the all these are abstract methods
67:50 - that has only body and there is no
67:52 - implementation okay
67:54 - and so these are the uh topmost root uh
67:57 - interface apart from all apart from this
68:00 - the web driver also has the nested
68:03 - interface okay it also has some nested
68:06 - interfaces like which has windows
68:08 - navigation target locator timers option
68:10 - these are also abstract methods through
68:12 - these methods the through these
68:14 - interfaces we can perform various uh
68:17 - operations like navigating to the url
68:20 - maximizing the window and many more okay
68:23 - so the uh the web driver also includes
68:24 - the nested interfaces
68:26 - next
68:27 - we have the remote web driver this is a
68:30 - fully implemented class
68:32 - okay which implements the interface web
68:36 - driver here you can see it implements
68:39 - the web driver interface okay
68:42 - now this web driver or remote web driver
68:45 - this remote web driver is a fully
68:47 - implemented class here you can see it's
68:49 - a fully implemented class where all the
68:52 - abstract methods coming from the search
68:55 - context
68:56 - coming from the search context and the
68:59 - web driver are implemented in this
69:02 - particular class because obviously when
69:04 - we create abstract classes right so
69:07 - these uh when we create abstract methods
69:09 - we have to use those methods we just you
69:11 - just don't have to keep it you will use
69:13 - it that is why there is no
69:15 - implementation and only definition in it
69:18 - as i said your core java knowledge will
69:22 - be required over here to understand this
69:24 - hierarchy so that is why we
69:27 - need to have the knowledge of
69:28 - inheritance and uh
69:30 - interface faces of core java so the
69:34 - remote web driver yeah so the remote web
69:36 - driver contains methods of the search
69:38 - context and the web driver in addition
69:41 - also it implements a javascript executor
69:43 - and takes screenshot
69:46 - okay so it uh implements these
69:48 - interfaces also which has abstract
69:50 - methods on its own and we will we can
69:53 - implement those extract extract methods
69:56 - so to the conclusion we can say that the
69:58 - remote webdriver is a fully implemented
70:00 - class which contains the abstract
70:03 - methods of the web driver interface and
70:05 - the search context interface and it
70:07 - takes screenshot
70:09 - interface and the javascript executor
70:13 - okay
70:14 - so this is about the remote web driver
70:17 - now here you can see these classes these
70:19 - classes are the
70:21 - uh
70:22 - browsers that we have of selenium
70:24 - selenium supports many browsers you know
70:26 - right the firefox browser the internet
70:28 - explorer browser the edge browser safari
70:30 - browser
70:32 - so the remote web driver it extends
70:33 - these classes and here you can see these
70:35 - classes are the web browsers that we
70:37 - have that is the firefox browser
70:39 - internet explorer browsers
70:41 - okay
70:42 - so now uh there are various versions of
70:44 - selenium as i told in the previous
70:46 - tutorial from fourth version here you
70:48 - can see this is the chromium driver and
70:50 - chrome driver right from the four fourth
70:51 - version the chrome driver extends the
70:53 - chromium driver this has happened from
70:56 - the fourth version they had made some
70:57 - changes they had included a chromium
70:59 - driver also which uh
71:02 - through which the chrome driver will get
71:03 - extended
71:04 - so these were the changes in the fourth
71:06 - uh
71:07 - release of selenium
71:09 - so this is the hierarchy of selenium
71:11 - cluster interface in which we have the
71:14 - uh super interface that is the search
71:16 - context then we have the web driver
71:18 - interface which has which includes uh
71:21 - nested interfaces also which has many
71:23 - abstract methods like windows navigation
71:25 - target locator timeouts options
71:28 - then we have the remote web driver which
71:31 - implements the
71:31 - [Music]
71:33 - interface webdriver
71:35 - and it also
71:36 - implements the javascript executor and
71:39 - the take screenshot
71:40 - interface next we have the um
71:44 - next we have the browsers these are the
71:45 - browsers which is supported by the
71:47 - selenium and the remote web driver
71:50 - extend these classes these are classes
71:53 - okay remember the remote web driver and
71:55 - these browser are the classes whereas
71:57 - the search context web driver nested
72:00 - interfaces take screenshot and
72:02 - javascript executor are the interfaces
72:06 - okay this so this is the complete
72:07 - hierarchy of the selenium class and the
72:09 - interface
72:11 - so now
72:12 - let's move to the
72:14 - program
72:16 - so now over here uh for opening the
72:19 - chrome browser the first thing that we
72:20 - did over here is we created a object of
72:23 - chrome driver right now how do we refer
72:26 - this object
72:27 - here
72:28 - in the
72:29 - so remember this chrome driver is a
72:31 - class
72:32 - right as we as shown
72:35 - in the hierarchy it is a class
72:38 - now here
72:39 - just refer to this hierarchy again and
72:41 - here we can see that the web driver
72:44 - is the parent interface
72:48 - here you can see that the web driver is
72:50 - the parent interface and now you must be
72:52 - saying no the remote driver
72:54 - the remote web driver is the parent but
72:57 - whatever talking about i'm talking about
72:58 - the interface focus on what i'm saying
73:00 - i'm talking about interface the web
73:02 - driver is the parent interface and the
73:05 - remote web driver is a class okay
73:07 - remote web driver is a class and the web
73:09 - driver is an interface so your the
73:11 - parent interface will be web driver
73:14 - so the web driver interface will give a
73:16 - reference to the chrome driver how i'm
73:18 - going to write webdriver
73:21 - i will give a reference like driver is
73:24 - equal to new chrome driver
73:27 - so now uh your in this command
73:30 - web driver driver is equal to new chrome
73:32 - driver we are using uh the dynamic
73:34 - polymorphism concept
73:36 - in which the child class object child
73:38 - loss object that is the chrome driver
73:40 - is referred by the parent interface that
73:43 - is the web driver through a reference
73:45 - variable and that reference variable is
73:48 - called as driver
73:49 - okay
73:51 - so this is how
73:53 - we are opening the chrome browser so
73:54 - let's run this command first
74:03 - so
74:05 - our chrome browser is not launched why
74:07 - let's see
74:09 - here it shows an error which says
74:11 - illegal state except exception
74:15 - which says the path to the driver
74:17 - executable must be set by the
74:21 - webdriver.chrome.driver system property
74:24 - okay this is your error the path to the
74:28 - driver executable must be set by the web
74:31 - driver
74:32 - dot chrome dot driver system property
74:36 - so here it says that i have to define a
74:38 - property
74:39 - a system property and to define this
74:41 - system property we have a system class
74:45 - so i will write
74:47 - system
74:49 - dot
74:50 - set property
74:52 - now this set property command has
74:54 - two values need to be entered over here
74:57 - uh one is the string key and is the
74:59 - string value
75:01 - in the string key what we have to enter
75:03 - it's given over here itself
75:05 - webdriver.chrome.driver we will simply
75:07 - copy this
75:08 - and paste it over here this is your
75:10 - string key
75:12 - whereas the value will be the part where
75:15 - your executable file is saved that is
75:18 - the chrome driver
75:19 - so in my case i'll go to
75:22 - d drive syrian jars and drivers
75:25 - drivers and the chrome driver because
75:27 - we're launching the chrome driver so i
75:29 - will simply just copy this part
75:33 - and i will paste it over you
75:37 - change the slashes
75:40 - okay and we're gonna include our file
75:42 - name over here
75:44 - our file name is
75:46 - chrome driver
75:48 - okay
75:49 - so we're gonna write chrome driver
75:52 - dot exe now if you're using mac you
75:55 - don't need to write exe because mac does
75:57 - not support exe files so there's no
75:59 - requirement to write exe but if you're
76:02 - using windows then you're going to write
76:03 - exe
76:04 - okay we're going to execute this
76:08 - statement now so here you can see
76:11 - my chrome browser is launched you can
76:14 - see this chrome browser it is launched
76:16 - which says chrome is being controlled by
76:18 - automated test software now this chrome
76:21 - browser
76:22 - and this chrome browser the
76:25 - original chrome browser these two chrome
76:27 - browsers are different here we cannot
76:28 - see any tab which shows that chrome
76:30 - browser is being controlled but over
76:32 - here you can see chrome is being
76:35 - controlled by automated test software
76:37 - there's a tab over here
76:39 - okay so this is the difference between
76:40 - the uh
76:42 - chrome browser that we are launching
76:44 - through automation and the chrome
76:45 - browser that we have originally on our
76:48 - computers
76:50 - so i'll just close this
76:53 - so we have launched the chrome browser
76:56 - and yes
76:57 - one important question
77:00 - that you must be thinking is uh by
77:01 - looking at this uh
77:04 - diagram now over here you must be
77:06 - thinking as i said that the parent
77:08 - interface is the web driver but
77:11 - you're the super parent interface that
77:13 - is the search context is also there so
77:16 - why are we not writing
77:18 - a search
77:20 - context
77:21 - driver
77:22 - like i'll just write
77:25 - driver1
77:27 - equal to new
77:29 - chrome driver now this command is also
77:32 - correct i'm not saying that this command
77:33 - is wrong but why are we not writing
77:36 - search context driver is equal to new
77:37 - chrome driver and why are we writing web
77:39 - driver driver is equal to new chrome
77:41 - driver
77:42 - the reason behind this is refer add this
77:45 - diagram again
77:46 - here i have uh told before that the
77:48 - search context interface contains only
77:51 - two methods that is the find element and
77:53 - the fine elements
77:54 - so if we are writing search context
77:56 - driver 1 is equal to new chrome driver
77:58 - it will only have
78:01 - two abstract classes or sorry two
78:04 - abstract methods that is the
78:06 - find element and the fine elements
78:08 - whereas if i'm writing web driver it has
78:10 - all those methods like the fine element
78:12 - and the fine elements also and all the
78:15 - web driver methods as well so that is
78:17 - the reason why we are writing web driver
78:19 - driver is equal to new chrome driver
78:21 - okay
78:22 - so now the next question that you must
78:24 - be thinking is okay we are fine with the
78:26 - search context we are not uh there's no
78:29 - advantage in writing search context
78:30 - because it will have only two methods
78:32 - included in it uh that is a find element
78:35 - in the find elements so why not remote
78:40 - why not remote web driver
78:42 - like we can write remote web driver
78:44 - driver
78:45 - sequel to new
78:47 - chrome driver this is also possible
78:51 - but the reason behind why we're not
78:53 - writing remote webdriver is because the
78:56 - remote webdriver mechanism the
78:58 - architecture of the remote web driver is
79:00 - very different from the web driver here
79:02 - there are two reasons okay if we want to
79:04 - use this approach the remote web driver
79:06 - driver 3 is equal to new chrome driver
79:09 - if you're using this approach
79:11 - then
79:13 - this approach is only accessible when we
79:15 - want to access in remote location see
79:17 - here the remote web driver works very
79:19 - different from the web driver and it
79:21 - also the remote web driver is a class
79:24 - always remember there's a difference
79:25 - between a class and an interface okay
79:27 - so class
79:29 - and it contains methods which
79:31 - shows that which what action is to be
79:34 - performed that is remote web driver
79:36 - whereas interface it contains the
79:38 - abstract method so the remote web driver
79:42 - is not serving as advantages as the web
79:45 - driver that we have included over here
79:46 - so it is the best practice is to include
79:49 - the web driver driver is equal to new
79:51 - chrome driver
79:53 - okay so i'll delete this
79:55 - command
79:57 - and yeah through system.set property
80:00 - uh we have a key value we have entered
80:04 - the string value over here that is the
80:05 - webdriver.chrome.driver
80:07 - and here we have entered the path of our
80:10 - executable chrome driver next we have
80:12 - written web driver driver is equal to
80:15 - new chrome driver
80:17 - through these two steps
80:18 - the chrome browser is launched now
80:20 - remember these two steps are common for
80:22 - all the test cases we are going to write
80:23 - because in every test case we are going
80:25 - to launch a browser so these two steps
80:27 - are going to be similar
80:29 - okay
80:30 - so the next test case the next test case
80:33 - that we have is
80:34 - navigate to the
80:37 - url okay
80:39 - how are you going to do that now we have
80:41 - driver as a reference variable we're
80:42 - going to write driver dot
80:44 - get
80:46 - and we're going to include the
80:49 - site where we want to navigate that is
80:52 - www.google.com
80:56 - this is the site i want to navigate to
80:58 - i'm going to run this command
81:08 - the chrome browser is launched but
81:11 - it has not navigated to
81:13 - the url why let's see
81:17 - so here it says chrome browser chrome
81:19 - driver was started successfully and here
81:22 - it says
81:24 - invalid argument exception there is
81:26 - invalid argument why
81:28 - let me tell you here when we write the
81:30 - url you need to write the complete url
81:33 - which includes https
81:35 - colon and slash
81:38 - now let's see
81:44 - so our chrome browser is launched and
81:47 - here it is it is navigated to the url
81:49 - that is the
81:50 - google.com okay
81:53 - i'll just close this
81:55 - i'll close this as well okay
81:59 - so now you have understood to navigate
82:01 - your url we will write driver dot get
82:03 - the get command is used to navigate to
82:06 - the url okay
82:09 - so the third test case
82:13 - is to close the
82:15 - browser
82:18 - how are we going to do that we're going
82:19 - to simply write driver
82:21 - dot
82:22 - close
82:26 - the close command is used to close the
82:28 - browser
82:31 - save it and
82:33 - run
82:37 - so your our chrome browser is launched
82:39 - and it is navigated to the url and it is
82:42 - closed
82:43 - see it happens very fast
82:46 - but uh yeah this is the process like we
82:49 - have launched the chrome browser we have
82:51 - navigated to the url and we have closed
82:53 - the browser
82:55 - to navigate the url we are using the get
82:57 - command and to close the browser we are
82:59 - using the close command
83:02 - so these were the steps to launch the
83:04 - browser to navigate to the url and to
83:06 - close the browser
83:07 - now let's execute the
83:09 - second test set
83:11 - which has the firefox browser which in
83:14 - which we have to launch the firefox
83:16 - browser so i'll comment all these
83:18 - and we're going to
83:21 - launch the firefox first okay there is
83:23 - no harm if we write both the browsers
83:26 - there's no harm it will execute the
83:28 - chrome browser first and then it will
83:30 - execute the firefox browser first we
83:31 - will do that also but first let us
83:33 - execute this particularly okay
83:36 - so in the next set of test cases
83:40 - here it is we have open the firefox
83:42 - browser navigate to the url and close
83:44 - the browser the only difference is that
83:46 - we are working with the firefox browser
83:47 - over here okay and over here we were
83:49 - working with the chrome browser
83:52 - so let's start
83:53 - first thing
83:55 - the first test case which says that we
83:58 - have to open the
84:00 - firefox browser
84:04 - okay so how we're going to do that
84:06 - obviously we're going to write system
84:07 - dot
84:08 - set property
84:10 - which is having two string values one is
84:12 - key and one is the
84:15 - value okay so over here you can see
84:18 - over here
84:20 - the key value is webdriver.chrome.driver
84:23 - so here it's going to be a web driver
84:26 - dot getco
84:28 - gecko is the driver name for the firefox
84:31 - browser
84:33 - dot
84:34 - driver
84:35 - okay
84:36 - this is the key
84:39 - now we will enter the value how we're
84:41 - going to do that we're going to go to
84:43 - the path where our
84:46 - firefox
84:47 - driver is saved
84:49 - here it is
84:51 - i'm going to copy this path
84:55 - i'm going to simply paste it over here
84:58 - we will
84:59 - change the slashes
85:01 - and we are going to include the
85:04 - file name
85:07 - so our file name is getco driver
85:11 - gecko
85:13 - driver
85:14 - dot exe
85:16 - okay
85:18 - and
85:19 - next command our next command is that
85:21 - we're going to create an object of
85:24 - firefox first and how we're going to
85:26 - refer it we are going to refer it by the
85:28 - web driver interface
85:31 - web driver
85:33 - driver
85:34 - is equal to new firefox
85:37 - okay
85:39 - next
85:40 - we need to navigate to the url how we're
85:42 - gonna do that
85:44 - navigate
85:46 - to
85:47 - the url
85:49 - we're gonna simply write
85:51 - driver
85:53 - dot get
85:56 - https we need to write https
86:00 - colon
86:02 - www.google.com
86:07 - okay
86:09 - now the third command
86:11 - is to
86:12 - close the
86:14 - browser how we're gonna do it we simply
86:16 - write driver
86:18 - dot close
86:20 - okay so let's
86:23 - launch it
86:24 - let's run this program we'll click on
86:26 - this
86:32 - and here it is our firefox is launched
86:35 - it is navigated and
86:37 - it's closed yes
86:39 - so as i said there's no harm like simply
86:42 - i will
86:44 - uncomment all
86:48 - these i'll
86:51 - name this as driver one
86:53 - driver one and driver one
86:57 - okay so let's execute this
87:00 - statement it will open the chrome driver
87:02 - first
87:06 - yes it is opening the chrome driver
87:07 - first it is navigating and it is closing
87:10 - now our firefox will be opened yes
87:14 - it is navigating and it is
87:16 - closed so there is no harm if you are
87:19 - including two browsers in one program
87:21 - there is no harm in that okay just
87:23 - change the reference variable your i
87:24 - have changed the reference variable to
87:26 - driver 1 and driver
87:28 - now since we have executed these two
87:30 - sets of test cases
87:32 - now let me explain you this command now
87:34 - here we have written web driver driver
87:36 - is equal to new firefox driver
87:38 - we can also write
87:40 - firefox
87:42 - driver
87:44 - dr1 is equal to new
87:47 - firefox driver
87:48 - this command
87:49 - is also valid okay it's there's no harm
87:52 - in writing firefox driver dr1 is equal
87:54 - to new firefox driver
87:56 - but what are the disadvantages behind
87:59 - this
88:00 - statement i'll tell you
88:02 - now see when you're working in an
88:03 - organization you are working
88:06 - with many people you will be having at
88:08 - least 500 number of test case cases and
88:11 - out of which 250 test cases are need to
88:13 - be automated so there are large number
88:15 - of test cases which are need to be
88:16 - automated in that you will be supporting
88:18 - the cross browser testing
88:21 - so
88:21 - you have to simultaneously uh
88:24 - run a multiple browsers at the same time
88:27 - okay and then a large number of test
88:29 - cases now see the advantage behind
88:31 - writing webdriver driver is equal to new
88:33 - firefox driver your you are not stick to
88:36 - one browser
88:38 - you can
88:40 - execute multiple browsers this way but
88:42 - whereas if we write firefox driver
88:44 - driver one is equal to a new firefox
88:46 - driver here we are stick to one driver
88:49 - it is um we are specific towards the
88:52 - driver that is the firefox driver here
88:54 - if you want to change to chrome driver
88:55 - it will be you have to write chrome
88:57 - driver
89:00 - dr2 is equal to
89:02 - new
89:03 - this is what you have to write if you
89:05 - want to change to chrome driver and you
89:06 - have to
89:07 - comment this line and even have you have
89:10 - to change there will be many other
89:12 - changes also in the program because of a
89:14 - driver okay so this thing is very
89:18 - harmful it is not a good practice of
89:20 - writing this command that is the firefox
89:22 - driver
89:23 - driver is equal to new firefox driver
89:25 - whereas when if you if you're working
89:27 - with this and there is a situation where
89:29 - you have to change to chrome driver you
89:32 - have to simply just change over your
89:35 - chrome driver
89:37 - you will just write chrome driver
89:39 - and your entire program will be
89:42 - launched through a chrome driver okay so
89:45 - this is the difference between the web
89:47 - driver driver is equal to new chrome
89:49 - driver and the chrome driver driver is
89:51 - equal to new chrome driver these are the
89:53 - problems that we are facing if you are
89:55 - writing chrome driver driver is equal to
89:57 - new chrome driver that is the program is
89:59 - specific towards the chrome driver
90:01 - whereas if you are writing web driver
90:03 - driver is equal to new chrome driver it
90:05 - is not specific to us a particular
90:07 - browser okay
90:09 - so let's first rely revise what have we
90:12 - uh understood in this tutorial
90:16 - so what did we learn the first thing
90:17 - that we learnt is to launch the browser
90:20 - in case of chrome browser how did we do
90:23 - first we uh
90:24 - set the property to a system class that
90:26 - is a system.set property in which we are
90:29 - having two string
90:31 - we need to enter two string values that
90:33 - is the string key and the string value
90:35 - in case of chrome driver the string key
90:37 - is the webdriver chrome driver whereas
90:40 - the string value will be the path where
90:43 - our executable file is saved
90:46 - the next statement is that we're going
90:48 - to write web driver driver is equal to
90:50 - new chrome driver through these commands
90:52 - it will launch the chrome browser
90:55 - now in case of firefox browser same we
90:57 - are going to write system.set property
90:59 - but the key value will change that is
91:01 - the webdriver.getcode.driver
91:04 - and also the path where our firefox
91:06 - driver is placed that will also change
91:09 - okay then the next command will be web
91:11 - driver driver is equal to new firefox
91:13 - driver through this command we are
91:17 - launching our firefox browser
91:19 - next we learned how to navigate to a
91:21 - particular url simply we will use driver
91:24 - dot get command the get command is used
91:26 - to navigate to a particular url we have
91:29 - to include the https uh all the website
91:32 - any any url you are entering over here
91:34 - you have to entire the you have to enter
91:37 - the full url the entire url including
91:40 - the https okay
91:42 - then to close the browser we learned how
91:44 - to close the browser that is we are
91:45 - using the close command that is a
91:47 - driver.close command
91:49 - so the next thing
91:50 - the next thing that we learned is about
91:52 - the hierarchy of the classes and the
91:54 - interfaces
91:55 - that is we learned first thing about the
91:58 - search context it is a super interface
92:00 - of the web driver and it has only two
92:03 - methods that is the fine element and the
92:05 - find elements
92:07 - next we learned that the web driver is
92:09 - an interface which extends the search
92:11 - context interface and the web driver has
92:14 - methods like the get method the get
92:16 - title get current url close quit etc
92:20 - that has many methods and also it
92:22 - has the nested interfaces also then the
92:26 - remote web driver is a fully implemented
92:28 - class which implements the web driver
92:30 - interface
92:31 - okay
92:32 - then we have the chrome driver the
92:34 - internet explorer driver the firefox
92:35 - driver opera safari driver all these are
92:38 - child classes of the remote webdriver
92:40 - class and they provide the browser
92:42 - specific implementation of the selenium
92:44 - webdriver
92:46 - so these are the hierarchy of the
92:47 - classes and the interfaces of the
92:49 - selenium webdriver
92:51 - next next we learned that what are the
92:54 - this is this this ppt shows that what
92:56 - are the valid statements that we can
92:58 - write through uh creating an object of
93:00 - chrome driver and how can we refer it
93:03 - now writing web driver driver is equal
93:05 - to new web driver this command is wrong
93:08 - okay this command is wrong
93:10 - we can write web driver driver is equal
93:13 - to new chrome driver new firefox driver
93:15 - new internet explorer driver this is the
93:17 - best practice in industry level we use
93:20 - the web driver driver is equal to new
93:21 - chrome driver this command is frequently
93:24 - cut this command is only used because uh
93:28 - writing this command firefox driver
93:30 - through this it is the program the
93:32 - script that you're writing is specific
93:34 - towards a firefox only it is launching
93:36 - it will launch only the firefox browser
93:38 - whereas over here also it will launch
93:40 - only the firefox driver but there's a
93:42 - situation where you have to change the
93:44 - driver they will they might say that the
93:46 - company says that you have to launch the
93:48 - chrome browser
93:49 - launch the entire test script in the
93:51 - chrome browser so what you're going to
93:52 - do is you just have to simply change
93:54 - over here to chrome driver and you're
93:56 - done but whereas if you're uh writing
93:59 - firefox driver you have to change the
94:01 - entire statement and there will be other
94:03 - statements also that you have to change
94:05 - okay
94:06 - so the best practice is the web driver
94:08 - practice web driver driver is equal to
94:10 - new firefox driver but whereas if you
94:12 - write chrome driver driver is equal to
94:14 - new chrome driver there's no harm in it
94:16 - but the best practice is to write the
94:17 - web driver
94:20 - so this is all for today
94:21 - so in this tutorial we will understand
94:24 - what are web elements what are the
94:26 - different types of web elements we will
94:28 - understand the locators and its types
94:30 - also we will understand the difference
94:31 - between find elements and find element
94:34 - method
94:35 - so let's get started
94:39 - first thing what is web element
94:42 - now anything that is present on the web
94:44 - page is called as a web element for
94:46 - example the text box is a drop down menu
94:48 - the radio button anything that is
94:50 - present on the web page is known as a
94:52 - web element
94:53 - let me show you this site for example
95:00 - for example this is the web page now
95:03 - anything that is present on this web
95:04 - page anything that is this search bar
95:07 - these uh
95:09 - my account link this more link this cart
95:11 - link the search icon anything that is
95:14 - present over here is a web element we
95:17 - have to inspect all these elements like
95:19 - over here if you want to send any
95:21 - command if you want to send any text
95:23 - message on the search bar how are we
95:25 - going to do that we're going to inspect
95:27 - the elements so all these are known as
95:29 - web elements
95:33 - now web elements are basically of two
95:35 - types one is single element the second
95:38 - is the group elements
95:41 - now single element
95:42 - this is the registration page here you
95:44 - can see
95:46 - here you can see these text boxes right
95:48 - so these are single elements why because
95:51 - of we can easily find out a locator to
95:54 - work with this for example we can find
95:56 - it through id we can find out through
95:58 - name so these are the different types of
96:00 - locators that will be used to uh inspect
96:03 - these elements these text boxes this
96:05 - radio button
96:06 - but
96:07 - i'm explaining here what are the
96:08 - different types of web elements so there
96:10 - are two one is the single element the
96:11 - second is the group element single
96:13 - elements are the text boxes because we
96:15 - can identify them very easily through
96:18 - locators through name through class name
96:20 - whereas the drop down menu they are
96:22 - known as group elements because
96:24 - here to identify the drop down menu we
96:27 - will use a locator as well as that we
96:30 - will use a combination of a value or
96:32 - index property now what is this value or
96:34 - index property when we understand how to
96:37 - uh inspect the drop down menu at that
96:40 - time we will come to know that what are
96:41 - the different types of
96:43 - commands that is used to inspect the
96:45 - drop down menu so there is a reason why
96:47 - it is called as a group element
96:50 - so next we have locators now what are
96:52 - locators locators are the way to
96:54 - identify and web element
96:57 - anything that is present on a web page
96:58 - is called as a web element right so how
97:00 - do we identify it for example
97:03 - here you can see right this search box
97:06 - how will you identify the search box how
97:08 - will you send commands to the search box
97:10 - how will you uh click on this icon on
97:12 - the search icon how will you do that for
97:14 - that you need to inspect these elements
97:16 - for that you need to locate these
97:17 - elements so how we gonna do that simply
97:19 - just place your cursor on this element
97:22 - or whichever element you want to inspect
97:24 - just right click it
97:26 - and click on inspect
97:28 - and here you can see
97:30 - see i'm
97:31 - actually placing my mouse on this syntax
97:33 - of search button of this search box and
97:36 - it is highlighting here you can see
97:38 - right it is highlighting
97:40 - so this is the way you can inspect your
97:42 - web element and through these locators
97:44 - we will
97:46 - inspect the element for example here you
97:47 - can see input this input is your tag
97:50 - name it is an element
97:52 - your input has many attributes like we
97:54 - have class we have type we have name we
97:57 - have title so these are the different
97:59 - attributes of input tag so we will be
98:02 - using these attributes as locators to
98:05 - locate these web elements to inspect
98:07 - these web elements okay
98:09 - so now what are locators locators are a
98:11 - way to identify a html element on a web
98:14 - page
98:16 - as we
98:17 - just saw right now now there are
98:19 - different types of locators one is the
98:21 - locator the second is the customized
98:23 - locator under locator we have the id we
98:26 - have the name we have the link text and
98:28 - the partial link text we have the tag
98:31 - name we have the class name whereas in
98:33 - customized locators we have the css
98:35 - selector and the x bar now this xpath is
98:38 - one of the most important locators and
98:40 - it is frequently used by many
98:42 - automation testers because it is one of
98:44 - the most easiest thing and uh we will be
98:47 - using a different uh plugin for this
98:49 - expert that is called the crow path
98:50 - plugin so choosing xpath as a locator
98:53 - will be one of the most easiest locator
98:56 - yeah even though id name and all these
98:58 - are easiest but most of the time peop
99:01 - automation testers they prefer the xpath
99:03 - locator
99:04 - okay so we will do that at the end
99:06 - because there are many uh technical
99:08 - things also in this it is
99:10 - a little hard to understand before that
99:12 - we will understand what is id name link
99:15 - text partial link text tag name class
99:17 - name and css selector and you will have
99:19 - a command on this we will
99:22 - practically implement also this
99:25 - okay so locating by id
99:27 - now uh before proceeding i would
99:29 - recommend you to
99:30 - have a basic knowledge about the html
99:33 - which will be very beneficial for you
99:34 - because we are automating the web pages
99:36 - over here and a web page is made up of
99:38 - html css javascript languages so your
99:42 - html and css will play a lot of role
99:44 - over here
99:45 - in locating the web elements just the
99:46 - basic knowledge and then it's fine
99:49 - okay
99:50 - so now locating by id
99:53 - now id they are unique for each element
99:56 - the id value that we have right is
99:58 - always unique for each element and it is
100:00 - one of the most common way of
100:03 - locating an element
100:05 - and the id are supposed to be unique on
100:07 - a page
100:09 - and that is the reason why id are the
100:11 - most reliable locators like in form of
100:13 - priorities whenever the automation
100:15 - tester tests the application
100:18 - the first thing that they will do is
100:19 - they will try to automate the web
100:21 - element through
100:22 - id
100:23 - because uh id the value of id is always
100:26 - unique for each element so that is the
100:28 - reason why id is one of the most
100:30 - reliable locator and the fastest and the
100:33 - safest locators out of all the locators
100:35 - okay
100:37 - now let us assume this is your text box
100:40 - email address and you want to send some
100:42 - value over here you want to automate
100:44 - this field okay you want to inspect this
100:46 - field you want to send some value over
100:48 - your how you're going to do that and
100:49 - this is the html syntax that you have
100:52 - for this text box
100:53 - so how will we locate this element by id
100:56 - we will simply write driver dot find
100:59 - element
101:00 - here i am using find element and not
101:02 - find elements okay
101:04 - driver dot find element by dot id
101:08 - and here when you inspect this element
101:10 - when you uh right click and inspect on
101:13 - this element here you will get the
101:15 - syntax right over your id is equal to
101:17 - email you will place this value over
101:20 - here now see whatever value you enter
101:22 - here is case sensitive okay whatever is
101:26 - written over here you have to write it
101:28 - over here the same way like over here
101:30 - the email is written in small letters
101:32 - you need to enter your email in small
101:34 - letters only it's case sensitive okay
101:37 - then i will
101:38 - send a form command this is the send key
101:41 - command over use this is a form control
101:43 - which is used over here to send a
101:45 - particular text to this field what i'm
101:47 - doing is send keys abc at the right
101:49 - gmail.com right so i'm sending this
101:52 - email id that is abc at the gmail.com in
101:55 - this text field the text field which is
101:58 - located over here this email
102:00 - so you get it i'm writing driver dot
102:03 - find element by dot id email which i
102:06 - found it over here in the syntax
102:09 - dot send keys abc at the rate gmail.com
102:14 - so this is the way how i'm going to
102:16 - locate the id see we're going to
102:18 - implement it also
102:19 - first just understand this command
102:23 - okay
102:24 - the next one
102:25 - locating by name the next locator is
102:27 - name okay
102:29 - now here
102:30 - same same thing just assume you have a
102:33 - text box which is name uh which is of
102:35 - email address and this is the
102:36 - syntax of it so how we gonna look it by
102:39 - name it's the same same as id but the
102:43 - only difference between name and id is
102:45 - that
102:47 - name locator
102:49 - are not unique for a page like i said
102:51 - for id for each element the id value is
102:54 - unique whereas for name it's not that
102:57 - okay
102:58 - that is the difference between the id
103:00 - and the name
103:01 - so over here you can see right name is
103:03 - equal to from similarly we will write
103:06 - driver dot find element
103:09 - by dot name
103:10 - from
103:12 - dot send keys abc at the rate gmail.com
103:15 - so this is the command which i will use
103:18 - to locate by name locator
103:23 - now let's implement this uh practically
103:26 - i'll just open my intellij idea ide
103:31 - so now i'll create a new java class
103:33 - simply uh i'm having this project name
103:36 - selenium and i'll create a new java
103:38 - class i'll name it as
103:40 - selenium
103:43 - tutorials
103:48 - now here you can see this web page now
103:50 - we will be automating this web page
103:53 - so the task that we have for today is
103:56 - here you can see the search bar
103:58 - so we will be automating this search bar
104:01 - so how we gonna do that we simply gonna
104:02 - click on the search bar and click on
104:05 - inspect
104:06 - and here you can see
104:08 - as my mouse is on the syntax and you can
104:10 - see that the search box is
104:13 - highlighted
104:14 - okay here we have different attributes
104:16 - like the class we have the type we have
104:18 - id we have name so we will be using
104:21 - these attributes to locate this search
104:23 - element one by one okay
104:26 - so let's do it
104:27 - now open your intelligent idea id and
104:32 - create a new class i created a new class
104:35 - in
104:36 - my selenium project that is the selenium
104:38 - tutorials too and
104:40 - in the previous tutorial i explained how
104:42 - to launch a browser we will be launching
104:44 - the chrome browser so here i have
104:48 - written the two commands that were used
104:50 - in launching the chrome browser that is
104:52 - the system dot set property here we have
104:55 - to enter the key value that is the
104:57 - webdriver.chrome.driver
104:59 - and the uh path of the executable file
105:02 - that is the chrome driver executable
105:04 - file
105:05 - next we had written that the web driver
105:07 - driver is equal to new chrome driver so
105:10 - these two commands are used to launch
105:11 - the chrome browser so let's run this
105:23 - okay so your our chrome browser is
105:25 - launched now what i want to do is i want
105:27 - to maximize this chrome browser that is
105:30 - my chrome browser is minimized right now
105:32 - this is what i want
105:33 - so how am i going to do that
105:36 - i'll simply write
105:43 - i'll write driver
105:45 - dot manage
105:48 - dot window
105:50 - dot maximize
105:52 - so this command will maximize the chrome
105:54 - browser now let's see
105:56 - let's run
106:06 - so here you can see my chrome browser
106:07 - got maximized okay
106:12 - then the next command
106:15 - as i said we are going to locate this
106:17 - search box through id and by name okay
106:20 - locators so let's do it by id first
106:29 - let's do it by id locator
106:32 - so first
106:34 - okay sorry uh just before that we have
106:36 - to navigate to the
106:38 - uh url right so first we will
106:42 - navigate to the
106:43 - url
106:44 - we're gonna write
106:46 - driver dot
106:48 - get
106:50 - gonna enter this
106:52 - url
106:57 - and yeah
106:59 - okay
107:00 - so yeah first we launched the chrome
107:02 - browser we maximized the chrome browser
107:04 - then we navigated to the url let's check
107:06 - it first
107:14 - it's launched the chrome browser is
107:15 - launched maximized
107:18 - and it is navigated to this url
107:22 - so i'll just close this
107:24 - now
107:26 - as i said i want to
107:28 - locate this search box this search box
107:31 - through id
107:32 - now here same i'll just place my command
107:35 - click on inspect and your this
107:38 - syntax here you can see right
107:40 - this syntax here you can see id is equal
107:43 - to search underscore query underscore
107:45 - top
107:46 - so this value will be used to locate
107:49 - this search box now how am i going to do
107:51 - that just check it out first
107:53 - okay
107:54 - so what i'm going to do is i'm going to
107:55 - write driver
107:56 - dot
107:58 - find element
107:59 - let's find element and not find elements
108:02 - okay fine element
108:05 - i'm gonna write by
108:07 - dot
108:08 - see here you can see it's by dot tag
108:10 - name id class name css selector so i'm
108:14 - using id
108:16 - id
108:17 - and then i will here
108:19 - insert the value of id that is given
108:21 - over here simply just double click on it
108:24 - copy it
108:26 - and paste it over here okay it is case
108:28 - sensitive so play uh paste the same
108:32 - thing the this this thing this value
108:34 - should be same
108:36 - as
108:37 - the id that is given in that syntax okay
108:40 - now what i want to do is i want to send
108:42 - some command to it so i'll write send
108:43 - keys
108:44 - and i'll simply just type
108:47 - i want to send
108:48 - t-shirts
108:54 - chrome browser is launched
108:58 - is maximize it is navigated to this page
109:07 - and here you can see you could see it's
109:08 - your it's written t-shirts right we
109:11 - haven't
109:12 - inspected this element this search bar
109:14 - and that's why it's not clicking on this
109:16 - okay we will do that later
109:19 - so now
109:20 - this is the first way of writing driver
109:22 - dot find element by id and dot sign keys
109:25 - okay the second method that you can
109:28 - write this command is
109:31 - let me comment this so i can write
109:33 - driver
109:35 - similarly just the same thing
109:37 - but
109:37 - i'll write it in a different way find
109:39 - element i'll write by dot id
109:49 - okay
109:50 - that's it now what i'm going to do is
109:52 - i'm going to store this
109:54 - in a variable i will name it as
109:58 - search
109:59 - is equal to driver dot fine element by
110:02 - dot id
110:03 - now what i'm doing i'm locating a web
110:05 - element right in java usually when we
110:08 - write we write it as int a is equal to
110:11 - 10 right then we write
110:14 - float
110:15 - b is equal to 10.2 so you're giving some
110:18 - data type to your a and b variables
110:20 - right so here also we will
110:24 - this search element
110:26 - so here also we will write something
110:28 - right so what you're going to do that so
110:30 - what you're going to write
110:32 - simply here you see this search
110:34 - underscore queries underscore talk what
110:37 - is this we are locating a web element
110:40 - right
110:41 - so we are finding a web element on a web
110:43 - page so this search variable will be of
110:46 - what type it will be of web element type
110:50 - so web element search is equal to driver
110:53 - dot find element by dot id search
110:56 - underscore query underscore talk
110:58 - okay
110:59 - now over here you could see i had
111:01 - written dots and key so simply what i'll
111:03 - do is i'll write
111:05 - search
111:06 - dot
111:07 - send keys and i'm gonna write
111:11 - t-shirts
111:14 - okay
111:14 - so let's run this command this is the
111:16 - second way of writing this
111:18 - one line command
111:20 - you can write it this way or you can
111:21 - write it this way depends on your
111:25 - choice
111:30 - okay so i'll just run this
111:38 - chrome browser is launched
111:42 - it's maximized
111:44 - is navigated to this url
111:52 - and here it is you can see it's t-shirt
111:54 - here the value is sent
111:57 - okay so i'll just close this
112:00 - and close this also
112:03 - okay so i'll just comment this
112:07 - for now
112:09 - this method
112:12 - is better
112:14 - okay
112:15 - next we will do it by
112:18 - name
112:19 - we will locate the search box by
112:22 - name
112:24 - okay so how we gonna do that
112:26 - again we're gonna write
112:27 - driver
112:30 - dot find element
112:33 - by
112:34 - dot
112:35 - name
112:38 - and here you will see
112:41 - we have the value of name just double
112:43 - click it
112:45 - copy it
112:46 - paste it over here
112:48 - and write
112:50 - dot send keys i'll write
112:55 - shorts
112:59 - okay
113:06 - so now let's run this
113:15 - chrome browser is launched it's
113:16 - maximized
113:18 - it is navigated to this url
113:24 - and
113:27 - here you can see
113:29 - okay wait a minute
113:32 - okay i didn't
113:34 - comment this let me comment this
113:37 - okay
113:40 - i'll do it again
113:44 - so i'll click on run
113:49 - the chrome browser is launched
113:52 - it's maximized it's navigated to this
113:56 - url
114:03 - and here you can see it's shorts
114:05 - okay
114:07 - so i'll just close this
114:09 - now we have understood how do we locate
114:11 - by id and how do we look it by name
114:13 - similarly here you can see the
114:15 - your the same way the same way you can
114:17 - write it by name also there's nothing
114:20 - different in it but this is the most
114:22 - precise way you just write it in your in
114:24 - one line here you have to write in two
114:26 - lines is the same thing
114:28 - so i prefer this one so it's up to you
114:31 - which one do you prefer there's no harm
114:34 - in writing
114:35 - either of the way okay
114:37 - so we have learnt by id we have learned
114:39 - by name
114:40 - next we have locating by link text and
114:43 - partial link text now what is link text
114:46 - and partial link text
114:48 - see
114:48 - whenever we have links in our pages okay
114:52 - like there's a web page and there are
114:53 - links involved in this in that case we
114:56 - have the link text and the partial link
114:58 - text
115:02 - now link text and partial link text both
115:04 - are different they are not the same but
115:07 - partial link text is not mostly used by
115:09 - the automation testers
115:11 - link text is mostly used by the testers
115:14 - because this is the most precise way of
115:17 - automating or clicking a link for
115:20 - example like suppose let me show you
115:23 - here this page you can see right now
115:25 - your woman
115:27 - i have dresses
115:30 - now there are various dresses over here
115:32 - so if i want to click on this link here
115:34 - you can see this link
115:36 - so if i want to click on this like how
115:37 - am i going to do i'm just simply going
115:39 - to click inspect
115:41 - and here you can see this you can see
115:43 - there's an anchor tag over here
115:46 - so this anchor tag is used for links in
115:49 - html okay now here you can see is there
115:51 - any class is there any name or id
115:55 - attribute used over here no right so how
115:57 - will you identify this element how will
115:59 - you inspect this element we will inspect
116:01 - this element through link text that is
116:04 - the link text which is written over here
116:05 - you can see women a line multi-color
116:08 - dress you can see this uh text written
116:10 - over here right we're gonna inspect
116:12 - through this text this is the link text
116:14 - that is given over here
116:16 - and the a class which denotes the anchor
116:18 - class
116:19 - uh
116:20 - which is used for links in html okay so
116:23 - for clicking the links in selenium we
116:26 - will be using the link text locator
116:31 - so how are we going to locate this
116:33 - element through link text or partial
116:35 - link text now for example here we have
116:37 - various links like the printed dress the
116:39 - printed summer dress and this is the
116:42 - syntax of this okay
116:44 - so
116:45 - it is a syntax of sprinted summer dress
116:47 - so how we're going to click on this
116:49 - printed summer dress how we're going to
116:51 - click on this link
116:52 - for that
116:54 - we will be using i'll be explaining link
116:56 - text first we'll write driver dot find
116:59 - element by dot link text
117:01 - printed summer dress here you can see
117:03 - this is printed summer dress this link
117:06 - text is used to identify this element
117:10 - here you can see there is printed summer
117:11 - dress this printed summer dress right
117:14 - this text is used to identify this
117:17 - element that is the printed summer dress
117:19 - okay so i just simply write printed some
117:21 - address this is case sensitive to cited
117:23 - the same way and dot click again before
117:26 - we were writing send keys right that is
117:28 - the form command this is also form
117:30 - command which is used to click a
117:32 - specific element or to click a specific
117:34 - link so what operation i need to perform
117:37 - over here i want to click this element
117:38 - right print it somewhere else so i'm
117:40 - going to write dot click
117:43 - similarly for partial link text what you
117:45 - do you partially write the text like
117:47 - over here we have the printed summer
117:49 - dress we'll just write some address
117:51 - still it will detect this printed sum
117:53 - address and it will click at this link
117:56 - okay
117:57 - that's the uh partial link test and the
118:00 - link text
118:01 - now here the partial link text means
118:03 - that we don't need to pass the complete
118:05 - value here you just need to pass a
118:07 - portion of the text like i said you need
118:08 - to pass the portion of the next i have
118:10 - passed some address over here right so
118:13 - through this also it will click at
118:15 - printed some address so let's uh
118:17 - practically do it first or uh just open
118:21 - your
118:23 - intellij id id
118:25 - so i'll just create a different package
118:27 - over here
118:28 - sorry i'll just create a different class
118:30 - over here
118:32 - or link text and
118:36 - partial link text so i'll just write
118:40 - selenium
118:42 - tutorials
118:43 - three
118:44 - okay
118:46 - just click on dresses
118:51 - okay so i'll just copy this
118:56 - and i'll paste this url here
119:00 - okay so now
119:03 - by
119:04 - link
119:06 - text
119:07 - so it's going to be um
119:11 - driver
119:12 - dot
119:13 - fine element
119:14 - by
119:16 - dot
119:18 - link text
119:19 - okay
119:20 - so now here i want um
119:24 - i want to click on this link so how am i
119:26 - gonna do it i'm gonna
119:28 - inspect this element first
119:36 - so i've inspected this element
119:40 - here you can see i have the printed
119:42 - chiffon dress which is written away this
119:44 - is the
119:46 - link text i will copy this
119:50 - and i will paste it over here
119:53 - and simply write
119:55 - click
119:58 - okay
119:59 - so now let's see
120:03 - okay it's launched
120:07 - is maximize it is navigated
120:21 - and here it is selected
120:24 - so here you can see this is printed
120:25 - chiffon dress
120:27 - as i had written a printed chiffon dress
120:29 - dot click so here it's clicked
120:32 - okay
120:33 - now let's try it by partial link text
120:37 - so i'll just simply
120:39 - command this
120:43 - i'll do it
120:46 - by
120:49 - what i'm going to do is i'm going to
120:50 - write driver
120:52 - dot
120:53 - find element
120:55 - by dot
120:57 - partial link text and what i'm going to
120:59 - enter is chiffon dress
121:01 - and i'll click
121:05 - this text okay
121:07 - so now let's run this
121:17 - chrome browser's launch this maximize it
121:19 - is navigating
121:22 - [Music]
121:28 - and now it's clicked okay so now you can
121:31 - see
121:32 - through partial link text also my
121:34 - printed chiffon dress this this dress
121:36 - this link is clicked
121:38 - so now we have understood uh
121:42 - id we have understood name then we have
121:44 - understood the partial link text and the
121:46 - link text
121:48 - so next is class name
121:51 - now through class also we can locate our
121:55 - web element for example we have this
121:57 - text box name email address and we have
122:00 - this uh syntax of html syntax now we
122:04 - have the attribute class over here here
122:06 - we have the class attribute form control
122:08 - the value is
122:09 - so how we're going to locate by class
122:11 - simply just write driver dot find
122:13 - element by dot class
122:15 - form control send keys and whatever
122:18 - value you want to send away it's similar
122:19 - to id and name there's no such
122:22 - difference in it but this one thing is
122:24 - that the class name that the value of
122:26 - form control now this value can be of
122:29 - multiple elements on a web page it's not
122:32 - unique
122:33 - whereas the id is a unique uh value
122:36 - right which is given to each element for
122:39 - each element the id value is different
122:41 - whereas for class the value for each
122:43 - element is similar
122:45 - like for multiple elements there must be
122:47 - a class name form control okay
122:50 - so in that case uh many of them don't
122:53 - use class the automation testers they
122:55 - use class uh locator very less as
122:58 - compared to the id and the name
123:00 - so the next locator that we have is the
123:03 - tag name
123:04 - okay now tag name uh are used to find
123:07 - multiple elements on the web page
123:10 - like let me tell you what is tag name
123:12 - like suppose um
123:14 - here you can see right this input this
123:17 - is your tag name
123:18 - this is the tag name here over your
123:20 - input and the attributes are this type
123:23 - name id
123:24 - these are the attributes that is used
123:28 - so tag name
123:29 - are used to find multiple elements on
123:31 - the web page
123:33 - for example suppose
123:36 - suppose this page okay
123:38 - now i want to find the number of links
123:41 - present on this page
123:43 - so how can i do that
123:45 - i'll simply click on inspect
123:47 - i'll find the anchor tags the number of
123:51 - anchor tags present on this page okay
123:54 - through that i can find out the number
123:56 - of links that is present in this page
123:58 - okay so tag name now your tag name like
124:01 - a like here the a the anchor tag is used
124:04 - as a tag name now through this a that is
124:07 - the anchor tag we can locate the uh we
124:10 - can find the number of links present on
124:12 - this page
124:13 - now remember tag name is used when we
124:15 - want to find multiple things like
124:18 - suppose i can now um
124:20 - [Music]
124:21 - i if i want to find the number of
124:23 - sliders over here
124:24 - like how many sliders are present
124:27 - so how am i going to do i'm going to
124:28 - inspect the element like under every
124:30 - anchor tag we have the image
124:33 - like suppose for example let me
124:36 - inspect this
124:38 - here
124:41 - yeah you can see under every angle tag
124:44 - we have the image so the source image
124:46 - resource so
124:48 - ah through this anchor tag i can inspect
124:50 - the number of sliders that is there i
124:53 - can inspect these sliders how many
124:54 - sliders are present how many uh through
124:56 - this image tag i can identify how many
124:58 - images are present on this web pages so
125:01 - the tag is used to find multiple
125:03 - elements on the web page
125:06 - now for example it is mostly used like
125:08 - if i want to find the number of sliders
125:09 - if i want to find the number of links on
125:11 - this page if i want to find the number
125:13 - of images on this page so through this i
125:16 - can find the uh
125:18 - number of multiple items or multiple
125:21 - elements on the web page
125:23 - so let's implement that
125:26 - so what i'm going to do is i'm going to
125:28 - let's create a new
125:30 - class
125:31 - java class
125:33 - write
125:34 - selenium
125:36 - tutorials
125:39 - okay so i have created a new java class
125:42 - over here
125:44 - i'll write driver.get
125:47 - and this i'll write
125:50 - inspect this element
125:57 - okay we will inspect this we will try to
126:00 - find the number of links present on this
126:02 - page okay
126:04 - let's see whether this
126:07 - program runs properly or not
126:16 - okay my chrome browser is launched
126:20 - is maximized it is navigated to
126:22 - google.com okay
126:25 - so now um
126:27 - what i want to do is i want to find the
126:29 - number of links that is present on this
126:31 - page okay there are many links like this
126:34 - image gmail
126:36 - and there are links like hindi and the
126:38 - different types of languages so i want
126:40 - to i want to know the number of links
126:41 - that is present on this page so how am i
126:44 - going to do that
126:45 - okay
126:47 - simply
126:48 - i'll use the tag name tags over here
126:51 - so here we will be using by tag name the
126:54 - locator so i'll just simply write driver
126:56 - dot find elements i'll use find elements
127:01 - over here because i have to find
127:02 - multiple elements over here okay
127:05 - by
127:06 - dot
127:08 - tag name and here i'll write
127:10 - which tag do i need to inspect to find
127:13 - the number of links that is present on
127:16 - this page so i will be inspecting the
127:18 - anchor tags that is present
127:20 - on this page right the number of anchor
127:22 - tags i want to know the number of anchor
127:24 - tags that is present on this page so
127:25 - i'll be using
127:27 - a this is the tag name which i want to
127:28 - inspect
127:30 - okay
127:32 - now here i have used elements find
127:35 - elements right
127:36 - so what i'm going to do is i'm going to
127:38 - um
127:40 - write a variable over here link is equal
127:43 - to driver.find elements by dot name tag
127:46 - name
127:46 - now this link is of what type that we
127:49 - need to decide right
127:51 - so how are we gonna do that now here
127:56 - this find elements okay
127:59 - this find elements need to return a list
128:02 - it needs to return a list of elements
128:05 - it needs to return a list of web
128:07 - elements
128:08 - where the elements are this a this
128:10 - anchor tag the links that is present on
128:12 - the web page anything that is present on
128:14 - the web page is known as web elements
128:15 - right so we are uh returning a list of
128:19 - web elements right we need a list of web
128:21 - elements so here we will be using the
128:23 - collections concept that is there in the
128:25 - java
128:26 - in which we have the list
128:30 - that is a java util package
128:32 - and your
128:33 - in list this a tag is what it is
128:37 - identifying what it is identifying a web
128:39 - element right so i'll write a web
128:42 - element
128:44 - so this find element is designed to
128:47 - return back a list of web element
128:52 - which is what is being assigned to the
128:54 - variable
128:56 - link
128:57 - okay
128:58 - whose type is of what
129:00 - list web element
129:04 - okay so now your uh there's a variable
129:06 - link so what i'm gonna do is i'm gonna
129:09 - write
129:10 - s out
129:12 - and
129:13 - link
129:14 - dot size now the size method is used to
129:18 - find the number of uh elements that is
129:21 - present okay number of elements that is
129:23 - present on the
129:24 - web page so this command through link
129:26 - dot size this method this method is used
129:29 - to find the number of elements okay
129:31 - so what i'm going to do is i'm going to
129:33 - save it and
129:35 - let's run
129:44 - chrome browser is launched
129:47 - it's maximized
129:49 - it's navigated
129:52 - and
129:53 - here you will see there are 20 total 27
129:56 - links present on the web page now what i
129:58 - want is i want the name of these links
130:01 - so how are we going to do that to print
130:03 - those name i'll use the for loop
130:08 - i'm simply going to write for
130:10 - and here
130:12 - we are inspecting the web element
130:15 - so i'll write web element
130:18 - i'll name it as l and your i'll write
130:21 - link
130:25 - s out and i will write
130:27 - l dot
130:29 - get
130:30 - text
130:31 - now the get text method is used to
130:34 - retrieve the or to return the text that
130:36 - is uh
130:38 - inspecting that we are inspecting over
130:39 - here we are inspecting the link right so
130:41 - it will get the text
130:43 - of those links that means i want the
130:45 - name of the links that is uh that they
130:47 - are identifying over here these 27 links
130:50 - right i want the name of these 27 links
130:52 - i'm adding for loop in which i have
130:54 - given a web element l because i'm
130:56 - inspecting a web element that is the
130:58 - links i'm inspecting i'm going to very
131:00 - i've stored it in l
131:02 - and uh here i'm printing those
131:05 - uh links the name of those links okay
131:09 - so i'll just click
131:19 - here my chrome browser is launched
131:24 - it's maximized it's navigated to
131:26 - google.com
131:30 - and here you can see we have the
131:31 - different types of links that is present
131:33 - over here
131:34 - okay
131:36 - so through this way we can find the
131:37 - number of uh
131:39 - links and we can find the name of the
131:40 - links that is present that is we can
131:42 - find
131:43 - we learnt the get text method and the
131:45 - size method over here
131:47 - okay
131:49 - creating by css selector
131:51 - now this css selector this is a type of
131:54 - customized locator now before uh
131:57 - studying the css selector we need to
131:59 - study some css concept
132:01 - so let's have a look at it
132:04 - now for example we have a front
132:06 - page.html we have this html file we have
132:08 - the html tags and everything and inside
132:11 - the body tag we have this div tag okay
132:14 - now we have written div class is equal
132:16 - to box i have given the class value as
132:20 - box okay and then i have given the
132:22 - uh
132:25 - text and if like i have given a code
132:27 - inside this div element this div block
132:30 - whatever it might be but the thing is
132:32 - over here is about the class and the id
132:34 - the difference between the class and the
132:35 - id over here okay so we have this front
132:38 - page dot html in which we have the div
132:40 - tag inside the div tag we have the class
132:43 - okay and the value of this class is box
132:46 - so
132:47 - if i append the style sheet or in this
132:50 - html page so how will i style this class
132:54 - how will i style this div block
132:56 - so i'm going to style through this class
132:58 - value that is box now how i'm going to
133:01 - do that to access this class i'm going
133:04 - to write uh this
133:05 - dot do you see i'll be accessing it
133:08 - through a dot this is a period that is
133:10 - used
133:11 - while accessing the class value okay
133:14 - so i'll write dot box and then whatever
133:16 - attributes i want to write like color
133:18 - green red or whatever it is whatever
133:20 - formatting i want to do or whatever
133:22 - style i need to add i'll add between
133:24 - these blocks of code okay
133:27 - so this is one concept for class we will
133:29 - use a dot
133:32 - now let's see for id now here we have
133:34 - the front page dot html similar and we
133:36 - have the div block in which we have the
133:38 - div id is equal to box one i have given
133:41 - the id value as box one so if i want to
133:44 - style it what i'm going to do i'm going
133:45 - to use the hash symbol over here here
133:48 - you can see i'm using the hash symbol to
133:50 - access this id
133:53 - i'm going to use the hash symbol that is
133:54 - the hash box one and then whatever our
133:56 - styling i want to perform i will perform
133:58 - between these blocks
134:00 - but the thing that i want you to
134:02 - understand over here is that for class
134:04 - we are using the uh dot and for id we
134:08 - are using the
134:09 - hash okay so this is the css concept we
134:12 - you need to know what's the css selector
134:16 - okay
134:17 - so now uh locating by css selector that
134:20 - is the tag and id
134:23 - now just assume we have this uh
134:26 - text box that is the email text box and
134:28 - this is this html syntax that we are
134:30 - having
134:31 - now here for tag in id
134:35 - your tag what is your tag name your tag
134:37 - name is this this is your tag name input
134:40 - okay and these are your attributes like
134:42 - the class id name these are your
134:44 - attributes right
134:46 - so what you're going to do is like for
134:47 - tag and id it is tag name hash id like
134:51 - as i said in the previous slide to
134:54 - access id we use the hash right so over
134:57 - here we'll use tag name hash id
135:01 - so how we're going to write is like
135:02 - driver dot find element
135:04 - by dot css selector we'll use css select
135:08 - over here
135:09 - we'll write tag name first the tag name
135:12 - is input so we'll write input
135:15 - then we'll write hash
135:18 - hash
135:19 - and then we are going to write the id
135:21 - value because it's tag and id the css
135:24 - selector that we are using is tag and id
135:26 - right so we're going to write the id
135:28 - value that is email okay now this is
135:31 - case sensitive just write it the same
135:32 - way which is it is written over here
135:35 - so we're going to write input
135:38 - email dot send keys okay whatever uh
135:41 - text you want to send just send it over
135:42 - here
135:44 - so this is how you're going to write the
135:45 - css director for tag and id
135:49 - now let's see for tag and class okay
135:53 - so here we have the text box email
135:55 - address and we have the syntax over here
135:58 - so how we gonna write for tag and class
136:01 - for class we use the dot operator here
136:03 - you can see we use a dot right
136:05 - so similarly before we were using hash
136:08 - here you can see we were using hash for
136:10 - id so for here we are using the dot for
136:13 - class
136:14 - it's the same thing we're just going to
136:15 - write driver dot find element by dot css
136:19 - selector
136:20 - input dot
136:22 - that is a tag name your tag name is
136:24 - input
136:26 - dot
136:27 - dot
136:28 - class value the value of your class is
136:30 - control right so i have written control
136:32 - over here dot send keys at the right abc
136:34 - gmail.com whatever text you want to send
136:37 - over here
136:38 - okay next we have the tag and attribute
136:41 - okay so how we're going to work with tag
136:43 - in attribute is tag name then we have
136:46 - the attribute name is equal to attribute
136:48 - value now we can use any of the
136:51 - attribute that we want
136:52 - like over here we can use the
136:54 - driver.find element by.css selector
136:57 - input
136:58 - name like here i can use id i can use
137:02 - name i can use class anything i can use
137:05 - so i'm using name name is equal to from
137:07 - that is the attribute name is name my
137:10 - attribute value is from here you can see
137:14 - and my tag name is input
137:16 - okay
137:18 - my next css locator is tag and class and
137:20 - attribute
137:21 - so how am i going to do that
137:24 - simply i just have this text box that is
137:25 - the email address and i have the syntax
137:28 - over here
137:29 - so what i'm going to do is uh over here
137:31 - for tag name
137:33 - it's tag and class and attribute right
137:36 - so for tag name we'll first insert our
137:38 - tag name that is the input
137:40 - then we have the uh class we want to uh
137:43 - write the class for that we need to use
137:45 - the dot operator here we are using the
137:48 - dot over here dot
137:49 - the class value that we have is control
137:52 - over here it's control then the
137:54 - attribute name now here i'm using id you
137:56 - can use any of the attribute so i'm
137:58 - using id is equal to email dot send keys
138:02 - abc at the rate gmail.com
138:05 - okay so i hope it's clear for you
138:08 - the css selector now see css selector is
138:10 - not mostly used by the automation tester
138:13 - they don't use this css selector a lot
138:15 - instead of css selector they use the
138:17 - xpath
138:18 - see the frequently used locators are the
138:20 - id
138:21 - the name
138:23 - and for links we use the link text and
138:26 - the xpath the expert is used
138:28 - used frequently by all the automation
138:31 - testers because it is one of the most
138:33 - precise form to use the locator and it's
138:36 - it's tough to understand but uh once you
138:39 - understand it it's very easy to use okay
138:41 - because we have a crow path plug-in to
138:44 - use that we will use that plug-in to uh
138:47 - find our x-path
138:50 - okay next the one of the most important
138:54 - interview question that you will face is
138:55 - that what is difference between the find
138:58 - element and the find elements
139:00 - okay
139:01 - now uh we found this find element and
139:04 - find elements in tag name in tag name i
139:07 - wrote a program in which i used find
139:09 - elements because i wanted to find the
139:11 - number of links on a web page right i
139:14 - wanted to find multiple web element on a
139:16 - web page
139:17 - so that's the
139:19 - method used to find multiple element on
139:21 - a web page we use the find elements
139:24 - that's where i use file elements right
139:26 - so the first difference is that find
139:28 - element
139:29 - this method is used to access a single
139:32 - web element on a web page we will use to
139:35 - access single element on the web page
139:37 - till now we were accessing find element
139:39 - because we wanted to access only one web
139:42 - element that is the
139:43 - text box or some other box that is the
139:46 - email box so we have to access only one
139:48 - web element so that is the reason why
139:50 - we're using find element
139:52 - whereas in find elements this method is
139:55 - used to access multiple web element on a
139:57 - web page in our case we were finding
140:00 - multiple angular tags the anchor tags
140:02 - that is the a tag that is used on our
140:04 - web page we were finding the number of
140:06 - links in our web page
140:08 - okay
140:09 - next in find element when the element is
140:12 - not found it throws an exception
140:14 - see whenever the element is not found in
140:16 - find element it will throw an exception
140:18 - such as no such element is found okay
140:21 - whereas in find elements when the
140:23 - element is not found it returns an empty
140:26 - list it will return some empty list okay
140:30 - next the final element it will find only
140:33 - one web element whereas the find
140:35 - elements will find the list of elements
140:37 - which matches the same locator like if
140:39 - we have uh written a as a tag name
140:42 - written over here
140:43 - in fine and we find the number of
140:46 - a tags so it will return the list of
140:48 - elements that is the list of elements
140:50 - will be returned as i have shown in the
140:52 - program let me show you the program
140:55 - um
140:56 - here it is
141:05 - here you can see it is returning the
141:07 - list of web elements that is it is
141:09 - returning the list of links
141:11 - so the find elements
141:14 - the find elements will find the list of
141:17 - elements which matches the locator
141:20 - now let me explain you when the element
141:22 - is not found
141:24 - like here you can see when the element
141:25 - is not found it throws an exception no
141:27 - such element found right so we're going
141:29 - to do that i'll show that i'll implement
141:32 - that for you
141:34 - for example suppose um
141:38 - let's go to this tutorial and
141:43 - recommend this
141:47 - okay
141:48 - and suppose
141:51 - this by name okay
141:53 - i'm
141:55 - just writing search
142:00 - just writing something so that you don't
142:01 - find the element i'm using the fine
142:03 - element method over here
142:05 - see what i'm trying to do is i am trying
142:07 - to prove you this statement that when
142:09 - the element is not found it will throw
142:10 - an exception no such element found i'm
142:12 - trying to prove this statement
142:14 - just check it out
142:17 - okay so i have changed the value over
142:19 - here now let's see
142:25 - chrome browser is launched
142:31 - it is navigated
142:38 - so let's see
142:40 - see here you can see no such element
142:42 - exception no such element unable to
142:44 - locate element here you can see
142:46 - we have got an error over here here you
142:48 - can see name is equal to search
142:50 - underscore q u
142:53 - unable to locate element that's what i
142:55 - try i said right
142:57 - for a fine element when you're using
142:59 - find element and the element is not
143:00 - found you will get an exception that no
143:02 - such element found or unable to locate
143:04 - the element whereas in fine elements we
143:07 - will return an empty list now let's try
143:10 - to do
143:11 - this one
143:13 - we use the find elements method here
143:17 - right find elements now let me change
143:20 - the tag to
143:22 - suppose i'm changing to ar okay
143:24 - this is what the tag i'm changing and
143:26 - i'll just comment
143:28 - this for
143:29 - time being
143:40 - let's navigate it
143:42 - here you can see are we getting any
143:45 - list of array it's just simply zero
143:47 - number of uh
143:50 - we didn't find any tag name a r over
143:53 - here so it just returned zero so that's
143:55 - what it said that it won't give any uh
143:58 - error or something it will just return
144:00 - an empty list it will just return like
144:02 - if the element is not for it will return
144:04 - an empty list over here it returns zero
144:06 - so there is no uh tag name name f a r
144:10 - so this is what is the difference
144:12 - between find element and fine elements
144:14 - this is one of the interview question
144:15 - which is asked in selenium and it is one
144:18 - also one of the most important question
144:19 - that is asked
144:21 - so this is all for today in the next
144:23 - tutorial we will learn what is xpath and
144:25 - we will execute we will practically
144:28 - implement that we will also download the
144:30 - crow path
144:31 - plugin that we used for uh
144:34 - xpath
144:35 - hello everyone my name is varsha and
144:37 - welcome to programming knowledge
144:39 - so in today's tutorial we are going to
144:42 - create test cases and we're going to
144:44 - execute them
144:45 - but before that let us understand what
144:47 - we did in the previous tutorial so in
144:49 - the previous tutorial we learned what
144:51 - are the web elements what are the
144:52 - different types of web elements and one
144:53 - of the most important concept that we
144:55 - learnt in the previous tutorial was the
144:57 - locators now the locators are the way to
144:59 - identify a web element on a web page and
145:02 - we discuss the different types of
145:03 - locators like the id name
145:06 - tag name class name the link text and
145:08 - the partial link text and also we
145:10 - discussed about the css selector in the
145:13 - previous tutorial
145:14 - so uh the id name and the class name are
145:17 - the attributes that is used in the html
145:19 - through which we can identify the web
145:21 - element
145:22 - whereas the link text and the tag name
145:25 - these two are used uh first of all the
145:28 - link text is basically used to click a
145:30 - link on a particular web page if you
145:32 - want to click on some link we use the
145:34 - link text whereas the tag name is used
145:36 - to retrieve multiple elements on a
145:38 - webpage like for example i want to know
145:40 - the number of links present on the
145:42 - particular page so i'm going to inspect
145:44 - the tag name that is the anchor tag that
145:46 - is the a tag and i'm going to count how
145:48 - many a tags are present on that web page
145:50 - to which i will uh retrieve multiple
145:53 - elements so that is uh that
145:55 - for the so for that we are using tag
145:57 - name whereas the css selector we use the
146:00 - tag in id we have the tag in class we
146:02 - have tag and attribute we have tag class
146:04 - and attribute so these are the different
146:06 - types of css selector also we understood
146:08 - in the previous tutorial so these were
146:11 - the some of the concepts that we learnt
146:12 - in the previous tutorial now in this
146:14 - tutorial we are going to create test
146:16 - cases and we are going to execute it
146:19 - what i'm going to do is i'm going to
146:20 - create a test case in which we're going
146:22 - to open the chrome browser
146:24 - i'm going to navigate to this url
146:26 - this page that you're seeing right i'm
146:28 - going to navigate to this url i'm going
146:31 - to enter the valid username and password
146:33 - and click on login button
146:35 - next i'm going to verify the title of
146:37 - the page that is the orange hrm and i'm
146:39 - also going to verify the url that is
146:42 - specified over here
146:44 - see the main intention behind this
146:45 - tutorial
146:47 - is that we're going to learn different
146:49 - types of commands in this also we are
146:51 - going to learn how to verify an element
146:53 - like in manual testing we use the
146:56 - expected result and the actual result
146:58 - and the status column is present right
146:59 - in which you have to match the results
147:01 - and pass the status that it is fail or
147:03 - passed
147:04 - so over here also we are going to verify
147:06 - some elements like i am going to verify
147:08 - the title of the page we are going to
147:09 - verify the
147:10 - url of the page so these are some of the
147:13 - elements that we are going to verify
147:14 - today before that let us understand some
147:16 - of the commands that we use in the
147:18 - previous tutorial let's understand that
147:20 - let's revise that the first command that
147:22 - we used was the form command that is the
147:24 - send keys command
147:27 - here you can see the send keys command
147:29 - which is used to send a particular
147:32 - text to the particular element right
147:34 - then we use the click command which is
147:35 - used to click an element
147:37 - then we use the get command which is
147:39 - used to navigate to the url
147:42 - next we use the get text command which
147:44 - is used to retry specific elements text
147:46 - if you remember that
147:48 - we were using uh
147:50 - we were counting the number of links in
147:52 - a page right so in that i wanted to know
147:56 - the name of those links so we use the
147:58 - get text command
148:00 - next we learnt about the size command
148:02 - the size command is used to get the
148:04 - number of elements in the list
148:06 - now uh if you remember
148:08 - while
148:09 - while counting the number of links we we
148:12 - use the size command to know how many
148:14 - links are present on the web page
148:17 - next we use the
148:19 - driver.manage.window.maximize command
148:21 - which is used to maximize the window
148:23 - next we use the system dot set property
148:26 - as you know it is the very first line
148:29 - on in our
148:31 - program so which is used to set a value
148:33 - and a key the key is like the
148:37 - webdriver.chrome.driver and the value is
148:39 - the path of your executable file
148:43 - okay so these were the commands that we
148:45 - learned in the previous tutorial so now
148:47 - here i have prepared some of the test
148:49 - cases first is open the chrome browser
148:52 - we will navigate to the url enter the
148:54 - valid username enter the valid password
148:57 - next we will click on login button then
148:59 - we are going to verify the url and then
149:01 - we are going to verify the title and
149:02 - then we will close the browser
149:04 - so these are the some of the steps that
149:06 - we are going to perform today so let's
149:08 - get started
149:09 - now open your intelligent idea id
149:12 - i'm going to create a new
149:15 - class over here
149:16 - in my project
149:18 - okay so now i have created a new class i
149:20 - have named it as selenium tutorials file
149:23 - and i have opened my chrome browser
149:24 - these are the two commands that i've
149:26 - used that is the system.set property
149:28 - next i have used the web driver driver
149:30 - is equal to new chrome driver
149:32 - next i have navigated to the url this is
149:35 - the url and i have maximized the window
149:37 - these are the commands that we have been
149:39 - learning in the previous tutorial also
149:42 - so now what i want is i want to uh enter
149:44 - valid username and valid password over
149:46 - here so i'm going to simply click on
149:48 - this element and click on inspect
149:52 - here you can see there are different
149:54 - attributes used so i'll use the id
149:55 - attribute first
149:59 - so i'm gonna write driver
150:01 - dot
150:02 - find element
150:04 - by dot id
150:07 - i'm going to enter the value that is
150:09 - there this is case sensitive so enter
150:11 - the same value
150:13 - and what i want to do is i want to send
150:14 - some value to it right
150:16 - so i'm going to write send keys and i'm
150:19 - going to enter the valid username here
150:21 - you can see the username and the
150:22 - password is given this is a demo website
150:25 - which is normally used for automation so
150:27 - you can also use this and you can
150:29 - automate this
150:30 - website so the username here uses admin
150:33 - so i'm going to copy this
150:36 - i'm going to paste it away
150:39 - so here i've entered a valid username
150:42 - now i'm going to enter the valid
150:44 - password
150:53 - so for that i'm going to write driver
150:54 - again
150:57 - dot find element
151:00 - i'm going to write by dot
151:04 - i'll use name
151:07 - let's see let's inspect that element
151:12 - here you can see this name attribute i'm
151:14 - going to copy this
151:15 - paste it over here
151:18 - i'm going to send some information to it
151:23 - the password is given over yours so i'll
151:25 - just simply copy this password
151:31 - and i'll paste it over here
151:33 - so here we have entered the valid
151:35 - username and valid password
151:37 - so i have entered the valid username and
151:39 - password next i have to click on login
151:41 - button
151:42 - so
151:45 - so i'm going to inspect this login
151:46 - button i'll simply click on inspect
151:49 - and here you can see we have the name
151:51 - class id
151:53 - so i'll use the id
151:59 - i'll use driver
152:01 - dot find element
152:07 - by dot
152:08 - id now enter the value and what i want
152:12 - to do is i want to click this right so
152:13 - i'll write right click
152:16 - okay so now let's run this
152:25 - my chrome browser browser is launched
152:27 - successfully
152:29 - it's navigated
152:33 - and it's maximized
152:38 - okay there is some problem to it
152:42 - [Music]
152:45 - okay here you can see i have given some
152:47 - space so there is no space and password
152:52 - again let's run this command
153:06 - it's launched it's navigated and my
153:08 - admin and password okay it's
153:11 - login successfully
153:14 - okay so now what i want is that i want
153:17 - to verify the title of the page and i
153:19 - want to verify the
153:21 - url that is present over here
153:23 - okay so let's verify that
153:27 - so first we will verify the url let's
153:31 - verify the url
153:34 - now for that we're going to use the get
153:36 - current url
153:37 - this is the command that we're going to
153:39 - use to verify the url now this command
153:42 - returns the current url of the web page
153:46 - okay
153:46 - so let's see
153:49 - what we're going to do is we're going to
153:51 - write
153:52 - driver dot
153:54 - get
153:55 - current url
153:57 - okay
153:58 - and we're going to store this in a
153:59 - variable we're going to store this in a
154:01 - string type variable
154:04 - let me write the actual
154:07 - url
154:12 - okay so we are storing in a string type
154:14 - variable i have named it a variable as
154:16 - actual url and i have written string
154:19 - actual url is equal to driver dot get
154:22 - current url okay
154:24 - now let me print this
154:33 - let's see the actual url of this webpage
154:36 - and then we will verify it first
154:39 - so let's run
154:45 - my chrome browser is launched
154:48 - it's
154:49 - navigated
154:51 - and the username and password has
154:53 - entered its login successfully
154:58 - and here it is
155:00 - this is my current url that i'm getting
155:02 - okay
155:03 - now i am on this page i'm on the
155:05 - dashboard page so that is the reason why
155:07 - i'm getting this url
155:09 - the current url retrieves the url of the
155:12 - current page okay your your on which
155:14 - page on that page the url will be
155:16 - retrieved
155:17 - so here we have printed the url now
155:19 - let's verify it
155:22 - so now i have to verify it right how how
155:25 - am i going to do that
155:26 - now
155:27 - i have already created a string variable
155:30 - that is the actual url in which i have
155:32 - got the current url of the web page
155:35 - now what i am going to do is i am going
155:36 - to create another variable of the string
155:38 - type in which i will store the desired
155:40 - url
155:41 - and i'm going to match both these url
155:43 - okay so this is what we're going to do
155:45 - it so first we will create a string type
155:50 - variable and i'm write it i'm going to
155:53 - write it as
155:54 - desired
155:56 - let's go url
155:58 - and i will
156:00 - paste this url that i am getting
156:06 - okay
156:08 - next
156:10 - i'm going to match this actual url and
156:13 - desired url
156:14 - for that i'll be using the if command
156:19 - simply i'll write the actual url dot
156:22 - equals
156:25 - the desired url
156:29 - now if they are equal what i'm going to
156:31 - print is i'm going to print
156:35 - pass
156:36 - and if they're not
156:38 - then i'm going to print
156:44 - fail
156:47 - okay
156:48 - so let's see
156:50 - let's run this command
156:56 - my chrome browser is launched
157:01 - it's
157:02 - navigated okay i've entered the valid
157:05 - username and password and it's
157:07 - successfully logging
157:10 - and here it is
157:11 - i have got the
157:14 - actual url is also retrieved by the
157:16 - current get current url command and also
157:19 - the actual url and the desired url
157:22 - both are matching so the uh output is
157:25 - passed now what if i change this url if
157:28 - i write
157:30 - rn.com so now let's run this command
157:35 - now you see the output will be fail
157:42 - it's launched is navigated
157:46 - browser is maximized valid username and
157:48 - password is entered and
157:51 - here it is on the dashboard page
157:54 - now let's see see
157:56 - here you can see the output it's failing
157:59 - why it's fail because i have changed the
158:01 - desired url the desired url that i want
158:03 - is the open source demo orange
158:06 - hrmlife.com and the actual url that i'm
158:09 - getting is this
158:10 - okay so that is the reason why it's fair
158:14 - so this is how you can verify the url of
158:16 - a web page
158:19 - next let's
158:21 - verify the title of the page
158:25 - okay
158:26 - similarly if you're going to verify the
158:28 - title of the page the same way for that
158:30 - the command that we will use is the
158:33 - get title command
158:38 - okay
158:39 - so what you're going to do is we're
158:40 - going to simply write string
158:44 - actual title
158:46 - that will be driver dot
158:49 - get title
158:51 - okay
158:53 - next
158:54 - let's print this title
158:58 - i'm going to write actual title
159:00 - [Music]
159:01 - and let's see
159:07 - my chrome browser is launched it's
159:09 - navigated
159:12 - valid username password is entered it's
159:15 - login
159:17 - okay
159:19 - so this is the title that i got the
159:22 - first one is the i got the current url
159:25 - then the test case that i have verified
159:27 - is par is failed because i have written
159:30 - the desired url that i want is this and
159:32 - the actual url that i'm getting is this
159:34 - the next one is that i'm printing the
159:36 - title of the page that is the orange hrm
159:38 - now how do we get the title simply just
159:40 - inspect this page
159:46 - and here in the head tag you can see the
159:47 - title here you can see it's orange hrm
159:49 - so this is the title of the page okay so
159:52 - this is this is the desired title that
159:54 - you want
159:56 - okay
159:57 - so what you're going to do is
159:58 - similarly we're going to write string
160:04 - desired
160:06 - title
160:08 - that we want is the
160:11 - orange hrm this title that we want is
160:13 - we're going to match this
160:16 - we're going to simply place it over here
160:20 - now we will verify it
160:23 - you will verify with the if command i'm
160:25 - going to write if
160:27 - the actual title dot equals
160:32 - and we're going to write the desired
160:33 - title
160:36 - and here we're going to
160:38 - write if my
160:41 - if my test case is passed
160:43 - then i'll write
160:44 - pass
160:46 - and if it's not if it's not matching
160:49 - then
160:50 - i'm going to write
160:54 - fail
160:59 - okay
161:00 - so now let's run
161:13 - okay now i've launched its login
161:17 - and we have login successfully
161:20 - let's see
161:21 - now here we can see the current url my
161:24 - test case is passed
161:27 - next i can see the title of the page
161:28 - that is the orange hrm and the desired
161:31 - title and the title that i'm getting
161:34 - the actual title they both are matching
161:36 - so the test case is passed what if what
161:38 - if i change this desired title
161:40 - and now let's see
161:44 - okay my chrome browser is launched it's
161:47 - navigated
161:50 - it's maximized and
161:56 - okay
162:00 - and here you can see it's failing
162:02 - okay
162:03 - so we have verified our title we have
162:06 - verified our url the next command that
162:08 - we're going to use is
162:10 - the
162:12 - driver dot
162:15 - close
162:18 - so this command is used to close the
162:21 - browser
162:28 - so let's
162:30 - run this again
162:31 - [Music]
162:35 - we have opened a chrome browser it's
162:37 - launched
162:38 - it's navigated
162:41 - it's maximized and
162:46 - log in successfully and here it says
162:48 - it's pass our
162:50 - the current url is retrieved the test
162:53 - cases of verifying the url is pass
162:56 - next the
162:58 - actual title of the web page is
163:00 - retrieved and the test cases fail
163:02 - because i have
163:03 - written only orange hr so let's change
163:06 - it and save it and let's run it again
163:13 - my chrome browser is launched
163:15 - it's navigated
163:18 - it's maximized the valid pass username
163:20 - password is entered and here it is okay
163:23 - and it's closed also
163:26 - so this is the current url
163:28 - the test case of verifying the url is
163:30 - passed this is the current title
163:33 - and the test case for verifying the
163:35 - title is passed
163:37 - so this is how you can verify the url
163:40 - and the title
163:42 - these are the different commands and the
163:43 - different commands that we learned today
163:45 - is one is the get current url then we
163:48 - learnt the get title
163:50 - also and we learned how to verify the
163:54 - commands okay so this is what we learned
163:56 - today we executed this test case we
163:58 - opened the chrome browser we navigated
164:00 - to the url we entered the valid username
164:03 - the valid password we clicked on login
164:05 - we
164:06 - verified the url we verified the title
164:08 - of the web page next we close the
164:10 - browser so we executed these test cases
164:14 - by executing these test cases we learned
164:16 - how to verify the title we learned how
164:18 - to verify the
164:20 - url also we learned different commands
164:22 - we learnt like the get title command and
164:24 - the get current
164:26 - url command okay so there is also one
164:29 - more command that i want to explain you
164:30 - is the get paid source command which is
164:32 - usually used to get the page source that
164:35 - is the source code of the page that we
164:37 - are on
164:38 - so these are some of the get commands
164:40 - that i'm explaining you these are
164:41 - frequently used by the automation
164:43 - testers
164:44 - so uh we're going to write the driver
164:47 - dot
164:48 - get page source
164:51 - and we're going to store this in an
164:52 - element
164:53 - sorry we're going to store this in a
164:55 - string type variable
164:59 - i'm going to write the page source that
165:00 - is ps
165:02 - and we're going to simply print it
165:10 - okay so let's run this
165:15 - so my chrome browser is launched this
165:18 - navigated and
165:21 - okay so here you can see that my source
165:23 - code that is the page source code is
165:25 - visible over here
165:28 - this is the source code that i have got
165:31 - okay
165:32 - so this is also one of the command which
165:34 - is used that is the get page source
165:37 - this is used to get the source code of
165:39 - the page that we are navigated to
165:42 - so in this tutorial we learned the three
165:44 - commands that is the get paid source we
165:46 - learned the get title and we learned to
165:48 - get current url
165:49 - okay
165:50 - so in the get source we learned that we
165:53 - uh through get page source we can get
165:56 - the page source we can get the source
165:58 - code of the page next we learn through
166:00 - get title command we learned how to get
166:02 - the title of the web page next we
166:05 - learned the get current url which is
166:07 - used to get the current url of the page
166:09 - so these were the three uh get commands
166:11 - that we learned in the today's tutorial
166:16 - so in the next tutorial we are going to
166:17 - learn about uh the xpath we are going to
166:20 - use the group plugin the crowpart plugin
166:22 - for the chrome browser
166:24 - and through that chrome brow crop path
166:27 - plugin we are going to uh retrieve our x
166:29 - part
166:30 - so we're going to study what are the
166:32 - different types of xpath also
166:34 - so in this tutorial you will understand
166:36 - about the xpath
166:38 - you will understand what is xpath how to
166:40 - locate the element using the xpath
166:43 - we will also understand about the crow
166:45 - path plugin the types of xpath what are
166:47 - their syntax
166:49 - then we will understand the difference
166:50 - between the absolute and the relative x
166:53 - path and out of the absolute and
166:55 - relative x path which one is preferred
166:58 - and why
166:59 - so let's get started
167:03 - first let us understand what is x path
167:06 - now as i said it is a part of a locator
167:10 - here you can see this chart right we
167:11 - have the different types of locators as
167:13 - i discussed in the previous tutorial i
167:16 - discussed about the id name link text
167:18 - the partial linked text the tag name the
167:21 - class name and then the css selector
167:24 - we are left with xpath now there are
167:26 - different types of xpath like the
167:27 - relative expert and the absolute xpath
167:30 - and it comes under the customized
167:31 - locators
167:32 - as i discussed in the previous tutorial
167:34 - locators are the way to find an html
167:37 - element on a web page
167:39 - expert is used when we don't have the id
167:43 - the name the tag name locators present
167:46 - in the html that is when we use xpath
167:49 - like here you can see in selenium
167:52 - automation if the elements are not found
167:54 - by the general locators like the id
167:57 - class name
167:59 - or the link text the partial link text
168:01 - the tag name etc
168:02 - then the xpath is used to find an
168:05 - element on the web page
168:07 - xpath is also defined as the xml path
168:10 - the shortcut the short name of xpath is
168:13 - the xml path
168:15 - now xpath is basically a syntax or a
168:18 - language for finding any element on the
168:21 - web page using the xml path expression
168:24 - as i said xml path is defined as the xml
168:28 - path right
168:29 - to find any element we use the xml path
168:32 - expression now this x path
168:35 - is the address of element using the html
168:38 - dom structure by using the html dom
168:40 - structure we will find the xml path
168:43 - expression now what is this html dome
168:45 - structure
168:48 - now here you can see we have the normal
168:50 - html code that we write usually we have
168:52 - the html head title body and we close
168:56 - the html tag this is the normal html
168:58 - code that we usually write
169:00 - but when a web page is loaded the
169:03 - browser automatically creates a dom
169:06 - structure that is the document object
169:08 - model
169:10 - here you can see this is the dom model
169:13 - like we have the document we have the
169:15 - html tag oh that is the root element
169:17 - then we have the head we have the title
169:20 - we have the body under body we have the
169:22 - different types of elements so this is
169:24 - the dom model that is the dom structure
169:27 - why it is called as a dom structure
169:29 - because
169:30 - the browser automatically creates a dom
169:32 - structure that is the nodes that is a
169:34 - different nodes are created
169:35 - automatically over here you can see we
169:37 - have the html head title is just simply
169:39 - written over here but over here we have
169:42 - the nodes there are nodes present over
169:43 - here so that is the reason why it is
169:45 - called the html dom structure and it is
169:48 - created automatically by the browser
169:50 - dom is basically an api interface that
169:53 - is provided by the browser
169:56 - now see if we go detailing into the dom
169:59 - structure it's a very huge concept but
170:01 - for now to understand that the x path
170:04 - the xml expression that we will derive
170:07 - we will derive from the html dom
170:09 - structure you know this structure that
170:11 - we have we will derive from this
170:13 - for example
170:15 - so this is the web page now if i want to
170:18 - uh inspect any of the element i'll
170:20 - quickly i simply click on inspect and
170:23 - here you see
170:24 - this is the dom structure of a web page
170:26 - like we have the html head body the html
170:29 - tag is closed inside head we have
170:33 - different types of meta property we have
170:35 - the style we have the script so all
170:38 - these are the
170:40 - so all these are in the form of the
170:43 - html dom structure
170:45 - okay
170:49 - so when a web page is loaded the browser
170:51 - automatically creates this dom object
170:54 - and
170:55 - this dom is an api interface that is
170:58 - provided by the browser
171:00 - okay
171:02 - next let us see how can we capture the x
171:05 - path
171:12 - now this is the page that we want to
171:14 - inspect now suppose this is the email
171:17 - address uh
171:18 - field we have and we want to inspect
171:20 - this element
171:21 - so i'll simply click on inspect and here
171:24 - you can see this text box is highlighted
171:26 - right
171:26 - now i'm i want to capture the x path of
171:29 - this text box how am i going to do that
171:32 - i will uh
171:34 - simply
171:36 - this syntax i will simply right click
171:38 - over here
171:39 - go to copy and i will click on copy full
171:43 - xpath see here i have two options i have
171:45 - copy xpath and i have copy full xpath so
171:48 - i will use copy full expert there is a
171:50 - difference between the two you will
171:52 - understand that later
171:54 - but for now let's
171:56 - click on copy full expat
172:00 - paste it over here
172:02 - okay
172:02 - so here you see
172:04 - this is the complete xpath that we are
172:07 - having
172:08 - for this field that is the email address
172:11 - how is it
172:12 - first we have the html then we have the
172:14 - body then we have the different div tags
172:17 - that we have over here and the last we
172:19 - have the input because we want to access
172:21 - this element we have the input tag over
172:23 - here
172:24 - now here you can see these numbers one
172:27 - two one
172:28 - these are the index numbers that is
172:31 - present over here
172:32 - okay these are the index number that is
172:35 - given away that is the first element of
172:37 - div under the first element of div i am
172:39 - selecting the second div under the
172:42 - second div i'm selecting the first dev
172:44 - as you can see there are different divs
172:46 - over here
172:47 - so uh through these uh acts by accessing
172:50 - these divs i have reached to input tag
172:52 - and over here i'm accessing the email
172:54 - address that is this field
172:56 - okay so this is how we can access uh
173:00 - so this is the first method of accessing
173:02 - the xpath the second method that we have
173:05 - is the pro path plugin
173:10 - okay so what we'll do is uh we'll simply
173:14 - go to google and type
173:15 - crow path plugin
173:18 - the very first link that we have i'll
173:20 - give the link in the description box
173:23 - just simply click add to chrome
173:28 - add extension
173:32 - and it is added
173:34 - okay
173:34 - now here you can see
173:37 - there is no option away of crow path but
173:39 - now uh let me refresh this page i'll
173:41 - just close this browser
173:45 - and here you can see we have the option
173:47 - crow path
173:48 - because we have added the extension to
173:50 - the chrome browser so we can see this
173:52 - option crow path
173:54 - okay now i inspected this element
173:58 - this element i have inspected so let's
174:00 - see the crow path
174:03 - and here it is
174:05 - so here you can see this crow path right
174:07 - uh we have the relative x path now as i
174:09 - said the x path are of two types that is
174:12 - the relative x path and the absolute x
174:14 - path
174:15 - then the css selector we have the hash
174:18 - id the hash is used for uh
174:20 - id write
174:21 - sorry the css directory that we have is
174:24 - the hash email now hash is used when we
174:26 - are accessing the id over here the id
174:28 - that we have is email or if you can see
174:31 - it's emailed
174:34 - here it is it's email okay
174:37 - next the absolute expire this is the
174:39 - absolute x bar that we are having
174:41 - and the tag name that we are using that
174:43 - is the input
174:45 - here you can see
174:46 - the crow path is basically used to find
174:49 - the x path of any element
174:51 - and it is mostly used because it is used
174:55 - to find the element move more precisely
174:57 - like suppose if i will copy this
175:00 - and here you can see the difference
175:03 - this x path is different from this x
175:05 - path why because we are indicating index
175:08 - number for each and every div that we
175:11 - have here you can see there is no index
175:13 - number for this three divs but over here
175:16 - we have the index number given over here
175:18 - why
175:19 - because uh
175:20 - crow path plugin is used to find the
175:23 - element more accurately okay
175:27 - that is the reason why we use crow path
175:29 - plugin there were previous plugins also
175:31 - that were used that is the firebug
175:32 - plugin the firepath plugin but they are
175:34 - outdated mostly crow path plugin is used
175:37 - by the companies
175:39 - and
175:40 - and the second most reason is that here
175:42 - you can see we have the relative x bar
175:44 - the css selector that it is selecting
175:46 - the tag name that it is using so all
175:49 - these things are present over here it is
175:50 - showing these things so whereas over
175:52 - here if we you can just simply copy
175:55 - full xpath and that's the option over
175:57 - here so that is the reason why we use
176:00 - the crow path plugin
176:02 - okay
176:03 - now this is one thing
176:05 - so the next thing that i want to explain
176:06 - is that suppose you have any of a
176:09 - expert suppose this is the expert that
176:11 - you have and you want to find the x bar
176:13 - this x part is of which element so what
176:15 - you're going to do is i'll simply copy
176:17 - this
176:19 - i will click on this source code control
176:21 - f here you can see find by string
176:24 - selector or xpath
176:26 - i will place my xpath over here and here
176:28 - you can see
176:29 - here it is
176:30 - i'm placing my password field over here
176:34 - this x path indicates the password field
176:36 - that i have so this is how also you can
176:38 - find the element through the x path
176:41 - and by using crow path you are finding
176:43 - the x path that is the absolute x bar
176:45 - and the relative x path as well okay
176:49 - okay so
176:50 - now you have got an idea of how to
176:52 - capture the x-path this is a small
176:54 - example of it which is very easier form
176:57 - now suppose this is the html syntax that
176:59 - i have for the username password and
177:01 - login button now if i want to access my
177:05 - login button through xpath
177:07 - if i want to click on this login button
177:08 - through my x bar
177:10 - so how am i going to uh capture the x
177:12 - path of this login button
177:15 - the very first thing that we have is the
177:17 - forward slash
177:19 - this forward slash is very important it
177:21 - is used to access the element okay
177:24 - forward slash and then first i'm
177:26 - accessing the html
177:28 - again a forward slash then i'm accessing
177:31 - the body tag
177:33 - again a forward slash then i'm accessing
177:35 - the form tag
177:37 - again a forward slash and then i'm
177:39 - accessing the input type that is the
177:41 - index three that is one two three the
177:44 - third input uh tag
177:47 - that i want to access because i want to
177:48 - click on the login button right here you
177:51 - can see the syntax it's input type
177:53 - submit name submit and the value is
177:55 - login this is the login button that we
177:58 - are having for this and i want to access
178:00 - this login button i want to click on
178:01 - this login button for that the x bar
178:04 - that we're going to use is this one
178:06 - over here the three indicates the index
178:08 - number that is the third input
178:10 - type
178:12 - that is the third input tag name i want
178:14 - to access so this is how you will write
178:17 - your x path
178:19 - so next now let us understand the
178:21 - different types of x path that is the
178:23 - relative x path and the absolute expo
178:25 - there are two types of x bar relative
178:27 - and absolute x bar
178:29 - let's see the absolute x
178:31 - now the absolute x path it contains the
178:34 - complete path from the root element to
178:36 - the desired element
178:38 - okay
178:39 - for example
178:41 - here you can see my root element is html
178:44 - and my desired element is this that is
178:47 - the input type submit name submit value
178:49 - login this is my desired
178:52 - okay so i want to i have to uh for
178:55 - absolute xpath i have to access from
178:58 - root element to the desired element
179:02 - that's what i'm doing over here i'm
179:04 - writing a forward slash that is only one
179:07 - forward slash
179:08 - then i'm accessing html again a forward
179:11 - slash then i'm accessing body
179:13 - again a forward slash i'm accessing form
179:16 - then in form tag i want to access the
179:18 - third input
179:20 - tag how i will write my xml path
179:23 - okay this is the xml path expression
179:25 - that i discussed before
179:27 - next it says that it starts with a
179:29 - single slash
179:31 - here you can see it is started with a
179:33 - single slash over here from root element
179:35 - to the desired element
179:38 - next uh let us discuss is advantages and
179:40 - disadvantages the advantage of absolute
179:42 - xpath is that it identify identifies the
179:45 - element very fast
179:47 - now obviously over here you are writing
179:49 - the
179:51 - complete path
179:53 - like we are writing
179:54 - html slash body slash form slash input
179:57 - the third index we are writing the
179:59 - complete path because of this it is
180:01 - accessing the element very faster okay
180:04 - that is the advantage of absolute x path
180:08 - whereas the disadvantage now for this
180:10 - we'll take up an example so that it will
180:12 - be easier for you
180:14 - so this is the page that you have that
180:16 - is the username and password and the
180:18 - login page that you have for that you
180:19 - have written the html syntax right
180:22 - now what if the developer wants to make
180:24 - some changes on this page it wants to uh
180:27 - suppose a developer wants to enter
180:28 - another field
180:30 - of email
180:33 - so
180:34 - here it is username password email i
180:37 - have written another uh
180:40 - syntax over here that is the input id
180:42 - email type text okay so the developer
180:45 - has entered another uh
180:48 - text field over here of email
180:50 - and i have to access the login and i had
180:53 - written the xpath before this one right
180:56 - this is the expert that i had written
180:57 - before
180:58 - so is it possible to access the login
181:01 - now after making this changes no right
181:05 - this was the previous expert that i had
181:07 - written for the login button
181:10 - for that
181:11 - this was the syntax i'm accessing the
181:13 - third element of input
181:16 - that is the login right over here
181:19 - i am accessing the third element of
181:21 - input which is the email id right it is
181:23 - the email id that is present over here
181:26 - so this is the biggest disadvantage of
181:28 - absolute xpath
181:30 - that is if there are any changes that is
181:33 - made by the developers in the path of
181:36 - the element then our written expat will
181:38 - no longer work as you saw in that
181:41 - example
181:43 - i had written the expert for the login
181:45 - but when the changes were made by the
181:47 - developers the expert did not work for
181:50 - the
181:51 - login button because at that place the
181:54 - third element of input tag was the email
181:57 - id
181:58 - okay
181:59 - so this is the advantages of the
182:01 - absolute x-path
182:04 - so now let's discuss about the relative
182:05 - x-path
182:07 - now a relative x-path is the one where
182:09 - the path starts from the middle of the
182:12 - html dom structure of your choice your
182:15 - there is no root note there is no
182:16 - desired node you can simply uh start the
182:19 - path where you want to of your choice
182:22 - wherever you want to start so basically
182:24 - it means that it can search for the
182:26 - element anywhere on the web page okay
182:28 - and it starts with a double slash
182:30 - whereas the absolute x path starts with
182:32 - a single slash
182:34 - it has a syntax and this is the basic
182:37 - syntax of the relative x path
182:41 - first we have the double slashes then we
182:44 - have the tag name the stack name can be
182:46 - div image input etc anything
182:49 - okay then uh we will open the brackets
182:52 - and then we have the add the rate this
182:54 - add the rate is used to select an
182:56 - attribute we will write the attribute
182:59 - name and we will write the value of this
183:01 - attribute okay for example
183:04 - i have written first the two the forward
183:08 - slashes i need the double forward
183:09 - slashes
183:10 - then i need input
183:12 - that is the tag name i'll open my
183:14 - brackets at the rate the attribute that
183:17 - i'm using is id and the value of this
183:19 - attribute is email
183:21 - so this is the basic syntax of xml that
183:24 - is the relative xml and this is most
183:26 - frequently used as compared to the
183:28 - absolute xml
183:31 - why we will discuss that later
183:37 - so the advantages of relative x path the
183:40 - first advantage is that you don't need
183:41 - to mention the long x bar the long x bar
183:43 - that is the absolute x path is from the
183:45 - root element to the desired element
183:47 - right so over here you don't need to
183:49 - mention this long x path because there
183:51 - is no
183:52 - need to start from the root element you
183:54 - can start
183:55 - middle at you the path can start from
183:58 - the middle of the html dom structure
184:00 - that is of your choice
184:02 - but the disadvantage is that it will
184:04 - take more time in identifying the
184:06 - element as we are specifying the partial
184:08 - path and not the exact exact part
184:12 - whereas in absolute x path we are
184:14 - specifying the exact path of the element
184:18 - over here we are specifying the partial
184:20 - path of the elements so that is the
184:22 - reason why it takes time in processing
184:25 - so here we have some of the examples of
184:27 - the relative x path like first you can
184:29 - see i have the two double slashes the
184:32 - tag name that i have used is a
184:34 - then this is the at the rate sign the
184:36 - attribute is hereif and the value of the
184:39 - attribute that i have given over here
184:41 - next i have the two double slashes and i
184:44 - have used the image that is the img uh
184:47 - tag name then i have the add the rate
184:50 - sign and the attribute that i'm using is
184:52 - alt and the value of this is flower so
184:55 - these are some of the examples
184:57 - now if you want to access a x part with
184:59 - multiple attributes what if we have
185:01 - multiple attributes like suppose there
185:05 - might be a
185:06 - syntax where the name value the name the
185:09 - value of the name is similar so what
185:11 - we'll do is we'll use multiple
185:12 - attributes we'll use id with that
185:14 - because id is never same it is not the
185:17 - same for every element it is different
185:20 - id is unique right so what i'm going to
185:22 - do is i'm going to use id that is over
185:25 - here is name and also the name attribute
185:27 - that is the name value so by using these
185:29 - multiple attributes value i can access
185:32 - the element more properly right so the
185:34 - syntax of this is tag name or the two
185:36 - double slashes tag name open bracket at
185:39 - the rate attribute one is equal to value
185:41 - one and then the attribute two the value
185:43 - two similarly like attribute three value
185:46 - three so you can go on
185:48 - as you wish okay so this is a way of
185:50 - accessing multiple attributes
185:52 - in relative x path
185:55 - so now let's study the difference
185:56 - between the absolute x path and the
185:58 - relative exponent
185:59 - now the absolute x path it contains the
186:01 - complete path from the root element to
186:03 - the desired element as we studied from
186:06 - the root element that is the html and
186:08 - the desired element that we wanted that
186:10 - is the login button we have the
186:12 - input tag right the input third index
186:15 - so it contains the complete path from
186:18 - the root element to the desired element
186:20 - whereas the relative x path
186:22 - is the one where the path starts from
186:25 - the middle of the html dom structure of
186:27 - your choice you can start from your
186:29 - choice
186:31 - okay
186:33 - it starts with a single forward slash
186:35 - whereas over here in later it starts
186:37 - with the doubles forward slash
186:40 - in absolute x path not used more often
186:43 - because it selects
186:46 - element from the root node
186:48 - whereas the relative x path is used very
186:50 - often because it searches the element
186:52 - everywhere at the web page
186:54 - okay
186:57 - next we have in absolute x bar there is
186:59 - no attribute value over here the syntax
187:01 - that i had shown before
187:06 - like this is the syntax of the xpath
187:08 - here we have the attribute value right
187:11 - we are using the value of the attribute
187:13 - and the attribute name
187:14 - whereas in absolute x path there is no
187:17 - such case there is no attribute value in
187:19 - relative we use the attribute and the
187:21 - value of it
187:24 - this is the basic example of the
187:26 - absolute expert and this is the example
187:27 - of the relative x path
187:30 - [Music]
187:32 - so this is the difference between the
187:33 - absolute x pi and the relative x part so
187:36 - we know x path are of two types but
187:38 - which one is mostly preferred
187:41 - obviously the relative x path is mostly
187:43 - preferred
187:44 - why
187:45 - because if the application is not very
187:48 - stable like if the application is not
187:50 - stable and all the attributes are not
187:52 - stable
187:53 - so we are not we cannot use the absolute
187:56 - expert why because the developer might
187:58 - make changes frequently right it's not
188:00 - stable so the developer will make
188:02 - changes the expat will keep on changing
188:04 - so that is the reason why absolute xpath
188:07 - is not mostly used by the automation
188:09 - testers whereas the relative xpath is
188:11 - mostly used by the automation testers
188:14 - because in relative xpath the attributes
188:16 - used are fixed they are not changing we
188:19 - are not using the root element to the
188:21 - desired element
188:22 - okay so that is the reason why we use
188:24 - the relative x path and not the absolute
188:27 - x path
188:29 - so in the previous tutorial we learnt
188:31 - about the x path what is x path and the
188:33 - different types of x path that is the
188:35 - absolute x path and the relative
188:36 - exponent also we learned the difference
188:38 - between the two so in this tutorial we
188:41 - will understand about the x path
188:42 - operators and functions
188:45 - so let's get started
188:48 - so previous uh tutorial we learnt about
188:50 - the relative xpath and the absolute
188:52 - expert let's implement that first on our
188:55 - intelligent idea id so open your
188:57 - intellij idea
189:01 - so i will create a new
189:04 - java class
189:05 - i'll name it as
189:07 - selenium
189:09 - tutorials
189:11 - six
189:15 - okay
189:16 - so all i want to do is this is the
189:18 - website like the ebay.com i'll all i
189:21 - want to do is i want to uh inspect this
189:23 - search box and the search button okay
189:27 - so for that in the previous tutorial i
189:29 - explained about the crow path plugin
189:31 - now we're going to use the selectors hub
189:33 - plugin see the selectors hub plugin is
189:35 - the advanced version of the crow path as
189:37 - the crow path is not having some of the
189:39 - features which this selector hub
189:42 - plugin is having so what we'll do is how
189:45 - to install is
189:46 - write
189:47 - selectors hub xpath
189:51 - the first link that you get over here
189:53 - i will provide the link in the
189:54 - description box
189:56 - simply just click to add to chrome
190:01 - add extension
190:05 - and your selectors hub is added to your
190:07 - chrome browser
190:09 - so since we have
190:11 - installed our selectors hub plugin xpath
190:14 - on our browsers so i'll just close this
190:16 - and i'll open it again
190:23 - so let me inspect this i'll inspect
190:28 - and here you can see we have the
190:29 - selectors hub
190:31 - present over here
190:35 - okay
190:36 - so now
190:37 - all i want to do is i want to inspect
190:39 - this search box and the search button i
190:41 - will write the x path for the search box
190:43 - and the search button the absolute
190:45 - expert as well as a relative expert so
190:48 - let's do it
190:49 - okay so i have created this uh selenium
190:51 - tutorial 6 this is the java class that i
190:53 - have created in my selenium package the
190:56 - first statement that i have written is
190:58 - to open the chrome browser that is the
191:00 - system.set property in which i have
191:02 - given the key value
191:04 - and the value of the that is the path of
191:06 - the executable driver
191:09 - next i have written the web driver
191:10 - driver is equal to new chrome driver
191:12 - next i have to navigate to the url that
191:15 - is the url i have given over here
191:17 - next i am maximizing the window through
191:20 - driver.manage.window
191:23 - okay so these are the three commands
191:25 - which is uh
191:26 - same in all the tutorials till now
191:29 - you want to locate the search box right
191:31 - through relative xpath and absolute
191:33 - expert let's first do the absolute x
191:35 - path
191:40 - [Music]
191:42 - okay so simply i'll just write driver
191:45 - dot find
191:46 - element
191:48 - by dot
191:49 - x path
191:51 - and i will write the absolute x path
191:53 - over here
191:56 - let me inspect this element
191:58 - here it is and here you can see we have
192:00 - the re relative x path we have the id
192:03 - name
192:04 - class name
192:05 - uh javascript path the absolute xpath
192:08 - and the tag name that is given over here
192:10 - in selectors hub we have
192:12 - many features there are a lot of
192:14 - features provided in selectors hub as
192:16 - compared to the crow path plugin the
192:18 - crowbar plugin is not having that much
192:20 - of features in it so that is the reason
192:22 - why uh selectors hub is mostly used by
192:25 - many automation testers also it supports
192:27 - the uh shadow dom objects now uh when i
192:30 - will be explaining about the shadow dome
192:32 - at that time we will be using it but for
192:34 - now uh
192:36 - let us focus on the absolute path in the
192:38 - relative expat that we are doing right
192:40 - now
192:42 - so this is the absolute x bar that we
192:44 - have i'll simply click on copy
192:49 - and here it is
192:52 - i want to send some command to it so
192:54 - i'll write send keys
192:56 - and i'll write
192:58 - t-show
193:05 - okay so
193:07 - let's run this
193:09 - so let's run this
193:11 - i'll simply click on run
193:16 - chrome browser is launched
193:19 - it's navigated
193:21 - the browser is maximized
193:24 - and here you can see on the search box
193:25 - we have t-shirts written over here okay
193:31 - so next uh what i want to do is i want
193:33 - to inspect this element that is i want
193:35 - to click on the search button okay so i
193:37 - will inspect this element
193:41 - and here you can see we have the
193:42 - absolute xpath as well as the relative
193:44 - expat we will choose the absolute xpath
193:47 - but
193:51 - here we'll write driver
193:53 - dot find element
193:55 - by dot x path and i will write my
194:00 - absolute x path
194:04 - over here
194:05 - and what i want to do is i want to click
194:07 - right so i will right click
194:17 - so here it is i am sending some command
194:19 - to the search box that is the t-shirt
194:20 - command and then i am clicking on the
194:23 - search button
194:24 - so let's run this
194:31 - chrome browser is launched
194:34 - it's navigated the browser is
194:36 - maximized t-shirts and here it's clicked
194:43 - okay
194:44 - so it's working properly
194:46 - now let's do with a relative xpath
194:51 - i'll commend this
194:54 - okay so now we'll do it
194:56 - relative
194:59 - xpath
195:01 - i'll write driver
195:03 - dot find element
195:05 - by dot
195:07 - x path and i'm going to mention my
195:09 - relative x path over here
195:12 - so as for the search box
195:15 - here it is we have the relative x path
195:18 - which is written over here
195:19 - and simply copy this
195:21 - and paste it over here okay so be
195:23 - careful with this syntax we have only
195:25 - the single quote over here there is no
195:27 - double quote because java does not
195:29 - support double quotes so if you mention
195:31 - double quote over here
195:32 - it will not support
195:35 - here you see right it's in red color so
195:37 - that's the reason why java does not
195:39 - support
195:40 - double uh inside double quotes another
195:42 - double quote so that's the reason why
195:44 - we're writing with single quotes okay
195:48 - so be careful with that
195:50 - now this is the relative expert for the
195:52 - search box and what i want to do is i
195:54 - want to send some key right so i will
195:56 - write
196:00 - shows over here
196:05 - so i'll write shirts for men okay
196:08 - next i want is i want to
196:10 - inspect the
196:12 - search button right for that i'll write
196:14 - fine element
196:15 - by dot x path
196:21 - this is the search button let me inspect
196:23 - it
196:25 - and here you can see we have the
196:26 - relative expert given over here right so
196:29 - i'll copy it
196:32 - paste it over here and what action do i
196:34 - need to perform is i want to click on
196:35 - that button right so i will write click
196:39 - ok
196:42 - let's see if this runs
196:46 - chrome browser is launched
196:50 - it's navigated
196:51 - and it's maximized it's written shirts
196:53 - for men
196:58 - and here it is
196:59 - okay so it's working properly
197:02 - so this is how you can inspect element
197:04 - through absolute expat and the relative
197:07 - x path ah the difference between the
197:09 - absolute expired and the relative expert
197:11 - we studied about that in the previous
197:12 - tutorial also their advantages and
197:14 - disadvantages
197:16 - okay so in this tutorial mainly we will
197:18 - understand about the
197:20 - xpath operators and their functions
197:25 - so the first thing is or operator now
197:27 - when we implement this uh practically at
197:29 - that time you will understand it very uh
197:31 - properly so first let us understand the
197:34 - syntax of it as in the previous tutorial
197:37 - i explained about the expert with
197:38 - multiple attributes
197:40 - here you can see
197:42 - that is the two slashes over here the
197:44 - tag name that we want that is input a or
197:46 - any of the tag name at the rate
197:48 - attribute 1 is equal to value 1 at the
197:50 - rate attribute 2 is equal to value 2 and
197:52 - so on this is how we will write x bar
197:55 - with multiple attributes now with the
197:57 - help of these multiple attributes we are
197:59 - inserting some of the operators of x bar
198:02 - that is the or operator and the and
198:05 - operator
198:06 - like here you can see we have the two
198:08 - slashes over here the tag name that
198:10 - we're using that is the input
198:13 - at the rate id the attribute that we are
198:15 - using is id and the value of it is the
198:17 - search underscore query
198:19 - or the or operator which i have written
198:22 - over here
198:23 - then the second attribute that i am
198:25 - using at the rate name
198:27 - and the value of it is search okay so
198:29 - this is how we will write the syntax
198:31 - with the operator in equilibrium x path
198:35 - now we will implement this method and
198:36 - then you will understand this table
198:40 - so i will just
198:42 - comment this
198:47 - okay
198:48 - so now what i want is i will inspect
198:50 - this element and i'll uh try to send
198:52 - some of the keys of it like i'll write
198:54 - t-shirts for men over here so let's see
198:56 - if the element is identified or not
198:59 - okay i'll click on inspect
199:03 - okay so in this syntax here you can see
199:05 - we have the id attribute as well as the
199:08 - name attribute present over here
199:10 - okay so first
199:13 - let me write
199:15 - driver
199:16 - dot
199:17 - find element
199:19 - by
199:20 - dot x path
199:22 - and here i will write my relative
199:25 - x path so first the two slashes
199:28 - the tag name that i want is input
199:32 - open bracket
199:34 - first i am going to write
199:37 - at the rate
199:39 - id
199:41 - so the value of the id
199:44 - is this here you can see
199:48 - so let me copy this
199:50 - next i'm going to write or
199:54 - then i'm going to write
199:56 - add the rate name attribute
200:01 - the value of the name attribute
200:06 - that is this
200:08 - i will just simply copy it
200:10 - paste it over here
200:12 - dot
200:14 - send keys and whatever keys i want to
200:16 - send is short
200:18 - for
200:20 - men
200:21 - and let's see whether we can locate this
200:23 - element or not
200:30 - so a chrome browser is launched
200:32 - it's navigated
200:35 - it's maximized and here you can see
200:38 - shirts for men that means this search
200:40 - box is located through our operator
200:43 - okay
200:45 - so now here you can see
200:49 - this a part the id part at the rate id
200:53 - is the a
200:54 - at the rate name is the b part right now
200:57 - if both the elements are true that means
200:59 - the return the element is identified and
201:01 - it returns both the element right now
201:03 - what if
201:04 - my first element is true and the second
201:07 - element is false it returns a so let's
201:09 - check this out
201:13 - that means at the rate id is equal to
201:16 - this value is correct whereas this value
201:18 - is not correct now let's see what
201:20 - happens
201:22 - whether we are able to locate the
201:24 - element or not
201:26 - so i click on run
201:33 - my browser is
201:35 - navigated
201:38 - it's maximize and here you can see
201:39 - shirts for men
201:41 - the search box is inspected it is
201:43 - identified
201:45 - even though if my name attribute the
201:47 - value of the name attribute is not
201:48 - correct okay
201:50 - now what if my ad id value is not
201:52 - correct like if i write this gh
201:55 - let's see whether we can identify the
201:57 - element or not
202:00 - my chrome browser is launched
202:02 - it's navigated
202:05 - it's maximized
202:06 - and here you can see shirts for men
202:09 - it's identified
202:11 - okay
202:12 - now what if the id value is wrong and
202:16 - even the name value is wrong
202:18 - let's see if the element is identified
202:20 - or not
202:26 - so our chrome browser is navigated and
202:28 - it's maximized
202:33 - and here you can see there is no element
202:35 - over here there is no key sent over here
202:37 - that is the shirts for men
202:38 - why because my id value as well as the
202:40 - name value is wrong okay
202:43 - so this is what the
202:45 - or operator is
202:47 - if my a element that is the id value
202:50 - is wrong as well as the name attribute
202:53 - value is wrong that means it's not the
202:55 - same as it is specified in the html dom
202:57 - structure the element will not be
202:59 - identified
203:00 - whereas if my id value is wrong but my
203:04 - name value is correct the element is
203:06 - identified similarly if my a value that
203:10 - is the id value is right whereas my name
203:13 - value is wrong
203:14 - still the element is identified and if
203:17 - both are right the element is identified
203:19 - but if both are wrong the element is not
203:21 - identified so this is all about the or
203:23 - operator
203:25 - now let's check out the and operator
203:28 - okay it's the same as it is or only the
203:30 - rules are bit different you will
203:32 - understand that practically
203:34 - so we are testing for and operators so
203:36 - i'll just write and over here
203:40 - let's see so the id value is same and
203:42 - the name value is also correct so let's
203:44 - see if it is inspected the element is
203:46 - inspected or not let me comment this
203:49 - okay
203:51 - all right
203:58 - when chrome browser's launched it's
204:00 - navigated it's maximized and here you
204:02 - can see the
204:03 - shirts for men
204:05 - the search box is inspected as well as
204:08 - the command is sent that is the shirts
204:09 - for women so this means this uh line
204:13 - this
204:14 - driver.fine element this function that
204:16 - we have written works well okay now what
204:19 - if if i just
204:21 - write the id value wrong whereas the
204:24 - name value the value of name attribute
204:26 - is correct okay so let's see if the
204:29 - element is identified or not
204:32 - so my chrome browser is launched
204:35 - it's navigated
204:38 - it's maximized
204:43 - okay there is no
204:44 - command sent over here
204:47 - okay so if my id is wrong
204:51 - and my name is right that means the
204:54 - element is not identified
204:56 - what if my id value is correct whereas
204:59 - the name value is wrong
205:02 - let's see if the element is identified
205:04 - or not
205:08 - my chrome browser is launched
205:10 - it's navigated
205:13 - and it's maximized
205:18 - okay so here you can see that my search
205:20 - box is not
205:22 - identified and there is no command sent
205:24 - over here
205:25 - so your element cannot be identified if
205:27 - the id value is right and the name value
205:30 - is wrong as well as the id value is
205:32 - right wrong and the name value is right
205:34 - both of the ways the i
205:36 - the element is not found what if
205:39 - both of them are wrong
205:40 - let's see
205:41 - let me inspect it
205:43 - click on run
205:45 - chrome browser is launched
205:47 - it's
205:48 - navigated it's maximized
205:52 - and here you can see there is no command
205:54 - sent over here
205:57 - okay
206:01 - so what this basically means is
206:06 - if the a element that is the id
206:08 - attribute is having the wrong value
206:11 - as well as the name attribute is having
206:13 - the wrong value the element is not
206:15 - identified
206:18 - similarly if the a attribute that is the
206:20 - id attribute is having the wrong value
206:22 - and the name attribute is having the
206:24 - right value still the element is not
206:26 - identified
206:28 - if the a attribute is having the correct
206:30 - value whereas the b attribute is having
206:32 - the wrong value still the element is not
206:34 - identified
206:35 - in case of and operator the element is
206:37 - only identified if the id attribute is
206:40 - correct as well as the name attribute
206:43 - value is correct only then the element
206:46 - is identified so that is the difference
206:48 - between the and operator and the or
206:50 - operator like here you can see
206:52 - the element is identified in all the
206:54 - cases except if both the uh attribute
206:58 - values are wrong okay whereas over here
207:01 - it is
207:03 - the element is identified in only one
207:05 - case that is both the id as well as the
207:07 - name attribute value should be correct
207:10 - that is it should be the same as it is
207:12 - mentioned in the html dom structure
207:15 - so this is the difference between the or
207:16 - operator and the and operator
207:19 - so the next function that we're going to
207:21 - study about is the contains function
207:24 - now the contains is used to identify an
207:26 - element all the functions that we
207:28 - studied till now of x path are used to
207:30 - identify an element
207:32 - when we are familiar with some part of
207:34 - the attribute value of an element
207:37 - now this means that when we are familiar
207:39 - with some part of the attributes value
207:42 - that is for example let me show you the
207:44 - normal syntax of the relative x bar that
207:47 - we write is this right
207:49 - two
207:50 - two slashes the tag name add the rate id
207:52 - and the value like over here you can see
207:55 - two slashes input at the rate id and the
207:58 - value that i have written is the first
208:00 - name
208:01 - now what if you want to use the contains
208:03 - method when we are using the contains
208:05 - method we will write add the rate id
208:08 - comma first that is only the partial
208:11 - text i will write in contains method i
208:13 - don't need to write the full text
208:16 - so this is a feature of contains
208:20 - the next function that we're going to
208:21 - study is the starts with function now
208:24 - see all these functions that we are
208:26 - studying they are used dynamically for
208:27 - dynamic uh elements they are used now
208:30 - what are dynamic elements there are two
208:31 - types of elements one is dynamic and one
208:33 - is static static elements are elements
208:35 - whose attributes value does not change
208:38 - the value of the attribute does not
208:40 - change
208:41 - whereas the dynamic elements are the
208:43 - elements whose attribute value changes
208:45 - on refresh or any of the operation of
208:48 - the web page like if we click on that
208:49 - element the value changes
208:51 - for example let us take up the start and
208:54 - the stop button like this is the button
208:56 - if i click on start
208:59 - the function will start
209:00 - but after start the button changes to
209:03 - stop
209:04 - and when i click on stop
209:06 - the function will stop and the button
209:07 - will change the value will change to
209:09 - start so this is how this this is what
209:11 - is the dynamic working of the
209:14 - uh
209:15 - of the elements on the web page now for
209:17 - example like over here you can see we
209:19 - have the button like start and the stop
209:22 - if i want to inspect the start button i
209:24 - want to uh
209:26 - identify the start element what i'm
209:28 - going to do is i'm going to write slash
209:30 - input two slashes input at the rate id
209:33 - is equal to start
209:34 - this will identify this will locate the
209:36 - start button only and not the stop
209:39 - button
209:40 - because after clicking on start
209:42 - the value is changing to stop right so
209:45 - it will only identify the start button
209:47 - what about stop
209:49 - so for that i have to write input at the
209:51 - rate id is equal to stop over here also
209:53 - it is identifying only the stop button
209:56 - and not the start button
209:58 - so in this case we will use the start
210:00 - smith operation
210:01 - now here you can see there are two
210:03 - things there are two words in common
210:05 - right the s t
210:07 - s and t these are the two words that are
210:09 - in common over here so what i'm going to
210:11 - do is i'm going to use a starts with
210:13 - function i'm going to write starts with
210:15 - either rate id and sd
210:17 - in this case it will detect the start
210:20 - operation as well as the stop operation
210:24 - so this is the advantage of start swipe
210:27 - like here you can
210:29 - like here you can see
210:31 - start with find the element whose
210:33 - attribute value changes on refresh or
210:36 - any operation on the web page like
210:38 - clicking the uh in the element on the
210:40 - web page
210:41 - now in this expression matching the
210:43 - starting text of the attribute used to
210:46 - find the element whose attribute changes
210:48 - dynamically
210:49 - here's the attribute value this is the
210:52 - attribute value right that start and the
210:53 - stop this attribute value is changing
210:55 - dynamically right
210:57 - so this is what we're going to do we are
210:58 - going to match the starting text of the
211:00 - attribute values this is the starting
211:03 - text which is the similarity
211:05 - so always keep in mind that the
211:07 - starting value of the attribute should
211:09 - be similar
211:10 - then only starts with function will work
211:13 - we can also find element whose attribute
211:14 - value is static which does not change
211:17 - but this works uh properly with dynamic
211:19 - functions okay
211:22 - so let's implement this first
211:25 - now this is the page this is the element
211:26 - that i want to inspect
211:30 - i'll click on inspect and here it is so
211:33 - what i'm going to do is i'm going to
211:34 - write the
211:36 - x path over here okay
211:38 - for contains method
211:41 - so let me write two slashes the tag name
211:45 - input
211:48 - then contains
211:51 - open brackets
211:53 - the rate i'll use
211:59 - i'll use name let me use name attribute
212:03 - so i'll write
212:04 - name
212:06 - comma
212:07 - single quotes
212:10 - underscore
212:12 - nkw
212:14 - here you can see
212:15 - this value
212:17 - let me copy this
212:23 - and close the bracket
212:24 - close the back
212:26 - and here you can see we have one element
212:28 - matching which shows one element
212:30 - matching this element is matching it is
212:32 - highlighted right so this is the element
212:34 - which is matched over here now if i'm
212:36 - using contains as i said i can use
212:37 - partial text right so what i'll do i'll
212:40 - just remove w
212:41 - and still you can see one element
212:43 - matching
212:45 - and still you can see one element
212:46 - matching i remove i remove the k as well
212:50 - so
212:50 - let's see if it is detecting this
212:52 - element or not i will copy this
212:57 - right driver
213:00 - dot
213:03 - find element
213:05 - by dot x path
213:08 - and i will mention this
213:12 - and i want to
213:14 - send some
213:15 - value to it so i'll write
213:19 - shirts for
213:21 - kids
213:22 - my chrome browser is launched
213:26 - it's navigated
213:30 - it's maximized and here you can see we
213:33 - have the value written away shirts for
213:35 - kids so this means that the search box
213:38 - that i have inspected over here through
213:40 - contains method is working properly okay
213:43 - we can locate the element over here so
213:46 - this is how we will use contains method
213:47 - now if i use
213:50 - starts with
213:53 - i'll just simply remove this contains
213:55 - and write
213:56 - starts with
213:58 - and here you can see
214:01 - uh so since uh
214:03 - selectors hubs gives us the feature of
214:05 - writing the x path over here as well in
214:08 - the uh expired the text box so i have
214:11 - written a input starts with at the rate
214:14 - name and here you can see it is starting
214:17 - with underscore n right so let me write
214:19 - underscore
214:21 - and here you can see we have one element
214:23 - matching now what if i remove n
214:25 - and here you can see we have three
214:27 - elements matching which is matching to
214:29 - underscore you can see
214:30 - the uh three elements are given over
214:32 - here the first element is over here this
214:35 - is the second element and this is the
214:37 - third element
214:38 - since we are inspecting this third
214:40 - element so i'll just include n see it
214:42 - doesn't matter where your what type of
214:45 - value you're writing over here
214:47 - these functions are used only for
214:48 - dynamically functions now in the next
214:50 - tutorial when you learn about the
214:52 - advanced x path there you will see many
214:55 - dynamic elements so at that point we
214:57 - will use starts with metal okay
215:00 - i'll just copy this element
215:02 - and let's see if it's working well or
215:04 - not
215:05 - driver dot
215:06 - fine element
215:08 - y dot x path
215:10 - and here i will include the element
215:14 - now let me send some keys
215:16 - t-shirts for
215:20 - kids
215:21 - let me comment this
215:24 - and let's see if it's working well or
215:26 - not
215:29 - so our chrome browser is launched
215:31 - it's navigated
215:33 - and
215:34 - it's maximized and here you can see
215:36 - t-shirts for kids this means that my
215:39 - search box the element that i want to
215:41 - inspect that is the search box is
215:43 - inspected through
215:44 - these starts with method okay see i'm
215:47 - here i'm just showing the demo of using
215:50 - these functions that how you can use
215:51 - these functions
215:55 - the next method that we're going to
215:56 - understand is the
215:58 - the next function that we're going to
216:00 - study is the text function
216:02 - now see text is an inbuilt function of
216:05 - the selenium webdriver and it is
216:07 - frequently used and it is one of the
216:08 - most popular expat function that is used
216:11 - and it is basically used to locate
216:13 - elements the elements that we want to
216:15 - locate right based on the text of the
216:18 - web element like here you can see we
216:20 - have the user id
216:22 - and the element that i want to locate
216:23 - this is the text box that i want to look
216:25 - at the text of the web element the text
216:28 - of the web element is the user id over
216:30 - here by using this this text i am going
216:33 - to identify this web element okay this
216:36 - is what text function is
216:39 - over here like you can see uh like if i
216:41 - inspect this element this is the element
216:43 - that i'm inspecting we have the td tag
216:46 - inside the tr tag we have the td a line
216:49 - is equal to right and the text that is
216:51 - used that is a user id so if i want to
216:53 - inspect this element how i am going to
216:55 - write is the two slashes td
216:58 - the text function the text the value of
217:00 - the text function is the user id this is
217:03 - how i'm going to write the text function
217:05 - okay so let's uh
217:08 - do this let's
217:10 - do the demo of this
217:12 - i'll comment this
217:14 - so this is the cell link that i want to
217:16 - click on so what i'm going to do is i'm
217:18 - going to inspect this element
217:20 - and i'll write the x path over here
217:24 - the tag that we're using is the a tag
217:27 - it's a link
217:28 - so a tag and i'm going to write text
217:31 - here you can see
217:34 - okay so here we can see that is the one
217:36 - element matching so i'm going to copy
217:37 - this
217:38 - x path
217:40 - and i'll paste it over here that'll
217:41 - write driver
217:43 - dot find element
217:44 - by dot
217:46 - x path
217:48 - paste it over here and the operation
217:50 - that i want to perform is i want to
217:51 - click on this link okay
217:53 - so let's see
217:56 - so our chrome browser is launched
218:01 - it's navigated
218:04 - and it's maximized and here you can see
218:06 - the cell
218:07 - link is clicked okay
218:12 - now suppose if i want to use the
218:14 - contains
218:16 - and the text method both of them i'll
218:19 - write contains
218:24 - open bracket then i'll write text
218:27 - function
218:29 - comma
218:30 - then i'll write
218:32 - a cell
218:40 - close your brackets
218:44 - and here you can see
218:51 - here you can see we have six elements
218:53 - that is matching it
218:56 - sell
218:57 - sell
219:00 - sell
219:00 - selling
219:03 - then we have saved sellers
219:05 - then sell
219:07 - sellers information center seller
219:09 - information center now see
219:11 - here you can see we have used the
219:13 - contains method when we were using the
219:15 - text method only one element was
219:17 - identified but when we are using the
219:19 - contains method the six elements are
219:21 - matching this means the cell this cell
219:25 - word that we're using
219:27 - see here i have used the contains method
219:30 - if i'm using contains method i'm finding
219:32 - six elements
219:34 - when i was using the text method only i
219:36 - found only one element matching whereas
219:39 - if i'm using the contains method there
219:41 - are six elements that is matching over
219:42 - here why
219:43 - because in all these matching elements
219:46 - there are some uh words at the cell like
219:49 - over here we have the cell we have
219:51 - selling we have said sellers we have
219:53 - sell over here again we have the seller
219:55 - information center then we have the
219:57 - seller information center
219:59 - so if you're using contains and text so
220:02 - this is the difference
220:04 - whereas if i use
220:06 - starts with over here
220:10 - there are three elements matching over
220:12 - here here you can see we have sell
220:14 - seller
220:16 - seller information center there are
220:18 - three elements that is matching to
220:20 - starts with so this is how you can use
220:22 - text function with all the functions
220:24 - that i have explained over here which
220:26 - contains start and starts with okay so
220:29 - uh
220:31 - but the only difference will be that
220:32 - that we will find multiple elements
220:34 - through these
220:35 - if we use starts with with text and if
220:38 - we use the contains with text
220:41 - so
220:41 - these were the functions that we studied
220:44 - let's see the final conclusion of it
220:46 - which function to use when
220:48 - so when do we use contains method in
220:51 - expert
220:52 - we will use the contains method if you
220:54 - know the partial constant visible text
220:56 - or attribute now what is this partial
220:58 - constant visible text partial constant
221:00 - visible text means that if there is any
221:03 - text like suppose there is an element
221:05 - which you want to identify
221:07 - there is a text for it right that is
221:09 - what we are using in contains method
221:11 - like here you can see
221:14 - the contains method the text which we
221:15 - are using we are using the partial
221:18 - constant text this first is the constant
221:21 - text even name is the constant text it
221:24 - contains method and the starts method is
221:27 - used dynamically
221:29 - so we will use only the words that are
221:32 - constant
221:33 - okay similarly goes with start with over
221:35 - here the words that are constant is s
221:37 - and t whereas the other words are
221:40 - changing right because start
221:42 - as a as we are starting the button it is
221:44 - changing to stop so that value is
221:46 - changing dynamically okay
221:51 - so we will use the contains method in x
221:53 - path if you know the partial constant
221:55 - visible text it should be constant it
221:58 - should not be dynamically okay
222:00 - next we will use the starts with method
222:02 - if you know the initial partial constant
222:05 - visible text or the attribute the
222:08 - initial partial constant text means that
222:12 - like over here
222:13 - there is an initial constant text right
222:15 - that is the st
222:17 - you are also st rest all the words are
222:19 - changing okay so the partial initial
222:22 - constant text is used in starts with
222:28 - next we can use the contains method and
222:30 - the starts with method with absolute
222:32 - text or attribute also this means that
222:34 - we can write
222:37 - the first name as well
222:39 - similarly for
222:41 - uh
222:42 - start with we can write start or stop as
222:44 - well but the only problem will be that
222:46 - it will identify that element only for
222:49 - starts with okay
222:53 - next we can you use the text method in
222:55 - xpath if you're aware of the absolute
222:57 - visible text now here in the text method
223:00 - we cannot write the partial text like
223:03 - over here you can see you cannot use
223:05 - text method with the partial text like
223:07 - in the contains method we were writing
223:09 - the partial text right
223:12 - whereas in text method we are not
223:14 - allowed to use the partial text like
223:16 - over here we were
223:19 - identifying the element cell right we
223:21 - were clicking the element cell in the
223:22 - demo now if i write sel only it will not
223:26 - identify
223:27 - if you're using the text method but in
223:29 - contains method it will identify okay so
223:32 - this is the difference between the two
223:35 - next we cannot make use of starswith
223:38 - method if the initial text is constantly
223:40 - changing now for example
223:43 - this st word is changing constantly now
223:45 - suppose just imagine we have a button
223:47 - name activated and deactivated
223:50 - the if you're clicking on activate
223:51 - button the process is activated and the
223:54 - value of that button is changing to
223:56 - deactivate so the first words are
223:58 - changing right so in that case you
224:01 - cannot use starts with function
224:03 - so this is the conclusion of the entire
224:06 - uh tutorial that we learned that is the
224:08 - contains whether the starts with method
224:09 - the text method then now we have learnt
224:12 - uh so much about xpath we have learnt
224:14 - what is x path what are the different
224:15 - types of x bar that is the relative x
224:17 - path the absolute x path the difference
224:19 - between the relative and x absolute x
224:21 - bar the functions of x bar that is the
224:24 - contains the starts with the text method
224:27 - so uh this is not all about expert the
224:31 - main part about xpath is the advanced
224:33 - expired functions that we are going to
224:34 - study
224:36 - that is uh this this is the graph that
224:38 - we're going to study in the next
224:40 - tutorial that is the xpath access in
224:42 - which uh we have the uh ancestors we
224:45 - have the parent we have the child we
224:47 - have the following siblings we have the
224:49 - preceding siblings so uh this entire
224:53 - thing we're going to study in the html
224:55 - dom structure and we will also do the
224:56 - demo of it so in the previous tutorial
224:59 - we learnt about the xpath
225:01 - operators and also the expert functions
225:04 - as well as we learnt about the different
225:06 - types of xpath that is the relative x
225:08 - path and the active expat the different
225:10 - types of locators also we have studied
225:12 - the id name the css selector link text
225:15 - and everything so in this tutorial we
225:17 - will learn about the advanced xpath with
225:19 - their access method
225:22 - in which we will cover what is the xpath
225:24 - axis and why do we use this x-path axis
225:28 - also we will understand the different
225:29 - types of x-path axis and the
225:31 - relationship with their nodes this is
225:33 - the most important thing that we need to
225:35 - understand
225:36 - next we are going to understand their
225:37 - syntax their descriptions and also we
225:40 - will implement it practically we will
225:43 - automate two websites let me show you
225:45 - those
225:46 - first is this website we will automate
225:48 - this table as well as we will automate
225:50 - this form
225:51 - so let's get started so the first thing
225:54 - that we need to understand is what is
225:56 - the xpath access
225:58 - now the xpath axis are those axes that
226:00 - is used to search for multiple nodes in
226:03 - the xml document for the current node
226:06 - context now what is this current node
226:08 - context we will understand while
226:09 - studying the relationship of nodes now
226:11 - why are we using the xpath access if we
226:14 - have locators like the id name class
226:18 - link text and all these locators are
226:20 - there still we are using the xpath
226:22 - access why see in the previous tutorial
226:25 - i explained about some of the expat
226:27 - functions right that is the contains
226:28 - method and the text method and the
226:30 - startswith method so even after using
226:34 - those expert functions we cannot
226:36 - identify the element that is the that is
226:39 - when we can use the xpath access
226:42 - so what to do when the expat functions
226:44 - fail to identify the elements in that
226:47 - case we will use the xpath access along
226:50 - with the xpath functions like the expert
226:52 - functions can be contact contains text
226:55 - start with we can use those functions as
226:57 - well as the xpath access also we can use
226:59 - those selectors like the id name class
227:03 - link text css selectors these locators
227:05 - can also be used okay
227:07 - so this is what expert access is and why
227:10 - do we use xpath access
227:13 - next there are different types of expat
227:15 - access like we have the child we have
227:17 - the parent we have following proceeding
227:19 - following sibling preceding sibling and
227:21 - sister descendants we will understand
227:23 - these terms in detail
227:26 - now here it comes
227:27 - this is the relationship of note okay
227:31 - this is one of the most important uh
227:33 - thing we need to learn in x-path access
227:36 - you need to remember you need to
227:37 - understand this relationship of note
227:40 - picture
227:41 - and uh so just have a look at this
227:43 - picture properly and see this topic is a
227:46 - bit difficult to understand but once you
227:48 - get a hang of this relationship of nodes
227:50 - uh it will be very easier for you to
227:52 - locate the elements in the dom html
227:55 - structure okay so now uh let's start
227:57 - from this node that is a self node now i
228:00 - would suggest you that uh take this
228:02 - relationship nodes in your family
228:03 - context as in when you study your family
228:06 - tree that is the ancestor parents your
228:08 - siblings your children your descendants
228:10 - so when you take take in those contexts
228:12 - when you take in those family terms it
228:14 - will be very easy for you to understand
228:16 - this relationship okay
228:17 - because there are many different uh
228:20 - keywords that we need to understand the
228:21 - ancestor the parent the child the
228:24 - preceding sibling the following sibling
228:26 - so to get a hang of it just keep
228:28 - yourself over here and just imagine your
228:30 - family tree
228:32 - so here uh this is you and this is the
228:34 - self element okay
228:37 - each and every node present over here is
228:39 - an element okay so this is self element
228:41 - so what will be your parent element the
228:43 - one about the self element is the parent
228:45 - element that here you can see is three
228:47 - this is your parent element
228:49 - and your ancestor is one now if you keep
228:52 - yourself over here who will be your
228:53 - ancestors your parents parents will be
228:56 - your ancestor right so in this case one
228:59 - is your ancestor so now uh this is
229:01 - yourself element three is the parent one
229:04 - is the ancestor
229:05 - now if you keep yourself over here your
229:08 - children that is the 9 10 11 12 and 13
229:11 - these are the child notes that are
229:13 - present over here okay
229:15 - this is you
229:16 - the one above you is your parent and
229:18 - your parents parent is your ancestor
229:22 - and your children are your child notes
229:24 - that is the 9 10 11 12 and 13. these are
229:28 - your child notes okay
229:30 - coming to the next term that is a
229:31 - descendant now what are those
229:33 - descendants
229:34 - descendant notes are
229:36 - children's children as well as the
229:38 - children
229:40 - okay
229:41 - that means
229:42 - descending will be your 9
229:44 - 10 11 12 13
229:48 - 14 15 16 17 and 18.
229:51 - keeping yourself over here your children
229:54 - and your children's children will be
229:56 - your descendants okay
229:58 - so what did we understand till now
230:00 - keeping yourself over here the one the
230:02 - element above you is the parent parent's
230:05 - parent is the ancestor that is the one
230:08 - and your child nodes that is your
230:10 - children are your child notes
230:12 - children's childrens are your descendant
230:14 - nodes okay
230:17 - now let's go to the preceding and the
230:20 - following these are the two uh terms
230:22 - that are left
230:23 - now the preceding siblings and the
230:24 - following siblings okay
230:27 - now your let's take in terms of family
230:29 - tree this is yourself keep yourself over
230:32 - here okay
230:33 - now just imagine that your brothers and
230:36 - sisters
230:37 - that are elder to you okay is your
230:40 - preceding sibling
230:42 - and your brothers and sisters that are
230:43 - younger to you are your following
230:45 - siblings okay this is what is following
230:48 - siblings and preceding siblings
230:51 - now coming to proceeding and following
230:53 - now your following means the elements
230:56 - that come after the current html tag the
230:59 - current html tag means the self tag the
231:02 - elements that come after the seller self
231:04 - tag is the following tag which includes
231:06 - the following siblings also
231:08 - whereas preceding is the elements that
231:11 - come before the self tag
231:13 - which includes the preceding siblings as
231:15 - well see when we practically implement
231:17 - this it will be more easier to
231:19 - understand you will understand in a very
231:21 - better way okay we will do the practical
231:24 - implementation also
231:26 - so let's see the syntax these are the
231:28 - two slashes that are always present in
231:30 - the x path we will write the tag name
231:33 - slash the single slash
231:34 - axis that is the child parent or
231:38 - ancestor or anything and there is an
231:40 - operator that is specially used over
231:42 - here that is a scope of operator in the
231:43 - scope of operator these two colons and
231:46 - then we will write the target element
231:48 - whatever it is the target element that
231:50 - we want to specify
231:51 - so let's have a description of this
231:55 - as i said
231:56 - child child means it travels all the
231:58 - child element of the current html tag
232:01 - okay so let's look at the description of
232:03 - it the first is a child
232:05 - it traverses all the child elements of
232:07 - the current html tag all the child
232:10 - elements of the current html tag our
232:12 - current html tag is the self tag okay it
232:15 - is traversing all the child elements of
232:17 - the current html tag that is 9 10 11 12
232:20 - and 13. next is the parent traverse all
232:23 - the parent element of the current html
232:25 - tag
232:27 - so the parent over here
232:29 - is three okay our current html tag is
232:31 - self so the element above the self is
232:35 - the parent element right so your three
232:37 - is the parent element next we have the
232:39 - following
232:40 - traverse all the elements that comes
232:42 - after the current attack
232:44 - after the current tag right self is the
232:46 - current tag all the elements after the
232:48 - current tag that includes the seven
232:50 - eight and also the four so this is the
232:52 - following
232:53 - okay
232:54 - see there is a difference between
232:55 - following and following siblings okay
232:58 - the following siblings consist of seven
233:00 - and eight element only whereas following
233:03 - is having four seven and eight okay so
233:06 - there is a difference between the two
233:08 - next coming to the proceeding
233:10 - traverse all the nodes that comes before
233:12 - the current html tag so the current html
233:16 - tag itself before the current html tag
233:19 - is 2 5 and 6. okay
233:22 - so this is your preceding elements
233:26 - next we have the following siblings
233:28 - traverse from current html tag to the
233:31 - next sibling html tag
233:34 - traverse from the current html track
233:37 - this self
233:38 - to the next
233:40 - html tag that is this
233:43 - this is your next html tag which is just
233:46 - next to it right next to your self tag
233:48 - which is seven and 8 so this will be
233:50 - your following sibling
233:54 - going to preceding sibling traverse from
233:57 - current html tag to previous sibling
233:59 - html tag
234:03 - current html tag is self
234:05 - previous sibling html tag is this that
234:08 - is the five and the six okay next we
234:11 - have the ancestors that is your
234:12 - grandparents in parent reverse all the
234:15 - ancestor elements of the current html
234:17 - tag
234:19 - so the ancestor over here is one this is
234:21 - your current html tag itself and the
234:23 - ancestor is one next we have the
234:25 - descendant it traverses all the
234:27 - descended elements now which consists of
234:29 - the child node the grandchild nodes of
234:31 - the current html tag
234:33 - so this is the current html tag the
234:35 - child node that is the 9 10 11 12 and 13
234:38 - and the grand child nodes that is the 14
234:41 - 15 16 17 and 18.
234:43 - so this is all about the relationship
234:45 - table in which we covered about the
234:47 - ancestor the parent the child descendant
234:50 - the following the preceding the
234:51 - preceding sibling and the following
234:53 - siblings now let's implement this
234:58 - so these two page uh these two sites we
235:00 - will automate today we will automate
235:02 - this table as well as this form now this
235:05 - table is dynamic it keeps on changing it
235:08 - is the
235:09 - rediff money.rediff.com the gainers page
235:12 - in which we have the markets uh
235:14 - companies present over here which keeps
235:16 - on changing according to their uh prices
235:19 - and so we're going to automate this
235:20 - table today which is dynamic also we're
235:22 - going to automate this form now this
235:24 - form is static this is dynamic so just
235:26 - open your intellij id id
235:34 - okay so i've already created a java
235:37 - class in the selenium package and i have
235:40 - named it as selenium tutorial 7 so we're
235:42 - going to implement our
235:44 - advanced xpath accesses in this uh
235:47 - selenium tutorial 7. so uh like the
235:50 - three lines is always the same in all
235:52 - the programs so first is the open the
235:54 - chrome browser that is the system.set
235:57 - property in which we have to specify the
235:59 - key value and the value that is present
236:01 - that is the executable file you need to
236:03 - write over here and the key that we use
236:05 - is the
236:06 - webdriver.chrome.driver because we're
236:08 - launching the chrome browser the next
236:10 - line that we write is the web driver
236:11 - driver is equal to new chrome driver and
236:13 - why do we write this i have explained in
236:15 - the previous tutorials so you can go and
236:17 - check out that
236:18 - the next thing that we're going to do is
236:20 - we are navigating to the url so we are
236:22 - going to use the driver.getcomma in
236:24 - which we are going to navigate to the
236:25 - particular url the next that we are
236:27 - going to write is the maximizing the
236:29 - window in which we are using the
236:30 - driver.manage.window.maximizecommand
236:34 - okay so these are the three things that
236:36 - we are going to do so let's execute this
236:39 - and yeah we are exec we are
236:42 - automating this table first and then we
236:45 - will jump on to this page okay so first
236:47 - automate this one
236:49 - so let's execute this first let's see we
236:52 - are whether we can launch the chrome
236:53 - browser or not
237:01 - so our chrome browser is launched
237:03 - it's navigated
237:07 - and it's maximized okay
237:10 - so so far our
237:13 - this commands are working
237:14 - so let's get started with the xpath
237:17 - access
237:20 - first important thing that we need to
237:21 - identify is a self node on the basis of
237:24 - the self node we will identify the other
237:26 - relationships that is the ancestor the
237:28 - parent the descendants and everything
237:30 - okay
237:31 - so first thing is we will identify the
237:33 - self node so
237:34 - i take any of the
237:37 - column let me take this one okay so i'll
237:39 - just click on inspect
237:43 - and i'll be using the selectors hub
237:45 - xpath tool i have explained about the
237:47 - selectors hub in the previous tutorial
237:49 - how to install it so you can check out
237:50 - that i'll also give the link in the
237:52 - description box to install it okay
237:55 - so uh this is the element that i
237:57 - inspected here you can see a rash
237:59 - television network
238:01 - so uh what i'll do is i will copy this
238:04 - relative path
238:06 - i'll paste it over here
238:08 - and
238:09 - i'll write the contains method over here
238:11 - let me use the contains method
238:13 - so you can see we have one element
238:15 - matching so what i'll do first i'll
238:17 - identify the self so the syntax for it
238:20 - is that i'm writing the tag name i'm
238:22 - using the function that is the contains
238:24 - function of the x path
238:26 - i'll place a slash over here
238:28 - then i write self
238:31 - and the tag name here you can see the
238:33 - tag name is a right so i will write a
238:37 - and click on enter and here you can see
238:38 - there's one element matching that is
238:41 - this one
238:42 - okay so i'll copy this
238:46 - and
238:47 - i'll write driver
238:50 - dot find element
238:53 - by dot
238:54 - x path
238:56 - and i'll place it over here and what i
238:58 - want to do is i want to uh click this
239:02 - link so let's see
239:04 - so let me run this
239:12 - so our chrome browser is
239:14 - executed it's navigated
239:16 - and it's maximized
239:20 - and here you can see the rash television
239:22 - network is
239:23 - clicked okay so we were performing the
239:26 - operation of click so it's clicked
239:28 - so i'll just close this
239:31 - so here you can see this is the self
239:33 - note we are using the self command we
239:36 - are identifying the self command over
239:38 - here just by writing one slash sells two
239:41 - colons and the tag name that is we're
239:42 - using is a
239:44 - okay
239:46 - next let's see is the
239:49 - parent node okay let's find the parent
239:52 - node this is our element
239:54 - now we have to find the parent node that
239:56 - is the node about the self node that is
239:58 - the current html tag that we're taking
240:00 - is the a right above it we have the td
240:03 - tag okay so this will be our parent node
240:06 - so now what if we don't know what i'll
240:09 - do is i'll just write uh this is this
240:11 - will be the command that is i'm writing
240:13 - the tag name a i'm using the contains
240:15 - function and then i'll write one slash
240:17 - and i'll use the parent
240:19 - over here and what i'll do is i'll write
240:22 - the asterisks
240:24 - and here i can see i have one parent
240:26 - over here which is identified for this
240:28 - element that is the rash television
240:30 - diagram okay for this element the parent
240:32 - is here this is the parent where you can
240:34 - see it's identified over here
240:37 - here you can see it's highlighted
240:40 - so this is the parent this is in case
240:42 - when we don't know the parent of the
240:44 - current html tag okay now here we know
240:47 - the parent right so uh since i have
240:50 - written one slash parent and the two
240:51 - colons over here which is in scope of
240:54 - operator and then i'll write td
240:57 - okay
240:58 - so here you can see again it's a one
241:00 - element matching that is this one so
241:03 - what i'll do is i'll
241:04 - copy this
241:07 - and
241:08 - driver dot
241:10 - find element
241:12 - by dot
241:13 - x path
241:16 - this
241:17 - and uh let's do one thing i will uh
241:21 - retrieve the text over here okay so
241:23 - let's retry the text so i'll write
241:25 - get text method
241:28 - and um
241:31 - let me give a string
241:32 - variable over here i'll write
241:36 - parent node
241:38 - then the next thing that i'll write is
241:40 - the system out.println
241:42 - i'll type
241:46 - the parent node is
241:53 - similarly i'll do for this one also
241:55 - let's see what value do we get
241:58 - get text
242:00 - and
242:03 - i will give a variable over here
242:07 - so i'll write
242:11 - the self
242:13 - node is
242:14 - so let's see what value it prints
242:17 - so i will execute this command
242:20 - a chrome browser is launched
242:22 - it's navigated
242:24 - it's maximized
242:27 - so let's see see the self note is large
242:30 - television network and the parent node
242:31 - is rash television network now here
242:33 - there's one thing to notice that is
242:35 - there any value in td
242:38 - here we can see it's here is there any
242:40 - value in td there is no value entity
242:43 - there is there is no value entity so
242:44 - that is the reason why
242:46 - we are not fine we are not getting any
242:48 - value printed over here the only value
242:50 - that we are getting over here is uh is
242:53 - rash television network because under
242:55 - the parent element under the td tag we
242:57 - have the a tag right which has the link
243:00 - of the rash television network so that
243:02 - is the reason why it is printing rush
243:04 - television network if td would be having
243:06 - any value the parent or value would be
243:09 - different from the self node value okay
243:11 - we will understand that in the forms
243:13 - when we will do uh we will navigate the
243:15 - different website this form website at
243:17 - that time we will see the values also at
243:19 - that time the values will be different
243:21 - okay so for now to understand the td tag
243:24 - is having no value so that is the reason
243:26 - why we're getting the raw television
243:28 - network away
243:30 - okay
243:31 - so now moving to the next thing is see
243:33 - the
243:34 - child nodes
243:36 - so now uh if i write
243:41 - child
243:42 - to collins and the asterisk
243:45 - so here we can see we have zero element
243:47 - matching over here there is no
243:49 - child node of this a tag okay
243:52 - so now what we're going to do is
243:55 - first uh we will go to the ancestor
243:58 - and then we will find the child elements
244:00 - for ancestor that is a tr tag is having
244:02 - different child elements like here you
244:03 - can see the b 34.05
244:06 - and 39.20 so these are the child
244:08 - elements of tr tag right so we're going
244:10 - to find the tr tag the uh tier tags
244:13 - child elements okay so how we're going
244:15 - to do this is the self tag that is the a
244:18 - type the parent tag is a td tag and the
244:20 - ancestor tag that we can see over here
244:22 - is the tr tag okay so first we'll go to
244:25 - the tr tag
244:26 - we'll go to the ancestor and then from
244:29 - there we will traverse the child
244:30 - elements okay so how we gonna do that
244:33 - just have a look at it
244:35 - this is the tag name that i'm using that
244:37 - is the a tag name and the contains
244:38 - method that is given over here then i'm
244:40 - given the slash over here
244:42 - and then i'll write
244:44 - the ancestor
244:46 - here it is okay
244:48 - who's my ancestor my ancestors tag is tr
244:51 - tag here you can see this is the tr tag
244:54 - click on enter and here i can see
244:56 - there's one element matching to it
244:58 - okay
244:59 - this is the element that is matching to
245:01 - it here you can see it's getting
245:02 - highlighted
245:04 - okay so i have gone to my ancestor after
245:06 - i was to tell my ancestor now i want to
245:08 - find the child elements of my ancestor
245:10 - so what i'm going to do is i'm going to
245:12 - put another slash over here
245:14 - write
245:15 - child
245:17 - colons and let's see how many i'm
245:20 - getting five child elements over here
245:23 - this is the first one
245:25 - this is the second one this is the third
245:27 - one this is the fourth one and this is
245:29 - the fifth one
245:30 - okay now see selectors hub is having
245:32 - this feature of identifying these five
245:34 - elements which are matching which is
245:36 - showing over here also so it's a great
245:38 - tool to use so i would suggest you to
245:40 - use selectors hub for the
245:43 - access when you're finding the xpath
245:45 - access because you will get a knowledge
245:47 - of uh writing the expert as well it's
245:50 - not that that you're getting used to
245:51 - this tool or not see sometimes people
245:54 - think by using this tool we are not
245:56 - getting a hang of writing your x bar
245:58 - that's not the point if you write your
246:00 - expert over here it tells you whether
246:02 - you're writing it right or wrong like if
246:04 - i
246:05 - delete if i just clear this one so you
246:07 - can see it's red in color but when i
246:10 - write this it's it's it's not having any
246:12 - color so it shows you that the
246:14 - expert that you're writing is correct or
246:16 - wrong so that will help you like if you
246:19 - write bigger scripts so in that case
246:21 - that will help you so it's a very great
246:24 - it is a very good tool to use so use
246:26 - selectors hub i would prefer you to use
246:28 - selectors hub okay
246:30 - as in the previous tutorial i explained
246:31 - about the crowbar plugin also but the
246:33 - selectors hub is the advanced version of
246:35 - the crow path plugin so i would
246:37 - recommend not to use crow path for now
246:38 - because uh it's so absolute it's not
246:41 - that updated till now so selectors hub
246:43 - is more updated so use selectors up
246:46 - okay like here you can see i placed the
246:48 - asterisk mark and here you can see uh
246:50 - there are different uh td tags present
246:52 - over here that is the child elements one
246:54 - two three four five we are having five
246:56 - elements over here okay so now what
246:59 - we're going to so till now what we did
247:01 - we went to the ancestor tag that is a tr
247:03 - tag and then we traverse the child
247:05 - elements over here what i'll do is i
247:06 - will write driver
247:10 - dot x
247:11 - dot
247:13 - find elements because i'm finding
247:15 - multiple elements over here okay the
247:18 - child nodes that i'm having the number
247:19 - of child node is five i'm not finding
247:21 - one element i'm finding multiple
247:22 - elements over here okay so find elements
247:25 - then i'll write by dot
247:28 - x path
247:29 - and i will write the entire x path over
247:32 - here
247:34 - now what what i'll do is i want to uh
247:38 - i want to know the number of child
247:40 - elements present over here i'll print
247:41 - the child number of child elements
247:42 - present over here so i'll write
247:45 - child node
247:46 - is equal to
247:47 - this now what we are finding we are
247:49 - finding a web element a multiple fweb
247:52 - elements we are finding right
247:54 - so i'll write
247:57 - web element
247:59 - now this is a web element child or not a
248:01 - child node but we are finding multiple
248:03 - elements we are using find elements
248:05 - right so it is a list of multiple
248:07 - elements so what i'll do is i'll write
248:09 - list
248:13 - web element child node driver dot find
248:16 - elements y dot x bar and the x bar that
248:19 - is present over here now what i want is
248:25 - i want to print this
248:27 - so
248:29 - so the number of child nodes are
248:33 - child
248:33 - node dot
248:35 - size okay so let's and after this uh
248:38 - what i want is i want to close the
248:41 - browser
248:42 - so i'll write driver dot
248:44 - close
248:47 - okay so let's run
248:51 - so the chrome browser is launched
248:54 - it's navigated
248:59 - and it's maximized and it's closed okay
249:02 - now here it's you here you can see the
249:03 - self note is rash television network the
249:05 - parent node is rash television network
249:07 - the same value is given because the td
249:09 - tag is not having any value and the
249:11 - number of child nodes are five here you
249:13 - can see we have five elements that is
249:14 - identified so the number of child nodes
249:16 - are five
249:18 - okay so so far we have seen the self
249:20 - known the parent node in the child node
249:22 - let's uh see the ancestor node since we
249:25 - have seen already but let's print it
249:29 - okay
249:30 - so what i'll do is
249:33 - same
249:36 - these are my ancestors so let me see so
249:38 - there is only one ancestor over here
249:40 - okay so i will copy this
249:43 - and i'll write
249:45 - driver
249:46 - dot
249:47 - find element
249:50 - by dot
249:52 - x path
249:54 - the ancestor
249:56 - and what i want is i want get text
250:00 - so i'll save it in a variable
250:03 - that is string variable i'll write it at
250:07 - ancestor
250:08 - node
250:09 - is equal to driver dot fine element by
250:11 - dot expat
250:13 - and
250:15 - next i'll print it
250:20 - the
250:23 - ancestor
250:23 - [Music]
250:25 - node is
250:27 - and plus
250:29 - ancestor node okay
250:32 - so let's see
250:33 - let's run this command
250:37 - so i chrome browser is
250:39 - launched it's navigated
250:42 - and
250:43 - it's maximized and it's closed so here
250:46 - you can see the ancestor node is
250:47 - television network b now see
250:50 - when you're traversing the ancestor that
250:52 - is the tr tag under tr tag we have the
250:55 - different uh
250:56 - tags right that is the td tag the td
250:59 - this tag then this td tag then the tr
251:01 - tag is closing
251:03 - now from this tag
251:05 - to this tag
251:06 - the number of tags that we are having it
251:08 - will print all the tags first is
251:10 - printing the raj
251:12 - here you can see the last television
251:14 - then it's printing b then it's printing
251:16 - 34.05
251:19 - just have a look at it
251:22 - here you can see we have the rash
251:24 - television network the rash television
251:26 - network then we are printing b
251:28 - then we are printing 34.05 34.05 and
251:31 - then the 39.02
251:34 - and then
251:36 - plus 15.12
251:38 - so it's printing the entire eye because
251:41 - under the tr tag under this tr tag there
251:44 - are different td tags that is present
251:45 - and under td tag we have the different
251:47 - values that are present over here that
251:49 - is the uh rash television network then
251:51 - the b then thirty four point zero four
251:53 - thirty nine point zero two and so on
251:55 - okay so like these there are uh five to
251:58 - six elements that we have printed
251:59 - printed over here this is all about the
252:01 - ancestor
252:03 - now let's see
252:05 - the
252:05 - following
252:07 - so i have the two slashes that is always
252:09 - there for the x path the a tag the tag
252:11 - name that i'm using is a contains the
252:13 - rash television network this is the
252:15 - element that is the self element now
252:17 - from here i want to see the following
252:19 - elements okay so what i'll do is put one
252:21 - slash i'll write following
252:26 - two columns now i don't know what are my
252:27 - following elements so i'll just put
252:29 - the asterisks mark and here you can see
252:33 - we can see there are almost 13 000
252:36 - elements that is matching to the
252:37 - following element you can see
252:41 - so just have a look over here the one
252:42 - that is highlighted the blue one is the
252:45 - following elements that is over there
252:47 - this these are the following elements
252:49 - okay
252:50 - the this blue one that is highlighted
252:51 - over here there are almost 13 000
252:53 - elements that is matching over here so
252:55 - this is the following element
252:57 - so i'll just print the number of
252:59 - following elements that is present over
253:01 - here
253:02 - so i'll just write
253:04 - driver
253:06 - dot
253:07 - find elements
253:10 - by dot
253:11 - x path
253:13 - i put the following
253:16 - and
253:19 - let's
253:21 - give a web element
253:23 - the
253:25 - i'll write the
253:27 - is equal to driver dot and it is of type
253:30 - list
253:31 - because the number of uh web elements
253:33 - that is identified over here are
253:36 - almost 13 000 web elements will be
253:37 - identified over here so i'm writing list
253:40 - web element
253:41 - and the following tag that is the web
253:44 - element that i'm specifying over here in
253:46 - the driver.find elements by.xpath
253:49 - and next what i want is
253:52 - so i want
253:54 - the number of
253:57 - following
253:59 - elements
254:01 - from the
254:03 - current
254:05 - html
254:07 - tag is
254:09 - and i will write
254:12 - following tag
254:14 - size let's execute this
254:21 - okay so my chrome browser is launched
254:23 - it's navigated
254:25 - and it's uh
254:27 - maximized
254:30 - so these are the number of the following
254:31 - elements from the current customer tag
254:33 - that is present over here now let's see
254:35 - the following sibling
254:37 - okay so let's check out the following
254:39 - siblings that are present over here so
254:41 - what i'll do is i will
254:43 - just write the following
254:45 - sibling
254:47 - i don't know the number of following
254:48 - siblings so i'll just write the
254:50 - asterisks
254:52 - and it says that there are zero number
254:54 - of following siblings present over here
254:56 - that is there is no node next to the
254:59 - self node so again what we'll do
255:02 - we will traverse to the ancestor
255:05 - so our ancestor tag is the tr tag
255:08 - slash
255:09 - following
255:12 - sibling
255:15 - and then let's see so what we did we
255:18 - traverse to the ancestor tag that is the
255:20 - tr tag and from tr tag we traverse the
255:23 - following siblings
255:24 - so the following siblings that are
255:26 - present over here
255:28 - are these these are the following
255:29 - siblings you know this uh blue marking
255:32 - done over here these are the following
255:34 - siblings okay so what i'll do i'll just
255:36 - print the number of the following
255:38 - siblings over here so what i'll write is
255:40 - i will write
255:43 - driver dot
255:45 - find elements
255:47 - by dot x path
255:49 - and the
255:50 - following sibling over here
255:53 - and then i will
255:55 - following siblings okay
255:58 - so let's execute this
256:04 - so my chrome browser is launched it's
256:06 - navigated it's maximized
256:12 - okay so here it is the following
256:13 - siblings are
256:15 - uh
256:16 - 1705 okay so the number of following
256:18 - siblings that are present over here is
256:20 - 1700.
256:22 - so now let's see the proceeding
256:24 - okay so what i'll do is i will
256:26 - slash proceeding now i don't know the
256:29 - number of preceding elements over here
256:30 - so i'll just write asterisk and here you
256:32 - can see
256:34 - this is the entire preceding element
256:36 - that is present over here
256:37 - the entire preceding elements that we
256:39 - have is this okay
256:41 - now what if i write
256:43 - preceding
256:45 - sibling
256:46 - so there are zero elements that is
256:48 - matching over here so
256:49 - so again we will go to the ancestor
256:52 - the tr tag
256:54 - and then we will go to the preceding
256:56 - sibling
256:57 - so there are six elements that is
256:59 - matching to the preceding sibling
257:01 - that is uh these elements
257:04 - before the rash television network the
257:06 - element that is present is the preceding
257:08 - siblings after the rash television
257:10 - network the elements that are present is
257:12 - the following siblings
257:14 - and the elements that are present before
257:16 - the last television network all these
257:18 - elements this entire pace that is
257:20 - present before the rash television
257:22 - network is your proceeding again let me
257:24 - show you
257:26 - this is your preceding sibling
257:29 - but whereas your proceeding is
257:31 - this
257:32 - this is your proceeding and you proceed
257:35 - preceding siblings for only these
257:36 - columns that is present over here before
257:38 - the rash television network so that is
257:40 - the difference between the preceding and
257:41 - the preceding siblings okay so keep in
257:44 - mind that so let's first do the
257:46 - preceding one so i'll just copy this
257:49 - and we will see that at least 200
257:51 - elements that is present over here so
257:53 - i'll just write
257:55 - list
257:57 - we will we are finding the web element
257:59 - over here and i'll write the
258:03 - preceding so pre and then driver dot
258:07 - find elements
258:09 - by dot
258:10 - x path
258:12 - and then this syntax of x path
258:16 - and
258:17 - the next line i'll write s out
258:21 - i'll write
258:23 - the number of
258:26 - preceding
258:28 - nodes are
258:32 - so our chrome browser is launched it's
258:35 - navigated
258:37 - and it's maximized
258:41 - okay and here you can see the following
258:42 - siblings are 1700 and the number of
258:45 - preceding nodes that are there it's 200
258:47 - okay so 217 so these are some preceding
258:50 - now let's see the preceding siblings
258:54 - okay so what i'll do is i will first
258:56 - find the number of elements that is
258:58 - present so what i'll do as a first
258:59 - traverse to the ancestor first ever so
259:02 - the ancestor we have the answer tag that
259:05 - is a tr tag then i'll write one slash
259:07 - and then i will write uh
259:10 - preceding siblings
259:13 - this and i'll write the asterisk sign
259:16 - and you can see we have six elements
259:18 - matching over here so i'll just copy
259:20 - this x path
259:22 - and
259:24 - i'll write list
259:27 - is equal to driver dot fine elements
259:32 - by dot x path
259:35 - and i'll place the x path over here
259:37 - so s out
259:39 - and
259:41 - the number of
259:44 - okay so
259:46 - let's run this now
259:56 - so our chrome browser is launched
260:00 - it's navigated
260:02 - it's maximized
260:07 - okay so here it shows the number of
260:09 - preceding siblings are six
260:11 - similarly we have seen over here there
260:12 - are six elements that are matching so
260:14 - the number of preceding elements uh
260:15 - preceding siblings are six
260:18 - so um
260:19 - [Music]
260:20 - this is the code that we have executed
260:23 - today for the expert access in which we
260:25 - have seen the self node first and the
260:27 - parent node the child node the ancestor
260:29 - node the following the following
260:31 - siblings the proceeding and the
260:32 - preceding siblings okay so for so far we
260:36 - have understood how do we write these
260:38 - elements when we're having a dynamic uh
260:41 - web page
260:42 - so this table is dynamic it keeps on
260:44 - changing you can check it out also if
260:46 - you like open today and open it tomorrow
260:48 - so these companies keep on switching
260:50 - okay depending on their change in prices
260:52 - this is a way that we can identify the
260:55 - ancestors and child nodes how to first
260:57 - traverse to the child node and then for
260:59 - how to first traverse to the ancestor
261:01 - node and then to the child node so this
261:02 - is this is the way to do it so now this
261:05 - is the first web page that we traverse
261:07 - and then the next webpage that we're
261:08 - going to automate is this one okay uh
261:11 - this code is available on the github so
261:13 - i'll uh give the link in the description
261:15 - box so you can check out okay so uh this
261:18 - is the second uh
261:19 - web page that we are going to automate
261:21 - we're going to use the xpath axis over
261:23 - here we will find the parent the self
261:24 - element and all the elements the xpath
261:26 - access elements over here
261:28 - so first is to identify the self element
261:30 - right the self node so i'll be taking
261:33 - this company name as the self node so
261:36 - here it is
261:38 - the company name
261:40 - okay so now what i'm going to do is
261:42 - i'm going to open my selectors hub
261:45 - and let me see yes this company name is
261:47 - myself note
261:48 - and here it is
261:50 - this is the
261:52 - just copy the relative path over here
261:54 - i'm using the two slashes first the two
261:56 - slashes that is used for the x part
261:58 - normally then the input tag here you can
262:00 - see we have the input tag and the id uh
262:02 - locator has been used the id locator in
262:05 - which the value is the company
262:08 - okay
262:08 - so as i said uh the expert access can be
262:11 - used with any of the locators and in
262:12 - fact it can be used with the uh methods
262:15 - also
262:16 - okay so now what i'm going to do is i'm
262:18 - just going to write
262:20 - a slash
262:21 - this is the self element so i'll write
262:23 - the cells
262:24 - two colons and the in the tag that is
262:28 - the input tag right the tag that is
262:29 - usable over here is the input type so
262:32 - you can see that there is only one
262:33 - element matching that is this element
262:35 - okay so i'll just copy this
262:39 - so i'll write driver
262:41 - dot
262:42 - find element because one element i'm
262:44 - finding by dot
262:47 - x path and i will specify the x path
262:49 - over here and the command that i want to
262:51 - send over here is send keys the company
262:53 - name is
262:54 - abc
262:56 - that's the company name
262:58 - run this
262:59 - so my chrome browser is launched
263:02 - it's navigated
263:05 - it's maximized and you can see the
263:07 - company name that the command that is
263:08 - sent over here is abc
263:11 - okay
263:12 - so here our self node is identified
263:14 - let's find the parent
263:17 - node
263:18 - so here
263:19 - this is a self node so uh i'm writing
263:22 - the two slashes that is the in and the
263:25 - tag name that i'm using is the input tag
263:27 - the id locator that i'm using and the
263:30 - value is company so
263:32 - slash and i'll be using parent
263:35 - now i don't know the number of parents
263:37 - over here so i'll just write asterisks
263:39 - and then let me see there is only one
263:41 - element
263:42 - the form here you can see why see
263:44 - because your input above input we have
263:46 - the select tag which is of the same
263:48 - level then we have the div tag which is
263:50 - of the same level
263:51 - next we have the form tag which is the
263:53 - parent tag why because above input now
263:56 - you must be saying about the self tag
263:58 - that i said the current html node is the
264:00 - this this input tag above this input tag
264:03 - we have the select tag right so this
264:05 - should be parent tag no
264:06 - this tag and this tag are on the same
264:08 - level the parent tag over here is the
264:11 - form
264:12 - so the parent tag over here is form
264:13 - right so we will access this element so
264:16 - what i'm going to do is i'm just going
264:17 - to
264:17 - copy this i'll just write driver dot
264:21 - find element
264:23 - now uh sometimes uh there is a question
264:25 - where people ask that the for relative x
264:27 - path for absolute x bar are the
264:29 - different different ways of writing like
264:31 - by relative x path by absolute x but by
264:34 - x path axis is no
264:36 - there is only one x path that is by dot
264:38 - x path okay okay so this is what and
264:41 - what i want is i want to find the value
264:43 - let me find the value of it what value
264:45 - do i get from here so i'll write string
264:51 - parent is equal to drive
264:54 - and i'll write the
264:56 - parent so chrome browser is launched
265:01 - it's navigated
265:06 - it's maximized and the company name that
265:08 - is the abc has been sent over here
265:17 - now you must be saying that your only
265:20 - one element is found
265:22 - but the value that is printed over here
265:24 - here you can see there is a number of
265:26 - values that is print the parent values
265:27 - name email role
265:29 - job and all these cities names and
265:32 - states names and
265:34 - this entire thing is printed why there's
265:36 - only one element matching and how come
265:38 - all these values are printed why as i
265:39 - said in the previous time when we were
265:41 - automating that uh
265:43 - table that dynamic table at that time
265:45 - also i said that when we are traversing
265:47 - when we are traversing to a parent tag
265:49 - or an ancestor tag so all the tags that
265:52 - are under it
265:53 - the values are printed when we are
265:55 - printing the value we are finding get
265:56 - text right the get text method has been
265:58 - used over here through gettext method we
266:01 - are finding the uh
266:03 - values that we are finding the text that
266:05 - is there for the parent
266:07 - string see the variable that we are
266:09 - using is parent over here
266:10 - right and the element that we are
266:12 - finding is this the parent element right
266:14 - so we are printing the parent element
266:16 - right so print while printing the parent
266:19 - element all the elements that are under
266:20 - form
266:21 - all the elements are printed over here
266:24 - okay
266:25 - so here you can see until the form is
266:28 - ended till here
266:30 - so all the elements that are present in
266:33 - here all the elements that are present
266:34 - see here you can see it's highlighted
266:38 - if you can see this entire frame has
266:41 - been done framing has been done okay
266:42 - this yellow color frame that is done
266:44 - this is your parent tag that is this
266:46 - showing
266:47 - this entire thing is your parent type so
266:49 - everything is printed over here that
266:50 - doesn't name your email your role your
266:52 - company your country your postal code
266:54 - your username everything that is present
266:56 - over here by registering everything is
266:57 - present we have printed on this
267:00 - uh
267:01 - console okay so here you can see by
267:03 - registering you confirm similarly over
267:05 - here also by registering your confirm so
267:07 - everything that is present under this
267:08 - form tag is printed over here in the
267:10 - parent
267:11 - this is one way so i'll just
267:13 - comment this because it's printing a
267:16 - long
267:16 - message so this is the way we can do the
267:19 - parent app
267:20 - next we have the
267:23 - child
267:24 - notes i'll write slash
267:27 - child
267:29 - to colons
267:30 - and the asterisk mark and you can see
267:34 - zero child elements that is identified
267:36 - over here
267:37 - so what you're going to do again
267:41 - we go to parent
267:43 - we can go to parent the parent tag that
267:45 - we're using is the form
267:47 - slash
267:48 - child
267:51 - to colons and then we can use the
267:53 - asterisk and you can see we have 26
267:55 - elements that are highlighted here you
267:57 - can see 26 elements the entire form is
268:00 - highlighted over here
268:01 - if you can see each and everything we
268:03 - have the name we have the email we have
268:05 - the role company the country the postal
268:07 - code the user name and all these
268:10 - elements are highlighted over here okay
268:12 - so what i'm going to do is i'll just
268:13 - print the number of elements that is
268:15 - matching over yours similarly we did in
268:17 - the previous so while navigating the
268:19 - previous
268:20 - web table
268:21 - the table that was there the dynamic
268:22 - table so i'll just write
268:25 - list
268:27 - and the web element
268:29 - driver dot find elements i'm using find
268:33 - elements
268:34 - by dot x path and i will specify the x
268:37 - path over here
268:39 - and
268:40 - [Music]
268:41 - what i want is i want to find the number
268:43 - of uh
268:44 - child nodes right
268:46 - plus
268:48 - sign notes dot
268:50 - size
268:52 - we're using the size method see the
268:53 - reason why i'm automating two webpages
268:55 - because that was a dynamic one this is a
268:57 - static one there is no such changes in
268:59 - it but you should know you should have a
269:01 - hang of it and it's a good practice to
269:03 - practice this
269:05 - way okay so you can automate any of the
269:07 - site like you can automate the
269:08 - facebook.com you can automate gmail you
269:10 - can automate the google so you can
269:12 - automate any one of it that's on you so
269:15 - let's run this command okay so our
269:18 - chrome browser is launched
269:21 - it's navigated
269:24 - it's maximized and the company name that
269:26 - is the abc company name
269:28 - and let's see the number of child nodes
269:31 - are 25 so this way we have found the
269:34 - number of child nodes
269:37 - now let's find following
269:40 - nodes
269:41 - so this is our self
269:43 - after the self node all the boxes that
269:45 - are showing over here is your following
269:47 - right till the
269:48 - end so i'll just write
269:52 - following
269:53 - and we have the 562 elements that is the
269:55 - country postal username this entire
269:59 - thing that is there right
270:00 - all the thing that is present over here
270:02 - this uh country postal code username by
270:05 - registering all these elements that is
270:07 - the 562 elements that is present over
270:09 - here are under your following
270:12 - okay
270:13 - similar same thing we'll do
270:16 - we will copy it
270:18 - we will write list
270:21 - web element
270:23 - so let's execute this
270:28 - chrome browser is launched
270:30 - it's navigated
270:33 - and it's maximized
270:36 - and here our country value is being sent
270:37 - that is in abc
270:40 - and the number of following nodes are
270:44 - 560. so there were among 500
270:47 - nodes that were present so the number of
270:49 - following nodes that are present over
270:50 - here
270:51 - similarly we'll go for preceding
270:54 - okay so this is the proceeding that we
270:56 - have so let me just print the values of
270:58 - here see it's similar to the previous uh
271:01 - web piece that we automated so this is
271:03 - the same
271:04 - this is just for the practice purpose
271:07 - so
271:08 - open your chrome browser it's launched
271:10 - it's navigated it's maximized and the
271:12 - company name is also been sent over here
271:15 - and here you can see we have the number
271:17 - of child nodes that are given is 25 the
271:19 - number of following nodes is 560 and the
271:21 - number of proceedings that is given away
271:22 - is 108. okay now let's find the
271:24 - following siblings
271:27 - okay
271:28 - so this is the command that i've written
271:29 - i have written the two slashes the input
271:31 - the tag name the id locator that i'm
271:33 - using and the values company and slash
271:36 - following siblings and two colons and
271:38 - the asterisk mark so this shows the
271:40 - following sibling that is the country
271:42 - person code username and this value and
271:44 - the sign up following siblings means
271:47 - this is the form right this is the
271:49 - parent tag over here is the form
271:51 - parent tag right so under the parent tag
271:54 - after the company name all the values
271:56 - that is coming all the web elements that
271:57 - is identified after the company name are
271:59 - your following siblings whereas
272:01 - following means the country the postal
272:03 - the username this the sign up and then
272:05 - this login i already have a sale force
272:07 - developer environment all this is the
272:09 - following and whereas the following
272:11 - siblings is the country postal code
272:13 - username and this value in the signup
272:15 - value similarly for preceding
272:18 - let me show you the proceeding as well
272:21 - so this is the proceeding there are 12
272:23 - elements that is the elements before the
272:25 - company that is the company role email
272:27 - name and whereas when we are finding the
272:29 - preceding element
272:30 - not the preceding sibling the preceding
272:32 - element we have all this also that is
272:34 - get your own developer addition and all
272:36 - all this is also included okay so
272:39 - proceeding here you can see in the
272:41 - output that we have found that there are
272:43 - proceedings only 108 whereas the
272:45 - preceding siblings is 12 elements so
272:47 - there is a difference between the two
272:48 - okay so remember that
272:51 - so this is the two syntax that i've
272:52 - written the two commas the following
272:54 - siblings and the preceding sibling so
272:55 - let's execute it
272:57 - this is our chrome browser's launch
273:00 - it's navigated it's maximized and the
273:02 - company name abc has been sent over here
273:05 - and here you can see the number of
273:06 - following siblings at 12 the number of
273:07 - preceding siblings at one
273:09 - okay
273:11 - so uh this way we have seen the child
273:13 - node the parent node the following node
273:15 - preceding nodes and all the nodes that
273:16 - we have study the relationship of nodes
273:18 - as well so to know we have covered many
273:21 - uh things about the x path we have
273:23 - covered what is the x path the different
273:25 - types of the x bar that is the absolute
273:27 - and the relative and which one is better
273:29 - to use
273:30 - then we have studied about the expert
273:32 - operators like the and the or operator
273:34 - the contains method the text method and
273:36 - the start swift method also we have
273:37 - studied about the xpath accesses so this
273:40 - is a simple cheat sheet which i usually
273:42 - uh use to refer the xpath whenever i
273:44 - study xpath or need to revise xpath so
273:47 - this is a cheat sheet which i usually um
273:50 - use it you can also use it while going
273:53 - before the interviews so let's get a
273:55 - hang of it so these are some of the uh
273:58 - methods that is used for the xpath axis
274:00 - like i said the two colons in the scope
274:02 - of and we're using the uh two slashes or
274:06 - one slashes now there's one thing that i
274:07 - need to remind you see over here you can
274:10 - see in the axises which is the cell
274:12 - following following sibling we have a
274:13 - two slashes specified over here
274:16 - it does not matter where you whether you
274:18 - put the two slashes or the one slash for
274:20 - example let me show you
274:22 - uh this was the page that we were
274:24 - navigating like suppose uh we were
274:26 - inspecting this page this one and
274:29 - we were traversing to the parent right
274:31 - and there's only one parent element so
274:33 - this one so i have used
274:35 - two uh slashes over here if you can see
274:38 - let me i'll write it in front of you
274:40 - wait
274:42 - two slashes i have used there are two
274:44 - slashes over here and i'm using parent
274:47 - two colors that is in scope of operator
274:49 - and
274:51 - a asterisk sign which is used to select
274:53 - all the elements right it shows all the
274:55 - elements so it's using it's selecting
274:56 - only one element is matching over here
274:58 - that is the form tag as i said the form
275:00 - tag is the parent type whereas if i use
275:02 - one slash i have used only one slash and
275:05 - parent
275:10 - and two colons and asterisk
275:13 - still the one element still only one
275:14 - element is
275:15 - matching okay so it does not matter if
275:17 - you uh
275:19 - put two slashes or one slash to it okay
275:23 - so next we have the slash tag name the
275:25 - tag name slash tag name is used to write
275:27 - the except x bar that we usually write
275:29 - that is a relative x path the syntax of
275:32 - it is this the two slashes the tag name
275:34 - at the rate the attribute is equal to
275:36 - value for example id and the value that
275:38 - we use it in country or anything then we
275:40 - have the contains method in the text
275:42 - method in the contents method we can
275:44 - have the two slashes tag name and the
275:46 - contains method
275:48 - and we can write at the rate attribute
275:50 - and the value for example at the rate id
275:52 - and the value that is country
275:54 - similarly if you want to use contains
275:56 - method and the text method together okay
275:58 - so what we're going to do is tag name
276:00 - contains
276:01 - text and then the value now here the
276:03 - star the asterisk which is used over
276:06 - here right it selects all the methods
276:08 - with the same value now for example if i
276:10 - write two slashes and the asterisk
276:12 - method contains text and the value that
276:15 - i'm writing is country so what will do
276:17 - what it will do is it will uh select all
276:20 - the value which is having country okay
276:23 - whereas if i'm taking tag name like for
276:25 - example if i'm writing input so under
276:28 - input tag whatever country values are
276:30 - present it will select that okay so that
276:32 - is the difference between the asterisk
276:33 - and the tag name that is present over
276:35 - here
276:36 - next we have the logical and in the or
276:38 - operator that we were using similarly we
276:40 - can just use and and the or the chart i
276:42 - also i have given the chart about the
276:44 - and in the or operator in which case the
276:47 - element will be identified in which case
276:49 - it will not be identified you can check
276:51 - it out in the previous tutorial
276:53 - next we have to start with the function
276:55 - that we're using
276:56 - this is similar to the
276:59 - dynamic functionality which we were
277:00 - starting in the previous tutorial the on
277:02 - and off button which i explained
277:05 - so you can write the starts with either
277:07 - right attribute the value whatever value
277:09 - is having the same value for example the
277:12 - start and the stop button right they
277:14 - have the two words that is the st was
277:17 - the starting value our same right so we
277:19 - can use that so starts with is used in
277:21 - that case the next we have the x path
277:23 - accesses that is a cell following
277:25 - following sibling ancestor proceeding
277:27 - descendant parent and child these are
277:29 - the uh syntaxes of all these uh self and
277:33 - following which we study till now so you
277:35 - can have uh you can study this and get a
277:37 - hang of it okay so this is a small cheat
277:39 - sheet which i usually refer while
277:41 - studying the expat so you can also check
277:43 - it out so this is all for today
277:45 - so this is all for today we learned
277:47 - about the xpath advanced expat we
277:50 - saw that practical implementation
277:52 - with the static web page as well as a
277:54 - dynamic table that we have seen
277:57 - so in this tutorial we will understand
277:58 - about the shadow dom objects so let's
278:00 - get started
278:01 - so before understanding about the shadow
278:03 - dome let us understand what is dom
278:06 - dom means document object model
278:09 - so when the web page is loaded the
278:10 - browser creates a tree of objects on the
278:13 - web page and this tree is called as dom
278:15 - like in the previous tutorial i
278:17 - explained dom is an api
278:19 - in which when the web page is loaded the
278:21 - browser creates a tree of objects on the
278:23 - web page like here you can see we have
278:25 - the root element html then we have the
278:27 - head we have title under the html we
278:30 - have the body tag
278:32 - inside the body tag we have the h1 the a
278:34 - tag and all these tags are inside the
278:37 - body tag right so this is a dom
278:39 - structure that is the document object
278:41 - model structure for example
278:44 - for example this page and if i click on
278:47 - inspect
278:48 - and here you can see
278:52 - this entire thing is your dom that is
278:54 - we're having the html head body and the
278:57 - div tags the input tags all this is your
279:00 - dom
279:03 - we have the head we have the we have
279:05 - html we have head and the body tag in
279:07 - the closing html tag so this is a dom
279:09 - structure okay
279:11 - now dom provides power to javascript to
279:14 - do some following things like they can
279:16 - change the elements of the page they can
279:18 - change the attributes of the element of
279:20 - the page we can add or remove elements
279:23 - or attributes in a page we can create
279:24 - new html events and we can react to
279:26 - those events now how do we do that let
279:29 - me explain you with the help of an
279:30 - example
279:34 - now uh for example suppose uh let me
279:36 - write html
279:39 - if i write html over here
279:42 - and i'll write the
279:44 - body i'll give the body tag
279:46 - then i'll use the p tag i'll write a
279:48 - text over here
279:50 - this
279:52 - is not shown this is my p tag
279:55 - now let me run this and here the output
279:58 - is on the console that is this is not
280:00 - shown this is the output
280:02 - now what if i write a javascript code
280:07 - i will write my javascript code in my
280:09 - script tag
280:11 - so here i will write document
280:15 - dot
280:17 - get element
280:23 - by id so i'll give an id over here in p
280:26 - tag
280:27 - i will write an id over here i'll write
280:29 - it as x
280:31 - 1
280:32 - so the id that i'm accessing over here
280:34 - is
280:35 - x1
280:38 - okay now i'll use a dom property that is
280:41 - the inner
280:43 - html
280:44 - is equal to
280:47 - welcome to
280:52 - programming
280:54 - knowledge
280:57 - okay
280:58 - now let's run this command
281:01 - and here you can see the output is
281:03 - welcome to programming knowledge
281:05 - now what we can see over here is that
281:08 - welcome to programming knowledge is
281:10 - overriding this is not shown
281:12 - okay what happens is when we write
281:14 - document.getelementbyid
281:16 - it finds this id x1
281:18 - and it uh changes this element that is
281:21 - this is not shown is changed to welcome
281:23 - to programming knowledge
281:25 - okay
281:26 - so this is what is happening over here
281:28 - so dom provides the power to javascript
281:32 - to change the element to change the
281:33 - attributes of the element we can add or
281:35 - remove the elements of the web page and
281:37 - we can create new html events as well
281:40 - what is the need of shadow dom like in
281:42 - the previous slide i explained that dom
281:45 - provides
281:46 - power to the
281:47 - javascript to change the lms right now
281:50 - there are websites that require some web
281:52 - components developed by others that
281:54 - contains the html css in javascript code
281:57 - what are these web components for
281:59 - example
282:02 - like this is the online id that i'm
282:04 - having and here you can see these
282:06 - advertisements right here you can see
282:08 - these ads
282:09 - these ads are controlled by some other
282:11 - site
282:12 - okay
282:13 - and you can see this is facebook so this
282:15 - is controlled by the facebook site
282:17 - similarly over here if you can see we
282:19 - have different types of ads over here
282:21 - like here you can see this dell ad
282:23 - also if you're looking some other pages
282:25 - like hurry also you can see this is the
282:27 - microsoft exchange this is also
282:28 - controlled by some other site
282:30 - all these ads are controlled by some
282:33 - other side
282:34 - so what you're saying is that these are
282:35 - the web components that is developed by
282:37 - others that contains the html css and
282:40 - javascript code now for example over
282:42 - here this this thing that you can see
282:45 - this web component is having an html css
282:48 - or javascript code
282:49 - now when i integrate with my code this
282:51 - is the code that i am having obviously
282:54 - as i said dom is giving the
282:56 - ability to javascript to change the
283:00 - elements right so what if all the code
283:02 - that is written over here in this
283:04 - javascript is changing the code that is
283:06 - written over here in the html
283:09 - it's harmful right so that's the reason
283:11 - why we are using shadow dom
283:14 - over here
283:16 - the objective is that people want to use
283:18 - this web component of others but they
283:19 - don't want their invo they don't want to
283:22 - impact the sites
283:23 - so how do we integrate a web component
283:26 - from other developer
283:28 - so that they cannot access my component
283:30 - so that their component my components
283:32 - don't interfere how do we do that the
283:34 - solution is the shadow dom and iframes
283:37 - now iframe is something different for
283:39 - example suppose if i give something uh
283:42 - some
283:44 - iframe some functionality is presented
283:47 - over here there is some functionality
283:49 - over here
283:52 - this is functionality one and there's
283:54 - another iframe that i have
283:58 - there is some
284:01 - functionality too
284:04 - so whatever changes that i perform in
284:05 - functionality one will not affect the
284:07 - changes in the functionality too
284:10 - that is the feature of iframe okay this
284:12 - is one feature of iframe uh we will
284:14 - study about iframe in detail but for now
284:16 - to understand whatever functionality uh
284:19 - whatever changes i do in functionality
284:21 - one will not affect the changes in the
284:23 - functionality too this is what iframe is
284:26 - okay
284:28 - coming to the next is shadow dom
284:30 - now what is shadow dom
284:32 - since we have understood the need of
284:34 - shadow dom we have understood what is
284:35 - dom and how does dom uh provide the
284:38 - power to the javascript to change
284:41 - elements so we have understood what is
284:43 - the need but what is dom this is the
284:45 - definition
284:46 - shadow dom is a web standard that
284:48 - developers use to encapsulate their html
284:52 - code and style components
284:54 - so that no the style component can
284:56 - overwrite their code
284:59 - for example
285:01 - for example suppose so we are working in
285:04 - a group we are working in a group of
285:06 - four to five people and there's a
285:08 - project and everyone is working on
285:10 - different different functionality so let
285:12 - us take up suppose
285:14 - there's a use of one
285:16 - so this user is developing some
285:18 - functionality and i'll just write a code
285:20 - for it suppose uh div class
285:22 - is equal to i'll write it
285:25 - v
285:27 - and i'll write h1 tag over here
285:30 - and i'll write a
285:33 - hello
285:35 - world
285:37 - okay
285:39 - and i'll write some styling over here
285:41 - i'll give some styling so since it's a
285:43 - class so dot v
285:47 - and i'll write
285:49 - some color
285:50 - and i'll give color as red
285:53 - let's run this
285:55 - so here the output is hello world in red
285:58 - color okay this is the user one score
286:00 - now uh the user one is not knowing what
286:03 - the user two is coding they are working
286:05 - in group but differently right someone
286:06 - is working for some other functionality
286:08 - someone is working with some other
286:09 - functionality so this is the first
286:11 - functionality which the user one created
286:12 - so i'll just comment this for now and
286:14 - let's see the next example
286:19 - so the next user
286:20 - develop some of the functionality let's
286:22 - see some other functionality and uh
286:26 - i'll just write a code of it i'll write
286:27 - div
286:29 - i'll write class
286:30 - and now the user two does not know what
286:33 - the user one has coded so
286:36 - there might be a chance that they have
286:37 - named the class similar so i'll name the
286:40 - class as v itself then i'll write the in
286:43 - h2 tag
286:48 - i'll write
286:50 - hello
286:51 - user 2
286:54 - okay
286:55 - and i'll write some code for css
287:00 - because it's a class so i'll access by a
287:02 - dot v
287:03 - and i'll write
287:05 - color
287:07 - i'll give it as
287:09 - green
287:11 - okay
287:12 - so let's see here the output is for the
287:14 - user too
287:15 - now since we are working in a project
287:16 - and we need to present it so we will
287:18 - integrate the code okay user1 and user2
287:21 - are integrating their codes so what will
287:23 - happen
287:24 - for example the user1 and user2 has
287:27 - integrated their code now what will
287:29 - happen
287:30 - as we know for user one our output was
287:32 - hello world in red color and for user 2
287:34 - our output was hello user 2 in green
287:37 - color
287:38 - so now
287:39 - after integrating let's see what the
287:41 - output is
287:43 - it's hello world in green color
287:45 - it's hello user 2 in green color which
287:48 - means
287:49 - this css style is overriding this css
287:52 - style right
287:53 - that's what is the definition of shadow
287:55 - dom
287:56 - shadow dom is a web standard that
287:58 - developers use to encapsulate their html
288:01 - code and css components style components
288:03 - means css components
288:05 - they are encapsulating their html code
288:08 - and css components so that no other css
288:10 - component can overwrite their code
288:13 - now in this case
288:15 - if user1 has given class v so there
288:18 - might be many classes of class we write
288:20 - of name v there would be very many
288:22 - classes of name v
288:24 - all those v classes will get overrided
288:26 - by green color right the entire text
288:28 - will be a green color so here the css
288:31 - style is overriding
288:33 - right so this is the definition of
288:36 - shadow dome
288:37 - so when we try to find shadow dome
288:39 - elements using the selenium locators it
288:41 - will throw no such element exception
288:44 - okay now how do we identify it is a
288:48 - shadow dom object for example
288:52 - i have this website this website is
288:54 - having the shadow dom elements so if i
288:56 - want to inspect this element i'll click
288:58 - on inspect
289:00 - and here you can see this shadow root
289:02 - open
289:03 - this shadow root open is used to
289:06 - denote the shadow dom object
289:09 - so uh another thing that we can see over
289:11 - here is if i see in selectors hub here
289:15 - it is it is in blue color that is in
289:16 - shadow dom it is here written over here
289:18 - so this means that this element is a
289:20 - shadow dom element here it is written
289:22 - the element inside the shadow dom and
289:24 - for such elements xpath won't support
289:27 - yes for shadow dom elements uh xpath
289:30 - will not support we need to inspect
289:33 - these elements through css selectors
289:36 - okay
289:37 - now let me give an example like suppose
289:39 - this is also a website which is having
289:40 - the shadow dom elements so if i want to
289:42 - inspect this element i'll click on
289:44 - inspect
289:45 - and since you here you can see we have
289:47 - shadow root open shadow root open shadow
289:49 - root open so this is a shadow dom object
289:51 - okay
289:52 - let me open my selectors hub and here
289:54 - you can see we have this element is
289:56 - inside shadow dom object and in such
289:59 - elements x path is not supported now
290:02 - what if we give an x path if i want to
290:04 - inspect this element let's see what
290:05 - error do we find so i have already
290:08 - created a selenium tutorials nine java
290:10 - class over here in which we have the
290:12 - first command is open the chrome browser
290:14 - in which we have system dot set property
290:16 - the key and the value is given over here
290:19 - next we have written web driver driver
290:20 - is equal to new chrome driver to launch
290:22 - the chrome driver
290:24 - next we are navigating to the url this
290:26 - is the url that we are navigating to and
290:28 - this is the element that we want to
290:30 - inspect so we will write a expert
290:33 - expert for this element okay
290:36 - let's see
290:37 - then i'm maximizing the window and this
290:39 - is the expert that i have written over
290:40 - here
290:41 - like i've written driver dot find
290:43 - element by dot xpath
290:45 - two slashes and the tag that i'm using
290:47 - is the input tag
290:49 - here you can see we have input tag also
290:52 - sele the
290:53 - attribute that i'm using is the id
290:55 - attribute and the value of it is input
290:58 - so the id attribute and the value is
291:00 - input and i'm sending some command as
291:02 - testing so let's see if we can run this
291:05 - code
291:06 - and what error do we find so
291:16 - so our chrome browser is launched
291:20 - it's navigated and it's maximized
291:24 - can you see some text over here no right
291:28 - so here there's an error let's see what
291:31 - that error is
291:33 - we have no such element exception that
291:36 - is no such element unable to locate this
291:38 - element
291:39 - we are unable to locate this element
291:41 - this is shown over here this is the
291:43 - error that we are getting and there is
291:44 - no text sent over here do you see any
291:46 - text no right there is no text sent over
291:48 - here so it says that is unable to locate
291:51 - element so whenever we locate we try to
291:54 - locate the shadow dome elements this is
291:56 - the error that we find that is the no
291:57 - such element
291:59 - exception is given over here and shadow
292:01 - domes does not support the x path okay
292:04 - we have to use a css selector to access
292:07 - shadow dom objects
292:09 - also to access shadow dom elements we
292:11 - need to use we have to use the
292:13 - javascript executor we will understand
292:15 - that by implementing it
292:20 - next there are some terminologies in
292:22 - shadow dom while inspecting the element
292:24 - while
292:25 - identifying it these terminologies will
292:27 - be used
292:28 - one is the shadow horse that is the
292:30 - regular dom node that the shadow dom is
292:32 - attached to this is the shadow host
292:35 - right it is the regular dom node that
292:38 - the shadow dom is attached the shadow
292:40 - dom is attached to shadow host
292:42 - next we have the shadow tree
292:44 - the dom tree inside the shadow dome this
292:47 - is the shadow tree that we are having
292:48 - here you can see this highlighted part
292:50 - this is the shadow trees that we are
292:52 - having
292:52 - it is a dorm tree inside the shadow dom
292:55 - inside the shadow dome these are the dom
292:56 - trees
292:59 - next we have the shadow boundary here
293:01 - you can see this is the shadow boundary
293:03 - this is a place where the shadow dome
293:05 - ends and the regular dome begins okay so
293:08 - this is the place where the shadow dome
293:10 - ends and the regular dome begins
293:12 - next we have the shadow root that is the
293:14 - root node of the shadow tree now this is
293:16 - the most important element that we are
293:18 - going to inspect like suppose if you
293:20 - want to inspect this element we will
293:21 - inspect the shadow root we will inspect
293:23 - the shadow host so we will understand
293:25 - that but for now these are some of the
293:27 - terminologies that is used in the shadow
293:29 - dom structure
293:31 - so uh now how to identify it like i have
293:34 - showed you before like we have the
293:36 - shadow root written over here that means
293:37 - it is a shadow dom object also if we go
293:40 - on selectors huh so over there there it
293:42 - has a feature it shows in blue color
293:44 - letters in shadow dome it also gives a
293:46 - information about that relative x path
293:48 - is not supported that is this element is
293:50 - in shadow dome and for such elements
293:52 - xpath is not supported
293:54 - so this is one way to identify the
293:56 - shadow dom object now next we will
293:58 - understand its implementation let us do
294:00 - a practical implementation on it so this
294:02 - is the website that we need to automate
294:04 - and this is the element that i am
294:05 - inspecting
294:06 - so i want to enter some value over here
294:09 - any value i want to enter so this is the
294:11 - element
294:13 - now before writing the code for it we
294:15 - need to understand the elements that are
294:17 - under shadow dom and which are not under
294:19 - shadow dom okay
294:21 - so
294:22 - this is the dom structure which we have
294:24 - this is the entire dom structure we need
294:26 - to understand it first
294:28 - this is the element that we want to
294:30 - inspect
294:31 - okay which is not under shadow root the
294:35 - elements that are under shadow root is
294:37 - style div div slot name these are the
294:40 - elements that is present under shadow
294:41 - root
294:43 - this input is under book input decorator
294:47 - top okay
294:49 - this book input decorator top is not
294:52 - under the shadow root if you are
294:53 - thinking this is under shadow root
294:54 - because the shadow root is written over
294:56 - here no
294:57 - if we click on this we can see the style
294:59 - and the slot tags are under the shadow
295:01 - root but the book input deck or top is
295:04 - not under the shadow root okay
295:08 - so this book input decor top is under
295:10 - the app toolbar
295:12 - so
295:14 - this book input decker top is under the
295:16 - app toolbar and this app toolbar is not
295:18 - under the shadow root
295:20 - can you see anything can you see the
295:22 - shadow root the shadow root is present
295:24 - over here in which we have the style and
295:25 - the div tags okay so this app toolbar is
295:29 - not present under the shadow root
295:32 - this book input echo is
295:34 - present into app toolbar
295:36 - okay
295:37 - next this app toolbar is present under
295:40 - the app header this is the app header
295:43 - okay
295:44 - which is inside the shadow root here you
295:47 - can see the shadow root now if i click
295:49 - on this we can see app header right
295:52 - so app header is under the shadow root
295:55 - and then we have the app book which is
295:57 - the host
295:58 - here we can see the root element and
296:00 - this is the host element
296:02 - right so first we will go on app book we
296:05 - will inspect the app book then we will
296:08 - enter the shadow root element
296:10 - after entering the shadow root
296:13 - we will move to app header
296:15 - after app header we will go on app
296:18 - toolbar
296:19 - after app toolbar we will go on book
296:22 - input decor and after in book input
296:24 - record we will inspect this element okay
296:28 - this is the element that we want to
296:29 - inspect
296:30 - right so this will be the entire process
296:33 - the first thing is that we have to
296:34 - identify the host
296:36 - this is our host this is the root
296:38 - element right
296:39 - so first we will inspect the app book
296:42 - then we will enter the dom element
296:44 - inside the dom element first we will
296:46 - enter the app header
296:48 - after app header we will inspect the app
296:50 - toolbar and after app toolbar we will
296:53 - inspect the book input decor and then we
296:56 - will inspect the inputs uh tag okay
297:00 - okay so this is the element that we want
297:02 - to inspect
297:03 - right this input is the element that we
297:05 - want to inspect
297:07 - this input is under book input
297:10 - okay
297:11 - this book input is under the app toolbar
297:15 - and this app toolbar is under the app
297:18 - header
297:19 - okay
297:21 - this app header is under the shadow root
297:24 - this is our route
297:26 - and this is our host
297:28 - and this is our host so the first thing
297:31 - that we will inspect is this the host
297:34 - this is the second thing we will do we
297:36 - will enter the dom
297:38 - inside dom this is the third thing that
297:40 - we will inspect that is the app header
297:43 - after app header we will go on app
297:45 - toolbar this is the fourth thing that we
297:47 - will inspect
297:48 - after app toolbar we will inspect the
297:51 - book input record this is the fifth
297:53 - thing
297:54 - and the sixth one is the input slot
297:57 - over here we will send the commands
297:59 - because it's the search box we want to
298:00 - send some command to it so after all
298:03 - these steps we can inspect this so this
298:05 - is the entire thing that we're going to
298:07 - implement now
298:09 - first we will inspect the host
298:11 - then we will enter the root the shadow
298:13 - root after entering the shadow root over
298:16 - here we will use a javascript executor
298:18 - after here over here after this
298:21 - we will access the app header
298:24 - after app header we will access the
298:26 - app toolbar we will inspect the app app
298:29 - toolbar after that we will inspect the
298:32 - book input record and then we can move
298:34 - on to input okay so this is the entire
298:37 - process that we're going to follow
298:38 - so
298:39 - let's do that
298:41 - so first let's inspect the host
298:44 - we will write a driver
298:47 - dot
298:48 - find element
298:50 - by dot
298:51 - tag name
298:54 - over here we're going to write
298:58 - this is our host right so we are
298:59 - inspecting our host
299:01 - the tag name is book app
299:05 - so i will write book app over here
299:10 - this is a web element
299:12 - i'll write web element
299:16 - host
299:17 - is equal to driver dot find element by
299:20 - dot tag name okay
299:22 - next we will enter the dom
299:24 - okay for that we need to write
299:26 - javascript executor
299:28 - j
299:30 - is equal to
299:31 - driver
299:33 - because this driver
299:36 - is of web driver driver is equal to new
299:38 - chrome driver
299:40 - so i'm going to write
299:43 - i'm going to typecast it so i'll write
299:46 - javascript executor driver okay
299:50 - next i'm going to do j dot
299:53 - execute script which accepts two
299:55 - arguments one is the string and one is
299:57 - the object argument so here in string i
300:00 - will write
300:01 - return
300:03 - arguments
300:05 - the zeroth one
300:07 - and where do i want to enter is i want
300:08 - to enter to shadow root right
300:11 - so i'll write the shadow root the zero
300:13 - shadow root uh shadow root is present in
300:16 - the host element right so i'll write
300:18 - comma host
300:20 - okay
300:23 - now i'll give this a
300:26 - web element
300:28 - i'll write
300:30 - shadow dom
300:32 - is equal to
300:36 - says we need to cast it to web element
300:39 - now just because this is of javascript
300:41 - executed type we need to cast it to web
300:43 - element because i want to inspect web
300:44 - elements over here okay
300:46 - now whatever we're going to do we're
300:48 - going to do inside the shadow dom
300:50 - okay
300:52 - this is the shadow dom we inspected the
300:54 - host element we are
300:57 - and we inspected the shadow root element
300:59 - so we are inside shadow root now now
301:02 - inside shadow root inside the shadow
301:04 - root what i want to inspect is app
301:06 - header now okay so what i'm going to do
301:08 - is
301:09 - this is the app header
301:12 - i will write
301:14 - shadow
301:16 - dom
301:18 - dot
301:19 - find element
301:21 - by dot
301:24 - tag name and inside the tag name i will
301:27 - write
301:29 - app header
301:36 - and i will
301:38 - give it as a web element
301:43 - app header
301:44 - okay
301:47 - so so far uh we have inspected our host
301:50 - we are into our dom element also we have
301:53 - inspected the
301:54 - app header
301:55 - now we are left with the app toolbar the
301:58 - book input decorator and then the input
302:00 - slot
302:01 - so after navigating to app header we
302:04 - need to enter the app toolbar okay so
302:07 - what i'm going to do is
302:13 - i will write
302:15 - app header dot
302:19 - find element
302:21 - by dot
302:27 - now this app toolbar there are two app
302:29 - toolbars here you can see this one and
302:31 - this one right so here the class name is
302:33 - different so we will access by class so
302:35 - we will use the css selector over here
302:38 - so i'll write by dot css selector
302:42 - and then i'll write
302:44 - input oh and then sorry i'll write
302:49 - app toolbar
302:53 - because it's a class so i'll write dot
302:56 - and the toolbar bottom
303:00 - okay so this is my tag name and this is
303:02 - my class
303:03 - i'll give a web element
303:05 - i'll name it as
303:08 - app
303:09 - tool
303:12 - okay
303:14 - so so far
303:16 - we have navigated to host we have
303:18 - inspected our host then we came into our
303:20 - dom element after that we navigated to
303:22 - app header
303:23 - and after which we came to app toolbar
303:25 - this is the app toolbar that we key
303:27 - now inside the app toolbar we want to go
303:29 - to the book input decorator so we're
303:32 - going to write
303:34 - this is the book input
303:38 - so what i'll do is i'll write app tool
303:42 - dot
303:43 - find element
303:46 - by dot
303:50 - tag name
303:52 - and i'll write the tag name over here
304:05 - i'll give this a web element
304:08 - i'll write a web element for your web
304:09 - element
304:11 - book
304:12 - is equal to app tool dot fine element
304:16 - okay
304:17 - so now we will inspect our element that
304:19 - is the input tag
304:22 - so what we're going to do is we'll write
304:24 - book
304:26 - dot
304:28 - find element or let us use a css
304:30 - selector so i will use the css selector
304:33 - i'll write
304:38 - by dot css selector
304:42 - so we can use
304:44 - this is the tag and the id that we have
304:46 - is input so i'll use input input
304:51 - input because it's a id so hash input
304:56 - and what value do i want to send i want
304:58 - to send
305:00 - some key to it i will send
305:03 - selenium web
305:05 - driver
305:09 - okay
305:11 - so let's run this
305:19 - so a chrome browser is launched
305:23 - it's navigated
305:27 - let's maximize and here you can see that
305:29 - the command is sent that is the selenium
305:31 - webdriver
305:32 - okay
305:36 - so uh this is what
305:38 - is shadow dom is
305:40 - as i said
305:41 - first we need to find the host element
305:43 - so our host element was book app then we
305:46 - entered the shadow dom
305:48 - after entering the shadow dom we have to
305:50 - inspect the app header after app header
305:52 - we inspected the app toolbar after which
305:55 - we inspected the book input decorator
305:57 - and then we inspected the input tag
306:00 - so here you see
306:01 - uh first we need to understand the dom
306:04 - structure before writing a code for the
306:06 - uh shadow dom we need to understand
306:08 - which elements are under shadow dom and
306:10 - which elements are not under shadow dog
306:12 - so this is one way
306:15 - so this is how we're going to do it now
306:17 - there are different sites where you can
306:20 - practice
306:21 - shadow dom like you can
306:23 - use the chrome download page as well
306:26 - this download page is also having
306:30 - shadow root elements for example like if
306:32 - you want to inspect this
306:34 - download here you can see we have shadow
306:36 - root elements this is the shadow root
306:38 - this is shadow road this is shadow root
306:40 - also uh there are different ways
306:42 - websites like um
306:45 - let me show you one
306:47 - like this is the website that is there
306:49 - for shadow dom practice like all the
306:51 - elements that are present over here are
306:52 - of shadow dom
306:54 - here we have shadow root we have shadow
306:56 - roof we have shadow roots so you can
306:57 - have a hang you can
306:59 - practice on this website also
307:02 - so i'll give all these links in the
307:03 - description so you can get a hang of it
307:06 - so in the previous tutorial we learnt
307:08 - about the shadow dom objects in this
307:10 - tutorial we are going to understand some
307:12 - of the important selenium commands which
307:14 - is frequently used to write the test
307:16 - scripts
307:18 - now these selenium commands consist of
307:20 - the browser commands the navigation
307:22 - commands and the web element commands
307:25 - today we are going to understand the
307:27 - browser commands like what are browser
307:29 - commands what are the different types of
307:30 - browser commands with their syntax also
307:33 - we will implement some set of test cases
307:36 - and then we will understand the
307:37 - difference between the close method and
307:39 - the quick method so let's get started
307:42 - now first let us understand what are
307:43 - browser commands
307:45 - browser commands are something that are
307:47 - very basic operations of the web driver
307:50 - which includes the closing of the
307:51 - browser performing some few tasks to see
307:54 - you task is like get title
307:57 - to
307:58 - quit to manage to close the browser to
308:01 - get the current url to get the page
308:03 - source so these are some of the uh
308:05 - operations these are some of the few
308:07 - tasks that we perform on the selenium
308:09 - webdriver
308:10 - so and these are some of the list that
308:12 - is given over here
308:14 - this is the list that is given over here
308:15 - now if you write for example
308:18 - if i write driver dot
308:21 - you can see this list so these are the
308:24 - different this list which is getting
308:26 - highlighted over here so these are the
308:28 - different browser commands that is
308:29 - present over here okay so these are
308:31 - browser commands
308:32 - now i have just created this basic uh
308:35 - uh notes
308:37 - this basic sheet which consists of the
308:39 - browser commands the navigational
308:41 - commands the web element commands which
308:44 - consists of the commands the description
308:46 - the syntax and what parameters accepts
308:49 - and what it returns
308:50 - it will be very quick recap for you
308:52 - while going in interviews because they
308:54 - frequently ask these questions like what
308:56 - is the difference between the close the
308:58 - quit method the submit and the click
309:00 - method
309:01 - and what is the difference between find
309:03 - element and find elements so these are
309:05 - some of the differences which we will
309:07 - cover
309:08 - and also we will study these commands so
309:11 - uh
309:12 - this is the sheet that i have prepared i
309:13 - will give the link of this sheet in the
309:15 - description box you can download the pdf
309:18 - format also i have uploaded on my drive
309:20 - so i will give the link of this drive as
309:22 - well so you can get a hang of all those
309:25 - commands whenever you go for interviews
309:27 - now coming to the test cases
309:29 - these are the test cases which we will
309:31 - execute
309:32 - and while executing we will cover these
309:35 - commands
309:36 - these are the commands like the get the
309:37 - get title the get current url to get
309:40 - paid source to close and the quit
309:42 - now get window handle and get window
309:44 - handles is a part of the browser command
309:47 - but it is a bit complicated
309:49 - i will cover that in the later tutorial
309:51 - so for now we need to get a hang of get
309:54 - get title get current url get paid
309:56 - source close and quick so by executing
309:59 - these test cases we will create the test
310:01 - scripts of these test cases we will
310:03 - understand these commands also okay
310:06 - first test case that we have is the open
310:08 - the chrome browser
310:10 - okay in which we use the system dot sell
310:12 - property
310:13 - and uh
310:14 - the web driver driver is equal to new
310:16 - chrome driver these are the two commands
310:18 - that we use in opening the chrome
310:19 - browser
310:21 - then navigate to the url to navigate to
310:23 - the url we use the
310:25 - drive.driver.getcommand right so this is
310:27 - the part of the browser command next we
310:29 - will maximize the window
310:31 - the next we will verify the current url
310:33 - of the page for this we will use the
310:35 - current
310:36 - get current url command okay
310:39 - through if statement
310:40 - okay then we have to verify the title of
310:43 - the page now to verify the title of the
310:45 - page we will use the get title command
310:48 - okay and we will verify it through if
310:51 - statement
310:52 - next we will print the length of the
310:54 - title of the page and this we will use
310:56 - the length command we'll have a look at
310:58 - that okay next we will print the page
311:00 - source of the page
311:02 - in which we will use the get page source
311:04 - command also we will print the length of
311:06 - the page source okay
311:08 - next we have to close the browser and
311:10 - quit the browser now uh we will
311:12 - understand the difference also uh
311:14 - practically okay so this is the webpage
311:17 - that i want to automate today now i have
311:19 - created a
311:20 - java class in my
311:23 - package combat selenium in which i have
311:26 - named it as selenium tutorials then i'll
311:28 - be executing my test scripts over here
311:31 - in this in this selenium tutorial 10 the
311:34 - first test case was to open the chrome
311:36 - browser for which we use the system.set
311:38 - properties
311:40 - in which we give the key and the value
311:42 - the key is the webdriver.chrome.driver
311:44 - and the value is the executable chrome
311:47 - driver file okay
311:49 - next we have the web driver driver is
311:51 - equal to new chrome driver
311:54 - why do we write the statement i have
311:55 - explained in the previous tutorial you
311:57 - can have a look at that tutorial
312:00 - okay the next command is that we have to
312:02 - navigate to the url
312:04 - so what i'll do is i'll write driver
312:08 - dot
312:10 - get
312:12 - and i will write my url in this get
312:17 - this is
312:18 - the first method okay to navigate to the
312:21 - url
312:24 - the second method that you can do or you
312:26 - can
312:27 - navigate is
312:29 - i can assign the url to a string
312:31 - variable
312:32 - like i'll write string
312:35 - i will name that variable as url
312:38 - and i will place my url in this
312:41 - variable
312:42 - next i will write driver
312:44 - dot get
312:46 - url
312:48 - so i can navigate to the url through
312:50 - this way as well as this way both the
312:53 - ways it will work for example so let's
312:55 - see
312:56 - whether we can navigate or not so by
312:58 - using this method driver dot get method
313:04 - okay so chrome browser is launched and
313:06 - also it is navigated to this
313:09 - page
313:10 - i will
313:12 - comment this and let's see
313:18 - okay so i chrome browser is also known
313:20 - so net is also navigated
313:22 - so these are the two methods to which
313:23 - you can navigate to the url
313:26 - now get method
313:28 - i will just comment this for now we will
313:30 - use this driver.get method now uh get my
313:34 - turn on this commands open the specified
313:36 - url in the browser it accepts string as
313:39 - a parameter and it returns nothing okay
313:42 - and this is the basic syntax of
313:44 - navigating to the url and it is a part
313:46 - of the browser command
313:49 - so next test case that we have
313:52 - is to maximize the window
313:54 - so i'll write driver
313:56 - dot
313:57 - manage
313:58 - dot window
314:00 - dot
314:03 - maximize
314:04 - okay so the next command is
314:08 - verify the current url of the page
314:10 - url of the page
314:12 - let's first find the url and then we
314:14 - will verify
314:15 - so i'll write driver
314:17 - dot
314:18 - get current url
314:22 - and i will store this in a
314:24 - string variable
314:27 - string
314:29 - url of the page
314:31 - and i will print this
314:39 - okay
314:40 - let's see what is the output
314:45 - so chrome browser is launched
314:49 - it's navigated
314:53 - it's maximized
314:59 - and here it is the url of the pages
315:01 - this this is the url of the page
315:04 - now let's verify the url
315:07 - to verify the url we will use the if
315:09 - statement so i will write if
315:12 - url of the page
315:15 - dot equals
315:17 - now i will write
315:18 - the url over here
315:24 - now if i was uh executing this statement
315:27 - this navigation statement what would i
315:29 - do what did i do over here is that i
315:31 - have written string url right so what
315:34 - would i do over here i will simply write
315:37 - url
315:40 - okay
315:42 - so this means that the url of the page
315:44 - that is the output that we are getting
315:46 - the actual output and the expected
315:48 - output
315:49 - will be matched the expected output is
315:52 - this this which is stored in this url
315:54 - variable and the actual output is stored
315:57 - in the url of the page right so if i
316:00 - would execute this statement i would
316:02 - have written this way but since i'm
316:04 - executing driver.getcommand i'm not
316:06 - writing it this way i'm not storing it
316:08 - in a string variable and then
316:10 - writing driver.get and inside get i'm
316:12 - writing the url the parameter that i'm
316:15 - giving is the url that is a string
316:16 - parameter
316:17 - so i'm not executing it this way i'm
316:20 - executing through driver.getcommand so
316:22 - i'm not writing it this way so i'll just
316:23 - simply write what output do i want this
316:27 - is the expected output that i'm writing
316:28 - over here and the actual output that i'm
316:30 - getting is the url of the page okay
316:33 - [Music]
316:35 - now if the actual and the expected
316:38 - matches so what i want is
316:40 - i want the output as
316:44 - the url
316:46 - is
316:47 - verified
316:50 - and then else
316:54 - i want
316:58 - the url is
317:00 - not
317:01 - verified so now let's execute this
317:05 - so my chrome browser is launched it's
317:08 - navigated
317:11 - it's maximized
317:14 - and now let's see the url of the pages
317:16 - this is the url and the url is verified
317:18 - that means the
317:20 - actual url that we are getting that is
317:22 - this and the expected view url
317:25 - that is this both is matching okay
317:29 - this is the expected url and this is the
317:31 - actual url both are matching that's the
317:33 - reason why we have called the url is
317:35 - verified
317:36 - for example if i just
317:39 - write it this way now let's see if it
317:42 - works
317:44 - so my chrome browser is launched
317:47 - it's navigated
317:52 - it's maximized
317:54 - okay and here you can see the url is not
317:56 - verified why
317:58 - because my actual that is this is my
318:00 - actual
318:01 - and the expected is not matching that's
318:04 - the reason why the output is the url is
318:06 - not verified
318:08 - the next test case is verify the title
318:10 - of the page
318:12 - so first we will find the title of the
318:14 - page
318:15 - so i'll write driver
318:17 - dot
318:18 - get
318:19 - title
318:21 - and i will store this in a string
318:22 - variable
318:25 - i will write string
318:28 - title is equal to driver dot cat title
318:31 - next i will print it
318:34 - so let's execute it
318:36 - my chrome browser is
318:44 - launched so here it is see this is the
318:47 - url of the page the url is verified and
318:49 - then here the title of the page is tools
318:52 - qa this is the title of the page now how
318:54 - do you see the title of the pages so
318:57 - i'll just inspect
319:02 - and you're in the head tag
319:05 - here you can see you can see title tools
319:08 - qa title this is the title of the page
319:12 - this is the title of the page
319:15 - and the title that we got is the tools
319:17 - qa so this is how you can find the title
319:18 - of the page on the
319:20 - web page okay next we have to verify the
319:22 - title right
319:25 - so
319:26 - i'll use the if statement
319:28 - i'll write if
319:31 - title
319:34 - dot equals
319:38 - okay
319:39 - so this is the title let me copy this
319:46 - and the
319:47 - output that i want if the actual and the
319:50 - expected is matching
319:54 - the title is
319:57 - verified
320:01 - in the else statement i will write
320:06 - the title
320:09 - is not
320:10 - verified
320:14 - okay
320:14 - so here uh we are verifying the title of
320:18 - the page so let's see let's see the
320:20 - output of it
320:22 - so my chrome browser is launched
320:26 - it's
320:27 - navigated
320:29 - it's maximized
320:32 - and here you can see the title is
320:34 - verified because the expected output and
320:36 - the actual output is matching
320:39 - okay
320:40 - so now next test case that we have is we
320:44 - need to print the length of the title of
320:46 - the page okay to print the length of the
320:49 - title of the page
320:50 - we're going to use the length command so
320:52 - what i'm going to do is i'm going to
320:53 - write
320:54 - driver
320:55 - dot
320:56 - get title dot
320:59 - length
321:00 - okay and i will store it in the integer
321:02 - type of variable
321:04 - because the answer that we're going to
321:05 - get is an integer so we i'm going to
321:07 - write int
321:09 - and
321:10 - title length
321:14 - is equal to driver.gettitle.length
321:18 - and
321:19 - let's print it
321:21 - so let's execute this
321:22 - [Music]
321:24 - so my chrome browser is launched
321:27 - it's navigated
321:31 - it's maximized
321:35 - and let's see the length of the title of
321:37 - the page is seven
321:39 - now it is seven because
321:42 - uh this is one two three four five six
321:46 - seven
321:47 - so the length of the title of the page
321:48 - is seven so now the next test case that
321:51 - we have is to print the page source of
321:53 - the page
321:57 - now for that i'm going to write driver
322:00 - dot
322:02 - get page source
322:05 - i will store this in a string type of
322:07 - variable
322:12 - string
322:14 - i will write
322:15 - ps is equal to
322:17 - driver dot page source next let's print
322:20 - it
322:21 - okay so now let's execute this
322:23 - so my chrome browser is launched
322:26 - it's navigated and it's maximized
322:29 - and here you can see the page source
322:31 - this is the entire page so that here you
322:33 - can see is this
322:35 - it prints the entire code of the page
322:37 - okay so it's quite long
322:39 - now we have to print the length of this
322:42 - right
322:49 - so what i'm going to do is i'm going to
322:50 - write
322:51 - driver
322:53 - dot
322:54 - get paid source dot
322:56 - length
322:57 - and i'm going to store it in the
322:59 - integer type of variable
323:01 - so i'll write in
323:04 - its source
323:06 - length is equal to
323:08 - driver.getpagesource.length
323:11 - okay
323:12 - now let's print it
323:15 - the
323:17 - length of the
323:22 - page sources
323:27 - length
323:29 - so this is the chrome browser
323:32 - now let's see here this is the length of
323:34 - the pesos now we we won't sit and count
323:37 - but since it's too long
323:40 - so this is the length of the page source
323:42 - now the next test case that we have is
323:44 - we have to click on the new tab right
323:48 - so we use the click command over here
323:50 - the click command is not a part of the
323:52 - browser
323:53 - command it is a part of a web element
323:54 - command but since we have to
323:57 - know the difference between the close
323:59 - and the quit so we are going to execute
324:01 - this command now this is the new tab
324:03 - command so i'll just inspect this
324:05 - and go to selectors hub here i can see
324:09 - the relative x path i'll just copy this
324:11 - relative x path
324:13 - i will write driver
324:15 - dot find element
324:18 - by dot
324:20 - x path
324:21 - and i will place my relative x path over
324:23 - here
324:24 - and what i want to do is i want to click
324:26 - so i right click
324:29 - and let's see
324:31 - [Music]
324:33 - so my chrome browser is launched
324:37 - it's navigated
324:39 - and it's maximized
324:43 - and the new tab is clicked so here you
324:45 - can see there is a new tab
324:47 - okay so first we will see the close
324:50 - command
324:53 - okay
324:53 - now if i write driver
324:55 - dot
324:57 - close
324:59 - just look at it very closely so i'll
325:02 - just write
325:03 - thread
325:07 - dot
325:08 - sleep
325:09 - and i'll write 100 over here
325:12 - so that you just get to know that how
325:15 - close method works
325:18 - okay it adds the exception towards
325:19 - interrupted exception over here
325:21 - and we're going to use a thread.sleep
325:23 - now thread.sleep is used in
325:24 - multithreading if you know your
325:26 - javascript concepts really well we you
325:28 - we use stand.sleep it causes the
325:31 - currently executing threat to sleep for
325:33 - some specified time so here i have
325:35 - specified the time of 100 milliseconds
325:37 - so now
325:39 - let's see the output
325:43 - i want you to closely look at the how
325:45 - driver.close works
325:50 - so our chrome browser is launched
325:54 - [Music]
325:58 - and
325:59 - the new tab is open and here you can see
326:02 - there was a parent tag over here
326:04 - the before tag okay let me increase the
326:07 - timing over here
326:12 - so my chrome browser is launched it's
326:14 - navigated now this is my parent tab
326:17 - and this is my child tab now let's look
326:20 - at it
326:21 - this tab will be close to close dot
326:23 - driver command
326:25 - if you can see let me show it you again
326:29 - i am executing the command now
326:35 - this is my parent tag that is this
326:38 - browser windows is my parent tag
326:41 - and this is my child tag now through
326:43 - driver.close the parent tag will be
326:46 - closed but my child is still open
326:48 - okay
326:49 - now i'll write
326:51 - now i will commend this and i will write
326:54 - driver
326:56 - now we'll use the quick method
327:00 - so i'll just write
327:02 - driver
327:03 - dot
327:05 - quit
327:07 - and i will
327:08 - write thread dot sleep
327:12 - okay
327:13 - now let's run this command
327:15 - so my chrome browser is launched
327:19 - it's navigated and this is my child tag
327:21 - that's my parent tag and you will see
327:25 - driver dot
327:26 - quit
327:27 - closes both the tabs so uh this is the
327:30 - parent tag now here when we perform the
327:32 - driver dot close command and the driver
327:34 - dot quit command there are two tabs okay
327:38 - uh this is the parent tab and here when
327:41 - i click on new tab this is the child tab
327:43 - okay
327:44 - so when i
327:46 - write driver.close command it will just
327:48 - close the
327:50 - parent tag it will not close the child
327:52 - tab okay
327:54 - whereas when i write driver.quit command
327:56 - it will close the parent tab as well as
327:59 - the child tab so let's have a recap of
328:01 - what we have done till now now the first
328:03 - test case was to open the chrome browser
328:06 - in which i have written the system.set
328:08 - property in which i have given the key
328:10 - and the value the key is given that the
328:12 - webdriver.chrome.driver
328:14 - and the value is the chromedriver
328:16 - executable file
328:18 - next we have to navigate to the url we
328:20 - can navigate to the url through two ways
328:22 - the first way we can do
328:24 - driver.getcommand
328:26 - now this
328:27 - java.getcommand
328:29 - this opens a specified url in the
328:31 - browser
328:32 - and this accepts a string as a parameter
328:34 - here you can see this is a string as a
328:36 - parameter and it returns nothing okay
328:40 - so this is the first method where we can
328:41 - write the driver.getcommand the
328:43 - getcommand is a part of the browser
328:45 - command
328:46 - and the second method that we can you is
328:49 - use is the we can assign the url to a
328:52 - string variable now here i have created
328:54 - a string variable like i have create
328:56 - string url and i have assigned the url
328:59 - to the string variable and then i have
329:01 - written driver.get and i have written
329:03 - this variable in my get
329:06 - the parameter that you are using is the
329:08 - string okay so basically it accepts
329:11 - string as a parameter and it returns
329:13 - nothing this is about the get command
329:16 - next we have maximized the window for
329:18 - that we have used
329:21 - driver.manage.window.maximize method
329:23 - okay
329:24 - next we have to uh
329:26 - find the url of the page what is the url
329:29 - of the page
329:31 - this is the page and this is the url so
329:33 - we have to find the url of this page
329:36 - so for that i have used the get current
329:39 - url method now this method fetches the
329:42 - string representing the current url
329:45 - which is opened in the browser
329:47 - okay and uh this accepts nothing as a
329:51 - parameter there is no parameter given
329:52 - over here but it returns a string value
329:55 - here you can see in the output here you
329:57 - can see in the output the url of the
329:59 - page so it returns the string value and
330:02 - it accepts nothing as a parameter
330:05 - and what does the get current url method
330:07 - does it does it fetches the string
330:10 - representing the current url which is
330:13 - open in the browser this page was opened
330:15 - right so it was fetching this string
330:18 - this is the current url of the page
330:21 - so for that we have given a string
330:23 - variable that is a string url of the
330:25 - page and i have written driver dot get
330:27 - current url and i've printed the url
330:30 - over here now to verify the url i have
330:32 - used the if command in which i have
330:34 - written the url of the page in which i
330:36 - am getting the
330:38 - actual output and here i am matching the
330:41 - actual and the expected output
330:43 - i'm using the equals method dot equals
330:46 - now i'm writing over here the expected
330:48 - output that i want now if the expected
330:51 - and the actual output matches the output
330:53 - will be the url is verified and if not
330:55 - the url is not verified now here it's
330:58 - matched so it is written the url is
331:00 - verified so the next is that we have to
331:03 - find the title of the page and we have
331:05 - to verify it
331:06 - now to find the title of the page i will
331:08 - be using the get title command now the
331:11 - get title command is used to retrieve
331:13 - the title of the web page
331:15 - that the user is currently working on
331:18 - now this is a page now when i inspect
331:20 - this here in the head tag you can see
331:23 - the title
331:26 - and here it is this is the title of the
331:28 - page that is the tools qa this is the
331:29 - title of the page okay now to get this
331:32 - title i have used the get title command
331:35 - which retrieves the title of the web
331:37 - page
331:38 - now it accepts nothing as a parameter
331:41 - can you see any parameters no right so
331:43 - it accepts nothing as a parameter but it
331:45 - returns a string value
331:47 - here you can see the value the title of
331:49 - the page is this this is the string
331:50 - value that it is returning so to get the
331:53 - title of the page i have written string
331:55 - title i have created a string variable a
331:58 - title i have named as title and i've
331:59 - written driver.gettitle the title is
332:02 - stored in this string variable then i am
332:04 - printing the string variable over here
332:06 - to verify it i am using the if statement
332:09 - first i will write the actual output
332:11 - that is the title
332:12 - dot equals the expected output that i
332:15 - want the expected output is our year
332:18 - this is the expected output okay so here
332:20 - the expected output is written when the
332:22 - expected and the actual output is
332:24 - matching the output will be the title is
332:26 - verified and if not the title is not
332:29 - verified like here you can see the title
332:31 - is verified now to print the length of
332:35 - the title i'm using the length command
332:37 - okay
332:38 - what i'm going to do is i'm going to
332:39 - create a integer type of variable and
332:41 - i'll name it as integer length and i'll
332:43 - write driver dot get title dot length by
332:47 - writing length i am actually fetching
332:49 - the total length of the title it returns
332:52 - the length of the string okay
332:55 - now uh to print it i'll write system dot
332:57 - out of println the length of the title
332:59 - is and i'll write the variable that is
333:00 - the title length and here the output is
333:03 - the length of the title is 7
333:05 - okay
333:07 - next is the page source
333:10 - now basically page source is a command
333:13 - it is a browser command
333:14 - which uh returns the source code of the
333:17 - page so this is the page and uh this is
333:20 - the entire source code of the page so it
333:21 - will return this entire source code of
333:23 - the page
333:24 - so for this we'll use the get page
333:26 - source
333:27 - and this get page source it accepts
333:30 - nothing as a parameter is there any
333:32 - parameter over here no right so it
333:33 - accepts nothing as a parameter but it
333:35 - returns a string value and the string
333:37 - value this is the entire string value
333:39 - that is given over here now to print the
333:41 - pace to source what i have written a
333:43 - string ps is equal to driver dot get
333:46 - page source i have used the get paste
333:47 - source command and i will print this
333:49 - variable this uh string variable
333:52 - then to find the length of the page
333:53 - source what i have done i have used the
333:55 - length
333:56 - uh method i write
333:58 - driver.getpaidsource.length and i store
334:00 - this length in the integer type of
334:02 - variable named as ph length and i've
334:05 - printed over here
334:06 - so the total length is displayed over
334:08 - here
334:10 - this is the total length so these were
334:12 - the commands the browser commands next
334:14 - we will learn about the click and the uh
334:17 - next we will learn about the close and
334:18 - the quit command the difference between
334:20 - the close and the quit method okay
334:22 - for that we will click this new tab so
334:25 - first what did i do is i clicked this uh
334:28 - new tab
334:29 - so for that i inspected this element and
334:31 - i wrote the x path and i have performed
334:32 - the click operation on this web element
334:35 - next to differentiate between the close
334:37 - and the quit what i did is let me
334:39 - execute this again first i have written
334:41 - driver.close now then i have written
334:42 - thread.sleep which causes the currently
334:44 - executing thread to sleep for specified
334:47 - time for example here i have written the
334:49 - 5000 milliseconds okay now let me
334:51 - execute this command and see the
334:53 - difference again
334:55 - so my chrome browser is launched
334:58 - it's maximized this is my parent and
335:00 - this is my child tab
335:02 - my parent tab will be closed
335:04 - so this is close driver dot close which
335:07 - means that the method terminates the
335:09 - current browser window okay
335:11 - whereas in quit it will terminate all
335:14 - the browsers
335:15 - so let's execute this
335:17 - so my chrome browser is launched
335:19 - it's navigated and here you can see this
335:22 - is the new tag
335:24 - and through driver.quit
335:26 - both the tabs are closed
335:28 - okay so uh this is the major difference
335:31 - between the close and the quit the close
335:33 - in both these commands they accept
335:35 - nothing as a parameter
335:37 - and it returns also nothing as a
335:39 - parameter this simply closes the
335:41 - tabs and the windows
335:43 - so this is all about the browser
335:45 - commands that we have studied till now
335:47 - we have studied about the get
335:49 - then we have studied about the get title
335:52 - the get current url
335:55 - and we have studied about the get page
335:58 - source
336:00 - then we have learned the difference
336:02 - between the
336:03 - close and the quit command now let's
336:05 - understand
336:07 - the difference
336:08 - so the driver.quick command closes all
336:10 - the browsers
336:11 - whereas the closed method shall close
336:14 - the browser which is in focus that was
336:15 - the parent
336:17 - tab was in focus right so it closes that
336:19 - browser which is in focus
336:21 - now the quick method closes all the
336:23 - active web driver instances whereas the
336:25 - close method closes the
336:27 - active webdriver instances so this is
336:30 - the difference between the quick and the
336:32 - close command
336:34 - so in this tutorial we will understand
336:36 - what are the navigational commands what
336:38 - are the different types of navigation
336:40 - commands with their syntax we will
336:42 - implement some test cases also we will
336:44 - understand the difference between the
336:45 - navigate.2 command and the get command
336:48 - in the previous tutorial i explained
336:50 - about the browser commands you can check
336:52 - out the tutorial
336:53 - i'll give the link in the description
336:54 - box we will understand what is the
336:56 - navigation commands today so first let
336:59 - us understand what is navigation
337:01 - commands now the web driver provides
337:03 - some basic browser navigation commands
337:06 - that allows the browser to move backward
337:08 - forward or to refresh the browser see
337:11 - here you can see these buttons that is
337:13 - the back and the forward and the refresh
337:16 - so we will be handling these buttons
337:18 - through selenium webdriver like for
337:20 - example suppose if i type a selenium web
337:22 - driver i have navigated to this space
337:24 - right now what if i want to go back so
337:26 - i'll click on the back button
337:28 - if i want to move forward i'll click on
337:30 - the forward button and if i want to
337:31 - refresh the browser i will click on
337:33 - refresh right
337:34 - so these are the buttons that we will be
337:36 - inspecting today for that we have the
337:38 - navigational commands
337:40 - now how do we find it's a navigation
337:42 - command we simply write driver
337:44 - dot
337:45 - navigate dot and the commands that is
337:48 - highlighted over here are the
337:49 - navigational commands okay also i have
337:52 - prepared the sheet over here in which i
337:54 - have written what are the navigational
337:56 - commands their description their syntax
337:58 - also what parameter it accepts and what
338:01 - it returns i will give the link in the
338:03 - description box just by clicking it you
338:05 - can download the pdf
338:07 - also i have attached the pdf in my drive
338:09 - so i will give the link of this drive as
338:11 - well so you can get the access of the
338:14 - navigation commands in pdf format also
338:16 - the test cases that we are going to
338:18 - implement today so moving on to the test
338:20 - case today we are going to implement two
338:22 - test cases this is the first one
338:24 - and this is the second one
338:26 - so the first one says that first we have
338:28 - to launch the chrome browser then we
338:30 - have to open the amazon website
338:33 - maximize the window
338:35 - and then we have to navigate to the ebay
338:37 - website through
338:39 - driver.navigate.2 command
338:41 - then we have to enter some value in the
338:42 - search box we will refresh the page we
338:45 - will navigate back then we will navigate
338:47 - forward and then we will close the
338:48 - browser this is the first test case that
338:50 - we will implement today
338:52 - so open your intelligent idea ide now
338:55 - under package com.selenium i have
338:57 - already created a java class i have
339:00 - named it as selenium tutorial 11
339:03 - so
339:03 - first is that we have to launch the
339:05 - chrome browser the test cases says that
339:07 - we have to launch the chrome browser for
339:09 - that we have to write system.set
339:11 - property in which the key is the
339:13 - webdriver.com.driver
339:15 - and the value is the executable file of
339:17 - the chrome driver
339:19 - next i will write driver web driver
339:21 - driver is equal to new chrome driver so
339:23 - the next command is that
339:25 - we have to open the amazon site we will
339:28 - be using the driver.get command so i
339:31 - will write driver
339:32 - dot get
339:34 - and i will write my url over here that
339:36 - is the amazon website
339:40 - i'll simply copy this and i'll paste it
339:41 - over here
339:44 - okay
339:45 - the next command is to maximize the
339:47 - window
339:49 - so i will write driver
339:51 - dot manage
339:53 - dot window dot maximize okay this will
339:56 - maximize the
339:58 - window
339:59 - the next the next test case is that we
340:01 - have to navigate to the ebay website
340:04 - so we will be using the
340:06 - driver.navigate.2 method okay so i will
340:09 - write driver
340:10 - dot
340:13 - navigate
340:14 - dot
340:15 - 2.
340:17 - so i'll write my url over here
340:21 - this is the url
340:23 - i'll simply copy this
340:25 - and i'll paste it over here
340:27 - now the driver.navigate.2
340:30 - method it loads a new page in the
340:33 - current browser so this will be loading
340:36 - a new page in the current browser the
340:38 - same browser in which it is loading
340:39 - amazon it will load the new page that is
340:41 - the ebay page in the current browser
340:44 - and it will accept the parameter that is
340:46 - the string parameter is accepted over
340:48 - here you can here you can see we have
340:50 - written the string parameter over here
340:52 - and it will return nothing okay
340:54 - so let's execute this
341:00 - so my chrome browser is launched
341:04 - it's navigated to amazon and then it's
341:06 - navigated to ebay
341:08 - i'll simply write
341:10 - s out
341:21 - okay so now let's execute
341:25 - so my chrome browser is launched it's
341:27 - navigated to amazon
341:28 - [Music]
341:30 - it's maximized and then it is navigated
341:33 - to ebay through driver.navigate or to
341:35 - method okay and here you can see
341:40 - the output that is it's opening the
341:42 - amazon page through driver.get and then
341:44 - it is navigated to ebay through
341:47 - driver.navigate.2 method okay so so far
341:50 - first we will open the chrome browser
341:52 - then we are opening the amazon page then
341:54 - we are maximizing the window then we are
341:57 - navigating to the ebay page through
341:59 - driver.navigate.2 command okay
342:02 - so the next test case is that i have to
342:04 - enter some value this is the search box
342:06 - i have to enter some value in it so i'll
342:08 - just inspect i'll click i'll right click
342:10 - it and here here i can see there's
342:12 - selectors up so i'll just click on copy
342:14 - relative xpath
342:16 - i'll write driver
342:17 - dot find element
342:20 - by dot x path and i'll write my x path
342:22 - over here and since i want to send some
342:24 - commands so i'll write send keys and
342:26 - i'll write t-shirts
342:30 - for men
342:33 - okay
342:34 - so i have entered some value and then i
342:36 - have to refresh it it's the same as here
342:39 - you can see there is a refresh button
342:40 - right so if i write t-shirt
342:45 - for men
342:46 - and then i refresh it
342:48 - here you can see there is no text type
342:50 - that means it is refreshed so what i'll
342:51 - do i will write driver
342:54 - dot
342:55 - navigate
342:56 - dot refresh through this command my
342:59 - browser will be refreshed so i'll just
343:01 - write thread
343:04 - dot sleep and i'll write some time over
343:07 - here
343:08 - i'll write refresh the browser
343:12 - okay
343:13 - so next is that we have to navigate back
343:16 - to
343:18 - amazon
343:20 - so i will just write a driver
343:23 - dot
343:24 - navigate
343:26 - dot
343:27 - back
343:27 - [Music]
343:29 - okay and i'll give some time over here
343:31 - i'll just write thread
343:33 - dot
343:34 - sleep and i'll give some time over here
343:37 - which is
343:39 - navigate it
343:41 - back to
343:42 - amazon
343:45 - okay so let's run this so my chrome
343:47 - browser is launched
343:50 - it's navigated to amazon and it's
343:52 - maximized
343:55 - then it's navigated to ebay then
343:57 - t-shirts for men is sent
343:59 - it's refreshed
344:01 - and here you can see it's navigated back
344:03 - to amazon here it is opening the amazon
344:05 - page first we will open the amazon page
344:07 - through driver.getmethod
344:09 - then we navigated to ebay through
344:12 - driver.navigate.2 method then we have
344:14 - refresh the browser and then the page is
344:16 - navigated back to amazon
344:19 - now this
344:20 - driver.navigate.back method is used to
344:22 - return to the previous page in the
344:24 - browser's history in our browser history
344:27 - the previous page was the amazon page
344:30 - so it was returning the amazon page okay
344:32 - and it accepts nothing as a parameter
344:35 - here there is no parameter and it
344:37 - accepts nothing as a parameter also it
344:39 - returns nothing okay
344:41 - similarly uh the refresh browse the
344:43 - refresh command that that is the
344:46 - driver.navigate.refresh method this acts
344:49 - similar to the refresh button of the
344:51 - browser like here you can see this is
344:53 - the refresh button of the browser this
344:54 - acts similar to that
344:56 - button and it accepts nothing as a
344:59 - parameter and it also returns nothing as
345:01 - a parameter our next test case is that
345:03 - we have to navigate forward
345:05 - to ebay
345:07 - so i will write driver
345:09 - dot
345:10 - navigate dot
345:11 - forward i will also write thread
345:15 - dot sleep i will give some time over
345:17 - here
345:18 - then i want to print
345:20 - so let's execute this
345:23 - so my chrome browser is launched
345:26 - it's navigated to amazon
345:29 - it's maximized and then it's navigated
345:31 - to ebay t-shirts for men is sent
345:34 - it's refreshed
345:36 - and it's navigated back to amazon
345:39 - then again it's navigated forward to
345:41 - ebay
345:43 - next our next test case is that we have
345:44 - to close the browser so i will write
345:46 - driver dot close we'll not use the quit
345:49 - command because there is no window or
345:51 - any tab open see here all the operations
345:54 - are performing in uh the current tab
345:56 - only there are no other tabs that is
345:57 - opening like if you're thinking like for
345:59 - amazon is one tab the ebay is the other
346:01 - tab no it is opening in the current
346:03 - browser and all the operations is
346:05 - performed in the current browser only
346:07 - that is it is navigating back or forward
346:09 - in the current browser
346:11 - so that's why we are writing
346:12 - driver.close
346:14 - so i'll execute this
346:16 - again
346:18 - [Music]
346:20 - my chrome browser is launched
346:23 - it's navigated
346:25 - to amazon
346:27 - it's maximized it's navigated to ebay
346:29 - t-shirts for men is sent and it's
346:32 - refreshed
346:33 - it's navigating back to amazon
346:36 - and then again
346:37 - it's navigating forward to ebay and it's
346:39 - closed so far first we navigated to ebay
346:43 - from amazon to ebay we navigated through
346:46 - driver.navigate.2 method now this method
346:49 - loads a new web page in the current
346:51 - browser window and it also accepts
346:53 - string as a parameter but it returns
346:55 - nothing that is the
346:57 - driver.navigate.2 method okay
347:00 - next after uh navigating to ebay we
347:03 - entered some text values we entered some
347:06 - values in the test search box and then
347:08 - we refresh the browser the refresh
347:10 - method it does the same operation as
347:12 - clicking on the refresh button on the
347:14 - browser when we click the refresh button
347:16 - on the browser it does the same
347:17 - operation
347:19 - and it accepts nothing as a parameter
347:20 - also returns nothing next we were
347:23 - navigating back again to the amazon
347:25 - website since we were on the ebay
347:27 - website and we were entering some value
347:29 - and we refreshed the page then after
347:30 - that we navigated back to the previous
347:32 - page we use the
347:34 - driver.navigate.back command which is
347:36 - used to return the previous page in the
347:38 - browser's history okay and it accepts
347:41 - nothing as a parameter it also returns
347:43 - nothing else next after uh navigating to
347:45 - back command we are in on the amazon web
347:47 - page on the amazon website we navigated
347:50 - forward to the ebay page that is the
347:52 - next page okay all the operations are
347:54 - performed on the current browser only
347:55 - there is no other new tab or window that
347:58 - is opened it is on the current window
348:00 - itself
348:01 - so for the forward we use the driver dot
348:04 - navigate dot forward method in which we
348:07 - move forward to the next space that is
348:09 - the ebay page and the forward command it
348:12 - accepts nothing as a parameter and it
348:14 - also returns nothing so this is all
348:16 - about the first test case
348:18 - now let us execute the second test case
348:21 - so now let's execute the second test
348:23 - case
348:25 - just open your intelligent idea id and i
348:27 - have already created a java class that
348:30 - is the selenium returns club java class
348:32 - in the package com.selenium
348:34 - and the first test case that we're
348:36 - having is that you have to launch the
348:37 - chrome browser for which i have written
348:39 - system that set property i have given
348:41 - the key as the webdriver.chrome
348:43 - webdriver and the value is the chrome
348:45 - driver executable file
348:47 - next i have written web driver driver is
348:49 - equal to new chrome driver
348:51 - the next test case is that we have to
348:53 - navigate to the page and this is the
348:55 - page that we will automate today so i
348:57 - will use driver
348:59 - dot
349:00 - navigate dot
349:02 - to command
349:03 - and i will insert the ui level here
349:06 - that is this is the url
349:08 - now this driver.navigator2 command it
349:11 - accepts string as a parameter and it
349:12 - returns nothing so
349:14 - let's execute this
349:16 - so my chromebook is launched
349:19 - it's navigated to the webpage.com
349:24 - okay
349:25 - so the next command is that we have to
349:27 - maximize the browser so i will just
349:28 - write driver dot manage dot
349:32 - window dot maximize through this command
349:34 - my window will be maximized
349:36 - next test case is that i have to inspect
349:39 - this element that is i have to click on
349:41 - this button that is a get start button
349:43 - so i'll just right click on it and i
349:45 - have this
349:47 - selectors hub option over here i'll
349:49 - click on copy relative expat this tool
349:51 - is amazing that is the selectors up tool
349:53 - you can just simply right click on any
349:55 - element and you will get the option over
349:57 - there like selectors up and you can copy
349:59 - your related x path over here
350:01 - okay so
350:03 - i'll just write
350:05 - driver dot
350:07 - sign element
350:08 - by dot
350:10 - x path and i will paste my relative x
350:12 - path over here
350:13 - and since i want to click on this button
350:15 - so i will click on clip
350:17 - method
350:19 - so let's execute this
350:22 - so my chromebook is launched it's
350:24 - navigated to the wordpress website it's
350:26 - maximize and here it's the button is
350:30 - click that is the get start button is
350:32 - click develop
350:34 - okay
350:35 - so now next is that i have to navigate
350:37 - back to the home page so i'll just write
350:39 - driver dot navigate
350:42 - dot
350:43 - back i'll also give
350:45 - some time over here so i'll just write
350:47 - thread.sleep
350:48 - now let's execute
350:50 - so my chromebook is launched
350:53 - it's navigated to wordpress
350:55 - let's
350:56 - maximize the button is clicked
351:01 - and it's navigating back to the home
351:02 - page
351:04 - okay
351:06 - so the next command is
351:08 - that we have to again go back to
351:10 - the get start page
351:13 - so i'll just write driver
351:15 - dot navigate dot forward
351:18 - and i'll give some time
351:21 - so i'll write a
351:23 - thread dot sleep
351:25 - and i'll specify some time over here
351:27 - that is 5000
351:29 - and then let's run this command
351:32 - [Music]
351:34 - so my chromebook is launched
351:37 - it's navigated to the wordpress website
351:40 - it's maximized
351:42 - [Music]
351:44 - and the button is clicked
351:45 - [Music]
351:47 - we're navigating back to the home page
351:55 - we are navigating forward to the get
351:56 - start page
352:00 - okay next is that we have to perform the
352:02 - refresh operation
352:04 - so i'll write driver dot navigate
352:07 - dot
352:08 - refresh
352:10 - and then we have to close the browser
352:15 - so i'll write driver dot close we
352:18 - specify some time over
352:20 - so i'll write thread dot sleep
352:22 - and here also i'll write
352:25 - thread dot
352:26 - sleep
352:28 - now let's execute this
352:30 - so my chrome browser is launched
352:32 - [Music]
352:34 - it's navigating the wordpress website
352:38 - it's maximized
352:39 - [Music]
352:41 - okay so that get start button is clicked
352:44 - we're navigating back to the home page
352:47 - [Music]
352:50 - navigating forward to the get start page
352:54 - [Music]
352:58 - refresh
352:58 - [Music]
353:03 - and the browser is closed so this is all
353:05 - about the navigation commands in which
353:08 - we have the navigate to method which
353:10 - loads a new web page in the current
353:12 - browser window and it accepts string as
353:14 - a parameter returns nothing next we have
353:17 - the refresh command which works same as
353:19 - the refresh button of any browser this
353:21 - is the refresh button of the browser and
353:23 - the syntax is that the
353:24 - driver.navigate.refresh
353:26 - and it accepts nothing as a parameter
353:28 - and it returns nothing next is the back
353:30 - command used to return the previous page
353:33 - in the browser's history the syntax is
353:34 - that the driver dot navigate the back
353:36 - command and it accepts nothing as a
353:39 - parameter also returns nothing next we
353:41 - have the forward command we will move to
353:43 - the forward page through driver dot
353:44 - navigate the forward command so these
353:46 - are the navigation commands that we have
353:48 - studied today also we have executed two
353:50 - test cases out of it
353:52 - next let us know the difference between
353:54 - the
353:55 - driver.navigator2 and the driver.jet
353:58 - since when we write driver.navigator2 uh
354:01 - and we write the url over here it
354:03 - performs the same operation also when we
354:05 - write driver.get it performs the same
354:07 - operation but yet they both are
354:08 - different okay now the
354:10 - driver.navigator2 command it is
354:12 - responsible for redirecting the page and
354:14 - then returning immediately like through
354:17 - driver.navigate we can navigate to
354:19 - forward we can now draw we can write
354:21 - driver.navigate.back then we can write
354:24 - driver.navigate.refresh but is there any
354:26 - command like driver.get.forward
354:28 - no right there is no command as such so
354:31 - driver.get is responsible for loading
354:33 - the page and it waits until the page has
354:35 - finished loading that's it that is what
354:37 - driver.get is responsible for
354:40 - whereas driver.navigate is responsible
354:42 - for redirecting the page we can perform
354:44 - the navigation
354:45 - uh operations like we can move forward
354:48 - we can move backwards and then we can
354:49 - refresh the browser so this is what is
354:51 - driver.navigate responsible for
354:54 - also the driver.navigator2 command it
354:57 - tracks the browser history and can
354:59 - perform back and forth in the browser
355:01 - like we have seen in the test cases we
355:03 - were performing the back operation and
355:05 - the forward operation so it tracks the
355:07 - browser history whereas the driver.get
355:09 - does not track any of the history of a
355:11 - browser
355:12 - like through
355:13 - driver.get.forward there's no such
355:15 - command so
355:16 - it is not tracking any of the history of
355:18 - the browser so these are the major
355:20 - difference between the driver.net
355:22 - driver.navigate command and the
355:24 - driver.get command so this is all for
355:27 - today in the next tutorial we will
355:29 - understand about the web element
355:30 - commands i have also provided this sheet
355:32 - in which i have written the commands
355:34 - description syntax and what parameter it
355:36 - accepts and returns i will provide the
355:38 - link in the description box you can
355:40 - directly download the pdf format also
355:42 - the link to the drive also i will
355:44 - provide in the description box so it
355:45 - will be very useful for you to revise
355:47 - during your interviews so this is all
355:49 - for today so in this tutorial we will
355:52 - understand some of the web element
355:53 - commands we will understand the
355:55 - different types of web element commands
355:57 - with their syntax
355:59 - also we will implement these commands
356:01 - then we will understand the difference
356:03 - between find elements and find element
356:06 - also we will understand the difference
356:07 - between the is displayed is enabled and
356:10 - is selected method and click and submit
356:13 - method
356:14 - so let's get started
356:16 - first we need to understand what are web
356:17 - elements command to understand what is
356:20 - web element command we need to
356:21 - understand what is web element
356:23 - anything that is present on the web page
356:25 - is called as a web element for example
356:28 - the text boxes the buttons the drop down
356:31 - menu the radio buttons etc everything is
356:34 - called web element to interact these web
356:36 - elements we have the different types of
356:38 - locators like the id name class the
356:41 - xpath i have explained that in the
356:43 - previous tutorial the web element
356:45 - commands are the list of actions that
356:47 - can be performed on various web elements
356:50 - these are called as the web element
356:52 - commands now here you can see these list
356:54 - of web element commands that is the
356:55 - click clear
356:57 - the find element the find elements the
356:59 - get attribute the get css value also i
357:02 - have prepared a document
357:05 - in this document i have mentioned the
357:07 - commands the description the syntax and
357:09 - what parameter it accepts and what it
357:11 - returns also you can get this document
357:14 - in the pdf format i have attached it to
357:16 - the
357:17 - drive
357:18 - i will give this link in the description
357:20 - box also i will give the direct link to
357:23 - download as a pdf
357:26 - so these are the commands like the clear
357:28 - click the submit the send keys and the
357:31 - element visibility methods and also
357:33 - these get text get tag name the get css
357:37 - get attribute get size and get location
357:39 - so these are the different web element
357:41 - commands and we will be understanding
357:43 - these commands today through set of test
357:46 - cases
357:46 - this is a test case that we're going to
357:48 - implement today
357:50 - and this is the website that we're going
357:52 - to automate today
357:54 - so
357:56 - first
357:58 - open your intelligent idea id
358:03 - so i have created this java class
358:05 - selenium tutorial 13 under package
358:07 - comrade selenium
358:08 - and the first test case says that i have
358:11 - to launch the chrome browser for that i
358:13 - have written system.set property in
358:15 - which i have given the key that is the
358:18 - webdriver.chrome.driver
358:20 - and the value is the executable file of
358:22 - the chrome driver
358:24 - next is the webdriver driver is equal to
358:26 - new chrome driver so these two commands
358:28 - will launch the chrome browser
358:30 - our next test case is that we have to
358:32 - open the url so i'll be using driver.get
358:37 - i'll insert the url that i want to
358:39 - navigate to this is the url
358:43 - so i'll copy this
358:44 - paste it over here
358:48 - and then i will maximize the page
358:51 - for that i will write driver
358:53 - dot
358:54 - manage
358:55 - dot
358:56 - window
358:58 - dot
358:59 - maximize
359:02 - now let's execute this
359:08 - so my chrome browser is launched
359:10 - it's navigated
359:12 - and it's maximized so my next test case
359:15 - is that i have to enter the username and
359:18 - password
359:20 - so this is username and this is the
359:22 - password i will inspect this element
359:23 - i'll simply click on inspect
359:26 - and here you can see we have the id name
359:29 - attribute so i'll use the id attribute
359:32 - i'll write
359:33 - driver dot find element
359:36 - by dot id
359:38 - and i will mention the id over here
359:47 - and here i'll be using the send keys
359:49 - command
359:51 - now the send keys command accepts the
359:54 - character sequence as a parameter and it
359:56 - returns nothing
359:57 - so the character sequence that i want to
359:59 - send over here is the username
360:01 - the username is given here so i'll
360:03 - simply just copy this
360:07 - i will paste it over here
360:10 - and this is the
360:12 - character that i want to send to
360:13 - username
360:16 - next i'll write driver
360:19 - dot find element
360:21 - by dot id
360:24 - the next element is the password so i'll
360:26 - inspect this
360:28 - the id
360:30 - i'll copy it over here
360:33 - and the operation that i want to perform
360:35 - over here is that i want to send some
360:37 - character sequence to the password field
360:41 - so here i will write the password
360:44 - the password is given over here
360:47 - so i'll simply copy this
360:50 - and paste it over here
360:51 - so this is the first web element command
360:54 - that we learnt is the send key so here
360:56 - you can see we have send keys now this
360:59 - send keys stimulates the typing into an
361:02 - element which may sets its value this is
361:04 - the syntax
361:06 - this is the parameter that is the
361:07 - character sequence it accepts as a
361:09 - parameter and it returns nothing
361:13 - so let's execute this
361:16 - so my chrome browser is launched it's
361:18 - navigated
361:20 - it's maximized and the username and the
361:22 - password is
361:23 - send
361:25 - so our next test case says that we have
361:27 - to clear the username and the password
361:29 - that we have entered for that we'll use
361:31 - the clear command okay
361:33 - so i will simply write driver
361:36 - dot
361:37 - find element
361:38 - by dot id
361:42 - dot
361:43 - i'll use the clear command
361:47 - it accepts nothing as a parameter it
361:50 - also returns nothing
361:52 - next i want to clear the password so
361:54 - i'll write driver dot fine element
361:58 - by dot id
362:01 - dot
362:02 - clear command
362:05 - now let's execute this
362:09 - so my chrome browser is launched
362:12 - it's navigated
362:16 - it's maximized and my username password
362:19 - is entered
362:22 - so here you can see the username is
362:24 - cleared
362:26 - and the password is also cleared
362:28 - okay
362:30 - so this is the next
362:31 - web element command that we have learned
362:34 - so this is the next uh web element
362:35 - command that we have learnt is the clear
362:37 - command this will clear the value this
362:39 - is the syntax and it accepts nothing as
362:41 - a parameter also returns nothing
362:44 - okay
362:44 - so our next test case says that we have
362:47 - to submit the login button so here comes
362:49 - the difference between the click command
362:51 - and the summit command these two
362:53 - commands for that i have an example
362:56 - let's understand that with the help of
362:58 - the example first and then
363:00 - we'll perform the test case
363:02 - to understand the difference between the
363:04 - summit and the click this is the page
363:07 - that i have made there are two divisions
363:09 - present over here one is the outside
363:10 - form tag and the second division is the
363:12 - inside form type in the outside form tag
363:16 - there are two buttons as well as in this
363:18 - inside form tag there are two buttons
363:19 - that is the submit button and the button
363:22 - the first one is of type submit here you
363:24 - can see this is input type submit and
363:27 - this is of
363:28 - type button okay
363:30 - so when i click on this this shows that
363:32 - the submit button
363:33 - outside the form tag and this is a
363:36 - button outside the form text similarly
363:37 - when i click on this this shows that
363:39 - this is a button inside a form tag
363:42 - and this is a button inside the form tag
363:45 - so now i created this page just to
363:48 - understand the difference between the
363:50 - click and the submit method okay
363:52 - so uh i have already created a java
363:55 - class i have named it as difference
363:57 - between submit and click i have opened
363:59 - the chrome browser i navigated to this
364:01 - page i maximize it the first operation
364:03 - that we're going to perform is the click
364:05 - operation and then we will perform the
364:07 - summit operation and then we will see
364:08 - the difference between the two
364:11 - so the first operation is the click
364:12 - operation and i inspected the
364:15 - outside form tag division first okay in
364:18 - which i click the submit button and the
364:20 - button
364:22 - so let's see let's execute this
364:25 - so my chrome browser is launched
364:30 - submit button is clicked
364:33 - then i navigated back
364:35 - then the button is clicked
364:39 - and it is navigated so my click
364:41 - method works for a submit button and the
364:44 - button which is outside the form tag
364:46 - now let's see whether it works for the
364:48 - inside the form tag or not
364:52 - so i have written this code for the
364:53 - inside the form tag
364:55 - in which i have inspected the uh
364:59 - submit button and the button through id
365:01 - locator and i have also written
365:03 - driver.navigate.back command just to
365:05 - navigate back to the page
365:07 - and i have also written thread dot sleep
365:09 - uh which shows the time so that it slows
365:11 - down the execution and we get to know
365:13 - what is actually happening
365:15 - so let's execute this
365:19 - here my chrome browser is launched
365:21 - it's navigated to this page it's
365:24 - maximized
365:28 - so this is the button inside the form
365:29 - tag the submit button is clicked
365:32 - it's navigated back
365:36 - so the button is also clicked
365:40 - and it's navigated back
365:42 - so here we can conclude that the click
365:43 - method is having no restrictions
365:46 - that is you can use click method to
365:48 - click on any button
365:50 - if it is of element of type button or of
365:53 - type submit the click will work for both
365:57 - okay whether it is outside the form tag
365:59 - or whether it is inside the form tag now
366:01 - let's see the summit
366:05 - to understand the submit
366:07 - method this is the first division that
366:09 - we are having the outside form tag so we
366:11 - will inspect this element first and
366:13 - let's see what the output is so i have
366:15 - written driver.find element and by dot
366:18 - id i have specified the id and the
366:19 - submit method and then i have written
366:21 - thread dot sleep to understand the
366:23 - execution
366:25 - so now let's execute this
366:28 - so my chrome browser is launched
366:30 - it's navigated
366:32 - it's maximized
366:42 - and here you can see there is an
366:43 - exception over here
366:46 - there is an exception of javascript
366:48 - execution the javascript error error
366:50 - unable to find moving document okay so
366:53 - this shows that
366:55 - the submit button will not work for a
366:57 - summit type of element outside the form
367:00 - tag now let's see if it works for the
367:02 - button type of element or not
367:05 - so i have written over your driver.find
367:07 - element by dot id and this is the id and
367:09 - i will use the
367:11 - submit method
367:13 - over here and i have given thread.sleep
367:16 - just to see its execution so that you
367:18 - can pause for some time
367:21 - and let's execute this
367:25 - my chrome browser is launched
367:27 - it's navigated it's maximized
367:34 - okay so again here you can see we have a
367:36 - error
367:37 - which says that is unable to find owing
367:40 - document so this means that the summary
367:42 - function is not applicable for the
367:44 - buttons that is outside the form tag
367:46 - okay now let's see
367:48 - is it applicable for buttons that is
367:50 - inside the form tag
367:53 - so here i have written driver dot find
367:54 - element by dot id and the id i have
367:56 - specified over here and the submit
367:58 - command and i've also written
368:00 - driver.navigate.back
368:01 - command now let's see whether
368:04 - it is executing or not or whether it
368:06 - shows an error
368:09 - so my chromebook has launched
368:11 - it's navigated
368:15 - and
368:17 - here it is this is a button inside a
368:19 - form tag and then it is navigated back
368:21 - okay
368:22 - so our submit function is working inside
368:25 - the form tag for the submit button but
368:27 - what about the
368:29 - element of type button
368:32 - so i have written this driver.find
368:34 - element by dot id
368:37 - and this is the id that is that i have
368:39 - given over here and the summit command
368:42 - and also thread dot sleeve so that we
368:43 - can
368:44 - see the execution
368:46 - so my chrome browser is launched it's
368:48 - navigated
368:51 - and this is the button inside the form
368:53 - tag
368:54 - so here you can see we had the division
368:56 - that is the inside the form tag division
368:58 - in which uh i had two buttons that the
369:00 - submit button and the button right so i
369:03 - could automate the submit button as well
369:05 - as this button also so the summit
369:07 - function is applicable only for buttons
369:09 - that are inside the form tag so this
369:11 - means that there are some restrictions
369:13 - for the submit method and there is no
369:14 - restrictions for the click method
369:16 - so let's see the difference between the
369:18 - two
369:19 - so this is the difference
369:21 - for the click method you can use the
369:22 - click method to click on any button
369:25 - whereas the summit function is
369:26 - applicable only for buttons that is
369:28 - inside the form tag
369:30 - there is no restrictions for click
369:32 - button but there are some restrictions
369:33 - for submit button that is it is only
369:36 - applicable if the button is inside the
369:38 - form tag
369:40 - now this means that
369:42 - when there is no restriction for click
369:43 - buttons that this means that the element
369:45 - type is button or it is of type summit
369:47 - the click method will work for both
369:50 - but whereas the element type of submit
369:52 - or button it should be inside the form
369:55 - tag then only the summit method will
369:57 - work
369:58 - okay now if the button is inside the
370:00 - form tag or the button is outside the
370:02 - form type the click will work but if the
370:04 - button is outside the form tag that
370:06 - means the summit will not work as we
370:08 - have seen in the example before
370:10 - so now moving on to the next test case
370:13 - that is the submit our login button is
370:16 - to submit our login form right so your
370:21 - let's inspect this element
370:24 - now this element is of type submit and
370:26 - it is under the form tag so we can use
370:29 - the summit command
370:31 - so i'll simply write driver
370:33 - dot find element
370:35 - by dot
370:38 - x path
370:40 - and
370:43 - and i will paste it over here
370:45 - okay so here i have written driver
370:46 - driver.find element and this is the
370:48 - expert that is present and the operation
370:50 - that i want to perform is i want to
370:52 - submit it
370:53 - so now let's execute this
370:55 - my chrome browser is launched
370:58 - it's navigated
371:00 - my username is entered password is
371:01 - entered username is cleared password is
371:03 - cleared
371:04 - and here you can see the login button is
371:07 - clicked and
371:08 - here the warning is given the username
371:10 - cannot be empty so our next test case is
371:13 - the get text
371:15 - now this method will fetch the visible
371:17 - uh inner text of the element
371:21 - and it accepts nothing as a parameter
371:22 - but it returns a string value for
371:24 - example
371:25 - suppose this element here you can see
371:27 - this link
371:29 - if i inspect this here you can see we
371:31 - have the forget your password text
371:33 - written over here so get text fill
371:35 - method get text method will retrieve
371:37 - this
371:38 - forget your password okay it will fetch
371:40 - the inner visible text that is present
371:42 - over here there is a text present right
371:44 - forget your password so it will print
371:47 - forget your password through get text
371:48 - method
371:49 - so what i'll do is i'll write driver
371:52 - dot find element
371:55 - by dot link text
371:57 - and the text that is present over here
372:00 - is this so i'll simply copy this
372:05 - and i'll write
372:06 - get
372:08 - text
372:12 - here i'll give some string value
372:16 - and i will print it
372:18 - let me execute this
372:21 - my chrome browse is launched
372:24 - it's navigated
372:26 - it's executed
372:29 - username password is entered
372:33 - the username is cleared the password is
372:34 - cleared
372:38 - the submit button is clicked
372:41 - and here you can see we have the text
372:43 - let's forget your password
372:45 - okay
372:48 - then the next test case says that get
372:50 - location
372:51 - now the get location method this method
372:53 - locates the location of the element on
372:55 - the page and it accepts nothing as a
372:57 - parameter but it returns a point object
373:00 - now here i will write driver
373:02 - dot find element by dot id
373:05 - i will store this in a web element
373:08 - type of variable
373:12 - so i'll use the point class over here
373:13 - and then i will write element dot get
373:16 - location
373:18 - next i will print it
373:21 - plus point dot
373:23 - x
373:25 - y coordinates
373:28 - point dot y
373:30 - so let me execute this
373:33 - my chrome browser is launched it's
373:36 - navigated
373:38 - it's maximized
373:40 - my username and password is enter
373:43 - my username is cleared my password is
373:45 - cleared
373:48 - so my login button is clicked
373:51 - and here you can see the text is
373:54 - forget your password x coordinates and
373:55 - the y coordinates
373:58 - so
373:59 - through
374:01 - get location we can
374:03 - locate the location of the element on
374:04 - the page on this page i was locating
374:07 - this element that is the user name
374:09 - that's what i found through
374:12 - get location method
374:14 - next
374:15 - test case says that you have to find the
374:18 - size that is the get
374:22 - size
374:23 - so here the get size method fetches the
374:25 - width and the height of the element
374:28 - now over here i will inspect this
374:30 - element only i will i want to know the
374:32 - width and the height of this element for
374:34 - that i will be using the get size method
374:36 - now remember the get size method is
374:38 - different and the size method is
374:40 - different they both are different okay
374:42 - now
374:43 - this get size method it accepts nothing
374:45 - as a parameter but it returns the
374:46 - dimension object so similarly i'll write
374:49 - the code for this
374:51 - i'll write driver dot find element
374:54 - by dot id
374:58 - and i will store this in a web element
375:02 - type of variable
375:05 - i will name it as element 1
375:08 - is equal to driver.fine element by dot
375:10 - ire
375:12 - okay next i will write dimensions
375:16 - dimension
375:19 - dimension is equal to
375:22 - element
375:23 - 1 dot
375:25 - get
375:26 - size next i will write s out and i'll
375:30 - write
375:31 - height is
375:33 - and i'll write dimension that is the dim
375:35 - dot height
375:38 - and i will write
375:39 - him dot
375:41 - so let's execute this
375:43 - so my chrome browser is launched it's
375:45 - navigated
375:47 - it's maximized and my username password
375:50 - is entered
375:52 - my username is cleared password is
375:53 - cleared
375:54 - the login button is clicked
375:56 - and here you can see the height and the
375:58 - width that is given
376:00 - of
376:02 - this element that is the username
376:03 - element
376:05 - so the next test case says that we have
376:07 - to find the get tag name now the get tag
376:10 - name method it gets the tag name of the
376:13 - element for example suppose
376:15 - if i inspect this element
376:17 - this is the element that i'm inspecting
376:20 - element that is there so the tag name is
376:23 - input so it will retrieve the input
376:25 - this is the tag name that is of this
376:27 - element right so the tag name of this
376:30 - element is redrive that is the input so
376:33 - let's see i'll simply write driver
376:37 - dot find element
376:39 - by dot id
376:42 - and i will place the id over here
376:46 - i'll write get
376:48 - tag name
376:50 - and i'll print this value
376:53 - so i'll store it in a string type of
376:54 - variable because it returns string
376:58 - next i will print it
377:02 - let's execute this
377:04 - so my chromebook is launched it's
377:06 - navigated the username password is
377:07 - entered
377:08 - the username is cleared the password is
377:10 - cleared
377:12 - and my login button is clicked
377:14 - and here you can see we have the tag
377:16 - name that is the input
377:18 - so the next test case is that we have to
377:21 - print the number of links present on the
377:23 - page now i have given this test case to
377:25 - understand the difference between the
377:27 - fine element and the find elements
377:29 - so what i'll do is i'll write driver dot
377:31 - find elements
377:34 - by dot
377:35 - tag name i'll use the tag name and to
377:37 - find the links on the page the tag that
377:39 - we use is the
377:41 - a tag right the anchor tag so i'll write
377:43 - a
377:45 - and i will store this in a list
377:48 - i'll use the web element
377:50 - because i have to inspect the web
377:52 - element over here
377:54 - the different types of web element that
377:55 - is i want to know the list of
377:59 - links that is present over here right so
378:01 - i'm using the list and the element that
378:03 - i want to inspect is the web element
378:06 - and i will give a variable name
378:08 - i'll name it as links is equal to
378:10 - driver.find elements by dot tag name
378:14 - and then i will print this
378:16 - that is i'll print the number of
378:18 - links that is present over here to print
378:20 - the number of links that
378:22 - that is present over here i'll use the
378:24 - size method
378:27 - remember the get size method is
378:28 - different whereas the size method is
378:30 - different the size
378:32 - method retrieves the number of elements
378:34 - in the list whereas over here the get
378:36 - size method this method that you see
378:38 - this is the get size method this shows
378:40 - the width and the height of the element
378:44 - my chrome browser is launched it's
378:46 - navigated
378:48 - it's maximized
378:50 - the username and the password is entered
378:53 - the username is cleared the password is
378:55 - clear
378:56 - and the login button is clicked okay
378:58 - here you can see we have the
379:00 - number that is present over here that is
379:01 - six there are six
379:03 - links present on this page
379:06 - okay
379:07 - now here you can see we have used the
379:09 - find elements method over here okay now
379:12 - the main difference between the fine
379:14 - element and the fine elements is that
379:16 - the fine element returns the first
379:18 - matching web element if the multiple web
379:20 - elements are discovered by the locator
379:22 - okay and here the find elements returns
379:25 - the list of multiple matching web
379:26 - elements
379:28 - in find element it will throw no such
379:31 - element exception if the element is not
379:33 - found whereas in find elements it
379:35 - returns the empty list it will return
379:37 - the empty list if no element is matching
379:39 - over here
379:41 - find element detects a unique web
379:43 - element whereas the fine elements it
379:45 - returns the collection of matching
379:46 - elements we have seen the example also
379:48 - over here
379:50 - so this is the main difference between
379:52 - the fine element and the find elements
379:55 - now the next test case is that
379:57 - we have to check if the login button is
379:59 - displayed or not now here we are using
380:02 - the
380:03 - element visibility methods okay
380:05 - we have three types of element
380:07 - visibility method one is the is
380:08 - displayed one is is enabled and one is
380:11 - is selected
380:12 - now the is selected method is mostly
380:14 - used for radio buttons and check boxes
380:16 - whereas the is displayed in is enable
380:18 - method is used for all types of web
380:20 - elements that is present on the web page
380:23 - all these methods it accepts nothing as
380:25 - a parameter but they return boolean
380:27 - values that is the true and the false
380:30 - the is displayed method this method
380:32 - determines if an element is currently
380:34 - displayed or not for example if the test
380:37 - case is that check if the login button
380:38 - is displayed that is this login button
380:40 - it is displayed on this page right on
380:43 - this web page so when i write
380:45 - driver dot file element dot
380:48 - id and if i located by id and when i
380:51 - write is displayed it will show true
380:54 - because this element is displayed on the
380:56 - web page now let's see if i write
381:00 - now if i write is displayed
381:05 - and if i save it in a boolean type of a
381:07 - variable because it returns true or
381:09 - false so if i write
381:12 - boolean 1
381:14 - is equal to
381:15 - driver.find element x bar then this is
381:18 - displayed and i will print it over here
381:21 - so here the output will be true
381:24 - because the element is displayed on the
381:25 - web page right
381:27 - so the output will be true so let's
381:29 - execute
381:30 - this my chrome browser is launched it's
381:33 - navigated my username and password is
381:35 - entered
381:37 - my username is erased and the password
381:39 - is also clear
381:41 - and the login is
381:43 - clicked
381:45 - and here you can see we have the value
381:46 - that is true
381:48 - why it is true because this login button
381:50 - is displayed on the web page
381:53 - so next test case says that we have to
381:55 - check if the login button is enabled or
381:58 - not
382:00 - now here i have written a boolean
382:02 - variable that i have given is the bool2
382:04 - and i have written driver.find element
382:06 - and the xpath and i have used the is
382:08 - enabled method now this method the minus
382:11 - of the element is currently enabled or
382:12 - not here you can see this uh element is
382:15 - enabled right if i click on this i can
382:18 - see over here it is enabled
382:20 - so
382:21 - let's see the output will be true
382:22 - because this element is enabled
382:25 - my chrome browser is
382:26 - launched it's navigated
382:30 - it's maximized
382:32 - and the username and the password is
382:33 - entered the username is cleared
382:37 - the password is cleared
382:38 - [Music]
382:41 - the login is clicked
382:44 - we close this and here you can see we
382:45 - have the true value given over here
382:48 - next let's check
382:50 - if the
382:53 - login button
382:54 - now this is selected method is basically
382:57 - used for the radio buttons and the check
382:59 - boxes mostly it determines whether
383:02 - the element is selected or not
383:05 - so this uh operation is only applied to
383:08 - input elements such as check boxes
383:10 - select option the radio buttons
383:12 - to return that it is true or false if
383:14 - the radio button is selected it will
383:16 - return true if it is not then it will
383:17 - return false okay and it accepts nothing
383:20 - as a parameter but it returns a boolean
383:22 - value so in this case this element is
383:25 - not a radio button or a check box or
383:27 - something but and it is not selected
383:29 - also
383:30 - so obviously
383:33 - it will return false so if i write
383:35 - driver.find element dot x python is
383:37 - selected and if i print this variable
383:40 - now let's see the output will be false
383:42 - because this element is not selected and
383:43 - it is not a
383:45 - radio button or a check box so my chrome
383:48 - browser is launched it's navigated and
383:50 - the username and password is entered
383:53 - the username is cleared the password is
383:55 - also cleared and the login is clicked
383:57 - and here you can see the output is false
384:02 - okay so here these were the test cases
384:04 - that we execute today we launched the
384:05 - chrome browser we opened the url we
384:08 - entered the username and the password we
384:09 - cleared it
384:11 - so here we use the clear operation
384:13 - here we use the uh send keys method and
384:16 - here we understood the difference
384:18 - between the click and the summit method
384:20 - then we use the get text method the get
384:22 - location the get size and that get tag
384:24 - name then we understood the difference
384:26 - between the fine element and the find
384:28 - elements then
384:29 - we use the is displayed method is
384:31 - enabled method in is selected method so
384:34 - this way we have covered all the web
384:36 - element commands
384:38 - so let us just understand the difference
384:40 - between all these elements
384:42 - i have explained the difference between
384:43 - the click and the submit so for the
384:46 - click we have no restrictions whereas
384:48 - for submit method we have the
384:50 - restrictions that is the method is only
384:52 - applicable if the buttons are inside the
384:54 - form tag okay so this is the basic
384:57 - difference between the click and the
384:58 - submit and if the button is inside the
385:01 - form tag or the button is outside the
385:03 - form type the click method will work but
385:05 - if the button is outside the form tag
385:06 - that means the summit will not work we
385:08 - have seen the example also
385:11 - next is the find element in the find
385:13 - elements now the find element returns
385:15 - the first matching web element if the
385:17 - multiple web elements are discovered by
385:19 - the locator now if the locators
385:21 - discovers multiple web elements like
385:23 - suppose of name suppose the name given
385:25 - over here is the column one and there
385:27 - are multiple column ones present on the
385:29 - web page okay and it has multiple web
385:31 - elements are discovered over there so it
385:33 - will return the first matching web
385:34 - element whereas in case of find elements
385:37 - it will return a mult list of multiple
385:39 - matching web elements and it throws no
385:42 - exception it is just that it returns an
385:44 - empty list whereas
385:46 - in fine element it throws no such
385:48 - element exception if the element is not
385:50 - formed detects a unique web element
385:52 - whereas the driver.find elements it
385:54 - returns the collection of matching
385:56 - elements this is the example we have
385:58 - also seen the example of find elements
386:02 - next what is the difference between the
386:04 - is displayed is enabled and is selected
386:06 - now the is displayed method is used to
386:08 - verify whether an element is on site
386:11 - present or not as i've shown the login
386:14 - button was present on the web page so it
386:15 - displayed true so this method is used to
386:18 - verify whether an element is present on
386:20 - the site or not
386:22 - is enabled is used to confirm whether an
386:24 - element is enabled or disabled whereas
386:26 - is selected is used to confirm whether
386:28 - an element is selected or not
386:31 - is selected is applicable to any web
386:33 - object or any web element that is
386:35 - present on the web page and it returns
386:38 - true or false whereas is enabled is also
386:41 - applicable to all the web object that is
386:43 - present on the web page when it returns
386:45 - true and false
386:47 - now this is selected method is only
386:49 - applicable for check box so the drop
386:51 - down menus and the radio buttons on the
386:53 - side and it will return true or false so
386:55 - if the radio button is selected it will
386:58 - show true and if it is not selected it
387:00 - will show false so this is the basic
387:02 - difference between the is displayed is
387:04 - enabled and the selected method so far
387:06 - we have covered the web element commands
387:08 - we have understood the difference also
387:10 - between the click and the summit the
387:12 - find element and the find elements also
387:15 - is displayed is enabled and is selected
387:17 - i have also given the pdf sheet i will
387:20 - give all the links in the description so
387:21 - that you can refer it also uh the source
387:24 - code link will be given in the
387:26 - description so you can check out the
387:27 - source code as well
387:29 - so for now uh this is what we have
387:32 - studied today in the next tutorial we
387:34 - will understand how to handle multiple
387:36 - windows
387:37 - through selenium webdriver so this is
387:39 - all for now
387:41 - so in today's tutorials we will cover
387:42 - one of the most important interview
387:44 - question that is how to handle multiple
387:46 - windows now in this tutorial we will
387:48 - understand
387:49 - what is window handle we will understand
387:51 - some methods used for handling window
387:53 - handles also we will cover some
387:55 - interview questions on get window handle
387:57 - and get window handles
387:59 - now in the previous tutorials i
388:00 - explained about the browser commands i
388:02 - explained all the commands except the
388:04 - two commands that is the get window
388:06 - handle and get window handles
388:08 - these are the two commands which is used
388:10 - to handle the multiple windows now for
388:13 - example this is the window now if i
388:16 - click on this this is the new window
388:18 - again if i click on this this is the
388:20 - next window
388:22 - so these are the child windows and this
388:24 - is the parent window
388:25 - now the problem is how do i switch from
388:27 - this window to this window
388:29 - now sometimes you may come across a
388:31 - complex scenario where you have to open
388:33 - a new window okay and you have to
388:36 - perform some desired operation on the
388:38 - open window like for example this is the
388:40 - parent window and by clicking on this
388:42 - new window button i opened a new window
388:45 - and i have to perform some operation on
388:47 - this so in this case how do i switch
388:49 - from this window to this window
388:52 - so this is what we're going to learn
388:53 - today
388:55 - now handling multiple tabs or windows
388:57 - may seem complex in the beginning
389:00 - because it involves some different
389:02 - commands which is new to you
389:04 - so as in beginner level so it will be a
389:06 - complex in the beginning but once you
389:08 - get get to know how to handle it and
389:10 - once you get a hang of it it will be
389:11 - very easy for you
389:13 - now there are many ways to handle
389:15 - multiple windows you can use a
389:16 - javascript executor also method but we
389:19 - will be covering the basic method to
389:21 - understand how to switch between the two
389:24 - browsers
389:25 - now here if i want to switch from this
389:27 - browser to this browser how am i going
389:29 - to do that i'm going to use the window
389:31 - handles value now what is the window
389:33 - handle value
389:34 - a window handle is basically a unique
389:37 - identifier that holds the address of all
389:39 - the windows it is basically a pointer to
389:41 - a window which returns the string value
389:44 - this is the window right this is the
389:47 - parent window
389:48 - and this is the child window now if i
389:50 - want to switch from this to this i will
389:51 - be using the window handles that is
389:54 - basically the pointer or the address
389:55 - that is given to a particular browser
389:58 - for example if i assume this parent
390:00 - window is having a pointer of value some
390:03 - string value it will be a very long
390:05 - string value i'm just taking up an
390:07 - example like suppose uh c21 okay and
390:10 - over here it will be uh something like
390:12 - d21 now if i want to switch from c21 to
390:15 - d21 how am i going to do that i'm going
390:17 - to use some specific commands
390:20 - okay
390:20 - and yeah these window handles are
390:22 - dynamic so it keeps on changing there's
390:24 - no fixed value for it the dynamic in
390:26 - nature they will keep on changing and it
390:29 - is a pointer to a window which returns
390:31 - the string value okay
390:33 - so there are some predefined methods of
390:35 - selenium that can be used to handle the
390:37 - windows first method is the browser
390:40 - commands that i have
390:42 - explained before but i didn't uh show
390:44 - the practical implementation so we're
390:45 - going to implement it today so first is
390:48 - that the get window handles and the get
390:49 - window handle now there's a difference
390:51 - between the both of them
390:53 - the get fit to handles is used for
390:55 - designing the window ids of multiple
390:57 - open windows
390:59 - and get window handle is used for
391:01 - retrieving the window id of the current
391:03 - focused window for example now the get
391:06 - window handles
391:07 - will retrieve the window id of this one
391:10 - as well as this child window and this
391:12 - child window okay
391:14 - whereas the get window handles will
391:16 - retrieve only the parent window handle
391:18 - value okay whatever value this window is
391:20 - going to have that value it will drive
391:23 - through get window handle so this is a
391:25 - basic difference between the get window
391:27 - handle and get window handles
391:29 - and the next uh method that is used that
391:32 - is the switch to method now if you want
391:34 - to switch from one window to the next
391:35 - window we will use the switch to command
391:37 - that will be driver dot switch to dot
391:39 - window
391:40 - next uh how we're going to implement
391:42 - this is we're going to execute three
391:43 - test cases today
391:45 - the first test case will teach that how
391:47 - to print the value how to print the
391:49 - handle values and we will learn the
391:50 - difference between the get window handle
391:52 - and get window handles
391:54 - the next set of test case will teach us
391:56 - that how to switch and navigate to the
391:57 - other sides
391:58 - also okay and the third test case we
392:01 - will know how to close the browser like
392:03 - the parent window we will close and then
392:05 - we will close the
392:06 - child window how do we do that okay
392:09 - so let's first start with the first test
392:11 - case
392:12 - open your intelligent id id
392:17 - so this is the java class that i have
392:20 - created or that is the selenium
392:21 - tutorials 14 and i have created under
392:24 - the package com.selenium and
392:27 - these are the three basic commands that
392:28 - we always tried first to see opening the
392:30 - chrome browser navigating to the url and
392:32 - maximizing it
392:35 - okay
392:36 - so
392:38 - first that open a chrome browser
392:39 - navigate to the url this is the new url
392:41 - so i'll simply just copy this and it's
392:45 - i'll paste it over here
392:47 - [Music]
392:49 - and i have to maximize the
392:51 - window next we have to print the parent
392:53 - window handle okay the parent window
392:56 - handle is this this is the parent window
392:58 - handle that we have
392:59 - and these are the child windows
393:02 - okay so we have to print the parent
393:04 - window handles so what you're going to
393:06 - do is i will write driver
393:10 - dot get window handle because i have to
393:14 - print the parent window handle so i'll
393:17 - use the get window handle over here
393:19 - because this returns string so i will
393:21 - store it in a string type of variable
393:23 - i'll name it as
393:25 - parent
393:26 - window handle
393:28 - so string parent window handle is equal
393:30 - to driver dot get window handle
393:33 - next i'm going to print it
393:37 - so i'll write s out
393:39 - the parent
393:41 - and i will write
393:43 - parent window handle okay
393:46 - this will print the parent window handle
393:48 - value
393:49 - next it says i click on the new window
393:51 - or button three times that is
393:55 - this one new window button three times
393:57 - for this i will be using the for loop
393:59 - so i'll write for
394:01 - int i
394:03 - is equal to one
394:05 - i less than or equal to three and i will
394:09 - increment it
394:11 - next i will write driver
394:14 - dot
394:15 - find element
394:18 - by dot x path and i will place the x
394:20 - path over here
394:24 - and what operation do i want to perform
394:26 - is the click operation which is one of
394:28 - the web element command so over here i
394:31 - have clicked three times now let me give
394:33 - some time
394:35 - so that we can see the execution
394:37 - properly now let's execute this now my
394:40 - chrome browser is launched
394:42 - it's navigated
394:43 - it's maximized
394:45 - the window is opened
394:48 - this is the next new window
394:51 - and this is the next one here you can
394:52 - see
394:54 - we have
394:55 - three
394:58 - windows over here
395:00 - okay this is the child window one the
395:01 - star window to the style window 3 and
395:03 - this is the parent window
395:05 - so i'll just close this
395:10 - now the next test case says that
395:15 - we have to print the window handles we
395:17 - have to print all the window has a
395:18 - handle so
395:20 - so i will write over here
395:22 - driver
395:23 - dot
395:24 - get window handles
395:27 - now this get window handles returns
395:31 - set
395:34 - so this get window handles returns a set
395:37 - of string type and why set because the
395:40 - get window handles are unique in nature
395:42 - so that's why it's set and i have named
395:44 - the variable window handles and is equal
395:46 - to driver dot get window handles
395:49 - now because i want to print all of them
395:51 - what i'm going to do is i'm going to use
395:52 - the for loop so i'll write for and over
395:55 - here because it's of string type so i'll
395:57 - write string
396:00 - and i'll name it as handle
396:03 - next uh the values from which is
396:06 - it's going to store and handle is from
396:08 - the windows handles and
396:10 - here i will print it
396:12 - and now let's execute this
396:16 - so my chrome browser is launched
396:19 - it's navigated
396:20 - [Music]
396:21 - it's maximized the child window is
396:24 - opened
396:25 - the second try window is click
396:28 - the third child window
396:29 - [Music]
396:32 - now let's see their values
396:35 - [Music]
396:37 - here it is the parent window handle is
396:39 - this is the parent window handle
396:42 - this is these are the
396:44 - child window handles and the parent
396:46 - window handles so here you can see there
396:48 - is a difference between get window
396:49 - handle and get window handles the get
396:52 - window handle it returns the window
396:54 - handle of the currently focused window
396:55 - or tab here our currently focus window
396:57 - tab is the parent window
397:00 - whereas the get window handles returns
397:02 - all the windows that is handled or
397:04 - launched including the parent and the
397:06 - child
397:07 - so that's why there are four window
397:08 - handles over here including the parent
397:10 - in the child there's a parent window as
397:11 - well as a child window in this okay
397:15 - which are all dynamic in nature it is
397:17 - having all unique values okay
397:20 - now there's a basic difference between
397:22 - the
397:23 - get window handle and get window handles
397:25 - our next test cases
397:27 - open the chrome browser navigate to the
397:29 - url maximize we have printed the windows
397:33 - parent window handle also we have
397:34 - clicked the new window button for three
397:36 - times then we have to print all the
397:38 - window handles and then we have to
397:39 - switch to windows okay now here comes
397:42 - the switching command that is the driver
397:44 - dot switch to dot window command okay
397:47 - so to switch to windows
397:51 - here i will write
397:53 - so you're in the for loop itself first
397:55 - i'm printing the window handles and then
397:57 - i'm switching so first i will print to
397:58 - which window it is and then
398:01 - i'll write driver dot switch to
398:03 - dot window and inside the window i will
398:06 - write handle i have to navigate to
398:08 - google
398:09 - so what i'll do that for that
398:13 - so basically it will switch and then it
398:15 - will navigate to the google so here
398:18 - i will write driver dot get
398:22 - and i will paste the google
398:25 - url over here and i will maximize it
398:28 - driver dot
398:29 - manage dot window
398:31 - dot
398:32 - maximize so let's give the time limit
398:35 - over here i'll write thread dot sleep
398:38 - and i'll specify some time
398:40 - here i'll write driver
398:42 - dot quit so that the browsers are closed
398:44 - my chrome browser is launched
398:46 - it's navigated it's maximized
398:49 - the child window is open
398:52 - the next child window is open
398:54 - the third child window is open
398:56 - [Music]
398:57 - next first the parent window will be
398:59 - navigated to google.com
399:02 - the next style window will be navigated
399:04 - to google and will be maximized
399:08 - [Music]
399:09 - then the next style window will be
399:10 - navigated to google and maximized
399:12 - [Music]
399:15 - and you're the third trial window will
399:16 - be navigated to google and it will be
399:18 - maximized
399:20 - [Music]
399:21 - so till now uh we have learned how to
399:24 - switch and navigate over here i'm
399:25 - switching and navigating to google okay
399:27 - so this is what we learnt over here the
399:29 - next third case says that we have to
399:31 - learn how to close the windows
399:33 - now here i use driver.quits so it just
399:36 - closed all the browsers
399:38 - including the parent window and the
399:40 - child window but if i use driver.close
399:42 - it will close only the current window
399:44 - handle that is handling okay that is an
399:46 - execution
399:47 - so
399:50 - here
399:51 - what we'll do is
399:52 - now over here currently there is no
399:54 - window in current okay so what we're
399:57 - going to do is we're going to switch
399:58 - first i'll use driver dot
400:00 - switch to window and
400:03 - here i will write the parent window i
400:05 - want to close the parent window first so
400:06 - i'll switch to parent window first
400:10 - i will write driver dot
400:13 - close
400:14 - so while switching
400:16 - let's write thread dot sleep
400:19 - and i will give some time over here
400:23 - okay the first is right we will switch
400:25 - to the parent window and then we will
400:27 - close it
400:29 - next
400:30 - switch back to the other windows and
400:32 - quit the browser now at this point of
400:34 - time there is no focused window after
400:36 - closing the parent window handle there
400:38 - is no focus window so we have to switch
400:40 - back to some window for that i am using
400:42 - a string type of a variable i will name
400:44 - it as last
400:45 - window
400:47 - i will use this variable so what i am
400:49 - going to do is i am going to write
400:50 - driver
400:51 - because i have to
400:53 - switch
400:54 - to the other windows
400:58 - i'll write driver
401:01 - dot switch to dot window and i'm going
401:05 - to write
401:07 - last window handle over here
401:10 - and i'm going to use the driver dot
401:13 - quit command
401:15 - now to see the execution
401:17 - properly i'll write thread
401:19 - dot sleep
401:21 - and here i'll give
401:22 - some time
401:25 - here also i'll write thread dot
401:28 - sleep
401:29 - and i'll give some time
401:32 - okay so now let's execute this
401:36 - my chrome browser is launched
401:38 - it's navigated
401:41 - it's maximized and then the child window
401:43 - is opened
401:45 - the next child window is open
401:47 - and the third child window is open
401:50 - now the parent will will be navigating
401:53 - to uh google.com
401:58 - then my child window will be navigating
402:00 - to google.com and it will be maximized
402:03 - [Music]
402:08 - again the same process
402:10 - it will be navigated to google and can
402:12 - be maximized
402:13 - [Music]
402:16 - again it will be navigated to google and
402:18 - it will be
402:19 - maximized
402:20 - [Music]
402:23 - so the parent window is closed first
402:26 - then it is switching to some tab and it
402:28 - is quitting the browser
402:31 - okay so here we have learned how to
402:33 - close the parent window and how to close
402:35 - the other browsers also
402:37 - so these are the three test cases that
402:39 - we executed the first one we learned
402:41 - that how to print the handle values and
402:43 - what is the difference between the get
402:45 - window handle and get window handles
402:47 - in the next uh test case we learned how
402:49 - to switch and navigate to the other side
402:51 - we were navigating to google and we were
402:53 - switching through
402:54 - driver.switch2.windows command
402:56 - in the third one we learned how to close
402:58 - all the windows first we switched to the
402:59 - parent window we closed it and then we
403:01 - closed the other windows okay so these
403:04 - are the three test cases that we
403:05 - executed
403:07 - next let's cover some interview
403:09 - questions on get window handle and get
403:10 - window handles okay so one of the most
403:14 - frequently asked interview question is
403:16 - that what is the difference between the
403:18 - get window handle and get window handles
403:21 - now the main difference between the two
403:23 - is that the get window handle returns
403:26 - the window value of the currently
403:27 - focused tab that is the parent window
403:29 - handle right
403:31 - whereas the get window handle it will
403:33 - return all the
403:35 - window handles including the parent and
403:37 - the child windows as we have seen in the
403:39 - example
403:40 - now the return type of get window handle
403:42 - is string
403:44 - whereas the return type of get window
403:45 - handles is set because the window handle
403:48 - is always unique and it is dynamic in
403:50 - nature and it keeps of changing okay so
403:53 - that's the reason why it is set so this
403:56 - is the basic difference between the get
403:58 - window handle and get window handles
404:00 - [Music]
404:01 - okay so the next interview question is
404:03 - how to switch to another window in
404:05 - selenium now to answer this question i
404:07 - divided the answer into two parts the
404:10 - first is that define the
404:12 - methods of selenium that can be used for
404:14 - handling the multiple windows in an
404:17 - application and those methods are the
404:18 - get window handle and the get window
404:21 - handles
404:22 - switch to end window these are some of
404:24 - the methods that will be used
404:27 - to
404:28 - handle multiple windows in an
404:29 - application so explain this first
404:32 - and then explain the steps the steps are
404:34 - similar to the uh
404:36 - test cases that we executed that is get
404:38 - the handle of the parent window by using
404:41 - the command driver dot get window handle
404:44 - print the parent window then find the
404:46 - element we found the element through
404:48 - xpath so you can use any of the element
404:50 - locator now open multiple child windows
404:53 - it through the child windows we use the
404:55 - for loop for this
404:56 - now get the handles of all the windows
404:58 - that are currently open using the
405:00 - command driver dot get window handles
405:03 - which returns the set
405:05 - why returning a set because it is
405:07 - storing unique
405:08 - values window handles right it is
405:10 - storing unique window handles so that's
405:12 - why it's set
405:13 - then use the switch to command to switch
405:15 - to the desired window that is the driver
405:17 - dot switch to dot window and then close
405:19 - the browser so these are the steps
405:22 - so that uh to handle multiple windows in
405:24 - an application okay
405:27 - okay so the next interview question that
405:29 - is asked is what does the switch to
405:31 - command do now basically the switch to
405:33 - command is used to switch between the
405:35 - windows frames and pop-ups and when we
405:37 - deal with frames and pop-ups at that
405:39 - time we will understand how it works
405:40 - okay
405:41 - so now whenever the web driver uh
405:43 - launches a new chrome browser it is
405:45 - given a unique alphanumeric value called
405:48 - the window handle
405:49 - and how to switch between the windows is
405:51 - that we use a
405:52 - driver.swisto.window and the handle
405:54 - value is given over here
405:56 - okay so this is what the switch to
405:57 - command do now this is one of the most
405:59 - important question i was asked in an
406:02 - interview this question so that's why i
406:03 - have mentioned this so as soon as you
406:06 - launch a browser window do we get the
406:08 - windows handle value
406:10 - the answer of this is yes
406:12 - let's see this with an example so as the
406:14 - question says that as soon as we launch
406:16 - a browser vendor do we get the windows
406:18 - handle value so here
406:21 - what i did is uh open the chrome browser
406:23 - i'm launching the chrome browser
406:26 - i'm launching the chrome browser and
406:27 - here i'm printing system.order
406:29 - system.out.printlndriver.getwindowhandle
406:31 - let's see what output do we get
406:34 - you have my chromebrowser is launched
406:36 - [Music]
406:39 - it is not navigated because i have not
406:41 - given any url over here and here you can
406:45 - see
406:46 - this is the get window handle i have
406:48 - used the get window handle uh
406:51 - command over here and i can see a window
406:53 - handle over here right
406:55 - so this means that as soon as you launch
406:57 - a browser window we can get the windows
406:59 - handle value there is no need to
407:01 - navigate to a url or something but as
407:03 - soon as we launch the browser you will
407:05 - get the window handle
407:07 - next is it mandatory to load a url to
407:09 - achieve the window handle value no as we
407:12 - have seen in the example
407:14 - here we are not loading any
407:16 - driver.getelement command right we are
407:18 - loading any url over here no right it's
407:20 - it's commented over here you can see
407:23 - so
407:24 - we can still get the window handle so
407:25 - this shows that it is not mandatory to
407:28 - load a url to achieve the window handle
407:30 - value
407:31 - okay this question is something very
407:33 - important
407:34 - so i was asked this question in an
407:36 - interview so that's why i have included
407:38 - this question
407:39 - now if you close the browser and then
407:41 - call the get window handle or get window
407:43 - handles on driver
407:46 - you will get no such session exception
407:48 - stating session id is null using the web
407:51 - driver after calling the quick
407:53 - now basically it says that you open the
407:55 - chrome browser i just launched the
407:57 - chrome browser i did not load the url
407:59 - and i'm quitting the browser
408:01 - then i'm calling the get window handles
408:03 - and what type of exception do i get do i
408:05 - get this exception and what this
408:07 - exception states you will understand
408:09 - that okay
408:11 - now here you can see i have already
408:13 - created this uh
408:15 - example in which i have launched the
408:16 - chrome browser i'm not loading any url
408:19 - i'm printing the get window handle value
408:21 - over here after launching the chrome
408:22 - browser and then again i'm calling
408:24 - driver.get window handles i want to know
408:27 - how many window handles are present over
408:28 - here okay after quitting the browser so
408:31 - let's see what output do we get over
408:33 - here
408:35 - let me execute this
408:37 - [Music]
408:39 - okay
408:44 - now here you can see uh
408:46 - we are launching the chrome browser the
408:47 - chrome browser launched successfully the
408:50 - chrome browser was started successfully
408:52 - then not loading uh we are not loading
408:54 - the url but we are printing the get
408:56 - window handle value over here we got the
408:59 - window handle over here
409:01 - next after quitting the browser we were
409:03 - trying to print the get window handles
409:05 - we were trying to know how many get
409:07 - window handles value are present over
409:09 - here for that the exception that we got
409:11 - is
409:13 - no such exception session id is null
409:16 - using web driver after calling quit
409:18 - this is the exception that we found now
409:21 - see
409:22 - whenever this script is trying to find
409:24 - an element after driver.quit or after
409:27 - driver.close action in the selenium
409:29 - script or after closing or quitting the
409:31 - driver session that is the open browser
409:33 - is closed right and at that time we are
409:35 - trying to find an element so at that
409:38 - time there is no session that is active
409:40 - to find the elements the session id is
409:43 - null uh exception is thrown at that time
409:46 - when we find try to find an element
409:48 - after driver.quit or after driver.close
409:51 - okay so this is what the this is what is
409:53 - the meaning of no such session exception
409:56 - and session id is none
409:58 - let's move to the next interview
410:00 - question that is does get window handles
410:02 - method return handles in the same order
410:05 - as the windows is launched the answer is
410:07 - no let's practically implement this now
410:10 - here i have created a html code in which
410:14 - there are links like open google
410:17 - and here there is open facebook and then
410:19 - there is open flip card and then there
410:21 - is open snapdeal okay these are the
410:23 - links now does get window handles method
410:26 - return handles in the same order as
410:28 - window launches let's find the answer
410:31 - for this so i have already written a
410:32 - code for this
410:35 - in which first we're opening the chrome
410:36 - browser i'm navigating to it and then
410:38 - i'm clicking on facebook i'm clicking on
410:40 - flipkart i'm clicking on snapdeal i'm
410:42 - clicking on google these are the sites
410:44 - that i'm clicking on and then i'm trying
410:46 - to find the get window handles and i'm
410:47 - printing it
410:48 - with the title so let's see
410:52 - which handle prints first
410:54 - and according to the order this the
410:56 - order should be google facebook flipkart
410:58 - snapdeal this should be the order now
411:00 - let's see the order
411:02 - so here my chrome browser is launched
411:04 - it's navigated
411:05 - [Music]
411:07 - and here you can see all the browsers
411:10 - are opened
411:12 - [Music]
411:23 - okay here the title is get window handle
411:25 - this is the parent window this is the
411:27 - parent window now the online shop online
411:30 - shop site india and this is a snapdeal
411:33 - this is flipkart this is facebook and
411:35 - google so basically it's the parent
411:37 - window
411:38 - snapdeal flipkart facebook and google
411:42 - but the order should be google facebook
411:43 - flipkart snapdeal okay so there is a
411:45 - different order so that this means that
411:48 - it is not necessary that the get window
411:51 - handle will method will return handles
411:53 - in the same order
411:54 - okay so the answer to it is no
411:57 - so this is all for today uh
412:00 - we learned some selenium interview
412:02 - questions about the get window handle
412:04 - and the get window handles which is very
412:05 - important and it is frequently asked
412:07 - also and we also learned the difference
412:09 - between the get window handle and the
412:11 - get window handles we learned how to
412:13 - handle multiple windows we executed some
412:15 - test cases also so this is all for today
412:18 - today we are going to learn about the
412:19 - drop down menus now basically a drop
412:22 - down menu is a menu that offers a list
412:24 - of options and we can select one value
412:27 - at a time
412:28 - for example
412:30 - here you can see this is the drop down
412:31 - menu i can select any one value at a
412:34 - time so this is called a drop down menu
412:36 - now we will handle the drop down menus
412:38 - with the help of a special class called
412:41 - as a select class
412:43 - because here you can see when i inspect
412:45 - this element
412:46 - i can see the select tag so that is the
412:49 - reason why to inspect this to select
412:51 - values in this drop down menu i will be
412:53 - using the select class
412:55 - now the basic syntax of select class is
412:57 - that select i'll create a reference of
412:59 - this
413:00 - new is equal to new select and i will
413:02 - specify my web element over here so this
413:04 - is the syntax of select class next there
413:06 - are different methods of select class
413:08 - we'll be covering all these methods that
413:10 - is the select by index select by value
413:13 - select by visible text deselect by index
413:16 - deselect by value deselect by visible
413:18 - text get options get all selected
413:21 - options and get first selected options
413:24 - the deselect by value deselect by index
413:26 - and deselect by visible text only works
413:29 - for the multi select box
413:30 - so what is multiselectbox we will cover
413:32 - that also
413:35 - now there are different types of drop
413:36 - down menus and we will be learning how
413:38 - to inspect all these menus the first is
413:41 - the drop down menu with a select class
413:43 - we have seen that example now
413:45 - next is the drop down menu with the
413:47 - multi select options
413:49 - and then there is a drop down menu with
413:50 - a bootstrap
413:52 - so uh here you can see this is a drop
413:55 - down menu with select class here you can
413:58 - see there is select tag and this is the
414:00 - multi select i can select multiple
414:01 - values over here okay so this is the
414:03 - multi select list so we will be
414:05 - inspecting these two lists first and
414:07 - then we will learn how to inspect the
414:09 - bootstrap list
414:10 - now uh when we are inspecting the drop
414:12 - down menu the first thing that we'll do
414:14 - is first we'll find how many options are
414:16 - present in the drop down menu we will
414:18 - extract all those options and then we
414:20 - will select the options from the drop
414:22 - down menu through through three methods
414:24 - the first is select by index select by
414:27 - value and then select by visible text
414:29 - okay so just open your intelligent idea
414:32 - id first
414:34 - now i have already created a java class
414:36 - i have named it as silly name tutorials
414:38 - under package com.selenium and i have
414:41 - given three commas that is open the
414:42 - chrome browser i have given the key that
414:44 - is the
414:45 - webdriver.chrome.driver and the value
414:47 - that is the executable chrome driver
414:49 - file
414:50 - then next i have written webdriver
414:52 - driver is equal to new chrome driver
414:54 - here i'm launching the chrome browser
414:56 - next i'm navigating to the urls i've
414:58 - specified the url over here this is the
415:00 - page that we will inspect first i will
415:03 - inspect the drop down menu and then we
415:05 - will select the
415:06 - multi select list okay and then i'm
415:08 - maximizing the browser now first to
415:11 - handle drop down menu first we will use
415:13 - a select class
415:15 - over here i'm going to write select i'll
415:17 - create a reference variable so i'll
415:19 - write select element
415:21 - new select
415:22 - and here i will specify the web element
415:24 - now there are two options over here
415:26 - either i write driver
415:28 - dot find element
415:31 - by dot
415:32 - x path and i will specify the x path
415:34 - over here i will inspect this element
415:37 - here it is and here in selectors up i
415:40 - can see the relative x path i'll copy
415:42 - this this is the first option
415:44 - the second option is
415:46 - the second option is if i copy this
415:49 - i'll simply cop i'll just copy this and
415:52 - i'll give a variable that is the web
415:54 - element
415:55 - i'll write your
415:58 - drop down is equal to driver dot find
416:00 - elements by dot x part and this is the x
416:02 - bar that i have given over here
416:05 - and here i'll write select
416:07 - then i'll write select element i'll give
416:10 - a reference variable i'm just showing
416:12 - you the different ways you can use the
416:14 - select class
416:15 - then new select
416:16 - and here i will specify
416:18 - drop down that is the web element
416:21 - variable that i have created over here
416:23 - okay so these are the two methods you
416:25 - can use a select class i prefer this one
416:28 - so
416:29 - i'll just comment this and we will
416:32 - continue with this one okay
416:34 - so here i have written select i have
416:35 - created a reference variable that is a
416:37 - select element is equal to new select
416:39 - and i have specified the web element
416:41 - that is the location of the drop down
416:43 - menu now
416:44 - here
416:46 - after creating a select class we will
416:49 - find how many options are present in the
416:50 - drop down menu so here i am going to
416:52 - write select element dot
416:56 - get options okay
416:58 - so your get options
417:00 - belongs to the select tag and
417:02 - through this option we will derive all
417:04 - the
417:05 - options that are present in the drop
417:06 - down menu okay
417:08 - now here i will store it in a list type
417:10 - of a web element
417:12 - i'll name this web element as options
417:14 - and is equal to select element dot get
417:17 - options now here i will print so i'll
417:20 - write s out
417:23 - i'll write options dot
417:26 - size now why i'm using the size function
417:29 - over here is because i want to return
417:31 - the number of elements in the list i
417:33 - want to see how many number of elements
417:34 - are present in the list okay
417:37 - then we will extract the values so let's
417:40 - run this
417:43 - my chrome browser is launched it's
417:45 - navigated
417:47 - it's maximized
417:50 - here there is no value displayed because
417:52 - we are not selecting any value right now
417:55 - we have just seen there are total eight
417:57 - elements that are present over here
417:59 - let's check
418:01 - if i inspect this
418:03 - here there is eight element that is one
418:05 - two three four five six seven eight
418:08 - there are total eight elements that is
418:10 - present over here
418:11 - okay here you can see it so the next is
418:14 - that we have to print them so for that
418:16 - we will be using the for each loop here
418:19 - i have written four and over here
418:21 - because of inspecting the web element so
418:23 - i'll write the web element and i'll give
418:25 - it as
418:26 - i'll give a variable as e
418:28 - and here because
418:30 - i have to
418:32 - print the options that are present
418:34 - so i'll write options over here
418:36 - and then i'll write a system.out.println
418:41 - i'll write the values r
418:43 - and here i'll write e dot e dot get text
418:47 - so let's execute this my chrome browser
418:50 - is launched it's navigated
418:52 - it's maximized and here you can see the
418:54 - values that is there please select then
418:57 - we have sunday monday tuesday wednesday
418:59 - thursday friday saturday
419:00 - and year also we can see these value
419:03 - please select sunday monday tuesday
419:04 - wednesday thursday friday saturday
419:08 - okay so these are the values we have
419:10 - printed the values now uh now
419:13 - i want to select them
419:16 - i want to select these options okay so
419:19 - there are three methods to select these
419:20 - options the first is select by index
419:23 - then it is select by value and next is
419:26 - select by visible text these are the
419:28 - different types of methods through which
419:29 - we will select the options in the drop
419:31 - down menu okay
419:33 - now let's use first
419:36 - select by
419:38 - value now here select by value when i
419:40 - inspect this element
419:42 - i can see option value there are
419:44 - different types of values given over
419:46 - here that is the sunday monday tuesday
419:49 - wednesday thursday friday saturday here
419:52 - it is an option value friday right so
419:55 - i'll be using this value to select this
419:57 - option so for example if i use
420:00 - friday i'll write
420:03 - select element
420:05 - dot
420:06 - [Music]
420:07 - select by value
420:10 - and i'll specify the value over here
420:12 - friday
420:13 - okay
420:14 - now let's run this
420:16 - my chrome browser is launched it's
420:18 - navigated it's maximized and here you
420:21 - can see the friday is selected here you
420:23 - can see
420:24 - they selected friday
420:26 - the values are printed we have got the
420:28 - total number of values that is 8 and
420:30 - then the values are also printed and
420:32 - friday is selected
420:34 - this is the first method
420:36 - the next method is
420:39 - select by
420:40 - index
420:42 - now for example suppose if i want to
420:44 - select tuesday okay and these are the
420:46 - options that are present over here to
420:48 - select by index it starts from zero so
420:50 - this will be zero one two three tuesday
420:54 - will be three so i'll be writing three
420:56 - over here so first i'll write select
421:00 - element dot
421:01 - select by index and i'll specify 3 over
421:04 - here now let's run this
421:07 - my chrome browser is launched
421:10 - it's
421:10 - navigated it's maximized and here you
421:13 - can see the day selected is tuesday
421:16 - okay so the next method is
421:19 - select by visible
421:22 - text
421:23 - okay
421:25 - over here
421:26 - visible text means
421:28 - when i'm inspecting this element the
421:30 - text that is visible over here here you
421:32 - can see there is text sunday monday
421:34 - tuesday
421:35 - now it is not necessary if the value and
421:38 - the text that is visible here is the
421:40 - same
421:41 - okay
421:42 - here in this case it is same but it is
421:44 - not
421:46 - it is not compulsory that the value and
421:48 - the visible text is same so for example
421:52 - now if i want to select monday so i will
421:54 - just copy this visible text monday over
421:56 - here
421:57 - and i'll
421:58 - paste it over here i'll write select dot
422:01 - select
422:03 - by visible text
422:05 - and i will paste it over here i'll
422:08 - comment this
422:10 - and i will execute this
422:12 - my chrome browser is launched
422:17 - it's navigated and here you can see the
422:18 - day selected is
422:20 - monday so now these are the different
422:22 - ways through which we can select these
422:23 - options now if in the interviews they
422:26 - ask how to handle drop down menus i have
422:28 - divided this answer into different steps
422:31 - so the first step is that to handle the
422:33 - drop down menu we will use the select
422:34 - class so first we will create a variable
422:37 - of web element type and pass it as a
422:39 - parameter in the select class as we have
422:41 - done in the example before i have
422:44 - created a variable of web element that
422:45 - is the d and driver.fine element by dot
422:48 - idean have specified the location of the
422:50 - drop down menu over here
422:52 - next i have created a select class
422:54 - i have also created a reference variable
422:57 - of this that is the drop down list is
422:59 - equal to new select and i have passed
423:02 - the parameter of web element type that
423:04 - is the d over here in the select class
423:07 - now this is the first method the second
423:08 - method is that if we see if we write
423:10 - select drop down list is equal to new
423:12 - select and we write driver.find element
423:13 - directly to vwritedriver.find element
423:16 - that is also fine okay
423:19 - then the next step is that we will find
423:21 - how many options are present in the drop
423:22 - down menu to find that we will write
423:24 - drop down list dot get options dot size
423:27 - now we can extract all the options in
423:29 - the drop down menu in the selenium with
423:31 - the help of select class method which
423:33 - has the get options method now this
423:35 - drives all the options of the select tag
423:37 - and it returns a list of web element
423:39 - types okay get options returns the list
423:42 - of web element types just remember that
423:44 - now we will extract all the options we
423:46 - will print them for printing them we are
423:48 - using the for loop and for extracting we
423:50 - use the
423:52 - dropdownlist.getoptions
423:53 - method
423:54 - and we printed it
423:56 - next is that we selected options from
423:58 - drop down menu through three ways first
424:01 - is select by index then select by value
424:03 - then select by visible text
424:05 - so your select by index you can use the
424:08 - index to select the option from a drop
424:10 - down menu basically the index starts for
424:13 - zero so this means the first option
424:15 - index will be zero and so on okay now if
424:18 - we write select by index we will writing
424:20 - uh we will write select dot select by
424:22 - index we will specify the index over
424:24 - here okay
424:26 - next is the select by value you can
424:28 - select an option by using the value
424:30 - attribute provided for each option in
424:33 - the drop down menu in the drop down menu
424:35 - there is an option that is a value
424:37 - attribute provided so using that value
424:39 - attribute you can
424:41 - select the option through select by
424:43 - value
424:44 - okay simply just write select dot select
424:46 - by value and the value you want to
424:48 - select
424:49 - for example in the value it is given
424:51 - options value is equal to 4 so your
424:54 - specify 4 now select by visible text
424:58 - you can use the visible text to select
424:59 - the options so if you want to select
425:01 - 2015
425:03 - you can select the option by visible
425:04 - text that is 2015 will be written over
425:07 - there okay
425:08 - so just simply write select dot select
425:10 - by visible text and specify the text
425:13 - that is visible over there so these are
425:15 - the three ways where you can uh handle
425:17 - the uh drop down menu options you can
425:19 - select these options through these three
425:22 - ways okay
425:23 - now as i specified this is the index
425:25 - that is selecting by index it will start
425:28 - from zero
425:29 - uh this is the select by uh visible text
425:32 - and this is select by value there is
425:34 - option value attribute that has been
425:35 - used over here so you will be using the
425:37 - select
425:38 - by value
425:40 - now over here we will understand what is
425:42 - the multi select drop down list
425:44 - a multi select drop down list control
425:46 - allows the user to select multiple items
425:49 - from the list
425:50 - to check if the select element supports
425:52 - the multiple selecting options at the
425:54 - same time or not we will use is multiple
425:57 - method this returns a boolean value that
425:59 - is true or false
426:01 - now here you can see this example there
426:03 - is multiple uh options are selected so
426:06 - this is called a multi select drop down
426:08 - box now there is multiple method for
426:11 - example over here this box is not
426:13 - multi-selected box right
426:16 - so if i write
426:21 - select element dot is multiple
426:24 - and i store this in a boolean type of a
426:26 - variable
426:27 - and let me print this variable
426:29 - so it will return true or false now in
426:31 - this case it will return false because
426:33 - it is not a multi select
426:35 - box so i will write
426:38 - and i will print it
426:39 - so let's execute this
426:43 - chrome browser's launch is navigated and
426:44 - maximized and here you can see this is
426:46 - like today days monday
426:48 - and the output for this is false why
426:51 - because it is not supporting multiple
426:53 - select
426:54 - it is not a multiple select drop down
426:56 - menu this is a multiple select drop down
426:58 - menu so we'll be using
427:00 - is multiple method in this and the
427:01 - answer for this will be true
427:04 - now
427:05 - to select multiple values in a drop down
427:07 - box
427:08 - i'll create a new
427:10 - java class
427:12 - i'll name it as
427:14 - selenium tutorials 16. now i'll simply
427:19 - copy this till
427:21 - printing the values
427:24 - [Music]
427:27 - now first i'm launching the chrome
427:28 - browser i'm opening the url maximizing
427:30 - the page
427:31 - i'm creating a select class i'll change
427:33 - the xpath over here
427:37 - i will inspect
427:39 - so this is it i'll copy this relative
427:41 - xpath over here
427:42 - i'll paste it over here
427:45 - then i'm finding the options present in
427:47 - the drop down menu it will print the
427:49 - number of options and then it will print
427:52 - the values of the options
427:54 - so let's execute this
427:57 - now my chrome browser is launched
428:00 - it's
428:01 - maximized
428:03 - and here i can see the total values are
428:05 - eight and the values are california
428:07 - florida new jersey new york
428:09 - texas
428:10 - these are the values that is present
428:12 - over here now if i want to select them
428:14 - what i'm going to do is i'm going to use
428:16 - we'll be using those options only that
428:19 - is a select by value select by index
428:20 - select by visible but there is something
428:23 - different in this
428:24 - that is a deselect now let's first see
428:26 - if this is a multi-select box or not so
428:29 - if i'll write first i'll use is multiple
428:32 - method i'll write select element dot is
428:35 - multiple
428:37 - i'll store this in a boolean type of a
428:39 - variable
428:41 - i'll print it
428:43 - and let's run this
428:46 - my chrome browser is launched it's
428:48 - navigated it's maximized
428:50 - and here you will see it's true
428:52 - so this is a multi select box and
428:55 - now let's select elements so now we will
428:58 - select the values so i'll write
429:02 - first we will use select
429:05 - by
429:06 - index so i'll write select element dot
429:10 - select by index
429:12 - and i want to select
429:14 - this
429:15 - the first index itself so this the index
429:18 - starts with zero so this is the zeroth
429:19 - index that is the california so i'll
429:22 - write 0 over here
429:24 - next we will use the select
429:27 - by value method
429:30 - i'll write select element dot select by
429:34 - value
429:35 - your value for new york is
429:38 - new york so i'll just copy this
429:41 - and i will paste it over here
429:44 - now next is that select by
429:48 - visible text
429:51 - so i'll write
429:53 - select element dot
429:55 - select by visible text and i will write
429:58 - the visible text that is present over
430:00 - here for
430:01 - washington it is washington so i'll just
430:06 - copy this
430:08 - washington and let's see whether it's
430:10 - selecting or not so i'll just run this
430:12 - command
430:13 - so my chrome browser is launched
430:15 - it's navigated
430:18 - it's maximized
430:20 - and here you can see there are three
430:21 - values that are selected that is the
430:22 - california new york and washington
430:26 - okay
430:27 - now if i want to know which is the first
430:30 - selected value so i'll write select
430:32 - element dot
430:34 - get
430:35 - first selected option
430:37 - dot
430:38 - get text i will
430:40 - write this in
430:43 - s out
430:44 - i want to print this so i'll write
430:47 - system.out.println select
430:48 - element.getfirstselectedoption.gettext
430:52 - now the
430:54 - first get first selected option returns
430:56 - the first selected option in the select
430:58 - tag here you can see it
431:00 - is the first selected option in the
431:01 - select tags and if we don't find it it
431:03 - will throw the exception no such element
431:05 - exception if the option is not selected
431:09 - so
431:11 - let's execute this
431:14 - my chrome browser is launched
431:16 - it's navigated
431:19 - so the options are selected
431:24 - the first option that we have selected
431:25 - is california over here you can see the
431:28 - index that we have given zero so the
431:30 - first option that is selected over here
431:31 - is california okay
431:33 - now let's deselect the values
431:36 - for that
431:37 - we'll be using three commas at the
431:39 - deselect by index deselect by value and
431:42 - deselect by visible text
431:44 - so first i'll write
431:46 - select element dot
431:48 - deselect
431:51 - by index okay now i want to deselect
431:55 - new york because i have selected new
431:57 - york so i will be writing 0 1 2 3. new
432:01 - york is the third index so i'll write 3.
432:05 - now here i'll write thread
432:07 - dot sleep
432:08 - let me give some time
432:12 - and let's execute this
432:15 - my chrome browser is launched it's
432:16 - navigated it's maximized
432:19 - and the values are selected california
432:21 - new york and washington and we saw the
432:23 - new york got deselected
432:26 - now next
432:28 - we will use the next method
432:30 - that is
432:31 - deselect
432:32 - [Music]
432:34 - by value so i'll write select element
432:37 - dot deselect by
432:39 - value
432:40 - now i want to deselect
432:43 - washington
432:44 - so the value of washington is washington
432:46 - so i'll simply copy this
432:48 - and paste it over here
432:50 - okay now let's execute this
432:54 - my chrome browser is launched it's
432:56 - navigated
432:57 - it's maximized and here you can see the
432:59 - three values that is selected
433:01 - and the new york and washington is
433:03 - deselected
433:07 - okay now we will use deselect
433:10 - by visible
433:11 - text
433:13 - so i'll write select element dot
433:16 - deselect by visible text
433:20 - and here
433:22 - i'll specify i will
433:24 - now here i want to deselect the
433:26 - california so the visible text that is
433:28 - present over here is california
433:30 - so i'll copy this
433:34 - paste it over here
433:37 - and let's run this
433:40 - my chrome browser is launched
433:43 - [Music]
433:44 - it's navigated
433:46 - it's maximized and those three values
433:48 - are selected
433:50 - the new york and washington is
433:52 - deselected
433:55 - okay so here i've used so here i'll
433:57 - write select element dot
433:59 - deselect by
434:01 - visible text and url paste california
434:05 - okay now so run this
434:07 - launch the chrome browser
434:09 - and maximize the web page and these are
434:12 - the three elements that is selected
434:13 - california new york and
434:15 - washington and all are deselected now
434:18 - over here the deselect option works only
434:20 - with the multi select boxes
434:23 - it does not work with the normal
434:25 - drop-down box that we have it works only
434:27 - for the multi select for example if i
434:29 - work for the multi select box the
434:31 - deselect option then
434:33 - in that case
434:35 - for example over here
434:39 - i'm selecting monday so in this case
434:42 - what will happen if i write
434:44 - select element dot deselect
434:48 - by visible text
434:51 - and here i'll specify monday itself
434:56 - so it will show an error
434:58 - so my chrome browser is launched
435:01 - it's navigated
435:04 - it's maximized
435:06 - and here you can see the date selected
435:08 - is monday
435:10 - [Music]
435:12 - but it shows an exception over here
435:15 - while deselecting monday shows an
435:17 - exception it says that
435:19 - you may only deselect options of a
435:21 - multi-select
435:23 - okay
435:24 - so the deselect option works only for
435:25 - the multi select drop down menus and not
435:28 - for the uh drop down menus with the
435:30 - select class okay
435:32 - so these are the different types of
435:34 - methods that we launched today that is
435:36 - the
435:37 - select by value select by index select
435:40 - by visible text and deselect by value
435:42 - deselect by index and deselect by
435:44 - visible text also we learnt the option
435:48 - that is the
435:49 - get for selected options now this works
435:51 - for validation then we have learned the
435:52 - method that is the guest get first
435:54 - selected option also so these are the
435:56 - different types of methods that is
435:58 - supported by the select class
436:00 - so this is all for now in the next class
436:03 - we will learn how to inspect the
436:05 - bootstrap drop down menu
436:08 - so today we're going to understand how
436:10 - to handle auto suggestion drop down
436:12 - menus with selenium webdriver
436:14 - well to understand how to handle auto
436:16 - suggestions with selenium webdriver
436:19 - firstly it is necessary to understand
436:21 - what basically order suggestions are for
436:23 - example if i type selenium
436:27 - webdriver
436:28 - now here you can see there are number of
436:30 - inputs given for selenium webdriver
436:32 - so these inputs are known as auto
436:35 - suggestion or autocomplete so we're
436:37 - going to automate this today
436:40 - this is the page that we're going to
436:42 - automate today what i want is for
436:43 - example suppose if i write the buy over
436:45 - here
436:47 - and i can see the number of inputs right
436:48 - so i'm going to click on this input and
436:50 - over here if i write indoor
436:55 - and here also i can see there are number
436:56 - of inputs right
436:59 - so i will click over here so this is
437:00 - what we're going to inspect today
437:03 - so let's just open your intellij idea
437:05 - ide
437:06 - okay so here i have already created a
437:08 - java class i have named it as selenium
437:11 - tutorial 17 under package com.tutorials
437:14 - of selenium and i have written the three
437:16 - basic
437:17 - commands that we usually write first is
437:19 - opening the chrome browser for opening
437:21 - the chrome browser we write system.set
437:23 - property in which we have the key
437:24 - written that is the
437:26 - webdriver.chrome.driver and the value is
437:28 - the chrome driver executable file
437:31 - next we have written web driver driver
437:33 - is equal to new chrome driver which will
437:35 - launch the chrome browser
437:37 - next we have navigated to the url so
437:39 - this is the page that we want to
437:40 - navigate to so i have just copied this
437:42 - url over here in driver.get command
437:46 - next i have written
437:49 - driver.manage.window.maximize to
437:50 - maximize the chrome browser so let's
437:52 - just execute this
437:55 - okay so here you can see the chrome
437:56 - browser is launched
437:59 - and it's navigated
438:03 - and it's also maximized okay so our
438:06 - three uh so are these three commands are
438:09 - working properly now let's uh automate
438:11 - the auto suggestion
438:14 - drop down menus so this is the page and
438:16 - i want to click on this element so i
438:18 - will inspect this
438:21 - also one thing like in the previous
438:23 - tutorial i explained about the drop down
438:25 - menus which were of select class over
438:27 - here there is no select class included
438:30 - so here you can see we have the input
438:32 - tag so i'll just copy this i'll go to
438:36 - selectors hub
438:37 - and here i can see the relative x path
438:39 - since i want to click on this element so
438:41 - i'll just copy this x path
438:45 - now here i will write driver dot find
438:48 - element
438:49 - by dot
438:51 - x path and i will specify this x path
438:54 - over here
438:55 - and i want to click on this
438:57 - so i'll write
439:00 - click
439:03 - or let's do one thing
439:05 - uh
439:06 - let me save this in a web element type
439:08 - of a variable
439:11 - so i'll just write
439:13 - from is equal to
439:15 - now i have saved this in a web type web
439:18 - element type of a variable i have named
439:20 - it as from
439:22 - so web element from is equal to driver
439:24 - dot find element by dot x path and i
439:26 - have placed my x path over here now over
439:29 - here i'm going to write from
439:31 - dot
439:32 - click
439:33 - first we will click on this element
439:35 - after inspecting uh so first we will
439:38 - click on this element
439:39 - then what i want to do is i want to move
439:41 - my cursor downwards okay now during
439:45 - automation we often require to press
439:47 - enter or we need to move our arrow keys
439:49 - downwards or we need to use the function
439:52 - keys or the tab or delete or enter okay
439:56 - so we can use these keys through send
439:59 - keys command how is that possible so
440:01 - just have a look at the syntax so here
440:03 - are the keyboard keys so here you can
440:05 - see we have the arrow key down so under
440:07 - the send keys command you just need to
440:09 - write keys dot arrow down which will
440:12 - move the arrow downwards okay
440:14 - next we have arrow key up which will
440:16 - move the arrow upwards then we have
440:19 - arrow key left right backspace ctrl key
440:23 - alt delete enter shift space bar so
440:26 - basically these are all the keyboards
440:28 - keys that is given by using send keys
440:30 - command you can press them
440:32 - okay so over here
440:36 - also we have the function keys like the
440:38 - f1 f2 f3 we can press these keys also by
440:42 - using the send keys command
440:44 - usually you we use the action classes
440:46 - for the keyboard commands but since we
440:49 - haven't learnt about action class so
440:50 - over here we will use the send keys
440:52 - command
440:54 - so here after clicking what i want to do
440:56 - is i'll write from
440:57 - dot send keys and i first i will enter
441:00 - some value that is dubai
441:02 - and after entering some value i want to
441:04 - move my cursor downwards right so i will
441:07 - write send keys again and here i will
441:09 - write keys
441:11 - dot
441:12 - arrow here you can see we have add alt
441:15 - left arrow down
441:17 - arrow left arrow right so i'll just
441:19 - click on arrow down
441:21 - now uh since uh first i clicked on this
441:24 - element then i entered some value that
441:26 - is dubai and then i moved downwards and
441:28 - after moving downwards what i want to do
441:30 - is i want to press enter okay
441:33 - so again over here i'll write from
441:37 - dot
441:39 - send keys and here i'll write keys dot
441:43 - enter
441:44 - and here you can see we have enter okay
441:47 - so this is what i want now why i have
441:49 - given a web element type of a variable
441:51 - over here because i want to make my code
441:53 - very systematic now if i did not give a
441:56 - web element type of a variable over here
441:58 - i mean uh you have to write again and
442:00 - again try dot find element the x part
442:02 - dot click then driver dot find element
442:04 - again the x path then dot send keys so
442:06 - instead of that i have written web
442:08 - element and i have given a variable from
442:11 - and then i have specified the x path and
442:13 - after that i'm clicking i'm sending keys
442:15 - and then i'm moving downwards and then
442:17 - i'm entering
442:18 - okay
442:19 - so let's execute this
442:21 - okay so my chrome browser is launched
442:25 - it's navigated
442:27 - it's maximize and here you can see dubai
442:30 - and it's moved downwards
442:32 - and it's
442:33 - entered so this is how we can automate
442:36 - it okay similarly we're going to do to
442:38 - this drop down menu also first i will
442:40 - inspect this
442:44 - go to inspect go to selectors hub and
442:47 - here we have the relative xpath i'll
442:48 - simply copy this
442:51 - and i'll just write a web element type
442:52 - of a variable first over here web
442:55 - element 2 is equal to driver
442:58 - dot find element
443:00 - by dot x path and i will specify the
443:02 - relative x path
443:04 - over here
443:05 - okay so first i will click the drop down
443:07 - menu then i would then after that what i
443:10 - want to do is i want to send some
443:11 - commands so let's send keys
443:13 - um
443:14 - i'll write indoor
443:18 - you can specify anything over here then
443:20 - i'll write 2 dot again i'm going to
443:22 - write send keys since i want to move the
443:25 - arrow downwards so i'll write keys
443:27 - dot
443:29 - arrow down okay
443:31 - let me specify some time over here
443:34 - thread dot sleep and i specify 2000
443:40 - similarly here also i will specify
443:42 - thread.sleep i will specify the time
443:45 - next after moving down i want to click
443:48 - on the
443:49 - enter button okay so i'm going to write
443:52 - 2 dot
443:54 - send keys and here i'm going to write
443:56 - keys dot
444:00 - enter
444:04 - so first i am
444:06 - clicking the element
444:07 - then i'm entering some value in it after
444:10 - that i'm moving the arrow downwards and
444:12 - then we have to enter
444:14 - okay
444:15 - so let's execute this
444:18 - so here my chrome browser is launched
444:24 - it's
444:25 - maximized and you can see dubai is
444:28 - entered let's click similarly indoor is
444:30 - entered and it's moving downward and it
444:32 - is
444:33 - clicked okay so this is how you can
444:36 - automate your
444:38 - auto suggestions drop down menus
444:41 - now that's it for this video i hope you
444:43 - have learned something new and
444:45 - now check boxes are widely used on our
444:47 - web pages to offer multiple choices of
444:50 - an option to the user it is basically a
444:52 - gui that allows the user to make certain
444:55 - choices for the given options okay now
444:58 - the user may get a list of choices and
445:00 - the checkbox records the choices made by
445:02 - the user the user can select either
445:04 - single choice uh or multiple choices
445:07 - okay so the user can make single choices
445:09 - or multiple choices out of the given
445:11 - list depending on their requirement okay
445:13 - so first we will learn how to handle
445:15 - these check boxes
445:17 - and then we will learn how to validate
445:19 - them
445:20 - now the user will select the options
445:22 - according to their requirement but as a
445:24 - quality engineer when you are becoming a
445:27 - software tester
445:28 - what will you do with these with these
445:30 - choices you're going to validate these
445:31 - choices okay that's what your work is
445:34 - right as an automation tester you
445:36 - perform test cases right so how we're
445:38 - going to handle the checkbox that we're
445:40 - going to learn first and then we're
445:42 - going to perform some validations on the
445:43 - check boxes
445:45 - okay so here uh we will understand the
445:47 - validation through three commands that
445:49 - is the is displayed is enabled and is
445:52 - selected we have covered these three
445:54 - commands in the previous tutorials and i
445:57 - have also explained the difference
445:58 - between these three commands okay
446:01 - so now uh this is the page that we're
446:03 - going to automate today here you can see
446:06 - we have the check boxes now you must be
446:08 - thinking how do we handle these check
446:10 - boxes right it's very easy simply just
446:13 - clicking on these check boxes it gets
446:15 - checked and if you click again it is
446:17 - unchecked right that's what we're going
446:19 - to do to handle these check boxes so
446:21 - just open your intelligent idea ide so
446:24 - here i have already created a selenium
446:26 - tutorial 18 java class
446:29 - in package com.tutorials of selenium and
446:32 - here we have written the three basic
446:34 - commands that we write in all the
446:36 - programs okay that is first launching
446:38 - the chrome browser to launch the chrome
446:40 - browser we write system.set property in
446:43 - which we involve the key that is the
446:46 - webdriver.chrome.driver and the value is
446:48 - the executable file
446:50 - next we have written web driver driver
446:52 - is equal to new chrome driver which
446:53 - launches the chrome browser
446:56 - now we have to navigate to the url
446:58 - through driver.get command this is the
447:00 - page that we're going to navigate to so
447:02 - i have copied this url in
447:04 - driver.getcommand and then we are
447:06 - maximizing the browser so let's just
447:08 - execute this
447:11 - i'll
447:12 - run this here you can see my chrome
447:14 - browser's launched
447:17 - it's maximized
447:19 - it's navigated and it's maximized okay
447:21 - so basically these three commands are
447:23 - working properly
447:25 - now let's handle
447:28 - the check boxes
447:30 - okay
447:31 - now to handle the check boxes uh
447:34 - generally what you do you just click on
447:36 - it right that's what we're going to do
447:38 - we're going to perform the click
447:40 - operation over here
447:41 - first let's inspect this i'll just go on
447:44 - selectors up
447:45 - and i'll just copy this relative x path
447:49 - i will write driver dot
447:52 - find element
447:54 - i dot x path
447:56 - and i will specify the
447:58 - x path over here
448:02 - okay so i will let me store this in a uh
448:05 - web element type of a variable i'll name
448:08 - it as
448:09 - sports
448:10 - because it's a sports check box
448:12 - okay now what operation do we need to
448:14 - perform over here we need to click this
448:18 - so i will write sports dot
448:20 - click command
448:22 - okay let us execute this
448:24 - okay so my chrome browser is launched
448:27 - it's
448:28 - navigated
448:30 - it's maximized
448:33 - and here you can see the spots is
448:35 - checked
448:36 - okay
448:38 - next
448:39 - again we will inspect
448:41 - this element that is the reading element
448:43 - checkbox
448:45 - here it is so i will copy the relative x
448:48 - path
448:50 - and again i will write
448:52 - web element i will write it as
448:55 - reading
448:57 - is equal to
448:59 - driver dot fine element
449:01 - by dot x path and i will specify the x
449:04 - path over here
449:05 - okay
449:06 - now what operation do i need to perform
449:08 - over here is
449:10 - click
449:11 - so i'll simply just click this i will
449:13 - give some time limit over here so that
449:15 - we can see the execution properly
449:19 - let me execute this again
449:23 - so you have my chrome brush is launched
449:26 - navigate and maximize and here you can
449:27 - see the sports is clicked the reading is
449:29 - also clicked
449:31 - okay
449:32 - so now the third web element so i'll
449:35 - write web element dot
449:37 - sorry web element and i will specify the
449:40 - variable over here as music is equal to
449:42 - driver
449:43 - dot find element by dot
449:46 - x path
449:47 - and
449:48 - i will just
449:50 - inspect this element and here it is so i
449:53 - will just
449:54 - copy this x path
449:56 - and i will
449:58 - paste it over here
450:02 - now what operation i need to perform
450:03 - over here is click operation right so i
450:05 - will just write music dot
450:07 - click
450:09 - let's specify some time over here so
450:12 - that
450:12 - we can see the execution properly
450:18 - i'll execute this
450:20 - so your uh my chrome browser is launched
450:23 - it's navigated
450:25 - it's maximized and here you can see
450:27 - sports is checked
450:28 - reading is checked
450:30 - music is also checked
450:32 - okay
450:33 - now while handling these check boxes
450:35 - that is check and uncheck right so we
450:37 - have learned how to check these check
450:39 - boxes let's learn how to uncheck them so
450:42 - if the check box is checked simply by
450:44 - clicking it again it will uncheck right
450:46 - so that's what we're going to perform it
450:48 - again
450:49 - so if we write uncheck so here i've
450:51 - written uncheck and what i'll do is i
450:53 - will click all these elements again so
450:55 - i'll just write sports dot
450:58 - click
450:59 - and then i will specify some time
451:02 - red dot sleep
451:05 - then again i'm going to write
451:10 - reading dot click and and then i will
451:13 - specify some time
451:15 - click and then i will specify some time
451:17 - over here sorry thread dot sleep
451:23 - again i'll write music dot click
451:26 - just by clicking them again i'm going to
451:29 - uncheck it okay
451:31 - so i'll write
451:33 - red dot
451:36 - sleep over here also
451:39 - now why i'm re writing shred dot sleep
451:41 - is because i want to see the execution
451:43 - of the code properly okay so i am giving
451:46 - a waiting time over here basically
451:49 - so let's execute this
451:51 - and my chrome browser is launched
451:53 - it's navigated it's maximized
451:56 - sports is checked
451:58 - reading is checked music is checked
452:00 - sports is unchecked reading is unchecked
452:03 - and music is unchecked
452:05 - okay so here we have learnt how to
452:08 - handle our checkbox so we can use the
452:10 - click operation to handle the checkbox
452:13 - if we click it once it will be checked
452:14 - if we click it again it is unchecked
452:17 - okay
452:17 - now let's learn the validation part
452:21 - now in validation i have explained three
452:24 - commands in the previous tutorials
452:26 - so if you have seen all the tutorials
452:28 - before i have also explained the
452:30 - difference between is selected is
452:31 - enabled and
452:33 - is displayed okay so these are the three
452:36 - commands that we're going to use for
452:37 - validation first is display that is it
452:40 - returns true or false if the element is
452:45 - is displayed
452:52 - then we have the is selected
452:54 - then we have the is selected which
452:55 - returns true or false
452:58 - if the element is
453:01 - selected
453:04 - okay
453:05 - and next is is enabled
453:08 - so uh these three functions returns
453:10 - boolean values that is true or false so
453:12 - it returns true or false if the element
453:15 - is enabled
453:18 - okay
453:20 - so these are the three commands for
453:22 - validation
453:24 - and your
453:27 - let's validate it so first uh i have
453:30 - explained how to handle it so first we
453:32 - are clicking the element like over here
453:34 - we are writing sports dot click so it is
453:35 - clicked
453:36 - okay next we are unchecking it so it is
453:39 - clicked again it's unchecked now here
453:41 - i'll first use the
453:44 - is
453:45 - displayed
453:47 - okay
453:48 - i'll just write
453:50 - sports dot
453:52 - is displayed
453:55 - okay
453:56 - and
453:57 - i'll store this in a boolean type of a
453:59 - variable
454:03 - so boolean bole one is equal to sports
454:06 - dot is displayed
454:08 - and we're going to print this
454:11 - now if this boolean variable is
454:13 - displayed
454:14 - okay now if this bool one comes true and
454:17 - if it is displayed it is true
454:21 - then we're going to write sports dot
454:23 - click okay
454:25 - let's execute this
454:28 - since it will show true because the
454:30 - element is displayed on the web page
454:32 - okay
454:33 - here my chrome browser's launched
454:37 - it's maximized and you can see sports is
454:39 - selected reading is selected music is
454:41 - selected sports is unselected reading is
454:43 - unselected and music is also unselected
454:47 - and again sports is selected the reason
454:49 - behind that is because the boolean value
454:51 - is printing true and since we have given
454:53 - a condition over here if the boolean
454:55 - value is true the spots will be clicked
454:57 - okay
454:59 - similarly let's
455:00 - go for
455:02 - is
455:04 - selected
455:05 - okay so your if i write
455:08 - boolean
455:10 - volt2 is equal to
455:12 - let's go for reading dot
455:15 - it's selected
455:19 - and
455:20 - next i'm going to write
455:23 - system.out.println and i'm going to
455:24 - print this
455:26 - value
455:27 - okay
455:29 - now let me give a condition now if
455:31 - boolean 2 is equal to
455:34 - is equal equal to false now if it is
455:36 - false
455:37 - if it is not selected
455:40 - then we're going to write
455:42 - reading dot
455:44 - click
455:45 - okay
455:46 - now let's execute this okay so my chrome
455:49 - browser is launched
455:51 - it's navigated
455:53 - it's
455:54 - maximized
455:56 - and you can see his post is clicked
455:59 - reading is clicked
456:00 - music is clicked sports is unclicked
456:03 - reading is unclicked and music is also
456:05 - unclicked
456:07 - and again this post is clicked and the
456:08 - reading is also click the reason why it
456:10 - is clicked because i have given
456:12 - over here the condition is like bool 2
456:14 - is equal equal to false and here the
456:16 - output for
456:17 - when we are writing reading dot is
456:19 - selected the output is false why because
456:21 - once we clicked it
456:23 - and after that again we are unchecking
456:25 - it right so if selected retrieves false
456:28 - if the element is not selected so here
456:30 - the element is not selected at this
456:32 - point of time so the value of bulldo is
456:35 - false and since it falls then it's
456:37 - clicking it again
456:39 - okay now let's let's go for is enabled
456:44 - now again i'll write boolean
456:47 - bool3 is equal to
456:49 - music
456:51 - bot is enabled
456:54 - okay
456:55 - next we're going to print it so i'll
456:57 - write
456:59 - 3
457:00 - and here again
457:02 - i'll give a condition condition will be
457:04 - if
457:06 - o 3 is equal equal to
457:09 - true
457:11 - if the value is true
457:13 - then music
457:15 - dot
457:16 - click
457:17 - just click the music check box
457:20 - so let's execute this
457:22 - okay so my chrome browser is launched
457:25 - it's maximized and here this post is
457:27 - clicked reading is clicked music is
457:29 - clicked
457:30 - sports is unchecked reading is unchecked
457:32 - and music is also unchecked
457:34 - and then again the spouse is checked
457:36 - reading is checked and the music is also
457:38 - checked
457:39 - the music is checked because the value
457:41 - of
457:42 - is enabled is true
457:44 - okay and i have given the condition over
457:46 - here as both 3 is equal equal to 3 so
457:49 - boot 3 is equal equal to true so that's
457:51 - the reason why it's clicking the music
457:52 - element
457:55 - so here we have learned how to handle
457:57 - the check boxes and here we have learned
457:59 - how to validate these check boxes okay
458:02 - so uh this is it for this video i hope
458:05 - that you learned something new so try
458:07 - these programs on your own and if you
458:09 - face any problem you can check out the
458:11 - uh github link that is given in the
458:13 - description
458:15 - uh also if you have any questions or any
458:17 - feedback use the comment section below
458:19 - in the

Cleaned transcript:

in this tutorial we will learn about the selenium the selenium framework why is it called as a framework and what are its advantages and disadvantages and its components so let's get started now here as an automation tool we will be studying the selenium webdriver for this you need to have some prior knowledge about the java and i have also explained what are the requirements of an automation tester i will give the link in the description box so when you go for an interview as an automation tester the very first question that comes to you is what is selenium see this is very important before mastering your skills in selenium you need to know what is selenium is at components as advantages and disadvantages and what are the different types of frameworks so we will be studying about selenium today so first let us understand what is selenium selenium is a portable framework for testing web applications now here there are three terms to understand in this definition one is portable second is framework third is web application now what is portable portable in general uh it means to be easily transported or relocated that is the meaning of portable now what is framework framework we can divide the word framework into two parts frame plus work that is if we work in a frame like here you can see this house right this is a house frame or a basic structure or a supporting structure with the help of this structure we will be able to build a house so this is a framework so framework just gives us the basic structure which will uh add our code for greater functionality of the system now you must be thinking why do we use framework we use framework for reusability and we don't need to build things from scratch like suppose let us take up an example if you are making a dynamic web page and what will you do you will create folders like suppose index.html then style.css validate.php and etc see the problem here is not that you have to create folders but the problem is that you have to follow the same process again and again but if you use a framework we don't have to worry about that you just need to code your logic and that's it so that's framework framework just gives us the basic structure round which we will add our code for greater functionality of the system okay that's framework next we have web applications now there are basically three types of applications webbased application desktop application and mobile applications webbased applications are applications that can be accessed through browsers that is like the online forms the registration forms those are online based applications then we have the desktop application the desktop applications are the applications in which we we install in the local system for example the microsoft word excel powerpoint that's your desktop application mobile applications are application we install our mobile in our mobile through a play store we download some apps like whatsapp flipkart amazon those are mobile applications now selenium is a portable framework for testing only web applications selenium tests only web applications that is the application that can be accessed through browsers this also serves as a limitation but we will discuss that later so moving forward why selenium first thing we will choose linear because of cost selenium is free it is open source as compared to the other tools like qtp and uft they are a paid the second point is flexibility selenium supports multiple programming languages like java c sharp python ruby and many more whereas if you go to some other tool like qtp it supports only vbscript next is the multiple browsers selenium supports multiple browsers like chrome firefox safari and many more whereas if you take qtp as a selenium tool it supports only chrome it also supports multiple os like windows linux apple and many more the main important point is that why are we using selenium because it supports parallel testing now let me tell you what is parallel testing the browser will execute the commands in two ways one is the parallel execution second is the cross browser execution now here you see on the screen parallel execution let us understand that first parallel executions are execution in which the test scripts opens all the browser at the same time and executes at the same time it's called as parallel execution here you can see there's a test scripts then you can see there are three browsers over here the first one is chrome the second is the firefox the third is the internet explorer so the test script will open all the browser at the same time and executed at the same time this is parallel execution we will explain i will explain it with an example just wait first understand what is cross browser execution cross browser execution let us take up an example like suppose uh in the test script over here it is written to insert some value in the drop down menu so this command will be first executed in the chrome browser when the execution is finished that is when the value is inserted in the drop down menu then the firefox browser will be open and the command to insert the value in the drop down box will be executed and when that command is executed then the internet explorer will be opened and the command will be executed so this is called cross browser execution that means the test script will open the brow chrome browser first after two three minutes when the execution is done it opens the firefox browser and then after some time it will open the internet explorer browser this is cross browse execution cross browser execution whereas in parallel execution if we have the same command to insert some value in the drop down menu then this command will be executed in all the browsers at the same time this is parallel execution and selenium supports parallel execution now let's move a little deeper towards the selenium uh we will study the selenium components which come prices of the selenium suite total we have the four components like the ide rc web driver and grid let us discuss ide first now the selenium ide is the most simplest tool in the entire suites of selenium it is nothing but an integrated development environment see earlier this ide was simply just a firefox extension and it's just a play around tool like you know you just play record functionality mainly it is useful prototyping and it is used only for demo purposes you cannot use ide for creating automation realtime projects because of its some limitations we will discuss those limitations later then the next component is the rc that is the selenium remote control it is used to write web application test in different programming languages it interacts with the browser with the help of the rc server through which we can interact to the web browser but this rc server got deprecated in the selenium version 2 and was replaced by the web driver in the selenium version 3. we will discuss that also why it happened the next component is the selenium web driver the selenium web driver is one of the most important component in the selenium suites it is an api to create and execute the test cases and it is a successor of rc basically the selenium web driver is a collection of open source api and which will be used to automate the testing of a web application as i said we will study the selenium web driver very deeply the next component is grid the selenium grid is used to run multiple test scripts simultaneously on the different browser and platforms and it supports parallel testing what is parallel testing i explained in the previous slide so because of a grid we can selenium supports parallel testing so these are the four components in selenium let us discuss the drawbacks of ide the first drawback selenium id is a mozzarella firefox plugin which means the tests can be recorded only in the firefox browser and not in any other browser second it's not suitable for dynamic web pages because it is just a prototyping tool which works well only with the static web pages and not with the dynamic web pages third data driven testing is not possible fourth cannot provide detailed test reports whereas rc the next version of ide can provide detailed reports then we cannot perform database testing through id same because it is just a prototyping tool it is used for demo and it is not used for automating web applications due to these drawbacks rc came into picture now we have discussed the components of selenium let's see the versions of selenium here we have total four versions selenium version one selenium version two three and four now see here we will dig into some history of the selenium here the selenium version one we have the selenium ide rc plus grid so when jason against introduces selenium the tool was called as a javascript program he called it as a javascript tester but he had one major issue that that is called as the same origin policy so now what is you must be thinking that what is this same origin policy this policy says that when javascript is executed in the domain it can access the web pages in that domain only and it cannot access any other web page in the another domain for example suppose like a web page in the google like if you have a domain google.com okay so you can access the search bar the email the drive but that can be accessible but nothing can be accessible outside the google.com like if you want to access you yahoo uh mantra or amazon or any other domain that cannot be accessible definitely this is because of some security reasons so that is why this is called as a same origin policy now to overcome this policy remote control server was designed that is the selenium rc now the main reason to create the server was to trick the browser in believing that the selenium code in which we are running the scripts and the web application under test are in the same domain now here this same origin policy is solved so this was the version one of selenium where we have the id rc and grid where the same origin policy was solved in the version one then comes the selenium version two here we have the ide the web driver the rc and the grid see in 2007 when this when siemens stewart he invented this web driver now why did he invent this web driver because the architecture of the rc was very complicated and in rc we need a separate server to talk to this like we need a separate server to talk to the browser so what he did is he removed the requirement of the separate server and this is the selenium version 2 where the web driver was introduced now why you must be thinking like why web driver and rc is uh introduced over here in the version 2 because the web driver was in the development phase and they were trying to implement it so that is the reason why we have uh in the selenium version 2 the ide the web driver the rc and the grid so in the selenium version 3 we had the ide web driver and grid here you see that the rc was completely deprecated and we only have the web driver currently we have the selenium version 4 that have many new features this is the new version of selenium 4 and now it is still in development recently there was a version known as alpha version was introduced and this version was mainly introduced because of complete w3c protocol adoption but this change in protocol isn't going to impact any of the user because many major of the browser drivers like the firefox the chrome driver and they all are included in the selenium 3.8 version which we are going to use and i will be also explaining i will be uh explaining some of the features of the selenium fourth version we will do that also like there are many ways to take screenshot in the selenium 4 version there are two to three methods so there are new apis added there are some ways to access the web elements also and there are some of the features that are very new introduced in the selenium version so mainly we will be studying about the selenium webdriver now you must be thinking why selenium webdriver now why are we studying the selenium webdriver for that we need to know the drawbacks of the selenium rc now this is the architecture of the selenium rc this is the main reason why we are studying the web driver so the selenium rc is a test tool that allows you to write automated web applications in various programming languages like java python ruby so let's see the architecture of selenium rc first we need to write the test scripts in supported languages like java python or any other supported language but before writing these test scripts the major requirement in rc is the rc server so first you need to start the rc server before you run a core and this rc server is a separate application this rc uh is uh responsible for receiving the selenius command from your test scripts it interprets them and then reports the result back to the script now i use the word selenius over here now what is the selenius commands they are nothing but the commands that are written in the test scripts are called as silence commands in id and rc they are called as syringes commands now let's look at the browser interaction how the browser interacts the browser interactions happens through the rc server this rc server is a simple http post and http get request to communicate okay it uses the simple http posts and get request to communicate to the browser now how this communication happens this rc server acts like a proxy now you see there is a complete cycle starting from your test script then the rc the rc server injects the javascript in the web browser runs your commands takes back the results sends it to the rc server and then the result is displayed this whole cycle gets repeated for each and every command which is written in the test scripts this is how the test case gets executed in the rc server like the selenium rc tool this is how the whole cycle goes for each and every test scripts now everything was good but why was rc not good enough to run test scripts let me tell you why what are those drawbacks first time taken for execution of command is locker why because there is an additional server rc to so it executes each and every command is executed through the rc so it takes a lot of time for execution the api supported by rc are redundant and confusing because one command means many meaning it has a lot of meaning for one command like suppose there is a command called as click and click at so which one to use it's very confusing for the developers then there is complicated architecture rc consists of an additional server that acts as a middleman also the mobile apps cannot be tested using rc so these are the drawbacks of rc now let's see how does selenium webdriver overcome these drawbacks for this we need to understand the architecture of the webdriver so in the webdriver architecture we have the test scripts the web browser and the web server however we do not have an additional server for communication like the rc server which we saw in the selenium rc which makes the architecture of the web driver very very easy because we don't have an additional server in this as you can see there are direct interactions with the web browser so as an advantage the selenium does not use an additional server and since there is no intermediate server there then the browser is controlled directly from the system due to this direct communication the overall cycle that we saw in the rc server was which was very indirect communication since this indirect communication made the execution very slow so that's why we have the web driver in which the execution is faster than the rc server as you can see the execution time for command is shorter due to the simple architecture now you have seen the architecture of rc and webdriver let's compare the selenium rc and the selenium webdriver let's see in terms of api now rc is less object oriented api now the api and rc is very confusing and redundant for example we have commands like click or click at commands which one to use so it was very confusing for the developers and the direct browsers interpreted different commands also which was very challenging for the developers working on different browsers for different browsers browsers there were different commands so it was very challenging whereas for selenium webdriver it is very simpler api and it is very easier to use for example we have the click function to click on the web element we have the send key command to send text on very on any web element in the web page so it has a very simpler api now let's see in terms of speed selenium rc is slow in execution and in terms of speed web driver is faster in execution because in selenium rc we have the rc server whereas in web driver there is no additional server next let's let's see in terms of browser support see rc and webdriver supports multiple browser but rc does not have support for html unit which is a headless browser now let's see what is this headless browser headless browser is a browser which does not have a ui this helps to make testing more faster because it does not need a real browser for testing it does not take time to load the web elements so and the headless browser is very quick so rc and webdriver the support multiple browser but rc does not support html unit that is the headless browser whereas the web driver supports the headless browser and it is and it makes the execution move faster next we have the uh comparison in terms of testing mobile applications selenium rc does not support testing of mobile applications whereas web driver selenium web driver it supports testing of mobile application there is an application name as apm through which we can test mobile applications so these were the difference between the rc and the web driver but every component has its own drawbacks so let us see the drawbacks of webdriver one cannot readily support new browsers but rc can and it does not have a builtin command for automatic generation of test results see uh it cannot readily support new browsers there are many new versions coming up so this challenge can be overcome second we don't have builtin commands for automatic generation of test results whereas in rc we have we can generate test results there's a proper format in rc whereas in web driver we don't but we can use a thirdparty tool we can integrate thirdparty tools for the test results generation so now we will discuss some advantages and disadvantages of selenium advantages of selenium selenium is an open source tool and it supports multiple operating system and multiple browsers like chrome safari internet explorer and many more it also supports multiple programming languages like java python c ruby etc apart from all this we can also integrate the third party tools in selenium like apache poi auto i t sql and why do we need to integrate this we will understand that in the next slide here you see the disadvantages of selenium the first disadvantage is that it cannot support windowbased application it can only support the webbased application but to overcome this disadvantage we can use a third party tool that is the auto id or the sql tool the second is that it cannot support test reports but if we integrate test ng or extend reports through that we can generate test reports third cannot support excel files now you must be thinking why do we use excel files we use excel files while we doing uh while we are doing the uh data driven testing we use it because suppose there is a username and a password field and there are many test data to it like for user name you have the admin for password you have admin at the rate one two three that's one test data the second test data third fourth so like this there can be many test data to check the expected and the output result we will match it and then we will pass the status as fail or pass so matching those and results and communicating the test scripts to the excel files that selenium cannot support that but through apache pui we can do it next we have less or no technical support in selenium because selenium is an open source tool so there is very less or technical support but there are many forums and communities on internet whereas wherever you can uh write your queries and you can get your answers then writing test cases are sometimes very time consuming because it is just a programming interface and not an ide see whereas if you go in other tools like the qtp and uft though those are id as well as the programming interface that means you can record also you can record also the test scripts that you have written whereas over here it is just a programming interface each and every command needs to be written so at times it becomes very time consuming so these are the disadvantages of selenium till now we have learnt uh what is selenium why is it called as a framework we have learned the versions of selenium their components that drawbacks and why are we starting the web driver we have also learned what are the advantages and disadvantages so in the next tutorial in the next video we will learn the installation part of selenium and then we will start the implementation of selenium we are going to install the intellij idea ide and some drivers and jar files for selenium framework so let's get started so the first thing that you need to do is go to google and type intellij idea and here you see the first link that we have that is www.jetbrains.com simply just click on this link so this is the official website of the intellij idea ide so the intellij idea is an integrated development environment that is the ide written in java for developing computer software and it was developed by the jet brains apart from all this the intellij idea ide has many features like builtin tools then we then it supports the jvm languages like the java kotlin scala and it also has some frameworks like spring java double e and it also supports mobile development and some of the web development like the html css angular typescript javascript so these are some of the features of the intellij idea ide and in terms of system requirement we will need a ram of 2gb minimum and the disk space that we require is of 3gb of space we also need to install the java jdk first and then we will install the intellij idea ide so let's install the java jdk first all you need to do is just type java jdk download and the first link that you get is the www.oracle.com just click on this link and here you see there are different versions of jdk like we have the java sc 15 we have the java se14 and java s11 we will download the latest version that is the java sc50 click on jdk download and click on this windows x64 installer this one if you're using the mac os then click on this one but i'm using windows so i'll be clicking on jdk 15 windows now here you must accept the license agreement for java oracle sc which says that i reviewed and accept the oracle technology network license agreement for java oracle se simply just click on this check box and click on download jdk 50. so now here you can see that my jdk 15 has been downloaded so let's install this simply just click on it click on next and your jdk will be installed in this file so just let it be that way just click on next and yeah it's installing now it might take some time so now you can see that my java jdk 15 has been successfully installed so let's check this out simply just click on close and over here just click cmd let's see if this has installed or not properly in our computer so we will check it through command prompt simply just type java space dash version so here you can see that we can see that we have downloaded our java jdk version 15. so once we have installed our jdk we have to set the environment variables all we need to do is just go here and write environment variable and here you can see edit the system environment variable click on this here you can see in the advanced tab there is environment variable click over here and in system variables go to path click edit and here we will edit the path how you gonna do that just simply go where you have installed your jdk that is c drive program files java jdk bin folder open your bin folder copy this path and place it over here and click on ok ok and over here also ok so you have set your environment variable path also now you will install the intellij idea id simply uh just go to the official website of the intellij idea ide and click on download over here so there are two versions over here ultimate in community we will download the community version click on download here you can see that it started downloading it might take some time so just wait now i have download the intellij idea ide the community version here you can see now let's install it simply just click it click on run click next next now over here uh create desktop shortcut yes for the 64bit launcher and update context menu i'll click this check box create associations for now i don't want to create any association then update path variable restart needed yes i will add the launcher to the path i'll click this checkbox as well and then click on next click on install and here you can see that the intellij idea ide is getting installed now here you can see that my intellij idea community version has been installed so i'll just click on this simply click on new project then here uh just click on java and here you can see that the java version 15. this is the jdk that we have installed before simply just click on next create project from template i'll just name it as hello and finish i'll just change the interface of this ide all we need to do is simply just go to file go to settings and here in the appearance bar just change the theme to intellij light so this is how you can do it now let's run a program saying hello world simply just write s out and here you can see we have the system out.println so this intellij idea ide has a feature of autocompleting also just simply by writing s out it will be system.out.println and i'll write hello everyone i'll save it and i'll click on this button so here you can see the output that's hello everyone that's what i printed over here so our program has been successfully executed so this is all about the intellij idea id so now we have installed the intellij idea ide and the java jdk also so we will install some of the drivers and the java files that we require in the selenium so all you need to do is just you need to go to this official page of the selenium is selenium hq i will give all the links in the description box so it will be easier for you click on this link that is a selenium.div and go to downloads this is the official website of selenium and we will download all our drivers and jar files from this website only now here first we will download some of the selenium client and web driver language bindings now selenium supports many languages like ruby java python c we will be working on java you will be working with java so in order to create scripts of selenium webdriver you need to make use of language specific line drivers so these are the drivers of java see here there are some of the versions that i have told before as well there's a stable version that is a 3.141 and the alpha version that is recently released i have discussed about the versions of selenium in the previous videos you can check out that for now uh to download these jar files we will click over here download and here you can see a zip file has been downloaded here you can see that it is downloaded simply click on this file just extract it and here you can see now see i would recommend you to make a separate folder for java files so it will be very easy and beneficial for you because we will be downloading many java files and drivers so it will be very confusing and here we will be giving the paths also in the program when we execute our test cases so it will be very difficult that which driver is placed where so it's better that you would make a separate folder for those drivers and jar files so here in d drive i'm making a separate folder named selenium jar and drivers okay so i'll be placing all my jar files and drivers in this file all i need to do is those files which i had downloaded here you can see that this is jar file this is executable jar files these two jar files i'll copy first and place it over here then the next i'll go in lips folder and over here all these jar files i will copy it and place it here okay so these are the java files which we downloaded now we will add all these jar files in the intellij idea ide so now we will add the jar files so simply just go on file go to project structure go to modules and go to the dependency tab you can see here add sign this plus sign click on this click on jar or directories then go to the file where your jar files are placed so here you can see all these jar files which i have pasted in the selenium jar and drivers just click all of them and add it click on ok and here you can see the jar file is added click on apply and click on ok just wait for a second here you can see indexing dependencies just wait for it so here you can see now those jar files are added so now we have installed the uh jdk we have set the path for it and then we have installed the intellij idea ide and we have added the jar files also so now let's install the drivers just go to the official website of selenium that is will be selenium.dave click on this and click on downloads so here you can see platform supported by selenium browsers now for various browsers we have various drivers for firefox we have the gecko driver we for the chrome we have the chrome driver for safari we have the safari driver so mainly i will be performing operations using the chrome driver so first we will download the chrome driver for chrome just simply before downloading open your chrome and be careful about the versions of chrome firefox and internet explorer you can do that by just going over here and click on settings click on about chrome and here you can see my version is 85.0.4183.121 so i'll be installing the driver of this version only be very careful with your drivers because if you're uh having an old version of google chrome and you're downloading a driver of a different version so it won't work so it's better check out your version first update it and then download an updated driver so i'll just simply go and write your download chrome driver for 85.0.4183.21 and here you can see i'll give the links in the description box so it'll be very easier for you to download see here the chrome driver for the latest is 86.0 but the latest version that is the stable version that i'm having is 85.0.4183 so i'll be downloading this version now if you're having linux then click this one if you're having mac then click this one and if you're having windows then click this one i'm having windows so i'll be clicking chrome driver underscore windows 32 zip folder and here you can see it has downloaded so here you can see this chrome driver it is a zip file i will extract it just simply click on extract all and it will start extracting it and here it is it is chrome driver all you need to do is just copy this driver and paste it the copy this driver and paste it in your folder that you have made so i have made different folders over here like for chrome driver firefox driver ie drivers and the jar files keep things making programs while implementing the selenium framework when you are implementing it we need to add many java files we need to have many drivers also so if you keep things very systematic it will be very easier for you so here for chrome driver i have added this now let's go and install the firefox driver simply just go on firefox again check your version you don't need to do anything just click on settings and go to general and here you can see my version is 81.0 so i'll be downloading the driver for version 81.0 just type download firefox driver for version 81.0 so here you can see the gecko driver and here you can see it's downloading it so here this is the driver for the firefox i will extract it and here it is again i will copy it and paste it over here in firefox driver so today we're going to install the intellij idea ide and some drivers and java files for selenium framework on windows 10. so let's get started so open your google and type intellij idea ide the very first link that we see is the www.jetbrains.com so click on this link the intellij idea is an integrated development environment that is the ide which is written in java for developing the computer software and it was developed by the jet trains now apart from all this intellij idea id also has features like we have the builtin tools we have the jvm languages like java kotlin scala groovy and also it supports some of the frameworks like the spring java double e and it's supposed to mobile development and web development as well like the html css angular node.js so these are some of the features of intellij idea id in terms of system requirement we need a ram of 2gb minimum and disk space that we require is of 3gb of space and also before installing the intellij idea ide we have to install the jdk first so what we need to do is first type jdk download now i haven't installed the jdk i'll show you go to cmd and i'll type java space dash version here you can see i haven't installed my jdk it says that java is not recognized as an internal or external command or operable program or batch file i will run this command again after installing my jdk so i'll close this and here you see we have the www.oracle.com on this link and we have different versions of java jdk we have the java sc 15 we have the java sc 14 and we have the java s11 we're going to download the latest one click on jdk download now uh if you have mac os if you're using mac os you can install installer you can click this one and if you're using windows then you can click this one so i'll i'm using windows so i click this file now here you must accept the license agreement for oracle java se which says i reviewed and accept the oracle technology network license agreement for oracle java se you have to simply just click on this check box and click on download jdk 15. so now you can see that my java jdk has been downloaded so all i'll need to do is i'll just click on this so click on next so this is the place where your java jdk will be saved let it be this way and click on next and here you can see that it is getting installed it will take some time so wait for it so here you can see that my java sc development kit 15 has been successfully installed so i'll click close and here i'll type cmd again just simply type java space dash version and here you can see java version 15 java sc runtime build 15 is been installed this shows that you have successfully installed your java jdk 15 and if it's not coming this way and if you type this command and this is not the output of it uh you need to go through the steps again and install it again so now we have uh installed our java jdk on on our system so we're going to set the environment variable simply just type environment variable and here you can see edit the system environment variable click on this here you can see environment variable right click on environment variable here you'll see system variables in this system variable window click on path and click edit so click on new and here we're going to enter the part how we're going to do it so just go on c drive on c drive go to program files and here you can see java go to java go to jdk 15 go to the bin folder and copy this path and paste it over here so this is going to be the new system environment variable click ok and click ok and click ok so you have set your environment variables as well so we can install the intellij idea ide now simply go to the official website of intellij idea ide and go to download here we have two versions the ultimate version and the community version and if you're using windows go to windows and if you're using mac then click on mac and if you're using linux then click on linux so i'm i'm using windows so i'll be clicking on windows and we're going to download the community version simply just click on download and here you can see that my intellij idea become ide the community version is getting downloaded so now you can see that my intellij idea the community version has been downloaded so click on this click on next click next so here uh create desktop shortcut yes for the 64bit and update context menu i'll click add open folder as a project then create associations i don't want to create any associations for now then update path variable that is the restart needed and add launchers did to the path i click on this checkbox as well and i'll click next then i click on install and here you can see that the intellij idea ide the community version is getting installed and just click on finish so here you can see so here you can see that the intellij idea id the community version has been installed and i have created a shortcut desktop icon over here so i'll just click on this and i'll click i confirm that i have read and accepted the terms of this user agreement and i click continue data sharing i'll just click don't sign i don't want to share data sharing so this is the ui theme i'll click the light one go to next just go to next or next okay so click on new project here click on java and here you can see that we have the java version 15 because you have downloaded the jdk so it will be visible here and if you have not downloaded the jdk it will show that a link to download jdk like here you can say see over here download jdk so i have downloaded so it's showing 15 java version 15 has been downloaded jdk just click on next uh create project from template click next so i'll just write hello world so let's run a program over here i'll simply write s out and here you can see like if i write s out a system out dot println so this intellij idea id has a very cool feature of auto completing it like if i write s out it's in system order printer n and there are many more shortcuts to this we will learn as and on we keep on programming we'll keep learning it so i'll just write hello world and i'll click on this button that is the run main click on it and here you can see here it's hello world so we have installed the java jdk we have set the variable path also and then we have installed the intellij idea ide and we executed a program and it's successfully executed so we're done with the installation of the jdk and the intellij idea id now we have to install java files and some of the drivers that we require for the browsers for the selenium framework so all we need to do is just go to the official web page of selenium that is the selenium hq here you see we have the www.selenium.dev click on this click on downloads and here we have the selenium client and web driver language bindings see to create webdriver selenium web driver scripts you need to make use of language specific client drivers now as we know selenium supports many languages like ruby java python csharp and javascript so it for every language we have the specific client drivers for ruby we have some client drivers for java we have some client drivers so we'll be using uh java we'll be doing selenium with java so here you can see we have a stable version for java is 3.141.59 the latest release that we have the alpha release for i have discussed about the selenium versions also in the previous tutorials so you can check out that so we're going to do with java selenium with java so simply click on download so here you can see we have this zip file of selenium java i'm going to extract it and here we have the executable jar files so it is recommended that you create a separate folder for the selenium jar files and the drivers so i'll be creating a separate folder of jar files and drivers just created on any drive like c drive or d drive or somewhere because we're going to download many jar files and many drivers so locating them and it will be placed in somewhere and then locating them and finding them at that point of time will be very hard so just simply make a folder over here i'll be naming selenium jars and drivers a folder in selenium jars and drivers i'll name it jars and i'll create a separate folder also name it drivers and in drivers we're going to install the chrome driver and the firefox driver so we'll make the folders for that as well let's make things very systematic because if you don't do it then it will be very problematic so these this way we have created a new folder in rd drive that is the selenium jars and drivers so we have downloaded jar files let's check that out we have the first two java files over here we're gonna copy it and place it over here then again over here go to libs and we have the jar files here also so we're going to copy it here and here it is so we're going to add these java files now to our id so just create a new project for selenium java next next i'll name it as selenium i'll change the package name to selenium and i'll click finish so here it is now we're going to add the jar files that we have downloaded simply go on file go to project structure must accept okay just click on accept and go to modules here you can see dependency tab called dependency and here you can see there's a plus sign right so click on this plus sign and here you see jars or directories click on jars or directories go to the drive where you have created your folder i've created a d drive and i have named as selenium jars and drivers for jars and select all those jars that you have downloaded and simply just click ok so here you can see that i have added my java file over here so just click on apply click ok so here you can see that i can see all my java files over here in external libraries okay so we have added the java files also so now let's download the drivers so what i need to do is same on selenium hq just go down and here you can see platforms supported by selenium browsers click on browsers and for different browsers we have different drivers like for firefox we have the gecko driver for internet expert we have the internet explorer driver for safari we have a safari driver for chrome we have the chrome driver so basically we will perform all our test cases in chrome driver we're going to launch the chrome driver frequently but in the next tutorial i will explain how to launch drivers like the firefox driver the chrome driver so for that we need to download the drivers for it so all we need to do is just click on documentation over here and here you can see the latest better version that we have is the chrome driver 86 and the stable version that we have the 85 now see over here you need to check your chrome browser version first so what you need to do is go on settings and go to about chrome and here you can see your version it's version 85 and if it is not updated then please update it and then download your driver because your driver version and your google browser this chrome browser should match and if it's not matching and then your browser will not be launched so here i have the stable version that is the 85 version so i'll be clicking over here and here you can see this page if you have linux click over here if you have mac click on this link and if you have windows then click on this link i'm having windows so i'll be clicking on this link here you can see this is the chrome driver this is the zip file i will extract it i have the exe file over here copy this file and paste it in the folder that you have created in chrome driver same way we're going to download the firefox driver go to documentation here we have different versions of gecko world driver so what you're going to do is just go to firefox and check out the version that you have simply go on settings or general and here you will see that you your updated version that is the version 81 i'm having 81.0.1 so my firefox is updated so i'm going to download the version 81. just go on gecko driver release and here you will see the driver versions now i'm having windows 64 64bit so i'll be clicking this and if you have mac then click this and if you have linux so depending upon your operating system just click so here you can see we have the gecko driver it's a zip folder so we're going to extract files and here you can see it is an exe application we're going to simply copy it and paste it to the folder where you have created your drivers folder in firefox driver so today we are going to understand uh many topics like first we are going to create two sets of test cases we will learn how to launch the browser next we will learn how to navigate to a particular url we will understand the hierarchy of the interfaces and the classes in the selenium web driver also we will understand a particular command that is the chrome driver driver is equal to new chrome driver why is it not called the best practice okay so let's get started so as we know before automating any test script we have to prepare manual test cases first so first we will create two sets of test cases over here so the first set in the first set we will have three test cases the first test case is open the chrome browser or to launch the chrome browser now whenever we create the manual test cases to open the browser or to launch a browser is the first test case it's always the first test case okay next we're going to navigate navigate to the url that is the www.google.com third the third command is close the browser so these are the three test cases that we're going to execute one is the open the chrome browser that we're going to launch the chrome browser next we're going to navigate to the url www.google.com and the third we're going to close the browser that we are opening okay this is the first set in the second set we're going to launch the firefox browser open the firefox browser next we're going to navigate to the url that is the ww dot next is we're going to close the browser that is the firefox browser okay these are the two sets of test cases that we have prepared and we're going to execute these test cases today as we know uh that the selenium supports many browsers like the firefox browser the chrome browser the internet explorer browser safari browser as we have installed the exe file of the chrome driver and the firefox driver that we have uh installed in the previous lecture so we are going to uh launch the chrome driver and the firefox driver and since the process is very similar so once you understand how to launch a particular browser you can launch any other browser according to your requirement okay open intellij idea ide so in the previous tutorial we had included our jar files in a selenium project we had created a selenium project we included a jar files in that so we're going to continue in that project itself so yeah as we know yeah we have created two sets of test cases uh we are going to execute it how we gonna do that first thing we know for chrome browser the driver that we require is the chrome driver right that we have installed in our computers we have installed the chrome driver and the firefox driver so first we will execute for the chrome driver and then i will execute the test cases for the firefox driver okay for the chrome browser we require the chrome driver so now what we're going to do first the very first step that we are having is the open the chrome browser this is the first step right so how we're going to do that first thing we're going to create the object of chrome chrome driver okay we're going to create the object of chrome driver but how do we refer this chrome driver object we need to understand the hierarchy of the selenium webdriver which has the classes and the interfaces so let's understand that first so this is the diagram that we are having the selenium provides my number of classes and the interfaces and we need to understand the hierarchy of classes and interfaces now to understand this hierarchy we need to have a knowledge about the interfaces and the inheritance concept of java now here here you can see this diagram right uh in selenium web driver the search context the very first interface these yellow boxes are interfaces and the green boxes are the classes okay so this yellow box search context this is the super interface of the web driver and it contains only two methods that is the find element and the fine elements yes these two methods are different it is not just about a s in find elements they are different they are used to find the element on our web page the web elements that we have that is the text box the drop down menu they uh these commands help to find the web elements on the web page so we will understand that when we practically implement the test cases but for now let us understand that the search context this search context that we have is the super interface and is an interface that contains abstract methods now what are these abstract methods these methods are the these abstract methods are the methods that has no implementation they have only definition there is no implementation of abstract methods they just have the definition okay so this is the search context that is the super interface which has the abstract method find element and the find elements next we have the web driver interface okay the web driver interface which is extended from the search context okay it is extended from the search context this means that it contains the methods the abstract methods of find element and find elements method is also in the web driver apart from this it also has the other methods like the get method the quit method close get window handles and many other methods okay so the all these are abstract methods that has only body and there is no implementation okay and so these are the uh topmost root uh interface apart from all apart from this the web driver also has the nested interface okay it also has some nested interfaces like which has windows navigation target locator timers option these are also abstract methods through these methods the through these interfaces we can perform various uh operations like navigating to the url maximizing the window and many more okay so the uh the web driver also includes the nested interfaces next we have the remote web driver this is a fully implemented class okay which implements the interface web driver here you can see it implements the web driver interface okay now this web driver or remote web driver this remote web driver is a fully implemented class here you can see it's a fully implemented class where all the abstract methods coming from the search context coming from the search context and the web driver are implemented in this particular class because obviously when we create abstract classes right so these uh when we create abstract methods we have to use those methods we just you just don't have to keep it you will use it that is why there is no implementation and only definition in it as i said your core java knowledge will be required over here to understand this hierarchy so that is why we need to have the knowledge of inheritance and uh interface faces of core java so the remote web driver yeah so the remote web driver contains methods of the search context and the web driver in addition also it implements a javascript executor and takes screenshot okay so it uh implements these interfaces also which has abstract methods on its own and we will we can implement those extract extract methods so to the conclusion we can say that the remote webdriver is a fully implemented class which contains the abstract methods of the web driver interface and the search context interface and it takes screenshot interface and the javascript executor okay so this is about the remote web driver now here you can see these classes these classes are the uh browsers that we have of selenium selenium supports many browsers you know right the firefox browser the internet explorer browser the edge browser safari browser so the remote web driver it extends these classes and here you can see these classes are the web browsers that we have that is the firefox browser internet explorer browsers okay so now uh there are various versions of selenium as i told in the previous tutorial from fourth version here you can see this is the chromium driver and chrome driver right from the four fourth version the chrome driver extends the chromium driver this has happened from the fourth version they had made some changes they had included a chromium driver also which uh through which the chrome driver will get extended so these were the changes in the fourth uh release of selenium so this is the hierarchy of selenium cluster interface in which we have the uh super interface that is the search context then we have the web driver interface which has which includes uh nested interfaces also which has many abstract methods like windows navigation target locator timeouts options then we have the remote web driver which implements the interface webdriver and it also implements the javascript executor and the take screenshot interface next we have the um next we have the browsers these are the browsers which is supported by the selenium and the remote web driver extend these classes these are classes okay remember the remote web driver and these browser are the classes whereas the search context web driver nested interfaces take screenshot and javascript executor are the interfaces okay this so this is the complete hierarchy of the selenium class and the interface so now let's move to the program so now over here uh for opening the chrome browser the first thing that we did over here is we created a object of chrome driver right now how do we refer this object here in the so remember this chrome driver is a class right as we as shown in the hierarchy it is a class now here just refer to this hierarchy again and here we can see that the web driver is the parent interface here you can see that the web driver is the parent interface and now you must be saying no the remote driver the remote web driver is the parent but whatever talking about i'm talking about the interface focus on what i'm saying i'm talking about interface the web driver is the parent interface and the remote web driver is a class okay remote web driver is a class and the web driver is an interface so your the parent interface will be web driver so the web driver interface will give a reference to the chrome driver how i'm going to write webdriver i will give a reference like driver is equal to new chrome driver so now uh your in this command web driver driver is equal to new chrome driver we are using uh the dynamic polymorphism concept in which the child class object child loss object that is the chrome driver is referred by the parent interface that is the web driver through a reference variable and that reference variable is called as driver okay so this is how we are opening the chrome browser so let's run this command first so our chrome browser is not launched why let's see here it shows an error which says illegal state except exception which says the path to the driver executable must be set by the webdriver.chrome.driver system property okay this is your error the path to the driver executable must be set by the web driver dot chrome dot driver system property so here it says that i have to define a property a system property and to define this system property we have a system class so i will write system dot set property now this set property command has two values need to be entered over here uh one is the string key and is the string value in the string key what we have to enter it's given over here itself webdriver.chrome.driver we will simply copy this and paste it over here this is your string key whereas the value will be the part where your executable file is saved that is the chrome driver so in my case i'll go to d drive syrian jars and drivers drivers and the chrome driver because we're launching the chrome driver so i will simply just copy this part and i will paste it over you change the slashes okay and we're gonna include our file name over here our file name is chrome driver okay so we're gonna write chrome driver dot exe now if you're using mac you don't need to write exe because mac does not support exe files so there's no requirement to write exe but if you're using windows then you're going to write exe okay we're going to execute this statement now so here you can see my chrome browser is launched you can see this chrome browser it is launched which says chrome is being controlled by automated test software now this chrome browser and this chrome browser the original chrome browser these two chrome browsers are different here we cannot see any tab which shows that chrome browser is being controlled but over here you can see chrome is being controlled by automated test software there's a tab over here okay so this is the difference between the uh chrome browser that we are launching through automation and the chrome browser that we have originally on our computers so i'll just close this so we have launched the chrome browser and yes one important question that you must be thinking is uh by looking at this uh diagram now over here you must be thinking as i said that the parent interface is the web driver but you're the super parent interface that is the search context is also there so why are we not writing a search context driver like i'll just write driver1 equal to new chrome driver now this command is also correct i'm not saying that this command is wrong but why are we not writing search context driver is equal to new chrome driver and why are we writing web driver driver is equal to new chrome driver the reason behind this is refer add this diagram again here i have uh told before that the search context interface contains only two methods that is the find element and the fine elements so if we are writing search context driver 1 is equal to new chrome driver it will only have two abstract classes or sorry two abstract methods that is the find element and the fine elements whereas if i'm writing web driver it has all those methods like the fine element and the fine elements also and all the web driver methods as well so that is the reason why we are writing web driver driver is equal to new chrome driver okay so now the next question that you must be thinking is okay we are fine with the search context we are not uh there's no advantage in writing search context because it will have only two methods included in it uh that is a find element in the find elements so why not remote why not remote web driver like we can write remote web driver driver sequel to new chrome driver this is also possible but the reason behind why we're not writing remote webdriver is because the remote webdriver mechanism the architecture of the remote web driver is very different from the web driver here there are two reasons okay if we want to use this approach the remote web driver driver 3 is equal to new chrome driver if you're using this approach then this approach is only accessible when we want to access in remote location see here the remote web driver works very different from the web driver and it also the remote web driver is a class always remember there's a difference between a class and an interface okay so class and it contains methods which shows that which what action is to be performed that is remote web driver whereas interface it contains the abstract method so the remote web driver is not serving as advantages as the web driver that we have included over here so it is the best practice is to include the web driver driver is equal to new chrome driver okay so i'll delete this command and yeah through system.set property uh we have a key value we have entered the string value over here that is the webdriver.chrome.driver and here we have entered the path of our executable chrome driver next we have written web driver driver is equal to new chrome driver through these two steps the chrome browser is launched now remember these two steps are common for all the test cases we are going to write because in every test case we are going to launch a browser so these two steps are going to be similar okay so the next test case the next test case that we have is navigate to the url okay how are you going to do that now we have driver as a reference variable we're going to write driver dot get and we're going to include the site where we want to navigate that is www.google.com this is the site i want to navigate to i'm going to run this command the chrome browser is launched but it has not navigated to the url why let's see so here it says chrome browser chrome driver was started successfully and here it says invalid argument exception there is invalid argument why let me tell you here when we write the url you need to write the complete url which includes https colon and slash now let's see so our chrome browser is launched and here it is it is navigated to the url that is the google.com okay i'll just close this i'll close this as well okay so now you have understood to navigate your url we will write driver dot get the get command is used to navigate to the url okay so the third test case is to close the browser how are we going to do that we're going to simply write driver dot close the close command is used to close the browser save it and run so your our chrome browser is launched and it is navigated to the url and it is closed see it happens very fast but uh yeah this is the process like we have launched the chrome browser we have navigated to the url and we have closed the browser to navigate the url we are using the get command and to close the browser we are using the close command so these were the steps to launch the browser to navigate to the url and to close the browser now let's execute the second test set which has the firefox browser which in which we have to launch the firefox browser so i'll comment all these and we're going to launch the firefox first okay there is no harm if we write both the browsers there's no harm it will execute the chrome browser first and then it will execute the firefox browser first we will do that also but first let us execute this particularly okay so in the next set of test cases here it is we have open the firefox browser navigate to the url and close the browser the only difference is that we are working with the firefox browser over here okay and over here we were working with the chrome browser so let's start first thing the first test case which says that we have to open the firefox browser okay so how we're going to do that obviously we're going to write system dot set property which is having two string values one is key and one is the value okay so over here you can see over here the key value is webdriver.chrome.driver so here it's going to be a web driver dot getco gecko is the driver name for the firefox browser dot driver okay this is the key now we will enter the value how we're going to do that we're going to go to the path where our firefox driver is saved here it is i'm going to copy this path i'm going to simply paste it over here we will change the slashes and we are going to include the file name so our file name is getco driver gecko driver dot exe okay and next command our next command is that we're going to create an object of firefox first and how we're going to refer it we are going to refer it by the web driver interface web driver driver is equal to new firefox okay next we need to navigate to the url how we're gonna do that navigate to the url we're gonna simply write driver dot get https we need to write https colon www.google.com okay now the third command is to close the browser how we're gonna do it we simply write driver dot close okay so let's launch it let's run this program we'll click on this and here it is our firefox is launched it is navigated and it's closed yes so as i said there's no harm like simply i will uncomment all these i'll name this as driver one driver one and driver one okay so let's execute this statement it will open the chrome driver first yes it is opening the chrome driver first it is navigating and it is closing now our firefox will be opened yes it is navigating and it is closed so there is no harm if you are including two browsers in one program there is no harm in that okay just change the reference variable your i have changed the reference variable to driver 1 and driver now since we have executed these two sets of test cases now let me explain you this command now here we have written web driver driver is equal to new firefox driver we can also write firefox driver dr1 is equal to new firefox driver this command is also valid okay it's there's no harm in writing firefox driver dr1 is equal to new firefox driver but what are the disadvantages behind this statement i'll tell you now see when you're working in an organization you are working with many people you will be having at least 500 number of test case cases and out of which 250 test cases are need to be automated so there are large number of test cases which are need to be automated in that you will be supporting the cross browser testing so you have to simultaneously uh run a multiple browsers at the same time okay and then a large number of test cases now see the advantage behind writing webdriver driver is equal to new firefox driver your you are not stick to one browser you can execute multiple browsers this way but whereas if we write firefox driver driver one is equal to a new firefox driver here we are stick to one driver it is um we are specific towards the driver that is the firefox driver here if you want to change to chrome driver it will be you have to write chrome driver dr2 is equal to new this is what you have to write if you want to change to chrome driver and you have to comment this line and even have you have to change there will be many other changes also in the program because of a driver okay so this thing is very harmful it is not a good practice of writing this command that is the firefox driver driver is equal to new firefox driver whereas when if you if you're working with this and there is a situation where you have to change to chrome driver you have to simply just change over your chrome driver you will just write chrome driver and your entire program will be launched through a chrome driver okay so this is the difference between the web driver driver is equal to new chrome driver and the chrome driver driver is equal to new chrome driver these are the problems that we are facing if you are writing chrome driver driver is equal to new chrome driver that is the program is specific towards the chrome driver whereas if you are writing web driver driver is equal to new chrome driver it is not specific to us a particular browser okay so let's first rely revise what have we uh understood in this tutorial so what did we learn the first thing that we learnt is to launch the browser in case of chrome browser how did we do first we uh set the property to a system class that is a system.set property in which we are having two string we need to enter two string values that is the string key and the string value in case of chrome driver the string key is the webdriver chrome driver whereas the string value will be the path where our executable file is saved the next statement is that we're going to write web driver driver is equal to new chrome driver through these commands it will launch the chrome browser now in case of firefox browser same we are going to write system.set property but the key value will change that is the webdriver.getcode.driver and also the path where our firefox driver is placed that will also change okay then the next command will be web driver driver is equal to new firefox driver through this command we are launching our firefox browser next we learned how to navigate to a particular url simply we will use driver dot get command the get command is used to navigate to a particular url we have to include the https uh all the website any any url you are entering over here you have to entire the you have to enter the full url the entire url including the https okay then to close the browser we learned how to close the browser that is we are using the close command that is a driver.close command so the next thing the next thing that we learned is about the hierarchy of the classes and the interfaces that is we learned first thing about the search context it is a super interface of the web driver and it has only two methods that is the fine element and the find elements next we learned that the web driver is an interface which extends the search context interface and the web driver has methods like the get method the get title get current url close quit etc that has many methods and also it has the nested interfaces also then the remote web driver is a fully implemented class which implements the web driver interface okay then we have the chrome driver the internet explorer driver the firefox driver opera safari driver all these are child classes of the remote webdriver class and they provide the browser specific implementation of the selenium webdriver so these are the hierarchy of the classes and the interfaces of the selenium webdriver next next we learned that what are the this is this this ppt shows that what are the valid statements that we can write through uh creating an object of chrome driver and how can we refer it now writing web driver driver is equal to new web driver this command is wrong okay this command is wrong we can write web driver driver is equal to new chrome driver new firefox driver new internet explorer driver this is the best practice in industry level we use the web driver driver is equal to new chrome driver this command is frequently cut this command is only used because uh writing this command firefox driver through this it is the program the script that you're writing is specific towards a firefox only it is launching it will launch only the firefox browser whereas over here also it will launch only the firefox driver but there's a situation where you have to change the driver they will they might say that the company says that you have to launch the chrome browser launch the entire test script in the chrome browser so what you're going to do is you just have to simply change over here to chrome driver and you're done but whereas if you're uh writing firefox driver you have to change the entire statement and there will be other statements also that you have to change okay so the best practice is the web driver practice web driver driver is equal to new firefox driver but whereas if you write chrome driver driver is equal to new chrome driver there's no harm in it but the best practice is to write the web driver so this is all for today so in this tutorial we will understand what are web elements what are the different types of web elements we will understand the locators and its types also we will understand the difference between find elements and find element method so let's get started first thing what is web element now anything that is present on the web page is called as a web element for example the text box is a drop down menu the radio button anything that is present on the web page is known as a web element let me show you this site for example for example this is the web page now anything that is present on this web page anything that is this search bar these uh my account link this more link this cart link the search icon anything that is present over here is a web element we have to inspect all these elements like over here if you want to send any command if you want to send any text message on the search bar how are we going to do that we're going to inspect the elements so all these are known as web elements now web elements are basically of two types one is single element the second is the group elements now single element this is the registration page here you can see here you can see these text boxes right so these are single elements why because of we can easily find out a locator to work with this for example we can find it through id we can find out through name so these are the different types of locators that will be used to uh inspect these elements these text boxes this radio button but i'm explaining here what are the different types of web elements so there are two one is the single element the second is the group element single elements are the text boxes because we can identify them very easily through locators through name through class name whereas the drop down menu they are known as group elements because here to identify the drop down menu we will use a locator as well as that we will use a combination of a value or index property now what is this value or index property when we understand how to uh inspect the drop down menu at that time we will come to know that what are the different types of commands that is used to inspect the drop down menu so there is a reason why it is called as a group element so next we have locators now what are locators locators are the way to identify and web element anything that is present on a web page is called as a web element right so how do we identify it for example here you can see right this search box how will you identify the search box how will you send commands to the search box how will you uh click on this icon on the search icon how will you do that for that you need to inspect these elements for that you need to locate these elements so how we gonna do that simply just place your cursor on this element or whichever element you want to inspect just right click it and click on inspect and here you can see see i'm actually placing my mouse on this syntax of search button of this search box and it is highlighting here you can see right it is highlighting so this is the way you can inspect your web element and through these locators we will inspect the element for example here you can see input this input is your tag name it is an element your input has many attributes like we have class we have type we have name we have title so these are the different attributes of input tag so we will be using these attributes as locators to locate these web elements to inspect these web elements okay so now what are locators locators are a way to identify a html element on a web page as we just saw right now now there are different types of locators one is the locator the second is the customized locator under locator we have the id we have the name we have the link text and the partial link text we have the tag name we have the class name whereas in customized locators we have the css selector and the x bar now this xpath is one of the most important locators and it is frequently used by many automation testers because it is one of the most easiest thing and uh we will be using a different uh plugin for this expert that is called the crow path plugin so choosing xpath as a locator will be one of the most easiest locator yeah even though id name and all these are easiest but most of the time peop automation testers they prefer the xpath locator okay so we will do that at the end because there are many uh technical things also in this it is a little hard to understand before that we will understand what is id name link text partial link text tag name class name and css selector and you will have a command on this we will practically implement also this okay so locating by id now uh before proceeding i would recommend you to have a basic knowledge about the html which will be very beneficial for you because we are automating the web pages over here and a web page is made up of html css javascript languages so your html and css will play a lot of role over here in locating the web elements just the basic knowledge and then it's fine okay so now locating by id now id they are unique for each element the id value that we have right is always unique for each element and it is one of the most common way of locating an element and the id are supposed to be unique on a page and that is the reason why id are the most reliable locators like in form of priorities whenever the automation tester tests the application the first thing that they will do is they will try to automate the web element through id because uh id the value of id is always unique for each element so that is the reason why id is one of the most reliable locator and the fastest and the safest locators out of all the locators okay now let us assume this is your text box email address and you want to send some value over here you want to automate this field okay you want to inspect this field you want to send some value over your how you're going to do that and this is the html syntax that you have for this text box so how will we locate this element by id we will simply write driver dot find element here i am using find element and not find elements okay driver dot find element by dot id and here when you inspect this element when you uh right click and inspect on this element here you will get the syntax right over your id is equal to email you will place this value over here now see whatever value you enter here is case sensitive okay whatever is written over here you have to write it over here the same way like over here the email is written in small letters you need to enter your email in small letters only it's case sensitive okay then i will send a form command this is the send key command over use this is a form control which is used over here to send a particular text to this field what i'm doing is send keys abc at the right gmail.com right so i'm sending this email id that is abc at the gmail.com in this text field the text field which is located over here this email so you get it i'm writing driver dot find element by dot id email which i found it over here in the syntax dot send keys abc at the rate gmail.com so this is the way how i'm going to locate the id see we're going to implement it also first just understand this command okay the next one locating by name the next locator is name okay now here same same thing just assume you have a text box which is name uh which is of email address and this is the syntax of it so how we gonna look it by name it's the same same as id but the only difference between name and id is that name locator are not unique for a page like i said for id for each element the id value is unique whereas for name it's not that okay that is the difference between the id and the name so over here you can see right name is equal to from similarly we will write driver dot find element by dot name from dot send keys abc at the rate gmail.com so this is the command which i will use to locate by name locator now let's implement this uh practically i'll just open my intellij idea ide so now i'll create a new java class simply uh i'm having this project name selenium and i'll create a new java class i'll name it as selenium tutorials now here you can see this web page now we will be automating this web page so the task that we have for today is here you can see the search bar so we will be automating this search bar so how we gonna do that we simply gonna click on the search bar and click on inspect and here you can see as my mouse is on the syntax and you can see that the search box is highlighted okay here we have different attributes like the class we have the type we have id we have name so we will be using these attributes to locate this search element one by one okay so let's do it now open your intelligent idea id and create a new class i created a new class in my selenium project that is the selenium tutorials too and in the previous tutorial i explained how to launch a browser we will be launching the chrome browser so here i have written the two commands that were used in launching the chrome browser that is the system dot set property here we have to enter the key value that is the webdriver.chrome.driver and the uh path of the executable file that is the chrome driver executable file next we had written that the web driver driver is equal to new chrome driver so these two commands are used to launch the chrome browser so let's run this okay so your our chrome browser is launched now what i want to do is i want to maximize this chrome browser that is my chrome browser is minimized right now this is what i want so how am i going to do that i'll simply write i'll write driver dot manage dot window dot maximize so this command will maximize the chrome browser now let's see let's run so here you can see my chrome browser got maximized okay then the next command as i said we are going to locate this search box through id and by name okay locators so let's do it by id first let's do it by id locator so first okay sorry uh just before that we have to navigate to the uh url right so first we will navigate to the url we're gonna write driver dot get gonna enter this url and yeah okay so yeah first we launched the chrome browser we maximized the chrome browser then we navigated to the url let's check it first it's launched the chrome browser is launched maximized and it is navigated to this url so i'll just close this now as i said i want to locate this search box this search box through id now here same i'll just place my command click on inspect and your this syntax here you can see right this syntax here you can see id is equal to search underscore query underscore top so this value will be used to locate this search box now how am i going to do that just check it out first okay so what i'm going to do is i'm going to write driver dot find element let's find element and not find elements okay fine element i'm gonna write by dot see here you can see it's by dot tag name id class name css selector so i'm using id id and then i will here insert the value of id that is given over here simply just double click on it copy it and paste it over here okay it is case sensitive so play uh paste the same thing the this this thing this value should be same as the id that is given in that syntax okay now what i want to do is i want to send some command to it so i'll write send keys and i'll simply just type i want to send tshirts chrome browser is launched is maximize it is navigated to this page and here you can see you could see it's your it's written tshirts right we haven't inspected this element this search bar and that's why it's not clicking on this okay we will do that later so now this is the first way of writing driver dot find element by id and dot sign keys okay the second method that you can write this command is let me comment this so i can write driver similarly just the same thing but i'll write it in a different way find element i'll write by dot id okay that's it now what i'm going to do is i'm going to store this in a variable i will name it as search is equal to driver dot fine element by dot id now what i'm doing i'm locating a web element right in java usually when we write we write it as int a is equal to 10 right then we write float b is equal to 10.2 so you're giving some data type to your a and b variables right so here also we will this search element so here also we will write something right so what you're going to do that so what you're going to write simply here you see this search underscore queries underscore talk what is this we are locating a web element right so we are finding a web element on a web page so this search variable will be of what type it will be of web element type so web element search is equal to driver dot find element by dot id search underscore query underscore talk okay now over here you could see i had written dots and key so simply what i'll do is i'll write search dot send keys and i'm gonna write tshirts okay so let's run this command this is the second way of writing this one line command you can write it this way or you can write it this way depends on your choice okay so i'll just run this chrome browser is launched it's maximized is navigated to this url and here it is you can see it's tshirt here the value is sent okay so i'll just close this and close this also okay so i'll just comment this for now this method is better okay next we will do it by name we will locate the search box by name okay so how we gonna do that again we're gonna write driver dot find element by dot name and here you will see we have the value of name just double click it copy it paste it over here and write dot send keys i'll write shorts okay so now let's run this chrome browser is launched it's maximized it is navigated to this url and here you can see okay wait a minute okay i didn't comment this let me comment this okay i'll do it again so i'll click on run the chrome browser is launched it's maximized it's navigated to this url and here you can see it's shorts okay so i'll just close this now we have understood how do we locate by id and how do we look it by name similarly here you can see the your the same way the same way you can write it by name also there's nothing different in it but this is the most precise way you just write it in your in one line here you have to write in two lines is the same thing so i prefer this one so it's up to you which one do you prefer there's no harm in writing either of the way okay so we have learnt by id we have learned by name next we have locating by link text and partial link text now what is link text and partial link text see whenever we have links in our pages okay like there's a web page and there are links involved in this in that case we have the link text and the partial link text now link text and partial link text both are different they are not the same but partial link text is not mostly used by the automation testers link text is mostly used by the testers because this is the most precise way of automating or clicking a link for example like suppose let me show you here this page you can see right now your woman i have dresses now there are various dresses over here so if i want to click on this link here you can see this link so if i want to click on this like how am i going to do i'm just simply going to click inspect and here you can see this you can see there's an anchor tag over here so this anchor tag is used for links in html okay now here you can see is there any class is there any name or id attribute used over here no right so how will you identify this element how will you inspect this element we will inspect this element through link text that is the link text which is written over here you can see women a line multicolor dress you can see this uh text written over here right we're gonna inspect through this text this is the link text that is given over here and the a class which denotes the anchor class uh which is used for links in html okay so for clicking the links in selenium we will be using the link text locator so how are we going to locate this element through link text or partial link text now for example here we have various links like the printed dress the printed summer dress and this is the syntax of this okay so it is a syntax of sprinted summer dress so how we're going to click on this printed summer dress how we're going to click on this link for that we will be using i'll be explaining link text first we'll write driver dot find element by dot link text printed summer dress here you can see this is printed summer dress this link text is used to identify this element here you can see there is printed summer dress this printed summer dress right this text is used to identify this element that is the printed summer dress okay so i just simply write printed some address this is case sensitive to cited the same way and dot click again before we were writing send keys right that is the form command this is also form command which is used to click a specific element or to click a specific link so what operation i need to perform over here i want to click this element right print it somewhere else so i'm going to write dot click similarly for partial link text what you do you partially write the text like over here we have the printed summer dress we'll just write some address still it will detect this printed sum address and it will click at this link okay that's the uh partial link test and the link text now here the partial link text means that we don't need to pass the complete value here you just need to pass a portion of the text like i said you need to pass the portion of the next i have passed some address over here right so through this also it will click at printed some address so let's uh practically do it first or uh just open your intellij id id so i'll just create a different package over here sorry i'll just create a different class over here or link text and partial link text so i'll just write selenium tutorials three okay just click on dresses okay so i'll just copy this and i'll paste this url here okay so now by link text so it's going to be um driver dot fine element by dot link text okay so now here i want um i want to click on this link so how am i gonna do it i'm gonna inspect this element first so i've inspected this element here you can see i have the printed chiffon dress which is written away this is the link text i will copy this and i will paste it over here and simply write click okay so now let's see okay it's launched is maximize it is navigated and here it is selected so here you can see this is printed chiffon dress as i had written a printed chiffon dress dot click so here it's clicked okay now let's try it by partial link text so i'll just simply command this i'll do it by what i'm going to do is i'm going to write driver dot find element by dot partial link text and what i'm going to enter is chiffon dress and i'll click this text okay so now let's run this chrome browser's launch this maximize it is navigating and now it's clicked okay so now you can see through partial link text also my printed chiffon dress this this dress this link is clicked so now we have understood uh id we have understood name then we have understood the partial link text and the link text so next is class name now through class also we can locate our web element for example we have this text box name email address and we have this uh syntax of html syntax now we have the attribute class over here here we have the class attribute form control the value is so how we're going to locate by class simply just write driver dot find element by dot class form control send keys and whatever value you want to send away it's similar to id and name there's no such difference in it but this one thing is that the class name that the value of form control now this value can be of multiple elements on a web page it's not unique whereas the id is a unique uh value right which is given to each element for each element the id value is different whereas for class the value for each element is similar like for multiple elements there must be a class name form control okay so in that case uh many of them don't use class the automation testers they use class uh locator very less as compared to the id and the name so the next locator that we have is the tag name okay now tag name uh are used to find multiple elements on the web page like let me tell you what is tag name like suppose um here you can see right this input this is your tag name this is the tag name here over your input and the attributes are this type name id these are the attributes that is used so tag name are used to find multiple elements on the web page for example suppose suppose this page okay now i want to find the number of links present on this page so how can i do that i'll simply click on inspect i'll find the anchor tags the number of anchor tags present on this page okay through that i can find out the number of links that is present in this page okay so tag name now your tag name like a like here the a the anchor tag is used as a tag name now through this a that is the anchor tag we can locate the uh we can find the number of links present on this page now remember tag name is used when we want to find multiple things like suppose i can now um i if i want to find the number of sliders over here like how many sliders are present so how am i going to do i'm going to inspect the element like under every anchor tag we have the image like suppose for example let me inspect this here yeah you can see under every angle tag we have the image so the source image resource so ah through this anchor tag i can inspect the number of sliders that is there i can inspect these sliders how many sliders are present how many uh through this image tag i can identify how many images are present on this web pages so the tag is used to find multiple elements on the web page now for example it is mostly used like if i want to find the number of sliders if i want to find the number of links on this page if i want to find the number of images on this page so through this i can find the uh number of multiple items or multiple elements on the web page so let's implement that so what i'm going to do is i'm going to let's create a new class java class write selenium tutorials okay so i have created a new java class over here i'll write driver.get and this i'll write inspect this element okay we will inspect this we will try to find the number of links present on this page okay let's see whether this program runs properly or not okay my chrome browser is launched is maximized it is navigated to google.com okay so now um what i want to do is i want to find the number of links that is present on this page okay there are many links like this image gmail and there are links like hindi and the different types of languages so i want to i want to know the number of links that is present on this page so how am i going to do that okay simply i'll use the tag name tags over here so here we will be using by tag name the locator so i'll just simply write driver dot find elements i'll use find elements over here because i have to find multiple elements over here okay by dot tag name and here i'll write which tag do i need to inspect to find the number of links that is present on this page so i will be inspecting the anchor tags that is present on this page right the number of anchor tags i want to know the number of anchor tags that is present on this page so i'll be using a this is the tag name which i want to inspect okay now here i have used elements find elements right so what i'm going to do is i'm going to um write a variable over here link is equal to driver.find elements by dot name tag name now this link is of what type that we need to decide right so how are we gonna do that now here this find elements okay this find elements need to return a list it needs to return a list of elements it needs to return a list of web elements where the elements are this a this anchor tag the links that is present on the web page anything that is present on the web page is known as web elements right so we are uh returning a list of web elements right we need a list of web elements so here we will be using the collections concept that is there in the java in which we have the list that is a java util package and your in list this a tag is what it is identifying what it is identifying a web element right so i'll write a web element so this find element is designed to return back a list of web element which is what is being assigned to the variable link okay whose type is of what list web element okay so now your uh there's a variable link so what i'm gonna do is i'm gonna write s out and link dot size now the size method is used to find the number of uh elements that is present okay number of elements that is present on the web page so this command through link dot size this method this method is used to find the number of elements okay so what i'm going to do is i'm going to save it and let's run chrome browser is launched it's maximized it's navigated and here you will see there are 20 total 27 links present on the web page now what i want is i want the name of these links so how are we going to do that to print those name i'll use the for loop i'm simply going to write for and here we are inspecting the web element so i'll write web element i'll name it as l and your i'll write link s out and i will write l dot get text now the get text method is used to retrieve the or to return the text that is uh inspecting that we are inspecting over here we are inspecting the link right so it will get the text of those links that means i want the name of the links that is uh that they are identifying over here these 27 links right i want the name of these 27 links i'm adding for loop in which i have given a web element l because i'm inspecting a web element that is the links i'm inspecting i'm going to very i've stored it in l and uh here i'm printing those uh links the name of those links okay so i'll just click here my chrome browser is launched it's maximized it's navigated to google.com and here you can see we have the different types of links that is present over here okay so through this way we can find the number of uh links and we can find the name of the links that is present that is we can find we learnt the get text method and the size method over here okay creating by css selector now this css selector this is a type of customized locator now before uh studying the css selector we need to study some css concept so let's have a look at it now for example we have a front page.html we have this html file we have the html tags and everything and inside the body tag we have this div tag okay now we have written div class is equal to box i have given the class value as box okay and then i have given the uh text and if like i have given a code inside this div element this div block whatever it might be but the thing is over here is about the class and the id the difference between the class and the id over here okay so we have this front page dot html in which we have the div tag inside the div tag we have the class okay and the value of this class is box so if i append the style sheet or in this html page so how will i style this class how will i style this div block so i'm going to style through this class value that is box now how i'm going to do that to access this class i'm going to write uh this dot do you see i'll be accessing it through a dot this is a period that is used while accessing the class value okay so i'll write dot box and then whatever attributes i want to write like color green red or whatever it is whatever formatting i want to do or whatever style i need to add i'll add between these blocks of code okay so this is one concept for class we will use a dot now let's see for id now here we have the front page dot html similar and we have the div block in which we have the div id is equal to box one i have given the id value as box one so if i want to style it what i'm going to do i'm going to use the hash symbol over here here you can see i'm using the hash symbol to access this id i'm going to use the hash symbol that is the hash box one and then whatever our styling i want to perform i will perform between these blocks but the thing that i want you to understand over here is that for class we are using the uh dot and for id we are using the hash okay so this is the css concept we you need to know what's the css selector okay so now uh locating by css selector that is the tag and id now just assume we have this uh text box that is the email text box and this is this html syntax that we are having now here for tag in id your tag what is your tag name your tag name is this this is your tag name input okay and these are your attributes like the class id name these are your attributes right so what you're going to do is like for tag and id it is tag name hash id like as i said in the previous slide to access id we use the hash right so over here we'll use tag name hash id so how we're going to write is like driver dot find element by dot css selector we'll use css select over here we'll write tag name first the tag name is input so we'll write input then we'll write hash hash and then we are going to write the id value because it's tag and id the css selector that we are using is tag and id right so we're going to write the id value that is email okay now this is case sensitive just write it the same way which is it is written over here so we're going to write input email dot send keys okay whatever uh text you want to send just send it over here so this is how you're going to write the css director for tag and id now let's see for tag and class okay so here we have the text box email address and we have the syntax over here so how we gonna write for tag and class for class we use the dot operator here you can see we use a dot right so similarly before we were using hash here you can see we were using hash for id so for here we are using the dot for class it's the same thing we're just going to write driver dot find element by dot css selector input dot that is a tag name your tag name is input dot dot class value the value of your class is control right so i have written control over here dot send keys at the right abc gmail.com whatever text you want to send over here okay next we have the tag and attribute okay so how we're going to work with tag in attribute is tag name then we have the attribute name is equal to attribute value now we can use any of the attribute that we want like over here we can use the driver.find element by.css selector input name like here i can use id i can use name i can use class anything i can use so i'm using name name is equal to from that is the attribute name is name my attribute value is from here you can see and my tag name is input okay my next css locator is tag and class and attribute so how am i going to do that simply i just have this text box that is the email address and i have the syntax over here so what i'm going to do is uh over here for tag name it's tag and class and attribute right so for tag name we'll first insert our tag name that is the input then we have the uh class we want to uh write the class for that we need to use the dot operator here we are using the dot over here dot the class value that we have is control over here it's control then the attribute name now here i'm using id you can use any of the attribute so i'm using id is equal to email dot send keys abc at the rate gmail.com okay so i hope it's clear for you the css selector now see css selector is not mostly used by the automation tester they don't use this css selector a lot instead of css selector they use the xpath see the frequently used locators are the id the name and for links we use the link text and the xpath the expert is used used frequently by all the automation testers because it is one of the most precise form to use the locator and it's it's tough to understand but uh once you understand it it's very easy to use okay because we have a crow path plugin to use that we will use that plugin to uh find our xpath okay next the one of the most important interview question that you will face is that what is difference between the find element and the find elements okay now uh we found this find element and find elements in tag name in tag name i wrote a program in which i used find elements because i wanted to find the number of links on a web page right i wanted to find multiple web element on a web page so that's the method used to find multiple element on a web page we use the find elements that's where i use file elements right so the first difference is that find element this method is used to access a single web element on a web page we will use to access single element on the web page till now we were accessing find element because we wanted to access only one web element that is the text box or some other box that is the email box so we have to access only one web element so that is the reason why we're using find element whereas in find elements this method is used to access multiple web element on a web page in our case we were finding multiple angular tags the anchor tags that is the a tag that is used on our web page we were finding the number of links in our web page okay next in find element when the element is not found it throws an exception see whenever the element is not found in find element it will throw an exception such as no such element is found okay whereas in find elements when the element is not found it returns an empty list it will return some empty list okay next the final element it will find only one web element whereas the find elements will find the list of elements which matches the same locator like if we have uh written a as a tag name written over here in fine and we find the number of a tags so it will return the list of elements that is the list of elements will be returned as i have shown in the program let me show you the program um here it is here you can see it is returning the list of web elements that is it is returning the list of links so the find elements the find elements will find the list of elements which matches the locator now let me explain you when the element is not found like here you can see when the element is not found it throws an exception no such element found right so we're going to do that i'll show that i'll implement that for you for example suppose um let's go to this tutorial and recommend this okay and suppose this by name okay i'm just writing search just writing something so that you don't find the element i'm using the fine element method over here see what i'm trying to do is i am trying to prove you this statement that when the element is not found it will throw an exception no such element found i'm trying to prove this statement just check it out okay so i have changed the value over here now let's see chrome browser is launched it is navigated so let's see see here you can see no such element exception no such element unable to locate element here you can see we have got an error over here here you can see name is equal to search underscore q u unable to locate element that's what i try i said right for a fine element when you're using find element and the element is not found you will get an exception that no such element found or unable to locate the element whereas in fine elements we will return an empty list now let's try to do this one we use the find elements method here right find elements now let me change the tag to suppose i'm changing to ar okay this is what the tag i'm changing and i'll just comment this for time being let's navigate it here you can see are we getting any list of array it's just simply zero number of uh we didn't find any tag name a r over here so it just returned zero so that's what it said that it won't give any uh error or something it will just return an empty list it will just return like if the element is not for it will return an empty list over here it returns zero so there is no uh tag name name f a r so this is what is the difference between find element and fine elements this is one of the interview question which is asked in selenium and it is one also one of the most important question that is asked so this is all for today in the next tutorial we will learn what is xpath and we will execute we will practically implement that we will also download the crow path plugin that we used for uh xpath hello everyone my name is varsha and welcome to programming knowledge so in today's tutorial we are going to create test cases and we're going to execute them but before that let us understand what we did in the previous tutorial so in the previous tutorial we learned what are the web elements what are the different types of web elements and one of the most important concept that we learnt in the previous tutorial was the locators now the locators are the way to identify a web element on a web page and we discuss the different types of locators like the id name tag name class name the link text and the partial link text and also we discussed about the css selector in the previous tutorial so uh the id name and the class name are the attributes that is used in the html through which we can identify the web element whereas the link text and the tag name these two are used uh first of all the link text is basically used to click a link on a particular web page if you want to click on some link we use the link text whereas the tag name is used to retrieve multiple elements on a webpage like for example i want to know the number of links present on the particular page so i'm going to inspect the tag name that is the anchor tag that is the a tag and i'm going to count how many a tags are present on that web page to which i will uh retrieve multiple elements so that is uh that for the so for that we are using tag name whereas the css selector we use the tag in id we have the tag in class we have tag and attribute we have tag class and attribute so these are the different types of css selector also we understood in the previous tutorial so these were the some of the concepts that we learnt in the previous tutorial now in this tutorial we are going to create test cases and we are going to execute it what i'm going to do is i'm going to create a test case in which we're going to open the chrome browser i'm going to navigate to this url this page that you're seeing right i'm going to navigate to this url i'm going to enter the valid username and password and click on login button next i'm going to verify the title of the page that is the orange hrm and i'm also going to verify the url that is specified over here see the main intention behind this tutorial is that we're going to learn different types of commands in this also we are going to learn how to verify an element like in manual testing we use the expected result and the actual result and the status column is present right in which you have to match the results and pass the status that it is fail or passed so over here also we are going to verify some elements like i am going to verify the title of the page we are going to verify the url of the page so these are some of the elements that we are going to verify today before that let us understand some of the commands that we use in the previous tutorial let's understand that let's revise that the first command that we used was the form command that is the send keys command here you can see the send keys command which is used to send a particular text to the particular element right then we use the click command which is used to click an element then we use the get command which is used to navigate to the url next we use the get text command which is used to retry specific elements text if you remember that we were using uh we were counting the number of links in a page right so in that i wanted to know the name of those links so we use the get text command next we learnt about the size command the size command is used to get the number of elements in the list now uh if you remember while while counting the number of links we we use the size command to know how many links are present on the web page next we use the driver.manage.window.maximize command which is used to maximize the window next we use the system dot set property as you know it is the very first line on in our program so which is used to set a value and a key the key is like the webdriver.chrome.driver and the value is the path of your executable file okay so these were the commands that we learned in the previous tutorial so now here i have prepared some of the test cases first is open the chrome browser we will navigate to the url enter the valid username enter the valid password next we will click on login button then we are going to verify the url and then we are going to verify the title and then we will close the browser so these are the some of the steps that we are going to perform today so let's get started now open your intelligent idea id i'm going to create a new class over here in my project okay so now i have created a new class i have named it as selenium tutorials file and i have opened my chrome browser these are the two commands that i've used that is the system.set property next i have used the web driver driver is equal to new chrome driver next i have navigated to the url this is the url and i have maximized the window these are the commands that we have been learning in the previous tutorial also so now what i want is i want to uh enter valid username and valid password over here so i'm going to simply click on this element and click on inspect here you can see there are different attributes used so i'll use the id attribute first so i'm gonna write driver dot find element by dot id i'm going to enter the value that is there this is case sensitive so enter the same value and what i want to do is i want to send some value to it right so i'm going to write send keys and i'm going to enter the valid username here you can see the username and the password is given this is a demo website which is normally used for automation so you can also use this and you can automate this website so the username here uses admin so i'm going to copy this i'm going to paste it away so here i've entered a valid username now i'm going to enter the valid password so for that i'm going to write driver again dot find element i'm going to write by dot i'll use name let's see let's inspect that element here you can see this name attribute i'm going to copy this paste it over here i'm going to send some information to it the password is given over yours so i'll just simply copy this password and i'll paste it over here so here we have entered the valid username and valid password so i have entered the valid username and password next i have to click on login button so so i'm going to inspect this login button i'll simply click on inspect and here you can see we have the name class id so i'll use the id i'll use driver dot find element by dot id now enter the value and what i want to do is i want to click this right so i'll write right click okay so now let's run this my chrome browser browser is launched successfully it's navigated and it's maximized okay there is some problem to it okay here you can see i have given some space so there is no space and password again let's run this command it's launched it's navigated and my admin and password okay it's login successfully okay so now what i want is that i want to verify the title of the page and i want to verify the url that is present over here okay so let's verify that so first we will verify the url let's verify the url now for that we're going to use the get current url this is the command that we're going to use to verify the url now this command returns the current url of the web page okay so let's see what we're going to do is we're going to write driver dot get current url okay and we're going to store this in a variable we're going to store this in a string type variable let me write the actual url okay so we are storing in a string type variable i have named it a variable as actual url and i have written string actual url is equal to driver dot get current url okay now let me print this let's see the actual url of this webpage and then we will verify it first so let's run my chrome browser is launched it's navigated and the username and password has entered its login successfully and here it is this is my current url that i'm getting okay now i am on this page i'm on the dashboard page so that is the reason why i'm getting this url the current url retrieves the url of the current page okay your your on which page on that page the url will be retrieved so here we have printed the url now let's verify it so now i have to verify it right how how am i going to do that now i have already created a string variable that is the actual url in which i have got the current url of the web page now what i am going to do is i am going to create another variable of the string type in which i will store the desired url and i'm going to match both these url okay so this is what we're going to do it so first we will create a string type variable and i'm write it i'm going to write it as desired let's go url and i will paste this url that i am getting okay next i'm going to match this actual url and desired url for that i'll be using the if command simply i'll write the actual url dot equals the desired url now if they are equal what i'm going to print is i'm going to print pass and if they're not then i'm going to print fail okay so let's see let's run this command my chrome browser is launched it's navigated okay i've entered the valid username and password and it's successfully logging and here it is i have got the actual url is also retrieved by the current get current url command and also the actual url and the desired url both are matching so the uh output is passed now what if i change this url if i write rn.com so now let's run this command now you see the output will be fail it's launched is navigated browser is maximized valid username and password is entered and here it is on the dashboard page now let's see see here you can see the output it's failing why it's fail because i have changed the desired url the desired url that i want is the open source demo orange hrmlife.com and the actual url that i'm getting is this okay so that is the reason why it's fair so this is how you can verify the url of a web page next let's verify the title of the page okay similarly if you're going to verify the title of the page the same way for that the command that we will use is the get title command okay so what you're going to do is we're going to simply write string actual title that will be driver dot get title okay next let's print this title i'm going to write actual title and let's see my chrome browser is launched it's navigated valid username password is entered it's login okay so this is the title that i got the first one is the i got the current url then the test case that i have verified is par is failed because i have written the desired url that i want is this and the actual url that i'm getting is this the next one is that i'm printing the title of the page that is the orange hrm now how do we get the title simply just inspect this page and here in the head tag you can see the title here you can see it's orange hrm so this is the title of the page okay so this is this is the desired title that you want okay so what you're going to do is similarly we're going to write string desired title that we want is the orange hrm this title that we want is we're going to match this we're going to simply place it over here now we will verify it you will verify with the if command i'm going to write if the actual title dot equals and we're going to write the desired title and here we're going to write if my if my test case is passed then i'll write pass and if it's not if it's not matching then i'm going to write fail okay so now let's run okay now i've launched its login and we have login successfully let's see now here we can see the current url my test case is passed next i can see the title of the page that is the orange hrm and the desired title and the title that i'm getting the actual title they both are matching so the test case is passed what if what if i change this desired title and now let's see okay my chrome browser is launched it's navigated it's maximized and okay and here you can see it's failing okay so we have verified our title we have verified our url the next command that we're going to use is the driver dot close so this command is used to close the browser so let's run this again we have opened a chrome browser it's launched it's navigated it's maximized and log in successfully and here it says it's pass our the current url is retrieved the test cases of verifying the url is pass next the actual title of the web page is retrieved and the test cases fail because i have written only orange hr so let's change it and save it and let's run it again my chrome browser is launched it's navigated it's maximized the valid pass username password is entered and here it is okay and it's closed also so this is the current url the test case of verifying the url is passed this is the current title and the test case for verifying the title is passed so this is how you can verify the url and the title these are the different commands and the different commands that we learned today is one is the get current url then we learnt the get title also and we learned how to verify the commands okay so this is what we learned today we executed this test case we opened the chrome browser we navigated to the url we entered the valid username the valid password we clicked on login we verified the url we verified the title of the web page next we close the browser so we executed these test cases by executing these test cases we learned how to verify the title we learned how to verify the url also we learned different commands we learnt like the get title command and the get current url command okay so there is also one more command that i want to explain you is the get paid source command which is usually used to get the page source that is the source code of the page that we are on so these are some of the get commands that i'm explaining you these are frequently used by the automation testers so uh we're going to write the driver dot get page source and we're going to store this in an element sorry we're going to store this in a string type variable i'm going to write the page source that is ps and we're going to simply print it okay so let's run this so my chrome browser is launched this navigated and okay so here you can see that my source code that is the page source code is visible over here this is the source code that i have got okay so this is also one of the command which is used that is the get page source this is used to get the source code of the page that we are navigated to so in this tutorial we learned the three commands that is the get paid source we learned the get title and we learned to get current url okay so in the get source we learned that we uh through get page source we can get the page source we can get the source code of the page next we learn through get title command we learned how to get the title of the web page next we learned the get current url which is used to get the current url of the page so these were the three uh get commands that we learned in the today's tutorial so in the next tutorial we are going to learn about uh the xpath we are going to use the group plugin the crowpart plugin for the chrome browser and through that chrome brow crop path plugin we are going to uh retrieve our x part so we're going to study what are the different types of xpath also so in this tutorial you will understand about the xpath you will understand what is xpath how to locate the element using the xpath we will also understand about the crow path plugin the types of xpath what are their syntax then we will understand the difference between the absolute and the relative x path and out of the absolute and relative x path which one is preferred and why so let's get started first let us understand what is x path now as i said it is a part of a locator here you can see this chart right we have the different types of locators as i discussed in the previous tutorial i discussed about the id name link text the partial linked text the tag name the class name and then the css selector we are left with xpath now there are different types of xpath like the relative expert and the absolute xpath and it comes under the customized locators as i discussed in the previous tutorial locators are the way to find an html element on a web page expert is used when we don't have the id the name the tag name locators present in the html that is when we use xpath like here you can see in selenium automation if the elements are not found by the general locators like the id class name or the link text the partial link text the tag name etc then the xpath is used to find an element on the web page xpath is also defined as the xml path the shortcut the short name of xpath is the xml path now xpath is basically a syntax or a language for finding any element on the web page using the xml path expression as i said xml path is defined as the xml path right to find any element we use the xml path expression now this x path is the address of element using the html dom structure by using the html dom structure we will find the xml path expression now what is this html dome structure now here you can see we have the normal html code that we write usually we have the html head title body and we close the html tag this is the normal html code that we usually write but when a web page is loaded the browser automatically creates a dom structure that is the document object model here you can see this is the dom model like we have the document we have the html tag oh that is the root element then we have the head we have the title we have the body under body we have the different types of elements so this is the dom model that is the dom structure why it is called as a dom structure because the browser automatically creates a dom structure that is the nodes that is a different nodes are created automatically over here you can see we have the html head title is just simply written over here but over here we have the nodes there are nodes present over here so that is the reason why it is called the html dom structure and it is created automatically by the browser dom is basically an api interface that is provided by the browser now see if we go detailing into the dom structure it's a very huge concept but for now to understand that the x path the xml expression that we will derive we will derive from the html dom structure you know this structure that we have we will derive from this for example so this is the web page now if i want to uh inspect any of the element i'll quickly i simply click on inspect and here you see this is the dom structure of a web page like we have the html head body the html tag is closed inside head we have different types of meta property we have the style we have the script so all these are the so all these are in the form of the html dom structure okay so when a web page is loaded the browser automatically creates this dom object and this dom is an api interface that is provided by the browser okay next let us see how can we capture the x path now this is the page that we want to inspect now suppose this is the email address uh field we have and we want to inspect this element so i'll simply click on inspect and here you can see this text box is highlighted right now i'm i want to capture the x path of this text box how am i going to do that i will uh simply this syntax i will simply right click over here go to copy and i will click on copy full xpath see here i have two options i have copy xpath and i have copy full xpath so i will use copy full expert there is a difference between the two you will understand that later but for now let's click on copy full expat paste it over here okay so here you see this is the complete xpath that we are having for this field that is the email address how is it first we have the html then we have the body then we have the different div tags that we have over here and the last we have the input because we want to access this element we have the input tag over here now here you can see these numbers one two one these are the index numbers that is present over here okay these are the index number that is given away that is the first element of div under the first element of div i am selecting the second div under the second div i'm selecting the first dev as you can see there are different divs over here so uh through these uh acts by accessing these divs i have reached to input tag and over here i'm accessing the email address that is this field okay so this is how we can access uh so this is the first method of accessing the xpath the second method that we have is the pro path plugin okay so what we'll do is uh we'll simply go to google and type crow path plugin the very first link that we have i'll give the link in the description box just simply click add to chrome add extension and it is added okay now here you can see there is no option away of crow path but now uh let me refresh this page i'll just close this browser and here you can see we have the option crow path because we have added the extension to the chrome browser so we can see this option crow path okay now i inspected this element this element i have inspected so let's see the crow path and here it is so here you can see this crow path right uh we have the relative x path now as i said the x path are of two types that is the relative x path and the absolute x path then the css selector we have the hash id the hash is used for uh id write sorry the css directory that we have is the hash email now hash is used when we are accessing the id over here the id that we have is email or if you can see it's emailed here it is it's email okay next the absolute expire this is the absolute x bar that we are having and the tag name that we are using that is the input here you can see the crow path is basically used to find the x path of any element and it is mostly used because it is used to find the element move more precisely like suppose if i will copy this and here you can see the difference this x path is different from this x path why because we are indicating index number for each and every div that we have here you can see there is no index number for this three divs but over here we have the index number given over here why because uh crow path plugin is used to find the element more accurately okay that is the reason why we use crow path plugin there were previous plugins also that were used that is the firebug plugin the firepath plugin but they are outdated mostly crow path plugin is used by the companies and and the second most reason is that here you can see we have the relative x bar the css selector that it is selecting the tag name that it is using so all these things are present over here it is showing these things so whereas over here if we you can just simply copy full xpath and that's the option over here so that is the reason why we use the crow path plugin okay now this is one thing so the next thing that i want to explain is that suppose you have any of a expert suppose this is the expert that you have and you want to find the x bar this x part is of which element so what you're going to do is i'll simply copy this i will click on this source code control f here you can see find by string selector or xpath i will place my xpath over here and here you can see here it is i'm placing my password field over here this x path indicates the password field that i have so this is how also you can find the element through the x path and by using crow path you are finding the x path that is the absolute x bar and the relative x path as well okay okay so now you have got an idea of how to capture the xpath this is a small example of it which is very easier form now suppose this is the html syntax that i have for the username password and login button now if i want to access my login button through xpath if i want to click on this login button through my x bar so how am i going to uh capture the x path of this login button the very first thing that we have is the forward slash this forward slash is very important it is used to access the element okay forward slash and then first i'm accessing the html again a forward slash then i'm accessing the body tag again a forward slash then i'm accessing the form tag again a forward slash and then i'm accessing the input type that is the index three that is one two three the third input uh tag that i want to access because i want to click on the login button right here you can see the syntax it's input type submit name submit and the value is login this is the login button that we are having for this and i want to access this login button i want to click on this login button for that the x bar that we're going to use is this one over here the three indicates the index number that is the third input type that is the third input tag name i want to access so this is how you will write your x path so next now let us understand the different types of x path that is the relative x path and the absolute expo there are two types of x bar relative and absolute x bar let's see the absolute x now the absolute x path it contains the complete path from the root element to the desired element okay for example here you can see my root element is html and my desired element is this that is the input type submit name submit value login this is my desired okay so i want to i have to uh for absolute xpath i have to access from root element to the desired element that's what i'm doing over here i'm writing a forward slash that is only one forward slash then i'm accessing html again a forward slash then i'm accessing body again a forward slash i'm accessing form then in form tag i want to access the third input tag how i will write my xml path okay this is the xml path expression that i discussed before next it says that it starts with a single slash here you can see it is started with a single slash over here from root element to the desired element next uh let us discuss is advantages and disadvantages the advantage of absolute xpath is that it identify identifies the element very fast now obviously over here you are writing the complete path like we are writing html slash body slash form slash input the third index we are writing the complete path because of this it is accessing the element very faster okay that is the advantage of absolute x path whereas the disadvantage now for this we'll take up an example so that it will be easier for you so this is the page that you have that is the username and password and the login page that you have for that you have written the html syntax right now what if the developer wants to make some changes on this page it wants to uh suppose a developer wants to enter another field of email so here it is username password email i have written another uh syntax over here that is the input id email type text okay so the developer has entered another uh text field over here of email and i have to access the login and i had written the xpath before this one right this is the expert that i had written before so is it possible to access the login now after making this changes no right this was the previous expert that i had written for the login button for that this was the syntax i'm accessing the third element of input that is the login right over here i am accessing the third element of input which is the email id right it is the email id that is present over here so this is the biggest disadvantage of absolute xpath that is if there are any changes that is made by the developers in the path of the element then our written expat will no longer work as you saw in that example i had written the expert for the login but when the changes were made by the developers the expert did not work for the login button because at that place the third element of input tag was the email id okay so this is the advantages of the absolute xpath so now let's discuss about the relative xpath now a relative xpath is the one where the path starts from the middle of the html dom structure of your choice your there is no root note there is no desired node you can simply uh start the path where you want to of your choice wherever you want to start so basically it means that it can search for the element anywhere on the web page okay and it starts with a double slash whereas the absolute x path starts with a single slash it has a syntax and this is the basic syntax of the relative x path first we have the double slashes then we have the tag name the stack name can be div image input etc anything okay then uh we will open the brackets and then we have the add the rate this add the rate is used to select an attribute we will write the attribute name and we will write the value of this attribute okay for example i have written first the two the forward slashes i need the double forward slashes then i need input that is the tag name i'll open my brackets at the rate the attribute that i'm using is id and the value of this attribute is email so this is the basic syntax of xml that is the relative xml and this is most frequently used as compared to the absolute xml why we will discuss that later so the advantages of relative x path the first advantage is that you don't need to mention the long x bar the long x bar that is the absolute x path is from the root element to the desired element right so over here you don't need to mention this long x path because there is no need to start from the root element you can start middle at you the path can start from the middle of the html dom structure that is of your choice but the disadvantage is that it will take more time in identifying the element as we are specifying the partial path and not the exact exact part whereas in absolute x path we are specifying the exact path of the element over here we are specifying the partial path of the elements so that is the reason why it takes time in processing so here we have some of the examples of the relative x path like first you can see i have the two double slashes the tag name that i have used is a then this is the at the rate sign the attribute is hereif and the value of the attribute that i have given over here next i have the two double slashes and i have used the image that is the img uh tag name then i have the add the rate sign and the attribute that i'm using is alt and the value of this is flower so these are some of the examples now if you want to access a x part with multiple attributes what if we have multiple attributes like suppose there might be a syntax where the name value the name the value of the name is similar so what we'll do is we'll use multiple attributes we'll use id with that because id is never same it is not the same for every element it is different id is unique right so what i'm going to do is i'm going to use id that is over here is name and also the name attribute that is the name value so by using these multiple attributes value i can access the element more properly right so the syntax of this is tag name or the two double slashes tag name open bracket at the rate attribute one is equal to value one and then the attribute two the value two similarly like attribute three value three so you can go on as you wish okay so this is a way of accessing multiple attributes in relative x path so now let's study the difference between the absolute x path and the relative exponent now the absolute x path it contains the complete path from the root element to the desired element as we studied from the root element that is the html and the desired element that we wanted that is the login button we have the input tag right the input third index so it contains the complete path from the root element to the desired element whereas the relative x path is the one where the path starts from the middle of the html dom structure of your choice you can start from your choice okay it starts with a single forward slash whereas over here in later it starts with the doubles forward slash in absolute x path not used more often because it selects element from the root node whereas the relative x path is used very often because it searches the element everywhere at the web page okay next we have in absolute x bar there is no attribute value over here the syntax that i had shown before like this is the syntax of the xpath here we have the attribute value right we are using the value of the attribute and the attribute name whereas in absolute x path there is no such case there is no attribute value in relative we use the attribute and the value of it this is the basic example of the absolute expert and this is the example of the relative x path so this is the difference between the absolute x pi and the relative x part so we know x path are of two types but which one is mostly preferred obviously the relative x path is mostly preferred why because if the application is not very stable like if the application is not stable and all the attributes are not stable so we are not we cannot use the absolute expert why because the developer might make changes frequently right it's not stable so the developer will make changes the expat will keep on changing so that is the reason why absolute xpath is not mostly used by the automation testers whereas the relative xpath is mostly used by the automation testers because in relative xpath the attributes used are fixed they are not changing we are not using the root element to the desired element okay so that is the reason why we use the relative x path and not the absolute x path so in the previous tutorial we learnt about the x path what is x path and the different types of x path that is the absolute x path and the relative exponent also we learned the difference between the two so in this tutorial we will understand about the x path operators and functions so let's get started so previous uh tutorial we learnt about the relative xpath and the absolute expert let's implement that first on our intelligent idea id so open your intellij idea so i will create a new java class i'll name it as selenium tutorials six okay so all i want to do is this is the website like the ebay.com i'll all i want to do is i want to uh inspect this search box and the search button okay so for that in the previous tutorial i explained about the crow path plugin now we're going to use the selectors hub plugin see the selectors hub plugin is the advanced version of the crow path as the crow path is not having some of the features which this selector hub plugin is having so what we'll do is how to install is write selectors hub xpath the first link that you get over here i will provide the link in the description box simply just click to add to chrome add extension and your selectors hub is added to your chrome browser so since we have installed our selectors hub plugin xpath on our browsers so i'll just close this and i'll open it again so let me inspect this i'll inspect and here you can see we have the selectors hub present over here okay so now all i want to do is i want to inspect this search box and the search button i will write the x path for the search box and the search button the absolute expert as well as a relative expert so let's do it okay so i have created this uh selenium tutorial 6 this is the java class that i have created in my selenium package the first statement that i have written is to open the chrome browser that is the system.set property in which i have given the key value and the value of the that is the path of the executable driver next i have written the web driver driver is equal to new chrome driver next i have to navigate to the url that is the url i have given over here next i am maximizing the window through driver.manage.window okay so these are the three commands which is uh same in all the tutorials till now you want to locate the search box right through relative xpath and absolute expert let's first do the absolute x path okay so simply i'll just write driver dot find element by dot x path and i will write the absolute x path over here let me inspect this element here it is and here you can see we have the re relative x path we have the id name class name uh javascript path the absolute xpath and the tag name that is given over here in selectors hub we have many features there are a lot of features provided in selectors hub as compared to the crow path plugin the crowbar plugin is not having that much of features in it so that is the reason why uh selectors hub is mostly used by many automation testers also it supports the uh shadow dom objects now uh when i will be explaining about the shadow dome at that time we will be using it but for now uh let us focus on the absolute path in the relative expat that we are doing right now so this is the absolute x bar that we have i'll simply click on copy and here it is i want to send some command to it so i'll write send keys and i'll write tshow okay so let's run this so let's run this i'll simply click on run chrome browser is launched it's navigated the browser is maximized and here you can see on the search box we have tshirts written over here okay so next uh what i want to do is i want to inspect this element that is i want to click on the search button okay so i will inspect this element and here you can see we have the absolute xpath as well as the relative expat we will choose the absolute xpath but here we'll write driver dot find element by dot x path and i will write my absolute x path over here and what i want to do is i want to click right so i will right click so here it is i am sending some command to the search box that is the tshirt command and then i am clicking on the search button so let's run this chrome browser is launched it's navigated the browser is maximized tshirts and here it's clicked okay so it's working properly now let's do with a relative xpath i'll commend this okay so now we'll do it relative xpath i'll write driver dot find element by dot x path and i'm going to mention my relative x path over here so as for the search box here it is we have the relative x path which is written over here and simply copy this and paste it over here okay so be careful with this syntax we have only the single quote over here there is no double quote because java does not support double quotes so if you mention double quote over here it will not support here you see right it's in red color so that's the reason why java does not support double uh inside double quotes another double quote so that's the reason why we're writing with single quotes okay so be careful with that now this is the relative expert for the search box and what i want to do is i want to send some key right so i will write shows over here so i'll write shirts for men okay next i want is i want to inspect the search button right for that i'll write fine element by dot x path this is the search button let me inspect it and here you can see we have the relative expert given over here right so i'll copy it paste it over here and what action do i need to perform is i want to click on that button right so i will write click ok let's see if this runs chrome browser is launched it's navigated and it's maximized it's written shirts for men and here it is okay so it's working properly so this is how you can inspect element through absolute expat and the relative x path ah the difference between the absolute expired and the relative expert we studied about that in the previous tutorial also their advantages and disadvantages okay so in this tutorial mainly we will understand about the xpath operators and their functions so the first thing is or operator now when we implement this uh practically at that time you will understand it very uh properly so first let us understand the syntax of it as in the previous tutorial i explained about the expert with multiple attributes here you can see that is the two slashes over here the tag name that we want that is input a or any of the tag name at the rate attribute 1 is equal to value 1 at the rate attribute 2 is equal to value 2 and so on this is how we will write x bar with multiple attributes now with the help of these multiple attributes we are inserting some of the operators of x bar that is the or operator and the and operator like here you can see we have the two slashes over here the tag name that we're using that is the input at the rate id the attribute that we are using is id and the value of it is the search underscore query or the or operator which i have written over here then the second attribute that i am using at the rate name and the value of it is search okay so this is how we will write the syntax with the operator in equilibrium x path now we will implement this method and then you will understand this table so i will just comment this okay so now what i want is i will inspect this element and i'll uh try to send some of the keys of it like i'll write tshirts for men over here so let's see if the element is identified or not okay i'll click on inspect okay so in this syntax here you can see we have the id attribute as well as the name attribute present over here okay so first let me write driver dot find element by dot x path and here i will write my relative x path so first the two slashes the tag name that i want is input open bracket first i am going to write at the rate id so the value of the id is this here you can see so let me copy this next i'm going to write or then i'm going to write add the rate name attribute the value of the name attribute that is this i will just simply copy it paste it over here dot send keys and whatever keys i want to send is short for men and let's see whether we can locate this element or not so a chrome browser is launched it's navigated it's maximized and here you can see shirts for men that means this search box is located through our operator okay so now here you can see this a part the id part at the rate id is the a at the rate name is the b part right now if both the elements are true that means the return the element is identified and it returns both the element right now what if my first element is true and the second element is false it returns a so let's check this out that means at the rate id is equal to this value is correct whereas this value is not correct now let's see what happens whether we are able to locate the element or not so i click on run my browser is navigated it's maximize and here you can see shirts for men the search box is inspected it is identified even though if my name attribute the value of the name attribute is not correct okay now what if my ad id value is not correct like if i write this gh let's see whether we can identify the element or not my chrome browser is launched it's navigated it's maximized and here you can see shirts for men it's identified okay now what if the id value is wrong and even the name value is wrong let's see if the element is identified or not so our chrome browser is navigated and it's maximized and here you can see there is no element over here there is no key sent over here that is the shirts for men why because my id value as well as the name value is wrong okay so this is what the or operator is if my a element that is the id value is wrong as well as the name attribute value is wrong that means it's not the same as it is specified in the html dom structure the element will not be identified whereas if my id value is wrong but my name value is correct the element is identified similarly if my a value that is the id value is right whereas my name value is wrong still the element is identified and if both are right the element is identified but if both are wrong the element is not identified so this is all about the or operator now let's check out the and operator okay it's the same as it is or only the rules are bit different you will understand that practically so we are testing for and operators so i'll just write and over here let's see so the id value is same and the name value is also correct so let's see if it is inspected the element is inspected or not let me comment this okay all right when chrome browser's launched it's navigated it's maximized and here you can see the shirts for men the search box is inspected as well as the command is sent that is the shirts for women so this means this uh line this driver.fine element this function that we have written works well okay now what if if i just write the id value wrong whereas the name value the value of name attribute is correct okay so let's see if the element is identified or not so my chrome browser is launched it's navigated it's maximized okay there is no command sent over here okay so if my id is wrong and my name is right that means the element is not identified what if my id value is correct whereas the name value is wrong let's see if the element is identified or not my chrome browser is launched it's navigated and it's maximized okay so here you can see that my search box is not identified and there is no command sent over here so your element cannot be identified if the id value is right and the name value is wrong as well as the id value is right wrong and the name value is right both of the ways the i the element is not found what if both of them are wrong let's see let me inspect it click on run chrome browser is launched it's navigated it's maximized and here you can see there is no command sent over here okay so what this basically means is if the a element that is the id attribute is having the wrong value as well as the name attribute is having the wrong value the element is not identified similarly if the a attribute that is the id attribute is having the wrong value and the name attribute is having the right value still the element is not identified if the a attribute is having the correct value whereas the b attribute is having the wrong value still the element is not identified in case of and operator the element is only identified if the id attribute is correct as well as the name attribute value is correct only then the element is identified so that is the difference between the and operator and the or operator like here you can see the element is identified in all the cases except if both the uh attribute values are wrong okay whereas over here it is the element is identified in only one case that is both the id as well as the name attribute value should be correct that is it should be the same as it is mentioned in the html dom structure so this is the difference between the or operator and the and operator so the next function that we're going to study about is the contains function now the contains is used to identify an element all the functions that we studied till now of x path are used to identify an element when we are familiar with some part of the attribute value of an element now this means that when we are familiar with some part of the attributes value that is for example let me show you the normal syntax of the relative x bar that we write is this right two two slashes the tag name add the rate id and the value like over here you can see two slashes input at the rate id and the value that i have written is the first name now what if you want to use the contains method when we are using the contains method we will write add the rate id comma first that is only the partial text i will write in contains method i don't need to write the full text so this is a feature of contains the next function that we're going to study is the starts with function now see all these functions that we are studying they are used dynamically for dynamic uh elements they are used now what are dynamic elements there are two types of elements one is dynamic and one is static static elements are elements whose attributes value does not change the value of the attribute does not change whereas the dynamic elements are the elements whose attribute value changes on refresh or any of the operation of the web page like if we click on that element the value changes for example let us take up the start and the stop button like this is the button if i click on start the function will start but after start the button changes to stop and when i click on stop the function will stop and the button will change the value will change to start so this is how this this is what is the dynamic working of the uh of the elements on the web page now for example like over here you can see we have the button like start and the stop if i want to inspect the start button i want to uh identify the start element what i'm going to do is i'm going to write slash input two slashes input at the rate id is equal to start this will identify this will locate the start button only and not the stop button because after clicking on start the value is changing to stop right so it will only identify the start button what about stop so for that i have to write input at the rate id is equal to stop over here also it is identifying only the stop button and not the start button so in this case we will use the start smith operation now here you can see there are two things there are two words in common right the s t s and t these are the two words that are in common over here so what i'm going to do is i'm going to use a starts with function i'm going to write starts with either rate id and sd in this case it will detect the start operation as well as the stop operation so this is the advantage of start swipe like here you can like here you can see start with find the element whose attribute value changes on refresh or any operation on the web page like clicking the uh in the element on the web page now in this expression matching the starting text of the attribute used to find the element whose attribute changes dynamically here's the attribute value this is the attribute value right that start and the stop this attribute value is changing dynamically right so this is what we're going to do we are going to match the starting text of the attribute values this is the starting text which is the similarity so always keep in mind that the starting value of the attribute should be similar then only starts with function will work we can also find element whose attribute value is static which does not change but this works uh properly with dynamic functions okay so let's implement this first now this is the page this is the element that i want to inspect i'll click on inspect and here it is so what i'm going to do is i'm going to write the x path over here okay for contains method so let me write two slashes the tag name input then contains open brackets the rate i'll use i'll use name let me use name attribute so i'll write name comma single quotes underscore nkw here you can see this value let me copy this and close the bracket close the back and here you can see we have one element matching which shows one element matching this element is matching it is highlighted right so this is the element which is matched over here now if i'm using contains as i said i can use partial text right so what i'll do i'll just remove w and still you can see one element matching and still you can see one element matching i remove i remove the k as well so let's see if it is detecting this element or not i will copy this right driver dot find element by dot x path and i will mention this and i want to send some value to it so i'll write shirts for kids my chrome browser is launched it's navigated it's maximized and here you can see we have the value written away shirts for kids so this means that the search box that i have inspected over here through contains method is working properly okay we can locate the element over here so this is how we will use contains method now if i use starts with i'll just simply remove this contains and write starts with and here you can see uh so since uh selectors hubs gives us the feature of writing the x path over here as well in the uh expired the text box so i have written a input starts with at the rate name and here you can see it is starting with underscore n right so let me write underscore and here you can see we have one element matching now what if i remove n and here you can see we have three elements matching which is matching to underscore you can see the uh three elements are given over here the first element is over here this is the second element and this is the third element since we are inspecting this third element so i'll just include n see it doesn't matter where your what type of value you're writing over here these functions are used only for dynamically functions now in the next tutorial when you learn about the advanced x path there you will see many dynamic elements so at that point we will use starts with metal okay i'll just copy this element and let's see if it's working well or not driver dot fine element y dot x path and here i will include the element now let me send some keys tshirts for kids let me comment this and let's see if it's working well or not so our chrome browser is launched it's navigated and it's maximized and here you can see tshirts for kids this means that my search box the element that i want to inspect that is the search box is inspected through these starts with method okay see i'm here i'm just showing the demo of using these functions that how you can use these functions the next method that we're going to understand is the the next function that we're going to study is the text function now see text is an inbuilt function of the selenium webdriver and it is frequently used and it is one of the most popular expat function that is used and it is basically used to locate elements the elements that we want to locate right based on the text of the web element like here you can see we have the user id and the element that i want to locate this is the text box that i want to look at the text of the web element the text of the web element is the user id over here by using this this text i am going to identify this web element okay this is what text function is over here like you can see uh like if i inspect this element this is the element that i'm inspecting we have the td tag inside the tr tag we have the td a line is equal to right and the text that is used that is a user id so if i want to inspect this element how i am going to write is the two slashes td the text function the text the value of the text function is the user id this is how i'm going to write the text function okay so let's uh do this let's do the demo of this i'll comment this so this is the cell link that i want to click on so what i'm going to do is i'm going to inspect this element and i'll write the x path over here the tag that we're using is the a tag it's a link so a tag and i'm going to write text here you can see okay so here we can see that is the one element matching so i'm going to copy this x path and i'll paste it over here that'll write driver dot find element by dot x path paste it over here and the operation that i want to perform is i want to click on this link okay so let's see so our chrome browser is launched it's navigated and it's maximized and here you can see the cell link is clicked okay now suppose if i want to use the contains and the text method both of them i'll write contains open bracket then i'll write text function comma then i'll write a cell close your brackets and here you can see here you can see we have six elements that is matching it sell sell sell selling then we have saved sellers then sell sellers information center seller information center now see here you can see we have used the contains method when we were using the text method only one element was identified but when we are using the contains method the six elements are matching this means the cell this cell word that we're using see here i have used the contains method if i'm using contains method i'm finding six elements when i was using the text method only i found only one element matching whereas if i'm using the contains method there are six elements that is matching over here why because in all these matching elements there are some uh words at the cell like over here we have the cell we have selling we have said sellers we have sell over here again we have the seller information center then we have the seller information center so if you're using contains and text so this is the difference whereas if i use starts with over here there are three elements matching over here here you can see we have sell seller seller information center there are three elements that is matching to starts with so this is how you can use text function with all the functions that i have explained over here which contains start and starts with okay so uh but the only difference will be that that we will find multiple elements through these if we use starts with with text and if we use the contains with text so these were the functions that we studied let's see the final conclusion of it which function to use when so when do we use contains method in expert we will use the contains method if you know the partial constant visible text or attribute now what is this partial constant visible text partial constant visible text means that if there is any text like suppose there is an element which you want to identify there is a text for it right that is what we are using in contains method like here you can see the contains method the text which we are using we are using the partial constant text this first is the constant text even name is the constant text it contains method and the starts method is used dynamically so we will use only the words that are constant okay similarly goes with start with over here the words that are constant is s and t whereas the other words are changing right because start as a as we are starting the button it is changing to stop so that value is changing dynamically okay so we will use the contains method in x path if you know the partial constant visible text it should be constant it should not be dynamically okay next we will use the starts with method if you know the initial partial constant visible text or the attribute the initial partial constant text means that like over here there is an initial constant text right that is the st you are also st rest all the words are changing okay so the partial initial constant text is used in starts with next we can use the contains method and the starts with method with absolute text or attribute also this means that we can write the first name as well similarly for uh start with we can write start or stop as well but the only problem will be that it will identify that element only for starts with okay next we can you use the text method in xpath if you're aware of the absolute visible text now here in the text method we cannot write the partial text like over here you can see you cannot use text method with the partial text like in the contains method we were writing the partial text right whereas in text method we are not allowed to use the partial text like over here we were identifying the element cell right we were clicking the element cell in the demo now if i write sel only it will not identify if you're using the text method but in contains method it will identify okay so this is the difference between the two next we cannot make use of starswith method if the initial text is constantly changing now for example this st word is changing constantly now suppose just imagine we have a button name activated and deactivated the if you're clicking on activate button the process is activated and the value of that button is changing to deactivate so the first words are changing right so in that case you cannot use starts with function so this is the conclusion of the entire uh tutorial that we learned that is the contains whether the starts with method the text method then now we have learnt uh so much about xpath we have learnt what is x path what are the different types of x bar that is the relative x path the absolute x path the difference between the relative and x absolute x bar the functions of x bar that is the contains the starts with the text method so uh this is not all about expert the main part about xpath is the advanced expired functions that we are going to study that is uh this this is the graph that we're going to study in the next tutorial that is the xpath access in which uh we have the uh ancestors we have the parent we have the child we have the following siblings we have the preceding siblings so uh this entire thing we're going to study in the html dom structure and we will also do the demo of it so in the previous tutorial we learnt about the xpath operators and also the expert functions as well as we learnt about the different types of xpath that is the relative x path and the active expat the different types of locators also we have studied the id name the css selector link text and everything so in this tutorial we will learn about the advanced xpath with their access method in which we will cover what is the xpath axis and why do we use this xpath axis also we will understand the different types of xpath axis and the relationship with their nodes this is the most important thing that we need to understand next we are going to understand their syntax their descriptions and also we will implement it practically we will automate two websites let me show you those first is this website we will automate this table as well as we will automate this form so let's get started so the first thing that we need to understand is what is the xpath access now the xpath axis are those axes that is used to search for multiple nodes in the xml document for the current node context now what is this current node context we will understand while studying the relationship of nodes now why are we using the xpath access if we have locators like the id name class link text and all these locators are there still we are using the xpath access why see in the previous tutorial i explained about some of the expat functions right that is the contains method and the text method and the startswith method so even after using those expert functions we cannot identify the element that is the that is when we can use the xpath access so what to do when the expat functions fail to identify the elements in that case we will use the xpath access along with the xpath functions like the expert functions can be contact contains text start with we can use those functions as well as the xpath access also we can use those selectors like the id name class link text css selectors these locators can also be used okay so this is what expert access is and why do we use xpath access next there are different types of expat access like we have the child we have the parent we have following proceeding following sibling preceding sibling and sister descendants we will understand these terms in detail now here it comes this is the relationship of note okay this is one of the most important uh thing we need to learn in xpath access you need to remember you need to understand this relationship of note picture and uh so just have a look at this picture properly and see this topic is a bit difficult to understand but once you get a hang of this relationship of nodes uh it will be very easier for you to locate the elements in the dom html structure okay so now uh let's start from this node that is a self node now i would suggest you that uh take this relationship nodes in your family context as in when you study your family tree that is the ancestor parents your siblings your children your descendants so when you take take in those contexts when you take in those family terms it will be very easy for you to understand this relationship okay because there are many different uh keywords that we need to understand the ancestor the parent the child the preceding sibling the following sibling so to get a hang of it just keep yourself over here and just imagine your family tree so here uh this is you and this is the self element okay each and every node present over here is an element okay so this is self element so what will be your parent element the one about the self element is the parent element that here you can see is three this is your parent element and your ancestor is one now if you keep yourself over here who will be your ancestors your parents parents will be your ancestor right so in this case one is your ancestor so now uh this is yourself element three is the parent one is the ancestor now if you keep yourself over here your children that is the 9 10 11 12 and 13 these are the child notes that are present over here okay this is you the one above you is your parent and your parents parent is your ancestor and your children are your child notes that is the 9 10 11 12 and 13. these are your child notes okay coming to the next term that is a descendant now what are those descendants descendant notes are children's children as well as the children okay that means descending will be your 9 10 11 12 13 14 15 16 17 and 18. keeping yourself over here your children and your children's children will be your descendants okay so what did we understand till now keeping yourself over here the one the element above you is the parent parent's parent is the ancestor that is the one and your child nodes that is your children are your child notes children's childrens are your descendant nodes okay now let's go to the preceding and the following these are the two uh terms that are left now the preceding siblings and the following siblings okay now your let's take in terms of family tree this is yourself keep yourself over here okay now just imagine that your brothers and sisters that are elder to you okay is your preceding sibling and your brothers and sisters that are younger to you are your following siblings okay this is what is following siblings and preceding siblings now coming to proceeding and following now your following means the elements that come after the current html tag the current html tag means the self tag the elements that come after the seller self tag is the following tag which includes the following siblings also whereas preceding is the elements that come before the self tag which includes the preceding siblings as well see when we practically implement this it will be more easier to understand you will understand in a very better way okay we will do the practical implementation also so let's see the syntax these are the two slashes that are always present in the x path we will write the tag name slash the single slash axis that is the child parent or ancestor or anything and there is an operator that is specially used over here that is a scope of operator in the scope of operator these two colons and then we will write the target element whatever it is the target element that we want to specify so let's have a description of this as i said child child means it travels all the child element of the current html tag okay so let's look at the description of it the first is a child it traverses all the child elements of the current html tag all the child elements of the current html tag our current html tag is the self tag okay it is traversing all the child elements of the current html tag that is 9 10 11 12 and 13. next is the parent traverse all the parent element of the current html tag so the parent over here is three okay our current html tag is self so the element above the self is the parent element right so your three is the parent element next we have the following traverse all the elements that comes after the current attack after the current tag right self is the current tag all the elements after the current tag that includes the seven eight and also the four so this is the following okay see there is a difference between following and following siblings okay the following siblings consist of seven and eight element only whereas following is having four seven and eight okay so there is a difference between the two next coming to the proceeding traverse all the nodes that comes before the current html tag so the current html tag itself before the current html tag is 2 5 and 6. okay so this is your preceding elements next we have the following siblings traverse from current html tag to the next sibling html tag traverse from the current html track this self to the next html tag that is this this is your next html tag which is just next to it right next to your self tag which is seven and 8 so this will be your following sibling going to preceding sibling traverse from current html tag to previous sibling html tag current html tag is self previous sibling html tag is this that is the five and the six okay next we have the ancestors that is your grandparents in parent reverse all the ancestor elements of the current html tag so the ancestor over here is one this is your current html tag itself and the ancestor is one next we have the descendant it traverses all the descended elements now which consists of the child node the grandchild nodes of the current html tag so this is the current html tag the child node that is the 9 10 11 12 and 13 and the grand child nodes that is the 14 15 16 17 and 18. so this is all about the relationship table in which we covered about the ancestor the parent the child descendant the following the preceding the preceding sibling and the following siblings now let's implement this so these two page uh these two sites we will automate today we will automate this table as well as this form now this table is dynamic it keeps on changing it is the rediff money.rediff.com the gainers page in which we have the markets uh companies present over here which keeps on changing according to their uh prices and so we're going to automate this table today which is dynamic also we're going to automate this form now this form is static this is dynamic so just open your intellij id id okay so i've already created a java class in the selenium package and i have named it as selenium tutorial 7 so we're going to implement our advanced xpath accesses in this uh selenium tutorial 7. so uh like the three lines is always the same in all the programs so first is the open the chrome browser that is the system.set property in which we have to specify the key value and the value that is present that is the executable file you need to write over here and the key that we use is the webdriver.chrome.driver because we're launching the chrome browser the next line that we write is the web driver driver is equal to new chrome driver and why do we write this i have explained in the previous tutorials so you can go and check out that the next thing that we're going to do is we are navigating to the url so we are going to use the driver.getcomma in which we are going to navigate to the particular url the next that we are going to write is the maximizing the window in which we are using the driver.manage.window.maximizecommand okay so these are the three things that we are going to do so let's execute this and yeah we are exec we are automating this table first and then we will jump on to this page okay so first automate this one so let's execute this first let's see we are whether we can launch the chrome browser or not so our chrome browser is launched it's navigated and it's maximized okay so so far our this commands are working so let's get started with the xpath access first important thing that we need to identify is a self node on the basis of the self node we will identify the other relationships that is the ancestor the parent the descendants and everything okay so first thing is we will identify the self node so i take any of the column let me take this one okay so i'll just click on inspect and i'll be using the selectors hub xpath tool i have explained about the selectors hub in the previous tutorial how to install it so you can check out that i'll also give the link in the description box to install it okay so uh this is the element that i inspected here you can see a rash television network so uh what i'll do is i will copy this relative path i'll paste it over here and i'll write the contains method over here let me use the contains method so you can see we have one element matching so what i'll do first i'll identify the self so the syntax for it is that i'm writing the tag name i'm using the function that is the contains function of the x path i'll place a slash over here then i write self and the tag name here you can see the tag name is a right so i will write a and click on enter and here you can see there's one element matching that is this one okay so i'll copy this and i'll write driver dot find element by dot x path and i'll place it over here and what i want to do is i want to uh click this link so let's see so let me run this so our chrome browser is executed it's navigated and it's maximized and here you can see the rash television network is clicked okay so we were performing the operation of click so it's clicked so i'll just close this so here you can see this is the self note we are using the self command we are identifying the self command over here just by writing one slash sells two colons and the tag name that is we're using is a okay next let's see is the parent node okay let's find the parent node this is our element now we have to find the parent node that is the node about the self node that is the current html tag that we're taking is the a right above it we have the td tag okay so this will be our parent node so now what if we don't know what i'll do is i'll just write uh this is this will be the command that is i'm writing the tag name a i'm using the contains function and then i'll write one slash and i'll use the parent over here and what i'll do is i'll write the asterisks and here i can see i have one parent over here which is identified for this element that is the rash television diagram okay for this element the parent is here this is the parent where you can see it's identified over here here you can see it's highlighted so this is the parent this is in case when we don't know the parent of the current html tag okay now here we know the parent right so uh since i have written one slash parent and the two colons over here which is in scope of operator and then i'll write td okay so here you can see again it's a one element matching that is this one so what i'll do is i'll copy this and driver dot find element by dot x path this and uh let's do one thing i will uh retrieve the text over here okay so let's retry the text so i'll write get text method and um let me give a string variable over here i'll write parent node then the next thing that i'll write is the system out.println i'll type the parent node is similarly i'll do for this one also let's see what value do we get get text and i will give a variable over here so i'll write the self node is so let's see what value it prints so i will execute this command a chrome browser is launched it's navigated it's maximized so let's see see the self note is large television network and the parent node is rash television network now here there's one thing to notice that is there any value in td here we can see it's here is there any value in td there is no value entity there is there is no value entity so that is the reason why we are not fine we are not getting any value printed over here the only value that we are getting over here is uh is rash television network because under the parent element under the td tag we have the a tag right which has the link of the rash television network so that is the reason why it is printing rush television network if td would be having any value the parent or value would be different from the self node value okay we will understand that in the forms when we will do uh we will navigate the different website this form website at that time we will see the values also at that time the values will be different okay so for now to understand the td tag is having no value so that is the reason why we're getting the raw television network away okay so now moving to the next thing is see the child nodes so now uh if i write child to collins and the asterisk so here we can see we have zero element matching over here there is no child node of this a tag okay so now what we're going to do is first uh we will go to the ancestor and then we will find the child elements for ancestor that is a tr tag is having different child elements like here you can see the b 34.05 and 39.20 so these are the child elements of tr tag right so we're going to find the tr tag the uh tier tags child elements okay so how we're going to do this is the self tag that is the a type the parent tag is a td tag and the ancestor tag that we can see over here is the tr tag okay so first we'll go to the tr tag we'll go to the ancestor and then from there we will traverse the child elements okay so how we gonna do that just have a look at it this is the tag name that i'm using that is the a tag name and the contains method that is given over here then i'm given the slash over here and then i'll write the ancestor here it is okay who's my ancestor my ancestors tag is tr tag here you can see this is the tr tag click on enter and here i can see there's one element matching to it okay this is the element that is matching to it here you can see it's getting highlighted okay so i have gone to my ancestor after i was to tell my ancestor now i want to find the child elements of my ancestor so what i'm going to do is i'm going to put another slash over here write child colons and let's see how many i'm getting five child elements over here this is the first one this is the second one this is the third one this is the fourth one and this is the fifth one okay now see selectors hub is having this feature of identifying these five elements which are matching which is showing over here also so it's a great tool to use so i would suggest you to use selectors hub for the access when you're finding the xpath access because you will get a knowledge of uh writing the expert as well it's not that that you're getting used to this tool or not see sometimes people think by using this tool we are not getting a hang of writing your x bar that's not the point if you write your expert over here it tells you whether you're writing it right or wrong like if i delete if i just clear this one so you can see it's red in color but when i write this it's it's it's not having any color so it shows you that the expert that you're writing is correct or wrong so that will help you like if you write bigger scripts so in that case that will help you so it's a very great it is a very good tool to use so use selectors hub i would prefer you to use selectors hub okay as in the previous tutorial i explained about the crowbar plugin also but the selectors hub is the advanced version of the crow path plugin so i would recommend not to use crow path for now because uh it's so absolute it's not that updated till now so selectors hub is more updated so use selectors up okay like here you can see i placed the asterisk mark and here you can see uh there are different uh td tags present over here that is the child elements one two three four five we are having five elements over here okay so now what we're going to so till now what we did we went to the ancestor tag that is a tr tag and then we traverse the child elements over here what i'll do is i will write driver dot x dot find elements because i'm finding multiple elements over here okay the child nodes that i'm having the number of child node is five i'm not finding one element i'm finding multiple elements over here okay so find elements then i'll write by dot x path and i will write the entire x path over here now what what i'll do is i want to uh i want to know the number of child elements present over here i'll print the child number of child elements present over here so i'll write child node is equal to this now what we are finding we are finding a web element a multiple fweb elements we are finding right so i'll write web element now this is a web element child or not a child node but we are finding multiple elements we are using find elements right so it is a list of multiple elements so what i'll do is i'll write list web element child node driver dot find elements y dot x bar and the x bar that is present over here now what i want is i want to print this so so the number of child nodes are child node dot size okay so let's and after this uh what i want is i want to close the browser so i'll write driver dot close okay so let's run so the chrome browser is launched it's navigated and it's maximized and it's closed okay now here it's you here you can see the self note is rash television network the parent node is rash television network the same value is given because the td tag is not having any value and the number of child nodes are five here you can see we have five elements that is identified so the number of child nodes are five okay so so far we have seen the self known the parent node in the child node let's uh see the ancestor node since we have seen already but let's print it okay so what i'll do is same these are my ancestors so let me see so there is only one ancestor over here okay so i will copy this and i'll write driver dot find element by dot x path the ancestor and what i want is i want get text so i'll save it in a variable that is string variable i'll write it at ancestor node is equal to driver dot fine element by dot expat and next i'll print it the ancestor node is and plus ancestor node okay so let's see let's run this command so i chrome browser is launched it's navigated and it's maximized and it's closed so here you can see the ancestor node is television network b now see when you're traversing the ancestor that is the tr tag under tr tag we have the different uh tags right that is the td tag the td this tag then this td tag then the tr tag is closing now from this tag to this tag the number of tags that we are having it will print all the tags first is printing the raj here you can see the last television then it's printing b then it's printing 34.05 just have a look at it here you can see we have the rash television network the rash television network then we are printing b then we are printing 34.05 34.05 and then the 39.02 and then plus 15.12 so it's printing the entire eye because under the tr tag under this tr tag there are different td tags that is present and under td tag we have the different values that are present over here that is the uh rash television network then the b then thirty four point zero four thirty nine point zero two and so on okay so like these there are uh five to six elements that we have printed printed over here this is all about the ancestor now let's see the following so i have the two slashes that is always there for the x path the a tag the tag name that i'm using is a contains the rash television network this is the element that is the self element now from here i want to see the following elements okay so what i'll do is put one slash i'll write following two columns now i don't know what are my following elements so i'll just put the asterisks mark and here you can see we can see there are almost 13 000 elements that is matching to the following element you can see so just have a look over here the one that is highlighted the blue one is the following elements that is over there this these are the following elements okay the this blue one that is highlighted over here there are almost 13 000 elements that is matching over here so this is the following element so i'll just print the number of following elements that is present over here so i'll just write driver dot find elements by dot x path i put the following and let's give a web element the i'll write the is equal to driver dot and it is of type list because the number of uh web elements that is identified over here are almost 13 000 web elements will be identified over here so i'm writing list web element and the following tag that is the web element that i'm specifying over here in the driver.find elements by.xpath and next what i want is so i want the number of following elements from the current html tag is and i will write following tag size let's execute this okay so my chrome browser is launched it's navigated and it's uh maximized so these are the number of the following elements from the current customer tag that is present over here now let's see the following sibling okay so let's check out the following siblings that are present over here so what i'll do is i will just write the following sibling i don't know the number of following siblings so i'll just write the asterisks and it says that there are zero number of following siblings present over here that is there is no node next to the self node so again what we'll do we will traverse to the ancestor so our ancestor tag is the tr tag slash following sibling and then let's see so what we did we traverse to the ancestor tag that is the tr tag and from tr tag we traverse the following siblings so the following siblings that are present over here are these these are the following siblings you know this uh blue marking done over here these are the following siblings okay so what i'll do i'll just print the number of the following siblings over here so what i'll write is i will write driver dot find elements by dot x path and the following sibling over here and then i will following siblings okay so let's execute this so my chrome browser is launched it's navigated it's maximized okay so here it is the following siblings are uh 1705 okay so the number of following siblings that are present over here is 1700. so now let's see the proceeding okay so what i'll do is i will slash proceeding now i don't know the number of preceding elements over here so i'll just write asterisk and here you can see this is the entire preceding element that is present over here the entire preceding elements that we have is this okay now what if i write preceding sibling so there are zero elements that is matching over here so so again we will go to the ancestor the tr tag and then we will go to the preceding sibling so there are six elements that is matching to the preceding sibling that is uh these elements before the rash television network the element that is present is the preceding siblings after the rash television network the elements that are present is the following siblings and the elements that are present before the last television network all these elements this entire pace that is present before the rash television network is your proceeding again let me show you this is your preceding sibling but whereas your proceeding is this this is your proceeding and you proceed preceding siblings for only these columns that is present over here before the rash television network so that is the difference between the preceding and the preceding siblings okay so keep in mind that so let's first do the preceding one so i'll just copy this and we will see that at least 200 elements that is present over here so i'll just write list we will we are finding the web element over here and i'll write the preceding so pre and then driver dot find elements by dot x path and then this syntax of x path and the next line i'll write s out i'll write the number of preceding nodes are so our chrome browser is launched it's navigated and it's maximized okay and here you can see the following siblings are 1700 and the number of preceding nodes that are there it's 200 okay so 217 so these are some preceding now let's see the preceding siblings okay so what i'll do is i will first find the number of elements that is present so what i'll do as a first traverse to the ancestor first ever so the ancestor we have the answer tag that is a tr tag then i'll write one slash and then i will write uh preceding siblings this and i'll write the asterisk sign and you can see we have six elements matching over here so i'll just copy this x path and i'll write list is equal to driver dot fine elements by dot x path and i'll place the x path over here so s out and the number of okay so let's run this now so our chrome browser is launched it's navigated it's maximized okay so here it shows the number of preceding siblings are six similarly we have seen over here there are six elements that are matching so the number of preceding elements uh preceding siblings are six so um this is the code that we have executed today for the expert access in which we have seen the self node first and the parent node the child node the ancestor node the following the following siblings the proceeding and the preceding siblings okay so for so far we have understood how do we write these elements when we're having a dynamic uh web page so this table is dynamic it keeps on changing you can check it out also if you like open today and open it tomorrow so these companies keep on switching okay depending on their change in prices this is a way that we can identify the ancestors and child nodes how to first traverse to the child node and then for how to first traverse to the ancestor node and then to the child node so this is this is the way to do it so now this is the first web page that we traverse and then the next webpage that we're going to automate is this one okay uh this code is available on the github so i'll uh give the link in the description box so you can check out okay so uh this is the second uh web page that we are going to automate we're going to use the xpath axis over here we will find the parent the self element and all the elements the xpath access elements over here so first is to identify the self element right the self node so i'll be taking this company name as the self node so here it is the company name okay so now what i'm going to do is i'm going to open my selectors hub and let me see yes this company name is myself note and here it is this is the just copy the relative path over here i'm using the two slashes first the two slashes that is used for the x part normally then the input tag here you can see we have the input tag and the id uh locator has been used the id locator in which the value is the company okay so as i said uh the expert access can be used with any of the locators and in fact it can be used with the uh methods also okay so now what i'm going to do is i'm just going to write a slash this is the self element so i'll write the cells two colons and the in the tag that is the input tag right the tag that is usable over here is the input type so you can see that there is only one element matching that is this element okay so i'll just copy this so i'll write driver dot find element because one element i'm finding by dot x path and i will specify the x path over here and the command that i want to send over here is send keys the company name is abc that's the company name run this so my chrome browser is launched it's navigated it's maximized and you can see the company name that the command that is sent over here is abc okay so here our self node is identified let's find the parent node so here this is a self node so uh i'm writing the two slashes that is the in and the tag name that i'm using is the input tag the id locator that i'm using and the value is company so slash and i'll be using parent now i don't know the number of parents over here so i'll just write asterisks and then let me see there is only one element the form here you can see why see because your input above input we have the select tag which is of the same level then we have the div tag which is of the same level next we have the form tag which is the parent tag why because above input now you must be saying about the self tag that i said the current html node is the this this input tag above this input tag we have the select tag right so this should be parent tag no this tag and this tag are on the same level the parent tag over here is the form so the parent tag over here is form right so we will access this element so what i'm going to do is i'm just going to copy this i'll just write driver dot find element now uh sometimes uh there is a question where people ask that the for relative x path for absolute x bar are the different different ways of writing like by relative x path by absolute x but by x path axis is no there is only one x path that is by dot x path okay okay so this is what and what i want is i want to find the value let me find the value of it what value do i get from here so i'll write string parent is equal to drive and i'll write the parent so chrome browser is launched it's navigated it's maximized and the company name that is the abc has been sent over here now you must be saying that your only one element is found but the value that is printed over here here you can see there is a number of values that is print the parent values name email role job and all these cities names and states names and this entire thing is printed why there's only one element matching and how come all these values are printed why as i said in the previous time when we were automating that uh table that dynamic table at that time also i said that when we are traversing when we are traversing to a parent tag or an ancestor tag so all the tags that are under it the values are printed when we are printing the value we are finding get text right the get text method has been used over here through gettext method we are finding the uh values that we are finding the text that is there for the parent string see the variable that we are using is parent over here right and the element that we are finding is this the parent element right so we are printing the parent element right so print while printing the parent element all the elements that are under form all the elements are printed over here okay so here you can see until the form is ended till here so all the elements that are present in here all the elements that are present see here you can see it's highlighted if you can see this entire frame has been done framing has been done okay this yellow color frame that is done this is your parent tag that is this showing this entire thing is your parent type so everything is printed over here that doesn't name your email your role your company your country your postal code your username everything that is present over here by registering everything is present we have printed on this uh console okay so here you can see by registering you confirm similarly over here also by registering your confirm so everything that is present under this form tag is printed over here in the parent this is one way so i'll just comment this because it's printing a long message so this is the way we can do the parent app next we have the child notes i'll write slash child to colons and the asterisk mark and you can see zero child elements that is identified over here so what you're going to do again we go to parent we can go to parent the parent tag that we're using is the form slash child to colons and then we can use the asterisk and you can see we have 26 elements that are highlighted here you can see 26 elements the entire form is highlighted over here if you can see each and everything we have the name we have the email we have the role company the country the postal code the user name and all these elements are highlighted over here okay so what i'm going to do is i'll just print the number of elements that is matching over yours similarly we did in the previous so while navigating the previous web table the table that was there the dynamic table so i'll just write list and the web element driver dot find elements i'm using find elements by dot x path and i will specify the x path over here and what i want is i want to find the number of uh child nodes right plus sign notes dot size we're using the size method see the reason why i'm automating two webpages because that was a dynamic one this is a static one there is no such changes in it but you should know you should have a hang of it and it's a good practice to practice this way okay so you can automate any of the site like you can automate the facebook.com you can automate gmail you can automate the google so you can automate any one of it that's on you so let's run this command okay so our chrome browser is launched it's navigated it's maximized and the company name that is the abc company name and let's see the number of child nodes are 25 so this way we have found the number of child nodes now let's find following nodes so this is our self after the self node all the boxes that are showing over here is your following right till the end so i'll just write following and we have the 562 elements that is the country postal username this entire thing that is there right all the thing that is present over here this uh country postal code username by registering all these elements that is the 562 elements that is present over here are under your following okay similar same thing we'll do we will copy it we will write list web element so let's execute this chrome browser is launched it's navigated and it's maximized and here our country value is being sent that is in abc and the number of following nodes are 560. so there were among 500 nodes that were present so the number of following nodes that are present over here similarly we'll go for preceding okay so this is the proceeding that we have so let me just print the values of here see it's similar to the previous uh web piece that we automated so this is the same this is just for the practice purpose so open your chrome browser it's launched it's navigated it's maximized and the company name is also been sent over here and here you can see we have the number of child nodes that are given is 25 the number of following nodes is 560 and the number of proceedings that is given away is 108. okay now let's find the following siblings okay so this is the command that i've written i have written the two slashes the input the tag name the id locator that i'm using and the values company and slash following siblings and two colons and the asterisk mark so this shows the following sibling that is the country person code username and this value and the sign up following siblings means this is the form right this is the parent tag over here is the form parent tag right so under the parent tag after the company name all the values that is coming all the web elements that is identified after the company name are your following siblings whereas following means the country the postal the username this the sign up and then this login i already have a sale force developer environment all this is the following and whereas the following siblings is the country postal code username and this value in the signup value similarly for preceding let me show you the proceeding as well so this is the proceeding there are 12 elements that is the elements before the company that is the company role email name and whereas when we are finding the preceding element not the preceding sibling the preceding element we have all this also that is get your own developer addition and all all this is also included okay so proceeding here you can see in the output that we have found that there are proceedings only 108 whereas the preceding siblings is 12 elements so there is a difference between the two okay so remember that so this is the two syntax that i've written the two commas the following siblings and the preceding sibling so let's execute it this is our chrome browser's launch it's navigated it's maximized and the company name abc has been sent over here and here you can see the number of following siblings at 12 the number of preceding siblings at one okay so uh this way we have seen the child node the parent node the following node preceding nodes and all the nodes that we have study the relationship of nodes as well so to know we have covered many uh things about the x path we have covered what is the x path the different types of the x bar that is the absolute and the relative and which one is better to use then we have studied about the expert operators like the and the or operator the contains method the text method and the start swift method also we have studied about the xpath accesses so this is a simple cheat sheet which i usually uh use to refer the xpath whenever i study xpath or need to revise xpath so this is a cheat sheet which i usually um use it you can also use it while going before the interviews so let's get a hang of it so these are some of the uh methods that is used for the xpath axis like i said the two colons in the scope of and we're using the uh two slashes or one slashes now there's one thing that i need to remind you see over here you can see in the axises which is the cell following following sibling we have a two slashes specified over here it does not matter where you whether you put the two slashes or the one slash for example let me show you uh this was the page that we were navigating like suppose uh we were inspecting this page this one and we were traversing to the parent right and there's only one parent element so this one so i have used two uh slashes over here if you can see let me i'll write it in front of you wait two slashes i have used there are two slashes over here and i'm using parent two colors that is in scope of operator and a asterisk sign which is used to select all the elements right it shows all the elements so it's using it's selecting only one element is matching over here that is the form tag as i said the form tag is the parent type whereas if i use one slash i have used only one slash and parent and two colons and asterisk still the one element still only one element is matching okay so it does not matter if you uh put two slashes or one slash to it okay so next we have the slash tag name the tag name slash tag name is used to write the except x bar that we usually write that is a relative x path the syntax of it is this the two slashes the tag name at the rate the attribute is equal to value for example id and the value that we use it in country or anything then we have the contains method in the text method in the contents method we can have the two slashes tag name and the contains method and we can write at the rate attribute and the value for example at the rate id and the value that is country similarly if you want to use contains method and the text method together okay so what we're going to do is tag name contains text and then the value now here the star the asterisk which is used over here right it selects all the methods with the same value now for example if i write two slashes and the asterisk method contains text and the value that i'm writing is country so what will do what it will do is it will uh select all the value which is having country okay whereas if i'm taking tag name like for example if i'm writing input so under input tag whatever country values are present it will select that okay so that is the difference between the asterisk and the tag name that is present over here next we have the logical and in the or operator that we were using similarly we can just use and and the or the chart i also i have given the chart about the and in the or operator in which case the element will be identified in which case it will not be identified you can check it out in the previous tutorial next we have to start with the function that we're using this is similar to the dynamic functionality which we were starting in the previous tutorial the on and off button which i explained so you can write the starts with either right attribute the value whatever value is having the same value for example the start and the stop button right they have the two words that is the st was the starting value our same right so we can use that so starts with is used in that case the next we have the x path accesses that is a cell following following sibling ancestor proceeding descendant parent and child these are the uh syntaxes of all these uh self and following which we study till now so you can have uh you can study this and get a hang of it okay so this is a small cheat sheet which i usually refer while studying the expat so you can also check it out so this is all for today so this is all for today we learned about the xpath advanced expat we saw that practical implementation with the static web page as well as a dynamic table that we have seen so in this tutorial we will understand about the shadow dom objects so let's get started so before understanding about the shadow dome let us understand what is dom dom means document object model so when the web page is loaded the browser creates a tree of objects on the web page and this tree is called as dom like in the previous tutorial i explained dom is an api in which when the web page is loaded the browser creates a tree of objects on the web page like here you can see we have the root element html then we have the head we have title under the html we have the body tag inside the body tag we have the h1 the a tag and all these tags are inside the body tag right so this is a dom structure that is the document object model structure for example for example this page and if i click on inspect and here you can see this entire thing is your dom that is we're having the html head body and the div tags the input tags all this is your dom we have the head we have the we have html we have head and the body tag in the closing html tag so this is a dom structure okay now dom provides power to javascript to do some following things like they can change the elements of the page they can change the attributes of the element of the page we can add or remove elements or attributes in a page we can create new html events and we can react to those events now how do we do that let me explain you with the help of an example now uh for example suppose uh let me write html if i write html over here and i'll write the body i'll give the body tag then i'll use the p tag i'll write a text over here this is not shown this is my p tag now let me run this and here the output is on the console that is this is not shown this is the output now what if i write a javascript code i will write my javascript code in my script tag so here i will write document dot get element by id so i'll give an id over here in p tag i will write an id over here i'll write it as x 1 so the id that i'm accessing over here is x1 okay now i'll use a dom property that is the inner html is equal to welcome to programming knowledge okay now let's run this command and here you can see the output is welcome to programming knowledge now what we can see over here is that welcome to programming knowledge is overriding this is not shown okay what happens is when we write document.getelementbyid it finds this id x1 and it uh changes this element that is this is not shown is changed to welcome to programming knowledge okay so this is what is happening over here so dom provides the power to javascript to change the element to change the attributes of the element we can add or remove the elements of the web page and we can create new html events as well what is the need of shadow dom like in the previous slide i explained that dom provides power to the javascript to change the lms right now there are websites that require some web components developed by others that contains the html css in javascript code what are these web components for example like this is the online id that i'm having and here you can see these advertisements right here you can see these ads these ads are controlled by some other site okay and you can see this is facebook so this is controlled by the facebook site similarly over here if you can see we have different types of ads over here like here you can see this dell ad also if you're looking some other pages like hurry also you can see this is the microsoft exchange this is also controlled by some other site all these ads are controlled by some other side so what you're saying is that these are the web components that is developed by others that contains the html css and javascript code now for example over here this this thing that you can see this web component is having an html css or javascript code now when i integrate with my code this is the code that i am having obviously as i said dom is giving the ability to javascript to change the elements right so what if all the code that is written over here in this javascript is changing the code that is written over here in the html it's harmful right so that's the reason why we are using shadow dom over here the objective is that people want to use this web component of others but they don't want their invo they don't want to impact the sites so how do we integrate a web component from other developer so that they cannot access my component so that their component my components don't interfere how do we do that the solution is the shadow dom and iframes now iframe is something different for example suppose if i give something uh some iframe some functionality is presented over here there is some functionality over here this is functionality one and there's another iframe that i have there is some functionality too so whatever changes that i perform in functionality one will not affect the changes in the functionality too that is the feature of iframe okay this is one feature of iframe uh we will study about iframe in detail but for now to understand whatever functionality uh whatever changes i do in functionality one will not affect the changes in the functionality too this is what iframe is okay coming to the next is shadow dom now what is shadow dom since we have understood the need of shadow dom we have understood what is dom and how does dom uh provide the power to the javascript to change elements so we have understood what is the need but what is dom this is the definition shadow dom is a web standard that developers use to encapsulate their html code and style components so that no the style component can overwrite their code for example for example suppose so we are working in a group we are working in a group of four to five people and there's a project and everyone is working on different different functionality so let us take up suppose there's a use of one so this user is developing some functionality and i'll just write a code for it suppose uh div class is equal to i'll write it v and i'll write h1 tag over here and i'll write a hello world okay and i'll write some styling over here i'll give some styling so since it's a class so dot v and i'll write some color and i'll give color as red let's run this so here the output is hello world in red color okay this is the user one score now uh the user one is not knowing what the user two is coding they are working in group but differently right someone is working for some other functionality someone is working with some other functionality so this is the first functionality which the user one created so i'll just comment this for now and let's see the next example so the next user develop some of the functionality let's see some other functionality and uh i'll just write a code of it i'll write div i'll write class and now the user two does not know what the user one has coded so there might be a chance that they have named the class similar so i'll name the class as v itself then i'll write the in h2 tag i'll write hello user 2 okay and i'll write some code for css because it's a class so i'll access by a dot v and i'll write color i'll give it as green okay so let's see here the output is for the user too now since we are working in a project and we need to present it so we will integrate the code okay user1 and user2 are integrating their codes so what will happen for example the user1 and user2 has integrated their code now what will happen as we know for user one our output was hello world in red color and for user 2 our output was hello user 2 in green color so now after integrating let's see what the output is it's hello world in green color it's hello user 2 in green color which means this css style is overriding this css style right that's what is the definition of shadow dom shadow dom is a web standard that developers use to encapsulate their html code and css components style components means css components they are encapsulating their html code and css components so that no other css component can overwrite their code now in this case if user1 has given class v so there might be many classes of class we write of name v there would be very many classes of name v all those v classes will get overrided by green color right the entire text will be a green color so here the css style is overriding right so this is the definition of shadow dome so when we try to find shadow dome elements using the selenium locators it will throw no such element exception okay now how do we identify it is a shadow dom object for example i have this website this website is having the shadow dom elements so if i want to inspect this element i'll click on inspect and here you can see this shadow root open this shadow root open is used to denote the shadow dom object so uh another thing that we can see over here is if i see in selectors hub here it is it is in blue color that is in shadow dom it is here written over here so this means that this element is a shadow dom element here it is written the element inside the shadow dom and for such elements xpath won't support yes for shadow dom elements uh xpath will not support we need to inspect these elements through css selectors okay now let me give an example like suppose this is also a website which is having the shadow dom elements so if i want to inspect this element i'll click on inspect and since you here you can see we have shadow root open shadow root open shadow root open so this is a shadow dom object okay let me open my selectors hub and here you can see we have this element is inside shadow dom object and in such elements x path is not supported now what if we give an x path if i want to inspect this element let's see what error do we find so i have already created a selenium tutorials nine java class over here in which we have the first command is open the chrome browser in which we have system dot set property the key and the value is given over here next we have written web driver driver is equal to new chrome driver to launch the chrome driver next we are navigating to the url this is the url that we are navigating to and this is the element that we want to inspect so we will write a expert expert for this element okay let's see then i'm maximizing the window and this is the expert that i have written over here like i've written driver dot find element by dot xpath two slashes and the tag that i'm using is the input tag here you can see we have input tag also sele the attribute that i'm using is the id attribute and the value of it is input so the id attribute and the value is input and i'm sending some command as testing so let's see if we can run this code and what error do we find so so our chrome browser is launched it's navigated and it's maximized can you see some text over here no right so here there's an error let's see what that error is we have no such element exception that is no such element unable to locate this element we are unable to locate this element this is shown over here this is the error that we are getting and there is no text sent over here do you see any text no right there is no text sent over here so it says that is unable to locate element so whenever we locate we try to locate the shadow dome elements this is the error that we find that is the no such element exception is given over here and shadow domes does not support the x path okay we have to use a css selector to access shadow dom objects also to access shadow dom elements we need to use we have to use the javascript executor we will understand that by implementing it next there are some terminologies in shadow dom while inspecting the element while identifying it these terminologies will be used one is the shadow horse that is the regular dom node that the shadow dom is attached to this is the shadow host right it is the regular dom node that the shadow dom is attached the shadow dom is attached to shadow host next we have the shadow tree the dom tree inside the shadow dome this is the shadow tree that we are having here you can see this highlighted part this is the shadow trees that we are having it is a dorm tree inside the shadow dom inside the shadow dome these are the dom trees next we have the shadow boundary here you can see this is the shadow boundary this is a place where the shadow dome ends and the regular dome begins okay so this is the place where the shadow dome ends and the regular dome begins next we have the shadow root that is the root node of the shadow tree now this is the most important element that we are going to inspect like suppose if you want to inspect this element we will inspect the shadow root we will inspect the shadow host so we will understand that but for now these are some of the terminologies that is used in the shadow dom structure so uh now how to identify it like i have showed you before like we have the shadow root written over here that means it is a shadow dom object also if we go on selectors huh so over there there it has a feature it shows in blue color letters in shadow dome it also gives a information about that relative x path is not supported that is this element is in shadow dome and for such elements xpath is not supported so this is one way to identify the shadow dom object now next we will understand its implementation let us do a practical implementation on it so this is the website that we need to automate and this is the element that i am inspecting so i want to enter some value over here any value i want to enter so this is the element now before writing the code for it we need to understand the elements that are under shadow dom and which are not under shadow dom okay so this is the dom structure which we have this is the entire dom structure we need to understand it first this is the element that we want to inspect okay which is not under shadow root the elements that are under shadow root is style div div slot name these are the elements that is present under shadow root this input is under book input decorator top okay this book input decorator top is not under the shadow root if you are thinking this is under shadow root because the shadow root is written over here no if we click on this we can see the style and the slot tags are under the shadow root but the book input deck or top is not under the shadow root okay so this book input decor top is under the app toolbar so this book input decker top is under the app toolbar and this app toolbar is not under the shadow root can you see anything can you see the shadow root the shadow root is present over here in which we have the style and the div tags okay so this app toolbar is not present under the shadow root this book input echo is present into app toolbar okay next this app toolbar is present under the app header this is the app header okay which is inside the shadow root here you can see the shadow root now if i click on this we can see app header right so app header is under the shadow root and then we have the app book which is the host here we can see the root element and this is the host element right so first we will go on app book we will inspect the app book then we will enter the shadow root element after entering the shadow root we will move to app header after app header we will go on app toolbar after app toolbar we will go on book input decor and after in book input record we will inspect this element okay this is the element that we want to inspect right so this will be the entire process the first thing is that we have to identify the host this is our host this is the root element right so first we will inspect the app book then we will enter the dom element inside the dom element first we will enter the app header after app header we will inspect the app toolbar and after app toolbar we will inspect the book input decor and then we will inspect the inputs uh tag okay okay so this is the element that we want to inspect right this input is the element that we want to inspect this input is under book input okay this book input is under the app toolbar and this app toolbar is under the app header okay this app header is under the shadow root this is our route and this is our host and this is our host so the first thing that we will inspect is this the host this is the second thing we will do we will enter the dom inside dom this is the third thing that we will inspect that is the app header after app header we will go on app toolbar this is the fourth thing that we will inspect after app toolbar we will inspect the book input record this is the fifth thing and the sixth one is the input slot over here we will send the commands because it's the search box we want to send some command to it so after all these steps we can inspect this so this is the entire thing that we're going to implement now first we will inspect the host then we will enter the root the shadow root after entering the shadow root over here we will use a javascript executor after here over here after this we will access the app header after app header we will access the app toolbar we will inspect the app app toolbar after that we will inspect the book input record and then we can move on to input okay so this is the entire process that we're going to follow so let's do that so first let's inspect the host we will write a driver dot find element by dot tag name over here we're going to write this is our host right so we are inspecting our host the tag name is book app so i will write book app over here this is a web element i'll write web element host is equal to driver dot find element by dot tag name okay next we will enter the dom okay for that we need to write javascript executor j is equal to driver because this driver is of web driver driver is equal to new chrome driver so i'm going to write i'm going to typecast it so i'll write javascript executor driver okay next i'm going to do j dot execute script which accepts two arguments one is the string and one is the object argument so here in string i will write return arguments the zeroth one and where do i want to enter is i want to enter to shadow root right so i'll write the shadow root the zero shadow root uh shadow root is present in the host element right so i'll write comma host okay now i'll give this a web element i'll write shadow dom is equal to says we need to cast it to web element now just because this is of javascript executed type we need to cast it to web element because i want to inspect web elements over here okay now whatever we're going to do we're going to do inside the shadow dom okay this is the shadow dom we inspected the host element we are and we inspected the shadow root element so we are inside shadow root now now inside shadow root inside the shadow root what i want to inspect is app header now okay so what i'm going to do is this is the app header i will write shadow dom dot find element by dot tag name and inside the tag name i will write app header and i will give it as a web element app header okay so so far uh we have inspected our host we are into our dom element also we have inspected the app header now we are left with the app toolbar the book input decorator and then the input slot so after navigating to app header we need to enter the app toolbar okay so what i'm going to do is i will write app header dot find element by dot now this app toolbar there are two app toolbars here you can see this one and this one right so here the class name is different so we will access by class so we will use the css selector over here so i'll write by dot css selector and then i'll write input oh and then sorry i'll write app toolbar because it's a class so i'll write dot and the toolbar bottom okay so this is my tag name and this is my class i'll give a web element i'll name it as app tool okay so so far we have navigated to host we have inspected our host then we came into our dom element after that we navigated to app header and after which we came to app toolbar this is the app toolbar that we key now inside the app toolbar we want to go to the book input decorator so we're going to write this is the book input so what i'll do is i'll write app tool dot find element by dot tag name and i'll write the tag name over here i'll give this a web element i'll write a web element for your web element book is equal to app tool dot fine element okay so now we will inspect our element that is the input tag so what we're going to do is we'll write book dot find element or let us use a css selector so i will use the css selector i'll write by dot css selector so we can use this is the tag and the id that we have is input so i'll use input input input because it's a id so hash input and what value do i want to send i want to send some key to it i will send selenium web driver okay so let's run this so a chrome browser is launched it's navigated let's maximize and here you can see that the command is sent that is the selenium webdriver okay so uh this is what is shadow dom is as i said first we need to find the host element so our host element was book app then we entered the shadow dom after entering the shadow dom we have to inspect the app header after app header we inspected the app toolbar after which we inspected the book input decorator and then we inspected the input tag so here you see uh first we need to understand the dom structure before writing a code for the uh shadow dom we need to understand which elements are under shadow dom and which elements are not under shadow dog so this is one way so this is how we're going to do it now there are different sites where you can practice shadow dom like you can use the chrome download page as well this download page is also having shadow root elements for example like if you want to inspect this download here you can see we have shadow root elements this is the shadow root this is shadow road this is shadow root also uh there are different ways websites like um let me show you one like this is the website that is there for shadow dom practice like all the elements that are present over here are of shadow dom here we have shadow root we have shadow roof we have shadow roots so you can have a hang you can practice on this website also so i'll give all these links in the description so you can get a hang of it so in the previous tutorial we learnt about the shadow dom objects in this tutorial we are going to understand some of the important selenium commands which is frequently used to write the test scripts now these selenium commands consist of the browser commands the navigation commands and the web element commands today we are going to understand the browser commands like what are browser commands what are the different types of browser commands with their syntax also we will implement some set of test cases and then we will understand the difference between the close method and the quick method so let's get started now first let us understand what are browser commands browser commands are something that are very basic operations of the web driver which includes the closing of the browser performing some few tasks to see you task is like get title to quit to manage to close the browser to get the current url to get the page source so these are some of the uh operations these are some of the few tasks that we perform on the selenium webdriver so and these are some of the list that is given over here this is the list that is given over here now if you write for example if i write driver dot you can see this list so these are the different this list which is getting highlighted over here so these are the different browser commands that is present over here okay so these are browser commands now i have just created this basic uh uh notes this basic sheet which consists of the browser commands the navigational commands the web element commands which consists of the commands the description the syntax and what parameters accepts and what it returns it will be very quick recap for you while going in interviews because they frequently ask these questions like what is the difference between the close the quit method the submit and the click method and what is the difference between find element and find elements so these are some of the differences which we will cover and also we will study these commands so uh this is the sheet that i have prepared i will give the link of this sheet in the description box you can download the pdf format also i have uploaded on my drive so i will give the link of this drive as well so you can get a hang of all those commands whenever you go for interviews now coming to the test cases these are the test cases which we will execute and while executing we will cover these commands these are the commands like the get the get title the get current url to get paid source to close and the quit now get window handle and get window handles is a part of the browser command but it is a bit complicated i will cover that in the later tutorial so for now we need to get a hang of get get title get current url get paid source close and quick so by executing these test cases we will create the test scripts of these test cases we will understand these commands also okay first test case that we have is the open the chrome browser okay in which we use the system dot sell property and uh the web driver driver is equal to new chrome driver these are the two commands that we use in opening the chrome browser then navigate to the url to navigate to the url we use the drive.driver.getcommand right so this is the part of the browser command next we will maximize the window the next we will verify the current url of the page for this we will use the current get current url command okay through if statement okay then we have to verify the title of the page now to verify the title of the page we will use the get title command okay and we will verify it through if statement next we will print the length of the title of the page and this we will use the length command we'll have a look at that okay next we will print the page source of the page in which we will use the get page source command also we will print the length of the page source okay next we have to close the browser and quit the browser now uh we will understand the difference also uh practically okay so this is the webpage that i want to automate today now i have created a java class in my package combat selenium in which i have named it as selenium tutorials then i'll be executing my test scripts over here in this in this selenium tutorial 10 the first test case was to open the chrome browser for which we use the system.set properties in which we give the key and the value the key is the webdriver.chrome.driver and the value is the executable chrome driver file okay next we have the web driver driver is equal to new chrome driver why do we write the statement i have explained in the previous tutorial you can have a look at that tutorial okay the next command is that we have to navigate to the url so what i'll do is i'll write driver dot get and i will write my url in this get this is the first method okay to navigate to the url the second method that you can do or you can navigate is i can assign the url to a string variable like i'll write string i will name that variable as url and i will place my url in this variable next i will write driver dot get url so i can navigate to the url through this way as well as this way both the ways it will work for example so let's see whether we can navigate or not so by using this method driver dot get method okay so chrome browser is launched and also it is navigated to this page i will comment this and let's see okay so i chrome browser is also known so net is also navigated so these are the two methods to which you can navigate to the url now get method i will just comment this for now we will use this driver.get method now uh get my turn on this commands open the specified url in the browser it accepts string as a parameter and it returns nothing okay and this is the basic syntax of navigating to the url and it is a part of the browser command so next test case that we have is to maximize the window so i'll write driver dot manage dot window dot maximize okay so the next command is verify the current url of the page url of the page let's first find the url and then we will verify so i'll write driver dot get current url and i will store this in a string variable string url of the page and i will print this okay let's see what is the output so chrome browser is launched it's navigated it's maximized and here it is the url of the pages this this is the url of the page now let's verify the url to verify the url we will use the if statement so i will write if url of the page dot equals now i will write the url over here now if i was uh executing this statement this navigation statement what would i do what did i do over here is that i have written string url right so what would i do over here i will simply write url okay so this means that the url of the page that is the output that we are getting the actual output and the expected output will be matched the expected output is this this which is stored in this url variable and the actual output is stored in the url of the page right so if i would execute this statement i would have written this way but since i'm executing driver.getcommand i'm not writing it this way i'm not storing it in a string variable and then writing driver.get and inside get i'm writing the url the parameter that i'm giving is the url that is a string parameter so i'm not executing it this way i'm executing through driver.getcommand so i'm not writing it this way so i'll just simply write what output do i want this is the expected output that i'm writing over here and the actual output that i'm getting is the url of the page okay now if the actual and the expected matches so what i want is i want the output as the url is verified and then else i want the url is not verified so now let's execute this so my chrome browser is launched it's navigated it's maximized and now let's see the url of the pages this is the url and the url is verified that means the actual url that we are getting that is this and the expected view url that is this both is matching okay this is the expected url and this is the actual url both are matching that's the reason why we have called the url is verified for example if i just write it this way now let's see if it works so my chrome browser is launched it's navigated it's maximized okay and here you can see the url is not verified why because my actual that is this is my actual and the expected is not matching that's the reason why the output is the url is not verified the next test case is verify the title of the page so first we will find the title of the page so i'll write driver dot get title and i will store this in a string variable i will write string title is equal to driver dot cat title next i will print it so let's execute it my chrome browser is launched so here it is see this is the url of the page the url is verified and then here the title of the page is tools qa this is the title of the page now how do you see the title of the pages so i'll just inspect and you're in the head tag here you can see you can see title tools qa title this is the title of the page this is the title of the page and the title that we got is the tools qa so this is how you can find the title of the page on the web page okay next we have to verify the title right so i'll use the if statement i'll write if title dot equals okay so this is the title let me copy this and the output that i want if the actual and the expected is matching the title is verified in the else statement i will write the title is not verified okay so here uh we are verifying the title of the page so let's see let's see the output of it so my chrome browser is launched it's navigated it's maximized and here you can see the title is verified because the expected output and the actual output is matching okay so now next test case that we have is we need to print the length of the title of the page okay to print the length of the title of the page we're going to use the length command so what i'm going to do is i'm going to write driver dot get title dot length okay and i will store it in the integer type of variable because the answer that we're going to get is an integer so we i'm going to write int and title length is equal to driver.gettitle.length and let's print it so let's execute this so my chrome browser is launched it's navigated it's maximized and let's see the length of the title of the page is seven now it is seven because uh this is one two three four five six seven so the length of the title of the page is seven so now the next test case that we have is to print the page source of the page now for that i'm going to write driver dot get page source i will store this in a string type of variable string i will write ps is equal to driver dot page source next let's print it okay so now let's execute this so my chrome browser is launched it's navigated and it's maximized and here you can see the page source this is the entire page so that here you can see is this it prints the entire code of the page okay so it's quite long now we have to print the length of this right so what i'm going to do is i'm going to write driver dot get paid source dot length and i'm going to store it in the integer type of variable so i'll write in its source length is equal to driver.getpagesource.length okay now let's print it the length of the page sources length so this is the chrome browser now let's see here this is the length of the pesos now we we won't sit and count but since it's too long so this is the length of the page source now the next test case that we have is we have to click on the new tab right so we use the click command over here the click command is not a part of the browser command it is a part of a web element command but since we have to know the difference between the close and the quit so we are going to execute this command now this is the new tab command so i'll just inspect this and go to selectors hub here i can see the relative x path i'll just copy this relative x path i will write driver dot find element by dot x path and i will place my relative x path over here and what i want to do is i want to click so i right click and let's see so my chrome browser is launched it's navigated and it's maximized and the new tab is clicked so here you can see there is a new tab okay so first we will see the close command okay now if i write driver dot close just look at it very closely so i'll just write thread dot sleep and i'll write 100 over here so that you just get to know that how close method works okay it adds the exception towards interrupted exception over here and we're going to use a thread.sleep now thread.sleep is used in multithreading if you know your javascript concepts really well we you we use stand.sleep it causes the currently executing threat to sleep for some specified time so here i have specified the time of 100 milliseconds so now let's see the output i want you to closely look at the how driver.close works so our chrome browser is launched and the new tab is open and here you can see there was a parent tag over here the before tag okay let me increase the timing over here so my chrome browser is launched it's navigated now this is my parent tab and this is my child tab now let's look at it this tab will be close to close dot driver command if you can see let me show it you again i am executing the command now this is my parent tag that is this browser windows is my parent tag and this is my child tag now through driver.close the parent tag will be closed but my child is still open okay now i'll write now i will commend this and i will write driver now we'll use the quick method so i'll just write driver dot quit and i will write thread dot sleep okay now let's run this command so my chrome browser is launched it's navigated and this is my child tag that's my parent tag and you will see driver dot quit closes both the tabs so uh this is the parent tag now here when we perform the driver dot close command and the driver dot quit command there are two tabs okay uh this is the parent tab and here when i click on new tab this is the child tab okay so when i write driver.close command it will just close the parent tag it will not close the child tab okay whereas when i write driver.quit command it will close the parent tab as well as the child tab so let's have a recap of what we have done till now now the first test case was to open the chrome browser in which i have written the system.set property in which i have given the key and the value the key is given that the webdriver.chrome.driver and the value is the chromedriver executable file next we have to navigate to the url we can navigate to the url through two ways the first way we can do driver.getcommand now this java.getcommand this opens a specified url in the browser and this accepts a string as a parameter here you can see this is a string as a parameter and it returns nothing okay so this is the first method where we can write the driver.getcommand the getcommand is a part of the browser command and the second method that we can you is use is the we can assign the url to a string variable now here i have created a string variable like i have create string url and i have assigned the url to the string variable and then i have written driver.get and i have written this variable in my get the parameter that you are using is the string okay so basically it accepts string as a parameter and it returns nothing this is about the get command next we have maximized the window for that we have used driver.manage.window.maximize method okay next we have to uh find the url of the page what is the url of the page this is the page and this is the url so we have to find the url of this page so for that i have used the get current url method now this method fetches the string representing the current url which is opened in the browser okay and uh this accepts nothing as a parameter there is no parameter given over here but it returns a string value here you can see in the output here you can see in the output the url of the page so it returns the string value and it accepts nothing as a parameter and what does the get current url method does it does it fetches the string representing the current url which is open in the browser this page was opened right so it was fetching this string this is the current url of the page so for that we have given a string variable that is a string url of the page and i have written driver dot get current url and i've printed the url over here now to verify the url i have used the if command in which i have written the url of the page in which i am getting the actual output and here i am matching the actual and the expected output i'm using the equals method dot equals now i'm writing over here the expected output that i want now if the expected and the actual output matches the output will be the url is verified and if not the url is not verified now here it's matched so it is written the url is verified so the next is that we have to find the title of the page and we have to verify it now to find the title of the page i will be using the get title command now the get title command is used to retrieve the title of the web page that the user is currently working on now this is a page now when i inspect this here in the head tag you can see the title and here it is this is the title of the page that is the tools qa this is the title of the page okay now to get this title i have used the get title command which retrieves the title of the web page now it accepts nothing as a parameter can you see any parameters no right so it accepts nothing as a parameter but it returns a string value here you can see the value the title of the page is this this is the string value that it is returning so to get the title of the page i have written string title i have created a string variable a title i have named as title and i've written driver.gettitle the title is stored in this string variable then i am printing the string variable over here to verify it i am using the if statement first i will write the actual output that is the title dot equals the expected output that i want the expected output is our year this is the expected output okay so here the expected output is written when the expected and the actual output is matching the output will be the title is verified and if not the title is not verified like here you can see the title is verified now to print the length of the title i'm using the length command okay what i'm going to do is i'm going to create a integer type of variable and i'll name it as integer length and i'll write driver dot get title dot length by writing length i am actually fetching the total length of the title it returns the length of the string okay now uh to print it i'll write system dot out of println the length of the title is and i'll write the variable that is the title length and here the output is the length of the title is 7 okay next is the page source now basically page source is a command it is a browser command which uh returns the source code of the page so this is the page and uh this is the entire source code of the page so it will return this entire source code of the page so for this we'll use the get page source and this get page source it accepts nothing as a parameter is there any parameter over here no right so it accepts nothing as a parameter but it returns a string value and the string value this is the entire string value that is given over here now to print the pace to source what i have written a string ps is equal to driver dot get page source i have used the get paste source command and i will print this variable this uh string variable then to find the length of the page source what i have done i have used the length uh method i write driver.getpaidsource.length and i store this length in the integer type of variable named as ph length and i've printed over here so the total length is displayed over here this is the total length so these were the commands the browser commands next we will learn about the click and the uh next we will learn about the close and the quit command the difference between the close and the quit method okay for that we will click this new tab so first what did i do is i clicked this uh new tab so for that i inspected this element and i wrote the x path and i have performed the click operation on this web element next to differentiate between the close and the quit what i did is let me execute this again first i have written driver.close now then i have written thread.sleep which causes the currently executing thread to sleep for specified time for example here i have written the 5000 milliseconds okay now let me execute this command and see the difference again so my chrome browser is launched it's maximized this is my parent and this is my child tab my parent tab will be closed so this is close driver dot close which means that the method terminates the current browser window okay whereas in quit it will terminate all the browsers so let's execute this so my chrome browser is launched it's navigated and here you can see this is the new tag and through driver.quit both the tabs are closed okay so uh this is the major difference between the close and the quit the close in both these commands they accept nothing as a parameter and it returns also nothing as a parameter this simply closes the tabs and the windows so this is all about the browser commands that we have studied till now we have studied about the get then we have studied about the get title the get current url and we have studied about the get page source then we have learned the difference between the close and the quit command now let's understand the difference so the driver.quick command closes all the browsers whereas the closed method shall close the browser which is in focus that was the parent tab was in focus right so it closes that browser which is in focus now the quick method closes all the active web driver instances whereas the close method closes the active webdriver instances so this is the difference between the quick and the close command so in this tutorial we will understand what are the navigational commands what are the different types of navigation commands with their syntax we will implement some test cases also we will understand the difference between the navigate.2 command and the get command in the previous tutorial i explained about the browser commands you can check out the tutorial i'll give the link in the description box we will understand what is the navigation commands today so first let us understand what is navigation commands now the web driver provides some basic browser navigation commands that allows the browser to move backward forward or to refresh the browser see here you can see these buttons that is the back and the forward and the refresh so we will be handling these buttons through selenium webdriver like for example suppose if i type a selenium web driver i have navigated to this space right now what if i want to go back so i'll click on the back button if i want to move forward i'll click on the forward button and if i want to refresh the browser i will click on refresh right so these are the buttons that we will be inspecting today for that we have the navigational commands now how do we find it's a navigation command we simply write driver dot navigate dot and the commands that is highlighted over here are the navigational commands okay also i have prepared the sheet over here in which i have written what are the navigational commands their description their syntax also what parameter it accepts and what it returns i will give the link in the description box just by clicking it you can download the pdf also i have attached the pdf in my drive so i will give the link of this drive as well so you can get the access of the navigation commands in pdf format also the test cases that we are going to implement today so moving on to the test case today we are going to implement two test cases this is the first one and this is the second one so the first one says that first we have to launch the chrome browser then we have to open the amazon website maximize the window and then we have to navigate to the ebay website through driver.navigate.2 command then we have to enter some value in the search box we will refresh the page we will navigate back then we will navigate forward and then we will close the browser this is the first test case that we will implement today so open your intelligent idea ide now under package com.selenium i have already created a java class i have named it as selenium tutorial 11 so first is that we have to launch the chrome browser the test cases says that we have to launch the chrome browser for that we have to write system.set property in which the key is the webdriver.com.driver and the value is the executable file of the chrome driver next i will write driver web driver driver is equal to new chrome driver so the next command is that we have to open the amazon site we will be using the driver.get command so i will write driver dot get and i will write my url over here that is the amazon website i'll simply copy this and i'll paste it over here okay the next command is to maximize the window so i will write driver dot manage dot window dot maximize okay this will maximize the window the next the next test case is that we have to navigate to the ebay website so we will be using the driver.navigate.2 method okay so i will write driver dot navigate dot 2. so i'll write my url over here this is the url i'll simply copy this and i'll paste it over here now the driver.navigate.2 method it loads a new page in the current browser so this will be loading a new page in the current browser the same browser in which it is loading amazon it will load the new page that is the ebay page in the current browser and it will accept the parameter that is the string parameter is accepted over here you can here you can see we have written the string parameter over here and it will return nothing okay so let's execute this so my chrome browser is launched it's navigated to amazon and then it's navigated to ebay i'll simply write s out okay so now let's execute so my chrome browser is launched it's navigated to amazon it's maximized and then it is navigated to ebay through driver.navigate or to method okay and here you can see the output that is it's opening the amazon page through driver.get and then it is navigated to ebay through driver.navigate.2 method okay so so far first we will open the chrome browser then we are opening the amazon page then we are maximizing the window then we are navigating to the ebay page through driver.navigate.2 command okay so the next test case is that i have to enter some value this is the search box i have to enter some value in it so i'll just inspect i'll click i'll right click it and here here i can see there's selectors up so i'll just click on copy relative xpath i'll write driver dot find element by dot x path and i'll write my x path over here and since i want to send some commands so i'll write send keys and i'll write tshirts for men okay so i have entered some value and then i have to refresh it it's the same as here you can see there is a refresh button right so if i write tshirt for men and then i refresh it here you can see there is no text type that means it is refreshed so what i'll do i will write driver dot navigate dot refresh through this command my browser will be refreshed so i'll just write thread dot sleep and i'll write some time over here i'll write refresh the browser okay so next is that we have to navigate back to amazon so i will just write a driver dot navigate dot back okay and i'll give some time over here i'll just write thread dot sleep and i'll give some time over here which is navigate it back to amazon okay so let's run this so my chrome browser is launched it's navigated to amazon and it's maximized then it's navigated to ebay then tshirts for men is sent it's refreshed and here you can see it's navigated back to amazon here it is opening the amazon page first we will open the amazon page through driver.getmethod then we navigated to ebay through driver.navigate.2 method then we have refresh the browser and then the page is navigated back to amazon now this driver.navigate.back method is used to return to the previous page in the browser's history in our browser history the previous page was the amazon page so it was returning the amazon page okay and it accepts nothing as a parameter here there is no parameter and it accepts nothing as a parameter also it returns nothing okay similarly uh the refresh browse the refresh command that that is the driver.navigate.refresh method this acts similar to the refresh button of the browser like here you can see this is the refresh button of the browser this acts similar to that button and it accepts nothing as a parameter and it also returns nothing as a parameter our next test case is that we have to navigate forward to ebay so i will write driver dot navigate dot forward i will also write thread dot sleep i will give some time over here then i want to print so let's execute this so my chrome browser is launched it's navigated to amazon it's maximized and then it's navigated to ebay tshirts for men is sent it's refreshed and it's navigated back to amazon then again it's navigated forward to ebay next our next test case is that we have to close the browser so i will write driver dot close we'll not use the quit command because there is no window or any tab open see here all the operations are performing in uh the current tab only there are no other tabs that is opening like if you're thinking like for amazon is one tab the ebay is the other tab no it is opening in the current browser and all the operations is performed in the current browser only that is it is navigating back or forward in the current browser so that's why we are writing driver.close so i'll execute this again my chrome browser is launched it's navigated to amazon it's maximized it's navigated to ebay tshirts for men is sent and it's refreshed it's navigating back to amazon and then again it's navigating forward to ebay and it's closed so far first we navigated to ebay from amazon to ebay we navigated through driver.navigate.2 method now this method loads a new web page in the current browser window and it also accepts string as a parameter but it returns nothing that is the driver.navigate.2 method okay next after uh navigating to ebay we entered some text values we entered some values in the test search box and then we refresh the browser the refresh method it does the same operation as clicking on the refresh button on the browser when we click the refresh button on the browser it does the same operation and it accepts nothing as a parameter also returns nothing next we were navigating back again to the amazon website since we were on the ebay website and we were entering some value and we refreshed the page then after that we navigated back to the previous page we use the driver.navigate.back command which is used to return the previous page in the browser's history okay and it accepts nothing as a parameter it also returns nothing else next after uh navigating to back command we are in on the amazon web page on the amazon website we navigated forward to the ebay page that is the next page okay all the operations are performed on the current browser only there is no other new tab or window that is opened it is on the current window itself so for the forward we use the driver dot navigate dot forward method in which we move forward to the next space that is the ebay page and the forward command it accepts nothing as a parameter and it also returns nothing so this is all about the first test case now let us execute the second test case so now let's execute the second test case just open your intelligent idea id and i have already created a java class that is the selenium returns club java class in the package com.selenium and the first test case that we're having is that you have to launch the chrome browser for which i have written system that set property i have given the key as the webdriver.chrome webdriver and the value is the chrome driver executable file next i have written web driver driver is equal to new chrome driver the next test case is that we have to navigate to the page and this is the page that we will automate today so i will use driver dot navigate dot to command and i will insert the ui level here that is this is the url now this driver.navigator2 command it accepts string as a parameter and it returns nothing so let's execute this so my chromebook is launched it's navigated to the webpage.com okay so the next command is that we have to maximize the browser so i will just write driver dot manage dot window dot maximize through this command my window will be maximized next test case is that i have to inspect this element that is i have to click on this button that is a get start button so i'll just right click on it and i have this selectors hub option over here i'll click on copy relative expat this tool is amazing that is the selectors up tool you can just simply right click on any element and you will get the option over there like selectors up and you can copy your related x path over here okay so i'll just write driver dot sign element by dot x path and i will paste my relative x path over here and since i want to click on this button so i will click on clip method so let's execute this so my chromebook is launched it's navigated to the wordpress website it's maximize and here it's the button is click that is the get start button is click develop okay so now next is that i have to navigate back to the home page so i'll just write driver dot navigate dot back i'll also give some time over here so i'll just write thread.sleep now let's execute so my chromebook is launched it's navigated to wordpress let's maximize the button is clicked and it's navigating back to the home page okay so the next command is that we have to again go back to the get start page so i'll just write driver dot navigate dot forward and i'll give some time so i'll write a thread dot sleep and i'll specify some time over here that is 5000 and then let's run this command so my chromebook is launched it's navigated to the wordpress website it's maximized and the button is clicked we're navigating back to the home page we are navigating forward to the get start page okay next is that we have to perform the refresh operation so i'll write driver dot navigate dot refresh and then we have to close the browser so i'll write driver dot close we specify some time over so i'll write thread dot sleep and here also i'll write thread dot sleep now let's execute this so my chrome browser is launched it's navigating the wordpress website it's maximized okay so that get start button is clicked we're navigating back to the home page navigating forward to the get start page refresh and the browser is closed so this is all about the navigation commands in which we have the navigate to method which loads a new web page in the current browser window and it accepts string as a parameter returns nothing next we have the refresh command which works same as the refresh button of any browser this is the refresh button of the browser and the syntax is that the driver.navigate.refresh and it accepts nothing as a parameter and it returns nothing next is the back command used to return the previous page in the browser's history the syntax is that the driver dot navigate the back command and it accepts nothing as a parameter also returns nothing next we have the forward command we will move to the forward page through driver dot navigate the forward command so these are the navigation commands that we have studied today also we have executed two test cases out of it next let us know the difference between the driver.navigator2 and the driver.jet since when we write driver.navigator2 uh and we write the url over here it performs the same operation also when we write driver.get it performs the same operation but yet they both are different okay now the driver.navigator2 command it is responsible for redirecting the page and then returning immediately like through driver.navigate we can navigate to forward we can now draw we can write driver.navigate.back then we can write driver.navigate.refresh but is there any command like driver.get.forward no right there is no command as such so driver.get is responsible for loading the page and it waits until the page has finished loading that's it that is what driver.get is responsible for whereas driver.navigate is responsible for redirecting the page we can perform the navigation uh operations like we can move forward we can move backwards and then we can refresh the browser so this is what is driver.navigate responsible for also the driver.navigator2 command it tracks the browser history and can perform back and forth in the browser like we have seen in the test cases we were performing the back operation and the forward operation so it tracks the browser history whereas the driver.get does not track any of the history of a browser like through driver.get.forward there's no such command so it is not tracking any of the history of the browser so these are the major difference between the driver.net driver.navigate command and the driver.get command so this is all for today in the next tutorial we will understand about the web element commands i have also provided this sheet in which i have written the commands description syntax and what parameter it accepts and returns i will provide the link in the description box you can directly download the pdf format also the link to the drive also i will provide in the description box so it will be very useful for you to revise during your interviews so this is all for today so in this tutorial we will understand some of the web element commands we will understand the different types of web element commands with their syntax also we will implement these commands then we will understand the difference between find elements and find element also we will understand the difference between the is displayed is enabled and is selected method and click and submit method so let's get started first we need to understand what are web elements command to understand what is web element command we need to understand what is web element anything that is present on the web page is called as a web element for example the text boxes the buttons the drop down menu the radio buttons etc everything is called web element to interact these web elements we have the different types of locators like the id name class the xpath i have explained that in the previous tutorial the web element commands are the list of actions that can be performed on various web elements these are called as the web element commands now here you can see these list of web element commands that is the click clear the find element the find elements the get attribute the get css value also i have prepared a document in this document i have mentioned the commands the description the syntax and what parameter it accepts and what it returns also you can get this document in the pdf format i have attached it to the drive i will give this link in the description box also i will give the direct link to download as a pdf so these are the commands like the clear click the submit the send keys and the element visibility methods and also these get text get tag name the get css get attribute get size and get location so these are the different web element commands and we will be understanding these commands today through set of test cases this is a test case that we're going to implement today and this is the website that we're going to automate today so first open your intelligent idea id so i have created this java class selenium tutorial 13 under package comrade selenium and the first test case says that i have to launch the chrome browser for that i have written system.set property in which i have given the key that is the webdriver.chrome.driver and the value is the executable file of the chrome driver next is the webdriver driver is equal to new chrome driver so these two commands will launch the chrome browser our next test case is that we have to open the url so i'll be using driver.get i'll insert the url that i want to navigate to this is the url so i'll copy this paste it over here and then i will maximize the page for that i will write driver dot manage dot window dot maximize now let's execute this so my chrome browser is launched it's navigated and it's maximized so my next test case is that i have to enter the username and password so this is username and this is the password i will inspect this element i'll simply click on inspect and here you can see we have the id name attribute so i'll use the id attribute i'll write driver dot find element by dot id and i will mention the id over here and here i'll be using the send keys command now the send keys command accepts the character sequence as a parameter and it returns nothing so the character sequence that i want to send over here is the username the username is given here so i'll simply just copy this i will paste it over here and this is the character that i want to send to username next i'll write driver dot find element by dot id the next element is the password so i'll inspect this the id i'll copy it over here and the operation that i want to perform over here is that i want to send some character sequence to the password field so here i will write the password the password is given over here so i'll simply copy this and paste it over here so this is the first web element command that we learnt is the send key so here you can see we have send keys now this send keys stimulates the typing into an element which may sets its value this is the syntax this is the parameter that is the character sequence it accepts as a parameter and it returns nothing so let's execute this so my chrome browser is launched it's navigated it's maximized and the username and the password is send so our next test case says that we have to clear the username and the password that we have entered for that we'll use the clear command okay so i will simply write driver dot find element by dot id dot i'll use the clear command it accepts nothing as a parameter it also returns nothing next i want to clear the password so i'll write driver dot fine element by dot id dot clear command now let's execute this so my chrome browser is launched it's navigated it's maximized and my username password is entered so here you can see the username is cleared and the password is also cleared okay so this is the next web element command that we have learned so this is the next uh web element command that we have learnt is the clear command this will clear the value this is the syntax and it accepts nothing as a parameter also returns nothing okay so our next test case says that we have to submit the login button so here comes the difference between the click command and the summit command these two commands for that i have an example let's understand that with the help of the example first and then we'll perform the test case to understand the difference between the summit and the click this is the page that i have made there are two divisions present over here one is the outside form tag and the second division is the inside form type in the outside form tag there are two buttons as well as in this inside form tag there are two buttons that is the submit button and the button the first one is of type submit here you can see this is input type submit and this is of type button okay so when i click on this this shows that the submit button outside the form tag and this is a button outside the form text similarly when i click on this this shows that this is a button inside a form tag and this is a button inside the form tag so now i created this page just to understand the difference between the click and the submit method okay so uh i have already created a java class i have named it as difference between submit and click i have opened the chrome browser i navigated to this page i maximize it the first operation that we're going to perform is the click operation and then we will perform the summit operation and then we will see the difference between the two so the first operation is the click operation and i inspected the outside form tag division first okay in which i click the submit button and the button so let's see let's execute this so my chrome browser is launched submit button is clicked then i navigated back then the button is clicked and it is navigated so my click method works for a submit button and the button which is outside the form tag now let's see whether it works for the inside the form tag or not so i have written this code for the inside the form tag in which i have inspected the uh submit button and the button through id locator and i have also written driver.navigate.back command just to navigate back to the page and i have also written thread dot sleep uh which shows the time so that it slows down the execution and we get to know what is actually happening so let's execute this here my chrome browser is launched it's navigated to this page it's maximized so this is the button inside the form tag the submit button is clicked it's navigated back so the button is also clicked and it's navigated back so here we can conclude that the click method is having no restrictions that is you can use click method to click on any button if it is of element of type button or of type submit the click will work for both okay whether it is outside the form tag or whether it is inside the form tag now let's see the summit to understand the submit method this is the first division that we are having the outside form tag so we will inspect this element first and let's see what the output is so i have written driver.find element and by dot id i have specified the id and the submit method and then i have written thread dot sleep to understand the execution so now let's execute this so my chrome browser is launched it's navigated it's maximized and here you can see there is an exception over here there is an exception of javascript execution the javascript error error unable to find moving document okay so this shows that the submit button will not work for a summit type of element outside the form tag now let's see if it works for the button type of element or not so i have written over your driver.find element by dot id and this is the id and i will use the submit method over here and i have given thread.sleep just to see its execution so that you can pause for some time and let's execute this my chrome browser is launched it's navigated it's maximized okay so again here you can see we have a error which says that is unable to find owing document so this means that the summary function is not applicable for the buttons that is outside the form tag okay now let's see is it applicable for buttons that is inside the form tag so here i have written driver dot find element by dot id and the id i have specified over here and the submit command and i've also written driver.navigate.back command now let's see whether it is executing or not or whether it shows an error so my chromebook has launched it's navigated and here it is this is a button inside a form tag and then it is navigated back okay so our submit function is working inside the form tag for the submit button but what about the element of type button so i have written this driver.find element by dot id and this is the id that is that i have given over here and the summit command and also thread dot sleeve so that we can see the execution so my chrome browser is launched it's navigated and this is the button inside the form tag so here you can see we had the division that is the inside the form tag division in which uh i had two buttons that the submit button and the button right so i could automate the submit button as well as this button also so the summit function is applicable only for buttons that are inside the form tag so this means that there are some restrictions for the submit method and there is no restrictions for the click method so let's see the difference between the two so this is the difference for the click method you can use the click method to click on any button whereas the summit function is applicable only for buttons that is inside the form tag there is no restrictions for click button but there are some restrictions for submit button that is it is only applicable if the button is inside the form tag now this means that when there is no restriction for click buttons that this means that the element type is button or it is of type summit the click method will work for both but whereas the element type of submit or button it should be inside the form tag then only the summit method will work okay now if the button is inside the form tag or the button is outside the form type the click will work but if the button is outside the form tag that means the summit will not work as we have seen in the example before so now moving on to the next test case that is the submit our login button is to submit our login form right so your let's inspect this element now this element is of type submit and it is under the form tag so we can use the summit command so i'll simply write driver dot find element by dot x path and and i will paste it over here okay so here i have written driver driver.find element and this is the expert that is present and the operation that i want to perform is i want to submit it so now let's execute this my chrome browser is launched it's navigated my username is entered password is entered username is cleared password is cleared and here you can see the login button is clicked and here the warning is given the username cannot be empty so our next test case is the get text now this method will fetch the visible uh inner text of the element and it accepts nothing as a parameter but it returns a string value for example suppose this element here you can see this link if i inspect this here you can see we have the forget your password text written over here so get text fill method get text method will retrieve this forget your password okay it will fetch the inner visible text that is present over here there is a text present right forget your password so it will print forget your password through get text method so what i'll do is i'll write driver dot find element by dot link text and the text that is present over here is this so i'll simply copy this and i'll write get text here i'll give some string value and i will print it let me execute this my chrome browse is launched it's navigated it's executed username password is entered the username is cleared the password is cleared the submit button is clicked and here you can see we have the text let's forget your password okay then the next test case says that get location now the get location method this method locates the location of the element on the page and it accepts nothing as a parameter but it returns a point object now here i will write driver dot find element by dot id i will store this in a web element type of variable so i'll use the point class over here and then i will write element dot get location next i will print it plus point dot x y coordinates point dot y so let me execute this my chrome browser is launched it's navigated it's maximized my username and password is enter my username is cleared my password is cleared so my login button is clicked and here you can see the text is forget your password x coordinates and the y coordinates so through get location we can locate the location of the element on the page on this page i was locating this element that is the user name that's what i found through get location method next test case says that you have to find the size that is the get size so here the get size method fetches the width and the height of the element now over here i will inspect this element only i will i want to know the width and the height of this element for that i will be using the get size method now remember the get size method is different and the size method is different they both are different okay now this get size method it accepts nothing as a parameter but it returns the dimension object so similarly i'll write the code for this i'll write driver dot find element by dot id and i will store this in a web element type of variable i will name it as element 1 is equal to driver.fine element by dot ire okay next i will write dimensions dimension dimension is equal to element 1 dot get size next i will write s out and i'll write height is and i'll write dimension that is the dim dot height and i will write him dot so let's execute this so my chrome browser is launched it's navigated it's maximized and my username password is entered my username is cleared password is cleared the login button is clicked and here you can see the height and the width that is given of this element that is the username element so the next test case says that we have to find the get tag name now the get tag name method it gets the tag name of the element for example suppose if i inspect this element this is the element that i'm inspecting element that is there so the tag name is input so it will retrieve the input this is the tag name that is of this element right so the tag name of this element is redrive that is the input so let's see i'll simply write driver dot find element by dot id and i will place the id over here i'll write get tag name and i'll print this value so i'll store it in a string type of variable because it returns string next i will print it let's execute this so my chromebook is launched it's navigated the username password is entered the username is cleared the password is cleared and my login button is clicked and here you can see we have the tag name that is the input so the next test case is that we have to print the number of links present on the page now i have given this test case to understand the difference between the fine element and the find elements so what i'll do is i'll write driver dot find elements by dot tag name i'll use the tag name and to find the links on the page the tag that we use is the a tag right the anchor tag so i'll write a and i will store this in a list i'll use the web element because i have to inspect the web element over here the different types of web element that is i want to know the list of links that is present over here right so i'm using the list and the element that i want to inspect is the web element and i will give a variable name i'll name it as links is equal to driver.find elements by dot tag name and then i will print this that is i'll print the number of links that is present over here to print the number of links that that is present over here i'll use the size method remember the get size method is different whereas the size method is different the size method retrieves the number of elements in the list whereas over here the get size method this method that you see this is the get size method this shows the width and the height of the element my chrome browser is launched it's navigated it's maximized the username and the password is entered the username is cleared the password is clear and the login button is clicked okay here you can see we have the number that is present over here that is six there are six links present on this page okay now here you can see we have used the find elements method over here okay now the main difference between the fine element and the fine elements is that the fine element returns the first matching web element if the multiple web elements are discovered by the locator okay and here the find elements returns the list of multiple matching web elements in find element it will throw no such element exception if the element is not found whereas in find elements it returns the empty list it will return the empty list if no element is matching over here find element detects a unique web element whereas the fine elements it returns the collection of matching elements we have seen the example also over here so this is the main difference between the fine element and the find elements now the next test case is that we have to check if the login button is displayed or not now here we are using the element visibility methods okay we have three types of element visibility method one is the is displayed one is is enabled and one is is selected now the is selected method is mostly used for radio buttons and check boxes whereas the is displayed in is enable method is used for all types of web elements that is present on the web page all these methods it accepts nothing as a parameter but they return boolean values that is the true and the false the is displayed method this method determines if an element is currently displayed or not for example if the test case is that check if the login button is displayed that is this login button it is displayed on this page right on this web page so when i write driver dot file element dot id and if i located by id and when i write is displayed it will show true because this element is displayed on the web page now let's see if i write now if i write is displayed and if i save it in a boolean type of a variable because it returns true or false so if i write boolean 1 is equal to driver.find element x bar then this is displayed and i will print it over here so here the output will be true because the element is displayed on the web page right so the output will be true so let's execute this my chrome browser is launched it's navigated my username and password is entered my username is erased and the password is also clear and the login is clicked and here you can see we have the value that is true why it is true because this login button is displayed on the web page so next test case says that we have to check if the login button is enabled or not now here i have written a boolean variable that i have given is the bool2 and i have written driver.find element and the xpath and i have used the is enabled method now this method the minus of the element is currently enabled or not here you can see this uh element is enabled right if i click on this i can see over here it is enabled so let's see the output will be true because this element is enabled my chrome browser is launched it's navigated it's maximized and the username and the password is entered the username is cleared the password is cleared the login is clicked we close this and here you can see we have the true value given over here next let's check if the login button now this is selected method is basically used for the radio buttons and the check boxes mostly it determines whether the element is selected or not so this uh operation is only applied to input elements such as check boxes select option the radio buttons to return that it is true or false if the radio button is selected it will return true if it is not then it will return false okay and it accepts nothing as a parameter but it returns a boolean value so in this case this element is not a radio button or a check box or something but and it is not selected also so obviously it will return false so if i write driver.find element dot x python is selected and if i print this variable now let's see the output will be false because this element is not selected and it is not a radio button or a check box so my chrome browser is launched it's navigated and the username and password is entered the username is cleared the password is also cleared and the login is clicked and here you can see the output is false okay so here these were the test cases that we execute today we launched the chrome browser we opened the url we entered the username and the password we cleared it so here we use the clear operation here we use the uh send keys method and here we understood the difference between the click and the summit method then we use the get text method the get location the get size and that get tag name then we understood the difference between the fine element and the find elements then we use the is displayed method is enabled method in is selected method so this way we have covered all the web element commands so let us just understand the difference between all these elements i have explained the difference between the click and the submit so for the click we have no restrictions whereas for submit method we have the restrictions that is the method is only applicable if the buttons are inside the form tag okay so this is the basic difference between the click and the submit and if the button is inside the form tag or the button is outside the form type the click method will work but if the button is outside the form tag that means the summit will not work we have seen the example also next is the find element in the find elements now the find element returns the first matching web element if the multiple web elements are discovered by the locator now if the locators discovers multiple web elements like suppose of name suppose the name given over here is the column one and there are multiple column ones present on the web page okay and it has multiple web elements are discovered over there so it will return the first matching web element whereas in case of find elements it will return a mult list of multiple matching web elements and it throws no exception it is just that it returns an empty list whereas in fine element it throws no such element exception if the element is not formed detects a unique web element whereas the driver.find elements it returns the collection of matching elements this is the example we have also seen the example of find elements next what is the difference between the is displayed is enabled and is selected now the is displayed method is used to verify whether an element is on site present or not as i've shown the login button was present on the web page so it displayed true so this method is used to verify whether an element is present on the site or not is enabled is used to confirm whether an element is enabled or disabled whereas is selected is used to confirm whether an element is selected or not is selected is applicable to any web object or any web element that is present on the web page and it returns true or false whereas is enabled is also applicable to all the web object that is present on the web page when it returns true and false now this is selected method is only applicable for check box so the drop down menus and the radio buttons on the side and it will return true or false so if the radio button is selected it will show true and if it is not selected it will show false so this is the basic difference between the is displayed is enabled and the selected method so far we have covered the web element commands we have understood the difference also between the click and the summit the find element and the find elements also is displayed is enabled and is selected i have also given the pdf sheet i will give all the links in the description so that you can refer it also uh the source code link will be given in the description so you can check out the source code as well so for now uh this is what we have studied today in the next tutorial we will understand how to handle multiple windows through selenium webdriver so this is all for now so in today's tutorials we will cover one of the most important interview question that is how to handle multiple windows now in this tutorial we will understand what is window handle we will understand some methods used for handling window handles also we will cover some interview questions on get window handle and get window handles now in the previous tutorials i explained about the browser commands i explained all the commands except the two commands that is the get window handle and get window handles these are the two commands which is used to handle the multiple windows now for example this is the window now if i click on this this is the new window again if i click on this this is the next window so these are the child windows and this is the parent window now the problem is how do i switch from this window to this window now sometimes you may come across a complex scenario where you have to open a new window okay and you have to perform some desired operation on the open window like for example this is the parent window and by clicking on this new window button i opened a new window and i have to perform some operation on this so in this case how do i switch from this window to this window so this is what we're going to learn today now handling multiple tabs or windows may seem complex in the beginning because it involves some different commands which is new to you so as in beginner level so it will be a complex in the beginning but once you get get to know how to handle it and once you get a hang of it it will be very easy for you now there are many ways to handle multiple windows you can use a javascript executor also method but we will be covering the basic method to understand how to switch between the two browsers now here if i want to switch from this browser to this browser how am i going to do that i'm going to use the window handles value now what is the window handle value a window handle is basically a unique identifier that holds the address of all the windows it is basically a pointer to a window which returns the string value this is the window right this is the parent window and this is the child window now if i want to switch from this to this i will be using the window handles that is basically the pointer or the address that is given to a particular browser for example if i assume this parent window is having a pointer of value some string value it will be a very long string value i'm just taking up an example like suppose uh c21 okay and over here it will be uh something like d21 now if i want to switch from c21 to d21 how am i going to do that i'm going to use some specific commands okay and yeah these window handles are dynamic so it keeps on changing there's no fixed value for it the dynamic in nature they will keep on changing and it is a pointer to a window which returns the string value okay so there are some predefined methods of selenium that can be used to handle the windows first method is the browser commands that i have explained before but i didn't uh show the practical implementation so we're going to implement it today so first is that the get window handles and the get window handle now there's a difference between the both of them the get fit to handles is used for designing the window ids of multiple open windows and get window handle is used for retrieving the window id of the current focused window for example now the get window handles will retrieve the window id of this one as well as this child window and this child window okay whereas the get window handles will retrieve only the parent window handle value okay whatever value this window is going to have that value it will drive through get window handle so this is a basic difference between the get window handle and get window handles and the next uh method that is used that is the switch to method now if you want to switch from one window to the next window we will use the switch to command that will be driver dot switch to dot window next uh how we're going to implement this is we're going to execute three test cases today the first test case will teach that how to print the value how to print the handle values and we will learn the difference between the get window handle and get window handles the next set of test case will teach us that how to switch and navigate to the other sides also okay and the third test case we will know how to close the browser like the parent window we will close and then we will close the child window how do we do that okay so let's first start with the first test case open your intelligent id id so this is the java class that i have created or that is the selenium tutorials 14 and i have created under the package com.selenium and these are the three basic commands that we always tried first to see opening the chrome browser navigating to the url and maximizing it okay so first that open a chrome browser navigate to the url this is the new url so i'll simply just copy this and it's i'll paste it over here and i have to maximize the window next we have to print the parent window handle okay the parent window handle is this this is the parent window handle that we have and these are the child windows okay so we have to print the parent window handles so what you're going to do is i will write driver dot get window handle because i have to print the parent window handle so i'll use the get window handle over here because this returns string so i will store it in a string type of variable i'll name it as parent window handle so string parent window handle is equal to driver dot get window handle next i'm going to print it so i'll write s out the parent and i will write parent window handle okay this will print the parent window handle value next it says i click on the new window or button three times that is this one new window button three times for this i will be using the for loop so i'll write for int i is equal to one i less than or equal to three and i will increment it next i will write driver dot find element by dot x path and i will place the x path over here and what operation do i want to perform is the click operation which is one of the web element command so over here i have clicked three times now let me give some time so that we can see the execution properly now let's execute this now my chrome browser is launched it's navigated it's maximized the window is opened this is the next new window and this is the next one here you can see we have three windows over here okay this is the child window one the star window to the style window 3 and this is the parent window so i'll just close this now the next test case says that we have to print the window handles we have to print all the window has a handle so so i will write over here driver dot get window handles now this get window handles returns set so this get window handles returns a set of string type and why set because the get window handles are unique in nature so that's why it's set and i have named the variable window handles and is equal to driver dot get window handles now because i want to print all of them what i'm going to do is i'm going to use the for loop so i'll write for and over here because it's of string type so i'll write string and i'll name it as handle next uh the values from which is it's going to store and handle is from the windows handles and here i will print it and now let's execute this so my chrome browser is launched it's navigated it's maximized the child window is opened the second try window is click the third child window now let's see their values here it is the parent window handle is this is the parent window handle this is these are the child window handles and the parent window handles so here you can see there is a difference between get window handle and get window handles the get window handle it returns the window handle of the currently focused window or tab here our currently focus window tab is the parent window whereas the get window handles returns all the windows that is handled or launched including the parent and the child so that's why there are four window handles over here including the parent in the child there's a parent window as well as a child window in this okay which are all dynamic in nature it is having all unique values okay now there's a basic difference between the get window handle and get window handles our next test cases open the chrome browser navigate to the url maximize we have printed the windows parent window handle also we have clicked the new window button for three times then we have to print all the window handles and then we have to switch to windows okay now here comes the switching command that is the driver dot switch to dot window command okay so to switch to windows here i will write so you're in the for loop itself first i'm printing the window handles and then i'm switching so first i will print to which window it is and then i'll write driver dot switch to dot window and inside the window i will write handle i have to navigate to google so what i'll do that for that so basically it will switch and then it will navigate to the google so here i will write driver dot get and i will paste the google url over here and i will maximize it driver dot manage dot window dot maximize so let's give the time limit over here i'll write thread dot sleep and i'll specify some time here i'll write driver dot quit so that the browsers are closed my chrome browser is launched it's navigated it's maximized the child window is open the next child window is open the third child window is open next first the parent window will be navigated to google.com the next style window will be navigated to google and will be maximized then the next style window will be navigated to google and maximized and you're the third trial window will be navigated to google and it will be maximized so till now uh we have learned how to switch and navigate over here i'm switching and navigating to google okay so this is what we learnt over here the next third case says that we have to learn how to close the windows now here i use driver.quits so it just closed all the browsers including the parent window and the child window but if i use driver.close it will close only the current window handle that is handling okay that is an execution so here what we'll do is now over here currently there is no window in current okay so what we're going to do is we're going to switch first i'll use driver dot switch to window and here i will write the parent window i want to close the parent window first so i'll switch to parent window first i will write driver dot close so while switching let's write thread dot sleep and i will give some time over here okay the first is right we will switch to the parent window and then we will close it next switch back to the other windows and quit the browser now at this point of time there is no focused window after closing the parent window handle there is no focus window so we have to switch back to some window for that i am using a string type of a variable i will name it as last window i will use this variable so what i am going to do is i am going to write driver because i have to switch to the other windows i'll write driver dot switch to dot window and i'm going to write last window handle over here and i'm going to use the driver dot quit command now to see the execution properly i'll write thread dot sleep and here i'll give some time here also i'll write thread dot sleep and i'll give some time okay so now let's execute this my chrome browser is launched it's navigated it's maximized and then the child window is opened the next child window is open and the third child window is open now the parent will will be navigating to uh google.com then my child window will be navigating to google.com and it will be maximized again the same process it will be navigated to google and can be maximized again it will be navigated to google and it will be maximized so the parent window is closed first then it is switching to some tab and it is quitting the browser okay so here we have learned how to close the parent window and how to close the other browsers also so these are the three test cases that we executed the first one we learned that how to print the handle values and what is the difference between the get window handle and get window handles in the next uh test case we learned how to switch and navigate to the other side we were navigating to google and we were switching through driver.switch2.windows command in the third one we learned how to close all the windows first we switched to the parent window we closed it and then we closed the other windows okay so these are the three test cases that we executed next let's cover some interview questions on get window handle and get window handles okay so one of the most frequently asked interview question is that what is the difference between the get window handle and get window handles now the main difference between the two is that the get window handle returns the window value of the currently focused tab that is the parent window handle right whereas the get window handle it will return all the window handles including the parent and the child windows as we have seen in the example now the return type of get window handle is string whereas the return type of get window handles is set because the window handle is always unique and it is dynamic in nature and it keeps of changing okay so that's the reason why it is set so this is the basic difference between the get window handle and get window handles okay so the next interview question is how to switch to another window in selenium now to answer this question i divided the answer into two parts the first is that define the methods of selenium that can be used for handling the multiple windows in an application and those methods are the get window handle and the get window handles switch to end window these are some of the methods that will be used to handle multiple windows in an application so explain this first and then explain the steps the steps are similar to the uh test cases that we executed that is get the handle of the parent window by using the command driver dot get window handle print the parent window then find the element we found the element through xpath so you can use any of the element locator now open multiple child windows it through the child windows we use the for loop for this now get the handles of all the windows that are currently open using the command driver dot get window handles which returns the set why returning a set because it is storing unique values window handles right it is storing unique window handles so that's why it's set then use the switch to command to switch to the desired window that is the driver dot switch to dot window and then close the browser so these are the steps so that uh to handle multiple windows in an application okay okay so the next interview question that is asked is what does the switch to command do now basically the switch to command is used to switch between the windows frames and popups and when we deal with frames and popups at that time we will understand how it works okay so now whenever the web driver uh launches a new chrome browser it is given a unique alphanumeric value called the window handle and how to switch between the windows is that we use a driver.swisto.window and the handle value is given over here okay so this is what the switch to command do now this is one of the most important question i was asked in an interview this question so that's why i have mentioned this so as soon as you launch a browser window do we get the windows handle value the answer of this is yes let's see this with an example so as the question says that as soon as we launch a browser vendor do we get the windows handle value so here what i did is uh open the chrome browser i'm launching the chrome browser i'm launching the chrome browser and here i'm printing system.order system.out.printlndriver.getwindowhandle let's see what output do we get you have my chromebrowser is launched it is not navigated because i have not given any url over here and here you can see this is the get window handle i have used the get window handle uh command over here and i can see a window handle over here right so this means that as soon as you launch a browser window we can get the windows handle value there is no need to navigate to a url or something but as soon as we launch the browser you will get the window handle next is it mandatory to load a url to achieve the window handle value no as we have seen in the example here we are not loading any driver.getelement command right we are loading any url over here no right it's it's commented over here you can see so we can still get the window handle so this shows that it is not mandatory to load a url to achieve the window handle value okay this question is something very important so i was asked this question in an interview so that's why i have included this question now if you close the browser and then call the get window handle or get window handles on driver you will get no such session exception stating session id is null using the web driver after calling the quick now basically it says that you open the chrome browser i just launched the chrome browser i did not load the url and i'm quitting the browser then i'm calling the get window handles and what type of exception do i get do i get this exception and what this exception states you will understand that okay now here you can see i have already created this uh example in which i have launched the chrome browser i'm not loading any url i'm printing the get window handle value over here after launching the chrome browser and then again i'm calling driver.get window handles i want to know how many window handles are present over here okay after quitting the browser so let's see what output do we get over here let me execute this okay now here you can see uh we are launching the chrome browser the chrome browser launched successfully the chrome browser was started successfully then not loading uh we are not loading the url but we are printing the get window handle value over here we got the window handle over here next after quitting the browser we were trying to print the get window handles we were trying to know how many get window handles value are present over here for that the exception that we got is no such exception session id is null using web driver after calling quit this is the exception that we found now see whenever this script is trying to find an element after driver.quit or after driver.close action in the selenium script or after closing or quitting the driver session that is the open browser is closed right and at that time we are trying to find an element so at that time there is no session that is active to find the elements the session id is null uh exception is thrown at that time when we find try to find an element after driver.quit or after driver.close okay so this is what the this is what is the meaning of no such session exception and session id is none let's move to the next interview question that is does get window handles method return handles in the same order as the windows is launched the answer is no let's practically implement this now here i have created a html code in which there are links like open google and here there is open facebook and then there is open flip card and then there is open snapdeal okay these are the links now does get window handles method return handles in the same order as window launches let's find the answer for this so i have already written a code for this in which first we're opening the chrome browser i'm navigating to it and then i'm clicking on facebook i'm clicking on flipkart i'm clicking on snapdeal i'm clicking on google these are the sites that i'm clicking on and then i'm trying to find the get window handles and i'm printing it with the title so let's see which handle prints first and according to the order this the order should be google facebook flipkart snapdeal this should be the order now let's see the order so here my chrome browser is launched it's navigated and here you can see all the browsers are opened okay here the title is get window handle this is the parent window this is the parent window now the online shop online shop site india and this is a snapdeal this is flipkart this is facebook and google so basically it's the parent window snapdeal flipkart facebook and google but the order should be google facebook flipkart snapdeal okay so there is a different order so that this means that it is not necessary that the get window handle will method will return handles in the same order okay so the answer to it is no so this is all for today uh we learned some selenium interview questions about the get window handle and the get window handles which is very important and it is frequently asked also and we also learned the difference between the get window handle and the get window handles we learned how to handle multiple windows we executed some test cases also so this is all for today today we are going to learn about the drop down menus now basically a drop down menu is a menu that offers a list of options and we can select one value at a time for example here you can see this is the drop down menu i can select any one value at a time so this is called a drop down menu now we will handle the drop down menus with the help of a special class called as a select class because here you can see when i inspect this element i can see the select tag so that is the reason why to inspect this to select values in this drop down menu i will be using the select class now the basic syntax of select class is that select i'll create a reference of this new is equal to new select and i will specify my web element over here so this is the syntax of select class next there are different methods of select class we'll be covering all these methods that is the select by index select by value select by visible text deselect by index deselect by value deselect by visible text get options get all selected options and get first selected options the deselect by value deselect by index and deselect by visible text only works for the multi select box so what is multiselectbox we will cover that also now there are different types of drop down menus and we will be learning how to inspect all these menus the first is the drop down menu with a select class we have seen that example now next is the drop down menu with the multi select options and then there is a drop down menu with a bootstrap so uh here you can see this is a drop down menu with select class here you can see there is select tag and this is the multi select i can select multiple values over here okay so this is the multi select list so we will be inspecting these two lists first and then we will learn how to inspect the bootstrap list now uh when we are inspecting the drop down menu the first thing that we'll do is first we'll find how many options are present in the drop down menu we will extract all those options and then we will select the options from the drop down menu through through three methods the first is select by index select by value and then select by visible text okay so just open your intelligent idea id first now i have already created a java class i have named it as silly name tutorials under package com.selenium and i have given three commas that is open the chrome browser i have given the key that is the webdriver.chrome.driver and the value that is the executable chrome driver file then next i have written webdriver driver is equal to new chrome driver here i'm launching the chrome browser next i'm navigating to the urls i've specified the url over here this is the page that we will inspect first i will inspect the drop down menu and then we will select the multi select list okay and then i'm maximizing the browser now first to handle drop down menu first we will use a select class over here i'm going to write select i'll create a reference variable so i'll write select element new select and here i will specify the web element now there are two options over here either i write driver dot find element by dot x path and i will specify the x path over here i will inspect this element here it is and here in selectors up i can see the relative x path i'll copy this this is the first option the second option is the second option is if i copy this i'll simply cop i'll just copy this and i'll give a variable that is the web element i'll write your drop down is equal to driver dot find elements by dot x part and this is the x bar that i have given over here and here i'll write select then i'll write select element i'll give a reference variable i'm just showing you the different ways you can use the select class then new select and here i will specify drop down that is the web element variable that i have created over here okay so these are the two methods you can use a select class i prefer this one so i'll just comment this and we will continue with this one okay so here i have written select i have created a reference variable that is a select element is equal to new select and i have specified the web element that is the location of the drop down menu now here after creating a select class we will find how many options are present in the drop down menu so here i am going to write select element dot get options okay so your get options belongs to the select tag and through this option we will derive all the options that are present in the drop down menu okay now here i will store it in a list type of a web element i'll name this web element as options and is equal to select element dot get options now here i will print so i'll write s out i'll write options dot size now why i'm using the size function over here is because i want to return the number of elements in the list i want to see how many number of elements are present in the list okay then we will extract the values so let's run this my chrome browser is launched it's navigated it's maximized here there is no value displayed because we are not selecting any value right now we have just seen there are total eight elements that are present over here let's check if i inspect this here there is eight element that is one two three four five six seven eight there are total eight elements that is present over here okay here you can see it so the next is that we have to print them so for that we will be using the for each loop here i have written four and over here because of inspecting the web element so i'll write the web element and i'll give it as i'll give a variable as e and here because i have to print the options that are present so i'll write options over here and then i'll write a system.out.println i'll write the values r and here i'll write e dot e dot get text so let's execute this my chrome browser is launched it's navigated it's maximized and here you can see the values that is there please select then we have sunday monday tuesday wednesday thursday friday saturday and year also we can see these value please select sunday monday tuesday wednesday thursday friday saturday okay so these are the values we have printed the values now uh now i want to select them i want to select these options okay so there are three methods to select these options the first is select by index then it is select by value and next is select by visible text these are the different types of methods through which we will select the options in the drop down menu okay now let's use first select by value now here select by value when i inspect this element i can see option value there are different types of values given over here that is the sunday monday tuesday wednesday thursday friday saturday here it is an option value friday right so i'll be using this value to select this option so for example if i use friday i'll write select element dot select by value and i'll specify the value over here friday okay now let's run this my chrome browser is launched it's navigated it's maximized and here you can see the friday is selected here you can see they selected friday the values are printed we have got the total number of values that is 8 and then the values are also printed and friday is selected this is the first method the next method is select by index now for example suppose if i want to select tuesday okay and these are the options that are present over here to select by index it starts from zero so this will be zero one two three tuesday will be three so i'll be writing three over here so first i'll write select element dot select by index and i'll specify 3 over here now let's run this my chrome browser is launched it's navigated it's maximized and here you can see the day selected is tuesday okay so the next method is select by visible text okay over here visible text means when i'm inspecting this element the text that is visible over here here you can see there is text sunday monday tuesday now it is not necessary if the value and the text that is visible here is the same okay here in this case it is same but it is not it is not compulsory that the value and the visible text is same so for example now if i want to select monday so i will just copy this visible text monday over here and i'll paste it over here i'll write select dot select by visible text and i will paste it over here i'll comment this and i will execute this my chrome browser is launched it's navigated and here you can see the day selected is monday so now these are the different ways through which we can select these options now if in the interviews they ask how to handle drop down menus i have divided this answer into different steps so the first step is that to handle the drop down menu we will use the select class so first we will create a variable of web element type and pass it as a parameter in the select class as we have done in the example before i have created a variable of web element that is the d and driver.fine element by dot idean have specified the location of the drop down menu over here next i have created a select class i have also created a reference variable of this that is the drop down list is equal to new select and i have passed the parameter of web element type that is the d over here in the select class now this is the first method the second method is that if we see if we write select drop down list is equal to new select and we write driver.find element directly to vwritedriver.find element that is also fine okay then the next step is that we will find how many options are present in the drop down menu to find that we will write drop down list dot get options dot size now we can extract all the options in the drop down menu in the selenium with the help of select class method which has the get options method now this drives all the options of the select tag and it returns a list of web element types okay get options returns the list of web element types just remember that now we will extract all the options we will print them for printing them we are using the for loop and for extracting we use the dropdownlist.getoptions method and we printed it next is that we selected options from drop down menu through three ways first is select by index then select by value then select by visible text so your select by index you can use the index to select the option from a drop down menu basically the index starts for zero so this means the first option index will be zero and so on okay now if we write select by index we will writing uh we will write select dot select by index we will specify the index over here okay next is the select by value you can select an option by using the value attribute provided for each option in the drop down menu in the drop down menu there is an option that is a value attribute provided so using that value attribute you can select the option through select by value okay simply just write select dot select by value and the value you want to select for example in the value it is given options value is equal to 4 so your specify 4 now select by visible text you can use the visible text to select the options so if you want to select 2015 you can select the option by visible text that is 2015 will be written over there okay so just simply write select dot select by visible text and specify the text that is visible over there so these are the three ways where you can uh handle the uh drop down menu options you can select these options through these three ways okay now as i specified this is the index that is selecting by index it will start from zero uh this is the select by uh visible text and this is select by value there is option value attribute that has been used over here so you will be using the select by value now over here we will understand what is the multi select drop down list a multi select drop down list control allows the user to select multiple items from the list to check if the select element supports the multiple selecting options at the same time or not we will use is multiple method this returns a boolean value that is true or false now here you can see this example there is multiple uh options are selected so this is called a multi select drop down box now there is multiple method for example over here this box is not multiselected box right so if i write select element dot is multiple and i store this in a boolean type of a variable and let me print this variable so it will return true or false now in this case it will return false because it is not a multi select box so i will write and i will print it so let's execute this chrome browser's launch is navigated and maximized and here you can see this is like today days monday and the output for this is false why because it is not supporting multiple select it is not a multiple select drop down menu this is a multiple select drop down menu so we'll be using is multiple method in this and the answer for this will be true now to select multiple values in a drop down box i'll create a new java class i'll name it as selenium tutorials 16. now i'll simply copy this till printing the values now first i'm launching the chrome browser i'm opening the url maximizing the page i'm creating a select class i'll change the xpath over here i will inspect so this is it i'll copy this relative xpath over here i'll paste it over here then i'm finding the options present in the drop down menu it will print the number of options and then it will print the values of the options so let's execute this now my chrome browser is launched it's maximized and here i can see the total values are eight and the values are california florida new jersey new york texas these are the values that is present over here now if i want to select them what i'm going to do is i'm going to use we'll be using those options only that is a select by value select by index select by visible but there is something different in this that is a deselect now let's first see if this is a multiselect box or not so if i'll write first i'll use is multiple method i'll write select element dot is multiple i'll store this in a boolean type of a variable i'll print it and let's run this my chrome browser is launched it's navigated it's maximized and here you will see it's true so this is a multi select box and now let's select elements so now we will select the values so i'll write first we will use select by index so i'll write select element dot select by index and i want to select this the first index itself so this the index starts with zero so this is the zeroth index that is the california so i'll write 0 over here next we will use the select by value method i'll write select element dot select by value your value for new york is new york so i'll just copy this and i will paste it over here now next is that select by visible text so i'll write select element dot select by visible text and i will write the visible text that is present over here for washington it is washington so i'll just copy this washington and let's see whether it's selecting or not so i'll just run this command so my chrome browser is launched it's navigated it's maximized and here you can see there are three values that are selected that is the california new york and washington okay now if i want to know which is the first selected value so i'll write select element dot get first selected option dot get text i will write this in s out i want to print this so i'll write system.out.println select element.getfirstselectedoption.gettext now the first get first selected option returns the first selected option in the select tag here you can see it is the first selected option in the select tags and if we don't find it it will throw the exception no such element exception if the option is not selected so let's execute this my chrome browser is launched it's navigated so the options are selected the first option that we have selected is california over here you can see the index that we have given zero so the first option that is selected over here is california okay now let's deselect the values for that we'll be using three commas at the deselect by index deselect by value and deselect by visible text so first i'll write select element dot deselect by index okay now i want to deselect new york because i have selected new york so i will be writing 0 1 2 3. new york is the third index so i'll write 3. now here i'll write thread dot sleep let me give some time and let's execute this my chrome browser is launched it's navigated it's maximized and the values are selected california new york and washington and we saw the new york got deselected now next we will use the next method that is deselect by value so i'll write select element dot deselect by value now i want to deselect washington so the value of washington is washington so i'll simply copy this and paste it over here okay now let's execute this my chrome browser is launched it's navigated it's maximized and here you can see the three values that is selected and the new york and washington is deselected okay now we will use deselect by visible text so i'll write select element dot deselect by visible text and here i'll specify i will now here i want to deselect the california so the visible text that is present over here is california so i'll copy this paste it over here and let's run this my chrome browser is launched it's navigated it's maximized and those three values are selected the new york and washington is deselected okay so here i've used so here i'll write select element dot deselect by visible text and url paste california okay now so run this launch the chrome browser and maximize the web page and these are the three elements that is selected california new york and washington and all are deselected now over here the deselect option works only with the multi select boxes it does not work with the normal dropdown box that we have it works only for the multi select for example if i work for the multi select box the deselect option then in that case for example over here i'm selecting monday so in this case what will happen if i write select element dot deselect by visible text and here i'll specify monday itself so it will show an error so my chrome browser is launched it's navigated it's maximized and here you can see the date selected is monday but it shows an exception over here while deselecting monday shows an exception it says that you may only deselect options of a multiselect okay so the deselect option works only for the multi select drop down menus and not for the uh drop down menus with the select class okay so these are the different types of methods that we launched today that is the select by value select by index select by visible text and deselect by value deselect by index and deselect by visible text also we learnt the option that is the get for selected options now this works for validation then we have learned the method that is the guest get first selected option also so these are the different types of methods that is supported by the select class so this is all for now in the next class we will learn how to inspect the bootstrap drop down menu so today we're going to understand how to handle auto suggestion drop down menus with selenium webdriver well to understand how to handle auto suggestions with selenium webdriver firstly it is necessary to understand what basically order suggestions are for example if i type selenium webdriver now here you can see there are number of inputs given for selenium webdriver so these inputs are known as auto suggestion or autocomplete so we're going to automate this today this is the page that we're going to automate today what i want is for example suppose if i write the buy over here and i can see the number of inputs right so i'm going to click on this input and over here if i write indoor and here also i can see there are number of inputs right so i will click over here so this is what we're going to inspect today so let's just open your intellij idea ide okay so here i have already created a java class i have named it as selenium tutorial 17 under package com.tutorials of selenium and i have written the three basic commands that we usually write first is opening the chrome browser for opening the chrome browser we write system.set property in which we have the key written that is the webdriver.chrome.driver and the value is the chrome driver executable file next we have written web driver driver is equal to new chrome driver which will launch the chrome browser next we have navigated to the url so this is the page that we want to navigate to so i have just copied this url over here in driver.get command next i have written driver.manage.window.maximize to maximize the chrome browser so let's just execute this okay so here you can see the chrome browser is launched and it's navigated and it's also maximized okay so our three uh so are these three commands are working properly now let's uh automate the auto suggestion drop down menus so this is the page and i want to click on this element so i will inspect this also one thing like in the previous tutorial i explained about the drop down menus which were of select class over here there is no select class included so here you can see we have the input tag so i'll just copy this i'll go to selectors hub and here i can see the relative x path since i want to click on this element so i'll just copy this x path now here i will write driver dot find element by dot x path and i will specify this x path over here and i want to click on this so i'll write click or let's do one thing uh let me save this in a web element type of a variable so i'll just write from is equal to now i have saved this in a web type web element type of a variable i have named it as from so web element from is equal to driver dot find element by dot x path and i have placed my x path over here now over here i'm going to write from dot click first we will click on this element after inspecting uh so first we will click on this element then what i want to do is i want to move my cursor downwards okay now during automation we often require to press enter or we need to move our arrow keys downwards or we need to use the function keys or the tab or delete or enter okay so we can use these keys through send keys command how is that possible so just have a look at the syntax so here are the keyboard keys so here you can see we have the arrow key down so under the send keys command you just need to write keys dot arrow down which will move the arrow downwards okay next we have arrow key up which will move the arrow upwards then we have arrow key left right backspace ctrl key alt delete enter shift space bar so basically these are all the keyboards keys that is given by using send keys command you can press them okay so over here also we have the function keys like the f1 f2 f3 we can press these keys also by using the send keys command usually you we use the action classes for the keyboard commands but since we haven't learnt about action class so over here we will use the send keys command so here after clicking what i want to do is i'll write from dot send keys and i first i will enter some value that is dubai and after entering some value i want to move my cursor downwards right so i will write send keys again and here i will write keys dot arrow here you can see we have add alt left arrow down arrow left arrow right so i'll just click on arrow down now uh since uh first i clicked on this element then i entered some value that is dubai and then i moved downwards and after moving downwards what i want to do is i want to press enter okay so again over here i'll write from dot send keys and here i'll write keys dot enter and here you can see we have enter okay so this is what i want now why i have given a web element type of a variable over here because i want to make my code very systematic now if i did not give a web element type of a variable over here i mean uh you have to write again and again try dot find element the x part dot click then driver dot find element again the x path then dot send keys so instead of that i have written web element and i have given a variable from and then i have specified the x path and after that i'm clicking i'm sending keys and then i'm moving downwards and then i'm entering okay so let's execute this okay so my chrome browser is launched it's navigated it's maximize and here you can see dubai and it's moved downwards and it's entered so this is how we can automate it okay similarly we're going to do to this drop down menu also first i will inspect this go to inspect go to selectors hub and here we have the relative xpath i'll simply copy this and i'll just write a web element type of a variable first over here web element 2 is equal to driver dot find element by dot x path and i will specify the relative x path over here okay so first i will click the drop down menu then i would then after that what i want to do is i want to send some commands so let's send keys um i'll write indoor you can specify anything over here then i'll write 2 dot again i'm going to write send keys since i want to move the arrow downwards so i'll write keys dot arrow down okay let me specify some time over here thread dot sleep and i specify 2000 similarly here also i will specify thread.sleep i will specify the time next after moving down i want to click on the enter button okay so i'm going to write 2 dot send keys and here i'm going to write keys dot enter so first i am clicking the element then i'm entering some value in it after that i'm moving the arrow downwards and then we have to enter okay so let's execute this so here my chrome browser is launched it's maximized and you can see dubai is entered let's click similarly indoor is entered and it's moving downward and it is clicked okay so this is how you can automate your auto suggestions drop down menus now that's it for this video i hope you have learned something new and now check boxes are widely used on our web pages to offer multiple choices of an option to the user it is basically a gui that allows the user to make certain choices for the given options okay now the user may get a list of choices and the checkbox records the choices made by the user the user can select either single choice uh or multiple choices okay so the user can make single choices or multiple choices out of the given list depending on their requirement okay so first we will learn how to handle these check boxes and then we will learn how to validate them now the user will select the options according to their requirement but as a quality engineer when you are becoming a software tester what will you do with these with these choices you're going to validate these choices okay that's what your work is right as an automation tester you perform test cases right so how we're going to handle the checkbox that we're going to learn first and then we're going to perform some validations on the check boxes okay so here uh we will understand the validation through three commands that is the is displayed is enabled and is selected we have covered these three commands in the previous tutorials and i have also explained the difference between these three commands okay so now uh this is the page that we're going to automate today here you can see we have the check boxes now you must be thinking how do we handle these check boxes right it's very easy simply just clicking on these check boxes it gets checked and if you click again it is unchecked right that's what we're going to do to handle these check boxes so just open your intelligent idea ide so here i have already created a selenium tutorial 18 java class in package com.tutorials of selenium and here we have written the three basic commands that we write in all the programs okay that is first launching the chrome browser to launch the chrome browser we write system.set property in which we involve the key that is the webdriver.chrome.driver and the value is the executable file next we have written web driver driver is equal to new chrome driver which launches the chrome browser now we have to navigate to the url through driver.get command this is the page that we're going to navigate to so i have copied this url in driver.getcommand and then we are maximizing the browser so let's just execute this i'll run this here you can see my chrome browser's launched it's maximized it's navigated and it's maximized okay so basically these three commands are working properly now let's handle the check boxes okay now to handle the check boxes uh generally what you do you just click on it right that's what we're going to do we're going to perform the click operation over here first let's inspect this i'll just go on selectors up and i'll just copy this relative x path i will write driver dot find element i dot x path and i will specify the x path over here okay so i will let me store this in a uh web element type of a variable i'll name it as sports because it's a sports check box okay now what operation do we need to perform over here we need to click this so i will write sports dot click command okay let us execute this okay so my chrome browser is launched it's navigated it's maximized and here you can see the spots is checked okay next again we will inspect this element that is the reading element checkbox here it is so i will copy the relative x path and again i will write web element i will write it as reading is equal to driver dot fine element by dot x path and i will specify the x path over here okay now what operation do i need to perform over here is click so i'll simply just click this i will give some time limit over here so that we can see the execution properly let me execute this again so you have my chrome brush is launched navigate and maximize and here you can see the sports is clicked the reading is also clicked okay so now the third web element so i'll write web element dot sorry web element and i will specify the variable over here as music is equal to driver dot find element by dot x path and i will just inspect this element and here it is so i will just copy this x path and i will paste it over here now what operation i need to perform over here is click operation right so i will just write music dot click let's specify some time over here so that we can see the execution properly i'll execute this so your uh my chrome browser is launched it's navigated it's maximized and here you can see sports is checked reading is checked music is also checked okay now while handling these check boxes that is check and uncheck right so we have learned how to check these check boxes let's learn how to uncheck them so if the check box is checked simply by clicking it again it will uncheck right so that's what we're going to perform it again so if we write uncheck so here i've written uncheck and what i'll do is i will click all these elements again so i'll just write sports dot click and then i will specify some time red dot sleep then again i'm going to write reading dot click and and then i will specify some time click and then i will specify some time over here sorry thread dot sleep again i'll write music dot click just by clicking them again i'm going to uncheck it okay so i'll write red dot sleep over here also now why i'm re writing shred dot sleep is because i want to see the execution of the code properly okay so i am giving a waiting time over here basically so let's execute this and my chrome browser is launched it's navigated it's maximized sports is checked reading is checked music is checked sports is unchecked reading is unchecked and music is unchecked okay so here we have learnt how to handle our checkbox so we can use the click operation to handle the checkbox if we click it once it will be checked if we click it again it is unchecked okay now let's learn the validation part now in validation i have explained three commands in the previous tutorials so if you have seen all the tutorials before i have also explained the difference between is selected is enabled and is displayed okay so these are the three commands that we're going to use for validation first is display that is it returns true or false if the element is is displayed then we have the is selected then we have the is selected which returns true or false if the element is selected okay and next is is enabled so uh these three functions returns boolean values that is true or false so it returns true or false if the element is enabled okay so these are the three commands for validation and your let's validate it so first uh i have explained how to handle it so first we are clicking the element like over here we are writing sports dot click so it is clicked okay next we are unchecking it so it is clicked again it's unchecked now here i'll first use the is displayed okay i'll just write sports dot is displayed okay and i'll store this in a boolean type of a variable so boolean bole one is equal to sports dot is displayed and we're going to print this now if this boolean variable is displayed okay now if this bool one comes true and if it is displayed it is true then we're going to write sports dot click okay let's execute this since it will show true because the element is displayed on the web page okay here my chrome browser's launched it's maximized and you can see sports is selected reading is selected music is selected sports is unselected reading is unselected and music is also unselected and again sports is selected the reason behind that is because the boolean value is printing true and since we have given a condition over here if the boolean value is true the spots will be clicked okay similarly let's go for is selected okay so your if i write boolean volt2 is equal to let's go for reading dot it's selected and next i'm going to write system.out.println and i'm going to print this value okay now let me give a condition now if boolean 2 is equal to is equal equal to false now if it is false if it is not selected then we're going to write reading dot click okay now let's execute this okay so my chrome browser is launched it's navigated it's maximized and you can see his post is clicked reading is clicked music is clicked sports is unclicked reading is unclicked and music is also unclicked and again this post is clicked and the reading is also click the reason why it is clicked because i have given over here the condition is like bool 2 is equal equal to false and here the output for when we are writing reading dot is selected the output is false why because once we clicked it and after that again we are unchecking it right so if selected retrieves false if the element is not selected so here the element is not selected at this point of time so the value of bulldo is false and since it falls then it's clicking it again okay now let's let's go for is enabled now again i'll write boolean bool3 is equal to music bot is enabled okay next we're going to print it so i'll write 3 and here again i'll give a condition condition will be if o 3 is equal equal to true if the value is true then music dot click just click the music check box so let's execute this okay so my chrome browser is launched it's maximized and here this post is clicked reading is clicked music is clicked sports is unchecked reading is unchecked and music is also unchecked and then again the spouse is checked reading is checked and the music is also checked the music is checked because the value of is enabled is true okay and i have given the condition over here as both 3 is equal equal to 3 so boot 3 is equal equal to true so that's the reason why it's clicking the music element so here we have learned how to handle the check boxes and here we have learned how to validate these check boxes okay so uh this is it for this video i hope that you learned something new so try these programs on your own and if you face any problem you can check out the uh github link that is given in the description uh also if you have any questions or any feedback use the comment section below in the
