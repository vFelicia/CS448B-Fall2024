With timestamps:

00:00 - hey guys welcome to the Python thread
00:02 - tutorial for beginners so first of all
00:05 - what is a thread so a thread is an
00:08 - individual and separate unit of
00:10 - execution that is the part of a process
00:13 - now what is a process a process is
00:17 - simply our running program so for
00:21 - example if you run a browser it's a
00:23 - process if you run a video game it's a
00:26 - process now inside this process multiple
00:30 - threads
00:31 - can work together to accomplish a common
00:35 - goal and threads allows the program to
00:38 - run in parallel that is the single most
00:41 - important benefit of using threads so
00:47 - let me give you an example so when you
00:50 - play a video game it has to handle few
00:52 - tasks for example it has to handle the
00:55 - graphics and the user interface and if
00:58 - you are playing the multiplayer game it
01:01 - has to handle the networking and all
01:04 - those things it has to handle in
01:07 - parallel because it has to remain
01:10 - responsive at all the times so how does
01:14 - this videogame handles those parallel
01:17 - tasks the simple answer is threads it
01:21 - can assign one thread for graphics one
01:24 - thread for user interface and other
01:27 - thread for networking so by using
01:30 - threads the beauty game can always
01:32 - remain responsive and it can run the
01:36 - task in a parallel way now let me
01:40 - explain threads using this diagram so
01:44 - you can see this whole blue box here is
01:47 - a process and the threads exists inside
01:52 - this process so in this process you can
01:56 - see three threads now inside those
02:00 - threads you can see there is a code and
02:04 - local variable so a thread is a
02:08 - light-weight process that exists inside
02:12 - the
02:13 - process also a thread is a sequence of
02:17 - control flow the difference between the
02:20 - thread and the process is that the tread
02:24 - exists entirely inside the process and
02:28 - share its resources so let's say inside
02:31 - this gray box we have the global
02:34 - variables that each tread will be able
02:37 - to share those global variables and in
02:41 - addition each thread can have its own
02:45 - local variables and its own control flow
02:49 - to work with those local and global
02:53 - variables now a single process may have
02:56 - multiple threads of execution and as I
03:00 - already said that threads are useful
03:03 - when an application wants to perform
03:05 - many concurrent tasks on a shared data
03:10 - now let me give you one more example so
03:13 - think about a browser it has to handle
03:17 - the landing pages or the animations or
03:20 - if you want to open multiple website on
03:24 - different tabs and you want to run video
03:28 - in one tab and if you want to do another
03:32 - task in other tab most of the time the
03:35 - browser always remains responsive and
03:39 - the browser can handle multiple tasks at
03:41 - the same time so it uses threads to
03:45 - always remain responsive now there are
03:48 - two different kinds of threads one is a
03:51 - kernel thread and other is a user space
03:55 - thread or a user thread now kernel
03:59 - threads are the part of operating system
04:03 - while userspace threads are not
04:06 - implemented in kernel the userspace
04:09 - threads can be seen as an extension of
04:12 - function concepts in programming
04:15 - languages now each process have at least
04:19 - one thread and that is the main thread
04:23 - so if you don't even create a thread
04:27 - inside a
04:28 - process it has at least one thread and
04:30 - that is process itself now let's talk
04:34 - about the advantages of using threading
04:37 - so the first advantage is multi-threaded
04:40 - programs can run faster on computer
04:42 - systems with multiple CPUs because these
04:46 - threads can be truly concurrent on
04:49 - multiple CPU computer systems the second
04:53 - advantage is the program can remain
04:55 - responsive to input at all the times
04:58 - this is true both for single and
05:02 - multiple CPU computer systems now the
05:06 - third advantage is threading allows to
05:10 - do something else while a thread is
05:13 - waiting for IO tasks or any other tasks
05:17 - to complete so it always remains
05:21 - responsive the next advantage is some
05:24 - programs are easy to Express using
05:27 - concurrency which leads to elegant
05:30 - solution and as a result they are easier
05:33 - to maintain and debug so some programs
05:36 - or some processes are inherently
05:39 - concurrent in nature and the next
05:42 - advantage is threads of process can
05:45 - share the memory of global variable so
05:49 - as I have already shown you in the
05:51 - diagram previously that multiple threads
05:54 - can share the memory of the global
05:56 - variables at the same time so if a
05:59 - global variable is changed in one thread
06:02 - this change is valid for all the threads
06:06 - a thread can have local variables also
06:10 - as we have seen in the diagram now let's
06:14 - talk about some of the issues or
06:15 - challenges you will face while
06:18 - programming threads for a program the
06:21 - first challenge is the scheduling so to
06:25 - execute a threaded program it must
06:28 - rapidly switch between threads so a
06:31 - program should be able to switch between
06:33 - threads efficiently and conveniently the
06:37 - second issue or challenge is the
06:40 - resource
06:41 - shirring so as I told you that multiple
06:44 - threads can share the same memory of the
06:49 - global variables so since threads share
06:53 - this memory and other resources it must
06:56 - be careful because operation performed
06:59 - in one thread could cause problem in
07:02 - another thread the next challenge you
07:05 - could face is of synchronizing of the
07:09 - threads so threads often need to
07:11 - coordinate their actions and as a
07:14 - software developer you may have heard
07:17 - about race condition of threads which
07:21 - means the outcome depends on the order
07:23 - of thread execution and often for
07:26 - synchronization we use locking
07:29 - primitives now that was the general
07:32 - description about threads now let's talk
07:35 - about the threads in item so in Python a
07:39 - thread is an object like any other
07:42 - object that can hold data this object
07:45 - can also be used to run with methods the
07:48 - object also can be stored in the data
07:51 - structures and this object can also be
07:54 - passed as a parameters to the methods
07:58 - also in Python our thread can also be
08:01 - executed as a process and during the
08:05 - lifetime of a thread it can have various
08:07 - states now in Python there are two
08:10 - modules which supports the usage of
08:12 - threads and these two modules are thread
08:15 - module and treading module now there is
08:18 - one thing to note here is that the tread
08:22 - module has been considered as deprecated
08:26 - for quite a long time so often users are
08:29 - encouraged to use that threading module
08:32 - instead of the thread module so if you
08:35 - will see in Python 3 that thread module
08:38 - is directly not available but indirectly
08:41 - you can use underscore thread to use the
08:45 - thread module and this is to remain
08:47 - backward compatible with the previous
08:50 - versions of the Python now the
08:52 - difference between the thread module and
08:55 - reading module is that the tread module
08:58 - treats the tread as the function while
09:01 - the module threading is implemented in
09:04 - an object-oriented way so in the next
09:06 - videos I will show you how to use these
09:09 - two modules in Python to create threads
09:12 - and handle threads in Python in the last
09:16 - video I have given you a brief
09:17 - introduction about threads and threads
09:20 - in Python in this video we will discuss
09:23 - about a module called thread module now
09:28 - if you remember in the last video I have
09:30 - told you that thread module is
09:33 - considered as deprecated in Python 3 but
09:38 - if we want to use thread module in
09:40 - Python 3
09:41 - we can still use thread module using
09:45 - module called underscore thread and this
09:49 - is for backward compatibility so I just
09:53 - want to give you a brief demo about
09:56 - thread module in Python 3 so you will
09:59 - have some idea about thread module in
10:02 - Python 3 so let's get started so first
10:05 - of all in order to use thread module you
10:10 - need to import it and then generally you
10:13 - will write thread but in order to use
10:17 - the thread module in Python 3 you need
10:19 - to use the underscore thread here okay
10:23 - so thread module is not directly
10:25 - available but it's available using this
10:28 - underscore thread module and for
10:32 - printing and giving some delay to our
10:35 - functions we are going to import a
10:38 - module called time now using thread
10:41 - module it's possible to use functions in
10:44 - separate threads so we are going to
10:47 - create a function and then we are going
10:50 - to execute this function in separate
10:53 - threads so let's define our functions
10:56 - and I'm going to name my function as
10:58 - print underscore epoch and if you don't
11:03 - know what is a pape it pork is the start
11:06 - of January first
11:09 - 1970 and we are going to try to print
11:13 - the number of seconds from apoc till now
11:16 - and inside this function we are going to
11:19 - provide two arguments first is the name
11:24 - of your thread so I'm going to just
11:27 - write name of thread and the second
11:32 - argument we are going to give is the
11:34 - delay okay so this is your custom
11:39 - function you can provide any name here
11:41 - and any number of arguments here and now
11:45 - inside this function first of all I'm
11:47 - going to create a counter so I'm going
11:50 - to just write count and I'm going to
11:53 - initialize this count with 0 now inside
11:57 - this function what I'm going to do is
11:59 - I'm going to loop around and inside the
12:03 - loop I'm going to provide some delay so
12:06 - we will be able to see the thread
12:08 - execution so let me just provide the
12:11 - while loop here and we are going to just
12:14 - check whether this count is less than 3
12:17 - and inside this while loop we are going
12:19 - to sleep for some time using that time
12:23 - module so I'm going to just write time
12:26 - dot sleep and we are going to just pass
12:30 - this delay argument inside this sleep
12:32 - function so I'm going to just write
12:34 - delay here which will be the delay in
12:37 - seconds so for example if I provide the
12:40 - delay of 1 then our while loop will
12:44 - sleep for one second now after this we
12:47 - are going to increment our counter so
12:50 - I'm going to just write count and then
12:52 - plus equals 1 which is going to
12:55 - increment the value of counter by 1 now
12:59 - after this in order to see whether our
13:01 - thread is working or not we are going to
13:05 - print something so let's print something
13:08 - using the print function so what we want
13:10 - to print so let's say we want to print
13:13 - the name of the thread whatever name we
13:15 - will provide for the thread and then I'm
13:19 - going to just give some indication
13:23 - here let's say this is some line and
13:25 - then we are going to print that time
13:27 - since epoch so in order to print time
13:31 - since epoch we will use this time module
13:34 - and then we just need to use the time
13:38 - function inside the time module
13:40 - so using this print function we will
13:42 - know which thread is executed and at
13:46 - what time it's executed so now we have
13:49 - our function and now this function we
13:52 - want to execute inside the thread so in
13:56 - order to execute this function inside
13:57 - the thread first of all I'm going to use
13:59 - this thread module and there is a
14:01 - special function inside this tread
14:04 - module which is called a start new
14:07 - thread function so I'm going to use that
14:09 - function so let's just call this
14:12 - function which is thought underscore new
14:15 - underscore thread now if you hover over
14:18 - this function and when I press ctrl on
14:21 - Windows or command on Mac and then I
14:25 - hover over this function you will be
14:28 - able to see the signature for this
14:30 - function so this function takes 3
14:32 - arguments 1st argument is the function
14:35 - which we want to execute inside the
14:37 - thread second argument is args which we
14:41 - provide to our function as tuples so 2nd
14:45 - argument we need to provide as tuple and
14:48 - inside this tuple we will provide the
14:50 - number of argument which we want to
14:52 - provide to our function and third
14:55 - argument is that kW adds option and this
14:58 - kwr is an optional dictionary for the
15:02 - keyword arguments so let's provide the
15:05 - function name first of all and our
15:07 - function name which we want to execute
15:09 - is print underscore epoch and you need
15:13 - to remember that you need to provide
15:15 - this function name without any
15:17 - parentheses okay so just provide the
15:20 - function name as the first argument
15:23 - second is the number of arguments so we
15:27 - have provided two arguments for this
15:30 - print a pop function so we need to give
15:32 - these two argument in the form of tuples
15:35 - so first argument
15:37 - let's say is the name of the thread so
15:40 - we are going to just say that this is
15:42 - the thread 1 which will be the name of
15:45 - this thread and the second argument is
15:48 - the delay in seconds so let's say I want
15:51 - to provide 1 second delay in the while
15:55 - loop so it will sleep for one second
15:58 - this delay we are providing in order to
16:01 - see the thread execution because thread
16:04 - execution is so fast that it will be
16:07 - difficult to see the execution of
16:08 - threads without this delay now I told
16:12 - you that the third argument is the
16:14 - optional argument so we will not provide
16:16 - the third argument to the start new
16:19 - thread so this statement is going to
16:21 - create a new thread and it's going to
16:24 - execute this function inside this new
16:27 - thread so till now we only have one
16:29 - thread so let's create the second thread
16:31 - and to create the second thread you need
16:34 - to repeat this function which is start
16:37 - new thread and then you need to give the
16:39 - name to your thread so I'm going to give
16:41 - the name thread too and let's just
16:44 - change the delay so here I am going to
16:47 - provide the delay of 3 second to the
16:49 - thread 2 so now we have created two
16:52 - threads and this function will be
16:55 - executed in both that threads so let's
16:58 - see if this code works or not so I'm
17:01 - going to just run the script and you
17:04 - will see as soon as I run the script it
17:07 - exists without printing anything and
17:10 - this is because thread takes some time
17:12 - to be created and we need to wait for
17:16 - the thread creation so we need to
17:18 - provide some mechanism to wait for that
17:22 - thread creation and this wait we can
17:24 - provide in two ways one is we can just
17:28 - provide the blank input function which
17:31 - waits for the input
17:32 - so using this input function we will
17:34 - wait for some time until these threads
17:37 - are created and now we will see if this
17:41 - works or not so let's run this script
17:43 - once again and let's see what happens so
17:45 - you can see now you will be able to see
17:48 - these print State
17:51 - and you will see that first of all
17:53 - thread one is executed and then thread
17:56 - one is executed once again because we
17:59 - have provided only one second delay
18:01 - between the loop inside this thread so
18:06 - thread one will be executed faster than
18:08 - thread two so first of all thread one is
18:11 - executed and the ik bak time is printed
18:14 - and once again this thread one is
18:16 - executed because the delay time is less
18:19 - and then thread two is executed and the
18:22 - Epoque time is printed here and then
18:24 - thread one is executed once again and at
18:28 - the end you will see that thread two is
18:29 - executed two times because you can see
18:32 - that here we have the counter limit
18:35 - which is less than three so let's try to
18:38 - increase this limit to five and let's
18:41 - see how many times this print statement
18:43 - is printed so let's run the program once
18:47 - again and let's see what happens so once
18:49 - again this thread one is executed two
18:53 - times and then thread two and then
18:55 - thread one is executed three times once
18:58 - again and then tried to comes and you
19:00 - can see rest of the threads are executed
19:03 - then so here you can see thread one is
19:06 - executed one two three four five times
19:09 - and thread two is executed also five
19:12 - times so in this way you can start
19:14 - multiple threads and execute different
19:17 - functions inside those threads now I
19:21 - told you there is another way of waiting
19:24 - and this is by providing the while loop
19:28 - so I'm going to just provide wild one
19:31 - and inside this while loop I'm going to
19:34 - wait forever so I'm going to just say
19:38 - pass and this is an infinite loop which
19:41 - is like waiting so I'm going to just
19:45 - close this script first of all and then
19:48 - run the script once again and then you
19:51 - will see the same effect which you have
19:53 - seen in the case of input function also
19:56 - now here one more thing to consider is
19:59 - the return of this function so if this
20:03 - function which
20:04 - you want to execute inside the thread
20:06 - returns successfully the thread will
20:10 - silently exit but when your function
20:12 - terminate unexpectedly then unhandled
20:16 - exception will be thrown and thus track
20:19 - trace of that exception will be printed
20:22 - on the terminal so if this function
20:25 - throws then strike trace will be printed
20:28 - and this will be an unhandled exception
20:31 - so in order to avoid this unhandled
20:34 - exception
20:35 - you can also provide the try catch block
20:39 - here so here you can provide try and
20:41 - then i'm going to provide some space
20:43 - here and here also and after this code
20:47 - I'm going to just write accept and
20:50 - inside the accept you can provide any
20:53 - error so you can print that this is an
20:56 - error so inside this print function you
20:59 - can just write that this is and or
21:03 - anything which you want to write inside
21:06 - this accept block you can write using
21:09 - the print function or whatever you want
21:10 - to do in order to handle this exception
21:13 - you can do inside that accept block so
21:17 - let's run this script once again and
21:18 - let's change the delay here so I'm going
21:21 - to provide the delay of two seconds and
21:23 - here I'm going to provide the delay of
21:26 - let's say four seconds and let's run the
21:29 - script once again and this script runs
21:32 - and you can see after two seconds the
21:35 - thread one print statement is executed
21:37 - and then after four second thread two
21:40 - print statement is executed and this
21:43 - tried execution you will be able to see
21:46 - in those intervals so this is how you
21:49 - can use thread module in Python 3 in the
21:52 - last video we have seen how to use
21:54 - thread module in Python now in this
21:57 - video I'm going to show you how to use
21:59 - threading module in Python and I'm going
22:02 - to give you some introduction about
22:04 - threading module how to create threads
22:07 - using threading modules and how to use
22:10 - threading module now threading module is
22:13 - more powerful and it has more higher
22:17 - level support
22:18 - for creating threads in Python so let's
22:22 - see how to use threading module in
22:24 - Python so in order to use threading
22:27 - module first of all we need to import it
22:30 - so I'm going to just import threading
22:33 - module and once threading module is
22:36 - imported we will be able to use
22:38 - threading module the second module which
22:41 - I am going to import here is the time
22:43 - module which we have also seen in the
22:45 - last video because we are going to
22:48 - create the same function and we are
22:50 - going to use this function using the
22:53 - threading module which we have seen in
22:55 - the last video now I'm going to create
22:58 - the same method which I have created in
22:59 - the last video also which is print a box
23:02 - so I'm going to just copy this method in
23:06 - order to save time and then I'm going to
23:09 - just paste it here so now we have our
23:12 - function which we want to call using the
23:14 - threading module and we want to create
23:17 - some threads using this threading module
23:20 - and call this function inside those
23:22 - threads so first of all I'm going to
23:24 - write this condition which is for the
23:27 - main method which is if name is equal to
23:32 - underscore underscore main underscore
23:34 - underscore and under this condition what
23:38 - I'm going to do is I'm going to create
23:39 - two variables let's say first variable
23:43 - name is t1 for thread 1 and then I'm
23:46 - going to call the threading module to
23:48 - create a thread now inside the threading
23:51 - module there is a class called thread
23:53 - which we will use to create threads so
23:56 - just call the thread class here and
23:59 - constructor of this class takes several
24:02 - argument when you hover over here inside
24:05 - the parentheses you will see the
24:08 - signature of this thread class so it can
24:11 - take the target it can take the name of
24:13 - the thread and arguments also it can
24:16 - take in the form of tupple and it can
24:18 - also take the keyword argument in the
24:21 - form of dictionary so for our purpose we
24:24 - need to call the function which is print
24:28 - Apoc so we need to provide a target so
24:31 - in order to provide
24:32 - target we are going to just write target
24:36 - equals and the name of the function so
24:39 - the name of the function is print epoch
24:42 - which we are going to call and this you
24:46 - need to give without the parentheses so
24:48 - just remove the parentheses in front of
24:51 - this method when you use it as the
24:54 - argument in front of target the second
24:57 - argument which we want to give here is
24:59 - the arguments which this function takes
25:02 - so this argument we can give using the
25:05 - odds parameter so I am going to just
25:08 - write as equals
25:11 - and then in the form of couple I'm going
25:13 - to give the name of the thread and that
25:16 - delay to the thread so let's give the
25:19 - name to the thread let's say this is
25:22 - thread 1 and the delay which we want to
25:25 - give here is 1 so this statement is
25:27 - going to create one thread and let me
25:30 - create one more thread in order to
25:32 - create multiple threads and instead of T
25:35 - 1 I'm going to change the name to T 2 so
25:37 - we have T 1 variable and T 2 variable
25:40 - and in the arcs I'm going to change the
25:43 - name of the thread which is thread 2 and
25:46 - let's say I want to give this delay of 2
25:48 - seconds to the function using the thread
25:51 - 2 so now we have two variables T 1 and T
25:55 - 2 which is an instance of that thread
25:58 - class now using T 1 and T 2 we can call
26:02 - a method called
26:04 - start in order to start the thread so
26:07 - I'm going to just call T 1 variable and
26:10 - then call a method called start which is
26:13 - going to start the thread T 1 similarly
26:16 - I am going to call the instance T 2 and
26:20 - I'm going to call the method start on
26:22 - this instance T 2 also so start method
26:26 - we use to start that threads now if you
26:30 - remember in the last video when we have
26:32 - created the thread using the thread
26:35 - module we have given this condition
26:37 - which is the infinite loop and this
26:40 - infinite loop we have used to wait until
26:43 - the execution of thread is completed
26:46 - now in the trading module which is the
26:48 - new module this facility is available
26:51 - using a method called join so on T one
26:56 - instance I can call a method called join
27:00 - and on T two instance also I can call a
27:04 - method called join and this join method
27:07 - waits until thread one and tried to is
27:11 - completed its execution and then at the
27:15 - end we can print something let's say we
27:18 - are going to print that everything is
27:20 - done so I'm going to print done here so
27:24 - let's rewind what we have done inside
27:26 - this script we have an imported
27:28 - threading module and time module and
27:30 - then we have created the function which
27:33 - we want to call using that threads now
27:36 - in order to create the thread using
27:38 - threading module we need to call the
27:41 - class called thread inside the threading
27:44 - module now this class constructor takes
27:47 - several arguments and right now we have
27:51 - given two arguments to this thread
27:54 - constructor which is the target which
27:56 - takes the name of the function which we
27:59 - want to execute using this thread and
28:01 - second argument we have given here is
28:03 - the args which is the argument which we
28:07 - want to give to the function which we
28:09 - want to execute same we have done for
28:12 - the thread two also now the start method
28:14 - on these instances is going to start the
28:18 - thread for T 1 and T 2 and the join
28:21 - method we have used to wait until thread
28:24 - 1 and thread 2 is completed their
28:27 - execution so let's run this script and
28:30 - let's see what happens so I'm going to
28:33 - right click and then run the threading
28:36 - example Python script and you can see
28:39 - straight away that this output is
28:42 - printed here similar output we have seen
28:45 - in the case of thread module also so in
28:49 - this output thread 1 is printed and the
28:51 - Epoque time is printed and then thread 2
28:54 - is printed printed using the
28:57 - thread 2 so this output is printed
29:00 - using the thread 1 and thread 2 output
29:02 - is printed using the thread 2 and
29:04 - because we have given different
29:06 - intervals for a thread 1 and thread -
29:09 - that's why we can see that thread 1 is
29:12 - printed and then thread 2 and then
29:14 - thread 1 is printed two times and then
29:17 - thread 2 is printed and then thread 1 is
29:20 - printed once again two times and then
29:23 - rest of the thread two outputs are
29:26 - printed now let's take one more example
29:28 - and what we are going to do at this
29:31 - example is we are going to create two
29:33 - different functions and we are going to
29:35 - try to call these two functions using
29:38 - these two threads so the first function
29:40 - I'm going to create here is the print
29:43 - underscore a cube which is going to
29:46 - print the value of cube of the number
29:48 - which we will provide as the argument to
29:52 - this function so I'm going to just write
29:55 - print here and then using this print
29:58 - statement I'm going to print the value
30:00 - of cube of the number so here I'm going
30:03 - to just write cube and then I'm going to
30:06 - provide these curly brackets and then
30:08 - I'm going to call the format method
30:11 - after this string so let's call the
30:15 - format method which we use in order to
30:18 - format a string now inside the string we
30:22 - want the cube of the number so we will
30:25 - just multiply this number three times so
30:27 - num Astrix num Asterix num which is
30:31 - going to print the cube of the number
30:34 - once again let me just copy this
30:38 - function and then I'm going to create
30:41 - one more function and this time I'm
30:43 - going to name my function as print
30:46 - square so I'm going to just write print
30:49 - square here and then I'm going to just
30:51 - write square is equal to and here I'm
30:54 - going to just print the square of the
30:56 - number now in this statement where we
30:59 - have created t1 and t2 instances the
31:02 - target we can change which is the name
31:04 - of the function so now our target is
31:07 - print cube and print square without the
31:12 - parenthesis we
31:13 - to give the name of this function so
31:16 - print cube and print square and
31:19 - arguments have also changed so earlier
31:22 - print epoch used to take two argument
31:24 - and now we just want to give one
31:27 - argument to the function and let's say
31:29 - it's two and also the print queue
31:32 - function takes one argument and let's
31:34 - say it's two also now let's run this
31:37 - script and let's see what happens so you
31:40 - will see that there is an exception here
31:44 - which is some kind of a weird exception
31:47 - which says that exception in thread two
31:51 - and this exception is this print square
31:55 - argument afters Asterix must be
31:59 - iterative all right so the problem here
32:02 - is we need to give a comma here which
32:06 - tells this parenthesis that this is a
32:10 - couple value okay that's why it's giving
32:14 - the exception so if your function takes
32:16 - one argument then you need to give the
32:19 - value of that argument and then give the
32:21 - comma so that it's able to understand
32:24 - that it's a tuple and then once again
32:26 - when you run this script you will see
32:29 - the value of cube is printed which is
32:32 - eight and square is printed which is 4
32:35 - so this cube value is printed using
32:37 - thread 1 and square value is printed
32:40 - using the threaded 2 so in this way you
32:43 - can also call a multiple function using
32:47 - multiple thread instances using
32:50 - threading module so this was a brief
32:53 - introduction about reading module in the
32:56 - last video we have seen how to use
32:57 - treading module to create threads in
33:00 - Python now in this video also we are
33:03 - going to see how to create threads using
33:05 - threading module but we are going to see
33:08 - in this video how to subclass from the
33:11 - thread class which is available inside
33:14 - the threading module and then create
33:16 - threads out of that class instance so to
33:21 - start with I have the same method which
33:24 - is print
33:25 - Apoc which I want to
33:27 - inside that's Fred so now here after
33:31 - this method what I want to do is I want
33:34 - to create a class so I'm going to create
33:36 - a class and the name of the class I'm
33:39 - going to give the name as my thread for
33:44 - example and one thing we need to do here
33:47 - is we need to subclass from the thread a
33:51 - class from the threading module so we
33:54 - are going to just call first of all
33:57 - threading dot thread so we are sub
34:01 - classing from the threaded laws now
34:04 - inside this my class first of all we are
34:07 - going to define the init method so let's
34:10 - define this init method and in this init
34:14 - method we are going to pass two
34:15 - arguments same as this print
34:19 - Apoc function so first argument will be
34:22 - the name of the thread and the second
34:24 - argument will be the delay so let's
34:27 - provide these two arguments first is the
34:30 - name and second is the delay now after
34:35 - this inside this init method we need to
34:39 - call the parents init method which is
34:42 - threading dot red dot in it so we are
34:45 - going to just call threading dot thread
34:49 - dot underscore underscore init method
34:53 - which is going to call the parent init
34:56 - method which is treading dot treaded
35:00 - right now once you have done that we can
35:03 - just simply define some local member
35:07 - variable for the name so first of all
35:10 - self dot name is equal to name and self
35:15 - dot delay is equal to delay so now once
35:20 - we have our member variables what we
35:23 - need to do next is we need to override a
35:26 - method called
35:28 - run which is available inside the thread
35:31 - class in a threading module so I'm going
35:34 - to just define run method and we are
35:38 - going to overwrite this so first of all
35:40 - what
35:41 - this one method do so the run method is
35:45 - the entry point for the thread now in
35:48 - the previous video if you remember we
35:50 - have called the start method on the
35:53 - thread class right so the start method
35:57 - starts the thread by calling this run
36:00 - method so under the hood start method
36:02 - calls this run method so if we override
36:06 - this run method that means when we call
36:10 - the start method from the thread class
36:12 - this run method is going to be called so
36:17 - now we can do some logging here so what
36:19 - I'm going to do is I'm going to print
36:21 - first of all start thread and then I'm
36:27 - going to print and thread now between
36:31 - the start thread and and thread logging
36:34 - I'm going to call the print a pork
36:38 - function and this print epoch function
36:41 - is going to take two arguments which is
36:44 - name so I'm going to just pass the self
36:46 - dot name which we have assigned to the
36:51 - member variable and second is the self
36:53 - dot delay so once again when we call the
36:59 - start method on the instance of this my
37:02 - thread class this run method is going to
37:05 - be called by the start method
37:08 - automatically because we are sub
37:10 - classing from the threading dot thread
37:13 - class now once we have I would run the
37:17 - method and we have created the init
37:20 - method we can create some instances of
37:22 - my class so I'm going to create some
37:25 - instances for example t1 is equal to my
37:29 - thread and then we are going to pass
37:32 - those two argument first is the name so
37:35 - let's say the name is thread one and the
37:40 - delay we want to provide here is let's
37:42 - say one second because this delay is
37:44 - going to go to the print a pork method
37:48 - which is this one right once again we
37:50 - are going to create the second instance
37:53 - let's say t2
37:55 - and once again we are going to call the
37:57 - my thread class which we have subclassed
37:59 - from the thread class and once again we
38:02 - are going to give these two argument
38:05 - first is the thread so this time I'm
38:08 - going to name it as thread two and the
38:11 - delay I'm going to give here is two
38:13 - second let's say and now after the
38:15 - instance is created we can call the
38:19 - start method and the join method on
38:21 - these two instances so let me just call
38:23 - t1 dot start and then we are going to
38:28 - call the t2 dot start and once we have
38:33 - the start which is going to start the
38:35 - threads we are going to just call the
38:38 - join method and by now you already know
38:42 - what this join method do which is to
38:45 - wait for the thread to be completed so
38:49 - I'm going to just call the join method
38:52 - on t2 also and let's run the script and
38:56 - let's see what happens so I'm going to
38:58 - run the script and you can see first of
39:00 - all start thread has been called which
39:03 - is from the logging of this print method
39:07 - and then thread one is printed and the
39:10 - Apoc time is printed and then thread 2
39:13 - is printed and the Epoque time is
39:15 - printed because we have given the one
39:17 - second delay for the thread 1 so thread
39:20 - one will be iterated faster than thread
39:23 - two because we have provided the delay
39:26 - of 2 seconds four three two and one
39:28 - second quartz red one as soon as the
39:31 - thread ends we can see this print
39:33 - statement which is n thread and after
39:36 - the end of the thread two we can see
39:38 - this print statement which is and thread
39:41 - two we can also print here so let's
39:44 - print some more things here so we can
39:47 - print the name of the thread so I'm
39:49 - going to just write self dot name and we
39:56 - are going to do the same for the end
39:58 - thread also so I'm going to just print
40:02 - here also self dot name so we will know
40:06 - which thread is starting and we
40:08 - tread is ending once again I'm going to
40:11 - run the program and now you can see
40:13 - start tread thread 1 so 21 is started
40:17 - and then tried to is started and you can
40:20 - see first of all thread 1 is ended and
40:23 - at last thread 2 is ended so this is how
40:27 - you can subclass from the thread class
40:29 - which is available inside the threading
40:32 - module now inside the threading module
40:35 - there are some special methods which we
40:38 - are going to see now so the first method
40:41 - is so let me just go after this start of
40:46 - the threads so here what I'm going to do
40:50 - is first of all I'm going to use the
40:52 - print function and inside this print
40:54 - function I'm going to call the threading
40:56 - module and there are some special
40:58 - methods for example first of all we are
41:02 - going to see what is the active count of
41:05 - threads so what are the number of
41:08 - threads which are there inside this
41:10 - program this is going to print the
41:13 - number of threads now the second method
41:16 - which I'm going to show you is the
41:19 - threading first of all let me just call
41:22 - the threading dot we are going to call
41:24 - the current thread so this is going to
41:28 - print the current thread which is active
41:31 - right now and third match third which I
41:34 - want to show here is threading dot
41:38 - enumerate and this enumerate method is
41:42 - going to enumerate the number of threads
41:44 - which are active so let's run this
41:47 - program once again and let's see what
41:49 - happens so I'm going to just run this
41:52 - program and first of all you will see 3
41:56 - is printed using this print statement
41:58 - which is threading dot active count so
42:03 - active count is going to give you the
42:05 - number of threads and you already know
42:07 - that we have created two threads and one
42:10 - main thread is already available so
42:13 - total number of threads are three here
42:16 - which is printed now the current thread
42:18 - here this print statement prints this
42:22 - output which is the main thread so right
42:25 - now at the time of this print statement
42:28 - main thread is active now this enumerate
42:32 - method as I said is going to enumerate
42:35 - over all the threads which are available
42:38 - so main thread is available and then we
42:41 - have created thread one which is this
42:43 - one this is the name of the thread one
42:45 - and then when I scroll here you can see
42:49 - thread two is available so total three
42:52 - threads are available main thread thread
42:55 - one and thread
42:57 - - so these method you can use to just
42:59 - find out how many threads are there what
43:03 - is the current thread thread and you can
43:05 - also a numerate over all the threads
43:07 - there is one more method so I'm going to
43:11 - call this method here and I'm going to
43:14 - print it inside the print function and
43:17 - this time I'm going to use the instances
43:20 - so T 1 dot and there is a method of
43:25 - available here which is get name which
43:28 - comes from the thread class and because
43:30 - we are sub classing from the thread
43:33 - class this marm
43:35 - and because we are sub classing from the
43:37 - thread class this get name is available
43:40 - inside the my thread class also and same
43:45 - we are going to do here also so print
43:47 - and then T 2 dot get name so this is
43:53 - going to give you the name of the thread
43:55 - by default so I'm going to just run this
43:59 - script once again and you can see this
44:02 - is going to print thread 1 and this is
44:05 - going to print thread 2 now you might
44:07 - wonder why this name is thread 1 hasn't
44:09 - tried to because this get name method is
44:14 - going to give the value of self dot name
44:18 - which we have assigned using this name
44:21 - argument so this name is overwritten in
44:25 - the subclass which is my thread class
44:27 - and that's why it's giving us thread 1
44:30 - and thread 2 name which we have provided
44:33 - if we change this name let's
44:35 - say t1 and t2 and once again we run the
44:40 - code you can see the name also changes
44:43 - to t1 and t2 so this is how you can
44:47 - subclass from the thread class which is
44:50 - available inside the training module and
44:52 - we have also seen some of the method
44:54 - which are available inside the threading
44:57 - module which are useful to us in this
45:01 - video we will see how thread
45:03 - synchronization works in the case of
45:06 - multi-threading in Python and we will
45:09 - talk about how to use locks in the case
45:12 - of thread synchronization so first of
45:15 - all what is thread synchronization so
45:18 - thread synchronization is defined as the
45:21 - mechanism which ensures that whenever
45:24 - two or more threads are executed in
45:28 - parallel or concurrently and if they are
45:32 - sharing the same resource in that case
45:35 - all the thread should not work
45:38 - simultaneously or parallely on the same
45:42 - resource so let me explain the thread
45:45 - synchronization problem with the diagram
45:48 - so in this diagram you can see there are
45:51 - three threads and all these threads are
45:54 - sharing the same resource it can be a
45:57 - global variable for example so as long
46:00 - as all these threads are accessing this
46:03 - shared resource one by one not at the
46:06 - same time everything will work fine but
46:10 - the problem arises when two or more
46:12 - threads try to access the same global
46:15 - variable or shared resource at a
46:18 - particular time and this kind of
46:21 - situation is called the race condition
46:24 - so a race condition occurs when two or
46:28 - more threads can access the same shared
46:31 - data and they try to change the value of
46:35 - this same shared data at the same time
46:38 - and whenever this kind of race condition
46:41 - occurs the value of the variables may be
46:45 - unpredictable because if two threads
46:49 - working on the same global variable at
46:51 - the same time you will never know which
46:54 - thread has worked on this variable so
46:57 - the result is the unpredictable value of
47:00 - a variable now let me explain this
47:03 - problem with an example so I have this
47:06 - sample code in which in the first line
47:08 - I'm importing threading module and in
47:11 - the second line I am just declaring a
47:14 - global variable now I have two functions
47:17 - here one is thread tasks and other is
47:20 - mean task now inside this thread task
47:23 - function I want to increment the value
47:25 - of X every time by 1 so this is the code
47:29 - for this and I want to increment this
47:32 - value by 1 10 times so that's why I have
47:35 - used this for loop in the range 0 to 9
47:39 - so it's going to increment the value of
47:42 - X 10 times inside this loop now because
47:45 - this X is a global variable I have just
47:48 - added this global keyword in front of X
47:52 - so our function knows that this X is not
47:56 - a local variable it's a global variable
47:58 - so this function is simple enough it
48:02 - just increments the value of x 10 times
48:05 - inside the loop and this X is this
48:09 - global variable which we have declared
48:12 - outside this function now in the main
48:15 - task what I'm doing is I'm creating two
48:18 - instances using the threading module
48:20 - with the help of thread class this we
48:23 - have already seen in the last video how
48:25 - to create threads using threading module
48:28 - so nothing new in this I have created
48:31 - two instances t1 and t2 and I'm passing
48:35 - the target is equal to the function name
48:37 - which is this function which is try to
48:40 - task
48:41 - so both the threads will call the same
48:44 - function try task and then I'm just
48:46 - starting both the threads with the help
48:49 - of start function and then I'm just
48:52 - using the join methods on both of the
48:55 - instances now here inside our main if
48:58 - condition I'm just calling our main task
49:02 - in
49:03 - which our threads are created and
49:05 - executed and then at last I want to
49:08 - print the value of x when all the thread
49:10 - execution has been completed so let's
49:13 - run this script and let's see what
49:15 - happens so you can see here the result
49:17 - here is 20 which is expected because we
49:20 - are incrementing the value of x 10 times
49:23 - using two threads so the value of X will
49:26 - be incremented ten times by thread t1
49:30 - and ten times by 22 and as a result the
49:34 - value of X becomes 20 but as soon as I
49:39 - increment the value of this range let's
49:42 - say this is 10000 and I want to just
49:45 - execute this program once again there is
49:48 - no problem until now we can just run
49:52 - this program again I mean again we will
49:54 - not see this problem because we are
49:57 - incrementing the value of x 10,000 times
50:01 - with a single thread so we have two
50:04 - threads and the result is 20,000 which
50:07 - is absolutely fine now let's increment
50:10 - the value of range once again 200
50:13 - thousand and now I want to show you the
50:16 - problem so as soon as you do this you
50:19 - can see that the thread synchronization
50:22 - problem occurs so here you can see the
50:25 - result is not 200 thousand which we were
50:28 - expecting because for such large value
50:32 - this scenario of thread synchronization
50:34 - is happening so the two threads try to
50:39 - work on the same variable at the same
50:42 - time and as a result the value of X is
50:46 - unpredictable so this thread
50:48 - synchronization problem you will see
50:50 - when you try to work on a same variable
50:53 - multiple number of times so in this case
50:56 - we have a hundred thousand iterations
50:59 - and both the threads try to iterate over
51:03 - the same variable using two threads and
51:07 - the result is unpredictable let's try to
51:10 - execute this once again so you can see
51:13 - the result is always different every
51:15 - time I
51:16 - cute this program because the result is
51:20 - unpredictable so how to solve this
51:22 - problem so one way of solving this
51:25 - problem is by using the locks so first
51:28 - of all let me just change this program
51:30 - and try to use locks in this Python
51:34 - script so to use locks what you can do
51:37 - is you can declare a local variable here
51:40 - for example lock is equal to threading
51:44 - dot class called lock so this is going
51:49 - to give you an instance of lock now this
51:52 - lock class have two method one is
51:54 - acquire and other is release now acquire
51:58 - method is used to lock and release
52:01 - method is used to release the lock so
52:05 - let me just complete this script and
52:08 - then I will explain what does these
52:11 - functions do so what I'm going to do is
52:13 - I'm going to pass this lock instance as
52:16 - an argument of the thread task function
52:18 - so I'm going to just write as is equal
52:22 - to and then we will just pass our lock
52:25 - instance as an argument of this credit
52:29 - task same we will do for the second
52:33 - thread and because we have passed this
52:35 - argument we need to add this argument
52:38 - here also so I'm going to just pass the
52:40 - lock instance as an argument of this
52:42 - function and now at last what we are
52:46 - going to do is just before we change the
52:50 - value of the global or the shed data we
52:54 - use this lock variable and call the
52:58 - method called acquires and just after
53:01 - you finished changing the resource or
53:04 - the shared data you use a method called
53:08 - lock dot release so once again we have
53:11 - passed this lot instance which we got
53:14 - from this lock class as an argument of
53:17 - this function so this is the lock
53:20 - instance and there are two main method
53:23 - inside this lock class which are acquire
53:26 - and release this acquire method you use
53:29 - two
53:30 - acquire the lock this lock can be
53:32 - blocking or non blocking so this acquire
53:36 - method takes one argument which is true
53:39 - or false by default the value of
53:42 - argument is true which means that this
53:46 - acquire is blocking by default so what
53:50 - does this lock dot acquire will do it
53:53 - locks the access of the shared variable
53:56 - in our case this is X and at this time
54:00 - only one thread can work on this
54:03 - variable whatever thread have the access
54:06 - to this function at a particular time so
54:11 - until and unless one thread execution is
54:14 - completed on this variable after that
54:17 - this lock is released that means that
54:20 - the other thread can work on this
54:23 - variable using the lock once again
54:26 - so whenever second thread wants to try
54:29 - to access this variable it will just
54:31 - lock the access to this variable first
54:34 - of all and then work on this variable
54:36 - whatever you want to do you want to
54:39 - increment the value or change the value
54:41 - of x and then release the lock and
54:43 - releasing means that we once again want
54:47 - to allow the other thread to work on
54:50 - this shared resource so this mechanism
54:54 - will allow only one thread to access
54:56 - this shared resource at a particular
55:00 - time so the Treader synchronization
55:02 - problem will not occur so now let's just
55:05 - run the program once again and let's see
55:08 - what's the result so you can see this
55:10 - problem and this problem is coming most
55:12 - likely because of this problem because
55:17 - we haven't provided args as the tuples
55:21 - so we need to provide this AAG as our
55:23 - tupple so always remember whenever you
55:25 - want to pass any argument using this
55:28 - args keyword you need to pass them as
55:30 - tupple so once again i'm going to just
55:33 - try to run this program and you can see
55:36 - the result is whatever we expected so
55:40 - because we are incrementing the value of
55:43 - x
55:44 - hundred thousand times and there are two
55:46 - threads which are working on the same
55:48 - variable so we get the two hundred
55:50 - thousand result which is expected now
55:53 - let me run this program again and again
55:56 - and you can see every time now we get
55:59 - the expected result which is two hundred
56:03 - thousand so this is how you can solve
56:06 - the thread synchronization problem using
56:10 - locks so this is how you can use locks
56:14 - to synchronize your threads in Python I
56:18 - hope you have enjoyed this video and I
56:20 - will see you in the next video

Cleaned transcript:

hey guys welcome to the Python thread tutorial for beginners so first of all what is a thread so a thread is an individual and separate unit of execution that is the part of a process now what is a process a process is simply our running program so for example if you run a browser it's a process if you run a video game it's a process now inside this process multiple threads can work together to accomplish a common goal and threads allows the program to run in parallel that is the single most important benefit of using threads so let me give you an example so when you play a video game it has to handle few tasks for example it has to handle the graphics and the user interface and if you are playing the multiplayer game it has to handle the networking and all those things it has to handle in parallel because it has to remain responsive at all the times so how does this videogame handles those parallel tasks the simple answer is threads it can assign one thread for graphics one thread for user interface and other thread for networking so by using threads the beauty game can always remain responsive and it can run the task in a parallel way now let me explain threads using this diagram so you can see this whole blue box here is a process and the threads exists inside this process so in this process you can see three threads now inside those threads you can see there is a code and local variable so a thread is a lightweight process that exists inside the process also a thread is a sequence of control flow the difference between the thread and the process is that the tread exists entirely inside the process and share its resources so let's say inside this gray box we have the global variables that each tread will be able to share those global variables and in addition each thread can have its own local variables and its own control flow to work with those local and global variables now a single process may have multiple threads of execution and as I already said that threads are useful when an application wants to perform many concurrent tasks on a shared data now let me give you one more example so think about a browser it has to handle the landing pages or the animations or if you want to open multiple website on different tabs and you want to run video in one tab and if you want to do another task in other tab most of the time the browser always remains responsive and the browser can handle multiple tasks at the same time so it uses threads to always remain responsive now there are two different kinds of threads one is a kernel thread and other is a user space thread or a user thread now kernel threads are the part of operating system while userspace threads are not implemented in kernel the userspace threads can be seen as an extension of function concepts in programming languages now each process have at least one thread and that is the main thread so if you don't even create a thread inside a process it has at least one thread and that is process itself now let's talk about the advantages of using threading so the first advantage is multithreaded programs can run faster on computer systems with multiple CPUs because these threads can be truly concurrent on multiple CPU computer systems the second advantage is the program can remain responsive to input at all the times this is true both for single and multiple CPU computer systems now the third advantage is threading allows to do something else while a thread is waiting for IO tasks or any other tasks to complete so it always remains responsive the next advantage is some programs are easy to Express using concurrency which leads to elegant solution and as a result they are easier to maintain and debug so some programs or some processes are inherently concurrent in nature and the next advantage is threads of process can share the memory of global variable so as I have already shown you in the diagram previously that multiple threads can share the memory of the global variables at the same time so if a global variable is changed in one thread this change is valid for all the threads a thread can have local variables also as we have seen in the diagram now let's talk about some of the issues or challenges you will face while programming threads for a program the first challenge is the scheduling so to execute a threaded program it must rapidly switch between threads so a program should be able to switch between threads efficiently and conveniently the second issue or challenge is the resource shirring so as I told you that multiple threads can share the same memory of the global variables so since threads share this memory and other resources it must be careful because operation performed in one thread could cause problem in another thread the next challenge you could face is of synchronizing of the threads so threads often need to coordinate their actions and as a software developer you may have heard about race condition of threads which means the outcome depends on the order of thread execution and often for synchronization we use locking primitives now that was the general description about threads now let's talk about the threads in item so in Python a thread is an object like any other object that can hold data this object can also be used to run with methods the object also can be stored in the data structures and this object can also be passed as a parameters to the methods also in Python our thread can also be executed as a process and during the lifetime of a thread it can have various states now in Python there are two modules which supports the usage of threads and these two modules are thread module and treading module now there is one thing to note here is that the tread module has been considered as deprecated for quite a long time so often users are encouraged to use that threading module instead of the thread module so if you will see in Python 3 that thread module is directly not available but indirectly you can use underscore thread to use the thread module and this is to remain backward compatible with the previous versions of the Python now the difference between the thread module and reading module is that the tread module treats the tread as the function while the module threading is implemented in an objectoriented way so in the next videos I will show you how to use these two modules in Python to create threads and handle threads in Python in the last video I have given you a brief introduction about threads and threads in Python in this video we will discuss about a module called thread module now if you remember in the last video I have told you that thread module is considered as deprecated in Python 3 but if we want to use thread module in Python 3 we can still use thread module using module called underscore thread and this is for backward compatibility so I just want to give you a brief demo about thread module in Python 3 so you will have some idea about thread module in Python 3 so let's get started so first of all in order to use thread module you need to import it and then generally you will write thread but in order to use the thread module in Python 3 you need to use the underscore thread here okay so thread module is not directly available but it's available using this underscore thread module and for printing and giving some delay to our functions we are going to import a module called time now using thread module it's possible to use functions in separate threads so we are going to create a function and then we are going to execute this function in separate threads so let's define our functions and I'm going to name my function as print underscore epoch and if you don't know what is a pape it pork is the start of January first 1970 and we are going to try to print the number of seconds from apoc till now and inside this function we are going to provide two arguments first is the name of your thread so I'm going to just write name of thread and the second argument we are going to give is the delay okay so this is your custom function you can provide any name here and any number of arguments here and now inside this function first of all I'm going to create a counter so I'm going to just write count and I'm going to initialize this count with 0 now inside this function what I'm going to do is I'm going to loop around and inside the loop I'm going to provide some delay so we will be able to see the thread execution so let me just provide the while loop here and we are going to just check whether this count is less than 3 and inside this while loop we are going to sleep for some time using that time module so I'm going to just write time dot sleep and we are going to just pass this delay argument inside this sleep function so I'm going to just write delay here which will be the delay in seconds so for example if I provide the delay of 1 then our while loop will sleep for one second now after this we are going to increment our counter so I'm going to just write count and then plus equals 1 which is going to increment the value of counter by 1 now after this in order to see whether our thread is working or not we are going to print something so let's print something using the print function so what we want to print so let's say we want to print the name of the thread whatever name we will provide for the thread and then I'm going to just give some indication here let's say this is some line and then we are going to print that time since epoch so in order to print time since epoch we will use this time module and then we just need to use the time function inside the time module so using this print function we will know which thread is executed and at what time it's executed so now we have our function and now this function we want to execute inside the thread so in order to execute this function inside the thread first of all I'm going to use this thread module and there is a special function inside this tread module which is called a start new thread function so I'm going to use that function so let's just call this function which is thought underscore new underscore thread now if you hover over this function and when I press ctrl on Windows or command on Mac and then I hover over this function you will be able to see the signature for this function so this function takes 3 arguments 1st argument is the function which we want to execute inside the thread second argument is args which we provide to our function as tuples so 2nd argument we need to provide as tuple and inside this tuple we will provide the number of argument which we want to provide to our function and third argument is that kW adds option and this kwr is an optional dictionary for the keyword arguments so let's provide the function name first of all and our function name which we want to execute is print underscore epoch and you need to remember that you need to provide this function name without any parentheses okay so just provide the function name as the first argument second is the number of arguments so we have provided two arguments for this print a pop function so we need to give these two argument in the form of tuples so first argument let's say is the name of the thread so we are going to just say that this is the thread 1 which will be the name of this thread and the second argument is the delay in seconds so let's say I want to provide 1 second delay in the while loop so it will sleep for one second this delay we are providing in order to see the thread execution because thread execution is so fast that it will be difficult to see the execution of threads without this delay now I told you that the third argument is the optional argument so we will not provide the third argument to the start new thread so this statement is going to create a new thread and it's going to execute this function inside this new thread so till now we only have one thread so let's create the second thread and to create the second thread you need to repeat this function which is start new thread and then you need to give the name to your thread so I'm going to give the name thread too and let's just change the delay so here I am going to provide the delay of 3 second to the thread 2 so now we have created two threads and this function will be executed in both that threads so let's see if this code works or not so I'm going to just run the script and you will see as soon as I run the script it exists without printing anything and this is because thread takes some time to be created and we need to wait for the thread creation so we need to provide some mechanism to wait for that thread creation and this wait we can provide in two ways one is we can just provide the blank input function which waits for the input so using this input function we will wait for some time until these threads are created and now we will see if this works or not so let's run this script once again and let's see what happens so you can see now you will be able to see these print State and you will see that first of all thread one is executed and then thread one is executed once again because we have provided only one second delay between the loop inside this thread so thread one will be executed faster than thread two so first of all thread one is executed and the ik bak time is printed and once again this thread one is executed because the delay time is less and then thread two is executed and the Epoque time is printed here and then thread one is executed once again and at the end you will see that thread two is executed two times because you can see that here we have the counter limit which is less than three so let's try to increase this limit to five and let's see how many times this print statement is printed so let's run the program once again and let's see what happens so once again this thread one is executed two times and then thread two and then thread one is executed three times once again and then tried to comes and you can see rest of the threads are executed then so here you can see thread one is executed one two three four five times and thread two is executed also five times so in this way you can start multiple threads and execute different functions inside those threads now I told you there is another way of waiting and this is by providing the while loop so I'm going to just provide wild one and inside this while loop I'm going to wait forever so I'm going to just say pass and this is an infinite loop which is like waiting so I'm going to just close this script first of all and then run the script once again and then you will see the same effect which you have seen in the case of input function also now here one more thing to consider is the return of this function so if this function which you want to execute inside the thread returns successfully the thread will silently exit but when your function terminate unexpectedly then unhandled exception will be thrown and thus track trace of that exception will be printed on the terminal so if this function throws then strike trace will be printed and this will be an unhandled exception so in order to avoid this unhandled exception you can also provide the try catch block here so here you can provide try and then i'm going to provide some space here and here also and after this code I'm going to just write accept and inside the accept you can provide any error so you can print that this is an error so inside this print function you can just write that this is and or anything which you want to write inside this accept block you can write using the print function or whatever you want to do in order to handle this exception you can do inside that accept block so let's run this script once again and let's change the delay here so I'm going to provide the delay of two seconds and here I'm going to provide the delay of let's say four seconds and let's run the script once again and this script runs and you can see after two seconds the thread one print statement is executed and then after four second thread two print statement is executed and this tried execution you will be able to see in those intervals so this is how you can use thread module in Python 3 in the last video we have seen how to use thread module in Python now in this video I'm going to show you how to use threading module in Python and I'm going to give you some introduction about threading module how to create threads using threading modules and how to use threading module now threading module is more powerful and it has more higher level support for creating threads in Python so let's see how to use threading module in Python so in order to use threading module first of all we need to import it so I'm going to just import threading module and once threading module is imported we will be able to use threading module the second module which I am going to import here is the time module which we have also seen in the last video because we are going to create the same function and we are going to use this function using the threading module which we have seen in the last video now I'm going to create the same method which I have created in the last video also which is print a box so I'm going to just copy this method in order to save time and then I'm going to just paste it here so now we have our function which we want to call using the threading module and we want to create some threads using this threading module and call this function inside those threads so first of all I'm going to write this condition which is for the main method which is if name is equal to underscore underscore main underscore underscore and under this condition what I'm going to do is I'm going to create two variables let's say first variable name is t1 for thread 1 and then I'm going to call the threading module to create a thread now inside the threading module there is a class called thread which we will use to create threads so just call the thread class here and constructor of this class takes several argument when you hover over here inside the parentheses you will see the signature of this thread class so it can take the target it can take the name of the thread and arguments also it can take in the form of tupple and it can also take the keyword argument in the form of dictionary so for our purpose we need to call the function which is print Apoc so we need to provide a target so in order to provide target we are going to just write target equals and the name of the function so the name of the function is print epoch which we are going to call and this you need to give without the parentheses so just remove the parentheses in front of this method when you use it as the argument in front of target the second argument which we want to give here is the arguments which this function takes so this argument we can give using the odds parameter so I am going to just write as equals and then in the form of couple I'm going to give the name of the thread and that delay to the thread so let's give the name to the thread let's say this is thread 1 and the delay which we want to give here is 1 so this statement is going to create one thread and let me create one more thread in order to create multiple threads and instead of T 1 I'm going to change the name to T 2 so we have T 1 variable and T 2 variable and in the arcs I'm going to change the name of the thread which is thread 2 and let's say I want to give this delay of 2 seconds to the function using the thread 2 so now we have two variables T 1 and T 2 which is an instance of that thread class now using T 1 and T 2 we can call a method called start in order to start the thread so I'm going to just call T 1 variable and then call a method called start which is going to start the thread T 1 similarly I am going to call the instance T 2 and I'm going to call the method start on this instance T 2 also so start method we use to start that threads now if you remember in the last video when we have created the thread using the thread module we have given this condition which is the infinite loop and this infinite loop we have used to wait until the execution of thread is completed now in the trading module which is the new module this facility is available using a method called join so on T one instance I can call a method called join and on T two instance also I can call a method called join and this join method waits until thread one and tried to is completed its execution and then at the end we can print something let's say we are going to print that everything is done so I'm going to print done here so let's rewind what we have done inside this script we have an imported threading module and time module and then we have created the function which we want to call using that threads now in order to create the thread using threading module we need to call the class called thread inside the threading module now this class constructor takes several arguments and right now we have given two arguments to this thread constructor which is the target which takes the name of the function which we want to execute using this thread and second argument we have given here is the args which is the argument which we want to give to the function which we want to execute same we have done for the thread two also now the start method on these instances is going to start the thread for T 1 and T 2 and the join method we have used to wait until thread 1 and thread 2 is completed their execution so let's run this script and let's see what happens so I'm going to right click and then run the threading example Python script and you can see straight away that this output is printed here similar output we have seen in the case of thread module also so in this output thread 1 is printed and the Epoque time is printed and then thread 2 is printed printed using the thread 2 so this output is printed using the thread 1 and thread 2 output is printed using the thread 2 and because we have given different intervals for a thread 1 and thread that's why we can see that thread 1 is printed and then thread 2 and then thread 1 is printed two times and then thread 2 is printed and then thread 1 is printed once again two times and then rest of the thread two outputs are printed now let's take one more example and what we are going to do at this example is we are going to create two different functions and we are going to try to call these two functions using these two threads so the first function I'm going to create here is the print underscore a cube which is going to print the value of cube of the number which we will provide as the argument to this function so I'm going to just write print here and then using this print statement I'm going to print the value of cube of the number so here I'm going to just write cube and then I'm going to provide these curly brackets and then I'm going to call the format method after this string so let's call the format method which we use in order to format a string now inside the string we want the cube of the number so we will just multiply this number three times so num Astrix num Asterix num which is going to print the cube of the number once again let me just copy this function and then I'm going to create one more function and this time I'm going to name my function as print square so I'm going to just write print square here and then I'm going to just write square is equal to and here I'm going to just print the square of the number now in this statement where we have created t1 and t2 instances the target we can change which is the name of the function so now our target is print cube and print square without the parenthesis we to give the name of this function so print cube and print square and arguments have also changed so earlier print epoch used to take two argument and now we just want to give one argument to the function and let's say it's two and also the print queue function takes one argument and let's say it's two also now let's run this script and let's see what happens so you will see that there is an exception here which is some kind of a weird exception which says that exception in thread two and this exception is this print square argument afters Asterix must be iterative all right so the problem here is we need to give a comma here which tells this parenthesis that this is a couple value okay that's why it's giving the exception so if your function takes one argument then you need to give the value of that argument and then give the comma so that it's able to understand that it's a tuple and then once again when you run this script you will see the value of cube is printed which is eight and square is printed which is 4 so this cube value is printed using thread 1 and square value is printed using the threaded 2 so in this way you can also call a multiple function using multiple thread instances using threading module so this was a brief introduction about reading module in the last video we have seen how to use treading module to create threads in Python now in this video also we are going to see how to create threads using threading module but we are going to see in this video how to subclass from the thread class which is available inside the threading module and then create threads out of that class instance so to start with I have the same method which is print Apoc which I want to inside that's Fred so now here after this method what I want to do is I want to create a class so I'm going to create a class and the name of the class I'm going to give the name as my thread for example and one thing we need to do here is we need to subclass from the thread a class from the threading module so we are going to just call first of all threading dot thread so we are sub classing from the threaded laws now inside this my class first of all we are going to define the init method so let's define this init method and in this init method we are going to pass two arguments same as this print Apoc function so first argument will be the name of the thread and the second argument will be the delay so let's provide these two arguments first is the name and second is the delay now after this inside this init method we need to call the parents init method which is threading dot red dot in it so we are going to just call threading dot thread dot underscore underscore init method which is going to call the parent init method which is treading dot treaded right now once you have done that we can just simply define some local member variable for the name so first of all self dot name is equal to name and self dot delay is equal to delay so now once we have our member variables what we need to do next is we need to override a method called run which is available inside the thread class in a threading module so I'm going to just define run method and we are going to overwrite this so first of all what this one method do so the run method is the entry point for the thread now in the previous video if you remember we have called the start method on the thread class right so the start method starts the thread by calling this run method so under the hood start method calls this run method so if we override this run method that means when we call the start method from the thread class this run method is going to be called so now we can do some logging here so what I'm going to do is I'm going to print first of all start thread and then I'm going to print and thread now between the start thread and and thread logging I'm going to call the print a pork function and this print epoch function is going to take two arguments which is name so I'm going to just pass the self dot name which we have assigned to the member variable and second is the self dot delay so once again when we call the start method on the instance of this my thread class this run method is going to be called by the start method automatically because we are sub classing from the threading dot thread class now once we have I would run the method and we have created the init method we can create some instances of my class so I'm going to create some instances for example t1 is equal to my thread and then we are going to pass those two argument first is the name so let's say the name is thread one and the delay we want to provide here is let's say one second because this delay is going to go to the print a pork method which is this one right once again we are going to create the second instance let's say t2 and once again we are going to call the my thread class which we have subclassed from the thread class and once again we are going to give these two argument first is the thread so this time I'm going to name it as thread two and the delay I'm going to give here is two second let's say and now after the instance is created we can call the start method and the join method on these two instances so let me just call t1 dot start and then we are going to call the t2 dot start and once we have the start which is going to start the threads we are going to just call the join method and by now you already know what this join method do which is to wait for the thread to be completed so I'm going to just call the join method on t2 also and let's run the script and let's see what happens so I'm going to run the script and you can see first of all start thread has been called which is from the logging of this print method and then thread one is printed and the Apoc time is printed and then thread 2 is printed and the Epoque time is printed because we have given the one second delay for the thread 1 so thread one will be iterated faster than thread two because we have provided the delay of 2 seconds four three two and one second quartz red one as soon as the thread ends we can see this print statement which is n thread and after the end of the thread two we can see this print statement which is and thread two we can also print here so let's print some more things here so we can print the name of the thread so I'm going to just write self dot name and we are going to do the same for the end thread also so I'm going to just print here also self dot name so we will know which thread is starting and we tread is ending once again I'm going to run the program and now you can see start tread thread 1 so 21 is started and then tried to is started and you can see first of all thread 1 is ended and at last thread 2 is ended so this is how you can subclass from the thread class which is available inside the threading module now inside the threading module there are some special methods which we are going to see now so the first method is so let me just go after this start of the threads so here what I'm going to do is first of all I'm going to use the print function and inside this print function I'm going to call the threading module and there are some special methods for example first of all we are going to see what is the active count of threads so what are the number of threads which are there inside this program this is going to print the number of threads now the second method which I'm going to show you is the threading first of all let me just call the threading dot we are going to call the current thread so this is going to print the current thread which is active right now and third match third which I want to show here is threading dot enumerate and this enumerate method is going to enumerate the number of threads which are active so let's run this program once again and let's see what happens so I'm going to just run this program and first of all you will see 3 is printed using this print statement which is threading dot active count so active count is going to give you the number of threads and you already know that we have created two threads and one main thread is already available so total number of threads are three here which is printed now the current thread here this print statement prints this output which is the main thread so right now at the time of this print statement main thread is active now this enumerate method as I said is going to enumerate over all the threads which are available so main thread is available and then we have created thread one which is this one this is the name of the thread one and then when I scroll here you can see thread two is available so total three threads are available main thread thread one and thread so these method you can use to just find out how many threads are there what is the current thread thread and you can also a numerate over all the threads there is one more method so I'm going to call this method here and I'm going to print it inside the print function and this time I'm going to use the instances so T 1 dot and there is a method of available here which is get name which comes from the thread class and because we are sub classing from the thread class this marm and because we are sub classing from the thread class this get name is available inside the my thread class also and same we are going to do here also so print and then T 2 dot get name so this is going to give you the name of the thread by default so I'm going to just run this script once again and you can see this is going to print thread 1 and this is going to print thread 2 now you might wonder why this name is thread 1 hasn't tried to because this get name method is going to give the value of self dot name which we have assigned using this name argument so this name is overwritten in the subclass which is my thread class and that's why it's giving us thread 1 and thread 2 name which we have provided if we change this name let's say t1 and t2 and once again we run the code you can see the name also changes to t1 and t2 so this is how you can subclass from the thread class which is available inside the training module and we have also seen some of the method which are available inside the threading module which are useful to us in this video we will see how thread synchronization works in the case of multithreading in Python and we will talk about how to use locks in the case of thread synchronization so first of all what is thread synchronization so thread synchronization is defined as the mechanism which ensures that whenever two or more threads are executed in parallel or concurrently and if they are sharing the same resource in that case all the thread should not work simultaneously or parallely on the same resource so let me explain the thread synchronization problem with the diagram so in this diagram you can see there are three threads and all these threads are sharing the same resource it can be a global variable for example so as long as all these threads are accessing this shared resource one by one not at the same time everything will work fine but the problem arises when two or more threads try to access the same global variable or shared resource at a particular time and this kind of situation is called the race condition so a race condition occurs when two or more threads can access the same shared data and they try to change the value of this same shared data at the same time and whenever this kind of race condition occurs the value of the variables may be unpredictable because if two threads working on the same global variable at the same time you will never know which thread has worked on this variable so the result is the unpredictable value of a variable now let me explain this problem with an example so I have this sample code in which in the first line I'm importing threading module and in the second line I am just declaring a global variable now I have two functions here one is thread tasks and other is mean task now inside this thread task function I want to increment the value of X every time by 1 so this is the code for this and I want to increment this value by 1 10 times so that's why I have used this for loop in the range 0 to 9 so it's going to increment the value of X 10 times inside this loop now because this X is a global variable I have just added this global keyword in front of X so our function knows that this X is not a local variable it's a global variable so this function is simple enough it just increments the value of x 10 times inside the loop and this X is this global variable which we have declared outside this function now in the main task what I'm doing is I'm creating two instances using the threading module with the help of thread class this we have already seen in the last video how to create threads using threading module so nothing new in this I have created two instances t1 and t2 and I'm passing the target is equal to the function name which is this function which is try to task so both the threads will call the same function try task and then I'm just starting both the threads with the help of start function and then I'm just using the join methods on both of the instances now here inside our main if condition I'm just calling our main task in which our threads are created and executed and then at last I want to print the value of x when all the thread execution has been completed so let's run this script and let's see what happens so you can see here the result here is 20 which is expected because we are incrementing the value of x 10 times using two threads so the value of X will be incremented ten times by thread t1 and ten times by 22 and as a result the value of X becomes 20 but as soon as I increment the value of this range let's say this is 10000 and I want to just execute this program once again there is no problem until now we can just run this program again I mean again we will not see this problem because we are incrementing the value of x 10,000 times with a single thread so we have two threads and the result is 20,000 which is absolutely fine now let's increment the value of range once again 200 thousand and now I want to show you the problem so as soon as you do this you can see that the thread synchronization problem occurs so here you can see the result is not 200 thousand which we were expecting because for such large value this scenario of thread synchronization is happening so the two threads try to work on the same variable at the same time and as a result the value of X is unpredictable so this thread synchronization problem you will see when you try to work on a same variable multiple number of times so in this case we have a hundred thousand iterations and both the threads try to iterate over the same variable using two threads and the result is unpredictable let's try to execute this once again so you can see the result is always different every time I cute this program because the result is unpredictable so how to solve this problem so one way of solving this problem is by using the locks so first of all let me just change this program and try to use locks in this Python script so to use locks what you can do is you can declare a local variable here for example lock is equal to threading dot class called lock so this is going to give you an instance of lock now this lock class have two method one is acquire and other is release now acquire method is used to lock and release method is used to release the lock so let me just complete this script and then I will explain what does these functions do so what I'm going to do is I'm going to pass this lock instance as an argument of the thread task function so I'm going to just write as is equal to and then we will just pass our lock instance as an argument of this credit task same we will do for the second thread and because we have passed this argument we need to add this argument here also so I'm going to just pass the lock instance as an argument of this function and now at last what we are going to do is just before we change the value of the global or the shed data we use this lock variable and call the method called acquires and just after you finished changing the resource or the shared data you use a method called lock dot release so once again we have passed this lot instance which we got from this lock class as an argument of this function so this is the lock instance and there are two main method inside this lock class which are acquire and release this acquire method you use two acquire the lock this lock can be blocking or non blocking so this acquire method takes one argument which is true or false by default the value of argument is true which means that this acquire is blocking by default so what does this lock dot acquire will do it locks the access of the shared variable in our case this is X and at this time only one thread can work on this variable whatever thread have the access to this function at a particular time so until and unless one thread execution is completed on this variable after that this lock is released that means that the other thread can work on this variable using the lock once again so whenever second thread wants to try to access this variable it will just lock the access to this variable first of all and then work on this variable whatever you want to do you want to increment the value or change the value of x and then release the lock and releasing means that we once again want to allow the other thread to work on this shared resource so this mechanism will allow only one thread to access this shared resource at a particular time so the Treader synchronization problem will not occur so now let's just run the program once again and let's see what's the result so you can see this problem and this problem is coming most likely because of this problem because we haven't provided args as the tuples so we need to provide this AAG as our tupple so always remember whenever you want to pass any argument using this args keyword you need to pass them as tupple so once again i'm going to just try to run this program and you can see the result is whatever we expected so because we are incrementing the value of x hundred thousand times and there are two threads which are working on the same variable so we get the two hundred thousand result which is expected now let me run this program again and again and you can see every time now we get the expected result which is two hundred thousand so this is how you can solve the thread synchronization problem using locks so this is how you can use locks to synchronize your threads in Python I hope you have enjoyed this video and I will see you in the next video
