With timestamps:

00:00 - now before starting our object oriented
00:02 - programming journey in Python let's
00:05 - discuss about what is the difference
00:07 - between the procedural programming and
00:10 - the object-oriented programming so you
00:14 - will have the better idea why we use
00:17 - object-oriented programming now
00:19 - traditional programming languages such
00:22 - as C or Pascal were called procedural
00:26 - programming languages or structural
00:29 - programming languages where the basic
00:32 - unit was functions now programming in
00:35 - these type of procedural languages
00:38 - involves choosing a data structure and
00:42 - then designing the algorithm and then
00:46 - translating that algorithm into a code
00:49 - so if this sounds little bit confusing
00:52 - let me try to explain it with an example
00:55 - so let's say you have been given a task
00:58 - to create a program for a passenger who
01:02 - wants to travel from one place to the
01:05 - another place using a cab service so if
01:09 - we think from the point of view of
01:11 - procedural programming what we do in the
01:14 - procedural programming is we create some
01:18 - global data structure which holds the
01:22 - data so here for example we create some
01:26 - kind of data structure which can hold
01:28 - the data for example in case of a cab
01:31 - service which cab service is it or which
01:35 - type of cab is it and at what location
01:38 - this cab is standing all these kind of
01:41 - data we store in a desta structure in
01:45 - our global environment
01:47 - now after storing the data we design an
01:50 - algorithm so let's see what kind of
01:54 - algorithm we can develop in the
01:57 - procedural programming language for our
01:59 - cab booking service so this is a
02:02 - pseudocode which I have written so first
02:04 - of all the passenger will open the app
02:08 - from which he can book a cab and then he
02:12 - will book
02:13 - cab and once the cab is booked he will
02:16 - wait for the cab and then once cab
02:19 - arrives he will sit in the cab and then
02:22 - he will reach to his or her destination
02:25 - and at the end he will pay the fare of
02:28 - the cab and this is the pseudocode of
02:31 - that algorithm and then we will
02:34 - translate this algorithm into actual
02:37 - code in procedural programming language
02:40 - now in these type of procedural
02:42 - programming languages we construct rate
02:44 - on creating the functions and the major
02:48 - drawback of using these functions is
02:51 - that data and operations on the data are
02:56 - separated that means we need a
02:58 - methodology to send this data to these
03:03 - functions so here we need to send this
03:07 - data which we have saved globally into
03:10 - these functions and these functions take
03:13 - this data either as argument or as a
03:15 - global variable and then perform some
03:18 - actions on this data and give you some
03:22 - result now these kind of functions are
03:24 - passive what do I mean by passive here
03:27 - that is these kind of function cannot
03:30 - hold any information inside them so once
03:35 - you give the data they are able to give
03:37 - you the result back after performing
03:40 - some operations but they cannot save or
03:43 - hold the state or the data so that if
03:47 - you want to use that data in some other
03:51 - place in your code then it will be very
03:53 - difficult using these kind of functions
03:56 - which you use in procedural programming
03:58 - now let's look at the object-oriented
04:01 - approach of doing things so in
04:05 - object-oriented programming languages
04:07 - like C++ or Java or Python the basic
04:12 - unit is class now if we take the same
04:15 - example of a passenger who wants to
04:18 - travel from one place to another using a
04:22 - cab service using object-oriented
04:24 - programming thinking which depends on
04:27 - on the creation of object we can create
04:31 - different kind of object for example for
04:35 - a cab we can create a class called cab
04:37 - and then we can create a class for cab
04:41 - driver and the third class we can create
04:44 - for a passenger okay
04:47 - so a class you can create for any
04:49 - real-life object it can be a car it can
04:52 - be a motorbike it can be a book or
04:54 - employee or a person so object-oriented
04:58 - programming allows us to create object
05:01 - so first of all what is a class so a
05:03 - class refers to a blueprint in which we
05:07 - can have data and methods okay
05:11 - so for example for our cab class what
05:15 - attributes this cab class can have for
05:19 - example a cab service which cab service
05:21 - we want to take what is the make of the
05:24 - cab it is it a Toyota or a BMW or a fox
05:29 - wagon cab at which location this cab is
05:33 - right now what is the number plate of
05:36 - that cab so the passenger can recognize
05:38 - this cab so all these things which I
05:42 - have written here are called data
05:46 - because they can hold some kind of data
05:49 - number plate has number plate data
05:51 - location have geolocation data may have
05:55 - the make data cap service can have data
05:59 - like uber or any other cab service and
06:02 - the other thing which at last can have
06:05 - are called method so earlier we have
06:08 - seen that we can create functions and
06:10 - when these functions you use inside a
06:13 - class they are called method ok so
06:17 - functions inside a class are called
06:20 - method now the data inside this object
06:23 - or class is called attributes or the
06:27 - member variables which can hold some
06:31 - data and using this class we can create
06:34 - object of the cab class which means we
06:39 - can create different or
06:41 - object using a same class and how to
06:44 - create object using classes we will see
06:47 - in the next video in the real-life
06:49 - example so don't worry if you don't
06:51 - understand how these things works I will
06:54 - give you a real-life example so you will
06:56 - be able to understand in a better way
06:59 - now what is an object an object is a
07:02 - software unit that combines data and
07:06 - methods okay so we have this data here
07:09 - and then we have the methods inside the
07:12 - class and object is able to combine both
07:16 - of them which is data with the methods
07:20 - now these object for example a cab
07:22 - object and the passenger object can
07:25 - exchange the data between them also so
07:29 - data is interchangeable between for
07:33 - example the passenger object and a cab
07:37 - object so let's rewind once again what
07:40 - we have learned about object-oriented
07:42 - programming so the basic unit in
07:45 - object-oriented programming is a class
07:48 - and at last refers to a blueprint which
07:52 - can have the data and methods now using
07:57 - a class we can create objects and what
08:00 - is an object object is an instance of a
08:04 - class and each object can have its own
08:07 - data and method and an object is able to
08:11 - store the state of some kind so at which
08:15 - location this cab is right now so this
08:19 - is a state and an object is able to
08:22 - store at that state now in procedural
08:25 - programming if you remember there is no
08:27 - relation between the data and the method
08:30 - right we need to provide the data to the
08:34 - method which are separate entities in
08:36 - the procedural programming language now
08:39 - these data members are called attributes
08:41 - or member variables and these functions
08:45 - which you define inside a class are
08:48 - called methods and what are some of the
08:51 - key differences between procedural
08:53 - programming language
08:54 - and object-oriented programming language
08:57 - the first is the unit in procedural
08:59 - programming language is function and on
09:02 - the other hand in object-oriented
09:04 - programming the unit is class the second
09:07 - is the procedural programming
09:09 - concentrate on creating functions while
09:13 - object-oriented programming starts from
09:15 - isolating classes and then they can have
09:19 - data and methods inside it in procedural
09:24 - programming language the data and the
09:26 - functions are separate and in
09:29 - object-oriented programming language
09:31 - data and methods are not separate they
09:34 - are at the part of a single object of
09:37 - Atlas now if all this seems to be little
09:41 - confusing to you don't worry you are not
09:44 - alone and I will try to solve this
09:47 - confusion in the next video in which I
09:51 - will tell you how to create the classes
09:53 - and how to use classes in Python in this
09:57 - video I'm going to show you how you can
09:59 - create your first class in Python now if
10:03 - you haven't seen my last video in which
10:06 - I have discussed what is object-oriented
10:09 - programming and what are classes I will
10:12 - highly recommend you to watch that video
10:15 - because this will be a continuation of
10:17 - that video so let's create a class in
10:22 - Python so for that I will create a new
10:25 - project so let's create a new project in
10:28 - PyCharm so just click on file here and
10:31 - then click on new project and then the
10:34 - project name I'm going to give here is
10:36 - oops
10:37 - and then I will just click on create and
10:40 - I will choose this option which says
10:43 - open in current window and also this
10:46 - option which is added to currently open
10:49 - the project which is going to create
10:51 - this project in this window itself which
10:54 - is already open so now you can see we
10:57 - have a empty project here and inside
11:01 - this project let's create a Python file
11:03 - so right click on the project and then
11:05 - new and then we are going to create a
11:07 - new
11:08 - file and let's create a class called car
11:12 - so I'm going to name the file name as
11:16 - car because we are going to create the
11:18 - car class now in order to create a class
11:22 - in Python you use a keyword class and
11:26 - then you give the name to your class so
11:31 - the class name in our case is car and
11:33 - then you give the schoolin and for
11:37 - example I write here a keyword called
11:41 - pass now when you write this keyword
11:44 - after the declaration of a class this
11:48 - means that it is a empty class you can
11:52 - also use this pass keyword to create an
11:55 - empty method so this keyword pass is
11:58 - used to create an empty class or an
12:02 - empty method now here after the class
12:05 - declaration let's see how we can create
12:08 - an instance of a class so it's really
12:11 - easy to create an instance of a class so
12:13 - let's create a first object and I'm
12:15 - going to name it as Ford which is a car
12:18 - brand and then you use your car class
12:22 - name and use these parentheses here okay
12:25 - so this here Ford is an object or you
12:31 - can also say it's an instance of that
12:34 - last car in a similar way we can create
12:37 - multiple objects for example Honda is
12:41 - another car brand and you can create the
12:45 - Honda object using this class car once
12:49 - again you can create a new object for
12:52 - example Audie and then you can once
12:54 - again use this car class to create this
12:58 - object so what we have done till now we
13:01 - have created three object from that last
13:05 - car now in the previous video I told you
13:08 - that you can associate some data with
13:11 - your object so let's associate some data
13:14 - so for example Ford we can associate
13:19 - attribute called speed
13:21 - right so we can assign the speed for
13:25 - example 200 here for a Honda we can
13:29 - assign speed let's say 220 and for Adi
13:35 - we can assign the speed let's say 250 so
13:39 - speed here is called the attribute and
13:42 - whenever you create an empty class using
13:45 - this pass keyword you can add these
13:48 - attributes on the fly so you can see we
13:52 - have added these attribute after the
13:55 - Declaration of the class and after the
13:59 - creation of the objects let's add some
14:02 - more attribute to these instances or the
14:05 - object so a car can have the color so
14:09 - I'm going to just write color and the
14:13 - food has let's say the red color and let
14:18 - me just copy and paste here and let's
14:21 - say the Honda have the blue color and we
14:27 - have the Adi of black color so once
14:31 - again color is an attribute here if you
14:35 - want to print these attribute you can
14:37 - use this print method and then for
14:40 - example we want to print the speed of
14:42 - food and the color of Ford then we can
14:48 - do it like this and let's run the code
14:51 - so in order to run this code first of
14:53 - all when you create a new project and a
14:56 - new python file you need to right click
14:59 - on this file and then click on run the
15:03 - file name whatever is your file name my
15:05 - file name was car so you can see now the
15:09 - result is printed here first is the
15:12 - speed and second is the color of an
15:16 - instance ford similarly you can print
15:19 - the color and speed of honda and audi
15:22 - objects also now if you want to change
15:25 - some attribute it's also possible so
15:28 - let's say I want to change the speed of
15:31 - Ford object so I'm going to use 4 dot
15:35 - speed once again and this time I want to
15:38 - assign 300 speed to this attribute let's
15:42 - say we also want to change the color of
15:45 - the food objects so I'm going to just
15:48 - use for dot color and this time I want
15:51 - to use the color blue here and let's
15:55 - once again we will try to print the
15:59 - color and speed of the object food and
16:02 - now you can see this result so before
16:06 - the speed was 200 and the new speed is
16:09 - 300 for the object food and before the
16:12 - color was red and the new color is blue
16:15 - for this object for now if you have
16:18 - followed the last video this speed and
16:21 - color is the data so speed and color are
16:24 - the variables which holds some data
16:27 - inside them but still we haven't added
16:30 - any behavior or methods to our class car
16:35 - and that we will do in the next video
16:38 - now let's create a new class because
16:41 - understanding classes in any language is
16:45 - difficult so let me give you another
16:47 - example so this time I'm going to create
16:51 - a new Python class and I'm going to name
16:53 - this python class as a rectangle and
16:57 - then press ok which is going to create
17:00 - this class and to create a class you
17:02 - already know you use the keyword and the
17:05 - name of the class and then the colon and
17:08 - we will also make this class an empty
17:12 - class using this path keyboard and in
17:15 - order to create an instance I'm going to
17:17 - just write correct one which is the
17:21 - first object using the rectangle class
17:24 - and then I'm going to create correct to
17:29 - which is the second object using this
17:32 - rectangle class and now what are the
17:35 - attributes which we can relate to the
17:38 - rectangle a rectangle have a width and
17:41 - the height so let's add the herebut and
17:45 - height so let me use the first object
17:48 - let's say height is 24 the rectangle 1
17:52 - and then we are going to use the second
17:55 - object and once again we are going to
17:58 - add the height for the second rectangle
18:02 - let's say the height of second rectangle
18:04 - is 30 similarly we can add the width to
18:09 - the rectangle so width is equal to let's
18:12 - say it's 40 and right to object have the
18:18 - width let's say 10 so what we have done
18:21 - here we have created a rectangle class
18:24 - and then we have created two instances
18:27 - of the rectangle class correct one and
18:30 - rag2 which are also called
18:32 - objects and then we have added some
18:35 - attributes to our objects which are
18:39 - height and width now let's say you want
18:41 - to calculate the area of these two
18:44 - rectangles I can use the print method
18:47 - and then what is the area of the
18:49 - rectangle
18:50 - it's the multiplication of the height
18:53 - and the width right so I can use this
18:58 - rectangle one object and then I can call
19:02 - the height and width of this object and
19:05 - this will give me the area of the
19:10 - rectangle one using this multiplication
19:12 - operator similarly I will do the same
19:16 - for the object to here and let's run the
19:20 - code and if you remember what we need to
19:22 - do if we create a new Python file we
19:24 - need to right-click on the file and then
19:28 - click on run right so once the file is
19:32 - running you can choose from here which
19:35 - file you want to run but at least once
19:38 - you need to right-click on the file and
19:40 - just click on run whatever file name you
19:43 - have so you can see the area of
19:45 - rectangle 1 is 800 and the area of
19:49 - rectangle 2 is 300 so this is how you
19:52 - can create a very simple class in Python
19:55 - in the next video I'm going to show you
19:58 - how to add behaviors to your class that
20:02 - means
20:02 - to add methods to your class and how to
20:05 - use this method to manipulate this data
20:08 - which we have provided here in the form
20:11 - of attributes in this video I'm going to
20:14 - show you how to use init method in
20:17 - Python and how to use a keyword called
20:20 - self in Python so I will continue with
20:23 - the class which I have created in the
20:26 - last video and this was the class which
20:29 - we have created and we have used this
20:31 - special keyword passed there and pass we
20:36 - were using to create an empty class now
20:39 - I'm going to remove this pass and I'm
20:42 - going to add a method called init here
20:46 - so I'm going to just write def and then
20:49 - underscore underscore in it and then
20:52 - press enter and you can see this init
20:56 - method is created here so this is like a
21:00 - normal method with double underscore in
21:03 - front and back of this init keyword and
21:06 - you will also see the self keyword is
21:10 - already added as the first argument of
21:14 - this method now this init method serves
21:18 - as a constructor for the class so
21:21 - usually it is used to initialize some
21:25 - attributes or some functions because
21:29 - this is the first method which will be
21:32 - called when you create an instance of a
21:36 - class so here we are creating an
21:38 - instance of a class and this init method
21:41 - will be the first method which will be
21:44 - called when this object or instance will
21:48 - be created so let's check what I am
21:50 - saying so let's say I want to print
21:53 - inside this init method that the
21:56 - underscore underscore init underscore
22:00 - underscore is called and let me run this
22:04 - code so I will change this to car and
22:06 - then run this code and now when I see
22:09 - this result you will see this line is
22:13 - called three times because
22:16 - we have created three instance from the
22:18 - same class okay so every time this
22:22 - instance is created this print is called
22:26 - and that's why this line is printed
22:29 - three times and everything else will be
22:32 - printed after that whatever we were
22:35 - printing for example speed or color of
22:37 - the car will be printed after that now
22:40 - one important thing to notice here is I
22:43 - said in it serves as a constructor it's
22:47 - not a constructor although it would be
22:50 - tempting to call this init method as a
22:53 - constructor actually it's not a
22:55 - constructor but it behaves like a
22:59 - constructor because in it is the closest
23:02 - thing we are going to get in Python to a
23:05 - constructor because it is the first
23:08 - method which is called whenever an
23:12 - instance is created now if you are
23:14 - familiar with other object-oriented
23:16 - programming languages like Java and C++
23:20 - there is a destructor also in those kind
23:24 - of languages with classes now Python
23:27 - doesn't have any destructor because
23:30 - python has an automatic garbage
23:33 - collections so you don't need a
23:35 - destructor in Python because python will
23:38 - take care of anything which should be
23:41 - taken care of now as I said usually init
23:44 - method is used to initialize something
23:48 - so instead of initializing the value of
23:51 - speed and initializing the value of
23:54 - color let me just comment this code
23:57 - first of all so I'm going to select
24:00 - whatever I want to comment and then I
24:02 - can press control forward slash to
24:05 - comment all the line you can also go to
24:08 - code and then use this option which says
24:11 - comment with line comment and you can
24:13 - see the shortcut for that ctrl + /o K so
24:18 - this is going to comment your lines of
24:20 - code and now I want to use the speed as
24:24 - the initialization value so after the
24:28 - self keyword like
24:29 - give the next parameter which is speed
24:33 - here and then the third parameter is the
24:37 - color here and now to print the value of
24:40 - speed and color I can use once again
24:43 - print and then first of all I'm going to
24:46 - print the speed and then I'm going to
24:48 - print the color attribute and as soon as
24:53 - you do this and when you try to run this
24:55 - program it will give you an error so let
24:58 - me run the program and it will give me
25:00 - the error it says in it missing two
25:04 - required positional argument which is
25:07 - speed and color okay so once you create
25:11 - an init method and provide any arguments
25:15 - other than self self is automatically
25:19 - provided by Python whenever you create
25:23 - an instance of a class but other than
25:25 - self when you write for example speed
25:28 - and color arguments here you need to
25:31 - provide those argument at the
25:33 - initialization of your class so here
25:37 - first we will give the speed inside
25:40 - these parentheses for example 200 and
25:42 - then the color for example red here okay
25:47 - same we need to do for the other two
25:51 - instantiation of the car class so let me
25:55 - do it for the second instance and also
25:59 - for the third instance and now let's run
26:03 - the code once again and let's see what
26:06 - happens so now you can see everything
26:09 - works fine and no error is given to us
26:13 - and you will also see because this print
26:16 - is called first you can see the speed is
26:20 - printed first and then the color and
26:22 - then this line is printed after that and
26:26 - that means we will get the speed color
26:29 - and this line three times for every
26:32 - instance with different values whatever
26:36 - values you have provided for the
26:38 - instantiation of your car class now
26:41 - usually you provide these arguments
26:43 - because you want to initialize the value
26:46 - of speed so let's try to access the
26:49 - value of the ford object speed and color
26:54 - so let me just uncomment this code and
26:56 - let's run this code and it will give us
26:59 - an error you can see this says that car
27:03 - object has no attribute called speed
27:05 - right so what is the error because we
27:09 - have provided these attribute speed and
27:13 - color but we haven't assigned these
27:15 - values to any attribute inside this car
27:18 - class earlier what we have done is we
27:22 - have assigned the speed value to a speed
27:25 - attribute and the color value to the
27:28 - color attribute but we have already
27:30 - commented those codes so how can we
27:33 - assign the speed and color to the car
27:36 - object so it turns out that you can use
27:39 - the self keyword and then using the self
27:43 - keyword you can assign the value to the
27:46 - current object so self is essentially
27:49 - the current object okay it's similar to
27:52 - using this in C++ or Java if you are
27:57 - familiar with those two languages so you
27:59 - use self dot and then the name of the
28:02 - attribute for example speed in our case
28:05 - is equal to whatever argument you
28:07 - provide for speed so we have provided
28:09 - the same argument which is speed is
28:11 - itself once again I can use self to set
28:16 - the value of color here so self dot
28:20 - color is equal to color let me remove
28:22 - this semicolon because it's not required
28:24 - and now when I run this code you will
28:28 - see that there is no error now so
28:32 - because we have now used the self
28:35 - keyboard to set the attributes of speed
28:38 - and color so we can easily access the
28:40 - values of the speed and color using any
28:44 - object of the car class so let me once
28:46 - again minimize this so now let's talk
28:49 - about the self keyword here so whenever
28:52 - you create a class the first argument of
28:55 - everyman
28:56 - third you need to provide this keyword
28:59 - self now it's not necessary to provide
29:02 - this same keyword which is self but it's
29:05 - a convention to write this self as the
29:08 - first parameter the first parameter can
29:11 - be for example ABC it doesn't matter but
29:14 - you need to use this ABC here also as
29:18 - self and it will be totally fine but
29:21 - it's a convention that we use the self
29:24 - keyword in order to indicate that this
29:27 - is the current object so every method
29:30 - you will create you need to give this
29:32 - self keyword as the first argument of
29:35 - your method inside at last now you may
29:39 - also observe that here when I am
29:41 - initializing this class instance I'm not
29:44 - providing any self keyword so even
29:48 - though in the init method I have
29:50 - provided three arguments
29:52 - I am only providing two arguments here
29:54 - so it turns out that you don't need to
29:56 - provide the first argument which is self
29:59 - it will be automatically be provided to
30:02 - your class so you just need to give the
30:06 - next argument whatever argument you give
30:09 - after the self so we have given speed
30:12 - and color after the self argument so we
30:15 - just need to provide those arguments
30:17 - after whatever you use after this
30:19 - keyword called the self so let's do the
30:22 - same thing with our second class which
30:24 - is the rectangle class and here also we
30:27 - have created this empty class so let's
30:29 - remove this pass keyword and instead of
30:32 - this pass keyword we will use this init
30:35 - method which is def underscore
30:38 - underscore init underscore underscore
30:40 - and here after the self we will provide
30:44 - the height as the second argument and
30:47 - the width as the third argument okay and
30:52 - then we are going to initialize the
30:55 - attributes height and width using this
30:58 - self keyword so self dot height is equal
31:02 - to height self dot width is equal to
31:07 - width okay so
31:09 - this is how you can initialize your
31:11 - attribute using this init method and now
31:15 - when you do this you don't need to
31:18 - initialize these values like this you
31:21 - can directly initialize this height and
31:24 - width using these parentheses let me
31:28 - provide these values let's say 20 and 60
31:31 - for the first rectangle and let's say 50
31:35 - and 40 for the second rectangle and when
31:38 - we run this code let me just change the
31:41 - file here and then run the code and you
31:45 - will see it will print the area once
31:47 - again here so this init method is used
31:50 - to initialize your attributes or
31:53 - whatever you want to initialize at the
31:56 - start of your class you will do all
31:59 - those initializations inside this init
32:03 - method in the last video we have seen
32:05 - how to use init method and self keyword
32:08 - in Python in this video also we will
32:12 - discuss more about init method and the
32:15 - self keyword so let's get started
32:18 - so here I have a very simple class
32:20 - called hello and in this class I have a
32:22 - method called init and I'm just
32:25 - instantiating this class and creating an
32:28 - object out of this hello class
32:31 - now the first question which may arise
32:33 - is what if I don't want to use this self
32:38 - keyword you can see directly that there
32:41 - is a red squiggly line appears here
32:44 - which means an error and this we can
32:46 - also see when we run the program so when
32:49 - we run the program it's going to give us
32:51 - this error which says in it takes zero
32:54 - arguments but given one now you may ask
32:58 - why it's saying that we have given one
33:01 - argument to the initialization of this
33:04 - hello class so as I said in the last
33:07 - video that self is automatically passed
33:10 - when you initialize a class and that's
33:13 - why it says that one argument is given
33:17 - but in it takes zero argument because
33:20 - here we haven't given any argument
33:23 - and inside these parentheses so self is
33:27 - absolutely important so you need to give
33:30 - the self now the second question you may
33:32 - ask is can I create multiple in it
33:36 - method inside a class so let's see if
33:38 - it's possible or not so here I'm going
33:41 - to give this pass keyword which means
33:44 - that this init method is an empty method
33:47 - and let me create a second init method
33:50 - and this time I want to add one more
33:54 - parameter here let's say name okay
33:58 - so we have provided two init methods
34:01 - here and let's see what happens so this
34:04 - is the instantiation of class where I
34:06 - haven't given any argument to this
34:10 - instantiation so I'm going to run the
34:12 - program and what it says it says init
34:16 - missing one required positional argument
34:20 - which is named so it turns out that it's
34:24 - not possible to provide multiple init
34:28 - methods in your Python class if you
34:32 - provide multiple init method in your
34:35 - Python class the init method which you
34:37 - define at last will be considered as the
34:41 - main init method and other will be
34:44 - overwritten okay so whatever init method
34:49 - you define at last that signature of
34:52 - init method will be valid and all the
34:55 - other init method which you will create
34:57 - will be overwritten by the last init
35:00 - method
35:01 - okay so let's provide the argument name
35:04 - here so I'm going to just provide one
35:07 - argument here and then run this code and
35:10 - it works perfectly fine okay let me just
35:14 - reverse this order so instead of using
35:17 - this init at the top I will use the init
35:20 - which doesn't take any parameter at the
35:23 - bottom now okay and we provided this
35:27 - argument and let's run the code and now
35:30 - once again we get the error which says
35:34 - in it takes one a positional argument
35:36 - but poober provided so one positional
35:40 - argument means that this in it only
35:43 - takes the self argument and nothing else
35:46 - but here self is provided automatically
35:50 - but we are providing an extra parameter
35:52 - here which is not required and that
35:55 - means this init which we have defined
35:58 - later is valid and this previous init is
36:02 - not valid so always remember it's not
36:05 - allowed to use multiple init method in
36:09 - the Python class but if you do this the
36:12 - last init method will be a valid init
36:16 - method and all the other init method
36:18 - will be the invalid init method now one
36:22 - more question you may ask here what if I
36:25 - want to create both kind of instances
36:27 - one which takes no argument here and
36:31 - other which takes one argument or
36:34 - multiple arguments here so the answer is
36:37 - in my previous video in which I have
36:40 - shown you how to provide default value
36:44 - to your arguments so let's say I provide
36:47 - a default value to my argument here now
36:51 - I will create two instances of the same
36:56 - class one takes no argument and other
36:59 - takes one argument and when I run this
37:02 - code no error appears here okay so if
37:05 - you want to create an init method with
37:08 - multiple parameters you can either use
37:11 - this default value for your init method
37:15 - parameters or what you can do here is
37:18 - you can use this parameter which takes a
37:21 - tuple so in the previous video we have
37:24 - seen that we can provide an argument
37:27 - with Asterix in front of it and this
37:30 - means that we can provide multiple
37:32 - parameters to our method here and when
37:36 - we run the code it's also valid we can
37:39 - also provide multiple parameters here
37:42 - and it will also be totally valid so I'm
37:46 - going to run the program once again and
37:48 - you can see it's totally valid
37:50 - if you want to provide multiple
37:51 - parameters to your init method you can
37:56 - use this kind of notation or you can
37:58 - provide the default value to your
38:01 - parameter or the last thing you can use
38:04 - is you can use for example this type of
38:08 - argument which takes the keyword so kW
38:11 - args here okay and this also we have
38:15 - seen when ever you use this kind of
38:17 - notation that means you want to provide
38:20 - the dictionary right key value pair so
38:24 - let me provide some kind of key value
38:26 - pair let's say name is equal to some
38:30 - kind of name here and then let me run
38:32 - the code and it's totally valid it
38:34 - doesn't give us any error so even though
38:37 - multiple init methods are not allowed in
38:40 - Python you can use these type of
38:42 - notations in order to give variable
38:45 - length argument in your init method now
38:48 - let me just remove all the parameters
38:51 - from here and this instantiation from
38:54 - here also and let's take the next
38:57 - question so let's say I want to remove
39:01 - this pass keyword from here and here I
39:05 - want to initialize some values so self
39:08 - dot name is equal to let's say we will
39:12 - provide some name so I'm going to
39:14 - provide argument called name and self
39:19 - dot name is equal to name here and then
39:22 - let's say self dot age here and we
39:26 - provide some value which is not taken
39:29 - from the argument but we provide some
39:32 - static value here is it allowed yes it's
39:36 - totally allowed right so if you want to
39:39 - provide some default value for your
39:42 - attribute you can absolutely provide
39:44 - that without even passing it as an
39:48 - argument so it's not necessary that all
39:50 - the attribute values you need to provide
39:53 - from this argument list you can provide
39:57 - any default or static value here which
39:59 - is not coming as an argument so I hope
40:02 - that clarifies some more
40:04 - details about this init method in this
40:07 - video we will learn how to use
40:08 - encapsulation in Python and capsulation
40:12 - is one of the most important principle
40:15 - in object-oriented programming so let's
40:18 - get started I will be using this car
40:20 - class and the rectangle class which we
40:23 - have been using in the previous videos
40:24 - also and let me remove these print
40:28 - statements because we don't want them
40:32 - right now now let's say we want to
40:34 - change the value of speed so if you want
40:37 - to change the value of speed you can
40:39 - simply take your object for example for
40:42 - dot your attribute name for example
40:45 - speed and then you can directly change
40:48 - it for example 300 and when I run the
40:51 - program it's going to print the new
40:53 - speed which is 300 initially we have set
40:56 - the speed to 200 in here we can also put
41:00 - let's say the speed as string which is
41:03 - very stupid but will it work it works
41:06 - you can see here and this can break the
41:08 - function in which the speed is used so
41:11 - therefore it is very important that we
41:13 - protect our data and only give the
41:16 - access to our data to the other users so
41:20 - encapsulation is particularly important
41:23 - when you want to give your code to some
41:27 - other people because they might want to
41:29 - change your code so let's see how we can
41:32 - encapsulate our code so to encapsulate
41:35 - our code we create functions so let's
41:38 - create our first function which is to
41:41 - set the value of speed so I'm going to
41:43 - just say set underscore speed and inside
41:47 - the parentheses it's going to take self
41:50 - as the first argument which is the
41:52 - default and second is the value of speed
41:56 - so so I can say value here right and
41:59 - then once we have the value of speed we
42:02 - can just call self dot speed is equal to
42:07 - value similarly we can create a get
42:10 - method for the speed so right now we
42:13 - have created the set method to set the
42:16 - speed and now
42:17 - we are going to create a get method to
42:20 - get the speed and in order to get the
42:23 - speed we don't need to pass any argument
42:26 - we just need to return the speed which
42:29 - is already said so we can just write
42:32 - return and then self dot speed so we
42:35 - have created two functions set and get
42:38 - these are also called setter and getter
42:40 - for the attribute which is speed in our
42:44 - case so let's use these functions
42:46 - instead of this kind of setting of data
42:49 - so first of all I'm going to call this
42:51 - for object dot set speed method out of
42:56 - this object and then I'm going to pass
42:58 - the new speed using this set method now
43:01 - in order to get the speed I can write
43:03 - instead of this for dot speed I can just
43:07 - write the for dot get speed which is
43:10 - going to give me the speed of this ford
43:14 - object so I'm going to run the code and
43:16 - you can see it prints the speed which we
43:19 - have set using the set method but still
43:23 - will this protect your data let's see so
43:26 - I am going to once again try to use for
43:30 - dot speed and then I will try to set the
43:34 - new value of speed will it be a problem
43:37 - no so you can see when I try to get the
43:41 - speed that new speed is set and we want
43:44 - to prevent this kind of setting of data
43:47 - using this equals to symbol so we need
43:50 - to somehow make our attribute private
43:54 - now if you are familiar with other
43:57 - object-oriented programming languages
43:59 - like Java or C++ they use the keywords
44:03 - like public private or protected in
44:06 - order to mark their attributes or the
44:09 - member variables as the private or
44:12 - public or protected but python doesn't
44:15 - have any of these keywords so how we can
44:18 - make our data private so let me give you
44:21 - first of all an example so I am going to
44:24 - go to this class which is hello and Here
44:27 - I am going to set some values so first
44:30 - value is
44:31 - for example self dot a is equal to ten
44:37 - second value is self dot underscore B is
44:41 - equal to 20 and the third value is self
44:45 - dot underscore underscore C is equal to
44:50 - 30 so we have created three member
44:53 - variables in this hello class
44:55 - one is a second is underscore B and the
45:00 - C is with two underscores in front of it
45:03 - and let's try to access all these three
45:06 - values so I'm going to just use the
45:09 - print method and then the hello object
45:12 - dot a and similarly I will use the
45:17 - sprint to get the value of dot
45:20 - underscore B and also dot underscore
45:26 - underscore C now let's try to run this
45:29 - program and let's see what happens and
45:31 - you can see here the first value which
45:33 - is printed here is 10 which is the value
45:36 - inside the a variable so this code was
45:38 - executed successfully now we can see
45:41 - here that 20 is also printed that means
45:44 - this code is also executed successfully
45:47 - but at the time of underscore underscore
45:50 - C when we want to use this underscore
45:54 - underscore C outside the class it says
45:58 - hello object has no attribute called
46:01 - underscore underscore C and this is the
46:04 - point
46:05 - so underscore underscore you can use to
46:08 - make your attribute private okay so this
46:12 - is our convention there is no keywords
46:15 - like private in Python that's why python
46:18 - uses this kind of convention in which
46:21 - whenever you use double underscores it
46:24 - makes your data private when you use
46:27 - single underscore that also means that
46:29 - it's a private variable but this is only
46:32 - a convention nothing stops you to change
46:35 - the value of underscore B or accessing
46:38 - the value of underscore B okay so if you
46:42 - truly want to make your data private
46:45 - then use double underscore in front of
46:48 - your variable when you use single
46:51 - underscore that means it's a partially
46:54 - private variable and it's only a
46:56 - convention okay so let's go to our car
47:00 - class once again and now we know that we
47:04 - can add double underscore in front of
47:07 - our variable names so we have two
47:10 - variables here one is speed so let's add
47:13 - double List underscore in front of speed
47:15 - and also let's add double underscore in
47:18 - front of this color variable to make
47:21 - both of them private so I'm going to
47:23 - change this value of speed in getter and
47:26 - setter also and now let's try to access
47:28 - this value using this ford object which
47:32 - is underscore underscore speed now let's
47:34 - try to run our program so I'm going to
47:36 - change the file and then run our program
47:38 - and you will see that it's going to give
47:41 - us an error and this error says the car
47:44 - object has no attribute called color
47:46 - because this variable color is private
47:50 - now also you will observe that the value
47:53 - of the speed is 300 which is set by this
47:58 - set function even though we have set the
48:01 - speed again to 400 using this underscore
48:05 - underscore speed but this speed is not
48:08 - changed right so we cannot change the
48:11 - speed using this underscore underscore
48:13 - variable because now it's a private
48:16 - variable and that means we cannot change
48:19 - the value using this variable we need to
48:22 - use this set function in order to change
48:26 - the value of the speed also if you want
48:29 - to use this underscore underscore color
48:32 - here and let's run the code this will
48:34 - also give you an error because this
48:36 - underscore underscore color is private
48:38 - so either you can remove this code or
48:42 - you can create the setter and getter
48:44 - method for the color also so let's
48:47 - create the setter and getter method for
48:49 - the color
48:54 - and now we can access the value of color
48:56 - using the get color method right so
49:00 - instead of this get speed we can just
49:03 - write for dot get color and it's going
49:07 - to give us the value of color and now
49:09 - you can see that there is no error and
49:12 - the speed here is 300 which we have set
49:15 - using this set speed method and color is
49:19 - red which is the color we have given
49:21 - using this argument in the constructor
49:24 - and this type of restricting your data
49:27 - access using functions is called
49:30 - encapsulation let's do the same thing
49:33 - with our rectangle class also and let's
49:36 - create the setter and getter method
49:38 - inside the rectangle class so you
49:41 - already know we can use this define and
49:45 - then we can first of all set for example
49:49 - set the height first of all and then we
49:51 - can give the value of height here and
49:53 - then self dot height is equal to height
50:00 - right and don't forget you need to give
50:02 - double underscore in front of your
50:05 - attributes in order to make them private
50:08 - so I'm going to do just that and let's
50:12 - create the get height method also
50:19 - so now we have created the setter and
50:21 - getter for the height and let's do the
50:24 - same for the width also
50:30 - so now you have made the height and
50:33 - width as private and we have created
50:35 - setter and getter for the height and
50:38 - weight and now in order to calculate the
50:39 - area we can define one more method here
50:42 - which is the area method so let's create
50:45 - the area method here and this area
50:47 - method is not going to take any argument
50:49 - we are just going to return the
50:51 - multiplication of the height so self dot
50:55 - height multiplied by self dot underscore
51:01 - underscore width okay which will give us
51:03 - the area of this rectangle and we can
51:06 - call this area method instead of using
51:09 - this kind of notation so wrecked one dot
51:12 - area and rect two dot area also let's
51:19 - run the code by changing the file name
51:22 - here and run this code and you can see
51:25 - the area is printed now so this is how
51:28 - you can use an capsulation in python to
51:31 - hide your data in the last video we have
51:34 - seen how to use encapsulation in python
51:37 - and we have also seen how we can declare
51:40 - private member variables in Python to
51:44 - declare a private member variable we use
51:46 - double underscore in front of your
51:50 - variable name and this variable becomes
51:53 - private but the question is what exactly
51:56 - is a private member variable so a
52:00 - private member variable is private to
52:03 - the class that means you can use this
52:06 - private member variable inside the class
52:09 - but as soon as you use it or access it
52:14 - outside the class it will give you an
52:17 - error so you cannot access a private
52:20 - member variable outside a class and the
52:23 - example we have already seen so here you
52:26 - can see I try to access this private
52:28 - member variable outside the class and
52:31 - when I run the code it says that there
52:34 - is no underscore underscore C attribute
52:38 - for this hollow object why because when
52:44 - you create an instance and if the member
52:47 - variable is private
52:49 - this private member variable is
52:51 - invisible to your object so you cannot
52:55 - access the private member variable
52:57 - outside the class but can be used this
53:01 - private member variable inside the class
53:03 - let's see so I'm going to declare one
53:06 - more method here and I'm going to name
53:09 - it as public underscore method and this
53:15 - doesn't take any argument but what we
53:18 - have learned about the methods in a
53:20 - class that even though you don't pass
53:23 - any argument to the method you have to
53:27 - provide at least one argument which is
53:30 - the self argument and what is self self
53:32 - is the current object so let me just
53:35 - print something here quickly for example
53:39 - public here so can we use this private
53:44 - member variable inside this method let's
53:47 - see so I'm going to just write self dot
53:51 - underscore underscore C and then I'm
53:55 - going to run this code and let me
53:57 - comment this line because this was
53:59 - giving us an error and instead we can
54:03 - use this public method so I can use an
54:08 - instance of hello which is hello dot
54:12 - public method and let's run the code now
54:15 - and you can see there is no error that
54:19 - means you can use your private member
54:21 - variables inside the class or any method
54:24 - of ductless now the other question is
54:27 - what is a public member variable like a
54:30 - here so a is a public member variable
54:34 - because it doesn't contain any
54:36 - underscore underscore in front of it and
54:39 - that means you can use this public
54:41 - member variable inside the class as well
54:45 - as outside the class so if I want to use
54:48 - this public member variable inside the
54:51 - class also I can just use self dot a and
54:55 - then
54:56 - run the code and it's totally fine it
54:59 - doesn't give us any error let's print
55:01 - the value of for those two member
55:04 - variables and once again run the code
55:07 - and it will print the value of a and C
55:09 - and then this message which we are
55:11 - printing here which is public here now
55:14 - the next question is how we can define a
55:16 - private method in that class so let's
55:20 - see how we can define a private method
55:22 - you already know most probably which is
55:26 - by using double underscore in front of
55:29 - your method name so for example
55:31 - underscore underscore private underscore
55:36 - method and then I'm going to just print
55:41 - something inside this method let's say
55:43 - private so this is a private method and
55:46 - how you can define a private method
55:49 - using these double underscore in front
55:51 - of the name of your private method and
55:54 - the restriction will be the same on the
55:56 - private methods also so let's try to
55:58 - access this private method outside the
56:01 - class so I have this hello instance and
56:03 - when I press dot here you will see there
56:07 - is no suggestion for this private method
56:10 - because PI Chum already know that this
56:13 - is a private method so it doesn't show
56:15 - this method in the suggestion when you
56:18 - use this object outside the class but
56:21 - let's try the brute force and let's try
56:24 - to use this method outside the class and
56:27 - when I run this code you will see once
56:30 - again you will get an error which says
56:33 - hello object has no attribute underscore
56:36 - underscore private method so private
56:39 - methods also you cannot use outside in
56:42 - the class but inside the class
56:45 - absolutely you can use your private
56:47 - methods so how to use your private
56:50 - methods inside that lass so you can use
56:53 - your private method inside the class
56:56 - using once again a self keyword so you
57:00 - write self dot and then your method name
57:04 - for example private method and that's
57:07 - how you can call your private method
57:09 - inside the class using cells so any
57:11 - method you want to call inside the class
57:14 - you do it once again
57:17 - using the self keyword as you do with
57:20 - your member variable and once again when
57:23 - I run the code now it prints private
57:26 - using this statement and this statement
57:29 - is executed when we call this private
57:32 - method from here so I hope this video
57:35 - will clarify some more doubts about the
57:38 - private member variables and private
57:40 - methods in Python in this video we will
57:43 - talk about Python inheritance so first
57:47 - of all what is inheritance in Python so
57:51 - classes in Python can be extended
57:54 - creating new classes which retains the
57:58 - characteristics of a base class and this
58:02 - process is known as inheritance now in
58:05 - simple words the idea behind the
58:08 - inheritance is that a new class can
58:12 - borrow the behaviors and methods from
58:16 - the another class now the inheritance
58:20 - involves two types of classes one is a
58:24 - superclass and other is a subclass now
58:29 - the subclass inherit members of the
58:33 - superclass on top of which it can add
58:37 - its own members for example any other
58:40 - member methods or variables so here
58:44 - subclass is the one who is doing the
58:48 - borrowing of the members and the
58:50 - superclass is one from which subclasses
58:54 - borrows these kind of member methods and
58:58 - variables now if this inheritance sounds
59:02 - to be little bit confusing to you let me
59:05 - give you an example so I said in
59:08 - inheritance there are two type of
59:10 - classes one is a superclass and other is
59:14 - a subclass now in this example I have
59:19 - taken polygons as a superclass and
59:22 - two classes rectangle and triangle as
59:26 - the subclasses now if you see carefully
59:30 - what is the relationship between
59:33 - rectangle and polygon and triangle and
59:37 - polygon so rectangle is a polygon right
59:42 - and the triangle is also a polygon that
59:46 - means the rectangle can inherit some
59:49 - properties from the polygon class also
59:53 - triangle can inherit some properties
59:56 - from the polygon class and the
59:59 - relationship between the superclass and
60:01 - the subclass is defined by a
60:05 - relationship called is our relationship
60:08 - so rectangle is a polygon and triangle
60:13 - is a polygon also that means that
60:17 - rectangle and triangle can inherit from
60:21 - the polygon class so in inheritance the
60:25 - subclasses have is our relationship with
60:30 - the super classes so let me give you one
60:33 - more example so as a superclass you can
60:35 - take an animal class and then as
60:39 - subclasses you can create a dog class
60:42 - cat class red class because all of them
60:47 - are animals so dog is an animal cat is
60:52 - an animal rat is an animal so always
60:55 - remember when you use inheritance there
60:58 - is a is our relationship between
61:01 - superclass and the subclass now let's
61:04 - take our real-life example and let me
61:07 - try to explain you this concept with
61:10 - some code so I'm going to create a new
61:13 - project in my PyCharm IDE and this I'm
61:16 - going to name it as inheritance and I
61:19 - will choose this option open in current
61:21 - bed door and also this option which says
61:23 - add to the current opened project which
61:25 - is going to create a project in the same
61:28 - window so now this project is created so
61:31 - I'm going to go inside this project and
61:33 - I'm going to create a new Python file
61:36 - here
61:36 - and I'm going to name this file as
61:39 - polygon because we are going to create a
61:42 - polygon class and inside this polygon
61:46 - dot py file let's first create a class
61:49 - called polygon and inside this polygon
61:53 - class what are the attributes which we
61:56 - want to add here so rectangle and
61:59 - triangle what are the common things
62:02 - which they both have they both have the
62:05 - width and the height so we are going to
62:08 - first of all create a variable called
62:11 - width and we will initialize it by a
62:15 - value none the non keyword is used
62:18 - whenever you want to assign nothing to
62:20 - your variables right in the same way I'm
62:24 - going to use height and I'm going to
62:28 - assign none to that also now what I'm
62:32 - going to do is I'm going to create a
62:34 - method here so let me define a method
62:36 - using d EF and I'm going to use this
62:41 - method to set the values of width and
62:43 - height and this method is going to take
62:45 - two argument one is the width and the
62:49 - other is the height right now if you
62:53 - remember in the last video I have shown
62:55 - you how to make your variable private so
62:58 - you use double underscore in front of
63:01 - your variables to make them private so
63:04 - I'm going to add this double underscore
63:06 - in front of width and height that means
63:08 - these two variables are private
63:10 - now using the set values method I am
63:14 - going to just set the values of the
63:17 - height and width so cells dot underscore
63:22 - underscore width is equal to width and
63:26 - self dot underscore underscore height is
63:30 - equal to height so this is the polygon
63:34 - class which we have created and it's a
63:37 - superclass in our case right and now
63:41 - let's define two subclasses one is a
63:44 - rectangle and
63:46 - other is a triangle so let's define
63:49 - other class called rectangle and inside
63:52 - this rectangle I'm going to define one
63:54 - method let's say this method is a area
63:58 - method and this area method is going to
64:01 - give us the area of the rectangle and
64:03 - what is the area of the rectangle the
64:06 - area of the rectangle is the
64:09 - multiplication of the width and the
64:12 - height similarly I'm going to define our
64:14 - triangle class also so let me define the
64:17 - triangle class here and let's say this
64:20 - triangle class also have this method
64:23 - which is area now what is the area of a
64:26 - triangle the area of the triangle is the
64:30 - multiplication of width and height
64:32 - divided by two so we are going to divide
64:35 - the multiplication of width and height
64:37 - by two this is the area of the triangle
64:40 - so now we have defined three different
64:42 - classes and we are saying that polygon
64:45 - is the superclass and rectangle and
64:48 - triangle is our subclasses now how we
64:53 - can inherit the properties of the super
64:57 - class which is polygon into our
64:59 - subclasses which is rectangle and
65:02 - triangle so in order to inherit from one
65:06 - class to another you use this
65:09 - parentheses and inside the parentheses
65:11 - you write the name of your super clasps
65:15 - and that means your rectangle is
65:18 - inheriting from the polygon class
65:22 - similarly when we write this parenthesis
65:26 - and the polygon class here that means
65:29 - triangle is inheriting from the polygon
65:34 - class now when a subclass inherits from
65:37 - a superclass the superclass member
65:39 - variables and methods are accessible
65:43 - also using the subclass also so let me
65:47 - give you an example so I'm going to
65:49 - create the instance of rectangle first
65:53 - of all so let me just write rectangle so
65:56 - this is the rectangle instance and let's
65:59 - create
66:00 - a triangle instance also and now once we
66:04 - have triangle and rectangle instance
66:06 - let's use this rectangle instance and
66:10 - when you write dot here you can see
66:12 - intelligence says that area is available
66:16 - for this object and set value is
66:19 - available for this object so when you
66:22 - use set value you can see we haven't
66:24 - defined the set value method inside the
66:28 - rectangle but because we are inheriting
66:31 - from the polygon class into a rectangle
66:34 - class all the members of the polygon
66:39 - class are available using the rectangle
66:41 - object also and what this method takes
66:44 - it takes the width and height so we are
66:46 - going to provide the width and let's say
66:50 - height 50 and 40 and once again we are
66:53 - going to use the triangle object and we
66:57 - use the set values and this time also
66:59 - let's say I'm going to provide the same
67:01 - values here and what does this set value
67:04 - method is doing it's just setting the
67:07 - values of width and height inside the
67:11 - polygon class now in order to calculate
67:13 - the area we can call the area method
67:16 - from the rectangle and the triangle
67:18 - class so let's just do that and I'm
67:21 - going to do this inside a print method
67:23 - and I'm going to just call the rectangle
67:27 - object dot area which doesn't take any
67:31 - argument and the same I'm going to do
67:34 - for the triangle object also so triangle
67:37 - dot area so what do you think will
67:40 - happen now so let's run the code and
67:42 - let's see what will happen so I'm going
67:44 - to right click on this file and I'm
67:46 - going to just choose run a polygon it's
67:49 - going to run the program and you will
67:51 - see it gives us an error and what is the
67:55 - error the rectangle object has no
67:57 - attribute rectangle underscore
68:00 - underscore width that means because this
68:04 - width and height are private member
68:08 - variables of the polygon class they are
68:11 - not accessible
68:13 - from the subclass which is the rectangle
68:17 - class and the triangle class so you
68:20 - cannot inherit the private members from
68:24 - the superclass into the subclass so what
68:29 - is the solution here so what we can do
68:32 - here is we can create the getter methods
68:36 - for the width and the height so I'm
68:40 - going to do exactly that so let's define
68:42 - a method called def get underscore width
68:48 - and it's going to take no argument and
68:51 - it's going to return the value of the
68:53 - width so using self we can access the
68:57 - value of underscore underscore width in
68:59 - the same way we can define a method
69:02 - called get underscore height here and
69:05 - it's also not going to take any argument
69:08 - but we are going to return the value of
69:10 - the height here so self thought
69:13 - underscore underscore high so now we
69:16 - have created the getter methods for the
69:19 - width and height and these getter
69:22 - methods are the public members why they
69:25 - are public because we haven't used the
69:28 - double underscore in front of these two
69:31 - methods and these two methods now we can
69:35 - use in place of these private member
69:39 - variables which we were trying to
69:41 - inherit in the subclass using the
69:46 - superclass so instead of underscore
69:49 - underscore width we can write self dot
69:52 - get width and also here instead of
69:56 - underscore underscore height we can use
69:58 - get height similarly we will do the same
70:02 - for the triangle class so get width and
70:05 - the get height dot get height now let's
70:11 - run the program again and let's see what
70:13 - happens and now when I run the code it
70:17 - gives me the area of rectangle using
70:19 - this print line statement and then it's
70:23 - going to give me the area of triangle
70:25 - which is exactly the half using
70:27 - this line of statement so let me once
70:30 - again minimize this and let's recap what
70:33 - we have learned so we have created a
70:36 - superclass and two subclasses
70:40 - superclasses polygons and subclasses our
70:43 - rectangle and triangle and in order to
70:46 - inherit from the superclass you just use
70:49 - parentheses and the name of your
70:51 - superclass and that means in our example
70:54 - rectangle is inheriting from the polygon
70:58 - class next what we have learned is all
71:01 - the public member variables or the
71:05 - methods are accessible from the subclass
71:09 - from the superclass so set value method
71:14 - and get value method is accessible
71:16 - because they are public methods but
71:20 - underscore underscore width and
71:22 - underscore underscore height are not
71:24 - accessible because they are the private
71:27 - member variables so you cannot inherit
71:29 - the private member variables into your
71:33 - subclasses now we have seen this example
71:36 - in which we have created two instance of
71:39 - the classes one is rectangle objects
71:42 - from the rectangle class and the other
71:44 - is triangle object from the triangle
71:47 - class and first of all we have used the
71:49 - set method which is coming from the
71:51 - polygon class it's not the part of the
71:54 - rectangle or the triangle class to set
71:57 - the values of width and height and then
72:00 - we have just called the area method from
72:04 - these two classes in order to give us
72:07 - the area so this set method is used to
72:11 - set the value so it has set the value of
72:13 - width and height and using this get
72:16 - method get width and get height this
72:19 - value is returned and this value is
72:22 - returned into the subclasses and then
72:26 - the multiplication of these two values
72:29 - gives us the area here and the
72:32 - multiplication of these values divided
72:34 - by two gives the area of the triangle
72:36 - here so this is how you can use
72:38 - inheritance in Python
72:41 - in this video we will discuss how to
72:43 - create modules in Python now in the
72:47 - previous videos I have already discussed
72:50 - briefly about built-in modules and how
72:53 - to import a built-in module you use an
72:57 - import keyword and then you use the name
73:00 - of the built-in module in Python
73:03 - built-in means this module is already
73:06 - present in Python so we can use these
73:10 - built-in module in order to perform some
73:13 - functionality so for example this math
73:15 - module helps us to perform some
73:18 - mathematical operations now first of all
73:21 - what is a module so it turns out that a
73:26 - module is nothing but a Python file now
73:32 - to prove my point
73:33 - let me just hover over this math module
73:38 - and just press control and then hover
73:41 - over it so right now I am pressing
73:43 - control and I'm hovering my mouse over
73:46 - this mat on the pycharm IDE and now I'm
73:50 - going to click it and when I click it
73:52 - you will see this module is nothing but
73:56 - a file right and inside this module we
73:59 - have a number of functions which we can
74:03 - use for example a COS function
74:06 - or a tan function or many different
74:10 - functions which we can use from this
74:13 - math module so a module is nothing but a
74:17 - Python file now if a module is nothing
74:20 - but a Python file why don't we create a
74:24 - module and it turns out that Python
74:27 - allows us to create our own modules so
74:31 - let's create our own modules and let me
74:34 - show you how you can create your own
74:36 - module and right now you can see in my
74:39 - project there is only one file which is
74:42 - hello dot py and it's empty right now
74:46 - now to create a module I'm going to just
74:49 - create a new file so right click and
74:51 - then new python file and this module I
74:54 - am going to
74:54 - it as my functions and then press okay
74:59 - and this file is created so now I have
75:02 - two files in my project one is my
75:04 - functions and other is hello dot py so
75:07 - let's say I want to create some
75:09 - functions inside this my functions dot
75:12 - py file so let's create some function
75:16 - I'm going to very quickly create some
75:19 - very basic functions which you already
75:21 - know in Python so so let's say I add
75:26 - function which returns the addition of
75:29 - two numbers and also let's create let's
75:33 - say multiply function so multiply and
75:36 - this is going to just give the product
75:39 - of two numbers so let's say this is our
75:42 - module and it has two functions now
75:46 - somehow I need to use these two
75:49 - functions from my functions dot py file
75:53 - into this hello dot py file now as you
75:58 - can see these two files are in the same
76:01 - directory right so I can import this my
76:05 - functions file using import and then the
76:09 - name of the file which is my functions
76:11 - and that's it
76:13 - so in order to import a module you just
76:17 - write a keyword called import and then
76:19 - you just write the name of the file
76:22 - without the extension py okay so you
76:25 - don't need to provide any extension here
76:28 - and then I can use this function so
76:30 - let's say I want to print my function
76:33 - which is the file name so whatever file
76:36 - name you give here you need to use the
76:39 - file name here dot you will see all the
76:43 - functions in the file are now visible in
76:46 - the other file which is hallo dot py so
76:48 - let's use this add function and I'm
76:51 - going to just give two parameters here
76:54 - and also let's use the multiply function
76:56 - from my functions files so the file name
77:01 - and the method name or the function name
77:05 - and let's give two parameters
77:08 - here also and that's it so it's that
77:10 - simple to create your own modules and
77:14 - import them in to other files in Python
77:18 - now when I run this program is going to
77:21 - give me the addition and the product of
77:24 - these two argument which I have provided
77:27 - here now let's say your my functions
77:32 - file is in some other directory so let
77:36 - me create a directory so I'm going to
77:38 - right click here and then I'm going to
77:40 - create a directory and I'm going to name
77:42 - it as dir and then click OK and now I'm
77:47 - going to move this my functions dot py
77:50 - file into the new directory so I'm going
77:54 - to just right click and cut from here
77:56 - this file and I'm going to just paste
77:58 - this file into the dir directory ok so
78:02 - let me just click OK here and as soon as
78:06 - I do this you will see here pycharm is
78:09 - intelligent enough to refactor this code
78:12 - and now it has given us the correct
78:15 - import ok so if this my functions file
78:20 - is in some directory then you use this
78:23 - type of notation so you write from and
78:26 - then your directory name and then import
78:29 - keyword and then your file name so you
78:32 - can see this is the directory name and
78:35 - this is the file name so I use from
78:37 - directory name import file name and when
78:41 - I run the code once again it's going to
78:43 - give me the same answer now there is one
78:47 - more way of writing the same notation
78:49 - and that is using the import so use
78:53 - import keyword and then write the name
78:56 - of your directory dot the name of your
78:59 - file so directory dot the file name and
79:02 - then you use this name in place of your
79:08 - my function name ok and once again when
79:13 - you run the code it runs fine now
79:16 - sometimes you might feel that this is a
79:18 - long name and Python have the solution
79:22 - for
79:22 - it also so it turns out that you can
79:25 - rename your file using a keyword called
79:31 - as so after the import so import
79:35 - directory name dot file name as and then
79:39 - you can provide your name for example my
79:42 - functions I will just name it as MF okay
79:46 - and now I can use this MF name instead
79:49 - of this big name and this will also work
79:54 - fine so either you can import from your
79:58 - file which is inside the directory using
80:01 - this notation or you can use this
80:04 - notation you can also write as in front
80:08 - of this notation also so from directory
80:12 - name import file name as whatever name
80:15 - you want to give here and this you can
80:18 - use to call your function using this dot
80:21 - notation now this was the easy stuff and
80:25 - I have just written here the two
80:28 - functions and then imported these two
80:31 - functions into the other file
80:33 - but what if if I have multiple classes I
80:38 - haven't shown you how to import files
80:40 - which have classes in them so let's see
80:44 - how to import the Python files which
80:46 - have classes inside them so I'm going to
80:49 - close these two files and in the last
80:52 - video I have shown you how to use
80:55 - inheritance in Python and we have
80:58 - created this class polygon and two other
81:02 - classes which is triangle and the
81:04 - rectangle class and this might be right
81:07 - now the perfect candidate to import into
81:11 - some other file so I'm going to create
81:15 - two more file one is the rectangle file
81:18 - so I'm going to just right click and
81:20 - create a Python file and I'm going to
81:22 - name it as rectangle and I'm going to
81:25 - create one more file with the name of
81:27 - triangle so right-click new Python file
81:30 - and the name is triangle dot py and let
81:35 - me create
81:36 - the fourth file which I'm going to name
81:38 - it as main and this will be our main
81:41 - file in which we will import all these
81:44 - classes so in my polygons class I will
81:47 - just leave this polygons class and I
81:50 - will just transfer this rectangle class
81:53 - into the rectangle dot py file and this
81:57 - triangle class into triangle dot py file
82:01 - and also this was the instantiation of
82:05 - the rectangle and triangle class which
82:08 - we have done so I will transfer this
82:10 - code into our main dot py file okay so
82:15 - now we have a polygon dot py file in
82:18 - which we have the polygon class and then
82:21 - we have the rectangle class inside
82:24 - rectangle dot py and also we have the
82:27 - triangle class into the triangle dot py
82:31 - file and rest of the code we have inside
82:34 - the main dot py now when you go to the
82:38 - rectangle dot py you will see that it's
82:41 - inheriting from the polygon class that
82:45 - means we need to import polygon class
82:49 - into the rectangle dot py file so how to
82:52 - import it you can use from and then the
82:55 - file name which is polygon and then use
82:58 - import keyword and use the name of the
83:02 - class which is polygon and you will see
83:05 - that this error is gone and same we will
83:08 - do inside the triangle dot py file in
83:12 - order to import the polygon class into
83:16 - that triangle dot py file so this is the
83:20 - file name so from file name import the
83:23 - class name now when I go to the polygon
83:26 - class we don't need to import anything
83:28 - here because it's a superclass and there
83:30 - is no import needed here let's go to the
83:33 - main dot py file and here you will see
83:36 - red squiggly line under rectangle and
83:40 - triangle class because we haven't
83:42 - imported this triangle dot py and the
83:46 - rectangle dot py into our main dot
83:48 - python file
83:49 - so the procedure is same from your file
83:53 - name which is first of all rectangle
83:56 - import the name of the class which is
84:00 - rectangular same we will do for the
84:03 - triangle class so from the triangle file
84:08 - named triangle dot py and then import
84:11 - and then the name of the triangle class
84:13 - and you will see as soon as you do this
84:16 - the error is gone so now there is no red
84:20 - squiggly line under any of the code so
84:25 - now let's run the code so I'm going to
84:27 - just go to the main dot py file and I'm
84:31 - going to right click on this main dot py
84:33 - file and I'm going to just click on run
84:36 - mean which is going to run the program
84:38 - and it's going to print the result which
84:41 - is the area of rectangle and the area of
84:45 - the triangle so in this way you can
84:48 - import the py file which have classes
84:52 - inside them so this is how you create
84:54 - your own modules in python and import
84:58 - them into other Python files in this
85:01 - video we will talk about multiple
85:03 - inheritance in Python so first of all
85:06 - what is multiple inheritance so the
85:10 - ability of a class to inherit from more
85:14 - than one class is called multiple
85:17 - inheritance and in Python
85:20 - a class can inherit from more than one
85:23 - class so let's see an example which
85:26 - shows us how to inherit from multiple
85:29 - classes now I will be using this example
85:32 - which I have already shown you in the
85:35 - video where I have shown you inheritance
85:37 - in Python so there is a class called
85:41 - polygon which is a superclass and the
85:44 - other two classes are triangle class and
85:47 - the rectangle class which are the
85:49 - subclasses and these two classes are
85:52 - inheriting from the polygon class and I
85:56 - have also one more Python file which is
85:59 - main dot py and in this main dot py
86:03 - just importing these two rectangle and
86:07 - triangle class and creating an instance
86:09 - out of them and then setting the value
86:12 - of width and height and then we are
86:14 - printing the area of the rectangle and a
86:17 - triangle so if you haven't seen the last
86:19 - two videos just watch those videos
86:21 - because I will be using the same code in
86:24 - order to show you how to use multiple
86:27 - inheritance so let's get started so what
86:29 - I'm going to do is I'm going to create a
86:32 - new python file here and I'm going to
86:34 - name my file as a shape and I'm going to
86:38 - use this shape dot py to create a class
86:42 - called shape so let me create a class
86:46 - quickly and I'm going to name it as
86:48 - shape and this method I'm going to
86:51 - define a private variable called color
86:54 - and I'm going to initialize it with the
86:57 - value none and then I'm going to define
86:59 - the setter and getter for this color
87:01 - attribute so let's define those
87:12 - so now we have defined the setter and
87:15 - getter for this color attribute now if
87:18 - you remember what I told you about
87:20 - inheritance and that is whenever you
87:23 - want to do inheritance between a
87:25 - superclass and the subclass there is a
87:27 - is our relationship between the subclass
87:30 - and the superclass so rectangle is a
87:35 - shape and triangle is also a shape so
87:38 - that means we can also use this shaped
87:41 - lass as the super class in rectangle and
87:45 - the triangle classes so let's use the
87:49 - shape class into the rectangle and
87:52 - triangle class as the superclass so
87:56 - first of all I'm going to import this
87:57 - shape class from the shape file so let's
88:02 - import this and same I will do in the
88:06 - triangle class also and now how to
88:09 - inherit from multiple classes into our
88:12 - subclasses so we have already inherited
88:15 - from in the polygon class and in order
88:17 - to add one more class here you just need
88:20 - a comma separator and the name of your
88:23 - class so this is how you inherit from
88:26 - multiple classes you just use the
88:29 - parentheses and then the name of your
88:32 - classes separated by the comma
88:35 - that means the triangle class is
88:38 - inheriting from the polygon class as
88:41 - well as the shape class the same we will
88:45 - do in the rectangle class so I will just
88:47 - provide the comma here and then I will
88:50 - just write shape here and now I will go
88:52 - to the main dot py file and once you do
88:56 - the multiple inheritance that means all
88:58 - the public methods of the shape class is
89:02 - available in the sub classes which are
89:05 - triangle and the rectangle so I can use
89:09 - this kind of notation first of all I am
89:12 - going to use rectangle class to call the
89:15 - method called set color so I'm going to
89:18 - set color from here and let's say the
89:21 - rectangle color is red
89:24 - and then I'm going to use the triangle
89:27 - object to call the set color method once
89:31 - again and the color I want to provide
89:33 - here is let's say blue ok and in order
89:36 - to get those two color values we can
89:39 - once again write print the instance name
89:42 - which is rectangle dot get color and
89:46 - same we will do for the triangle object
89:50 - also so print triangle dot get color and
89:55 - that's it so now all the public method
89:59 - of the shaped lass is also available in
90:03 - our rectangle and the triangle classes
90:08 - and we can use all the public methods of
90:10 - this shape class into the subclasses and
90:13 - let's run the code and let's see what
90:16 - happens so the code is running and you
90:18 - can see it prints red and blue using
90:22 - these two statements so this is how you
90:26 - can do multiple inheritance in python in
90:29 - this video I'm going to show you how you
90:31 - can use a built-in function called super
90:34 - in your Python classes so let's get
90:38 - started so to start with I have two
90:41 - classes here one is the parent class and
90:43 - other is the child class and here parent
90:47 - class acts like a superclass and the
90:50 - child class acts like a subclass which
90:52 - is inheriting from the parent class now
90:55 - both these classes have this init
90:59 - function and you already know what does
91:01 - this init function do it is the first
91:03 - function which is called when an
91:06 - instance of a class is created and here
91:09 - I'm just creating the object from the
91:11 - child class now what do you think will
91:14 - happen well that this constructor will
91:17 - be called or this constructor will be
91:20 - called because we are inheriting from
91:22 - the parent class into the child class so
91:25 - let's find out so I'm going to run this
91:27 - code and it prints child in it
91:30 - that means this statement under the
91:32 - child class init method is executed and
91:36 - this method
91:38 - is not executed now in some cases you
91:41 - might want to pass some parameters also
91:44 - into your superclass for example I'm
91:48 - just going to give this example let's
91:51 - say I want to pass a argument called
91:53 - name here and then I will just print the
91:57 - value of name how can I call this init
92:01 - function using this child class instance
92:05 - so it turns out that there is a function
92:08 - called super in Python that allows us to
92:12 - refer to the superclass implicitly now
92:17 - this super function is a built-in
92:20 - function which returns a proxy object
92:23 - that allows you to refer to your
92:27 - superclass so let's try to use this
92:30 - super function so you just use the
92:32 - keyword super and then give these
92:35 - parentheses because this is a function
92:37 - and then this super function will return
92:39 - the proxy object of the superclass that
92:42 - means I can use this dot operator to
92:45 - call the init method from the superclass
92:49 - so this notation means super dot in it
92:53 - means we are calling the init method
92:55 - from the parent class and that means we
92:58 - can pass the name from here so let's
93:01 - just pass this near I am going to just
93:03 - write max here and now I'm going to run
93:06 - this code and now you will see that
93:09 - child in it is printed using this
93:11 - statement first of all and then using
93:14 - the super function the init method of
93:17 - the parent class is called and then this
93:21 - name is passed here and it prints parent
93:24 - in it and the name whatever name we have
93:27 - provided here so this super function
93:29 - allows us to refer to the superclass now
93:33 - let me show you one more thing which is
93:35 - called the method resolution order and
93:37 - you can find this method resolution
93:40 - order by using your class name so child
93:44 - last name dot underscore underscore mro
93:49 - so just write underscore underscore
93:50 - Amaro
93:51 - underscore underscore and this statement
93:53 - I'm going to use inside the print
93:55 - function so you can see the result what
93:58 - it returns so I'm going to run the code
94:00 - now and you can see it returns this kind
94:03 - of order so as the name suggests mr o
94:06 - stands for method resolution order and
94:10 - this is the order in which the methods
94:13 - are called inside your child class or
94:18 - the parent class and this order means
94:20 - that all the method in the child class
94:23 - will be executed first and then all the
94:27 - method in the parent class will be
94:30 - executed now there are some rules based
94:33 - upon which this order is calculated and
94:37 - these rules are the first rule is the
94:40 - method inside your subclass are always
94:43 - called first and then whatever the
94:47 - method inside the base class they will
94:50 - be called and the second rule is related
94:53 - to multiple inheritance so let me just
94:55 - create the second parent class and I'm
94:58 - going to name it as parent too and here
95:01 - also I'm going to just write parent 2
95:03 - here and let me inherit from the parent
95:07 - 2 also in the child class right and
95:10 - let's run the code once again and now
95:13 - you will see this order so once again
95:16 - child is printed and then the parent and
95:19 - then prayer in 2 and then the object so
95:23 - the second thing on which the amaro
95:25 - depends upon is the order in which you
95:28 - inherit from the parent class or the
95:31 - superclass so in our example we were
95:34 - inheriting from the parent class first
95:37 - of all and then parent to and in the
95:40 - same order this amaro also will be
95:43 - decided so all the method in the child
95:45 - class will be executed first and then
95:48 - all the methods inside the parent class
95:51 - whatever you use first here will be
95:55 - executed and then whatever superclass
95:57 - you write after that those method inside
96:00 - the class or superclass will be executed
96:03 - next and
96:04 - at last this is the base object now
96:07 - let's try to just reverse this order and
96:10 - once again let's run the code and you
96:14 - will see that this order will be
96:16 - reversed so the method resolution order
96:18 - will tell you which class method will be
96:21 - executed first and then the order of all
96:25 - the methods from the super classes now
96:29 - one more interesting thing which you
96:31 - will observe here is this output so I
96:34 - said that this super function is used to
96:38 - refer to the super class and now we have
96:42 - two super classes that means multiple
96:44 - inheritance and you will see here that
96:47 - only one output is printed which is from
96:51 - the init method inside the parent to and
96:56 - this statement is not printed which is
96:59 - inside the init method inside the parent
97:02 - class so how to solve this problem so if
97:06 - you have multiple inheritance then you
97:10 - need to manually call these init
97:13 - function using the class name so let's
97:18 - say I want to call the init function
97:19 - first fall from the parent to class I
97:22 - will use parent to dot in it and then
97:26 - you need to give also the self as the
97:29 - first parameter and the second which is
97:31 - the name in the same way you use the
97:35 - second class which is parent dot init
97:38 - function and then first parameter is the
97:42 - cell and then you can pass any other
97:44 - name for example Tom here and let me run
97:47 - the code and you will see it calls first
97:50 - of all parent to init function and we
97:52 - have passed max here as the name and
97:55 - then it calls the parent one init
97:57 - function with the name Tom which is
98:00 - printed here also so this is how you can
98:03 - use super function in Python in this
98:06 - video we will talk about operator
98:08 - overloading in Python
98:10 - now you might already know that
98:12 - everything is an object in Python so
98:15 - when I want to know the type of this
98:18 - number
98:18 - - it's going to show this kind of output
98:20 - and this means that - is an object of
98:24 - the class int now when I once again want
98:28 - to know the type of let's say 2.0 it's
98:33 - an object of class float when I want to
98:37 - do the same operation with the string
98:40 - this string is an object of class string
98:45 - so everything is an object in Python now
98:48 - have you ever wondered that when you do
98:52 - 2 + 2 it's going to give us the addition
98:56 - of two numbers and when I add two
99:00 - strings let's say two and then I am
99:03 - going to use the same operator which is
99:05 - plus operator with the other string it's
99:08 - going to give me the concatenation of
99:11 - these two string values so the same
99:15 - operator plus is working differently
99:17 - with different type of objects the same
99:22 - you might have observed with the
99:25 - multiplication operator which is this
99:27 - asterisk so when I use this asterisks or
99:30 - multiplication operator with a string
99:32 - and let's say I write three here it's
99:35 - going to print this given string three
99:37 - times but the same operator when I will
99:40 - use with the two numbers it's going to
99:43 - give me the different behavior which is
99:44 - the multiplication of these two numbers
99:48 - so the same operator Asterix is
99:50 - functioning differently with different
99:52 - kind of data or in other words we can
99:56 - say that this Astrix operator or this
100:00 - plus operator are overloaded for a
100:04 - different kind of objects so whenever
100:07 - this plus operator is used with two
100:10 - numbers it's going to give us the sum of
100:13 - these two numbers and whenever this
100:15 - operator is used with the string it's
100:18 - going to give us the concatenation of
100:20 - these two strings so both these
100:22 - operators are overloaded for handling
100:25 - different kind of data so this is the
100:28 - overloading of the built-in
100:31 - readers now we might also think that if
100:35 - this is possible
100:36 - can we overload the operators by our
100:41 - custom classes so let me create a class
100:44 - and I'm going to name it as the number
100:48 - class which is going to take one
100:51 - argument so let me define a constructor
100:53 - here so underscore underscore init
100:56 - underscore underscore and this is going
100:59 - to take one argument which is the number
101:01 - and I'm going to just write self dot num
101:06 - is equal to num so this is the simple
101:09 - class which we have created and now I'm
101:12 - going to create two instances of the
101:15 - same class so number and I'm going to
101:18 - give the number one let's say here and
101:20 - then I'm going to create a second object
101:23 - of this class and this time I'm going to
101:25 - give the number two here so is it
101:28 - possible that we can use let's say + 1 +
101:32 - + 2 so let's try this and it's going to
101:36 - give us this error which says
101:38 - unsupported operand type 4 plus number
101:43 - and number so because Python doesn't
101:45 - know how to use this + operator with
101:48 - your class objects it's going to give us
101:51 - this error which is unsupported operand
101:54 - type and whatever is the operator you
101:57 - are using so it turns out that we can
101:59 - overload these kind of operators in
102:02 - Python by implementing some inbuilt
102:05 - methods in our class so we already know
102:09 - that whenever we want to implement a
102:12 - constructor in Python we use this init
102:16 - method so I'm going to create a very
102:18 - simple class and I'm going to name it as
102:20 - a and this will be a blank class so this
102:25 - is a very simple class in Python and
102:28 - when I use a dir function which is a
102:32 - built-in function with this class let's
102:35 - see what happens so I'm going to just
102:37 - press ENTER and it's going to print some
102:40 - methods here which are inbuilt method so
102:43 - here not all methods are
102:45 - Cybil so I'm going to assign this value
102:48 - of dir a to a variable a and then we
102:54 - will see in the right hand side in this
102:57 - inspector here and this is the a
102:59 - variable and you will see the list of
103:02 - all the inbuilt methods which are
103:05 - associated or which you can implement
103:07 - them so for example we have implemented
103:10 - the init method in order to have the
103:13 - functionality similar to constructor but
103:16 - there are other methods here too so
103:19 - there is a STR method or le method which
103:23 - is less than method or any method which
103:26 - is not equal to method and many other
103:28 - methods which we can implement here in
103:31 - our class so now I have given enough
103:35 - theory to you and let's try to see with
103:38 - an example how to overload an operator
103:42 - in Python so here I have created a class
103:46 - which I call circle and this takes one
103:50 - argument which is the radius of the
103:52 - circle and I have created the setter and
103:55 - get a method for this radius variable
103:58 - and in the third method I am just
104:01 - calculating the area of the circle using
104:05 - the radius and I have also used a
104:08 - inbuilt module which is math in order to
104:11 - get the value of pi so using this
104:14 - expression I am just calculating the
104:16 - area of the circle now I have created
104:19 - two objects of this class with two
104:22 - different radiuses so in the first
104:25 - object I have given the radius to and in
104:28 - the second object I have given the
104:29 - radius 3 and from the theory which we
104:32 - have learned till now we already know
104:34 - that this expression will not work with
104:38 - these two objects so when I run this
104:40 - code it's going to give me the error
104:42 - which says unsupported operand error so
104:46 - now we are going to overload this plus
104:48 - operator in this circle class now in
104:52 - order to overload a particular operator
104:54 - let's say plus you need to implement
104:58 - associated
104:59 - method in your class so with this plus
105:02 - operator there is a special method which
105:05 - we need to implement in our class and I
105:08 - have given the list of all the methods
105:09 - which is associated with the operators
105:13 - so with the plus operator you need to
105:16 - implement this special method which is
105:18 - underscore underscore add underscore
105:20 - underscore in order to overload - you
105:24 - use this method in order to overload the
105:27 - multiplication you use this method so
105:30 - here is the operator which we want to
105:33 - overload and here I have given the
105:37 - method name which you need to implement
105:39 - in your class in order to overload this
105:43 - operator in Python so there is this list
105:46 - which you can use with all these
105:49 - operators so you can overload the
105:51 - mathematical operators in Python you can
105:55 - also overload the bitwise operators in
105:57 - Python like and or or bitwise right
106:02 - shift orbit wise left shift and also you
106:06 - can overload the comparison operators in
106:09 - python using these associated methods
106:13 - with these operators so now we want to
106:16 - overload this plus operator so we will
106:19 - implement this add method into our class
106:23 - so let's implement this add method into
106:25 - our class and implementing this method
106:28 - is really simple you just need to define
106:31 - a special method which is underscore
106:34 - underscore add underscore underscore and
106:36 - this add method is going to take two
106:39 - arguments one is self you already know
106:42 - and the other is the object of the other
106:46 - instance so this second argument is the
106:49 - object of the circle class and now
106:52 - inside this method I am going to just
106:55 - return first of all I will just use this
106:58 - circle as the constructor and what I
107:00 - want to do I want to add let's say the
107:03 - radius of the two objects which are
107:07 - provided one is the self object and
107:10 - other is the object which is provided
107:13 - you
107:13 - using this argument so I'm going to just
107:16 - say self dot underscore underscore
107:18 - radius plus the circle object radius so
107:23 - let's use the circle object and then dot
107:26 - and then underscore underscore radius so
107:29 - basically I'm adding the radius of the
107:33 - two objects one is this circle object
107:36 - and other is the radius of the self
107:38 - which is the current class so as soon as
107:41 - you implement this method ad using these
107:44 - two arguments then this operation is
107:48 - going to work in Python so because we
107:51 - have overloaded the plus operator using
107:54 - this ad method now this operation is
107:58 - going to work so let me just assign the
108:01 - addition of these two objects into a
108:04 - third variable and this variable I'm
108:07 - going to name it as c3 and using this c3
108:10 - let's say I want to print the radius of
108:14 - the circle so I'm going to just use the
108:18 - print method and then I'm going to use
108:21 - the c3 object and I'm going to call our
108:25 - get radius method from this object and
108:28 - let's print the radius of c1 and c2 also
108:32 - so here I am going to just write c1 and
108:34 - here I'm going to just write c2 so we
108:37 - are printing the radius of all these
108:40 - three objects and I'm going to run the
108:42 - program now and you can see here the
108:45 - radius of the first object is two
108:47 - because we have provided two as an
108:49 - argument here the second is three
108:52 - because we have provided three as an
108:54 - argument here and because we have
108:56 - created this third object using the
108:58 - overloading of this plus operator where
109:01 - we were just adding the radius of both
109:05 - the objects that's why we got five years
109:07 - so two plus three is equal to five and
109:10 - this addition we have done using this
109:14 - expression so we have added the radius
109:17 - of the current class and the object
109:20 - which is passed using this argument so
109:24 - this is how you can overload the
109:26 - craters in Python by implementing the
109:29 - Associated methods which are available
109:32 - in Python so let's say now we want to
109:36 - overload the less than and the greater
109:39 - than operator so for the less than
109:42 - operator we use this LT method and for
109:46 - the greater than operator we use this
109:49 - method called GT so let's implement
109:52 - these two method inside our classes so
109:56 - I'm going to just copy this add method
110:00 - to x and first of all I'm going to
110:03 - replace this by LT which is less than
110:05 - and the second method I'm going to
110:08 - replace by GT which is greater than and
110:12 - we want to see if the radius of the
110:15 - circle is greater than the second radius
110:18 - which is provided using this object or
110:20 - not
110:21 - so first is less than so we are going to
110:23 - provide this operator and second is
110:25 - greater than so we are going to provide
110:27 - the other operator which is greater than
110:30 - operator and now this less than and
110:32 - greater than function is going to give
110:34 - us the boolean value if this radius is
110:39 - less than this radius then it's going to
110:42 - return as true otherwise it's going to
110:44 - return us the false so I already have
110:47 - the two instance of two classes and if I
110:50 - want to compare these two classes I can
110:52 - just write c1 and I will use thus less
110:57 - than operator here and then c2 and also
111:00 - I'm going to use the greater than
111:04 - operator here and let's run the code and
111:07 - let's see what happens so now it's going
111:10 - to give us this value which is the
111:11 - constructor of the circle so how can we
111:14 - get the boolean value you just need to
111:16 - remove this constructor from here so you
111:20 - just need to remove the name of the
111:23 - class and now I'm going to run the code
111:25 - once again and now you will see true and
111:28 - false so we were checking if c1 radius
111:31 - is less than C 2 and it gives us true
111:33 - and once again we were checking if c1
111:35 - radius is greater than C 2 and it has
111:38 - given
111:39 - Falls to us all so we can check the
111:42 - third object for example c3 here if c3
111:46 - is greater than C 2 or not and most
111:48 - probably it's going to give us true and
111:50 - it's correct here so you can see it's
111:52 - that simple to overload any operator in
111:55 - python using these built-in methods so
111:59 - you just need to find out the Associated
112:03 - method related to that operator and then
112:06 - you just need to implement that method
112:09 - related to that operator in addition you
112:12 - can also implement some other methods
112:15 - which are available with the class so
112:18 - once again when I'm going to print the
112:21 - dir with any of the object let's say c1
112:25 - and I'm going to run this program and
112:28 - you can see the list of the functions
112:30 - which you can implement inside your
112:32 - class so ad is already there but you can
112:35 - also implement this dish method or dir
112:39 - method or any of these methods which are
112:42 - available here so our EPR method or STR
112:46 - method any method you can implement
112:49 - inside your class in order to avail the
112:53 - functionality associated with that
112:55 - method so it's last let's try to
112:58 - implement one of the method which are
113:01 - associated with the class so let's say
113:04 - we want to implement this method which
113:06 - is the STR method so I'm going to just
113:09 - minimize this and I'm going to just copy
113:11 - this function and once again paste here
113:14 - and instead of greater than I'm going to
113:17 - just implement now the STR method
113:20 - now this STR method only takes one
113:22 - argument which is self so I'm going to
113:24 - just remove the second argument and here
113:27 - in the return value I can just return
113:31 - some string for example so I can just
113:34 - say circle area and I'm going to return
113:37 - the area of the circle so I'm going to
113:40 - use this concatenation operator and then
113:44 - I'm going to convert the area into the
113:47 - string and then I'm going to just use
113:49 - self dot area which is going to give us
113:52 - the area of that circle so once you have
113:55 - implemented this STR method in your
113:57 - class you can simply use it like this
114:01 - dir method so I can just write STR and
114:05 - then the name of your object which you
114:07 - have created and let's run the code and
114:10 - let's see what happens so I'm going to
114:12 - just see the result now and it prints
114:15 - circle area and it's going to print the
114:18 - area of the circle I just need to
114:20 - provide equals to symbol here so we will
114:23 - be able to see it in a prettier way so
114:27 - you can see the area of the circle is
114:29 - printed similarly you can print the area
114:32 - of the other two circle which is circle
114:35 - two and circle three and let's run the
114:38 - code once again it's going to print us
114:40 - the area of all these circles so this is
114:43 - how you can use operator overloading in
114:46 - python in this video I'm going to show
114:49 - you what is composition and how to use
114:52 - class composition in Python so to start
114:55 - with I have two classes here one is an
114:59 - employee class and other is the celery
115:02 - class now in the salary class I have
115:05 - this init method which takes two
115:07 - argument P and bonus and it sets these
115:10 - two arguments to the member variables of
115:13 - this class also I have a method called
115:16 - annual salary which is used to calculate
115:18 - the salary now in the employee class I
115:22 - have this constructor which takes four
115:24 - arguments which is name age P and bonus
115:29 - now what do you think can we apply
115:32 - inheritance here the answer is no
115:35 - because there is no is our relationship
115:37 - between salary and employee so employee
115:40 - is not a salary and salary is not an
115:44 - employee but somehow I want to delegate
115:46 - the responsibility of calculating the
115:49 - employee salary to the salary class
115:52 - because calculating salary is in itself
115:55 - is a big task I have just simplified
115:58 - this class in the form of just
116:01 - calculating the annual salary but the
116:04 - employee can have his
116:06 - in Texas or he has taken some leaves or
116:10 - many factors affects the salary of an
116:13 - employee so this salary calculation
116:17 - let's say we want to delegate to the
116:19 - salary class but whose salary is this
116:22 - this salary is the employees salary so
116:25 - we know that we cannot use inheritance
116:27 - here but we can use a concept called
116:31 - composition here and the composition
116:34 - means that we are just delegating some
116:38 - responsibilities from one class to the
116:41 - another class so how to delegate this
116:44 - responsibility we can just create one
116:47 - more variable here for example self dot
116:52 - obj underscore salary which is the
116:56 - salary object we are going to create
116:58 - using the salary class okay and this
117:02 - salary class takes two parameters one is
117:05 - pay and other is bonus which we are
117:08 - already providing using the employee
117:11 - init method so I'm going to just pass
117:14 - this pay comma the bonus into the salary
117:19 - class so we are instantiating the salary
117:22 - class inside the employee class so here
117:25 - one class which is an employee class
117:28 - acts like a container of the other class
117:33 - which acts like a Content
117:36 - okay so salary class is the content and
117:38 - the employee class is the container of
117:42 - this salary class now in order to
117:45 - calculate the total salary we can define
117:47 - one more method here and I'm going to
117:49 - just say total underscore celery and
117:53 - then what we are going to do is we are
117:55 - going to call our object salary member
117:59 - variable because this gives us the
118:02 - object of the salary so I am going to
118:05 - just call object salary and we can call
118:07 - this method from the salary class which
118:10 - gives us the annual salary and now I am
118:12 - going to just create the object of this
118:16 - employee class so let me just
118:18 - right EMP is equal to employee which
118:22 - takes four parameter first is name
118:25 - second is the age third is the piece so
118:30 - let's say P is 15,000 and the bonus is
118:35 - 10,000 and now I just want to print the
118:38 - total salary of this employee so I can
118:41 - just write print and then EMP object dot
118:46 - the total salary which is total salary
118:49 - method and you can see here this total
118:51 - salary is returning let me just use the
118:54 - return keyword also because we are
118:57 - returning this annual salary from the
118:59 - salary class using this total salary
119:02 - method so let's run the code once again
119:04 - let's see what happens and you can see
119:06 - annual salary is printed and this annual
119:09 - salary is calculated using the salary
119:13 - class so what this employee class has
119:17 - done it has delegated some
119:19 - responsibilities to the other class
119:23 - which is the salary class which gives us
119:26 - the annual salary of an employee and
119:29 - this here is called composition now one
119:32 - interesting thing which you will notice
119:34 - here is we are not instantiating salary
119:38 - here we are just instantiating the
119:41 - salary inside an employee class so as
119:45 - soon as you delete an instance of an
119:48 - employee the celery class instance will
119:51 - be automatically deleted so whenever you
119:54 - want to delegate some responsibility of
119:57 - one class to the another class it's
120:00 - called composition one more example of
120:03 - composition can be a book class and a
120:07 - chapter class so a chapter is not a book
120:11 - and book is not a chapter but we can
120:15 - delegate some responsibilities from a
120:17 - book class to the chapter class so this
120:21 - is how you can use composition in Python
120:23 - in the last video we have seen how to
120:25 - use composition between classes in
120:28 - Python in this video I'm going to show
120:31 - you how to you
120:32 - class aggregation between classes in
120:35 - Python now if you haven't watched my
120:38 - last video in which I have shown you how
120:40 - to use class composition in Python I
120:44 - will highly recommend you to watch that
120:46 - video because I will be using the same
120:49 - code to demonstrate how aggregation
120:53 - works in Python so in the last video we
120:57 - have created two classes one is an
121:00 - employed loss and other is the salary
121:03 - class and then we have used the celery
121:06 - class inside the employee class and we
121:10 - have seen how composition works in
121:12 - Python so employee class is delegating
121:15 - some part of its responsibility to the
121:19 - celery class and that is called the
121:21 - composition now in composition the
121:24 - relationship between the classes which
121:26 - have some Association is represented by
121:29 - a key word part of so celery is the part
121:34 - of employee so the key word we use in
121:37 - composition is part of now let's see how
121:41 - we can use aggregation instead of
121:43 - composition between these two classes so
121:46 - let's say I will not use this celery
121:48 - class inside the employee class but what
121:53 - I'm going to do is I'm going to pass an
121:55 - instance of celery here so I'm going to
121:58 - just write celery and this will be the
122:02 - object of celery class which I'm going
122:05 - to pass in the init method of the
122:10 - employee class so let's create an object
122:13 - of the celery so I'm going to just write
122:16 - celery here is equal to the celery class
122:20 - and we will instantiate the celery class
122:23 - by these two argument which we have
122:27 - given in the last video to the employee
122:29 - class so I'm going to just copy these
122:31 - two arguments and paste it here and I'm
122:34 - going to remove this comma here so now
122:36 - what we are doing here is we are first
122:39 - of all instantiating the celery class
122:42 - and now the celery class we can pass to
122:44 - the
122:46 - structure of the employee class and this
122:49 - is the object which we have passed using
122:52 - the salary class object and then I'm
122:54 - going to take the salary class object
122:56 - and I'm going to assign the salary class
122:58 - object to the member variable of the
123:01 - employee class which is obj underscore
123:04 - salary now because we are passing the
123:06 - salary object that means this member
123:09 - variable is the salary member object and
123:12 - we can call any public method from the
123:14 - salary class using this member variable
123:17 - now so let's run the code and let's see
123:19 - what happens and we get the same result
123:21 - as we have seen in the last video in the
123:24 - composition example so what we have done
123:27 - differently here so instead of using
123:30 - this salary class inside the employee
123:32 - class we have first created an instance
123:35 - of the salary class and then we have
123:37 - passed this instance to the employee
123:41 - constructor which can be used inside the
123:44 - employee class and this type of
123:46 - relationship is called aggregation now
123:49 - let's see what are the special
123:51 - properties of the aggregation the first
123:54 - property is the relationship between the
123:58 - associated classes in aggregation is
124:01 - defined by the keyword has a so employee
124:05 - has a salary because now we are first of
124:08 - all creating the salary object and then
124:10 - passing it to the employee so now we are
124:13 - not directly using salary inside the
124:16 - employee class the second property of
124:19 - aggregation is that associated classes
124:22 - have uni-directional Association so we
124:26 - are just passing salary object to the
124:29 - employee class we are not passing
124:33 - employee object to the salary class so
124:36 - it's a unidirectional Association only
124:39 - salary can be passed to employee not the
124:43 - other way around and the third property
124:45 - of aggregation is we have created the
124:48 - salary object and the employee object so
124:51 - both these objects are independent of
124:54 - each other so if one object dies the
124:58 - other server
124:59 - so both the object are able to survive
125:02 - individually so these are the three
125:04 - properties of aggregation now let's see
125:07 - the difference between the composition
125:08 - and the aggregation so I'm going to
125:10 - split the screen so I'm going to just
125:12 - right click on this tab and I will say
125:16 - split vertically and here I'm going to
125:18 - open the example of the composition so
125:22 - on the right hand side I have the
125:24 - example of composition and on the left
125:26 - hand side I have the example of
125:28 - aggregation
125:29 - let me just maximize this so you can see
125:32 - it and now let's discuss about the
125:35 - differences between the composition and
125:37 - aggregation so the relationship in
125:42 - composition is defined by a keyword
125:45 - called part of so salary is the part of
125:50 - employee in aggregation there is no part
125:55 - of relationship but the relationship is
125:57 - defined by the keyword called has a so
126:01 - now in aggregation we are defining the
126:02 - instance of salary and then passing it
126:05 - to the employee class and salary is not
126:08 - the part of the employee class we are
126:11 - just passing it to the employee class so
126:15 - aggregation we use has our relationship
126:18 - and in composition we use part of
126:20 - relationship the second difference is
126:23 - when you delete the employee object the
126:27 - salary object will be automatically be
126:30 - deleted so salary object is dependent on
126:34 - the employee class but in aggregation
126:38 - the salary object and the employee
126:41 - object are individually independent so
126:45 - they can survive individually if one
126:47 - object dies then it doesn't matter that
126:49 - the other object dies because we have
126:52 - created these object individually now in
126:56 - composition both salary and employee are
126:58 - interdependent on each other but in
127:02 - aggregation the relationship is
127:04 - unidirectional so the association
127:07 - between the employee and the salary
127:10 - object is unidirectional
127:12 - you can only pass the salary to the
127:15 - employee class but we cannot pass the
127:18 - employee object to the salary class so
127:21 - these are the three major differences
127:23 - between composition and the aggregation
127:26 - in this video we will talk about
127:28 - creating abstract classes in Python so
127:32 - let's get started so to start with I
127:34 - have here two classes one is a shape
127:38 - class another is a square class in shape
127:41 - class I have to empty methods one is
127:44 - area and other is perimeter and I'm
127:47 - using shape as a superclass and square
127:51 - as a subclass and square class is
127:54 - inheriting from the shape class now in
127:58 - this example I want to do two things one
128:01 - is I don't want to allow the other users
128:04 - to create an instance of a shape class
128:07 - because shape class acts like a template
128:10 - for the square class so I don't want to
128:14 - allow those users to create an instance
128:16 - of this shape class so let's see right
128:20 - now if we can create an instance of this
128:23 - shape class or not so I'm going to just
128:25 - right shape is equal to shape and when I
128:30 - run the code my code runs fine that
128:33 - means right now I'm able to create an
128:36 - instance of the shape class which I
128:39 - don't want the second thing is I want to
128:42 - make sure that both these methods which
128:45 - are there inside the shape class are
128:49 - implemented inside the square class so I
128:52 - want to make sure that whoever is using
128:55 - the shape class he or she must implement
128:59 - these two methods inside the subclass so
129:03 - how can I achieve these two things now
129:06 - it turns out that abstract classes are
129:08 - just made for that so how to create an
129:11 - abstract class in Python the fact is
129:13 - Python on its own doesn't provide any
129:17 - abstract class but don't worry there is
129:20 - a built-in module in Python which we can
129:23 - use to create an abstract class
129:26 - so let's import this built-in module
129:29 - first so I'm going to just write from
129:31 - ABC import capital ABC comma abstract
129:36 - method so these are the two things we
129:39 - need to import from this module now this
129:43 - module ABC stands for abstract base
129:46 - classes and this allows us to create the
129:50 - abstract classes so how we can create an
129:53 - abstract class using this ABC module so
129:57 - what we need to do here is we need to
129:59 - inherit from the ABC module into the
130:04 - shape class okay so shape class is
130:07 - inheriting from the ABC module now once
130:10 - this shape class inherit from the ABC
130:13 - module the second thing what we need to
130:16 - do here is we need to add a decorator
130:19 - here and how to add a decorator we just
130:22 - need to use at the rate and then the
130:25 - name of this abstract method which is
130:28 - like this and let me use this abstract
130:31 - method decorator on top of this
130:35 - parameter method also so what this
130:37 - abstract method decorator does is it
130:40 - makes these two methods abstract and
130:43 - what is an abstract method an abstract
130:46 - method is a method which you must
130:48 - implement in the subclass so when you
130:52 - run the code now it will give us this
130:54 - error which says can't instantiate
130:57 - abstract class shape with the abstract
131:01 - method so once you create any of your
131:03 - class method as abstract then your class
131:07 - becomes the effect class and then you
131:10 - cannot instantiate this class like this
131:14 - so our first goal is achieved that we
131:17 - cannot instantiate this shape class now
131:20 - because this class is now an abstract
131:23 - class and how to create an abstract
131:26 - class you just need to import the ABC
131:30 - module and then you just need to add
131:31 - this decorator on top of your method and
131:35 - if you do this even with one method in
131:37 - your class then your class becomes
131:40 - abstract so now we have removed the
131:43 - instantiation of this shape class but
131:45 - now when I try to instantiate this
131:48 - square object from the square class
131:51 - let's see what happens so this square
131:53 - class takes one argument which is the
131:55 - side of the square and let me run this
131:58 - code and once again it gives us an error
132:01 - and this error says can't instantiate
132:04 - abstract class square with abstract
132:07 - methods so that means that whenever you
132:10 - inherit from a class which is an
132:13 - abstract class and if this class contain
132:16 - any abstract methods then the subclass
132:19 - have to implement the methods which are
132:23 - abstract so this method area is an
132:26 - abstract method and this method
132:28 - parameter is also an abstract method
132:31 - that means we have to provide the
132:33 - implementation of these two method
132:36 - inside our subclass so I'm going to
132:39 - provide the implementation of area first
132:43 - of all into the subclass and area I'm
132:46 - going to just return as the
132:48 - multiplication of the sides right so
132:51 - self dot underscore underscore side
132:54 - multiplied by itself so self dot
132:57 - underscore underscore side and let's say
133:00 - for now I will remove this abstract
133:02 - decorator from the parameter method and
133:06 - let's run the code once again and you
133:09 - can see it runs fine so there is no
133:11 - error when we instantiate this class
133:14 - when we implement all the abstract
133:17 - method into your subclass
133:20 - so right now there is only one abstract
133:22 - method which is area into the shape
133:24 - class which we need to implement in the
133:27 - subclass and that we have done so we see
133:30 - no error here now let's add this
133:32 - decorator abstract method on top of this
133:35 - parameter method also and once again
133:37 - when I run the code it will give me once
133:39 - again this error it's going to give me
133:42 - the same error which says can't
133:44 - instantiate the abstract class square
133:46 - with the abstract method parameter so we
133:49 - also need now to implement this method
133:53 - also
133:54 - let's just implement this parameter
133:57 - method inside the subclass once again
134:00 - and what is the parameter it's four
134:03 - times the size of your square so self
134:06 - dot underscore underscore size and now
134:10 - we have implemented both of them and
134:12 - once again when we run the code it runs
134:15 - fine let's also try to print the area
134:18 - and perimeter of the square so I'm going
134:21 - to just use this object to call the area
134:24 - method and in the next line I'm going to
134:27 - just use print to once again call this
134:30 - object and this time I will call the
134:32 - parameter method and let's run the code
134:35 - once again and it prints the area of the
134:38 - square and the perimeter of this square
134:41 - so let's rewind what we have learned
134:43 - till now so in Python you can define an
134:47 - abstract class by importing this module
134:50 - and this abstract method and this ABC
134:54 - stands for abstract base classes and you
134:57 - need to inherit from this ABC into the
135:01 - class which you want to make abstract
135:02 - the second thing which you need to do is
135:05 - you need to provide this decorator at
135:07 - the rate abstract method on top of at
135:10 - least one of the methods inside your
135:14 - abstract class that makes your class
135:16 - abstract and what are the properties of
135:18 - the abstract class you cannot
135:21 - instantiate an abstract class so you
135:24 - cannot create an object of this abstract
135:26 - class and you need to implement all the
135:30 - abstract method into the sub class which
135:34 - is inheriting the abstract class so this
135:36 - abstract class acts like just a template
135:40 - for other classes which wants to inherit
135:43 - from this shape class so this is how you
135:45 - can use abstract classes in Python I
135:48 - hope you have enjoyed this video and I
135:51 - will see you in the next video

Cleaned transcript:

now before starting our object oriented programming journey in Python let's discuss about what is the difference between the procedural programming and the objectoriented programming so you will have the better idea why we use objectoriented programming now traditional programming languages such as C or Pascal were called procedural programming languages or structural programming languages where the basic unit was functions now programming in these type of procedural languages involves choosing a data structure and then designing the algorithm and then translating that algorithm into a code so if this sounds little bit confusing let me try to explain it with an example so let's say you have been given a task to create a program for a passenger who wants to travel from one place to the another place using a cab service so if we think from the point of view of procedural programming what we do in the procedural programming is we create some global data structure which holds the data so here for example we create some kind of data structure which can hold the data for example in case of a cab service which cab service is it or which type of cab is it and at what location this cab is standing all these kind of data we store in a desta structure in our global environment now after storing the data we design an algorithm so let's see what kind of algorithm we can develop in the procedural programming language for our cab booking service so this is a pseudocode which I have written so first of all the passenger will open the app from which he can book a cab and then he will book cab and once the cab is booked he will wait for the cab and then once cab arrives he will sit in the cab and then he will reach to his or her destination and at the end he will pay the fare of the cab and this is the pseudocode of that algorithm and then we will translate this algorithm into actual code in procedural programming language now in these type of procedural programming languages we construct rate on creating the functions and the major drawback of using these functions is that data and operations on the data are separated that means we need a methodology to send this data to these functions so here we need to send this data which we have saved globally into these functions and these functions take this data either as argument or as a global variable and then perform some actions on this data and give you some result now these kind of functions are passive what do I mean by passive here that is these kind of function cannot hold any information inside them so once you give the data they are able to give you the result back after performing some operations but they cannot save or hold the state or the data so that if you want to use that data in some other place in your code then it will be very difficult using these kind of functions which you use in procedural programming now let's look at the objectoriented approach of doing things so in objectoriented programming languages like C++ or Java or Python the basic unit is class now if we take the same example of a passenger who wants to travel from one place to another using a cab service using objectoriented programming thinking which depends on on the creation of object we can create different kind of object for example for a cab we can create a class called cab and then we can create a class for cab driver and the third class we can create for a passenger okay so a class you can create for any reallife object it can be a car it can be a motorbike it can be a book or employee or a person so objectoriented programming allows us to create object so first of all what is a class so a class refers to a blueprint in which we can have data and methods okay so for example for our cab class what attributes this cab class can have for example a cab service which cab service we want to take what is the make of the cab it is it a Toyota or a BMW or a fox wagon cab at which location this cab is right now what is the number plate of that cab so the passenger can recognize this cab so all these things which I have written here are called data because they can hold some kind of data number plate has number plate data location have geolocation data may have the make data cap service can have data like uber or any other cab service and the other thing which at last can have are called method so earlier we have seen that we can create functions and when these functions you use inside a class they are called method ok so functions inside a class are called method now the data inside this object or class is called attributes or the member variables which can hold some data and using this class we can create object of the cab class which means we can create different or object using a same class and how to create object using classes we will see in the next video in the reallife example so don't worry if you don't understand how these things works I will give you a reallife example so you will be able to understand in a better way now what is an object an object is a software unit that combines data and methods okay so we have this data here and then we have the methods inside the class and object is able to combine both of them which is data with the methods now these object for example a cab object and the passenger object can exchange the data between them also so data is interchangeable between for example the passenger object and a cab object so let's rewind once again what we have learned about objectoriented programming so the basic unit in objectoriented programming is a class and at last refers to a blueprint which can have the data and methods now using a class we can create objects and what is an object object is an instance of a class and each object can have its own data and method and an object is able to store the state of some kind so at which location this cab is right now so this is a state and an object is able to store at that state now in procedural programming if you remember there is no relation between the data and the method right we need to provide the data to the method which are separate entities in the procedural programming language now these data members are called attributes or member variables and these functions which you define inside a class are called methods and what are some of the key differences between procedural programming language and objectoriented programming language the first is the unit in procedural programming language is function and on the other hand in objectoriented programming the unit is class the second is the procedural programming concentrate on creating functions while objectoriented programming starts from isolating classes and then they can have data and methods inside it in procedural programming language the data and the functions are separate and in objectoriented programming language data and methods are not separate they are at the part of a single object of Atlas now if all this seems to be little confusing to you don't worry you are not alone and I will try to solve this confusion in the next video in which I will tell you how to create the classes and how to use classes in Python in this video I'm going to show you how you can create your first class in Python now if you haven't seen my last video in which I have discussed what is objectoriented programming and what are classes I will highly recommend you to watch that video because this will be a continuation of that video so let's create a class in Python so for that I will create a new project so let's create a new project in PyCharm so just click on file here and then click on new project and then the project name I'm going to give here is oops and then I will just click on create and I will choose this option which says open in current window and also this option which is added to currently open the project which is going to create this project in this window itself which is already open so now you can see we have a empty project here and inside this project let's create a Python file so right click on the project and then new and then we are going to create a new file and let's create a class called car so I'm going to name the file name as car because we are going to create the car class now in order to create a class in Python you use a keyword class and then you give the name to your class so the class name in our case is car and then you give the schoolin and for example I write here a keyword called pass now when you write this keyword after the declaration of a class this means that it is a empty class you can also use this pass keyword to create an empty method so this keyword pass is used to create an empty class or an empty method now here after the class declaration let's see how we can create an instance of a class so it's really easy to create an instance of a class so let's create a first object and I'm going to name it as Ford which is a car brand and then you use your car class name and use these parentheses here okay so this here Ford is an object or you can also say it's an instance of that last car in a similar way we can create multiple objects for example Honda is another car brand and you can create the Honda object using this class car once again you can create a new object for example Audie and then you can once again use this car class to create this object so what we have done till now we have created three object from that last car now in the previous video I told you that you can associate some data with your object so let's associate some data so for example Ford we can associate attribute called speed right so we can assign the speed for example 200 here for a Honda we can assign speed let's say 220 and for Adi we can assign the speed let's say 250 so speed here is called the attribute and whenever you create an empty class using this pass keyword you can add these attributes on the fly so you can see we have added these attribute after the Declaration of the class and after the creation of the objects let's add some more attribute to these instances or the object so a car can have the color so I'm going to just write color and the food has let's say the red color and let me just copy and paste here and let's say the Honda have the blue color and we have the Adi of black color so once again color is an attribute here if you want to print these attribute you can use this print method and then for example we want to print the speed of food and the color of Ford then we can do it like this and let's run the code so in order to run this code first of all when you create a new project and a new python file you need to right click on this file and then click on run the file name whatever is your file name my file name was car so you can see now the result is printed here first is the speed and second is the color of an instance ford similarly you can print the color and speed of honda and audi objects also now if you want to change some attribute it's also possible so let's say I want to change the speed of Ford object so I'm going to use 4 dot speed once again and this time I want to assign 300 speed to this attribute let's say we also want to change the color of the food objects so I'm going to just use for dot color and this time I want to use the color blue here and let's once again we will try to print the color and speed of the object food and now you can see this result so before the speed was 200 and the new speed is 300 for the object food and before the color was red and the new color is blue for this object for now if you have followed the last video this speed and color is the data so speed and color are the variables which holds some data inside them but still we haven't added any behavior or methods to our class car and that we will do in the next video now let's create a new class because understanding classes in any language is difficult so let me give you another example so this time I'm going to create a new Python class and I'm going to name this python class as a rectangle and then press ok which is going to create this class and to create a class you already know you use the keyword and the name of the class and then the colon and we will also make this class an empty class using this path keyboard and in order to create an instance I'm going to just write correct one which is the first object using the rectangle class and then I'm going to create correct to which is the second object using this rectangle class and now what are the attributes which we can relate to the rectangle a rectangle have a width and the height so let's add the herebut and height so let me use the first object let's say height is 24 the rectangle 1 and then we are going to use the second object and once again we are going to add the height for the second rectangle let's say the height of second rectangle is 30 similarly we can add the width to the rectangle so width is equal to let's say it's 40 and right to object have the width let's say 10 so what we have done here we have created a rectangle class and then we have created two instances of the rectangle class correct one and rag2 which are also called objects and then we have added some attributes to our objects which are height and width now let's say you want to calculate the area of these two rectangles I can use the print method and then what is the area of the rectangle it's the multiplication of the height and the width right so I can use this rectangle one object and then I can call the height and width of this object and this will give me the area of the rectangle one using this multiplication operator similarly I will do the same for the object to here and let's run the code and if you remember what we need to do if we create a new Python file we need to rightclick on the file and then click on run right so once the file is running you can choose from here which file you want to run but at least once you need to rightclick on the file and just click on run whatever file name you have so you can see the area of rectangle 1 is 800 and the area of rectangle 2 is 300 so this is how you can create a very simple class in Python in the next video I'm going to show you how to add behaviors to your class that means to add methods to your class and how to use this method to manipulate this data which we have provided here in the form of attributes in this video I'm going to show you how to use init method in Python and how to use a keyword called self in Python so I will continue with the class which I have created in the last video and this was the class which we have created and we have used this special keyword passed there and pass we were using to create an empty class now I'm going to remove this pass and I'm going to add a method called init here so I'm going to just write def and then underscore underscore in it and then press enter and you can see this init method is created here so this is like a normal method with double underscore in front and back of this init keyword and you will also see the self keyword is already added as the first argument of this method now this init method serves as a constructor for the class so usually it is used to initialize some attributes or some functions because this is the first method which will be called when you create an instance of a class so here we are creating an instance of a class and this init method will be the first method which will be called when this object or instance will be created so let's check what I am saying so let's say I want to print inside this init method that the underscore underscore init underscore underscore is called and let me run this code so I will change this to car and then run this code and now when I see this result you will see this line is called three times because we have created three instance from the same class okay so every time this instance is created this print is called and that's why this line is printed three times and everything else will be printed after that whatever we were printing for example speed or color of the car will be printed after that now one important thing to notice here is I said in it serves as a constructor it's not a constructor although it would be tempting to call this init method as a constructor actually it's not a constructor but it behaves like a constructor because in it is the closest thing we are going to get in Python to a constructor because it is the first method which is called whenever an instance is created now if you are familiar with other objectoriented programming languages like Java and C++ there is a destructor also in those kind of languages with classes now Python doesn't have any destructor because python has an automatic garbage collections so you don't need a destructor in Python because python will take care of anything which should be taken care of now as I said usually init method is used to initialize something so instead of initializing the value of speed and initializing the value of color let me just comment this code first of all so I'm going to select whatever I want to comment and then I can press control forward slash to comment all the line you can also go to code and then use this option which says comment with line comment and you can see the shortcut for that ctrl + /o K so this is going to comment your lines of code and now I want to use the speed as the initialization value so after the self keyword like give the next parameter which is speed here and then the third parameter is the color here and now to print the value of speed and color I can use once again print and then first of all I'm going to print the speed and then I'm going to print the color attribute and as soon as you do this and when you try to run this program it will give you an error so let me run the program and it will give me the error it says in it missing two required positional argument which is speed and color okay so once you create an init method and provide any arguments other than self self is automatically provided by Python whenever you create an instance of a class but other than self when you write for example speed and color arguments here you need to provide those argument at the initialization of your class so here first we will give the speed inside these parentheses for example 200 and then the color for example red here okay same we need to do for the other two instantiation of the car class so let me do it for the second instance and also for the third instance and now let's run the code once again and let's see what happens so now you can see everything works fine and no error is given to us and you will also see because this print is called first you can see the speed is printed first and then the color and then this line is printed after that and that means we will get the speed color and this line three times for every instance with different values whatever values you have provided for the instantiation of your car class now usually you provide these arguments because you want to initialize the value of speed so let's try to access the value of the ford object speed and color so let me just uncomment this code and let's run this code and it will give us an error you can see this says that car object has no attribute called speed right so what is the error because we have provided these attribute speed and color but we haven't assigned these values to any attribute inside this car class earlier what we have done is we have assigned the speed value to a speed attribute and the color value to the color attribute but we have already commented those codes so how can we assign the speed and color to the car object so it turns out that you can use the self keyword and then using the self keyword you can assign the value to the current object so self is essentially the current object okay it's similar to using this in C++ or Java if you are familiar with those two languages so you use self dot and then the name of the attribute for example speed in our case is equal to whatever argument you provide for speed so we have provided the same argument which is speed is itself once again I can use self to set the value of color here so self dot color is equal to color let me remove this semicolon because it's not required and now when I run this code you will see that there is no error now so because we have now used the self keyboard to set the attributes of speed and color so we can easily access the values of the speed and color using any object of the car class so let me once again minimize this so now let's talk about the self keyword here so whenever you create a class the first argument of everyman third you need to provide this keyword self now it's not necessary to provide this same keyword which is self but it's a convention to write this self as the first parameter the first parameter can be for example ABC it doesn't matter but you need to use this ABC here also as self and it will be totally fine but it's a convention that we use the self keyword in order to indicate that this is the current object so every method you will create you need to give this self keyword as the first argument of your method inside at last now you may also observe that here when I am initializing this class instance I'm not providing any self keyword so even though in the init method I have provided three arguments I am only providing two arguments here so it turns out that you don't need to provide the first argument which is self it will be automatically be provided to your class so you just need to give the next argument whatever argument you give after the self so we have given speed and color after the self argument so we just need to provide those arguments after whatever you use after this keyword called the self so let's do the same thing with our second class which is the rectangle class and here also we have created this empty class so let's remove this pass keyword and instead of this pass keyword we will use this init method which is def underscore underscore init underscore underscore and here after the self we will provide the height as the second argument and the width as the third argument okay and then we are going to initialize the attributes height and width using this self keyword so self dot height is equal to height self dot width is equal to width okay so this is how you can initialize your attribute using this init method and now when you do this you don't need to initialize these values like this you can directly initialize this height and width using these parentheses let me provide these values let's say 20 and 60 for the first rectangle and let's say 50 and 40 for the second rectangle and when we run this code let me just change the file here and then run the code and you will see it will print the area once again here so this init method is used to initialize your attributes or whatever you want to initialize at the start of your class you will do all those initializations inside this init method in the last video we have seen how to use init method and self keyword in Python in this video also we will discuss more about init method and the self keyword so let's get started so here I have a very simple class called hello and in this class I have a method called init and I'm just instantiating this class and creating an object out of this hello class now the first question which may arise is what if I don't want to use this self keyword you can see directly that there is a red squiggly line appears here which means an error and this we can also see when we run the program so when we run the program it's going to give us this error which says in it takes zero arguments but given one now you may ask why it's saying that we have given one argument to the initialization of this hello class so as I said in the last video that self is automatically passed when you initialize a class and that's why it says that one argument is given but in it takes zero argument because here we haven't given any argument and inside these parentheses so self is absolutely important so you need to give the self now the second question you may ask is can I create multiple in it method inside a class so let's see if it's possible or not so here I'm going to give this pass keyword which means that this init method is an empty method and let me create a second init method and this time I want to add one more parameter here let's say name okay so we have provided two init methods here and let's see what happens so this is the instantiation of class where I haven't given any argument to this instantiation so I'm going to run the program and what it says it says init missing one required positional argument which is named so it turns out that it's not possible to provide multiple init methods in your Python class if you provide multiple init method in your Python class the init method which you define at last will be considered as the main init method and other will be overwritten okay so whatever init method you define at last that signature of init method will be valid and all the other init method which you will create will be overwritten by the last init method okay so let's provide the argument name here so I'm going to just provide one argument here and then run this code and it works perfectly fine okay let me just reverse this order so instead of using this init at the top I will use the init which doesn't take any parameter at the bottom now okay and we provided this argument and let's run the code and now once again we get the error which says in it takes one a positional argument but poober provided so one positional argument means that this in it only takes the self argument and nothing else but here self is provided automatically but we are providing an extra parameter here which is not required and that means this init which we have defined later is valid and this previous init is not valid so always remember it's not allowed to use multiple init method in the Python class but if you do this the last init method will be a valid init method and all the other init method will be the invalid init method now one more question you may ask here what if I want to create both kind of instances one which takes no argument here and other which takes one argument or multiple arguments here so the answer is in my previous video in which I have shown you how to provide default value to your arguments so let's say I provide a default value to my argument here now I will create two instances of the same class one takes no argument and other takes one argument and when I run this code no error appears here okay so if you want to create an init method with multiple parameters you can either use this default value for your init method parameters or what you can do here is you can use this parameter which takes a tuple so in the previous video we have seen that we can provide an argument with Asterix in front of it and this means that we can provide multiple parameters to our method here and when we run the code it's also valid we can also provide multiple parameters here and it will also be totally valid so I'm going to run the program once again and you can see it's totally valid if you want to provide multiple parameters to your init method you can use this kind of notation or you can provide the default value to your parameter or the last thing you can use is you can use for example this type of argument which takes the keyword so kW args here okay and this also we have seen when ever you use this kind of notation that means you want to provide the dictionary right key value pair so let me provide some kind of key value pair let's say name is equal to some kind of name here and then let me run the code and it's totally valid it doesn't give us any error so even though multiple init methods are not allowed in Python you can use these type of notations in order to give variable length argument in your init method now let me just remove all the parameters from here and this instantiation from here also and let's take the next question so let's say I want to remove this pass keyword from here and here I want to initialize some values so self dot name is equal to let's say we will provide some name so I'm going to provide argument called name and self dot name is equal to name here and then let's say self dot age here and we provide some value which is not taken from the argument but we provide some static value here is it allowed yes it's totally allowed right so if you want to provide some default value for your attribute you can absolutely provide that without even passing it as an argument so it's not necessary that all the attribute values you need to provide from this argument list you can provide any default or static value here which is not coming as an argument so I hope that clarifies some more details about this init method in this video we will learn how to use encapsulation in Python and capsulation is one of the most important principle in objectoriented programming so let's get started I will be using this car class and the rectangle class which we have been using in the previous videos also and let me remove these print statements because we don't want them right now now let's say we want to change the value of speed so if you want to change the value of speed you can simply take your object for example for dot your attribute name for example speed and then you can directly change it for example 300 and when I run the program it's going to print the new speed which is 300 initially we have set the speed to 200 in here we can also put let's say the speed as string which is very stupid but will it work it works you can see here and this can break the function in which the speed is used so therefore it is very important that we protect our data and only give the access to our data to the other users so encapsulation is particularly important when you want to give your code to some other people because they might want to change your code so let's see how we can encapsulate our code so to encapsulate our code we create functions so let's create our first function which is to set the value of speed so I'm going to just say set underscore speed and inside the parentheses it's going to take self as the first argument which is the default and second is the value of speed so so I can say value here right and then once we have the value of speed we can just call self dot speed is equal to value similarly we can create a get method for the speed so right now we have created the set method to set the speed and now we are going to create a get method to get the speed and in order to get the speed we don't need to pass any argument we just need to return the speed which is already said so we can just write return and then self dot speed so we have created two functions set and get these are also called setter and getter for the attribute which is speed in our case so let's use these functions instead of this kind of setting of data so first of all I'm going to call this for object dot set speed method out of this object and then I'm going to pass the new speed using this set method now in order to get the speed I can write instead of this for dot speed I can just write the for dot get speed which is going to give me the speed of this ford object so I'm going to run the code and you can see it prints the speed which we have set using the set method but still will this protect your data let's see so I am going to once again try to use for dot speed and then I will try to set the new value of speed will it be a problem no so you can see when I try to get the speed that new speed is set and we want to prevent this kind of setting of data using this equals to symbol so we need to somehow make our attribute private now if you are familiar with other objectoriented programming languages like Java or C++ they use the keywords like public private or protected in order to mark their attributes or the member variables as the private or public or protected but python doesn't have any of these keywords so how we can make our data private so let me give you first of all an example so I am going to go to this class which is hello and Here I am going to set some values so first value is for example self dot a is equal to ten second value is self dot underscore B is equal to 20 and the third value is self dot underscore underscore C is equal to 30 so we have created three member variables in this hello class one is a second is underscore B and the C is with two underscores in front of it and let's try to access all these three values so I'm going to just use the print method and then the hello object dot a and similarly I will use the sprint to get the value of dot underscore B and also dot underscore underscore C now let's try to run this program and let's see what happens and you can see here the first value which is printed here is 10 which is the value inside the a variable so this code was executed successfully now we can see here that 20 is also printed that means this code is also executed successfully but at the time of underscore underscore C when we want to use this underscore underscore C outside the class it says hello object has no attribute called underscore underscore C and this is the point so underscore underscore you can use to make your attribute private okay so this is our convention there is no keywords like private in Python that's why python uses this kind of convention in which whenever you use double underscores it makes your data private when you use single underscore that also means that it's a private variable but this is only a convention nothing stops you to change the value of underscore B or accessing the value of underscore B okay so if you truly want to make your data private then use double underscore in front of your variable when you use single underscore that means it's a partially private variable and it's only a convention okay so let's go to our car class once again and now we know that we can add double underscore in front of our variable names so we have two variables here one is speed so let's add double List underscore in front of speed and also let's add double underscore in front of this color variable to make both of them private so I'm going to change this value of speed in getter and setter also and now let's try to access this value using this ford object which is underscore underscore speed now let's try to run our program so I'm going to change the file and then run our program and you will see that it's going to give us an error and this error says the car object has no attribute called color because this variable color is private now also you will observe that the value of the speed is 300 which is set by this set function even though we have set the speed again to 400 using this underscore underscore speed but this speed is not changed right so we cannot change the speed using this underscore underscore variable because now it's a private variable and that means we cannot change the value using this variable we need to use this set function in order to change the value of the speed also if you want to use this underscore underscore color here and let's run the code this will also give you an error because this underscore underscore color is private so either you can remove this code or you can create the setter and getter method for the color also so let's create the setter and getter method for the color and now we can access the value of color using the get color method right so instead of this get speed we can just write for dot get color and it's going to give us the value of color and now you can see that there is no error and the speed here is 300 which we have set using this set speed method and color is red which is the color we have given using this argument in the constructor and this type of restricting your data access using functions is called encapsulation let's do the same thing with our rectangle class also and let's create the setter and getter method inside the rectangle class so you already know we can use this define and then we can first of all set for example set the height first of all and then we can give the value of height here and then self dot height is equal to height right and don't forget you need to give double underscore in front of your attributes in order to make them private so I'm going to do just that and let's create the get height method also so now we have created the setter and getter for the height and let's do the same for the width also so now you have made the height and width as private and we have created setter and getter for the height and weight and now in order to calculate the area we can define one more method here which is the area method so let's create the area method here and this area method is not going to take any argument we are just going to return the multiplication of the height so self dot height multiplied by self dot underscore underscore width okay which will give us the area of this rectangle and we can call this area method instead of using this kind of notation so wrecked one dot area and rect two dot area also let's run the code by changing the file name here and run this code and you can see the area is printed now so this is how you can use an capsulation in python to hide your data in the last video we have seen how to use encapsulation in python and we have also seen how we can declare private member variables in Python to declare a private member variable we use double underscore in front of your variable name and this variable becomes private but the question is what exactly is a private member variable so a private member variable is private to the class that means you can use this private member variable inside the class but as soon as you use it or access it outside the class it will give you an error so you cannot access a private member variable outside a class and the example we have already seen so here you can see I try to access this private member variable outside the class and when I run the code it says that there is no underscore underscore C attribute for this hollow object why because when you create an instance and if the member variable is private this private member variable is invisible to your object so you cannot access the private member variable outside the class but can be used this private member variable inside the class let's see so I'm going to declare one more method here and I'm going to name it as public underscore method and this doesn't take any argument but what we have learned about the methods in a class that even though you don't pass any argument to the method you have to provide at least one argument which is the self argument and what is self self is the current object so let me just print something here quickly for example public here so can we use this private member variable inside this method let's see so I'm going to just write self dot underscore underscore C and then I'm going to run this code and let me comment this line because this was giving us an error and instead we can use this public method so I can use an instance of hello which is hello dot public method and let's run the code now and you can see there is no error that means you can use your private member variables inside the class or any method of ductless now the other question is what is a public member variable like a here so a is a public member variable because it doesn't contain any underscore underscore in front of it and that means you can use this public member variable inside the class as well as outside the class so if I want to use this public member variable inside the class also I can just use self dot a and then run the code and it's totally fine it doesn't give us any error let's print the value of for those two member variables and once again run the code and it will print the value of a and C and then this message which we are printing here which is public here now the next question is how we can define a private method in that class so let's see how we can define a private method you already know most probably which is by using double underscore in front of your method name so for example underscore underscore private underscore method and then I'm going to just print something inside this method let's say private so this is a private method and how you can define a private method using these double underscore in front of the name of your private method and the restriction will be the same on the private methods also so let's try to access this private method outside the class so I have this hello instance and when I press dot here you will see there is no suggestion for this private method because PI Chum already know that this is a private method so it doesn't show this method in the suggestion when you use this object outside the class but let's try the brute force and let's try to use this method outside the class and when I run this code you will see once again you will get an error which says hello object has no attribute underscore underscore private method so private methods also you cannot use outside in the class but inside the class absolutely you can use your private methods so how to use your private methods inside that lass so you can use your private method inside the class using once again a self keyword so you write self dot and then your method name for example private method and that's how you can call your private method inside the class using cells so any method you want to call inside the class you do it once again using the self keyword as you do with your member variable and once again when I run the code now it prints private using this statement and this statement is executed when we call this private method from here so I hope this video will clarify some more doubts about the private member variables and private methods in Python in this video we will talk about Python inheritance so first of all what is inheritance in Python so classes in Python can be extended creating new classes which retains the characteristics of a base class and this process is known as inheritance now in simple words the idea behind the inheritance is that a new class can borrow the behaviors and methods from the another class now the inheritance involves two types of classes one is a superclass and other is a subclass now the subclass inherit members of the superclass on top of which it can add its own members for example any other member methods or variables so here subclass is the one who is doing the borrowing of the members and the superclass is one from which subclasses borrows these kind of member methods and variables now if this inheritance sounds to be little bit confusing to you let me give you an example so I said in inheritance there are two type of classes one is a superclass and other is a subclass now in this example I have taken polygons as a superclass and two classes rectangle and triangle as the subclasses now if you see carefully what is the relationship between rectangle and polygon and triangle and polygon so rectangle is a polygon right and the triangle is also a polygon that means the rectangle can inherit some properties from the polygon class also triangle can inherit some properties from the polygon class and the relationship between the superclass and the subclass is defined by a relationship called is our relationship so rectangle is a polygon and triangle is a polygon also that means that rectangle and triangle can inherit from the polygon class so in inheritance the subclasses have is our relationship with the super classes so let me give you one more example so as a superclass you can take an animal class and then as subclasses you can create a dog class cat class red class because all of them are animals so dog is an animal cat is an animal rat is an animal so always remember when you use inheritance there is a is our relationship between superclass and the subclass now let's take our reallife example and let me try to explain you this concept with some code so I'm going to create a new project in my PyCharm IDE and this I'm going to name it as inheritance and I will choose this option open in current bed door and also this option which says add to the current opened project which is going to create a project in the same window so now this project is created so I'm going to go inside this project and I'm going to create a new Python file here and I'm going to name this file as polygon because we are going to create a polygon class and inside this polygon dot py file let's first create a class called polygon and inside this polygon class what are the attributes which we want to add here so rectangle and triangle what are the common things which they both have they both have the width and the height so we are going to first of all create a variable called width and we will initialize it by a value none the non keyword is used whenever you want to assign nothing to your variables right in the same way I'm going to use height and I'm going to assign none to that also now what I'm going to do is I'm going to create a method here so let me define a method using d EF and I'm going to use this method to set the values of width and height and this method is going to take two argument one is the width and the other is the height right now if you remember in the last video I have shown you how to make your variable private so you use double underscore in front of your variables to make them private so I'm going to add this double underscore in front of width and height that means these two variables are private now using the set values method I am going to just set the values of the height and width so cells dot underscore underscore width is equal to width and self dot underscore underscore height is equal to height so this is the polygon class which we have created and it's a superclass in our case right and now let's define two subclasses one is a rectangle and other is a triangle so let's define other class called rectangle and inside this rectangle I'm going to define one method let's say this method is a area method and this area method is going to give us the area of the rectangle and what is the area of the rectangle the area of the rectangle is the multiplication of the width and the height similarly I'm going to define our triangle class also so let me define the triangle class here and let's say this triangle class also have this method which is area now what is the area of a triangle the area of the triangle is the multiplication of width and height divided by two so we are going to divide the multiplication of width and height by two this is the area of the triangle so now we have defined three different classes and we are saying that polygon is the superclass and rectangle and triangle is our subclasses now how we can inherit the properties of the super class which is polygon into our subclasses which is rectangle and triangle so in order to inherit from one class to another you use this parentheses and inside the parentheses you write the name of your super clasps and that means your rectangle is inheriting from the polygon class similarly when we write this parenthesis and the polygon class here that means triangle is inheriting from the polygon class now when a subclass inherits from a superclass the superclass member variables and methods are accessible also using the subclass also so let me give you an example so I'm going to create the instance of rectangle first of all so let me just write rectangle so this is the rectangle instance and let's create a triangle instance also and now once we have triangle and rectangle instance let's use this rectangle instance and when you write dot here you can see intelligence says that area is available for this object and set value is available for this object so when you use set value you can see we haven't defined the set value method inside the rectangle but because we are inheriting from the polygon class into a rectangle class all the members of the polygon class are available using the rectangle object also and what this method takes it takes the width and height so we are going to provide the width and let's say height 50 and 40 and once again we are going to use the triangle object and we use the set values and this time also let's say I'm going to provide the same values here and what does this set value method is doing it's just setting the values of width and height inside the polygon class now in order to calculate the area we can call the area method from the rectangle and the triangle class so let's just do that and I'm going to do this inside a print method and I'm going to just call the rectangle object dot area which doesn't take any argument and the same I'm going to do for the triangle object also so triangle dot area so what do you think will happen now so let's run the code and let's see what will happen so I'm going to right click on this file and I'm going to just choose run a polygon it's going to run the program and you will see it gives us an error and what is the error the rectangle object has no attribute rectangle underscore underscore width that means because this width and height are private member variables of the polygon class they are not accessible from the subclass which is the rectangle class and the triangle class so you cannot inherit the private members from the superclass into the subclass so what is the solution here so what we can do here is we can create the getter methods for the width and the height so I'm going to do exactly that so let's define a method called def get underscore width and it's going to take no argument and it's going to return the value of the width so using self we can access the value of underscore underscore width in the same way we can define a method called get underscore height here and it's also not going to take any argument but we are going to return the value of the height here so self thought underscore underscore high so now we have created the getter methods for the width and height and these getter methods are the public members why they are public because we haven't used the double underscore in front of these two methods and these two methods now we can use in place of these private member variables which we were trying to inherit in the subclass using the superclass so instead of underscore underscore width we can write self dot get width and also here instead of underscore underscore height we can use get height similarly we will do the same for the triangle class so get width and the get height dot get height now let's run the program again and let's see what happens and now when I run the code it gives me the area of rectangle using this print line statement and then it's going to give me the area of triangle which is exactly the half using this line of statement so let me once again minimize this and let's recap what we have learned so we have created a superclass and two subclasses superclasses polygons and subclasses our rectangle and triangle and in order to inherit from the superclass you just use parentheses and the name of your superclass and that means in our example rectangle is inheriting from the polygon class next what we have learned is all the public member variables or the methods are accessible from the subclass from the superclass so set value method and get value method is accessible because they are public methods but underscore underscore width and underscore underscore height are not accessible because they are the private member variables so you cannot inherit the private member variables into your subclasses now we have seen this example in which we have created two instance of the classes one is rectangle objects from the rectangle class and the other is triangle object from the triangle class and first of all we have used the set method which is coming from the polygon class it's not the part of the rectangle or the triangle class to set the values of width and height and then we have just called the area method from these two classes in order to give us the area so this set method is used to set the value so it has set the value of width and height and using this get method get width and get height this value is returned and this value is returned into the subclasses and then the multiplication of these two values gives us the area here and the multiplication of these values divided by two gives the area of the triangle here so this is how you can use inheritance in Python in this video we will discuss how to create modules in Python now in the previous videos I have already discussed briefly about builtin modules and how to import a builtin module you use an import keyword and then you use the name of the builtin module in Python builtin means this module is already present in Python so we can use these builtin module in order to perform some functionality so for example this math module helps us to perform some mathematical operations now first of all what is a module so it turns out that a module is nothing but a Python file now to prove my point let me just hover over this math module and just press control and then hover over it so right now I am pressing control and I'm hovering my mouse over this mat on the pycharm IDE and now I'm going to click it and when I click it you will see this module is nothing but a file right and inside this module we have a number of functions which we can use for example a COS function or a tan function or many different functions which we can use from this math module so a module is nothing but a Python file now if a module is nothing but a Python file why don't we create a module and it turns out that Python allows us to create our own modules so let's create our own modules and let me show you how you can create your own module and right now you can see in my project there is only one file which is hello dot py and it's empty right now now to create a module I'm going to just create a new file so right click and then new python file and this module I am going to it as my functions and then press okay and this file is created so now I have two files in my project one is my functions and other is hello dot py so let's say I want to create some functions inside this my functions dot py file so let's create some function I'm going to very quickly create some very basic functions which you already know in Python so so let's say I add function which returns the addition of two numbers and also let's create let's say multiply function so multiply and this is going to just give the product of two numbers so let's say this is our module and it has two functions now somehow I need to use these two functions from my functions dot py file into this hello dot py file now as you can see these two files are in the same directory right so I can import this my functions file using import and then the name of the file which is my functions and that's it so in order to import a module you just write a keyword called import and then you just write the name of the file without the extension py okay so you don't need to provide any extension here and then I can use this function so let's say I want to print my function which is the file name so whatever file name you give here you need to use the file name here dot you will see all the functions in the file are now visible in the other file which is hallo dot py so let's use this add function and I'm going to just give two parameters here and also let's use the multiply function from my functions files so the file name and the method name or the function name and let's give two parameters here also and that's it so it's that simple to create your own modules and import them in to other files in Python now when I run this program is going to give me the addition and the product of these two argument which I have provided here now let's say your my functions file is in some other directory so let me create a directory so I'm going to right click here and then I'm going to create a directory and I'm going to name it as dir and then click OK and now I'm going to move this my functions dot py file into the new directory so I'm going to just right click and cut from here this file and I'm going to just paste this file into the dir directory ok so let me just click OK here and as soon as I do this you will see here pycharm is intelligent enough to refactor this code and now it has given us the correct import ok so if this my functions file is in some directory then you use this type of notation so you write from and then your directory name and then import keyword and then your file name so you can see this is the directory name and this is the file name so I use from directory name import file name and when I run the code once again it's going to give me the same answer now there is one more way of writing the same notation and that is using the import so use import keyword and then write the name of your directory dot the name of your file so directory dot the file name and then you use this name in place of your my function name ok and once again when you run the code it runs fine now sometimes you might feel that this is a long name and Python have the solution for it also so it turns out that you can rename your file using a keyword called as so after the import so import directory name dot file name as and then you can provide your name for example my functions I will just name it as MF okay and now I can use this MF name instead of this big name and this will also work fine so either you can import from your file which is inside the directory using this notation or you can use this notation you can also write as in front of this notation also so from directory name import file name as whatever name you want to give here and this you can use to call your function using this dot notation now this was the easy stuff and I have just written here the two functions and then imported these two functions into the other file but what if if I have multiple classes I haven't shown you how to import files which have classes in them so let's see how to import the Python files which have classes inside them so I'm going to close these two files and in the last video I have shown you how to use inheritance in Python and we have created this class polygon and two other classes which is triangle and the rectangle class and this might be right now the perfect candidate to import into some other file so I'm going to create two more file one is the rectangle file so I'm going to just right click and create a Python file and I'm going to name it as rectangle and I'm going to create one more file with the name of triangle so rightclick new Python file and the name is triangle dot py and let me create the fourth file which I'm going to name it as main and this will be our main file in which we will import all these classes so in my polygons class I will just leave this polygons class and I will just transfer this rectangle class into the rectangle dot py file and this triangle class into triangle dot py file and also this was the instantiation of the rectangle and triangle class which we have done so I will transfer this code into our main dot py file okay so now we have a polygon dot py file in which we have the polygon class and then we have the rectangle class inside rectangle dot py and also we have the triangle class into the triangle dot py file and rest of the code we have inside the main dot py now when you go to the rectangle dot py you will see that it's inheriting from the polygon class that means we need to import polygon class into the rectangle dot py file so how to import it you can use from and then the file name which is polygon and then use import keyword and use the name of the class which is polygon and you will see that this error is gone and same we will do inside the triangle dot py file in order to import the polygon class into that triangle dot py file so this is the file name so from file name import the class name now when I go to the polygon class we don't need to import anything here because it's a superclass and there is no import needed here let's go to the main dot py file and here you will see red squiggly line under rectangle and triangle class because we haven't imported this triangle dot py and the rectangle dot py into our main dot python file so the procedure is same from your file name which is first of all rectangle import the name of the class which is rectangular same we will do for the triangle class so from the triangle file named triangle dot py and then import and then the name of the triangle class and you will see as soon as you do this the error is gone so now there is no red squiggly line under any of the code so now let's run the code so I'm going to just go to the main dot py file and I'm going to right click on this main dot py file and I'm going to just click on run mean which is going to run the program and it's going to print the result which is the area of rectangle and the area of the triangle so in this way you can import the py file which have classes inside them so this is how you create your own modules in python and import them into other Python files in this video we will talk about multiple inheritance in Python so first of all what is multiple inheritance so the ability of a class to inherit from more than one class is called multiple inheritance and in Python a class can inherit from more than one class so let's see an example which shows us how to inherit from multiple classes now I will be using this example which I have already shown you in the video where I have shown you inheritance in Python so there is a class called polygon which is a superclass and the other two classes are triangle class and the rectangle class which are the subclasses and these two classes are inheriting from the polygon class and I have also one more Python file which is main dot py and in this main dot py just importing these two rectangle and triangle class and creating an instance out of them and then setting the value of width and height and then we are printing the area of the rectangle and a triangle so if you haven't seen the last two videos just watch those videos because I will be using the same code in order to show you how to use multiple inheritance so let's get started so what I'm going to do is I'm going to create a new python file here and I'm going to name my file as a shape and I'm going to use this shape dot py to create a class called shape so let me create a class quickly and I'm going to name it as shape and this method I'm going to define a private variable called color and I'm going to initialize it with the value none and then I'm going to define the setter and getter for this color attribute so let's define those so now we have defined the setter and getter for this color attribute now if you remember what I told you about inheritance and that is whenever you want to do inheritance between a superclass and the subclass there is a is our relationship between the subclass and the superclass so rectangle is a shape and triangle is also a shape so that means we can also use this shaped lass as the super class in rectangle and the triangle classes so let's use the shape class into the rectangle and triangle class as the superclass so first of all I'm going to import this shape class from the shape file so let's import this and same I will do in the triangle class also and now how to inherit from multiple classes into our subclasses so we have already inherited from in the polygon class and in order to add one more class here you just need a comma separator and the name of your class so this is how you inherit from multiple classes you just use the parentheses and then the name of your classes separated by the comma that means the triangle class is inheriting from the polygon class as well as the shape class the same we will do in the rectangle class so I will just provide the comma here and then I will just write shape here and now I will go to the main dot py file and once you do the multiple inheritance that means all the public methods of the shape class is available in the sub classes which are triangle and the rectangle so I can use this kind of notation first of all I am going to use rectangle class to call the method called set color so I'm going to set color from here and let's say the rectangle color is red and then I'm going to use the triangle object to call the set color method once again and the color I want to provide here is let's say blue ok and in order to get those two color values we can once again write print the instance name which is rectangle dot get color and same we will do for the triangle object also so print triangle dot get color and that's it so now all the public method of the shaped lass is also available in our rectangle and the triangle classes and we can use all the public methods of this shape class into the subclasses and let's run the code and let's see what happens so the code is running and you can see it prints red and blue using these two statements so this is how you can do multiple inheritance in python in this video I'm going to show you how you can use a builtin function called super in your Python classes so let's get started so to start with I have two classes here one is the parent class and other is the child class and here parent class acts like a superclass and the child class acts like a subclass which is inheriting from the parent class now both these classes have this init function and you already know what does this init function do it is the first function which is called when an instance of a class is created and here I'm just creating the object from the child class now what do you think will happen well that this constructor will be called or this constructor will be called because we are inheriting from the parent class into the child class so let's find out so I'm going to run this code and it prints child in it that means this statement under the child class init method is executed and this method is not executed now in some cases you might want to pass some parameters also into your superclass for example I'm just going to give this example let's say I want to pass a argument called name here and then I will just print the value of name how can I call this init function using this child class instance so it turns out that there is a function called super in Python that allows us to refer to the superclass implicitly now this super function is a builtin function which returns a proxy object that allows you to refer to your superclass so let's try to use this super function so you just use the keyword super and then give these parentheses because this is a function and then this super function will return the proxy object of the superclass that means I can use this dot operator to call the init method from the superclass so this notation means super dot in it means we are calling the init method from the parent class and that means we can pass the name from here so let's just pass this near I am going to just write max here and now I'm going to run this code and now you will see that child in it is printed using this statement first of all and then using the super function the init method of the parent class is called and then this name is passed here and it prints parent in it and the name whatever name we have provided here so this super function allows us to refer to the superclass now let me show you one more thing which is called the method resolution order and you can find this method resolution order by using your class name so child last name dot underscore underscore mro so just write underscore underscore Amaro underscore underscore and this statement I'm going to use inside the print function so you can see the result what it returns so I'm going to run the code now and you can see it returns this kind of order so as the name suggests mr o stands for method resolution order and this is the order in which the methods are called inside your child class or the parent class and this order means that all the method in the child class will be executed first and then all the method in the parent class will be executed now there are some rules based upon which this order is calculated and these rules are the first rule is the method inside your subclass are always called first and then whatever the method inside the base class they will be called and the second rule is related to multiple inheritance so let me just create the second parent class and I'm going to name it as parent too and here also I'm going to just write parent 2 here and let me inherit from the parent 2 also in the child class right and let's run the code once again and now you will see this order so once again child is printed and then the parent and then prayer in 2 and then the object so the second thing on which the amaro depends upon is the order in which you inherit from the parent class or the superclass so in our example we were inheriting from the parent class first of all and then parent to and in the same order this amaro also will be decided so all the method in the child class will be executed first and then all the methods inside the parent class whatever you use first here will be executed and then whatever superclass you write after that those method inside the class or superclass will be executed next and at last this is the base object now let's try to just reverse this order and once again let's run the code and you will see that this order will be reversed so the method resolution order will tell you which class method will be executed first and then the order of all the methods from the super classes now one more interesting thing which you will observe here is this output so I said that this super function is used to refer to the super class and now we have two super classes that means multiple inheritance and you will see here that only one output is printed which is from the init method inside the parent to and this statement is not printed which is inside the init method inside the parent class so how to solve this problem so if you have multiple inheritance then you need to manually call these init function using the class name so let's say I want to call the init function first fall from the parent to class I will use parent to dot in it and then you need to give also the self as the first parameter and the second which is the name in the same way you use the second class which is parent dot init function and then first parameter is the cell and then you can pass any other name for example Tom here and let me run the code and you will see it calls first of all parent to init function and we have passed max here as the name and then it calls the parent one init function with the name Tom which is printed here also so this is how you can use super function in Python in this video we will talk about operator overloading in Python now you might already know that everything is an object in Python so when I want to know the type of this number it's going to show this kind of output and this means that is an object of the class int now when I once again want to know the type of let's say 2.0 it's an object of class float when I want to do the same operation with the string this string is an object of class string so everything is an object in Python now have you ever wondered that when you do 2 + 2 it's going to give us the addition of two numbers and when I add two strings let's say two and then I am going to use the same operator which is plus operator with the other string it's going to give me the concatenation of these two string values so the same operator plus is working differently with different type of objects the same you might have observed with the multiplication operator which is this asterisk so when I use this asterisks or multiplication operator with a string and let's say I write three here it's going to print this given string three times but the same operator when I will use with the two numbers it's going to give me the different behavior which is the multiplication of these two numbers so the same operator Asterix is functioning differently with different kind of data or in other words we can say that this Astrix operator or this plus operator are overloaded for a different kind of objects so whenever this plus operator is used with two numbers it's going to give us the sum of these two numbers and whenever this operator is used with the string it's going to give us the concatenation of these two strings so both these operators are overloaded for handling different kind of data so this is the overloading of the builtin readers now we might also think that if this is possible can we overload the operators by our custom classes so let me create a class and I'm going to name it as the number class which is going to take one argument so let me define a constructor here so underscore underscore init underscore underscore and this is going to take one argument which is the number and I'm going to just write self dot num is equal to num so this is the simple class which we have created and now I'm going to create two instances of the same class so number and I'm going to give the number one let's say here and then I'm going to create a second object of this class and this time I'm going to give the number two here so is it possible that we can use let's say + 1 + + 2 so let's try this and it's going to give us this error which says unsupported operand type 4 plus number and number so because Python doesn't know how to use this + operator with your class objects it's going to give us this error which is unsupported operand type and whatever is the operator you are using so it turns out that we can overload these kind of operators in Python by implementing some inbuilt methods in our class so we already know that whenever we want to implement a constructor in Python we use this init method so I'm going to create a very simple class and I'm going to name it as a and this will be a blank class so this is a very simple class in Python and when I use a dir function which is a builtin function with this class let's see what happens so I'm going to just press ENTER and it's going to print some methods here which are inbuilt method so here not all methods are Cybil so I'm going to assign this value of dir a to a variable a and then we will see in the right hand side in this inspector here and this is the a variable and you will see the list of all the inbuilt methods which are associated or which you can implement them so for example we have implemented the init method in order to have the functionality similar to constructor but there are other methods here too so there is a STR method or le method which is less than method or any method which is not equal to method and many other methods which we can implement here in our class so now I have given enough theory to you and let's try to see with an example how to overload an operator in Python so here I have created a class which I call circle and this takes one argument which is the radius of the circle and I have created the setter and get a method for this radius variable and in the third method I am just calculating the area of the circle using the radius and I have also used a inbuilt module which is math in order to get the value of pi so using this expression I am just calculating the area of the circle now I have created two objects of this class with two different radiuses so in the first object I have given the radius to and in the second object I have given the radius 3 and from the theory which we have learned till now we already know that this expression will not work with these two objects so when I run this code it's going to give me the error which says unsupported operand error so now we are going to overload this plus operator in this circle class now in order to overload a particular operator let's say plus you need to implement associated method in your class so with this plus operator there is a special method which we need to implement in our class and I have given the list of all the methods which is associated with the operators so with the plus operator you need to implement this special method which is underscore underscore add underscore underscore in order to overload you use this method in order to overload the multiplication you use this method so here is the operator which we want to overload and here I have given the method name which you need to implement in your class in order to overload this operator in Python so there is this list which you can use with all these operators so you can overload the mathematical operators in Python you can also overload the bitwise operators in Python like and or or bitwise right shift orbit wise left shift and also you can overload the comparison operators in python using these associated methods with these operators so now we want to overload this plus operator so we will implement this add method into our class so let's implement this add method into our class and implementing this method is really simple you just need to define a special method which is underscore underscore add underscore underscore and this add method is going to take two arguments one is self you already know and the other is the object of the other instance so this second argument is the object of the circle class and now inside this method I am going to just return first of all I will just use this circle as the constructor and what I want to do I want to add let's say the radius of the two objects which are provided one is the self object and other is the object which is provided you using this argument so I'm going to just say self dot underscore underscore radius plus the circle object radius so let's use the circle object and then dot and then underscore underscore radius so basically I'm adding the radius of the two objects one is this circle object and other is the radius of the self which is the current class so as soon as you implement this method ad using these two arguments then this operation is going to work in Python so because we have overloaded the plus operator using this ad method now this operation is going to work so let me just assign the addition of these two objects into a third variable and this variable I'm going to name it as c3 and using this c3 let's say I want to print the radius of the circle so I'm going to just use the print method and then I'm going to use the c3 object and I'm going to call our get radius method from this object and let's print the radius of c1 and c2 also so here I am going to just write c1 and here I'm going to just write c2 so we are printing the radius of all these three objects and I'm going to run the program now and you can see here the radius of the first object is two because we have provided two as an argument here the second is three because we have provided three as an argument here and because we have created this third object using the overloading of this plus operator where we were just adding the radius of both the objects that's why we got five years so two plus three is equal to five and this addition we have done using this expression so we have added the radius of the current class and the object which is passed using this argument so this is how you can overload the craters in Python by implementing the Associated methods which are available in Python so let's say now we want to overload the less than and the greater than operator so for the less than operator we use this LT method and for the greater than operator we use this method called GT so let's implement these two method inside our classes so I'm going to just copy this add method to x and first of all I'm going to replace this by LT which is less than and the second method I'm going to replace by GT which is greater than and we want to see if the radius of the circle is greater than the second radius which is provided using this object or not so first is less than so we are going to provide this operator and second is greater than so we are going to provide the other operator which is greater than operator and now this less than and greater than function is going to give us the boolean value if this radius is less than this radius then it's going to return as true otherwise it's going to return us the false so I already have the two instance of two classes and if I want to compare these two classes I can just write c1 and I will use thus less than operator here and then c2 and also I'm going to use the greater than operator here and let's run the code and let's see what happens so now it's going to give us this value which is the constructor of the circle so how can we get the boolean value you just need to remove this constructor from here so you just need to remove the name of the class and now I'm going to run the code once again and now you will see true and false so we were checking if c1 radius is less than C 2 and it gives us true and once again we were checking if c1 radius is greater than C 2 and it has given Falls to us all so we can check the third object for example c3 here if c3 is greater than C 2 or not and most probably it's going to give us true and it's correct here so you can see it's that simple to overload any operator in python using these builtin methods so you just need to find out the Associated method related to that operator and then you just need to implement that method related to that operator in addition you can also implement some other methods which are available with the class so once again when I'm going to print the dir with any of the object let's say c1 and I'm going to run this program and you can see the list of the functions which you can implement inside your class so ad is already there but you can also implement this dish method or dir method or any of these methods which are available here so our EPR method or STR method any method you can implement inside your class in order to avail the functionality associated with that method so it's last let's try to implement one of the method which are associated with the class so let's say we want to implement this method which is the STR method so I'm going to just minimize this and I'm going to just copy this function and once again paste here and instead of greater than I'm going to just implement now the STR method now this STR method only takes one argument which is self so I'm going to just remove the second argument and here in the return value I can just return some string for example so I can just say circle area and I'm going to return the area of the circle so I'm going to use this concatenation operator and then I'm going to convert the area into the string and then I'm going to just use self dot area which is going to give us the area of that circle so once you have implemented this STR method in your class you can simply use it like this dir method so I can just write STR and then the name of your object which you have created and let's run the code and let's see what happens so I'm going to just see the result now and it prints circle area and it's going to print the area of the circle I just need to provide equals to symbol here so we will be able to see it in a prettier way so you can see the area of the circle is printed similarly you can print the area of the other two circle which is circle two and circle three and let's run the code once again it's going to print us the area of all these circles so this is how you can use operator overloading in python in this video I'm going to show you what is composition and how to use class composition in Python so to start with I have two classes here one is an employee class and other is the celery class now in the salary class I have this init method which takes two argument P and bonus and it sets these two arguments to the member variables of this class also I have a method called annual salary which is used to calculate the salary now in the employee class I have this constructor which takes four arguments which is name age P and bonus now what do you think can we apply inheritance here the answer is no because there is no is our relationship between salary and employee so employee is not a salary and salary is not an employee but somehow I want to delegate the responsibility of calculating the employee salary to the salary class because calculating salary is in itself is a big task I have just simplified this class in the form of just calculating the annual salary but the employee can have his in Texas or he has taken some leaves or many factors affects the salary of an employee so this salary calculation let's say we want to delegate to the salary class but whose salary is this this salary is the employees salary so we know that we cannot use inheritance here but we can use a concept called composition here and the composition means that we are just delegating some responsibilities from one class to the another class so how to delegate this responsibility we can just create one more variable here for example self dot obj underscore salary which is the salary object we are going to create using the salary class okay and this salary class takes two parameters one is pay and other is bonus which we are already providing using the employee init method so I'm going to just pass this pay comma the bonus into the salary class so we are instantiating the salary class inside the employee class so here one class which is an employee class acts like a container of the other class which acts like a Content okay so salary class is the content and the employee class is the container of this salary class now in order to calculate the total salary we can define one more method here and I'm going to just say total underscore celery and then what we are going to do is we are going to call our object salary member variable because this gives us the object of the salary so I am going to just call object salary and we can call this method from the salary class which gives us the annual salary and now I am going to just create the object of this employee class so let me just right EMP is equal to employee which takes four parameter first is name second is the age third is the piece so let's say P is 15,000 and the bonus is 10,000 and now I just want to print the total salary of this employee so I can just write print and then EMP object dot the total salary which is total salary method and you can see here this total salary is returning let me just use the return keyword also because we are returning this annual salary from the salary class using this total salary method so let's run the code once again let's see what happens and you can see annual salary is printed and this annual salary is calculated using the salary class so what this employee class has done it has delegated some responsibilities to the other class which is the salary class which gives us the annual salary of an employee and this here is called composition now one interesting thing which you will notice here is we are not instantiating salary here we are just instantiating the salary inside an employee class so as soon as you delete an instance of an employee the celery class instance will be automatically deleted so whenever you want to delegate some responsibility of one class to the another class it's called composition one more example of composition can be a book class and a chapter class so a chapter is not a book and book is not a chapter but we can delegate some responsibilities from a book class to the chapter class so this is how you can use composition in Python in the last video we have seen how to use composition between classes in Python in this video I'm going to show you how to you class aggregation between classes in Python now if you haven't watched my last video in which I have shown you how to use class composition in Python I will highly recommend you to watch that video because I will be using the same code to demonstrate how aggregation works in Python so in the last video we have created two classes one is an employed loss and other is the salary class and then we have used the celery class inside the employee class and we have seen how composition works in Python so employee class is delegating some part of its responsibility to the celery class and that is called the composition now in composition the relationship between the classes which have some Association is represented by a key word part of so celery is the part of employee so the key word we use in composition is part of now let's see how we can use aggregation instead of composition between these two classes so let's say I will not use this celery class inside the employee class but what I'm going to do is I'm going to pass an instance of celery here so I'm going to just write celery and this will be the object of celery class which I'm going to pass in the init method of the employee class so let's create an object of the celery so I'm going to just write celery here is equal to the celery class and we will instantiate the celery class by these two argument which we have given in the last video to the employee class so I'm going to just copy these two arguments and paste it here and I'm going to remove this comma here so now what we are doing here is we are first of all instantiating the celery class and now the celery class we can pass to the structure of the employee class and this is the object which we have passed using the salary class object and then I'm going to take the salary class object and I'm going to assign the salary class object to the member variable of the employee class which is obj underscore salary now because we are passing the salary object that means this member variable is the salary member object and we can call any public method from the salary class using this member variable now so let's run the code and let's see what happens and we get the same result as we have seen in the last video in the composition example so what we have done differently here so instead of using this salary class inside the employee class we have first created an instance of the salary class and then we have passed this instance to the employee constructor which can be used inside the employee class and this type of relationship is called aggregation now let's see what are the special properties of the aggregation the first property is the relationship between the associated classes in aggregation is defined by the keyword has a so employee has a salary because now we are first of all creating the salary object and then passing it to the employee so now we are not directly using salary inside the employee class the second property of aggregation is that associated classes have unidirectional Association so we are just passing salary object to the employee class we are not passing employee object to the salary class so it's a unidirectional Association only salary can be passed to employee not the other way around and the third property of aggregation is we have created the salary object and the employee object so both these objects are independent of each other so if one object dies the other server so both the object are able to survive individually so these are the three properties of aggregation now let's see the difference between the composition and the aggregation so I'm going to split the screen so I'm going to just right click on this tab and I will say split vertically and here I'm going to open the example of the composition so on the right hand side I have the example of composition and on the left hand side I have the example of aggregation let me just maximize this so you can see it and now let's discuss about the differences between the composition and aggregation so the relationship in composition is defined by a keyword called part of so salary is the part of employee in aggregation there is no part of relationship but the relationship is defined by the keyword called has a so now in aggregation we are defining the instance of salary and then passing it to the employee class and salary is not the part of the employee class we are just passing it to the employee class so aggregation we use has our relationship and in composition we use part of relationship the second difference is when you delete the employee object the salary object will be automatically be deleted so salary object is dependent on the employee class but in aggregation the salary object and the employee object are individually independent so they can survive individually if one object dies then it doesn't matter that the other object dies because we have created these object individually now in composition both salary and employee are interdependent on each other but in aggregation the relationship is unidirectional so the association between the employee and the salary object is unidirectional you can only pass the salary to the employee class but we cannot pass the employee object to the salary class so these are the three major differences between composition and the aggregation in this video we will talk about creating abstract classes in Python so let's get started so to start with I have here two classes one is a shape class another is a square class in shape class I have to empty methods one is area and other is perimeter and I'm using shape as a superclass and square as a subclass and square class is inheriting from the shape class now in this example I want to do two things one is I don't want to allow the other users to create an instance of a shape class because shape class acts like a template for the square class so I don't want to allow those users to create an instance of this shape class so let's see right now if we can create an instance of this shape class or not so I'm going to just right shape is equal to shape and when I run the code my code runs fine that means right now I'm able to create an instance of the shape class which I don't want the second thing is I want to make sure that both these methods which are there inside the shape class are implemented inside the square class so I want to make sure that whoever is using the shape class he or she must implement these two methods inside the subclass so how can I achieve these two things now it turns out that abstract classes are just made for that so how to create an abstract class in Python the fact is Python on its own doesn't provide any abstract class but don't worry there is a builtin module in Python which we can use to create an abstract class so let's import this builtin module first so I'm going to just write from ABC import capital ABC comma abstract method so these are the two things we need to import from this module now this module ABC stands for abstract base classes and this allows us to create the abstract classes so how we can create an abstract class using this ABC module so what we need to do here is we need to inherit from the ABC module into the shape class okay so shape class is inheriting from the ABC module now once this shape class inherit from the ABC module the second thing what we need to do here is we need to add a decorator here and how to add a decorator we just need to use at the rate and then the name of this abstract method which is like this and let me use this abstract method decorator on top of this parameter method also so what this abstract method decorator does is it makes these two methods abstract and what is an abstract method an abstract method is a method which you must implement in the subclass so when you run the code now it will give us this error which says can't instantiate abstract class shape with the abstract method so once you create any of your class method as abstract then your class becomes the effect class and then you cannot instantiate this class like this so our first goal is achieved that we cannot instantiate this shape class now because this class is now an abstract class and how to create an abstract class you just need to import the ABC module and then you just need to add this decorator on top of your method and if you do this even with one method in your class then your class becomes abstract so now we have removed the instantiation of this shape class but now when I try to instantiate this square object from the square class let's see what happens so this square class takes one argument which is the side of the square and let me run this code and once again it gives us an error and this error says can't instantiate abstract class square with abstract methods so that means that whenever you inherit from a class which is an abstract class and if this class contain any abstract methods then the subclass have to implement the methods which are abstract so this method area is an abstract method and this method parameter is also an abstract method that means we have to provide the implementation of these two method inside our subclass so I'm going to provide the implementation of area first of all into the subclass and area I'm going to just return as the multiplication of the sides right so self dot underscore underscore side multiplied by itself so self dot underscore underscore side and let's say for now I will remove this abstract decorator from the parameter method and let's run the code once again and you can see it runs fine so there is no error when we instantiate this class when we implement all the abstract method into your subclass so right now there is only one abstract method which is area into the shape class which we need to implement in the subclass and that we have done so we see no error here now let's add this decorator abstract method on top of this parameter method also and once again when I run the code it will give me once again this error it's going to give me the same error which says can't instantiate the abstract class square with the abstract method parameter so we also need now to implement this method also let's just implement this parameter method inside the subclass once again and what is the parameter it's four times the size of your square so self dot underscore underscore size and now we have implemented both of them and once again when we run the code it runs fine let's also try to print the area and perimeter of the square so I'm going to just use this object to call the area method and in the next line I'm going to just use print to once again call this object and this time I will call the parameter method and let's run the code once again and it prints the area of the square and the perimeter of this square so let's rewind what we have learned till now so in Python you can define an abstract class by importing this module and this abstract method and this ABC stands for abstract base classes and you need to inherit from this ABC into the class which you want to make abstract the second thing which you need to do is you need to provide this decorator at the rate abstract method on top of at least one of the methods inside your abstract class that makes your class abstract and what are the properties of the abstract class you cannot instantiate an abstract class so you cannot create an object of this abstract class and you need to implement all the abstract method into the sub class which is inheriting the abstract class so this abstract class acts like just a template for other classes which wants to inherit from this shape class so this is how you can use abstract classes in Python I hope you have enjoyed this video and I will see you in the next video
