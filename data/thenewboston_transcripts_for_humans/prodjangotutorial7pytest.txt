With timestamps:

00:00 - all right everybody welcome back and in
00:03 - this video we are going to be talking
00:04 - about Pi test now in the future videos
00:08 - we're actually going to be setting up a
00:09 - CI CD pipeline however before we do that
00:12 - I did want to cover Pi test because
00:14 - whenever we set that up what we want to
00:16 - do is we want to make sure we have a
00:18 - proper test Suite to make sure
00:20 - everything is working before we deploy
00:22 - our application so that's why I decided
00:24 - to make this uh pipe test tutorial now
00:27 - now with that said to get started we're
00:29 - going to need to install some packages
00:31 - and we are going to install of course Pi
00:34 - test itself Pi Test X dist and what this
00:38 - package does is it allows us to um test
00:41 - across multiple cores pretty much just
00:43 - speeds up testing for better performance
00:46 - this Pi test Django package right here
00:49 - this just gives us some useful tools for
00:51 - testing Django apps which we're going to
00:53 - see in a bit and then this last one is
00:55 - actually one on two lines here but model
00:58 - Bakery
00:59 - this last one is for creating realistic
01:01 - Django model instances for testing
01:04 - purposes so let me go ahead and install
01:07 - all of those
01:09 - and that was quick and okay
01:12 - now before we get into typing any real
01:15 - tests or anything what we need to do is
01:17 - just configure this Pi test tool so what
01:20 - we are going to do is go into
01:22 - pipeproject.tomo and you see just like
01:25 - before how we configured some different
01:27 - tools like isort
01:28 - Yap F in
01:31 - let me just paste this in I'm glad uh
01:34 - you guys said that you like this paste
01:36 - method rather than me typing everything
01:38 - out because hey I like it too all right
01:41 - so this is what I just pasted in and
01:44 - what are these configuration settings
01:46 - well some of these are pretty
01:48 - self-explanatory for example for the
01:50 - test paths all of our tests are going to
01:53 - be in cooking core and for the python
01:56 - files that we want to test we're just
01:57 - going to prepend everything
01:59 - the module names with test underscore
02:01 - just to kind of signify which one of our
02:03 - files
02:04 - um yeah need to be tested
02:06 - now this one right here you may want to
02:10 - include this however whenever I run Pi
02:13 - test in addition to like telling me the
02:15 - output of the test like what one's
02:17 - passed what one's failed it also gives
02:18 - me some deprecation warnings and like
02:23 - it it isn't an air or a bug with app
02:25 - it's just like a warning that some of
02:27 - your packages are deprecated or
02:29 - some methods or functions in there it's
02:32 - just kind of annoying so I decided to
02:33 - hide it kind of just like clutters up my
02:36 - console so you can have it if you want
02:37 - but I decided to hide it and then last
02:40 - but not least we have these two right
02:42 - here so by default
02:45 - Pi test Django one of those packages
02:47 - that we just installed it uses the
02:49 - directory containing this manage.py
02:52 - script as the jingle project directory
02:55 - however
02:56 - because we have our settings set up a
02:59 - little bit weird what we want to do is
03:01 - we pretty much want to say hey don't
03:03 - worry about like automatically finding
03:05 - anything we want to explicitly give you
03:08 - a path to the Django settings module so
03:11 - use these two in conjunction even if
03:13 - it's working like it automatically finds
03:16 - the right directory I still like
03:18 - explicitly giving it that path just
03:20 - because I don't know it just feels kind
03:22 - of weird that process is like happening
03:24 - behind the scenes and you don't really
03:26 - see what's going on but anyways this is
03:29 - kind of the configuration for pi test
03:31 - now the next thing that we need to do
03:34 - from here before we start writing any
03:36 - tests is we actually need to create
03:37 - something called fixtures
03:39 - now let me actually go ahead and create
03:42 - one of these and then I'll kind of
03:44 - explain what it is
03:45 - so what I'm going to do is in my
03:47 - accounts app I'm going to go ahead and
03:49 - make a new package called Tess now for
03:52 - all of the tests that we write that's or
03:55 - this is where they are going to live
03:57 - right here however what we are going to
03:59 - do to kind of prepare those tests is we
04:01 - are going to create a new package called
04:05 - fixtures now in here let me go ahead and
04:09 - actually
04:10 - give you some sample data in here I'm
04:13 - just going to create a new python file
04:14 - accounts
04:16 - and I'll paste this in and then talk you
04:19 - through what exactly fixtures are kind
04:21 - of what all this is
04:23 - so in pi test a fixture
04:27 - in each of these right here are fixtures
04:29 - so a fixture is a function that returns
04:33 - some I want to say like a reusable bit
04:36 - of code that can be used in your tests
04:39 - now each of these fixture functions you
04:41 - can see that it's signified by this
04:44 - pytest.fixture decorator now in order to
04:47 - use fixtures in your test what you do is
04:50 - you pretty much just include the
04:52 - function name or the fixture name as a
04:55 - argument or parameter right into your
04:57 - function right here
04:59 - so you can see that what this fixture is
05:02 - doing right here is it's pretty much
05:03 - just making a sample account and this
05:06 - account has this account number and it
05:09 - just has a default balance right here
05:11 - and that's it so whenever we want to use
05:13 - this fixture later on in one of our
05:15 - tests we're pretty much just going to
05:17 - pass in sender account
05:19 - pretty much like this uh sender account
05:21 - number is being passed in and here you
05:23 - can actually see uh something cool
05:25 - that's going on within this fixture
05:27 - it's actually made up of this picture as
05:30 - well so whenever you have an account
05:32 - you of course need an account number and
05:35 - that account number is coming from this
05:37 - fixture and how do you get the account
05:40 - number well you need to make a key pair
05:42 - and a key pair consists of a private key
05:45 - which is kind of like your secret
05:47 - password almost and a public key and so
05:52 - this is kind of the chain right here but
05:53 - it's kind of cool to display so this
05:55 - fixture is being used again Center Key
05:58 - pair in this picture to get the sender
06:00 - account number and the center account
06:02 - number is being used in sender account
06:03 - in that this sender account is pretty
06:06 - much what we're going to use in all our
06:07 - tests so it's kind of a I don't want to
06:10 - say confusing at first but it's a cool
06:12 - way that you can just make a bunch of
06:13 - reusable Snippets of code to use across
06:16 - multiple tests rather than
06:19 - creating the same thing with the same
06:21 - exact data
06:22 - um you know across like 50 tests or
06:24 - whatever
06:24 - now another thing that I want to do just
06:26 - to make these Imports a little bit
06:28 - cleaner whenever we're working with
06:29 - these fixtures is in fixtures in it py
06:33 - I'm just going to import all of the
06:36 - stuff from this file right here now in
06:40 - addition to this fixture right here
06:42 - which is pretty much just a sample
06:44 - account that we're going to be using I
06:46 - also want to create one more fixture
06:48 - because in addition to just like having
06:50 - sample data
06:52 - um it doesn't always have to be data and
06:54 - I'll show you what I mean in just a sec
06:56 - so I'm going to go to General and I'm
06:59 - gonna make again a new test package and
07:03 - in here I'm going to create a new
07:06 - fixtures package I can close out of
07:08 - these actually
07:10 - now in this one what I want to do is I
07:13 - want to make a new python file called
07:15 - clients and I'm going to paste this
07:18 - fixture in right here
07:20 - so what this fixture is is an API client
07:23 - and this is just a class that we can use
07:25 - it's included in the rest framework
07:27 - package just so we can test our rest
07:31 - endpoints test our API so again like I
07:34 - said it doesn't always have to be sample
07:36 - data but it can be like a reusable class
07:38 - or well really any reusable snippet that
07:42 - you want to use across your test and
07:44 - just like before in this in it
07:49 - file I'm gonna just include everything
07:51 - from this file right here
07:54 - and then once I have my fixtures taken
07:57 - care of what I'm going to do now is go
08:01 - ahead and create
08:02 - a new file right in the um cooking core
08:06 - package and I'm going to name this conf
08:10 - ESS and make sure that you name this
08:12 - exactly like this is it stands for
08:14 - configure test or it's a it's basically
08:17 - a configuration file used by pi test
08:20 - and what we can do in here is pi test is
08:24 - pretty much going to pick this up before
08:26 - it starts running the test so it's the
08:28 - perfect place to pretty much um
08:30 - aggregate all your filters or anything
08:32 - that's going to be used across multiple
08:34 - tests and by the way this file like I
08:37 - said it's um like the default for pi
08:39 - test it's automatically discovered by pi
08:41 - test as long as you name it conf test
08:43 - then you don't have to like manually
08:45 - configure it anything else so now that
08:47 - we set this up this way whenever we
08:50 - write our test we can pretty much just
08:52 - use these fixtures pass them into the
08:54 - functions and yeah it's good to go so
08:57 - now let's go ahead and actually write a
09:00 - test so under accounts in test I'm going
09:03 - to make a new
09:04 - test file and remember anytime you write
09:07 - a test file we need to prepend it with
09:10 - the name test underscore anything that
09:12 - we want I'll just name this test rest
09:15 - API since I'm going to be testing some
09:16 - of my endpoints
09:18 - and for this
09:20 - again what I want to do is I want to
09:23 - have my function name test underscore
09:25 - retrieve account as well and you see
09:28 - that the parameters that we're passing
09:31 - in is sender account and yes it does
09:35 - have to be named this because this as
09:37 - you can see was the name of this fixture
09:39 - right here so basically what this
09:42 - reflects
09:43 - is this
09:45 - like dummy account that we just made and
09:48 - what this API client is is if I go back
09:51 - in general
09:53 - then you can see that this is resembling
09:56 - this right here which is just a tool
09:58 - like I said from rest framework that
10:00 - allows us to make requests to our API
10:04 - just like this
10:06 - so whenever we use our client to make a
10:09 - request to this endpoint which is the
10:11 - accounts endpoint for the sender's
10:13 - account what we're expecting to get back
10:15 - is first of all a status code of 200
10:17 - that endpoint should be working and then
10:20 - another thing is that this is the shape
10:22 - of the Json and their account number
10:24 - should match their account number the
10:26 - balance should match their balance which
10:28 - is twenty thousand and then since we
10:31 - didn't have any display imager display
10:33 - name set then those should just be equal
10:36 - to blank so now everything is all pretty
10:39 - much set up so we can actually run our
10:41 - test so how do we run our test well what
10:45 - we could do is we can just go ahead and
10:47 - write a command to start running those
10:49 - however since we are going to be running
10:52 - our test multiple times of course what
10:55 - we want to do is head over to our make
10:57 - file
10:58 - and let's see here St always have to
11:02 - sing the ABC song in my head to figure
11:05 - out the alphabetical order but anyways
11:07 - uh what I just pasted in is this and we
11:11 - are going to be able to run it by just
11:13 - writing make test and it's going to run
11:15 - this Command right here so of course the
11:19 - command to run your test is pi test and
11:21 - what these flags mean we'll kind of
11:23 - break them down one by one so this uh V
11:25 - this just stands for verbose and again
11:28 - this is just a common it's actually a
11:30 - flag used in a lot of different commands
11:32 - just means like more output just so we
11:34 - can kind of see what's going on
11:36 - this RS right here this actually stands
11:39 - for two separate things this R uh stands
11:42 - for report and that is
11:45 - um kind of the it changes the summary
11:48 - report at the end that okay let me take
11:51 - a step back so at the end of your test
11:53 - Pi test is going to show you a summary
11:55 - of like all the tests like this one
11:57 - passed this one failed yada yada
12:00 - now that's what the report is this s
12:02 - means skipped and it can be used along
12:05 - with this R flag right here so when it's
12:08 - used together like this what we're
12:10 - pretty much saying the pi test is show
12:12 - me a summary of all the skip tests at
12:15 - the end now this n Auto what this means
12:20 - is let me pull open my uh Pi Project
12:22 - Tamil
12:24 - so you know how we installed these
12:26 - packages at the very beginning and one
12:28 - of the packages was this Pi Test X dist
12:31 - and I said that it allows you to
12:34 - um pretty much run these tests
12:38 - across multiple cores it doesn't really
12:40 - make sense since we only have um one
12:43 - test right now however later on I mean
12:45 - in a large project you're going to have
12:47 - like a hundred or thousands of tests and
12:50 - that's when it's really useful to speed
12:51 - up your test Suite by splitting them up
12:54 - to run across uh multiple different
12:56 - cores in parallel but for right now with
12:58 - this n Auto is is it's pretty much the
13:02 - option from that plug-in to say
13:05 - um run these across as as many chords as
13:08 - we have again it doesn't really make
13:09 - sense right now but it will in the
13:11 - future so might as well include it now
13:13 - now this last one show capture equals no
13:17 - so by default if your test produces any
13:21 - output like print statements or logging
13:24 - or anything like that then what's going
13:25 - to happen is pi test is going to capture
13:27 - that output and show it in the event
13:30 - that that test fails now here we're
13:33 - saying not to show that output and it's
13:37 - useful in the case that your test
13:39 - produces like a ton of output and that
13:43 - output isn't very relevant to
13:45 - understanding why your test is failing
13:47 - so again this is optional I don't know
13:49 - if it's beneficial to you or if it's
13:53 - like detrimental but anyways this is
13:55 - what this is you can you guys can
13:57 - include in your projects or not but this
13:59 - is how I have my test set up by default
14:01 - and by the way if you find yourself like
14:04 - testing using make test which we can
14:08 - actually do right now just run make test
14:12 - yes see it's uh preparing all of my
14:15 - workers
14:16 - figuring out how many cores I have and
14:18 - then just running uh one test which pass
14:20 - by the way which is pretty cool but
14:22 - either way what I wanted to say is that
14:24 - if you find yourself like running the
14:27 - test in this kind of way and you like
14:29 - this setup however you go back and
14:31 - you're like okay let me tweak this and
14:33 - oh something was failing so let me like
14:35 - change one of these what you can
14:36 - actually do is just like make a couple
14:37 - commands say make tests and you know you
14:41 - can call this one like test detailed or
14:43 - something like that and that way you
14:45 - don't have to like explicitly change
14:47 - these and um of course you would want to
14:49 - tag this but either way
14:51 - it's kind of uh getting ahead of myself
14:53 - just saying that
14:55 - um if you find yourself like editing
14:57 - this often just go ahead and make
14:59 - another uh make Command all right so we
15:02 - got Pi test set up everything is looking
15:04 - pretty good however what we want to do
15:07 - to kind of prepare for some more
15:09 - intricate tests in the future and also
15:12 - just kind of good practice is whenever
15:16 - we run our test Suite we want to create
15:18 - our own custom settings file right here
15:21 - and this is just going to ensure that we
15:24 - have a consistent environment with all
15:26 - the consistent settings every single
15:28 - time that we run our test Suite so in
15:32 - order to do that what I want to do is if
15:36 - I go in cooking core and projects and
15:39 - settings and templates again this was my
15:42 - template for my Dev settings I'm also
15:44 - going to create a new one right here and
15:47 - this is a python file and I'm just gonna
15:49 - pretty much follow the same naming
15:51 - convention settings but instead of Dev
15:54 - I'm just going to write unit test
15:59 - make sure I spell the right unit test.py
16:02 - and in here I'm just going to paste in
16:05 - this
16:06 - so this looks pretty similar to our Dev
16:09 - settings right here however you see one
16:11 - difference is the secret key which I'll
16:13 - explain what we're going to do about
16:15 - that in a second
16:16 - but either way we are going to be
16:18 - populating this with some more stuff
16:20 - later on but the point is what we want
16:23 - to do is whenever we run Pi test we want
16:25 - to make sure that it picks up this file
16:28 - and that way whenever we're running it
16:30 - like I said it just gives a consistent
16:32 - environment to run each time
16:34 - so with that said what I'm going to do
16:38 - since this file is right now in uh well
16:41 - you can see right here cooking core
16:42 - project settings templates this we want
16:45 - to get this file over to our local
16:46 - directory and not only do we want to do
16:49 - it now which we can do with
16:52 - this command pretty much copy this file
16:56 - from wherever it is now to our local
17:00 - directory right here so let me just run
17:02 - this
17:03 - and when I do
17:05 - you can see that is now in local but I
17:08 - also want pretty much any developer
17:10 - working on this project to do that same
17:13 - thing whenever they're like just um you
17:15 - know getting their environment started
17:17 - so in that case I'm just going to add it
17:19 - to the readme right here
17:21 - so as part of the project setup not only
17:24 - do we want you to copy those local
17:27 - development settings which is just
17:29 - whenever you're developing also these
17:31 - unit test settings over here as well
17:35 - so now that we have those settings
17:37 - copied over what we pretty much want to
17:40 - say to Pi test or to our Django
17:43 - application is that whenever you are
17:45 - running in pi test mode then we want to
17:48 - pick up these settings so in order to do
17:51 - that we first need a function to detect
17:53 - if we are running in pi test mode
17:56 - so for this I'm going to go in cooking
17:58 - core in general
18:00 - and I'll put it in utils I'm going to
18:03 - create a new file called Pi test
18:06 - and in here I'm going to paste this
18:09 - right here
18:11 - expand this so you guys can see so this
18:13 - is a function that we're going to use
18:14 - and what this does is it pretty much
18:17 - says that if we have an environment
18:19 - variable set explicitly that says Pi
18:21 - test running
18:23 - and of course the value for this is
18:25 - going to be true or if the pretty much
18:30 - we're running a command in the first
18:31 - argument is one of these then that means
18:34 - that we are running this application in
18:38 - pi test mode or Pi test whatever you
18:40 - want to call it now because we have this
18:42 - logic right here what we actually need
18:44 - to do is we need to create an
18:45 - environment variable called Pi test
18:47 - running and set it equal to true and
18:50 - where do we do that well we do it in
18:53 - this file right here because remember
18:54 - this is our PI test configuration file
18:57 - it pretty much gets loaded in right
19:00 - before Pi test starts running the actual
19:02 - test
19:03 - so I'm just gonna import OS
19:06 - and this is going to set a temporary
19:09 - environment variable
19:11 - um pretty much through the duration of
19:13 - Pi Test's Pi tests execution so we're
19:18 - going to set this this function is going
19:20 - to be equal to true but the last thing
19:22 - that we need to do now is we need to use
19:25 - this function to say whenever this is
19:27 - true update our local settings path so
19:31 - it uses
19:32 - this instead of development or
19:34 - production or anything else and where do
19:37 - we do that well if you go to cooking
19:39 - core projects
19:41 - are in it settings right here
19:44 - then what we can do is first of all
19:46 - import
19:48 - that function and again that was in
19:50 - cooking core General utils Pi test and
19:53 - instead of this local settings pass what
19:56 - we can do is we can just update this
19:59 - logic right here where we can say that
20:02 - if Pi test running equals true then what
20:06 - we want to do is we want to use this
20:08 - unit test
20:11 - setting right here instead of Dev now of
20:15 - course whenever we are just in local
20:17 - development mode then this is not going
20:19 - to be true so then it's just going to
20:21 - pick up our Dev settings as usual now
20:24 - one other thing actually a couple other
20:26 - things that I want to do is I want to
20:28 - add this snippet right here now again
20:32 - this says if not if Pi test is not
20:35 - running then make sure the secret key is
20:38 - not implemented and there's a lot of
20:40 - like uh double negative statements in
20:43 - here but what this means in kind of
20:45 - layman's term is that unless Pi test is
20:48 - running there should be a secret key set
20:51 - because of course in normal mode whether
20:54 - it's um production or local development
20:57 - of course in Django you need the secret
20:59 - key for a lot of different things
21:01 - however check this out why is it that in
21:04 - pi test we kind of want to make sure
21:07 - that it's not implemented at this point
21:09 - right here because even in pi tests I'm
21:12 - sure we need Django secret key so like a
21:14 - lot of things don't break
21:16 - well the reason that in pi test we want
21:19 - to make sure that a secret key hasn't
21:20 - already been set and by the way the
21:23 - reason that I want to do this one of
21:24 - them
21:25 - is because
21:26 - if I am in pi test mode and just run out
21:30 - a bunch of tests and a secret key is set
21:31 - at this point that means that like I
21:34 - messed something up I'm either running
21:35 - in my development settings or God forbid
21:38 - I'm running my production settings and
21:40 - whenever you are running in production
21:42 - mode you definitely don't want to be
21:44 - running a bunch of automated tests and
21:45 - just like hitting your production
21:47 - database so on and so forth so this
21:49 - gives you some protection against that
21:51 - however because we still need a secret
21:54 - key
21:55 - um even in testing our PI test
21:58 - environment how do we handle this
22:00 - we'll check this out what I'm gonna do
22:04 - is I'm going to create one more fixture
22:06 - file and this is actually what we have
22:09 - uh two more things to do before we're
22:11 - done with this tutorial we are going to
22:13 - go to General test and remember where
22:16 - this fixture was right here this client
22:18 - right
22:20 - actually let me close this uh let me
22:23 - close all these all right so right
22:25 - alongside this we are going to create
22:27 - one more fixture file and we're just
22:30 - going to name it uh miscellaneous
22:32 - and in here I am going to paste this
22:36 - fixture right here so what is this doing
22:38 - well this fixture is it's kind of
22:41 - special in a way that it's used
22:44 - differently than the other fixtures and
22:46 - that is because we are using whenever we
22:49 - Define this fixture in this decorator
22:50 - right here we are using this Auto use
22:53 - equals true parameter
22:55 - now what this means is that this fixture
22:59 - is automatically going to be picked up
23:01 - every single test run without needing to
23:04 - explicitly include it as a parameter in
23:06 - those other functions
23:08 - so again this is always going to be used
23:11 - um across all tests so what exactly is
23:14 - this doing well what we are doing right
23:17 - here is we are using this built-in
23:20 - override settings context and this is a
23:23 - part of Django's test Suite and we are
23:26 - pretty much saying that within this
23:29 - context what we want to do is we want to
23:32 - provide an explicit secret key and this
23:36 - is just a way that you can pretty much
23:38 - within your testing you can have like
23:42 - standard uh Django settings applied to
23:45 - every single test and again this is
23:47 - useful to ensure that we have a
23:49 - consistent environment across all of our
23:51 - tests without having to modify our
23:54 - actual settings file or use any like
23:57 - settings keys from development or
23:59 - production or anything like that
24:01 - so that's what this context is in this
24:04 - yield keyword right here this keyword
24:06 - marks the point where Pi test is
24:08 - actually going to be running the test so
24:11 - if you can imagine
24:12 - that these tests let me just actually
24:15 - kind of show you what's going on so if
24:18 - you can kind of imagine that this yield
24:20 - keyword is going to be replaced with
24:23 - this test right here
24:24 - it's pretty much saying with these
24:26 - temporary settings apply it whenever you
24:29 - run the test
24:30 - however just the pi test syntax you use
24:33 - yield kind of in place of where your
24:36 - tests are going to be ran
24:38 - so actually the last thing that we need
24:40 - to do to pick up these settings is just
24:42 - make sure that
24:46 - everything from this file right here
24:50 - is just imported
24:53 - in our fixtures.init and we don't need
24:57 - to do anything else because in our test
24:59 - configuration
25:01 - we are already pulling everything in
25:04 - from this file which is General test
25:07 - fixtures and again we already did this
25:09 - before
25:10 - so now in all of our tests even though
25:14 - it didn't really matter for that one
25:15 - test but in all of our tests and we can
25:17 - run this again
25:19 - just to make sure nothing breaks we now
25:22 - have our consistent unique
25:25 - um like temporary secret key set and
25:28 - later on just kind of a heads up we're
25:30 - actually going to be adding more
25:32 - settings in here but yeah for now this
25:35 - is the basic structure of how you can
25:37 - set up Pi test and uh a lot to it but
25:40 - the cool thing is from here on out we
25:43 - pretty much just have to add more tests
25:44 - and everything else is going to be
25:46 - configured more or less
25:48 - So yeah thank you for watching and
25:51 - um in the upcoming videos what we'll do
25:53 - is now that we have some tests that we
25:56 - can kind of make sure that our
25:57 - application is working as expected I
26:00 - think we're ready to move on to some of
26:02 - the CI CD so looking forward to that and
26:04 - I'll see you next time

Cleaned transcript:

all right everybody welcome back and in this video we are going to be talking about Pi test now in the future videos we're actually going to be setting up a CI CD pipeline however before we do that I did want to cover Pi test because whenever we set that up what we want to do is we want to make sure we have a proper test Suite to make sure everything is working before we deploy our application so that's why I decided to make this uh pipe test tutorial now now with that said to get started we're going to need to install some packages and we are going to install of course Pi test itself Pi Test X dist and what this package does is it allows us to um test across multiple cores pretty much just speeds up testing for better performance this Pi test Django package right here this just gives us some useful tools for testing Django apps which we're going to see in a bit and then this last one is actually one on two lines here but model Bakery this last one is for creating realistic Django model instances for testing purposes so let me go ahead and install all of those and that was quick and okay now before we get into typing any real tests or anything what we need to do is just configure this Pi test tool so what we are going to do is go into pipeproject.tomo and you see just like before how we configured some different tools like isort Yap F in let me just paste this in I'm glad uh you guys said that you like this paste method rather than me typing everything out because hey I like it too all right so this is what I just pasted in and what are these configuration settings well some of these are pretty selfexplanatory for example for the test paths all of our tests are going to be in cooking core and for the python files that we want to test we're just going to prepend everything the module names with test underscore just to kind of signify which one of our files um yeah need to be tested now this one right here you may want to include this however whenever I run Pi test in addition to like telling me the output of the test like what one's passed what one's failed it also gives me some deprecation warnings and like it it isn't an air or a bug with app it's just like a warning that some of your packages are deprecated or some methods or functions in there it's just kind of annoying so I decided to hide it kind of just like clutters up my console so you can have it if you want but I decided to hide it and then last but not least we have these two right here so by default Pi test Django one of those packages that we just installed it uses the directory containing this manage.py script as the jingle project directory however because we have our settings set up a little bit weird what we want to do is we pretty much want to say hey don't worry about like automatically finding anything we want to explicitly give you a path to the Django settings module so use these two in conjunction even if it's working like it automatically finds the right directory I still like explicitly giving it that path just because I don't know it just feels kind of weird that process is like happening behind the scenes and you don't really see what's going on but anyways this is kind of the configuration for pi test now the next thing that we need to do from here before we start writing any tests is we actually need to create something called fixtures now let me actually go ahead and create one of these and then I'll kind of explain what it is so what I'm going to do is in my accounts app I'm going to go ahead and make a new package called Tess now for all of the tests that we write that's or this is where they are going to live right here however what we are going to do to kind of prepare those tests is we are going to create a new package called fixtures now in here let me go ahead and actually give you some sample data in here I'm just going to create a new python file accounts and I'll paste this in and then talk you through what exactly fixtures are kind of what all this is so in pi test a fixture in each of these right here are fixtures so a fixture is a function that returns some I want to say like a reusable bit of code that can be used in your tests now each of these fixture functions you can see that it's signified by this pytest.fixture decorator now in order to use fixtures in your test what you do is you pretty much just include the function name or the fixture name as a argument or parameter right into your function right here so you can see that what this fixture is doing right here is it's pretty much just making a sample account and this account has this account number and it just has a default balance right here and that's it so whenever we want to use this fixture later on in one of our tests we're pretty much just going to pass in sender account pretty much like this uh sender account number is being passed in and here you can actually see uh something cool that's going on within this fixture it's actually made up of this picture as well so whenever you have an account you of course need an account number and that account number is coming from this fixture and how do you get the account number well you need to make a key pair and a key pair consists of a private key which is kind of like your secret password almost and a public key and so this is kind of the chain right here but it's kind of cool to display so this fixture is being used again Center Key pair in this picture to get the sender account number and the center account number is being used in sender account in that this sender account is pretty much what we're going to use in all our tests so it's kind of a I don't want to say confusing at first but it's a cool way that you can just make a bunch of reusable Snippets of code to use across multiple tests rather than creating the same thing with the same exact data um you know across like 50 tests or whatever now another thing that I want to do just to make these Imports a little bit cleaner whenever we're working with these fixtures is in fixtures in it py I'm just going to import all of the stuff from this file right here now in addition to this fixture right here which is pretty much just a sample account that we're going to be using I also want to create one more fixture because in addition to just like having sample data um it doesn't always have to be data and I'll show you what I mean in just a sec so I'm going to go to General and I'm gonna make again a new test package and in here I'm going to create a new fixtures package I can close out of these actually now in this one what I want to do is I want to make a new python file called clients and I'm going to paste this fixture in right here so what this fixture is is an API client and this is just a class that we can use it's included in the rest framework package just so we can test our rest endpoints test our API so again like I said it doesn't always have to be sample data but it can be like a reusable class or well really any reusable snippet that you want to use across your test and just like before in this in it file I'm gonna just include everything from this file right here and then once I have my fixtures taken care of what I'm going to do now is go ahead and create a new file right in the um cooking core package and I'm going to name this conf ESS and make sure that you name this exactly like this is it stands for configure test or it's a it's basically a configuration file used by pi test and what we can do in here is pi test is pretty much going to pick this up before it starts running the test so it's the perfect place to pretty much um aggregate all your filters or anything that's going to be used across multiple tests and by the way this file like I said it's um like the default for pi test it's automatically discovered by pi test as long as you name it conf test then you don't have to like manually configure it anything else so now that we set this up this way whenever we write our test we can pretty much just use these fixtures pass them into the functions and yeah it's good to go so now let's go ahead and actually write a test so under accounts in test I'm going to make a new test file and remember anytime you write a test file we need to prepend it with the name test underscore anything that we want I'll just name this test rest API since I'm going to be testing some of my endpoints and for this again what I want to do is I want to have my function name test underscore retrieve account as well and you see that the parameters that we're passing in is sender account and yes it does have to be named this because this as you can see was the name of this fixture right here so basically what this reflects is this like dummy account that we just made and what this API client is is if I go back in general then you can see that this is resembling this right here which is just a tool like I said from rest framework that allows us to make requests to our API just like this so whenever we use our client to make a request to this endpoint which is the accounts endpoint for the sender's account what we're expecting to get back is first of all a status code of 200 that endpoint should be working and then another thing is that this is the shape of the Json and their account number should match their account number the balance should match their balance which is twenty thousand and then since we didn't have any display imager display name set then those should just be equal to blank so now everything is all pretty much set up so we can actually run our test so how do we run our test well what we could do is we can just go ahead and write a command to start running those however since we are going to be running our test multiple times of course what we want to do is head over to our make file and let's see here St always have to sing the ABC song in my head to figure out the alphabetical order but anyways uh what I just pasted in is this and we are going to be able to run it by just writing make test and it's going to run this Command right here so of course the command to run your test is pi test and what these flags mean we'll kind of break them down one by one so this uh V this just stands for verbose and again this is just a common it's actually a flag used in a lot of different commands just means like more output just so we can kind of see what's going on this RS right here this actually stands for two separate things this R uh stands for report and that is um kind of the it changes the summary report at the end that okay let me take a step back so at the end of your test Pi test is going to show you a summary of like all the tests like this one passed this one failed yada yada now that's what the report is this s means skipped and it can be used along with this R flag right here so when it's used together like this what we're pretty much saying the pi test is show me a summary of all the skip tests at the end now this n Auto what this means is let me pull open my uh Pi Project Tamil so you know how we installed these packages at the very beginning and one of the packages was this Pi Test X dist and I said that it allows you to um pretty much run these tests across multiple cores it doesn't really make sense since we only have um one test right now however later on I mean in a large project you're going to have like a hundred or thousands of tests and that's when it's really useful to speed up your test Suite by splitting them up to run across uh multiple different cores in parallel but for right now with this n Auto is is it's pretty much the option from that plugin to say um run these across as as many chords as we have again it doesn't really make sense right now but it will in the future so might as well include it now now this last one show capture equals no so by default if your test produces any output like print statements or logging or anything like that then what's going to happen is pi test is going to capture that output and show it in the event that that test fails now here we're saying not to show that output and it's useful in the case that your test produces like a ton of output and that output isn't very relevant to understanding why your test is failing so again this is optional I don't know if it's beneficial to you or if it's like detrimental but anyways this is what this is you can you guys can include in your projects or not but this is how I have my test set up by default and by the way if you find yourself like testing using make test which we can actually do right now just run make test yes see it's uh preparing all of my workers figuring out how many cores I have and then just running uh one test which pass by the way which is pretty cool but either way what I wanted to say is that if you find yourself like running the test in this kind of way and you like this setup however you go back and you're like okay let me tweak this and oh something was failing so let me like change one of these what you can actually do is just like make a couple commands say make tests and you know you can call this one like test detailed or something like that and that way you don't have to like explicitly change these and um of course you would want to tag this but either way it's kind of uh getting ahead of myself just saying that um if you find yourself like editing this often just go ahead and make another uh make Command all right so we got Pi test set up everything is looking pretty good however what we want to do to kind of prepare for some more intricate tests in the future and also just kind of good practice is whenever we run our test Suite we want to create our own custom settings file right here and this is just going to ensure that we have a consistent environment with all the consistent settings every single time that we run our test Suite so in order to do that what I want to do is if I go in cooking core and projects and settings and templates again this was my template for my Dev settings I'm also going to create a new one right here and this is a python file and I'm just gonna pretty much follow the same naming convention settings but instead of Dev I'm just going to write unit test make sure I spell the right unit test.py and in here I'm just going to paste in this so this looks pretty similar to our Dev settings right here however you see one difference is the secret key which I'll explain what we're going to do about that in a second but either way we are going to be populating this with some more stuff later on but the point is what we want to do is whenever we run Pi test we want to make sure that it picks up this file and that way whenever we're running it like I said it just gives a consistent environment to run each time so with that said what I'm going to do since this file is right now in uh well you can see right here cooking core project settings templates this we want to get this file over to our local directory and not only do we want to do it now which we can do with this command pretty much copy this file from wherever it is now to our local directory right here so let me just run this and when I do you can see that is now in local but I also want pretty much any developer working on this project to do that same thing whenever they're like just um you know getting their environment started so in that case I'm just going to add it to the readme right here so as part of the project setup not only do we want you to copy those local development settings which is just whenever you're developing also these unit test settings over here as well so now that we have those settings copied over what we pretty much want to say to Pi test or to our Django application is that whenever you are running in pi test mode then we want to pick up these settings so in order to do that we first need a function to detect if we are running in pi test mode so for this I'm going to go in cooking core in general and I'll put it in utils I'm going to create a new file called Pi test and in here I'm going to paste this right here expand this so you guys can see so this is a function that we're going to use and what this does is it pretty much says that if we have an environment variable set explicitly that says Pi test running and of course the value for this is going to be true or if the pretty much we're running a command in the first argument is one of these then that means that we are running this application in pi test mode or Pi test whatever you want to call it now because we have this logic right here what we actually need to do is we need to create an environment variable called Pi test running and set it equal to true and where do we do that well we do it in this file right here because remember this is our PI test configuration file it pretty much gets loaded in right before Pi test starts running the actual test so I'm just gonna import OS and this is going to set a temporary environment variable um pretty much through the duration of Pi Test's Pi tests execution so we're going to set this this function is going to be equal to true but the last thing that we need to do now is we need to use this function to say whenever this is true update our local settings path so it uses this instead of development or production or anything else and where do we do that well if you go to cooking core projects are in it settings right here then what we can do is first of all import that function and again that was in cooking core General utils Pi test and instead of this local settings pass what we can do is we can just update this logic right here where we can say that if Pi test running equals true then what we want to do is we want to use this unit test setting right here instead of Dev now of course whenever we are just in local development mode then this is not going to be true so then it's just going to pick up our Dev settings as usual now one other thing actually a couple other things that I want to do is I want to add this snippet right here now again this says if not if Pi test is not running then make sure the secret key is not implemented and there's a lot of like uh double negative statements in here but what this means in kind of layman's term is that unless Pi test is running there should be a secret key set because of course in normal mode whether it's um production or local development of course in Django you need the secret key for a lot of different things however check this out why is it that in pi test we kind of want to make sure that it's not implemented at this point right here because even in pi tests I'm sure we need Django secret key so like a lot of things don't break well the reason that in pi test we want to make sure that a secret key hasn't already been set and by the way the reason that I want to do this one of them is because if I am in pi test mode and just run out a bunch of tests and a secret key is set at this point that means that like I messed something up I'm either running in my development settings or God forbid I'm running my production settings and whenever you are running in production mode you definitely don't want to be running a bunch of automated tests and just like hitting your production database so on and so forth so this gives you some protection against that however because we still need a secret key um even in testing our PI test environment how do we handle this we'll check this out what I'm gonna do is I'm going to create one more fixture file and this is actually what we have uh two more things to do before we're done with this tutorial we are going to go to General test and remember where this fixture was right here this client right actually let me close this uh let me close all these all right so right alongside this we are going to create one more fixture file and we're just going to name it uh miscellaneous and in here I am going to paste this fixture right here so what is this doing well this fixture is it's kind of special in a way that it's used differently than the other fixtures and that is because we are using whenever we Define this fixture in this decorator right here we are using this Auto use equals true parameter now what this means is that this fixture is automatically going to be picked up every single test run without needing to explicitly include it as a parameter in those other functions so again this is always going to be used um across all tests so what exactly is this doing well what we are doing right here is we are using this builtin override settings context and this is a part of Django's test Suite and we are pretty much saying that within this context what we want to do is we want to provide an explicit secret key and this is just a way that you can pretty much within your testing you can have like standard uh Django settings applied to every single test and again this is useful to ensure that we have a consistent environment across all of our tests without having to modify our actual settings file or use any like settings keys from development or production or anything like that so that's what this context is in this yield keyword right here this keyword marks the point where Pi test is actually going to be running the test so if you can imagine that these tests let me just actually kind of show you what's going on so if you can kind of imagine that this yield keyword is going to be replaced with this test right here it's pretty much saying with these temporary settings apply it whenever you run the test however just the pi test syntax you use yield kind of in place of where your tests are going to be ran so actually the last thing that we need to do to pick up these settings is just make sure that everything from this file right here is just imported in our fixtures.init and we don't need to do anything else because in our test configuration we are already pulling everything in from this file which is General test fixtures and again we already did this before so now in all of our tests even though it didn't really matter for that one test but in all of our tests and we can run this again just to make sure nothing breaks we now have our consistent unique um like temporary secret key set and later on just kind of a heads up we're actually going to be adding more settings in here but yeah for now this is the basic structure of how you can set up Pi test and uh a lot to it but the cool thing is from here on out we pretty much just have to add more tests and everything else is going to be configured more or less So yeah thank you for watching and um in the upcoming videos what we'll do is now that we have some tests that we can kind of make sure that our application is working as expected I think we're ready to move on to some of the CI CD so looking forward to that and I'll see you next time
