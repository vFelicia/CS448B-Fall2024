With timestamps:

00:00 - alrighty i'll welcome back to another
00:02 - video and in this one we are going to be
00:04 - covering remix
00:05 - so
00:06 - to see this tool go to
00:08 - remix.etherium.org
00:11 - and
00:12 - all right so
00:13 - once you go there you're going to be
00:15 - greeted with a screen that looks like
00:16 - this
00:17 - so first of all what is remix so remix
00:20 - is an in-browser ide for writing smart
00:22 - contracts so if you just want to jump
00:24 - into writing smart contracts play around
00:27 - with some things but you don't want to
00:28 - download and install some you know beefy
00:31 - bulky piece of software then this is the
00:33 - tool that you can use
00:34 - now with that said i'm not going to
00:36 - recommend this tool for developing
00:38 - production grade dapps this is more you
00:40 - can think of it almost like a playground
00:43 - it's a useful tool whenever you're
00:44 - working on simple smart contracts or
00:46 - smaller projects
00:48 - but like i said probably wouldn't want
00:50 - to stick with it for production grade
00:51 - apps for that type of environment we're
00:54 - actually going to be getting into that
00:55 - in the next video but for now i just
00:57 - wanted to go over this tool it's a very
00:59 - handy tool so let's go ahead and jump
01:01 - right into it
01:02 - now on the left right here you're going
01:04 - to notice workspaces
01:06 - now you can think of a workspace
01:08 - essentially as a project in remix
01:11 - so actually we can go ahead and create a
01:13 - new workspace now
01:14 - and whenever we do we can see that it
01:17 - pops up right here
01:18 - is the new item in the menu and this
01:20 - menu right here is just how you switch
01:22 - between your workspaces pretty simple
01:25 - so a new workspace is going to come with
01:28 - a very basic project structure and that
01:30 - includes your contracts directory and
01:33 - inside here are your solidity contracts
01:35 - and we're going to be writing one of
01:36 - these in just a few minutes
01:38 - under that you have your scripts these
01:41 - are your javascript files and then under
01:43 - that you have your tests and this test
01:45 - right here is testing one of the
01:47 - solidity contracts and last but not
01:49 - least you have a readme which is
01:51 - essentially just a readme overview
01:53 - description for the project
01:55 - now in order to best understand these
01:58 - other sections of this ide is probably
02:00 - useful if we do have a simple solidity
02:02 - contract so let's go ahead and create
02:04 - one right now
02:05 - so to create one if you just click on
02:07 - this contracts directory and you right
02:09 - click you can click new file and i'm
02:12 - just going to name this bucky
02:14 - dot s-o-l
02:16 - and the name doesn't really matter well
02:18 - it does in a lot of cases but for this
02:19 - example it doesn't really matter sol
02:22 - just means that it's a solidity file in
02:24 - other words uh smart contract you can
02:26 - think of it like that
02:28 - and all right let me actually boost this
02:31 - up so you can see
02:32 - and if you click this button on the left
02:34 - you can actually just toggle this left
02:36 - menu alright so we are finally ready to
02:38 - start writing our first smart contract
02:40 - where do we begin
02:42 - so the very first line in your smart
02:43 - contract actually let me ask
02:47 - do you hear that noise it's like marbles
02:50 - running down my wall
02:53 - that's a weird noise anyways uh okay
02:56 - spdx and then you want
02:59 - license
03:02 - identifier
03:04 - mit okay
03:06 - so the first line here is actually a
03:08 - comment it's spdx license identifier mit
03:10 - what does this mean this is just an open
03:13 - standard stating that this source code
03:15 - is mit licensed and this is actually
03:17 - recommended to include in all of your
03:19 - solidity files
03:21 - and right under this let's go ahead
03:24 - and write pragma
03:27 - solidity
03:30 - 0.8
03:32 - okay so what is pragma solidity greater
03:34 - or equal to 0.8.7 mean
03:37 - so this is just indicating what version
03:40 - of solidity we're using
03:42 - and by that i mean
03:43 - the
03:44 - solidity language and not only the
03:46 - language itself but the related compiler
03:48 - to compile this source code down into
03:51 - bytecode
03:52 - changes over time and that's just
03:54 - because well really with any programming
03:56 - language as new features are introduced
03:58 - and you know maybe syntax changes that
04:00 - the language naturally changes so this
04:03 - is really just saying that we're going
04:05 - to be using this version of solidity so
04:07 - we need to make sure when we compile
04:09 - this down that the compiler supports
04:11 - this version of solidity as well
04:13 - so now let's hop into the good stuff and
04:15 - that is actually writing our contract
04:18 - so to begin a smart contract
04:20 - you begin with a name contract and then
04:22 - you can actually name it really anything
04:24 - you want some limitations of course uh
04:27 - no weird characters or anything like
04:28 - that
04:29 - but the name of course should be
04:31 - descriptive of what the contract is
04:34 - and
04:35 - just as a quick overview in terms of uh
04:38 - kind of porting this over to some
04:39 - programming concepts when you think of a
04:41 - contract in solidity you can think of it
04:43 - similar to a class in an object-oriented
04:46 - language
04:47 - so this contract similar to a class is
04:50 - going to contain variables and functions
04:52 - so on and so forth now whenever we
04:54 - deploy this contract to the network what
04:56 - you can think of that process as is
04:58 - creating an instance of this class
05:01 - so essentially we are going to be
05:03 - creating an instance of bucky and
05:06 - pushing it up to the ethereum network
05:07 - and that is essentially going to be our
05:09 - smart contract
05:10 - so if all that's a little hazy don't
05:12 - worry about it right now it's going to
05:13 - make sense whenever we actually deploy
05:15 - it and interact with it a few times it's
05:17 - going to click pretty clearly what's
05:19 - going on so now let's go ahead and talk
05:21 - about what the smart contract is going
05:23 - to do so we just want to stick with the
05:25 - bare bones simple example so we'll just
05:28 - say that there's going to be one
05:29 - variable in here and that's called age
05:31 - and the only real thing that this smart
05:34 - contract is going to do is it's going to
05:35 - store my age on the ethereum network i'm
05:39 - i'm not sure why anyone would ever use
05:41 - the smart contract but uh that's what
05:44 - it's going to do
05:45 - so
05:46 - the first thing that we need is to
05:47 - create a variable to actually store that
05:49 - value so there are different data types
05:51 - i actually have a link right here let me
05:53 - pop it up so there are different data
05:55 - types that you can use in solidity we're
05:57 - going to be kind of tackling these one
05:58 - by one but a lot of them are pretty
06:01 - simple booleans integers
06:03 - uh we are going to be using a u-int
06:06 - which is pretty much just an unassigned
06:08 - integer or non-negative integer
06:10 - however there are some unique data types
06:13 - as well so not just you know your ins
06:15 - your strings so on and so forth but
06:18 - this is a unique one where it's address
06:20 - and of course this is made to store an
06:23 - ethereum address and we're not going to
06:25 - be going over all of these i just want
06:27 - to point out that if you do want to see
06:29 - the different data types then you can
06:30 - type in solidity data types and
06:32 - something like this is going to pop up
06:34 - so that said let's go ahead and create a
06:36 - variable for my age and again we're
06:38 - going to be using a u int
06:41 - and that means a non-negative integer
06:43 - because i can't have a negative h and
06:45 - we're just going to call it h
06:46 - so end it with a semicolon and again
06:49 - whenever you're defining a variable you
06:51 - put the data type and then the variable
06:53 - name ended with the semicolon
06:55 - all right so we have a variable we have
06:58 - the ability to store my age in the smart
07:00 - contract so now we actually have to
07:02 - write a function to set my age
07:06 - so let me just go ahead and write this
07:07 - and then we'll kind of talk through what
07:09 - it's doing so you're going to call
07:11 - function
07:12 - i'll just call this set age
07:14 - and we're going to be passing in a uint
07:16 - just call it x
07:18 - and then i'll say public
07:21 - and age is equal to x
07:24 - all right so we'll get into this syntax
07:27 - in just a second but just to talk about
07:29 - this logic real quick all this function
07:31 - is doing
07:32 - is we're saying whenever we want to set
07:34 - the age of bucky
07:36 - then what we're going to do is we're
07:38 - going to pass in a value
07:39 - and then we're going to take that value
07:41 - and set it equal to the age variable
07:44 - okay so some things to point out here is
07:46 - one whenever we are
07:49 - passing in arguments to our function
07:51 - then we also need to specify the type of
07:54 - data that we are expecting so this is
07:56 - similar to right here
07:58 - um pretty much whenever you see a
08:00 - variable for the first time it's gonna
08:01 - need the data type right before it
08:03 - now another thing that's interesting
08:06 - about this is this public keyword right
08:08 - here
08:09 - so what does this mean
08:10 - so
08:11 - functions and solidity contracts can
08:14 - have different what is called visibility
08:16 - types
08:17 - now public means that this function it
08:20 - can be called basically by anyone by
08:23 - anyone in the world once this contract
08:25 - is deployed they can call this function
08:27 - um if if we had another function in here
08:30 - which we're going to have in just a bit
08:31 - then that function can call this
08:33 - function as well other contracts can
08:35 - call this function
08:37 - so basically anyone with ethereum
08:39 - account or even other contracts uh this
08:42 - function is callable by you know pretty
08:44 - wide open
08:45 - now
08:46 - there is another keyword and we're not
08:48 - going to be actually using this
08:51 - in this example but just to point out
08:53 - there's another keyword called private
08:56 - and what this is
08:57 - is essentially saying that this function
09:00 - if deemed private it's only callable by
09:03 - other functions in this contract so that
09:06 - means that users couldn't call this
09:09 - function other smart contracts couldn't
09:11 - call it
09:12 - private again it means that this
09:13 - function can be only called from another
09:16 - function within this contract so let me
09:19 - go ahead and revert that back to public
09:21 - and all right so we have a function to
09:24 - set the age of bucky and now before we
09:26 - kind of test this out let me go ahead
09:28 - and create one more function
09:29 - and all this is going to do is it's
09:31 - going to get the age or pretty much
09:34 - return the value
09:36 - of age and that's just because we want
09:38 - to be able to test it out later on make
09:40 - sure that we have the right value set so
09:42 - let's go ahead and do that right now
09:44 - function get
09:45 - age
09:47 - now
09:48 - uh one thing to know is unlike set age
09:51 - where i'm i want to set this variable
09:54 - equal to a new value with the getage
09:57 - we're not going to be passing in any
09:58 - additional information because
10:01 - we're not going to be setting it or
10:02 - updating anything we're basically just
10:04 - going to be reading this age variable to
10:06 - get the value
10:08 - so
10:09 - one thing that we want to add is public
10:12 - because you know this isn't like a
10:14 - private function we don't need to hide
10:16 - anything from anyone else we'll just say
10:18 - that anyone on the entire ethereum
10:20 - network can see my age no problem there
10:22 - now another keyword that i want to
10:24 - introduce is view
10:26 - so what is this view keyword
10:28 - so a function declared as a view means
10:31 - that it doesn't modify any state
10:34 - so
10:35 - for example in this function right here
10:38 - we were taking an age variable and
10:40 - pretty much updating the value of it
10:42 - this would not be a good time to use
10:45 - view in fact this is kind of the
10:47 - opposite of when you should use it
10:49 - because view means the opposite of that
10:51 - that you are not
10:53 - modifying any state or any variables in
10:55 - your contract so view kind of just means
10:57 - uh read only in the last bit of info we
11:00 - need before we can start coding in the
11:02 - function body is this actually let me uh
11:05 - kind of do it the reverse way so what
11:07 - this function is going to do is it's
11:09 - going to return
11:10 - the
11:11 - pretty much the value of age so let's
11:13 - say 20 30 40 whatever it is
11:16 - now whenever you create a function and
11:18 - it does return data you need to specify
11:22 - what type of data is being returned
11:25 - so this returns age which is an unsigned
11:28 - integer
11:29 - so in order to specify that i'm just
11:31 - going to say returns
11:34 - and have a parenthesis there u int
11:38 - all right so just reading this one more
11:40 - we have a function it's called get h
11:43 - it's a public function means pretty much
11:45 - anyone can call it
11:46 - it's read only so it doesn't manipulate
11:49 - any data and it's going to return
11:52 - an unsigned integer
11:54 - and that is h and that is pretty much it
11:57 - again this is a very uh simple contract
12:01 - i don't think it's something that
12:02 - anyone's ever going to use but in terms
12:04 - of just getting something out there
12:05 - quick so we can figure out these other
12:07 - features we remix i think it's looking
12:10 - alright
12:11 - now before we take a look at the
12:13 - compiler let's just go ahead and review
12:15 - why we even need to compile it at all
12:17 - so we are going to be writing source
12:19 - code and we just saw that it was just
12:20 - you know human readable solidity code
12:23 - now these nodes on the network they
12:25 - actually don't run that source code they
12:27 - need to run bytecode ones and zeros so
12:30 - essentially just real quick overview to
12:32 - compile you are taking your source code
12:35 - you are pretty much running it through a
12:37 - compiler and converting it to something
12:38 - called bytecode ones and zeros and then
12:41 - when you deploy your contract or pretty
12:43 - much upload it to the network you're
12:45 - gonna be uploading this bytecode
12:47 - just like that and this is what the
12:49 - nodes are gonna run
12:51 - all right so now let's hop back into
12:53 - remix and take a look at how to do this
12:55 - so on the left menu you see that this
12:57 - right here this is your file explorer
12:59 - pretty much you get to your workspaces
13:01 - now right under here you can see if you
13:04 - hover over it says solidity compiler
13:06 - let's go ahead and click that so the
13:07 - first thing that you need to make sure
13:09 - of is that the compiler version
13:11 - matches this pragma solidity right here
13:15 - pretty much just to make sure that your
13:16 - compiler and your source code are synced
13:18 - up uh they're aware that it's the same
13:20 - version so on and so forth
13:22 - and of course working with solidity a
13:24 - lot of this should be good by default
13:26 - the one thing that i do want to point
13:28 - out is that if you're working on a small
13:30 - project like just a few contracts then
13:33 - it's probably nice to have this auto
13:34 - compile and this just saves you from
13:36 - having to do it manually now i will say
13:38 - that if you're working on a larger
13:40 - project with a lot of the dependencies
13:42 - then it's probably gonna kind of bog
13:44 - down your your browser your resources to
13:47 - have this auto compile feature so
13:50 - typically you want to leave it on but
13:51 - again that's up to your best judgment
13:54 - now
13:55 - i believe that's all we need to set for
13:57 - this so now our code should be auto
13:59 - compiling
14:00 - now after this go ahead and hop down to
14:03 - this section right here so deploy and
14:05 - run transactions
14:07 - and let me zoom out just a bit
14:11 - all right now believe it or not and i do
14:14 - want to
14:15 - bump this up a little bit since we're
14:16 - going to be seeing activity here in just
14:18 - a second
14:19 - but anyways believe it or not
14:22 - remix also includes a built-in mini
14:25 - ethereum network so you know that we
14:27 - talked about these different ethereum
14:29 - networks one was like the actual
14:32 - ethereum network the ethereum main net
14:33 - it's called and these other like rink b
14:36 - these were test and development networks
14:38 - now you can also just have a local
14:40 - network or in other words a mini virtual
14:42 - ethereum network just running on your
14:44 - own a local computer
14:46 - so that's what this is right here with
14:48 - this javascript vm
14:50 - so make sure you have javascript vm
14:53 - selected and we can just work off this
14:55 - built-in um ethereum networks baked
14:57 - right into the remix tool to make things
14:59 - a whole lot easier now another cool
15:01 - thing about these networks is they also
15:03 - come with test accounts
15:05 - so there are test accounts in here as
15:07 - you can see and each of them are loaded
15:09 - up with 100 each sure would be nice if
15:11 - that was real ether but
15:14 - look at me
15:15 - dreaming away my days all right so just
15:18 - go ahead and keep the first one selected
15:20 - now under here there are some settings
15:22 - for gas limit we talked about that
15:24 - what was it in the last video maybe
15:26 - and value these two we really don't need
15:29 - to touch for
15:30 - um this tutorial now this section right
15:32 - here is where we need to select our
15:34 - contract and right now it says no
15:36 - compiled contracts and that is because i
15:39 - actually set this to auto compile after
15:41 - the contract was already written but if
15:43 - you want to compile this manually then
15:45 - what you can do is hop back in your
15:46 - workspace right click this and just hit
15:49 - compile
15:50 - and then let's pop down here see what
15:52 - this notification is all right
15:55 - huh spdx license not provided i have a
15:58 - typo or something
16:00 - whoa what's going on here
16:04 - and pretty sure that i had that too
16:09 - all right that was pretty strange i uh
16:11 - believe i just pasted in the exact same
16:14 - source code and it seemed to work that
16:15 - time
16:16 - but either way um that is how you
16:19 - manually compile and now it looks like
16:21 - our auto compile process is working fine
16:25 - so with that being said let's hop back
16:27 - down to our deploy section and you
16:30 - should have a contract in there that is
16:32 - now compiled
16:34 - so how do we deploy this to our well our
16:37 - fake ethereum network and i'm sure you
16:40 - can guess this once you have everything
16:41 - selected just go ahead and hit deploy
16:44 - and if everything was successful then
16:46 - you should see a success message right
16:48 - here in your terminal now another thing
16:50 - is that if you scroll down a little bit
16:52 - you will now have a new item under this
16:54 - deployed contract section
16:56 - and this is essentially a reference to
16:59 - that contract or in other words an
17:01 - instance of bucky so the two functions
17:05 - that we had on the smart contract let me
17:08 - minimize this a bit
17:10 - were set age and get age
17:12 - and that's what these two little buttons
17:15 - resemble right here so it's pretty much
17:17 - just a very simple ui or user interface
17:20 - resembling your smart contract now one
17:22 - thing to point out before we get to this
17:24 - is that if you scroll up you are going
17:26 - to see now that
17:28 - how all of these accounts had 100 ether
17:31 - there's one and this is the account that
17:33 - we used to deploy with it has less than
17:35 - that
17:36 - and this is essentially resembling the
17:38 - fact that whenever you deploy a contract
17:40 - to a network it does require some amount
17:43 - of ether so this was just simulating
17:44 - that so now let's go ahead and scroll
17:47 - back down
17:48 - and okay
17:49 - so we have our contract deployed and
17:51 - there are two functions that we can call
17:53 - on it one is age one is get age
17:55 - now for set age let's go ahead and add
17:58 - some value in there right now 20 click
18:00 - the button and actually let me scroll
18:02 - down here okay so i'm going to click set
18:04 - age right here
18:05 - and what this is going to do is it's
18:07 - going to send a transaction to the
18:09 - network essentially calling set age with
18:12 - a value of 20. now whenever we did this
18:15 - since it did require some update to the
18:18 - network that is indeed also going to
18:21 - cost ether
18:22 - now if we just want to read the value of
18:25 - that variable then i'm sure you can
18:27 - guess what we're going to do here we can
18:28 - just call
18:30 - get age
18:31 - and again this is of course needs to
18:33 - interact with the network but
18:36 - it returns the value of 20 right here
18:38 - remix isn't letting me highlight it but
18:40 - there it is right here where my mouse is
18:42 - and just to confirm that this is working
18:45 - let's call set age again with 36
18:47 - and get age 36
18:50 - so there you go a very simple way of
18:52 - deploying smart contracts and
18:54 - interacting with them from this remix
18:56 - tool again a lot of things built in
18:58 - and to be honest that's pretty much the
19:00 - basics of what we need to know about
19:02 - this tool for now some other quick
19:04 - things is well one if you ever want to
19:06 - delete these then you can just go ahead
19:08 - and hit this and you can delete those
19:11 - and if you ever want to deploy again
19:13 - just hit deploy and boom there you go
19:16 - and you can also deploy multiple ones at
19:18 - once for example if you want maybe a
19:20 - couple instances of it and this is
19:22 - actually what i meant by
19:24 - um there's not only one version of the
19:27 - smart contract living on the ethereum
19:28 - network you can deploy it multiple times
19:31 - and have different instances of it so
19:33 - now i deployed it twice so we got two
19:36 - versions of bucky floating around maybe
19:38 - one has the age of 10 and one has the
19:40 - age of 20. and the last thing that i
19:41 - want to mention is that let me go ahead
19:44 - and actually clean these up
19:46 - is that whenever you are interacting
19:48 - with these smart contracts whenever you
19:50 - are using this javascript vm again this
19:53 - is basically a built-in uh browser
19:56 - network so it's going to be a lot faster
19:59 - than interacting with actual ethereum
20:01 - network even a development or test
20:03 - network so just want to point out that
20:05 - if things are going really fast during
20:07 - development and then when you try to you
20:09 - know deploy it live everything seems
20:11 - just so slow and
20:13 - it's bogging down i just want to say
20:15 - that that's expected behavior one of the
20:18 - benefits we get is a faster network with
20:20 - local development so there you go a very
20:22 - quick introduction to remix and i'm sure
20:24 - you're going to find this tool very
20:26 - helpful throughout your development
20:27 - career so thank you for watching don't
20:29 - forget subscribe and i'll see y'all
20:31 - later

Cleaned transcript:

alrighty i'll welcome back to another video and in this one we are going to be covering remix so to see this tool go to remix.etherium.org and all right so once you go there you're going to be greeted with a screen that looks like this so first of all what is remix so remix is an inbrowser ide for writing smart contracts so if you just want to jump into writing smart contracts play around with some things but you don't want to download and install some you know beefy bulky piece of software then this is the tool that you can use now with that said i'm not going to recommend this tool for developing production grade dapps this is more you can think of it almost like a playground it's a useful tool whenever you're working on simple smart contracts or smaller projects but like i said probably wouldn't want to stick with it for production grade apps for that type of environment we're actually going to be getting into that in the next video but for now i just wanted to go over this tool it's a very handy tool so let's go ahead and jump right into it now on the left right here you're going to notice workspaces now you can think of a workspace essentially as a project in remix so actually we can go ahead and create a new workspace now and whenever we do we can see that it pops up right here is the new item in the menu and this menu right here is just how you switch between your workspaces pretty simple so a new workspace is going to come with a very basic project structure and that includes your contracts directory and inside here are your solidity contracts and we're going to be writing one of these in just a few minutes under that you have your scripts these are your javascript files and then under that you have your tests and this test right here is testing one of the solidity contracts and last but not least you have a readme which is essentially just a readme overview description for the project now in order to best understand these other sections of this ide is probably useful if we do have a simple solidity contract so let's go ahead and create one right now so to create one if you just click on this contracts directory and you right click you can click new file and i'm just going to name this bucky dot sol and the name doesn't really matter well it does in a lot of cases but for this example it doesn't really matter sol just means that it's a solidity file in other words uh smart contract you can think of it like that and all right let me actually boost this up so you can see and if you click this button on the left you can actually just toggle this left menu alright so we are finally ready to start writing our first smart contract where do we begin so the very first line in your smart contract actually let me ask do you hear that noise it's like marbles running down my wall that's a weird noise anyways uh okay spdx and then you want license identifier mit okay so the first line here is actually a comment it's spdx license identifier mit what does this mean this is just an open standard stating that this source code is mit licensed and this is actually recommended to include in all of your solidity files and right under this let's go ahead and write pragma solidity 0.8 okay so what is pragma solidity greater or equal to 0.8.7 mean so this is just indicating what version of solidity we're using and by that i mean the solidity language and not only the language itself but the related compiler to compile this source code down into bytecode changes over time and that's just because well really with any programming language as new features are introduced and you know maybe syntax changes that the language naturally changes so this is really just saying that we're going to be using this version of solidity so we need to make sure when we compile this down that the compiler supports this version of solidity as well so now let's hop into the good stuff and that is actually writing our contract so to begin a smart contract you begin with a name contract and then you can actually name it really anything you want some limitations of course uh no weird characters or anything like that but the name of course should be descriptive of what the contract is and just as a quick overview in terms of uh kind of porting this over to some programming concepts when you think of a contract in solidity you can think of it similar to a class in an objectoriented language so this contract similar to a class is going to contain variables and functions so on and so forth now whenever we deploy this contract to the network what you can think of that process as is creating an instance of this class so essentially we are going to be creating an instance of bucky and pushing it up to the ethereum network and that is essentially going to be our smart contract so if all that's a little hazy don't worry about it right now it's going to make sense whenever we actually deploy it and interact with it a few times it's going to click pretty clearly what's going on so now let's go ahead and talk about what the smart contract is going to do so we just want to stick with the bare bones simple example so we'll just say that there's going to be one variable in here and that's called age and the only real thing that this smart contract is going to do is it's going to store my age on the ethereum network i'm i'm not sure why anyone would ever use the smart contract but uh that's what it's going to do so the first thing that we need is to create a variable to actually store that value so there are different data types i actually have a link right here let me pop it up so there are different data types that you can use in solidity we're going to be kind of tackling these one by one but a lot of them are pretty simple booleans integers uh we are going to be using a uint which is pretty much just an unassigned integer or nonnegative integer however there are some unique data types as well so not just you know your ins your strings so on and so forth but this is a unique one where it's address and of course this is made to store an ethereum address and we're not going to be going over all of these i just want to point out that if you do want to see the different data types then you can type in solidity data types and something like this is going to pop up so that said let's go ahead and create a variable for my age and again we're going to be using a u int and that means a nonnegative integer because i can't have a negative h and we're just going to call it h so end it with a semicolon and again whenever you're defining a variable you put the data type and then the variable name ended with the semicolon all right so we have a variable we have the ability to store my age in the smart contract so now we actually have to write a function to set my age so let me just go ahead and write this and then we'll kind of talk through what it's doing so you're going to call function i'll just call this set age and we're going to be passing in a uint just call it x and then i'll say public and age is equal to x all right so we'll get into this syntax in just a second but just to talk about this logic real quick all this function is doing is we're saying whenever we want to set the age of bucky then what we're going to do is we're going to pass in a value and then we're going to take that value and set it equal to the age variable okay so some things to point out here is one whenever we are passing in arguments to our function then we also need to specify the type of data that we are expecting so this is similar to right here um pretty much whenever you see a variable for the first time it's gonna need the data type right before it now another thing that's interesting about this is this public keyword right here so what does this mean so functions and solidity contracts can have different what is called visibility types now public means that this function it can be called basically by anyone by anyone in the world once this contract is deployed they can call this function um if if we had another function in here which we're going to have in just a bit then that function can call this function as well other contracts can call this function so basically anyone with ethereum account or even other contracts uh this function is callable by you know pretty wide open now there is another keyword and we're not going to be actually using this in this example but just to point out there's another keyword called private and what this is is essentially saying that this function if deemed private it's only callable by other functions in this contract so that means that users couldn't call this function other smart contracts couldn't call it private again it means that this function can be only called from another function within this contract so let me go ahead and revert that back to public and all right so we have a function to set the age of bucky and now before we kind of test this out let me go ahead and create one more function and all this is going to do is it's going to get the age or pretty much return the value of age and that's just because we want to be able to test it out later on make sure that we have the right value set so let's go ahead and do that right now function get age now uh one thing to know is unlike set age where i'm i want to set this variable equal to a new value with the getage we're not going to be passing in any additional information because we're not going to be setting it or updating anything we're basically just going to be reading this age variable to get the value so one thing that we want to add is public because you know this isn't like a private function we don't need to hide anything from anyone else we'll just say that anyone on the entire ethereum network can see my age no problem there now another keyword that i want to introduce is view so what is this view keyword so a function declared as a view means that it doesn't modify any state so for example in this function right here we were taking an age variable and pretty much updating the value of it this would not be a good time to use view in fact this is kind of the opposite of when you should use it because view means the opposite of that that you are not modifying any state or any variables in your contract so view kind of just means uh read only in the last bit of info we need before we can start coding in the function body is this actually let me uh kind of do it the reverse way so what this function is going to do is it's going to return the pretty much the value of age so let's say 20 30 40 whatever it is now whenever you create a function and it does return data you need to specify what type of data is being returned so this returns age which is an unsigned integer so in order to specify that i'm just going to say returns and have a parenthesis there u int all right so just reading this one more we have a function it's called get h it's a public function means pretty much anyone can call it it's read only so it doesn't manipulate any data and it's going to return an unsigned integer and that is h and that is pretty much it again this is a very uh simple contract i don't think it's something that anyone's ever going to use but in terms of just getting something out there quick so we can figure out these other features we remix i think it's looking alright now before we take a look at the compiler let's just go ahead and review why we even need to compile it at all so we are going to be writing source code and we just saw that it was just you know human readable solidity code now these nodes on the network they actually don't run that source code they need to run bytecode ones and zeros so essentially just real quick overview to compile you are taking your source code you are pretty much running it through a compiler and converting it to something called bytecode ones and zeros and then when you deploy your contract or pretty much upload it to the network you're gonna be uploading this bytecode just like that and this is what the nodes are gonna run all right so now let's hop back into remix and take a look at how to do this so on the left menu you see that this right here this is your file explorer pretty much you get to your workspaces now right under here you can see if you hover over it says solidity compiler let's go ahead and click that so the first thing that you need to make sure of is that the compiler version matches this pragma solidity right here pretty much just to make sure that your compiler and your source code are synced up uh they're aware that it's the same version so on and so forth and of course working with solidity a lot of this should be good by default the one thing that i do want to point out is that if you're working on a small project like just a few contracts then it's probably nice to have this auto compile and this just saves you from having to do it manually now i will say that if you're working on a larger project with a lot of the dependencies then it's probably gonna kind of bog down your your browser your resources to have this auto compile feature so typically you want to leave it on but again that's up to your best judgment now i believe that's all we need to set for this so now our code should be auto compiling now after this go ahead and hop down to this section right here so deploy and run transactions and let me zoom out just a bit all right now believe it or not and i do want to bump this up a little bit since we're going to be seeing activity here in just a second but anyways believe it or not remix also includes a builtin mini ethereum network so you know that we talked about these different ethereum networks one was like the actual ethereum network the ethereum main net it's called and these other like rink b these were test and development networks now you can also just have a local network or in other words a mini virtual ethereum network just running on your own a local computer so that's what this is right here with this javascript vm so make sure you have javascript vm selected and we can just work off this builtin um ethereum networks baked right into the remix tool to make things a whole lot easier now another cool thing about these networks is they also come with test accounts so there are test accounts in here as you can see and each of them are loaded up with 100 each sure would be nice if that was real ether but look at me dreaming away my days all right so just go ahead and keep the first one selected now under here there are some settings for gas limit we talked about that what was it in the last video maybe and value these two we really don't need to touch for um this tutorial now this section right here is where we need to select our contract and right now it says no compiled contracts and that is because i actually set this to auto compile after the contract was already written but if you want to compile this manually then what you can do is hop back in your workspace right click this and just hit compile and then let's pop down here see what this notification is all right huh spdx license not provided i have a typo or something whoa what's going on here and pretty sure that i had that too all right that was pretty strange i uh believe i just pasted in the exact same source code and it seemed to work that time but either way um that is how you manually compile and now it looks like our auto compile process is working fine so with that being said let's hop back down to our deploy section and you should have a contract in there that is now compiled so how do we deploy this to our well our fake ethereum network and i'm sure you can guess this once you have everything selected just go ahead and hit deploy and if everything was successful then you should see a success message right here in your terminal now another thing is that if you scroll down a little bit you will now have a new item under this deployed contract section and this is essentially a reference to that contract or in other words an instance of bucky so the two functions that we had on the smart contract let me minimize this a bit were set age and get age and that's what these two little buttons resemble right here so it's pretty much just a very simple ui or user interface resembling your smart contract now one thing to point out before we get to this is that if you scroll up you are going to see now that how all of these accounts had 100 ether there's one and this is the account that we used to deploy with it has less than that and this is essentially resembling the fact that whenever you deploy a contract to a network it does require some amount of ether so this was just simulating that so now let's go ahead and scroll back down and okay so we have our contract deployed and there are two functions that we can call on it one is age one is get age now for set age let's go ahead and add some value in there right now 20 click the button and actually let me scroll down here okay so i'm going to click set age right here and what this is going to do is it's going to send a transaction to the network essentially calling set age with a value of 20. now whenever we did this since it did require some update to the network that is indeed also going to cost ether now if we just want to read the value of that variable then i'm sure you can guess what we're going to do here we can just call get age and again this is of course needs to interact with the network but it returns the value of 20 right here remix isn't letting me highlight it but there it is right here where my mouse is and just to confirm that this is working let's call set age again with 36 and get age 36 so there you go a very simple way of deploying smart contracts and interacting with them from this remix tool again a lot of things built in and to be honest that's pretty much the basics of what we need to know about this tool for now some other quick things is well one if you ever want to delete these then you can just go ahead and hit this and you can delete those and if you ever want to deploy again just hit deploy and boom there you go and you can also deploy multiple ones at once for example if you want maybe a couple instances of it and this is actually what i meant by um there's not only one version of the smart contract living on the ethereum network you can deploy it multiple times and have different instances of it so now i deployed it twice so we got two versions of bucky floating around maybe one has the age of 10 and one has the age of 20. and the last thing that i want to mention is that let me go ahead and actually clean these up is that whenever you are interacting with these smart contracts whenever you are using this javascript vm again this is basically a builtin uh browser network so it's going to be a lot faster than interacting with actual ethereum network even a development or test network so just want to point out that if things are going really fast during development and then when you try to you know deploy it live everything seems just so slow and it's bogging down i just want to say that that's expected behavior one of the benefits we get is a faster network with local development so there you go a very quick introduction to remix and i'm sure you're going to find this tool very helpful throughout your development career so thank you for watching don't forget subscribe and i'll see y'all later
