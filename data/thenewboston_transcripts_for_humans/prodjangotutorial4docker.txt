With timestamps:

00:00 - what is up y'all what is up y'all all
00:04 - right so in this video what we're going
00:06 - to be doing is we're going to start
00:08 - dockerizing our app however before we
00:11 - get to that I want to show you a few
00:13 - things and that is that I did go ahead
00:16 - between the last video and this one and
00:19 - I built out a lot of business logic and
00:22 - that's because I was realizing that it
00:25 - was actually hard to teach a lot of
00:26 - these Concepts without having an actual
00:28 - app that does something so we now have
00:32 - this social network app where you can
00:34 - like share recipes and comment on other
00:37 - people's recipes so pretty uh generic
00:40 - app but it did allow me to install
00:42 - jingle rest framework create a few
00:45 - endpoints and I also added uh jingle
00:47 - channels for websocket sport
00:49 - and aside from that I also want to point
00:52 - this out
00:53 - that I move the location of this
00:57 - to the New Boston developers and it's
01:00 - called cooking core right here so if you
01:03 - want to follow along with the new repo
01:05 - then uh hit up this URL and there you go
01:08 - but either way Yep this is the app
01:12 - um like I said you have your own profile
01:14 - pretty generic you can create recipes
01:17 - and then once you have a recipe other
01:19 - people can come and just comment on them
01:22 - and then they can uh send coins as well
01:25 - and then when anyone sends coins to my
01:30 - recipe I can just like leave them there
01:32 - or I can click this and withdraw them to
01:35 - my main account which is this right here
01:37 - and I did that because I'm thinking
01:40 - about putting like a leaderboard system
01:41 - in to see who can I don't know get the
01:43 - most coins but either way that is kind
01:47 - of the skinnier that and with that out
01:49 - of the way let's go ahead and get to the
01:51 - good stuff so in this video what we're
01:53 - going to be doing is we're going to
01:55 - start dockerizing our app now eventually
01:57 - we're gonna be setting up Docker for
01:59 - production but for right now just to get
02:01 - started what I want to do is
02:04 - um I just want to set it up for local
02:06 - development and by that I mean we are
02:09 - just going to dockerize our database
02:11 - because I think I said in the last
02:14 - tutorial or two tutorials ago that we're
02:17 - not going to be using uh SQL Lite even
02:19 - for development so we're going to be
02:21 - replacing this with postgres and that's
02:24 - going to be our dockerized version of
02:25 - postgres and that's going to give us our
02:27 - development environment where we're
02:28 - going to be running postgres and Docker
02:30 - and we'll keep our main app running in
02:33 - that virtual environment running through
02:34 - poetry
02:35 - and then eventually what we're going to
02:37 - do is for the production mode we are
02:40 - going to be both
02:42 - um dockerizing the database like we do
02:44 - in development but also dockerizing the
02:47 - like built version of this app so we're
02:50 - going to have pretty much uh the
02:52 - database in the app running in two
02:54 - containers and then they're going to be
02:56 - able to communicate with each other
02:57 - that's what we're going to be running on
02:59 - the server whenever we deploy it but
03:01 - enough of this talking nonsense let's go
03:04 - ahead and get started so the first thing
03:06 - I want to do and by the way I already
03:08 - installed
03:10 - let me see if I can find it if I can
03:14 - find it
03:15 - right here
03:16 - uh we might have installed this in the
03:18 - last tutorial but this is the dependency
03:21 - that you're going to need
03:23 - for connecting to postgres
03:25 - so once you have that installed make
03:28 - sure that you go ahead and delete your
03:30 - sqlite database if you have it don't
03:32 - need it anymore
03:34 - and actually let me just copy this in
03:36 - it's probably going to be easier
03:38 - I have my notes to the side here all
03:41 - right so this is the setup that we're
03:43 - going to need for our postgres
03:45 - connection so we switch out the engine
03:47 - again before
03:50 - it was sqlite and now we are going with
03:54 - our postgres backend and then a few
03:56 - things that we're going to need is a
03:58 - name a user and a password to connect to
04:01 - the database and we're just keeping
04:03 - these all as cooking core keeping it
04:05 - simple for now
04:06 - where is the status database running
04:08 - it's going to be running on the same
04:10 - computer localhost on this port this is
04:12 - just a standard postgres Port Atomic
04:14 - request connection Max ages or just some
04:17 - postgres settings and now with this done
04:20 - we can go ahead and start with the
04:22 - docker portion of it
04:24 - so again like I said make sure you have
04:26 - your sqlite database deleted and then
04:29 - what we are going to be doing actually
04:31 - let me talk through a little bit about
04:33 - this before so
04:35 - I assume that you already have Docker
04:37 - installed on your computer and also
04:39 - Docker compose if not go ahead and watch
04:42 - my
04:43 - um probably the first video in my Docker
04:45 - series it'll walk you through that I
04:47 - don't want to repeat anything for those
04:48 - who I'm assume have it already so go
04:52 - ahead and make sure you have those
04:53 - installed and eventually what we're
04:55 - going to be doing is we are going to be
04:57 - creating a docker
05:00 - compose dot yaml file and this is what
05:04 - Docker compose is going to look for and
05:07 - it what this file is is basically
05:10 - consists of multiple containers and it
05:13 - just uh yeah it's just what Docker
05:15 - composes Docker compose uses
05:18 - and for production like I said
05:21 - in the production version of this we are
05:24 - going to have our app and our database
05:26 - however for now
05:27 - since we're not ready to set that up
05:29 - quite yet instead of the stalker
05:31 - compose.yaml create Docker compose dot
05:34 - Dev
05:37 - Dot yaml and then whenever we are
05:40 - running this in our local environment
05:42 - this is what we're gonna pick up instead
05:45 - so what exactly goes in here and
05:48 - actually let me do this again
05:52 - let me know if uh you like me typing all
05:54 - these commands one by one or if you kind
05:56 - of just would rather me paste it in and
05:59 - then kind of talk through it almost like
06:00 - a code review Style
06:02 - like to try and mix things up you know
06:04 - so anyways this is going to be our
06:07 - configuration for Docker compose again
06:09 - um this is just going to be the version
06:11 - Docker compose that we're using in case
06:13 - they changed it later on but the meat
06:15 - and potatoes of this is that this Docker
06:18 - compose file is made up of services now
06:21 - right now we only have one service in
06:23 - here which is our database service but
06:26 - just to kind of take a step back a
06:28 - service is like a piece of our
06:30 - application and it's similar to like an
06:32 - image in Docker but you can kind of
06:34 - think of them like separate uh like mini
06:37 - servers or processes so for example in
06:40 - application maybe we'll have one server
06:42 - or process running redis and then we'll
06:46 - have another server running our like
06:48 - main app so in this case what we're
06:52 - going to do is we're just going to
06:53 - create this one service and it's our
06:56 - database service and most of this is
06:59 - pretty self-explanatory this is the
07:01 - image that we're going to use just a
07:03 - lean version of postgres now this right
07:06 - here restart and let's stop this is our
07:08 - restart policy so unless we explicitly
07:11 - stop this for example if our
07:13 - um well in production what this means is
07:15 - that if you ever have to like reboot
07:17 - your instance then this is automatically
07:19 - going to start back up and that way you
07:22 - don't have to let go in and manually
07:23 - start everything in Docker again so this
07:26 - is going to be our restart policy for
07:28 - our Port mapping what we're going to
07:30 - just do is uh map 5432 on our local
07:33 - system to this port 5432
07:36 - and for the environment variables or
07:40 - pretty much the environment set up for
07:42 - this just make sure that your database
07:46 - name the user and the password all match
07:49 - whatever you have right here
07:51 - so again in and you may want to keep an
07:54 - eye out for this but in your Docker
07:56 - compose file you need to prefix these
07:58 - with postgres underscore and also this
08:02 - one's DB and then that's going to refer
08:04 - to the name so a little bit different
08:06 - name and Convention so just look out for
08:08 - that
08:08 - and the last thing that I don't think we
08:10 - talked about even in my darker series is
08:13 - volumes so what are volumes
08:17 - well almost all applications they're
08:20 - going to require some kind of data
08:22 - storage however we want our containers
08:25 - themselves to be as stateless as
08:27 - possible and that way
08:29 - as you know in Docker we can remove them
08:31 - we can stop them we can start them up
08:33 - whenever we want a lot of flexibility to
08:35 - do that now volumes are a way that we
08:39 - can persist data
08:40 - in a way that that can be used by the
08:43 - container and you can kind of think of
08:45 - it like a virtual thumb drive that can
08:47 - be used by the container so whenever we
08:51 - for example stop this service that data
08:55 - is still going to remain so even if we
08:57 - destroy this container this volume data
09:00 - is still going to be there now the first
09:02 - time that we run this Docker compose
09:04 - file which we're going to do in just a
09:05 - second that's going to go ahead and
09:07 - create the initial volume and then
09:09 - whenever like I said we stop it and
09:11 - started it again then that volume is
09:13 - going to stick around so pretty much
09:15 - allows you to reuse it now just to go
09:17 - over the syntax a little bit right here
09:19 - so this is basically saying that this
09:22 - volume
09:23 - the setup right here I'm going to create
09:25 - a like a virtual USB drive on my
09:27 - computer refer to it is postgres SQL
09:30 - hyphen data
09:32 - and use it to store the data at
09:35 - container path VAR lib postgres data now
09:38 - what's up with this path well it's not
09:40 - just a random path this is actually the
09:42 - default directory where the postgres
09:44 - database stores and serves or excuse me
09:47 - where it stores all of its data files
09:49 - like its tables indexes configuration
09:52 - files so on and so forth
09:55 - so yeah that's pretty much what that's
09:57 - doing right there
09:59 - and now with that said I I think I
10:03 - actually made this make Command before
10:04 - yeah so check it out
10:07 - so I made this makemand which is
10:11 - make sure you tag it as phony as well up
10:13 - dependencies only and what this is going
10:15 - to do is it's first going to check if
10:17 - you have this Dot N file and if not it's
10:20 - going to go ahead and touch it or in
10:21 - other words create it and then after
10:24 - that we are going to run this Docker
10:26 - compose command and if you don't include
10:30 - this flag right here then it's going to
10:33 - look for that Docker compose yaml by
10:36 - default but we want to save that one for
10:38 - our production Docker compose so make
10:40 - sure that you explicitly say no we want
10:42 - to run the dev
10:43 - Docker compose file right here and this
10:46 - is just going to make sure that we get a
10:48 - new database each time
10:51 - so with that said what we can do is
10:56 - actually
10:59 - maybe move this down here well oh well
11:02 - actually just to make sure that um and
11:04 - you guys probably won't need to do this
11:05 - but I just want to make sure that I'm
11:07 - starting fresh since I did play around
11:09 - with things before this tutorial I'm
11:10 - going to do Docker system prune
11:13 - wow
11:16 - prune all yes I want to wipe everything
11:20 - out
11:23 - just still wiping
11:25 - okay
11:27 - and I want to also Docker volume prune
11:31 - and that just means if I had any volumes
11:34 - in there I just want to wipe those out
11:36 - as well again you probably won't have to
11:38 - do this but uh just to make sure we're
11:40 - all starting from the same place in this
11:42 - tutorial and now what I want to do is
11:44 - run this command which is pretty much if
11:46 - all goes well it's gonna spin up this
11:49 - instance right here
11:51 - and that is make up dependencies only
11:55 - so okay it looks good I don't have it
11:58 - yet since I just wiped everything out so
12:00 - it's gonna pull it from Docker hub
12:03 - now we wait
12:05 - sweet so it looks like everything is
12:07 - working and now in my local I'm gonna do
12:10 - make run server
12:14 - and actually yes so because all of our
12:19 - data before was in SQL Lite and now it's
12:22 - in postgres we pretty much need to
12:24 - rebuild our database and for that since
12:28 - we have all our migrations we can just
12:30 - do make migrate
12:32 - and then I'm gonna have to create a
12:34 - super user as well so all those
12:36 - migrations are in right there and I'll
12:39 - do make super user
12:42 - and actually I forgot for this I
12:46 - want second I had a custom user set up
12:49 - so it's compatible with the New Boston
12:52 - ecosystem
12:55 - and this is actually uh
12:59 - a pretty cool system because you have
13:02 - like the same account number that you
13:04 - can use across any of the New Boston
13:06 - software but
13:09 - okay so now I created a super user real
13:12 - quick and I'm just going to run this
13:14 - again and now with that said
13:18 - let me pull up this one
13:21 - all right you should be able to go into
13:23 - my admin panel and just log in
13:28 - it was Auto saved and sweet so there we
13:30 - go nothing broke that means that our
13:33 - local version of Docker is working again
13:37 - this make Command is using Docker
13:39 - compose to run the services in our
13:44 - dockercompose.dev file right here
13:46 - and then this is just running our
13:48 - postgres database which we hooked up to
13:51 - our Django app right there
13:54 - all right so things are looking good and
13:57 - now with this all done what we can do
14:00 - now is start working on our production
14:03 - uh version of Docker now the production
14:07 - version of Docker that we're going to be
14:09 - running it's actually going to look
14:10 - pretty similar to this the main
14:12 - difference is that in addition to
14:14 - running our database it's also going to
14:16 - run our app in a separate container and
14:19 - if you're wondering all right well where
14:22 - is that container being built or is it
14:24 - defined that my friend is what we're
14:26 - gonna do right now
14:28 - so let's go ahead and create a new file
14:30 - and we'll just say Docker file
14:33 - and in here just go ahead and paste this
14:36 - in again and talk you through
14:39 - everything in detail all right
14:43 - so starting from the top
14:46 - so our base image that we're going to
14:49 - use is this uh Buster image and this is
14:52 - pretty much
14:54 - um oh it's Debian Buster which is a
14:56 - specific version of the Debian operating
14:58 - system and this one's just uh kind of
15:01 - popular for running python apps and then
15:03 - for our working directly working
15:06 - directory we are going to stick it in
15:09 - opt which stands for optional in a
15:13 - subdirectory called project
15:15 - and this opt directory in Debian is just
15:20 - a um yeah it's just like convention for
15:22 - whenever you are installing optional
15:25 - software that's kind of not part of the
15:27 - main operating system
15:29 - and then these you're going to find in a
15:32 - lot of
15:33 - um dockerized uh python applications uh
15:37 - quickly this first one is just gonna
15:40 - prevent you from writing dot pyc files
15:42 - to your disk this one is going to
15:46 - disable Python's input output buffering
15:48 - and then what this python path dot does
15:51 - this is going to add the current
15:52 - directory to Python's path and why do we
15:56 - do that is because
15:59 - um later on whenever we are importing
16:01 - our own modules it just makes it easier
16:04 - for python to find those
16:06 - now after this you see kind of the um
16:10 - that setup that we had before so I
16:13 - believe in the last tutorial this is
16:16 - another thing that I changed to but let
16:18 - me actually find this my cooking core
16:21 - project
16:23 - I believe it's in right here you see
16:25 - that the prefix for setting environment
16:29 - variables we had to prefix it with this
16:31 - let me actually copy and make sure I got
16:33 - the right one
16:35 - so we want to flag this indocker
16:39 - to be true and in order to do that for
16:43 - our Django app to pick it up we just
16:45 - need to prefix it with this and that way
16:47 - whenever we are running these settings
16:50 - and it picks up this Docker setting
16:53 - right here this is going to be true
16:55 - right here and we already saw how
16:57 - exactly that works behind the scenes
16:59 - and let me close this for now all right
17:03 - close this clean everything up all right
17:06 - so here we are just installing all of
17:09 - the dependencies that we're going to
17:11 - need and these are the like a system
17:14 - it's like a jet flying overhead but um
17:17 - these are like the system dependencies
17:20 - um not our python dependencies which are
17:23 - going to be installed right here
17:24 - actually right here what we're doing is
17:27 - we're just copying over this
17:29 - poetry lock file and also this
17:32 - piproject.tomo file which is pretty much
17:33 - just a list of all our dependencies
17:36 - and then here is where we are actually
17:39 - installing them with poetry and again
17:42 - poetry is going to be installed
17:45 - right here is where we're doing it
17:48 - and now after that jeez how many
17:53 - vehicles are flying in the air tonight
17:55 - Jesus okay now after this we're going to
17:58 - be copying over readme make file pretty
18:00 - self-explanatory and then here this is
18:04 - where we're going to start copying our
18:05 - actual source code make sure not to
18:07 - forget this line
18:08 - and then one other thing that we're
18:10 - going to do is we're also going to need
18:12 - a local directory in our container as
18:15 - well because right now we have the
18:18 - settings.dev.pui however what we're
18:21 - going to do
18:22 - um in our production app is we're
18:24 - actually going to be
18:25 - setting debug equal to false and we'll
18:29 - also generate another secret key and by
18:31 - the way another thing that I should have
18:33 - mentioned especially when I was setting
18:35 - up that Django admin I built a little
18:37 - helper script right here called
18:39 - production data and if you just run this
18:41 - it's going to give you all of the data
18:43 - that you need for production so it's
18:45 - going to generate that account number
18:47 - because remember I overwrote the user
18:49 - model to use this like custom
18:52 - um like the New Boston compatible user
18:55 - system basically and the signing key is
18:57 - the equivalent of your password more or
18:59 - less and the secret key this is going to
19:02 - be the Django secret key that you are
19:06 - going to be using basically in the
19:10 - production version of these local
19:11 - settings right here but you'll see all
19:13 - that I just want to kind of put in that
19:15 - right now in case I forget
19:17 - and okay moving on so this of course
19:20 - like we saw actually this is a bad
19:22 - comment let me say uh expose
19:25 - uh
19:26 - port 8000.
19:29 - and this is just going to be the port
19:30 - that our application is going to be
19:32 - running on locally not the port that the
19:36 - user is going to hit from the outside
19:39 - um so what we're going to be doing is
19:41 - we're going to be setting up SSL https
19:43 - so they're going to be using Port 443 by
19:46 - default however like um this is all set
19:49 - up where they can just go to our domain
19:51 - name and that's the default Port so they
19:53 - don't have to like explicitly use a 443
19:56 - or 80 or 8000 or anything like that
19:59 - but anyways moving on to this last bit
20:02 - this entry point so this entry point in
20:05 - this script by the way
20:07 - it doesn't exist yet we're going to be
20:09 - writing that in about like 30 seconds
20:11 - but what this entry point script is is
20:14 - it's pretty much a script that's going
20:16 - to be executed as soon as the container
20:19 - starts up and we'll see what the script
20:21 - is it's it's going to do stuff like um
20:23 - installer migrations and pretty much
20:25 - like run the app
20:27 - so anyways with that being said let me
20:29 - go ahead and copy this because what this
20:32 - line is saying is pay in your scripts
20:34 - directory I'm going to look for a file
20:37 - called
20:38 - entrypoint.sh and then I'm going to copy
20:41 - that over so yeah we're gonna need one
20:43 - right now
20:45 - so for this and again what this is is
20:48 - the main command that's executed
20:50 - whenever this entire thing starts up
20:54 - so let me copy this over as well
20:57 - by the way this is a lot easier for me
20:59 - so I really hope you guys like it not
21:01 - having to type in uh uh explain things
21:04 - at the same time all right so all this
21:07 - is doing and by the way the set e-flag
21:09 - just means that if there's any uh errors
21:11 - right here then stop don't try to like
21:13 - power through them because hopefully we
21:15 - don't get error but if we do we want
21:17 - like things to stop so we can actually
21:19 - like check out what's going on and fix
21:21 - it
21:22 - um this is just setting a quick little
21:25 - variable to avoid having to type it
21:27 - multiple times
21:29 - this is just going to Echo out what
21:30 - we're doing and again this is just going
21:32 - to click static and I'm sure you already
21:35 - know what that is and then this is going
21:37 - to run our migrations like we just did a
21:39 - few minutes ago and then this last one
21:42 - is kind of the meat and potatoes to tie
21:44 - everything together we're going to be
21:46 - using poetry to run Daphne because we're
21:50 - no longer using run server since this is
21:52 - a production environment and also we are
21:56 - going to be no longer using whiskey like
21:59 - I said I installed Django channels and
22:01 - that means that we're going to be using
22:03 - Daphne which is capable of running ASCII
22:06 - in other words it just gives us a
22:07 - asynchronous or the ability to use
22:10 - websockets more or less
22:12 - and I already have all of this set up so
22:15 - in uh yeah all that set up I'll need to
22:19 - walk you through that we're going to be
22:20 - running it on Port 8000 and then this is
22:24 - just our uh local logo host basically
22:28 - all right so that is our Docker file
22:30 - again this is pretty much the blueprint
22:33 - for creating the container to run this
22:36 - Django application
22:38 - so now once we have this done we are now
22:42 - just to kind of walk you through what
22:43 - we're going to do we're going to create
22:45 - a new Docker compose file that's capable
22:47 - of running this in production mode which
22:50 - is both the database and
22:52 - this Docker file right here so how do we
22:55 - do that well we go ahead and create that
22:58 - new Docker compose dot yaml file
23:04 - and I can get rid of this one and
23:08 - instead I'll paste in this right there
23:12 - okay
23:13 - so we already know what the majority of
23:15 - this does again version Services again
23:18 - instead of just one service like we had
23:20 - before which was our local database
23:23 - instead in production we're going to be
23:25 - running two services our postgres
23:27 - database and again this is all the same
23:29 - settings we had before
23:31 - and also this other service right here
23:34 - which is our app
23:36 - so this of course is going to be our
23:37 - Django app and what is this saying so
23:40 - the first thing it's saying is okay
23:43 - for this container we are just going to
23:46 - be building whatever is in this current
23:49 - directory and again this is my Docker
23:51 - compose file right here and in that same
23:54 - directory is this Docker file so more or
23:57 - less this app is gonna reference this
24:00 - Docker file right here
24:02 - so whenever Docker compose builds it
24:04 - it's pretty much just going to execute
24:05 - all of this
24:07 - and then last but not least this entry
24:10 - point right here and the restart policy
24:13 - we want the same as our database where
24:16 - unless we explicitly stop one of these
24:19 - then just yeah keep it running and that
24:22 - way like I said if we ever restart our
24:24 - instance or like the power goes out or
24:27 - something whenever it boots back up
24:29 - um we don't have to go in and manually
24:30 - restart everything
24:32 - of course Port mapping right here and
24:35 - also this depends on the service right
24:39 - here and what this means is
24:41 - whenever Docker compose is kind of like
24:44 - uh running these Services wait till this
24:47 - one is booted up first and then run this
24:50 - one right here because we don't want our
24:52 - app running if the database isn't like
24:54 - ready yet
24:56 - and the last couple settings are again
25:00 - setting some environment variables
25:01 - however this time we do need to change
25:05 - one of our database settings so for the
25:09 - databases and this is another uh cool
25:11 - part about this how we set everything up
25:14 - you know how I said that sometimes we
25:16 - need to be able to access nested
25:18 - settings from our environment variables
25:20 - so check this out
25:22 - now
25:24 - I'm kind of glad I get to like show off
25:26 - how everything's tied together right now
25:27 - so now in our project settings base
25:31 - right here
25:32 - so what we need to do
25:35 - is we need to update the uh host right
25:39 - here
25:40 - so instead of localhost what we want to
25:44 - do is we want to say whenever we're
25:45 - running in Docker production then we
25:49 - want to use this database right here in
25:53 - Docker is going to be able to refer to
25:55 - it simply as DB
25:58 - now since this isn't like a simple
26:01 - environment variable because
26:03 - by this I mean usually if you set an
26:06 - environment variable it's just going to
26:08 - override this entire thing but we don't
26:10 - want to override this entire dictionary
26:12 - right here we just want to override one
26:15 - of the values in here this host and keep
26:17 - everything else the same so because in
26:19 - the last tutorials how we set up
26:20 - everything nice and special that's what
26:22 - we can do we can override default host
26:25 - and set that to DB pretty cool
26:28 - and then the last thing that we're going
26:31 - to change is in this local settings path
26:33 - I can just to show you how this is all
26:35 - patched together
26:36 - when we are not running it in Docker
26:39 - just for local development then we have
26:41 - this set equal to
26:43 - local settings dev.pui
26:47 - which is this right here and this is
26:50 - kind of like our default development
26:52 - environment settings however for
26:54 - production we're going to be creating a
26:56 - new file so we don't have you know we
26:58 - just don't want to reuse the same secret
26:59 - key and uh definitely don't want to have
27:02 - it running in debug mode so this is
27:05 - pretty much saying that look for this
27:06 - file and we don't have it created yet
27:08 - we'll actually create this when we
27:10 - deploy
27:11 - but uh yeah that's pretty much all
27:14 - that's going on here so and yeah I think
27:18 - that's actually all we needed to cover
27:20 - um we won't run this right now because
27:22 - we're going to be deploying in the next
27:23 - video and running it right then but uh
27:26 - yeah I think uh pretty much good to go
27:30 - so in the next video like I said we're
27:33 - going to be actually deploying this
27:34 - spinning up a ec2 instance and let's see
27:38 - what else we're going to be doing we
27:40 - will
27:41 - um set up an elastic IP point it to our
27:44 - instance we're setting up a domain name
27:46 - we'll be setting up like SSL to make
27:48 - sure that we can uh access everything
27:50 - over https
27:52 - and yeah we'll even deploy the front end
27:54 - I know that this tutorial series is more
27:57 - for like Docker and you know the back
28:00 - end but I'm guessing that if if anyone's
28:04 - like following along and they're going
28:05 - to be doing this in like a real job
28:07 - you're probably going to end up
28:09 - deploying the front end as well so we'll
28:12 - go through the process of deploying the
28:13 - front end to S3 and then setting up like
28:16 - CDN and stuff yada yada it's going to be
28:19 - awesome very entertaining and
28:21 - educational that's my pitch and uh on
28:24 - that note yeah I'll see you guys next
28:26 - time

Cleaned transcript:

what is up y'all what is up y'all all right so in this video what we're going to be doing is we're going to start dockerizing our app however before we get to that I want to show you a few things and that is that I did go ahead between the last video and this one and I built out a lot of business logic and that's because I was realizing that it was actually hard to teach a lot of these Concepts without having an actual app that does something so we now have this social network app where you can like share recipes and comment on other people's recipes so pretty uh generic app but it did allow me to install jingle rest framework create a few endpoints and I also added uh jingle channels for websocket sport and aside from that I also want to point this out that I move the location of this to the New Boston developers and it's called cooking core right here so if you want to follow along with the new repo then uh hit up this URL and there you go but either way Yep this is the app um like I said you have your own profile pretty generic you can create recipes and then once you have a recipe other people can come and just comment on them and then they can uh send coins as well and then when anyone sends coins to my recipe I can just like leave them there or I can click this and withdraw them to my main account which is this right here and I did that because I'm thinking about putting like a leaderboard system in to see who can I don't know get the most coins but either way that is kind of the skinnier that and with that out of the way let's go ahead and get to the good stuff so in this video what we're going to be doing is we're going to start dockerizing our app now eventually we're gonna be setting up Docker for production but for right now just to get started what I want to do is um I just want to set it up for local development and by that I mean we are just going to dockerize our database because I think I said in the last tutorial or two tutorials ago that we're not going to be using uh SQL Lite even for development so we're going to be replacing this with postgres and that's going to be our dockerized version of postgres and that's going to give us our development environment where we're going to be running postgres and Docker and we'll keep our main app running in that virtual environment running through poetry and then eventually what we're going to do is for the production mode we are going to be both um dockerizing the database like we do in development but also dockerizing the like built version of this app so we're going to have pretty much uh the database in the app running in two containers and then they're going to be able to communicate with each other that's what we're going to be running on the server whenever we deploy it but enough of this talking nonsense let's go ahead and get started so the first thing I want to do and by the way I already installed let me see if I can find it if I can find it right here uh we might have installed this in the last tutorial but this is the dependency that you're going to need for connecting to postgres so once you have that installed make sure that you go ahead and delete your sqlite database if you have it don't need it anymore and actually let me just copy this in it's probably going to be easier I have my notes to the side here all right so this is the setup that we're going to need for our postgres connection so we switch out the engine again before it was sqlite and now we are going with our postgres backend and then a few things that we're going to need is a name a user and a password to connect to the database and we're just keeping these all as cooking core keeping it simple for now where is the status database running it's going to be running on the same computer localhost on this port this is just a standard postgres Port Atomic request connection Max ages or just some postgres settings and now with this done we can go ahead and start with the docker portion of it so again like I said make sure you have your sqlite database deleted and then what we are going to be doing actually let me talk through a little bit about this before so I assume that you already have Docker installed on your computer and also Docker compose if not go ahead and watch my um probably the first video in my Docker series it'll walk you through that I don't want to repeat anything for those who I'm assume have it already so go ahead and make sure you have those installed and eventually what we're going to be doing is we are going to be creating a docker compose dot yaml file and this is what Docker compose is going to look for and it what this file is is basically consists of multiple containers and it just uh yeah it's just what Docker composes Docker compose uses and for production like I said in the production version of this we are going to have our app and our database however for now since we're not ready to set that up quite yet instead of the stalker compose.yaml create Docker compose dot Dev Dot yaml and then whenever we are running this in our local environment this is what we're gonna pick up instead so what exactly goes in here and actually let me do this again let me know if uh you like me typing all these commands one by one or if you kind of just would rather me paste it in and then kind of talk through it almost like a code review Style like to try and mix things up you know so anyways this is going to be our configuration for Docker compose again um this is just going to be the version Docker compose that we're using in case they changed it later on but the meat and potatoes of this is that this Docker compose file is made up of services now right now we only have one service in here which is our database service but just to kind of take a step back a service is like a piece of our application and it's similar to like an image in Docker but you can kind of think of them like separate uh like mini servers or processes so for example in application maybe we'll have one server or process running redis and then we'll have another server running our like main app so in this case what we're going to do is we're just going to create this one service and it's our database service and most of this is pretty selfexplanatory this is the image that we're going to use just a lean version of postgres now this right here restart and let's stop this is our restart policy so unless we explicitly stop this for example if our um well in production what this means is that if you ever have to like reboot your instance then this is automatically going to start back up and that way you don't have to let go in and manually start everything in Docker again so this is going to be our restart policy for our Port mapping what we're going to just do is uh map 5432 on our local system to this port 5432 and for the environment variables or pretty much the environment set up for this just make sure that your database name the user and the password all match whatever you have right here so again in and you may want to keep an eye out for this but in your Docker compose file you need to prefix these with postgres underscore and also this one's DB and then that's going to refer to the name so a little bit different name and Convention so just look out for that and the last thing that I don't think we talked about even in my darker series is volumes so what are volumes well almost all applications they're going to require some kind of data storage however we want our containers themselves to be as stateless as possible and that way as you know in Docker we can remove them we can stop them we can start them up whenever we want a lot of flexibility to do that now volumes are a way that we can persist data in a way that that can be used by the container and you can kind of think of it like a virtual thumb drive that can be used by the container so whenever we for example stop this service that data is still going to remain so even if we destroy this container this volume data is still going to be there now the first time that we run this Docker compose file which we're going to do in just a second that's going to go ahead and create the initial volume and then whenever like I said we stop it and started it again then that volume is going to stick around so pretty much allows you to reuse it now just to go over the syntax a little bit right here so this is basically saying that this volume the setup right here I'm going to create a like a virtual USB drive on my computer refer to it is postgres SQL hyphen data and use it to store the data at container path VAR lib postgres data now what's up with this path well it's not just a random path this is actually the default directory where the postgres database stores and serves or excuse me where it stores all of its data files like its tables indexes configuration files so on and so forth so yeah that's pretty much what that's doing right there and now with that said I I think I actually made this make Command before yeah so check it out so I made this makemand which is make sure you tag it as phony as well up dependencies only and what this is going to do is it's first going to check if you have this Dot N file and if not it's going to go ahead and touch it or in other words create it and then after that we are going to run this Docker compose command and if you don't include this flag right here then it's going to look for that Docker compose yaml by default but we want to save that one for our production Docker compose so make sure that you explicitly say no we want to run the dev Docker compose file right here and this is just going to make sure that we get a new database each time so with that said what we can do is actually maybe move this down here well oh well actually just to make sure that um and you guys probably won't need to do this but I just want to make sure that I'm starting fresh since I did play around with things before this tutorial I'm going to do Docker system prune wow prune all yes I want to wipe everything out just still wiping okay and I want to also Docker volume prune and that just means if I had any volumes in there I just want to wipe those out as well again you probably won't have to do this but uh just to make sure we're all starting from the same place in this tutorial and now what I want to do is run this command which is pretty much if all goes well it's gonna spin up this instance right here and that is make up dependencies only so okay it looks good I don't have it yet since I just wiped everything out so it's gonna pull it from Docker hub now we wait sweet so it looks like everything is working and now in my local I'm gonna do make run server and actually yes so because all of our data before was in SQL Lite and now it's in postgres we pretty much need to rebuild our database and for that since we have all our migrations we can just do make migrate and then I'm gonna have to create a super user as well so all those migrations are in right there and I'll do make super user and actually I forgot for this I want second I had a custom user set up so it's compatible with the New Boston ecosystem and this is actually uh a pretty cool system because you have like the same account number that you can use across any of the New Boston software but okay so now I created a super user real quick and I'm just going to run this again and now with that said let me pull up this one all right you should be able to go into my admin panel and just log in it was Auto saved and sweet so there we go nothing broke that means that our local version of Docker is working again this make Command is using Docker compose to run the services in our dockercompose.dev file right here and then this is just running our postgres database which we hooked up to our Django app right there all right so things are looking good and now with this all done what we can do now is start working on our production uh version of Docker now the production version of Docker that we're going to be running it's actually going to look pretty similar to this the main difference is that in addition to running our database it's also going to run our app in a separate container and if you're wondering all right well where is that container being built or is it defined that my friend is what we're gonna do right now so let's go ahead and create a new file and we'll just say Docker file and in here just go ahead and paste this in again and talk you through everything in detail all right so starting from the top so our base image that we're going to use is this uh Buster image and this is pretty much um oh it's Debian Buster which is a specific version of the Debian operating system and this one's just uh kind of popular for running python apps and then for our working directly working directory we are going to stick it in opt which stands for optional in a subdirectory called project and this opt directory in Debian is just a um yeah it's just like convention for whenever you are installing optional software that's kind of not part of the main operating system and then these you're going to find in a lot of um dockerized uh python applications uh quickly this first one is just gonna prevent you from writing dot pyc files to your disk this one is going to disable Python's input output buffering and then what this python path dot does this is going to add the current directory to Python's path and why do we do that is because um later on whenever we are importing our own modules it just makes it easier for python to find those now after this you see kind of the um that setup that we had before so I believe in the last tutorial this is another thing that I changed to but let me actually find this my cooking core project I believe it's in right here you see that the prefix for setting environment variables we had to prefix it with this let me actually copy and make sure I got the right one so we want to flag this indocker to be true and in order to do that for our Django app to pick it up we just need to prefix it with this and that way whenever we are running these settings and it picks up this Docker setting right here this is going to be true right here and we already saw how exactly that works behind the scenes and let me close this for now all right close this clean everything up all right so here we are just installing all of the dependencies that we're going to need and these are the like a system it's like a jet flying overhead but um these are like the system dependencies um not our python dependencies which are going to be installed right here actually right here what we're doing is we're just copying over this poetry lock file and also this piproject.tomo file which is pretty much just a list of all our dependencies and then here is where we are actually installing them with poetry and again poetry is going to be installed right here is where we're doing it and now after that jeez how many vehicles are flying in the air tonight Jesus okay now after this we're going to be copying over readme make file pretty selfexplanatory and then here this is where we're going to start copying our actual source code make sure not to forget this line and then one other thing that we're going to do is we're also going to need a local directory in our container as well because right now we have the settings.dev.pui however what we're going to do um in our production app is we're actually going to be setting debug equal to false and we'll also generate another secret key and by the way another thing that I should have mentioned especially when I was setting up that Django admin I built a little helper script right here called production data and if you just run this it's going to give you all of the data that you need for production so it's going to generate that account number because remember I overwrote the user model to use this like custom um like the New Boston compatible user system basically and the signing key is the equivalent of your password more or less and the secret key this is going to be the Django secret key that you are going to be using basically in the production version of these local settings right here but you'll see all that I just want to kind of put in that right now in case I forget and okay moving on so this of course like we saw actually this is a bad comment let me say uh expose uh port 8000. and this is just going to be the port that our application is going to be running on locally not the port that the user is going to hit from the outside um so what we're going to be doing is we're going to be setting up SSL https so they're going to be using Port 443 by default however like um this is all set up where they can just go to our domain name and that's the default Port so they don't have to like explicitly use a 443 or 80 or 8000 or anything like that but anyways moving on to this last bit this entry point so this entry point in this script by the way it doesn't exist yet we're going to be writing that in about like 30 seconds but what this entry point script is is it's pretty much a script that's going to be executed as soon as the container starts up and we'll see what the script is it's it's going to do stuff like um installer migrations and pretty much like run the app so anyways with that being said let me go ahead and copy this because what this line is saying is pay in your scripts directory I'm going to look for a file called entrypoint.sh and then I'm going to copy that over so yeah we're gonna need one right now so for this and again what this is is the main command that's executed whenever this entire thing starts up so let me copy this over as well by the way this is a lot easier for me so I really hope you guys like it not having to type in uh uh explain things at the same time all right so all this is doing and by the way the set eflag just means that if there's any uh errors right here then stop don't try to like power through them because hopefully we don't get error but if we do we want like things to stop so we can actually like check out what's going on and fix it um this is just setting a quick little variable to avoid having to type it multiple times this is just going to Echo out what we're doing and again this is just going to click static and I'm sure you already know what that is and then this is going to run our migrations like we just did a few minutes ago and then this last one is kind of the meat and potatoes to tie everything together we're going to be using poetry to run Daphne because we're no longer using run server since this is a production environment and also we are going to be no longer using whiskey like I said I installed Django channels and that means that we're going to be using Daphne which is capable of running ASCII in other words it just gives us a asynchronous or the ability to use websockets more or less and I already have all of this set up so in uh yeah all that set up I'll need to walk you through that we're going to be running it on Port 8000 and then this is just our uh local logo host basically all right so that is our Docker file again this is pretty much the blueprint for creating the container to run this Django application so now once we have this done we are now just to kind of walk you through what we're going to do we're going to create a new Docker compose file that's capable of running this in production mode which is both the database and this Docker file right here so how do we do that well we go ahead and create that new Docker compose dot yaml file and I can get rid of this one and instead I'll paste in this right there okay so we already know what the majority of this does again version Services again instead of just one service like we had before which was our local database instead in production we're going to be running two services our postgres database and again this is all the same settings we had before and also this other service right here which is our app so this of course is going to be our Django app and what is this saying so the first thing it's saying is okay for this container we are just going to be building whatever is in this current directory and again this is my Docker compose file right here and in that same directory is this Docker file so more or less this app is gonna reference this Docker file right here so whenever Docker compose builds it it's pretty much just going to execute all of this and then last but not least this entry point right here and the restart policy we want the same as our database where unless we explicitly stop one of these then just yeah keep it running and that way like I said if we ever restart our instance or like the power goes out or something whenever it boots back up um we don't have to go in and manually restart everything of course Port mapping right here and also this depends on the service right here and what this means is whenever Docker compose is kind of like uh running these Services wait till this one is booted up first and then run this one right here because we don't want our app running if the database isn't like ready yet and the last couple settings are again setting some environment variables however this time we do need to change one of our database settings so for the databases and this is another uh cool part about this how we set everything up you know how I said that sometimes we need to be able to access nested settings from our environment variables so check this out now I'm kind of glad I get to like show off how everything's tied together right now so now in our project settings base right here so what we need to do is we need to update the uh host right here so instead of localhost what we want to do is we want to say whenever we're running in Docker production then we want to use this database right here in Docker is going to be able to refer to it simply as DB now since this isn't like a simple environment variable because by this I mean usually if you set an environment variable it's just going to override this entire thing but we don't want to override this entire dictionary right here we just want to override one of the values in here this host and keep everything else the same so because in the last tutorials how we set up everything nice and special that's what we can do we can override default host and set that to DB pretty cool and then the last thing that we're going to change is in this local settings path I can just to show you how this is all patched together when we are not running it in Docker just for local development then we have this set equal to local settings dev.pui which is this right here and this is kind of like our default development environment settings however for production we're going to be creating a new file so we don't have you know we just don't want to reuse the same secret key and uh definitely don't want to have it running in debug mode so this is pretty much saying that look for this file and we don't have it created yet we'll actually create this when we deploy but uh yeah that's pretty much all that's going on here so and yeah I think that's actually all we needed to cover um we won't run this right now because we're going to be deploying in the next video and running it right then but uh yeah I think uh pretty much good to go so in the next video like I said we're going to be actually deploying this spinning up a ec2 instance and let's see what else we're going to be doing we will um set up an elastic IP point it to our instance we're setting up a domain name we'll be setting up like SSL to make sure that we can uh access everything over https and yeah we'll even deploy the front end I know that this tutorial series is more for like Docker and you know the back end but I'm guessing that if if anyone's like following along and they're going to be doing this in like a real job you're probably going to end up deploying the front end as well so we'll go through the process of deploying the front end to S3 and then setting up like CDN and stuff yada yada it's going to be awesome very entertaining and educational that's my pitch and uh on that note yeah I'll see you guys next time
