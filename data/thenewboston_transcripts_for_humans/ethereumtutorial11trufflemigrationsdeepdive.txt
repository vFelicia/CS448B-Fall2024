With timestamps:

00:00 - what is up y'all welcome back to another
00:02 - video and in this one we're going to be
00:04 - taking a closer look at truffle
00:06 - migrations
00:08 - so the first thing that i want you to do
00:10 - is go ahead and pop open ganache
00:12 - and we're just going to be working off a
00:14 - brand new blockchain so just click quick
00:17 - start ethereum
00:18 - nothing else we need to do here right
00:20 - now pretty much just ensure we have a
00:22 - brand new empty blockchain
00:25 - minimize that just make sure it's
00:26 - running in the background and what i did
00:28 - in this tutorial is i created a brand
00:30 - new empty folder and then i just opened
00:32 - that in my ide so make sure you have an
00:35 - empty folder to start and what we can do
00:38 - after that is we can initialize a new
00:40 - truffle project so how do we do that
00:43 - truffle init
00:45 - and it init it's short for initialize
00:48 - project and just hit enter
00:51 - and then that looks successful so after
00:54 - you run that you should have these
00:56 - folders contract migration test and
00:58 - truffle config
01:00 - now we touched on this at a very high
01:02 - level in the last video however what
01:04 - we're going to be doing in this video is
01:06 - we're going to be taking a look at this
01:08 - migration system
01:09 - and that consists of migrations.sol
01:13 - the solidity contract
01:14 - and more specifically we're going to be
01:16 - looking at these migration files
01:19 - so first of all what the heck is this
01:21 - migration system overall
01:23 - so the migration system is truffle's way
01:26 - of keeping track of what changed since
01:29 - you last deployed your project
01:32 - so what i mean by that is typically
01:35 - throughout the lifecycle of a project
01:37 - you're going to be working on a few
01:38 - contracts and say this looks pretty good
01:40 - i'm ready to push it up to the network
01:42 - you push it up and those contracts are
01:43 - deployed
01:44 - and then later on let's say the next day
01:47 - you're like okay let me add some more
01:48 - contracts here let me build in some new
01:50 - features
01:51 - uh you update your project in one way or
01:53 - another and then you're ready to deploy
01:55 - those changes now whenever you deploy
01:57 - those new changes you typically don't
02:00 - want to deploy your entire project again
02:02 - you typically just want to deploy like
02:04 - maybe some updated new contracts that
02:07 - you've written so this migration system
02:10 - is truffle's way of saying you know what
02:12 - these contracts they're already deployed
02:14 - good to go no need to touch those again
02:16 - and in fact you don't want to redeploy
02:18 - those if they haven't changed because
02:20 - it's just going to cost you extra gas
02:21 - fees aside from that what it's going to
02:23 - do is say
02:24 - however these contracts i haven't seen
02:26 - these yet these are new to me so
02:28 - whenever you deploy this i'm going to
02:30 - just deploy the updated portion of your
02:32 - project
02:33 - and if that doesn't really make sense
02:36 - we're going to be taking a look at an
02:37 - example just want to give you a quick
02:39 - overview of kind of what's going to
02:41 - happen and why we're learning it right
02:43 - now so that's the system overall now
02:45 - let's look at these pieces individually
02:47 - so this migration contract this is
02:50 - actually the smart contract that's gonna
02:52 - record which migrations have already
02:55 - been ran or in other words what code has
02:57 - already been deployed and it's gonna say
02:59 - if there's a new migration that i didn't
03:01 - see yet then i'm gonna go ahead and make
03:03 - sure that i run this and then log it
03:05 - here so it's essentially the way that it
03:07 - tracks which code was already deployed
03:10 - and not
03:11 - now this javascript file this migrations
03:15 - one underscore initial migration this is
03:18 - essentially the javascript half of it
03:20 - and all this is saying is this migration
03:23 - file right here again contract
03:25 - migrations
03:26 - this is the very first thing that we're
03:28 - going to deploy to the network and all
03:30 - of these uh little miscellaneous
03:32 - keywords artifacts require deploy or
03:35 - deploy we're going to be covering that
03:36 - in a little bit more detail in just a
03:38 - few minutes but just to show you how
03:40 - these two things are pieced together and
03:42 - now that we have an understanding of the
03:44 - overall system and kind of the couple
03:46 - key components let's go ahead and run
03:48 - our very first migration
03:50 - which is going to be this one right here
03:52 - so what i'm going to do is i'm going to
03:54 - pop open my terminal and i'm just going
03:55 - to run truffle migrate
03:58 - now at this point even though we did
04:00 - start our little uh simulation
04:03 - blockchain we didn't push anything up to
04:05 - the blockchain yet so whenever i run
04:08 - migrate what this is gonna do
04:10 - is truffle is gonna recognize and you
04:13 - can see it right here that whenever i
04:16 - said hey migrate in other words push up
04:18 - my changes to the network it's gonna say
04:22 - okay so the first thing it needs to do
04:23 - is compile this because we only have it
04:25 - in solidity code remember it needs to
04:27 - convert it to ones and zeros before it
04:29 - can push it up
04:30 - so after that is compiled it says
04:32 - starting migrations it's gonna deploy
04:35 - this migration so it essentially deploys
04:38 - that contract and says this is how much
04:40 - gas that it costs all right looks good
04:43 - so now
04:45 - truffle has already deployed these
04:47 - changes to the network and actually if
04:49 - we go back in ganache we can see a
04:51 - couple changes here and my ethereum
04:53 - balance is a little bit less here so it
04:55 - looks like these changes were deployed
04:57 - successfully
04:59 - so now what i'm going to do is i'm
05:00 - actually going to run this command again
05:02 - now whenever i hit enter this time
05:06 - something interesting happens instead of
05:08 - compiling and deploying and doing all
05:10 - that again
05:12 - instead this time it's going to say you
05:14 - know what everything is up to date there
05:16 - is nothing to compile
05:18 - and in fact there were no more changes
05:21 - to ganache
05:23 - no more blocks added nothing happened
05:25 - so why is that now that's because
05:27 - whenever we run truffle migrate what we
05:30 - are essentially instructing truffle to
05:32 - do
05:32 - is we're basically saying hey truffle
05:35 - push up any new updates from our project
05:38 - to the ethereum network and on that
05:41 - second instruction
05:42 - it's gonna say okay well there are no
05:44 - changes that happened since i last
05:46 - deployed so i really don't need to do
05:48 - anything so that's the basics of it and
05:51 - just to hammer this home what i want to
05:53 - do is i want to create one more contract
05:56 - and then we're going to migrate that and
05:58 - it's going to be crystal clear exactly
06:00 - what's going on
06:01 - so i'm just going to create a new
06:03 - contract called bucky.sol
06:06 - and i actually have right next to me
06:09 - that very first contract that we created
06:11 - in remix
06:12 - and the content of this contract it
06:14 - doesn't really matter for this example
06:16 - just want to have some bare bones
06:18 - contract so we can figure out how to
06:20 - migrate it and to do that the first
06:23 - command that we can actually run is
06:26 - truffle compile so what this is going to
06:28 - do is it's going to take any contracts
06:31 - that have not yet been compiled like
06:33 - this one and essentially you can think
06:34 - of it as taking the solidity code and
06:37 - converting it into ones and zeros
06:39 - and you can actually see
06:42 - more details of what it does if you go
06:44 - to build contracts after you compiled
06:46 - you're gonna see this bucky.json
06:48 - and in addition to
06:50 - some other things this interface meta
06:53 - byte code right here
06:55 - you can see that this is essentially
06:56 - preparing
06:57 - the contract converting it into a format
07:00 - that truffle can then push it up to the
07:02 - network all right fantastic so it looks
07:04 - like we have our solidity contract
07:07 - written it is now compiled with all the
07:09 - information in build contracts
07:10 - bucky.json
07:12 - so now how do we get it pushed up to the
07:14 - network well to do so you're going to go
07:17 - ahead and create a brand new migrations
07:19 - file right here so in your migrations
07:22 - directory just go ahead and create a new
07:24 - javascript file
07:26 - and the naming convention for this is
07:28 - actually very specific
07:30 - so the first thing you're going to do is
07:33 - you're going to prefix the file name
07:34 - with a number
07:35 - now this number is going to be
07:38 - sequential to the previous migrations
07:40 - that ran so essentially look at the
07:42 - number of the last migration and just
07:45 - add one to it so this one was one
07:48 - initial migration so this one needs to
07:50 - start with two
07:51 - and i say that this is important because
07:53 - this is actually how truffle keeps track
07:56 - of which migrations uh have already ran
07:59 - and which one have not ran yet so
08:02 - essentially truffle already knows that
08:03 - it already ran number one and when we
08:06 - run it again it's gonna say oh i didn't
08:08 - run two yet so let me go ahead and run
08:10 - that now after two just go ahead and
08:12 - write underscore and then you can just
08:14 - write any human readable short
08:16 - description
08:18 - and i'm just going to call this bucky
08:20 - migration again this number
08:22 - is the really important part and this is
08:25 - just for humans to understand whenever
08:27 - they're quickly looking at this file
08:28 - name
08:29 - what this migration is responsible for
08:32 - so i'm going to call mine to underscore
08:33 - bucky underscore migration.js
08:36 - and there we go
08:38 - so now we have an empty migrations file
08:41 - and what we can actually do is copy
08:44 - everything over from this initial
08:46 - migration and plop it into bucky
08:49 - migrations now i am also going to
08:51 - replace everywhere it says migrations
08:54 - with the name bucky
08:56 - and the reason for that is because that
08:58 - keyword references the contract name and
09:00 - i'm just
09:02 - basically instructing it to deploy bucky
09:05 - instead
09:07 - so everything else is pretty much the
09:08 - same we're
09:11 - okay
09:12 - so change all of the instances of
09:14 - migrations to bucky and now let's go
09:17 - ahead and break this down in a little
09:18 - bit more detail now the first thing that
09:20 - i want to point out is this artifacts
09:22 - require statement right here now if
09:25 - you're familiar with node or javascript
09:26 - this may look like somewhat familiar
09:28 - syntax however i do want to point out
09:31 - that it is actually quite a bit
09:32 - different than node's standard require
09:35 - statement where you essentially just
09:37 - pull in code from another file
09:39 - instead what this is going to do is it's
09:42 - going to pull in a contract and wrap it
09:44 - in a contract abstraction
09:46 - now this means is that with this bucky
09:49 - contract abstraction we can actually
09:51 - interact with it in some pretty special
09:53 - ways
09:54 - and we'll see that later on just want to
09:56 - point out right now that
09:58 - there is not a direct translation from
10:00 - artifacts require to require you can
10:04 - think of them kind of as different
10:06 - systems where instead of just pulling in
10:08 - the source code we're actually pulling
10:09 - in a contract abstraction
10:11 - now another thing that i want to point
10:13 - out that differs from node or javascript
10:16 - is that this
10:18 - value that we pass in as
10:20 - artifacts.require
10:22 - this is not the name of the source file
10:25 - so even though we have a contract file
10:26 - named bucky.sol
10:28 - this is actually the keyword signifying
10:32 - the contract's name right here
10:35 - now why do i make this differentiation
10:37 - why is it even important at all well
10:39 - believe it or not in these solidity
10:41 - files we can actually have multiple
10:43 - contracts in the same file for example
10:45 - we can create another contract in this
10:47 - file named wendy
10:49 - this might be kind of
10:51 - a bad convention but for example just
10:54 - want to show you what's possible
10:55 - now in that case
10:57 - we could just put wendy right here and
11:00 - it would work all the same but either
11:02 - way what i want to point out
11:04 - is that typically or i don't want to say
11:06 - typically a lot of the time
11:08 - you have your contract name the same as
11:10 - your file name right here
11:13 - and what people do is they just uh try
11:15 - to require in the name of the file like
11:18 - bucky as in bucky.sol
11:21 - but if you ever get issues it's probably
11:23 - because you need to pull in the contract
11:25 - name instead so in this case if we did
11:28 - have that wendy
11:30 - contract in there as well what we could
11:32 - do is we could actually pull that in
11:33 - just like this
11:36 - so requiring a bucky and requiring wendy
11:38 - just like that
11:40 - now another thing that must be included
11:42 - in these migration files is this
11:44 - module.exports so module.exports
11:48 - it needs to export a single function and
11:50 - this function takes
11:53 - deployer as its first parameter right
11:55 - here now this deployer object you can
11:58 - kind of guess is truffles object that
12:00 - comes with some functions useful for
12:02 - deploying smart contracts now we're
12:04 - going to be taking a closer look at each
12:05 - of those functions as we need them later
12:07 - on
12:08 - as you can see the first one is uh kind
12:10 - of simple uh it just has a deploy
12:12 - function which we pass in the contract
12:14 - and it essentially is just going to
12:16 - deploy this to the ethereum network
12:18 - pretty simple and the last thing that i
12:20 - want to mention before we actually
12:21 - deploy this is that you may also see
12:24 - some other values being passed into this
12:26 - function
12:26 - for example you may see network being
12:29 - passed in and this is just if you want
12:31 - to deploy but you need some more context
12:33 - around your deployment
12:35 - in this case you can do something like
12:37 - if network is equal to like a
12:41 - development network or something then
12:43 - you can do some kind of deployment
12:46 - uh otherwise
12:48 - you just do this you can do something
12:50 - else
12:51 - so again there is a little bit more to
12:54 - this but again i don't wanna
12:56 - kind of just focus on all the nitty
12:58 - gritty details uh before we actually
13:00 - need those features so for now this
13:03 - looks pretty good so what i'm gonna do
13:05 - now that we have everything set up is
13:08 - i'm gonna go ahead and run truffle
13:10 - migrate again
13:11 - now remember if everything worked
13:13 - correctly and i set everything up
13:15 - correctly then what this should do
13:18 - is truffle should recognize that we
13:20 - already did run that first migration so
13:23 - no change is needed there however this
13:26 - new migration which is deploying this
13:28 - bucky contract to the ethereum network
13:31 - this has not ran yet this is not yet on
13:34 - the network so
13:36 - these are the only changes that it
13:37 - should push up so let me go ahead and
13:39 - hit enter
13:41 - expand this a little bit
13:42 - all right so we ran truffle migrate
13:46 - looks like a compiled bucky.so
13:48 - and all right looks like it is deploying
13:51 - this bucky contract
13:53 - and only deployed one contract
13:56 - all right so far so good and just to
13:58 - verify that if i run truffle migrate
14:00 - again since it now deployed all those
14:03 - changes it should now say everything is
14:05 - up to date and just to verify that that
14:08 - all worked we now have some new blocks
14:11 - looking good now the last thing i want
14:12 - to talk about regarding truffle
14:14 - migrations is actually how to reset your
14:17 - migrations in other words if you do want
14:20 - to run all of your migrations from the
14:22 - very beginning even if you ran them
14:24 - before
14:25 - then how you would do that
14:27 - now before we just hop into that i want
14:28 - to show you example of when this would
14:30 - actually be useful
14:32 - and for that let me go ahead and
14:35 - pop open my terminal and i'm going to
14:37 - run truffle console just so i can
14:39 - interact with that ganache blockchain
14:41 - and
14:42 - to see what's going on here let me go
14:44 - ahead and get a reference to that
14:46 - contract abstraction and by the way all
14:48 - a contract abstraction means if that
14:50 - terminology is getting kind of confusing
14:52 - is just saying that hey i want a way to
14:54 - interact with this ethereum contract and
14:57 - i want to do it through javascript so
14:59 - pretty much just allows you to interact
15:01 - with ethereum contract through
15:02 - javascript
15:03 - so
15:05 - to do this i'm going to say let instance
15:07 - equals await
15:09 - bucky which is the contract and i want
15:11 - to get a reference to the deployed
15:13 - contract so again
15:15 - essentially just a abstraction for this
15:17 - deployed bucky contract storing it in a
15:20 - variable called instance
15:22 - and then this instance if i log it out
15:25 - you can see it's pretty much just a
15:26 - javascript object that is essentially a
15:28 - reference to our deployed contract
15:30 - so right now
15:32 - i'm gonna say let's go ahead and just
15:34 - get the age of this deployed contract so
15:38 - we can do instance dot get age
15:41 - and all right
15:42 - so this is kind of surprising instead of
15:45 - just a number
15:47 - which
15:48 - that's another thing so we initialized
15:51 - this contract and bucky didn't have any
15:53 - age
15:54 - and actually we didn't even set an age
15:57 - so
15:58 - whenever this contract is first
16:00 - initialized if we don't give age an
16:02 - explicit value then it's just going to
16:05 - initialize it by default to the default
16:08 - value which is zero so why don't we just
16:10 - see zero print out here so this is
16:13 - another interesting point about solidity
16:15 - and really a theorem overall and that is
16:17 - that the ethereum network can handle
16:20 - very large numbers now
16:23 - to make those numbers javascript
16:25 - compatible what we do is we essentially
16:27 - convert them to something called a big
16:29 - number and that's what this bn stands
16:32 - for right here and later on when we're
16:34 - actually writing a full dap i'll show
16:36 - you how to convert uh these big numbers
16:38 - to something that's more usable in our
16:40 - depth but for now just want to say that
16:42 - this is indeed storing that numerical
16:45 - value it's just kind of a javascript
16:48 - compatible version of that ethereum
16:50 - number alright so whenever this contract
16:52 - was initialized bucky's age did get set
16:56 - to zero by default now of course what we
16:59 - can do is we can say instance
17:01 - and we can set age to something like 300
17:05 - and then okay whenever i run get age
17:08 - again now you can see that
17:11 - and it's kind of weird because this is
17:12 - stored in object and the value is
17:14 - actually the first item in this list but
17:17 - if you look uh kind of squint your eyes
17:19 - you can see that the age of bucky after
17:22 - setting it to 300 is now indeed 300.
17:26 - okay fantastic but what are we doing
17:29 - setting and getting bucky's age for you
17:31 - know this doesn't really seem related to
17:33 - migrations at all well i mentioned this
17:36 - because let's say that
17:38 - we realized after interacting with this
17:40 - contract that this isn't the exact logic
17:43 - that we want
17:44 - instead whenever this contract is first
17:47 - created we want to initialize bucky's
17:49 - age to
17:50 - well we're not sure yet let's give the
17:52 - deployer the flexibility to set their
17:55 - own age so what we can do is we can
17:57 - introduce a concept called a constructor
18:02 - and this constructor function again if
18:04 - you're familiar with well a lot of
18:06 - different object-oriented program
18:08 - languages you're probably going to
18:09 - understand the concept of this
18:10 - constructor but for those who don't it's
18:12 - really just an optional function
18:14 - that gets declared and any code that is
18:18 - inside here it's going to be executed as
18:20 - soon as your contract is first created
18:23 - so think of this code right here
18:25 - essentially as contract initialization
18:27 - code initialization code there you go
18:30 - that's a tongue twister
18:32 - so what can we do in this case well
18:34 - let's say that whenever this contract is
18:36 - first created in other words first
18:38 - deployed to the network then we're going
18:40 - to allow the user to pass an age and
18:42 - that's going to be bucky's initial age
18:44 - so how do we do that well it's actually
18:46 - the
18:47 - exact same as this function right here
18:50 - but let's just go ahead to change things
18:52 - up a bit we'll say
18:53 - that age
18:56 - is equal to
18:58 - the age that we pass in that's actually
19:00 - a little bit better than x
19:03 - and let's say we want to update that
19:05 - right there too
19:07 - okay so we made a few changes to this
19:10 - age contract right here
19:12 - most specifically or most notably i
19:15 - guess you could say is that we added
19:16 - this constructor we also changed the
19:19 - variable name right here
19:21 - now
19:22 - let's think about this a bit
19:24 - because
19:25 - the javascript code or the migration
19:28 - file responsible for deploying this
19:30 - contract right here
19:31 - it actually already ran
19:34 - so
19:34 - is truffle going to know to actually run
19:38 - this again with our updates well let's
19:40 - find out so what i'm going to do is i'm
19:43 - going to first
19:46 - compile this contract again
19:48 - now it is going to recompile this
19:51 - because it does see oh i compiled this
19:53 - before but there were some changes since
19:56 - then so i'm going to go ahead and
19:57 - recompile it basically it now converted
20:01 - this
20:02 - to a different set of ones and zeros so
20:04 - this file has been updated right here
20:07 - but now once that's compiled let me go
20:09 - ahead and run truffle migrate
20:12 - and all right
20:14 - everything is up to date okay
20:17 - so it did compile it but it didn't push
20:20 - these new changes up to the network so
20:23 - why didn't it do that well it turns out
20:26 - according to our migration system it is
20:28 - just working correctly because we said
20:31 - that whenever there is a new migration
20:34 - that you are unaware of then just go
20:36 - ahead and run the code in this migration
20:39 - file specifically in this function right
20:41 - here and this is essentially how you
20:44 - migrate those changes
20:46 - now it already ran migration 1 and
20:49 - already ran migration 2 so even though
20:52 - this contract was updated the migration
20:54 - system it didn't really care because you
20:56 - can update it all day
20:58 - no matter what it already ran migration
21:01 - too
21:02 - so
21:03 - if we want to update this contract how
21:05 - do we go back and say you know what
21:07 - truffle i know we told you only run new
21:10 - changes however we didn't make changes
21:13 - to this so if you can go ahead and rerun
21:15 - these migrations then that would be
21:16 - great
21:18 - well we know that it won't work with
21:20 - truffle migrate as is
21:22 - however what we can do is we can send in
21:24 - the flag reset
21:26 - now whenever we run truffle migrate
21:28 - reset then what this is going to do is
21:30 - instruct truffle to run all migrations
21:33 - from the very beginning instead of just
21:36 - running the new migrations since the
21:38 - last migration was successfully ran
21:41 - so now let me go ahead and run this
21:42 - again and check it out
21:46 - all right so it looked like it tried to
21:49 - migrate this but
21:51 - getting a weird error here here invalid
21:53 - number of parameters for undefined
21:55 - got zero expected one
21:58 - okay
21:59 - so somewhere it was expecting a value
22:03 - and we weren't passing in that value in
22:06 - so check it out
22:08 - before when we didn't have this
22:10 - constructor we could just take this
22:12 - contract deploy it up to the network and
22:14 - everything was fine
22:15 - now however since we made this update
22:18 - what's happening is that is part of the
22:21 - deployment process or in other words the
22:23 - very first time that you push this up to
22:25 - the network you have to give bucky an
22:28 - initial age
22:29 - and that is part of the constructor
22:31 - logic so that is why in this it's saying
22:34 - hey
22:35 - even though it doesn't or maybe it says
22:36 - it somewhere that it's the constructor
22:38 - but it's essentially saying hey
22:40 - as part of this initialization i was
22:43 - expecting a value for h
22:45 - which was this value right here but
22:47 - instead i got zero information zero
22:50 - values
22:51 - so how do we deploy this with this
22:55 - constructor requirement right here well
22:57 - what we can do is we can hop back into
22:59 - this migration
23:00 - and
23:01 - in this deployer.deploy
23:04 - the first argument is always going to be
23:06 - the contract abstraction right here
23:08 - and then the second one
23:10 - let's just say 90 this is going to be
23:13 - the value for the constructor
23:15 - so if this works correctly then what we
23:18 - should do when we run this command again
23:20 - is it should deploy the same contract
23:22 - however then when we tap into it and
23:24 - check the initial value of uh bucky's
23:27 - age that should be 90. so now let me go
23:30 - ahead and clear this and try running it
23:32 - again
23:33 - and are right
23:35 - so we are resetting and all right this
23:38 - looks pretty cool total deployments of
23:40 - two
23:41 - so now let's just go ahead and clear and
23:43 - make sure
23:44 - everything worked correctly
23:47 - so i'm gonna tap into this again hit
23:49 - truffle console
23:50 - all right let's go ahead
23:53 - and do the same thing
23:56 - where we are going to want to get the
24:00 - deployed
24:01 - reference to our bucky contract and now
24:04 - that we got a reference to our new
24:06 - contract if we do instance dot get age
24:09 - unlike before when it was zero hopefully
24:12 - we see 90 right there
24:14 - so again a couple notes just a reminder
24:17 - is that whenever we already ran
24:20 - migrations but we want to explicitly
24:22 - rerun those migrations then what we
24:24 - could do is we can run truffle migrate
24:26 - again by passing in the reset flag this
24:29 - is going to indicate no matter if you
24:31 - ran those migrations or not just go
24:32 - ahead and reset from the very beginning
24:35 - and re-run those again
24:37 - and another thing is that when we have a
24:39 - constructor
24:41 - during deployment in order to
24:44 - essentially pass in values to that
24:45 - constructor you just uh pretty much just
24:48 - add those values right after the
24:49 - contract name right here
24:52 - all right so i think that covers
24:55 - everything that we need to cover right
24:56 - now in terms of migration again i know
24:58 - this isn't the most uh interesting stuff
25:01 - you probably want to get into you know
25:03 - creating your own tokens and nfts and so
25:05 - on and so forth however i did want to
25:08 - take a tutorial and cover all this
25:10 - because it is going to save you a bunch
25:12 - of headaches in the future
25:14 - by understanding all this in a little
25:16 - bit more detail but for now thank you
25:18 - for watching don't get subscribed and
25:20 - i'll see y'all in the next video

Cleaned transcript:

what is up y'all welcome back to another video and in this one we're going to be taking a closer look at truffle migrations so the first thing that i want you to do is go ahead and pop open ganache and we're just going to be working off a brand new blockchain so just click quick start ethereum nothing else we need to do here right now pretty much just ensure we have a brand new empty blockchain minimize that just make sure it's running in the background and what i did in this tutorial is i created a brand new empty folder and then i just opened that in my ide so make sure you have an empty folder to start and what we can do after that is we can initialize a new truffle project so how do we do that truffle init and it init it's short for initialize project and just hit enter and then that looks successful so after you run that you should have these folders contract migration test and truffle config now we touched on this at a very high level in the last video however what we're going to be doing in this video is we're going to be taking a look at this migration system and that consists of migrations.sol the solidity contract and more specifically we're going to be looking at these migration files so first of all what the heck is this migration system overall so the migration system is truffle's way of keeping track of what changed since you last deployed your project so what i mean by that is typically throughout the lifecycle of a project you're going to be working on a few contracts and say this looks pretty good i'm ready to push it up to the network you push it up and those contracts are deployed and then later on let's say the next day you're like okay let me add some more contracts here let me build in some new features uh you update your project in one way or another and then you're ready to deploy those changes now whenever you deploy those new changes you typically don't want to deploy your entire project again you typically just want to deploy like maybe some updated new contracts that you've written so this migration system is truffle's way of saying you know what these contracts they're already deployed good to go no need to touch those again and in fact you don't want to redeploy those if they haven't changed because it's just going to cost you extra gas fees aside from that what it's going to do is say however these contracts i haven't seen these yet these are new to me so whenever you deploy this i'm going to just deploy the updated portion of your project and if that doesn't really make sense we're going to be taking a look at an example just want to give you a quick overview of kind of what's going to happen and why we're learning it right now so that's the system overall now let's look at these pieces individually so this migration contract this is actually the smart contract that's gonna record which migrations have already been ran or in other words what code has already been deployed and it's gonna say if there's a new migration that i didn't see yet then i'm gonna go ahead and make sure that i run this and then log it here so it's essentially the way that it tracks which code was already deployed and not now this javascript file this migrations one underscore initial migration this is essentially the javascript half of it and all this is saying is this migration file right here again contract migrations this is the very first thing that we're going to deploy to the network and all of these uh little miscellaneous keywords artifacts require deploy or deploy we're going to be covering that in a little bit more detail in just a few minutes but just to show you how these two things are pieced together and now that we have an understanding of the overall system and kind of the couple key components let's go ahead and run our very first migration which is going to be this one right here so what i'm going to do is i'm going to pop open my terminal and i'm just going to run truffle migrate now at this point even though we did start our little uh simulation blockchain we didn't push anything up to the blockchain yet so whenever i run migrate what this is gonna do is truffle is gonna recognize and you can see it right here that whenever i said hey migrate in other words push up my changes to the network it's gonna say okay so the first thing it needs to do is compile this because we only have it in solidity code remember it needs to convert it to ones and zeros before it can push it up so after that is compiled it says starting migrations it's gonna deploy this migration so it essentially deploys that contract and says this is how much gas that it costs all right looks good so now truffle has already deployed these changes to the network and actually if we go back in ganache we can see a couple changes here and my ethereum balance is a little bit less here so it looks like these changes were deployed successfully so now what i'm going to do is i'm actually going to run this command again now whenever i hit enter this time something interesting happens instead of compiling and deploying and doing all that again instead this time it's going to say you know what everything is up to date there is nothing to compile and in fact there were no more changes to ganache no more blocks added nothing happened so why is that now that's because whenever we run truffle migrate what we are essentially instructing truffle to do is we're basically saying hey truffle push up any new updates from our project to the ethereum network and on that second instruction it's gonna say okay well there are no changes that happened since i last deployed so i really don't need to do anything so that's the basics of it and just to hammer this home what i want to do is i want to create one more contract and then we're going to migrate that and it's going to be crystal clear exactly what's going on so i'm just going to create a new contract called bucky.sol and i actually have right next to me that very first contract that we created in remix and the content of this contract it doesn't really matter for this example just want to have some bare bones contract so we can figure out how to migrate it and to do that the first command that we can actually run is truffle compile so what this is going to do is it's going to take any contracts that have not yet been compiled like this one and essentially you can think of it as taking the solidity code and converting it into ones and zeros and you can actually see more details of what it does if you go to build contracts after you compiled you're gonna see this bucky.json and in addition to some other things this interface meta byte code right here you can see that this is essentially preparing the contract converting it into a format that truffle can then push it up to the network all right fantastic so it looks like we have our solidity contract written it is now compiled with all the information in build contracts bucky.json so now how do we get it pushed up to the network well to do so you're going to go ahead and create a brand new migrations file right here so in your migrations directory just go ahead and create a new javascript file and the naming convention for this is actually very specific so the first thing you're going to do is you're going to prefix the file name with a number now this number is going to be sequential to the previous migrations that ran so essentially look at the number of the last migration and just add one to it so this one was one initial migration so this one needs to start with two and i say that this is important because this is actually how truffle keeps track of which migrations uh have already ran and which one have not ran yet so essentially truffle already knows that it already ran number one and when we run it again it's gonna say oh i didn't run two yet so let me go ahead and run that now after two just go ahead and write underscore and then you can just write any human readable short description and i'm just going to call this bucky migration again this number is the really important part and this is just for humans to understand whenever they're quickly looking at this file name what this migration is responsible for so i'm going to call mine to underscore bucky underscore migration.js and there we go so now we have an empty migrations file and what we can actually do is copy everything over from this initial migration and plop it into bucky migrations now i am also going to replace everywhere it says migrations with the name bucky and the reason for that is because that keyword references the contract name and i'm just basically instructing it to deploy bucky instead so everything else is pretty much the same we're okay so change all of the instances of migrations to bucky and now let's go ahead and break this down in a little bit more detail now the first thing that i want to point out is this artifacts require statement right here now if you're familiar with node or javascript this may look like somewhat familiar syntax however i do want to point out that it is actually quite a bit different than node's standard require statement where you essentially just pull in code from another file instead what this is going to do is it's going to pull in a contract and wrap it in a contract abstraction now this means is that with this bucky contract abstraction we can actually interact with it in some pretty special ways and we'll see that later on just want to point out right now that there is not a direct translation from artifacts require to require you can think of them kind of as different systems where instead of just pulling in the source code we're actually pulling in a contract abstraction now another thing that i want to point out that differs from node or javascript is that this value that we pass in as artifacts.require this is not the name of the source file so even though we have a contract file named bucky.sol this is actually the keyword signifying the contract's name right here now why do i make this differentiation why is it even important at all well believe it or not in these solidity files we can actually have multiple contracts in the same file for example we can create another contract in this file named wendy this might be kind of a bad convention but for example just want to show you what's possible now in that case we could just put wendy right here and it would work all the same but either way what i want to point out is that typically or i don't want to say typically a lot of the time you have your contract name the same as your file name right here and what people do is they just uh try to require in the name of the file like bucky as in bucky.sol but if you ever get issues it's probably because you need to pull in the contract name instead so in this case if we did have that wendy contract in there as well what we could do is we could actually pull that in just like this so requiring a bucky and requiring wendy just like that now another thing that must be included in these migration files is this module.exports so module.exports it needs to export a single function and this function takes deployer as its first parameter right here now this deployer object you can kind of guess is truffles object that comes with some functions useful for deploying smart contracts now we're going to be taking a closer look at each of those functions as we need them later on as you can see the first one is uh kind of simple uh it just has a deploy function which we pass in the contract and it essentially is just going to deploy this to the ethereum network pretty simple and the last thing that i want to mention before we actually deploy this is that you may also see some other values being passed into this function for example you may see network being passed in and this is just if you want to deploy but you need some more context around your deployment in this case you can do something like if network is equal to like a development network or something then you can do some kind of deployment uh otherwise you just do this you can do something else so again there is a little bit more to this but again i don't wanna kind of just focus on all the nitty gritty details uh before we actually need those features so for now this looks pretty good so what i'm gonna do now that we have everything set up is i'm gonna go ahead and run truffle migrate again now remember if everything worked correctly and i set everything up correctly then what this should do is truffle should recognize that we already did run that first migration so no change is needed there however this new migration which is deploying this bucky contract to the ethereum network this has not ran yet this is not yet on the network so these are the only changes that it should push up so let me go ahead and hit enter expand this a little bit all right so we ran truffle migrate looks like a compiled bucky.so and all right looks like it is deploying this bucky contract and only deployed one contract all right so far so good and just to verify that if i run truffle migrate again since it now deployed all those changes it should now say everything is up to date and just to verify that that all worked we now have some new blocks looking good now the last thing i want to talk about regarding truffle migrations is actually how to reset your migrations in other words if you do want to run all of your migrations from the very beginning even if you ran them before then how you would do that now before we just hop into that i want to show you example of when this would actually be useful and for that let me go ahead and pop open my terminal and i'm going to run truffle console just so i can interact with that ganache blockchain and to see what's going on here let me go ahead and get a reference to that contract abstraction and by the way all a contract abstraction means if that terminology is getting kind of confusing is just saying that hey i want a way to interact with this ethereum contract and i want to do it through javascript so pretty much just allows you to interact with ethereum contract through javascript so to do this i'm going to say let instance equals await bucky which is the contract and i want to get a reference to the deployed contract so again essentially just a abstraction for this deployed bucky contract storing it in a variable called instance and then this instance if i log it out you can see it's pretty much just a javascript object that is essentially a reference to our deployed contract so right now i'm gonna say let's go ahead and just get the age of this deployed contract so we can do instance dot get age and all right so this is kind of surprising instead of just a number which that's another thing so we initialized this contract and bucky didn't have any age and actually we didn't even set an age so whenever this contract is first initialized if we don't give age an explicit value then it's just going to initialize it by default to the default value which is zero so why don't we just see zero print out here so this is another interesting point about solidity and really a theorem overall and that is that the ethereum network can handle very large numbers now to make those numbers javascript compatible what we do is we essentially convert them to something called a big number and that's what this bn stands for right here and later on when we're actually writing a full dap i'll show you how to convert uh these big numbers to something that's more usable in our depth but for now just want to say that this is indeed storing that numerical value it's just kind of a javascript compatible version of that ethereum number alright so whenever this contract was initialized bucky's age did get set to zero by default now of course what we can do is we can say instance and we can set age to something like 300 and then okay whenever i run get age again now you can see that and it's kind of weird because this is stored in object and the value is actually the first item in this list but if you look uh kind of squint your eyes you can see that the age of bucky after setting it to 300 is now indeed 300. okay fantastic but what are we doing setting and getting bucky's age for you know this doesn't really seem related to migrations at all well i mentioned this because let's say that we realized after interacting with this contract that this isn't the exact logic that we want instead whenever this contract is first created we want to initialize bucky's age to well we're not sure yet let's give the deployer the flexibility to set their own age so what we can do is we can introduce a concept called a constructor and this constructor function again if you're familiar with well a lot of different objectoriented program languages you're probably going to understand the concept of this constructor but for those who don't it's really just an optional function that gets declared and any code that is inside here it's going to be executed as soon as your contract is first created so think of this code right here essentially as contract initialization code initialization code there you go that's a tongue twister so what can we do in this case well let's say that whenever this contract is first created in other words first deployed to the network then we're going to allow the user to pass an age and that's going to be bucky's initial age so how do we do that well it's actually the exact same as this function right here but let's just go ahead to change things up a bit we'll say that age is equal to the age that we pass in that's actually a little bit better than x and let's say we want to update that right there too okay so we made a few changes to this age contract right here most specifically or most notably i guess you could say is that we added this constructor we also changed the variable name right here now let's think about this a bit because the javascript code or the migration file responsible for deploying this contract right here it actually already ran so is truffle going to know to actually run this again with our updates well let's find out so what i'm going to do is i'm going to first compile this contract again now it is going to recompile this because it does see oh i compiled this before but there were some changes since then so i'm going to go ahead and recompile it basically it now converted this to a different set of ones and zeros so this file has been updated right here but now once that's compiled let me go ahead and run truffle migrate and all right everything is up to date okay so it did compile it but it didn't push these new changes up to the network so why didn't it do that well it turns out according to our migration system it is just working correctly because we said that whenever there is a new migration that you are unaware of then just go ahead and run the code in this migration file specifically in this function right here and this is essentially how you migrate those changes now it already ran migration 1 and already ran migration 2 so even though this contract was updated the migration system it didn't really care because you can update it all day no matter what it already ran migration too so if we want to update this contract how do we go back and say you know what truffle i know we told you only run new changes however we didn't make changes to this so if you can go ahead and rerun these migrations then that would be great well we know that it won't work with truffle migrate as is however what we can do is we can send in the flag reset now whenever we run truffle migrate reset then what this is going to do is instruct truffle to run all migrations from the very beginning instead of just running the new migrations since the last migration was successfully ran so now let me go ahead and run this again and check it out all right so it looked like it tried to migrate this but getting a weird error here here invalid number of parameters for undefined got zero expected one okay so somewhere it was expecting a value and we weren't passing in that value in so check it out before when we didn't have this constructor we could just take this contract deploy it up to the network and everything was fine now however since we made this update what's happening is that is part of the deployment process or in other words the very first time that you push this up to the network you have to give bucky an initial age and that is part of the constructor logic so that is why in this it's saying hey even though it doesn't or maybe it says it somewhere that it's the constructor but it's essentially saying hey as part of this initialization i was expecting a value for h which was this value right here but instead i got zero information zero values so how do we deploy this with this constructor requirement right here well what we can do is we can hop back into this migration and in this deployer.deploy the first argument is always going to be the contract abstraction right here and then the second one let's just say 90 this is going to be the value for the constructor so if this works correctly then what we should do when we run this command again is it should deploy the same contract however then when we tap into it and check the initial value of uh bucky's age that should be 90. so now let me go ahead and clear this and try running it again and are right so we are resetting and all right this looks pretty cool total deployments of two so now let's just go ahead and clear and make sure everything worked correctly so i'm gonna tap into this again hit truffle console all right let's go ahead and do the same thing where we are going to want to get the deployed reference to our bucky contract and now that we got a reference to our new contract if we do instance dot get age unlike before when it was zero hopefully we see 90 right there so again a couple notes just a reminder is that whenever we already ran migrations but we want to explicitly rerun those migrations then what we could do is we can run truffle migrate again by passing in the reset flag this is going to indicate no matter if you ran those migrations or not just go ahead and reset from the very beginning and rerun those again and another thing is that when we have a constructor during deployment in order to essentially pass in values to that constructor you just uh pretty much just add those values right after the contract name right here all right so i think that covers everything that we need to cover right now in terms of migration again i know this isn't the most uh interesting stuff you probably want to get into you know creating your own tokens and nfts and so on and so forth however i did want to take a tutorial and cover all this because it is going to save you a bunch of headaches in the future by understanding all this in a little bit more detail but for now thank you for watching don't get subscribed and i'll see y'all in the next video
