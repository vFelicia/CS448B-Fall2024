00:00 - hey there how's it going everybody so in
00:01 - the matplotlib series that I recently
00:03 - released I mentioned several times in
00:05 - that series that I had taken that data
00:07 - from the 2019 stack overflow developer
00:10 - survey so in this video I want to show
00:12 - you how you'd go about downloading that
00:13 - raw data from the survey how we can
00:16 - explore that data to see what's actually
00:17 - in there and how we can write our own
00:20 - scripts to make some calculations and
00:22 - perform some analysis on that data so
00:24 - that you can pull out that information
00:26 - that you're looking for so this is going
00:27 - to be great practice for anyone who's
00:29 - wanting to learn more about data science
00:31 - so this is likely something very common
00:34 - that you'll be doing downloading data
00:36 - seeing how the data is organized and
00:37 - analyzing that data with Python now I
00:40 - would like to mention that we do have a
00:41 - sponsor for this video and that is
00:43 - brilliant org so I'd really like to
00:45 - thank brilliant for sponsoring this
00:46 - video and it would be great if you all
00:48 - could go and check them out using the
00:49 - link in the description section below
00:51 - and support the sponsors and I'll talk
00:53 - more about their services in just a bit
00:55 - so with that said let's go ahead and get
00:57 - started so when the stack overflow
00:58 - developer survey results were first
01:00 - released
01:01 - I saw them posted to Reddit on the
01:03 - programming subreddit and I was reading
01:06 - the comments and this one popped out to
01:08 - me it had a hundred and fifty nine up
01:10 - folks here so we can see that this guy
01:13 - seems frustrated and commented another
01:16 - effing survey that fails to report
01:18 - language popularity by developer type
01:20 - many of those languages are never or
01:22 - almost never used in the embedded world
01:24 - so I don't want to give this person or
01:26 - the people who voted that comment too
01:28 - much pushback but there are tons of
01:30 - specific questions that could be asked
01:32 - about that data so it's a bit hard for
01:34 - Stack Overflow to anticipate everything
01:36 - that people want to know about the data
01:37 - but luckily the data is available for
01:39 - free and we can do that analysis
01:41 - ourselves so if the person who made that
01:44 - frustrated comment happens to be
01:45 - watching this video then you're in luck
01:47 - because at some point I'll also do the
01:50 - analysis that you were looking for where
01:52 - we break down the popular languages by
01:54 - developer type so let's get started and
01:56 - see how to do this so I'm going to open
01:58 - up Google here and first of all let's
02:00 - Google Stack Overflow developer survey
02:05 - results and the first link here should
02:08 - take us to the latest survey now this
02:11 - page actually takes you to the page
02:13 - where they
02:13 - formed some of their own analysis on the
02:15 - data so you can look through and see
02:17 - what they've already analyzed so if we
02:19 - scroll through here then we can see that
02:20 - they break down some of the survey data
02:23 - by geography some developer types that
02:26 - answer the survey and things like that
02:29 - but what we want is the actual data so
02:31 - that we can do some analysis ourselves
02:33 - so if we scroll back up to the top here
02:36 - and we read this first couple of
02:39 - paragraphs here down here at the bottom
02:41 - right here close to the bottom of these
02:43 - first paragraphs it says do you want to
02:45 - dive into the results yourself the
02:48 - results of the survey are available for
02:50 - download here now on this page here you
02:52 - can download the data in CSV form for
02:55 - any year that they have available they
02:57 - organize these CSVs really well now but
03:00 - if you try to download the 2011 data
03:03 - then it's pretty disorganized how they
03:05 - organized it back then so there might be
03:07 - some data cleanup depending on what year
03:09 - you're downloading but I'm going to go
03:11 - ahead and download the 2019 data which
03:14 - is right here so I'm going to download
03:16 - the CSV file and once that is downloaded
03:20 - whoops let's try to redo that it looks
03:23 - like that download didn't work okay and
03:26 - it looks like the download worked that
03:27 - time so now I'm going to open up my
03:31 - downloads folder here and now I'm just
03:34 - going to unzip the zip file that we
03:36 - downloaded so I am extracting those okay
03:40 - so once that's downloaded and unzipped
03:42 - I'm going to go ahead and drag that
03:44 - folder to a folder on my desktop and
03:47 - that's where I'll write a script to
03:49 - analyze the data so I have a folder here
03:51 - on my desktop called Stack Overflow demo
03:54 - so I'm going to drag this over here and
03:56 - we can see that this says developer
03:57 - survey 2019 that's a little long so I'm
04:01 - just going to rename that to data okay
04:04 - so what files are in the directory that
04:06 - we just unzipped so let me close that
04:10 - down and make this a little larger here
04:13 - and let's look at the files that are
04:15 - here within this directory okay so first
04:18 - of all if you download data that comes
04:20 - with a readme file then that's usually
04:23 - really helpful so if we open this up
04:26 - then this will tell us all about the
04:29 - data so let me open up my sublime text
04:32 - here okay and I currently have my word
04:34 - rap turned off so let me turn that on so
04:37 - this is a little easier to read
04:39 - okay so this readme file will tell us
04:41 - about the data here so we can see here
04:44 - that we have these three files here we
04:47 - have survey results public survey
04:49 - results schema CSV and then we have this
04:53 - s Oh survey 2019 PDF PDF file so the
04:57 - survey results public we can see that it
04:59 - says a CVS file with the main survey
05:02 - results one respondent per row and one
05:05 - column per answer the survey results
05:07 - schema is the CSV file with the survey
05:11 - schema ie the questions that correspond
05:14 - to each column name and lastly we have
05:16 - the Esso survey 20:19 dot PDF file and
05:19 - that's a PDF of the actual survey if you
05:22 - want to see how an exact question looked
05:24 - on the survey itself okay so now we know
05:28 - that the survey results public CSV
05:30 - contains these survey results and the
05:33 - survey results schema has the questions
05:36 - that correspond to each column name in
05:38 - the survey results so let me open up
05:40 - both of these to show you what this
05:42 - means so I'm going to use libre office
05:44 - so that it's a bit easier to see
05:46 - everything but you can use any program
05:49 - that you'd like okay so I will open this
05:52 - one here using libre office and these
05:55 - are the survey results public and I will
05:58 - also open the survey results schema as
06:02 - well and this might take a second to
06:04 - open up since there are so many survey
06:08 - results okay so I have the survey
06:10 - results public CSV file open here and
06:13 - let me make this text a little larger
06:16 - here just in case it is difficult for
06:18 - anyone to see so I will just bump that
06:21 - up to 12 and I think that that should be
06:24 - good okay so like we saw in the readme
06:27 - file this file contains the main survey
06:29 - results with one respondent per row and
06:32 - one column per answer so if we look at
06:35 - the first row here we have a respondent
06:38 - number one
06:39 - and let me make this a little larger
06:41 - here so that we can see this complete
06:44 - column name here so we can see that we
06:47 - have a respondent and then we have
06:48 - respondent 1 as the first row and this
06:51 - row is that respondents answers to the
06:53 - survey so let's look through here and
06:55 - find a question and an answer so we can
06:58 - see here that one of the first columns
07:00 - is hobbiest so we have this hobbiest
07:02 - column and their answer to hobbiest was
07:05 - yes so we can probably understand pretty
07:08 - easily what hobbiest means but for some
07:10 - of these columns they're a bit more
07:12 - vague so to understand what all of these
07:15 - columns mean we need to look at our
07:17 - other CSV file that is the schema so let
07:20 - me switch over to the schema CSV file
07:23 - and again I will make this text a little
07:26 - larger so everyone can see and again in
07:29 - the readme file we saw that this schema
07:31 - gives us the questions that correspond
07:33 - to the column names so if we find
07:36 - hobbyists down here it's on row 4 we can
07:39 - see that for hobbyist that the question
07:42 - that the respondent actually answered
07:44 - was do you code as a hobby okay so now
07:48 - that we know how to find all of the
07:49 - questions and answers now we can use
07:51 - Python to analyze this data in just
07:53 - about any way that we'd like all we need
07:55 - to do is think of a question that we'd
07:57 - like answered and then find out a way to
08:00 - parse that information out of the data
08:02 - that we have here so let's start off
08:04 - simple at first and then we'll look at
08:06 - some more complicated examples so to
08:08 - start off let's just see what percentage
08:10 - of people who answered this developer
08:12 - survey said that they actually code as a
08:15 - hobby so first off we'll need to create
08:17 - a new Python script and I'll just do
08:20 - that here within my editor so I'm going
08:22 - to open up sublime text here and here in
08:28 - my editor I already have my folder open
08:32 - on my desktop that I called Stack
08:34 - Overflow demo and I already have the
08:36 - data here that we downloaded so we can
08:39 - see here that we have the readme the PDF
08:41 - file and those CSV files within this
08:44 - data directory so now I'm going to
08:46 - create a Python script here and I'm just
08:49 - going to call this a stack overflow
08:53 - demo dot pie okay so first since we're
08:56 - working with CSV files let's import the
08:59 - CSV module so that we can load in our
09:01 - survey results now if you're familiar
09:03 - with pandas then we could use pandas to
09:06 - analyze this data also but I'm not going
09:08 - to do that in this video because pandas
09:10 - is a big subject to itself so I don't
09:12 - want to do anything
09:14 - using that library that might be
09:15 - confusing to anyone watching who doesn't
09:19 - know how to use that library yet I'm
09:20 - actually working on a panda series right
09:22 - now so though for those of you who are
09:24 - interested I can do some analysis on the
09:27 - same data using pandas in a future video
09:29 - but for now we'll just use the built-in
09:32 - CSV module to load in this data now if
09:35 - you are also unfamiliar with the
09:36 - built-in CSV module then I do have a
09:39 - video on that already and I'll be sure
09:41 - to leave a link to that video in the
09:42 - description section below if anyone
09:44 - would like to brush up on that ok so
09:46 - let's go ahead and import that CSV
09:48 - module so we can load this data in the
09:51 - Python so I'm going to say import CSV
09:53 - and let me actually maximize this so
09:56 - that we can take up the entire screen
09:58 - here okay so now let's load in our data
10:02 - so to do this we can just say with open
10:05 - and remember I put that inside of a
10:07 - directory called data so within data we
10:11 - want to open the survey underscore
10:14 - results under score public dot CSV and
10:18 - we will open that just as F and now I'm
10:24 - going to use a CSV dict reader to load
10:27 - in that file so I'm going to say CSV
10:29 - reader is equal to CS v dot dict reader
10:35 - and we will load in that file
10:38 - so the dict reader from the csv module
10:41 - will load in our data as a list of
10:43 - ordered dictionaries so to see what this
10:45 - looks like let's just print out the
10:48 - first item of that list of objects which
10:51 - will be the first response in that
10:52 - survey now this isn't actually a list
10:55 - this behaves like a generator so we
10:57 - can't access them access the items using
11:00 - indexing it might be easier to work with
11:03 - this data just by casting this to a list
11:05 - but depending on the size of
11:06 - your data that might not always be an
11:08 - option so I'll leave this as a generator
11:10 - for now so we'll have to iterate over
11:13 - the items and to do this we can just say
11:15 - four line in CSV reader and now we will
11:20 - print out those lines and to be sure we
11:25 - only grab that first item I'm going to
11:27 - put in a break here so that the loop
11:29 - doesn't continue okay so now if we run
11:33 - this then we can see that we got one
11:37 - response here and this response is an
11:40 - order dictionary of the responses that
11:42 - were given for our first respondent of
11:44 - the survey and if we want to look at
11:47 - their answers for a certain question
11:49 - then we can access the column name for
11:52 - that question as a key to the dictionary
11:53 - so if we remember the column for the
11:56 - question do you code as a hobby was
11:59 - called hobbyist so let's access their
12:01 - answer to that question just by
12:04 - accessing that as a key so for our line
12:08 - we want to access that hobbyist column
12:11 - so if I run that then now we can see
12:14 - that we just get the response of yes and
12:16 - if we remove this break statement then
12:18 - it won't stop the loop after that first
12:20 - iteration and we'll loop through all of
12:22 - the responses to that answer in the
12:24 - survey so if I remove that break and now
12:28 - I run this code then we can see that
12:32 - it's looping through and printing out
12:33 - everyone's responses from that survey so
12:36 - there are a lot of responses here so it
12:38 - might take a second to print all of
12:40 - those out now I should mention that a
12:42 - lot of people like to use Jupiter
12:43 - notebooks to analyze data like this and
12:45 - there's a good reason for that
12:47 - Jupiter allows you to run single cells
12:49 - at a time so you can load in your data
12:52 - and run your analysis on the data
12:54 - without loading in the data every single
12:56 - time so I have a video on jupiter
12:59 - notebooks if anyone is interested but
13:01 - will be using a regular editor in this
13:03 - video where it just runs the whole
13:05 - script every time okay so I said we'd
13:07 - start off pretty simple here and just
13:09 - analyze what percentage of people who
13:10 - answer the survey said that they code as
13:12 - a hobby and how many of them didn't so
13:16 - to do this let's just track all of the
13:18 - yes and no responses from the survey
13:20 - and then we can calculate the
13:22 - percentages from there now there are
13:24 - several ways we can do this so let's
13:26 - walk through a few different ways that
13:28 - we can solve this answer now this is
13:30 - where I see a lot of people beat
13:31 - themselves up when it comes to
13:33 - programming so they might not be able to
13:35 - think of a solution to this question
13:36 - right away or if they do think of a
13:38 - solution then they might do something in
13:40 - a different way than I do it in these
13:42 - videos and if they do it in a different
13:44 - way
13:44 - sometimes they think that their way is
13:46 - wrong but that's not necessarily the
13:48 - case so let me quickly show you four
13:51 - different ways to solve this problem and
13:53 - if none of these jumped out to you
13:54 - immediately then that's fine too
13:56 - the longer that you're programming the
13:58 - easier that these solutions will kind of
14:00 - pop out in your head okay so I think
14:02 - that some people might be thinking about
14:04 - just having a variable for guess results
14:06 - and a variable for no results and
14:08 - increment those each time we see one of
14:11 - those responses so that would be one way
14:13 - to do it so let's do that first and then
14:16 - we'll look at some ways that we might be
14:17 - able to improve this so we can say right
14:20 - above here I'll say yes count is equal
14:24 - to zero and no count is equal to zero
14:27 - and now in order to keep count of these
14:30 - we can just have a conditional in our
14:32 - for loop that increments these by one
14:34 - each time we see a yes or a No so in
14:37 - here I'm going to overwrite this print
14:39 - line and I'm just going to say if line
14:41 - and we're going to access that hobbiest
14:44 - column if that answer is equal to yes
14:49 - then we will increment our yes count by
14:53 - one else or actually L if line is equal
14:58 - to no then we will increment that no
15:04 - count by one okay so now let's print out
15:07 - those counts and make sure that you
15:09 - print these outside of your loop because
15:12 - if you are inside the loop when you
15:15 - print this then it's going to print
15:17 - something out every time in increments
15:19 - so I will now print out our yes count
15:23 - and also let's print our no count so if
15:28 - I run this then again it's going to take
15:31 - a while to load in this data
15:34 - and we can see that we had 71 thousand
15:38 - roughly people who said that they do
15:39 - code as a hobby and around seventeen to
15:42 - eighteen thousand who said that they
15:44 - didn't so now let's calculate out these
15:46 - percentages so to calculate a percentage
15:48 - all we need to do is divide each of
15:50 - these by the total number of answers so
15:53 - first let's create a variable above for
15:57 - the total number of answers so right
15:59 - above our print statements here I'm
16:00 - going to say that our total is equal to
16:04 - and that's just going to be equal to our
16:06 - yes counts added to our no counts and
16:10 - now we can print out these percentages
16:12 - just by saying I'm just going to modify
16:14 - these existing print statements here and
16:17 - I'm going to say the yes count divided
16:20 - by the total and the no count divided by
16:23 - the total so now if I run this now we
16:27 - get these as percentages so we can see
16:30 - that about 80% of people who answer to
16:32 - the survey said that they code as a
16:33 - hobby and about 20% said that they
16:36 - didn't and if you're making a report or
16:38 - something on this data and wanted to
16:40 - clean this up a bit then we could
16:42 - multiply these numbers by 100 so that we
16:44 - actually have a whole number as
16:46 - percentages and we could also round
16:48 - these to the nearest two decimal places
16:50 - so let me do that really quick so I am
16:54 - going to actually create a variable here
16:58 - below total and I will just call this
17:00 - yes percent and I'll set that equal to
17:03 - and let me just grab this here I'll set
17:06 - that equal to the yes count divided by
17:08 - the total we'll multiply that by 100 I
17:11 - will do the same for the no count so let
17:16 - me grab that sorry they are made a
17:19 - couple of typos okay so no percentage is
17:22 - equal to no count divided by total times
17:25 - 100 so those will give us whole numbers
17:27 - here so instead of you know point zero
17:31 - or point eight zero one it'll give us 80
17:34 - point one instead so now let's actually
17:37 - round those numbers as well since we
17:39 - don't really need this to be as accurate
17:40 - all the way out to these decimal places
17:43 - so I'm just going to do a new line here
17:46 - and I will say that our yes percent is
17:51 - equal to and now we will round our
17:54 - previous yes percent and let's round
17:57 - that just to two decimal places and let
18:00 - me also do this for the no percentage as
18:04 - well so I'll say no percentage is equal
18:07 - to the rounded version of the no count
18:10 - divided by 2
18:11 - whoops and I didn't mean for that to be
18:13 - no count sorry I need to round that
18:15 - percentage to two decimal places okay
18:18 - and now let's print these out and I'll
18:20 - print F strings in order to add some
18:22 - information to what we're printing as
18:23 - well so within here I'm going to create
18:26 - an F string and I will say that the yes
18:30 - answers then I'll fill in a variable
18:32 - here and say that I want this to be the
18:35 - yes percentage and then I'm going to put
18:37 - in a % after that as well so let me copy
18:40 - that and do the same thing for no so
18:43 - I'll say that the no responses had a no
18:46 - percentage and then we will have the %
18:49 - there so now if I run this then we can
18:52 - see that this is a bit more cleaned up
18:54 - here so we can see that the yes
18:55 - responses are 80 point one seven and the
18:59 - no responses are nineteen point eight
19:01 - three okay so now we can see that we get
19:03 - some good information printed out here
19:04 - on how many people code as a hobby okay
19:07 - so this is one way to solve this problem
19:09 - and I said that I would show a couple of
19:11 - other ways that might improve on this
19:13 - now one way I could think that we could
19:16 - improve this is to use dictionaries to
19:19 - track the number of yes and no responses
19:21 - instead of the integer variables that we
19:23 - have already so let me show you what
19:25 - this would look like so let's scroll up
19:28 - here to where we initialized the yes
19:30 - count and the no count and instead of
19:33 - doing it this way let's actually use a
19:35 - dictionary for these instead so instead
19:38 - I'm gonna have a dictionary called
19:39 - counts and in my dictionary I'm going to
19:42 - say have a key for the yes results and
19:45 - I'm also going to have a key for the no
19:50 - results and I'm just going to initialize
19:52 - both of those with a value of zero so
19:55 - now we have a dictionary called counts
19:57 - where the keys of yes and no
20:00 - our keeping track of the yes and no
20:02 - responses now the good thing about using
20:04 - this approach is that we don't need to
20:06 - use this conditional inside of our loop
20:08 - anymore checking if the response is yes
20:10 - or no instead I can just replace this
20:13 - entire conditional so I will get rid of
20:16 - the entire conditional and I'm just
20:18 - going to say counts and then add in a
20:21 - key of our answer for the hobbiest
20:25 - question and I will just increment that
20:27 - key by one so let me explain this one
20:31 - more time here so since we have a
20:32 - dictionary here this line of hobbyists
20:36 - this is going to either be yes or no so
20:39 - if it's a yes then it's gonna access
20:41 - this yes key here in our counts and
20:44 - increment that by one if it's no then
20:46 - it's gonna increment that key by one and
20:49 - since we got rid of the yes count and
20:51 - the no count variables we need to
20:53 - replace where we had those so down here
20:56 - where we have yes count and no count I'm
20:58 - going to replace all of those and we
21:00 - just have two of them here so I'm gonna
21:02 - replace replace those with our counts
21:05 - dictionary and the value of the key yes
21:08 - I'm going to do the same thing with no
21:11 - count here we have two of those here so
21:13 - again I'm going to say counts and access
21:16 - the key of No so I think that is all the
21:18 - changes that we need to make if I run
21:20 - this then we can see that we still get
21:23 - the same results but this cleaned up our
21:26 - code a good bit since we got rid of
21:28 - those conditionals now one more little
21:31 - tip here if you ever find yourself
21:33 - initializing a dictionary with certain
21:35 - values like we did here where we have
21:38 - yes initialize to zero and no initialize
21:40 - to zero then it might be a good idea to
21:43 - use a default dictionary from the
21:45 - collection module instead so default
21:47 - dictionaries allow us to create a
21:49 - dictionary where we don't need to
21:51 - initialize values like this so let me
21:53 - import this and then we'll see how this
21:55 - works so I'll say from collections
21:58 - import and that is default dict and now
22:03 - instead of initializing our values like
22:05 - we did right here instead I'm just going
22:08 - to make this a default dictionary and I
22:11 - want to say that I want this to be a
22:14 - fault dictionary of integers and now our
22:16 - dictionary knows to expect integers as
22:18 - values to our keys and it will start at
22:21 - zero by default so now we should be able
22:24 - to run this just like we did before and
22:26 - we can see that now we get those same
22:28 - results but with our code cleaned up a
22:31 - little bit more now let me show you one
22:33 - last way that we could have done this
22:34 - now the reason I'm showing you multiple
22:36 - ways to solve one simple example is just
22:39 - because these are some of the same types
22:42 - of problems that you'll likely run into
22:43 - when analyzing data and it's nice to
22:46 - know what's available to you so there
22:48 - are many many times when we run into
22:50 - problems where we're simply counting
22:52 - certain values and it's so common that
22:55 - there's actually a data type
22:56 - specifically for counting in Python and
22:58 - it's called counter and it's from the
23:01 - collections module as well so let me
23:03 - import this and we will see how this
23:05 - works so after our default dictionary
23:07 - I'm also going to import counter okay so
23:10 - now instead of setting this as a default
23:14 - dictionary here at the top of the file
23:16 - let's instead create a new counter and
23:20 - just with that small little change if we
23:23 - run this then it should look almost the
23:25 - same as what it was when we used our
23:28 - default dictionary so we can see that we
23:30 - got the same result here but the nice
23:32 - thing about using a counter is that we
23:34 - get some nice extra features such as
23:36 - being able to view the most common
23:38 - values with a single method and doing a
23:41 - few other operations that we wouldn't be
23:43 - able to with a default dictionary as
23:45 - easily okay so now that we've seen this
23:47 - easier example of just figuring out what
23:50 - percentage of people answered yes or no
23:52 - as to whether or not they code as a
23:53 - hobby now let's take a look at a more
23:56 - complicated example and find out the
23:58 - most popular programming languages among
24:00 - the developers who answered this survey
24:02 - so to do this we'll need to open up our
24:04 - schema CSV file again and see what
24:07 - column matches with the programming
24:09 - question so I'm going to open up the
24:12 - schema dot CSV file here and these are
24:16 - actually the results CSV okay here's the
24:18 - schema here now there are a lot of
24:21 - different questions here on this survey
24:22 - but just for the sake of keeping the
24:25 - video as short as I can I memorized
24:26 - where
24:28 - this question is that I'm looking for
24:29 - and it's down here on row 45 so let me
24:34 - find that and if you read this column in
24:37 - question then the column is called
24:40 - language worked with and the question on
24:43 - the survey was which of the following
24:45 - programming scripting and markup
24:47 - languages have you done extensive
24:49 - development work in over the past year
24:52 - and which do you want to work in over
24:54 - the next year if you both worked in the
24:56 - language and want to continue to do so
24:58 - then please check both boxes in that row
25:01 - so this was actually a two-part question
25:03 - on the survey where they chose the
25:05 - languages they're currently working with
25:08 - and also the languages that they want to
25:10 - work with next year and again if you'd
25:12 - like to see exactly how this question
25:14 - looked on the survey then you can open
25:16 - up that PDF file that was in our
25:18 - download and look at that directly so
25:21 - this language worked with column is
25:23 - going to be their answer to the
25:25 - languages that they are currently using
25:27 - at this time so let's go back to our
25:29 - script and see how we can analyze these
25:32 - most popular languages okay so first of
25:35 - all I'm just going to go ahead and
25:37 - comment out everything here below our
25:40 - for loop and I'm going to we might use
25:45 - some of this in a bit but we just don't
25:47 - need it for now okay and I'm also going
25:49 - to rename our counter here I'm going to
25:52 - rename this to language counter since we
25:55 - are calculating the most popular
25:59 - programming languages and now I will
26:02 - instead say language counter and we
26:07 - don't want to use this hobbyists key
26:10 - here instead we want to use this let me
26:14 - say that was language worked with and
26:18 - again if you ever forget one of these
26:20 - then you can just look in those CSV
26:22 - files now before I actually print this
26:25 - out I'm going to comment out that for
26:27 - now and let's instead just print the
26:30 - first result of the survey just to see
26:33 - what one of these responses might look
26:35 - like so again I'm going to print out the
26:38 - answer for language worked with and then
26:40 - I'm going to put in a
26:41 - make statement so that we only get the
26:43 - first result of the survey okay so if I
26:45 - run this then we can see that we get the
26:48 - languages that that's that this specific
26:50 - person said that they work with so this
26:53 - person uses HTML CSS Java JavaScript and
26:57 - Python and we can see that these are
26:59 - separated by semicolons so this isn't
27:02 - going to be as easy as simply
27:04 - incrementing our counter with the value
27:06 - from this languages worked with field
27:09 - because we need to split those into
27:11 - individual languages first so to do this
27:14 - we can use the Python split method and
27:16 - split these on semicolons so instead of
27:20 - let me above our line here above our
27:25 - print I'm going to say that our
27:27 - languages are equal to and we want to
27:30 - take their answer to this language
27:34 - worked with question and we want to
27:36 - split that and let's split that on
27:39 - semicolons and now let's print out those
27:42 - languages so if I save that and run it
27:45 - now we can see that we have a list of
27:48 - those answers instead of the string
27:51 - separated by semicolons okay so now to
27:55 - find the most popular languages we can
27:57 - loop over this list of languages and
27:59 - increment every one of those with our
28:01 - counter so now above our print statement
28:05 - here I'm going to say for language
28:08 - whoops
28:09 - language in languages and now we will
28:15 - increment our languages here oops I
28:19 - actually want to grab this line here we
28:21 - will increment our language counter with
28:24 - that language and we'll just plus equals
28:28 - one on that and I'm actually not going
28:29 - to be using this outside of the loop
28:31 - here anymore since that would give us a
28:34 - false answer there so I'm going to get
28:36 - rid of that and now let's print out that
28:38 - language counter and make sure that it
28:40 - looks right just for this one person so
28:43 - I'm going to print out language counter
28:45 - and let's run this and we can see that
28:48 - we have a counter object here and we
28:50 - have one result for HTML CSS one result
28:53 - for Java one for Java Script one
28:55 - for python that's good now another nice
28:57 - thing about counter objects is that you
29:00 - can pass them a list of items and just
29:03 - have it increment the counter for each
29:05 - one of those items and we can do that
29:08 - with the update method so what we're
29:10 - doing here with this for loop this for
29:13 - loop right here where we are
29:15 - incrementing all of these values by one
29:18 - we can do the same thing as this simply
29:22 - by saying language counter dot update
29:25 - and just pass in that list of languages
29:28 - to that update method so now if I run
29:30 - that then we can see that we got the
29:32 - same results using that update method so
29:35 - now let's remove this Brinks break
29:38 - statement here and see what we get for
29:40 - everyone in the survey and I'll actually
29:43 - remove the print statement as well there
29:46 - and outside of this loop I'm going to
29:49 - print the language counter and again
29:51 - make sure that you are outside of your
29:53 - loop or you'll get something printed for
29:55 - every person in the survey so outside of
29:58 - the loop here I'm just going to print
30:00 - out our language counter I will save
30:03 - that and run it make this a little
30:05 - larger here okay so now we can see that
30:08 - we get our counts for how many people
30:10 - said they know each language and the
30:12 - cool thing with the counter is that we
30:14 - can use the most common method in order
30:17 - to see the most popular languages so if
30:19 - I wanted to just see the five most
30:21 - popular languages then I could down here
30:24 - on my print statement instead of
30:26 - printing that entire counter I could say
30:28 - print dot most underscore common and
30:32 - let's pass in a value of five to that
30:35 - method to say that we want the five most
30:37 - common languages so now if I run this
30:41 - now we can see those top five
30:43 - programming languages okay so we can see
30:45 - how many people said they know each
30:47 - language and when we use the most common
30:50 - method there it returned a list of
30:52 - tuples and each tuple had the name of
30:55 - the language and the number of the
30:58 - people who knew that language and
30:59 - that'll be good to know in just a second
31:02 - because we're going to loop over these
31:03 - as well but before we do that just like
31:06 - we did before it would probably be
31:08 - better to have the
31:09 - and percentages instead of raw numbers
31:11 - so we can do this similar to how we did
31:14 - it before but first we're going to need
31:16 - to get the total of all the responses so
31:19 - that we can use that value to divide
31:22 - those numbers by before when we only had
31:25 - yes and no answers we just added them
31:28 - together to get the total and we were
31:30 - able to do that because the respondents
31:32 - could only respond with a yes or a No
31:35 - but here they can choose as many
31:37 - languages as they want so if we total
31:40 - all of those languages up then we would
31:42 - get a lot more than our total number of
31:44 - respondents because each respondent can
31:47 - have more than one language so instead
31:49 - we're going to need to keep a running
31:51 - total up in our loop where we are
31:55 - looping over the lines from our survey
31:56 - now if we had converted this CSV writter
32:00 - reader to a list then we could simply
32:02 - take the length of that list as our
32:04 - total but since this is a generator I
32:06 - think it'll be easier just to keep a
32:08 - running total so above our CSV reader
32:13 - line here or actually it's right below
32:16 - it it doesn't matter I'm just going to
32:17 - say total is equal to zero and below our
32:22 - for loop here at the end I'm just going
32:26 - to say total plus equals one and now
32:29 - down here at the bottom let me uncomment
32:31 - out what we had here before and actually
32:35 - I can just get rid of that altogether
32:36 - because we've already calculated the
32:38 - total in our for loop okay so now let's
32:41 - loop over those most popular languages
32:43 - and we'll calculate the percentages for
32:45 - each one of these so we can say I'm
32:48 - going to copy out this these five most
32:50 - common languages here so we can say for
32:53 - language and well that's just language
32:57 - and value in our language counter dot
33:01 - most common and five now remember that
33:04 - returned a tuple where the first value
33:07 - was a language the second value was the
33:09 - value was the number of people who said
33:12 - that they knew that language so within
33:13 - this loop I can take the same logic that
33:16 - we did before to calculate percentages
33:17 - and I can just say let me uncomment out
33:22 - these here
33:23 - and instead of yes percentage I'm going
33:26 - to call this language percentage and the
33:30 - value that we are dividing by our total
33:32 - here it is no longer our yes values
33:35 - instead it is going to be this value
33:38 - here that was in our language counter
33:41 - most common tuple and lastly let's go
33:44 - ahead and print this out so again I'm
33:46 - going to take some of the same logic and
33:48 - copy this down here that we used before
33:50 - and I will print this out and instead
33:53 - for our value here I'm just going to
33:55 - print out the language and then print
33:59 - out the language percentage okay so now
34:03 - if I run this whoops and it looks like I
34:06 - got an error here some of you probably
34:08 - noticed that as I was typing it out we
34:10 - are no longer using this yes percentage
34:13 - value here I forgot to replace that we
34:15 - wanted to round our language percentage
34:17 - to two decimal places and not that yes
34:19 - percentage so now if we run this then
34:23 - now we can see the percentages of people
34:25 - who said that they use these languages
34:27 - now if you actually go to the Stack
34:29 - Overflow survey results where they ran
34:32 - some of their own analysis on the data
34:34 - then their results are very similar to
34:37 - this but some of these are different by
34:39 - a tenth of a percent or so and I'm
34:42 - assuming that they used some different
34:43 - criteria for sanitizing their data and
34:45 - filtering out some bad answers but our
34:48 - results here are very similar to the
34:50 - official results on the Stack Overflow
34:52 - results as well so for example some
34:55 - people didn't put any languages down
34:57 - here which would have been an n/a result
34:59 - so Stack Overflow likely got rid of
35:02 - those and there's probably a couple of
35:04 - other forms of criteria that they put in
35:06 - there as well but these are very similar
35:09 - to the results that they got for their
35:11 - survey results as well okay so lastly
35:14 - now that we have the most popular
35:16 - languages programming languages for all
35:19 - the people who've responded to this
35:20 - survey now let's answer that question
35:23 - that we saw at the very beginning of the
35:24 - video and break down the most popular
35:27 - languages by developer type so let's
35:30 - think about how we want to do this so
35:32 - right now we're already getting the most
35:34 - popular languages for all of the people
35:36 - who respond
35:37 - to do the survey so the code is likely
35:40 - going to be similar but now we want to
35:42 - break up the most popular languages
35:44 - based on the type of developer they are
35:46 - so what I think that we should do here
35:49 - is to have a dictionary where each key
35:52 - is the developer type and the value for
35:55 - each key in that dictionary will be
35:57 - another dictionary so these will be
35:59 - nested dictionaries so I'm thinking that
36:02 - the dictionaries for each developer type
36:04 - will have two key value pairs they'll
36:07 - have a key for the total number of
36:09 - people in the survey who said that they
36:11 - work as that type of developer and also
36:14 - they'll have a language counter they'll
36:17 - have a language counter key that has a
36:19 - value that is a counter object with the
36:22 - language breakdown for that developer
36:24 - type which is similar to what we already
36:26 - have here now I know that that might
36:28 - sound a little complicated just by
36:29 - hearing it but it should make more sense
36:32 - once we actually see this and again if
36:34 - you're solving this differently than I
36:36 - am then that's fine this is just one way
36:38 - that I thought of where we could solve
36:40 - this problem there might be even be some
36:42 - faster more efficient ways of solving
36:44 - this in a more functional way with
36:46 - comprehensions but this is how I'm going
36:48 - to solve this in this video so when
36:50 - you're trying to solve a problem like
36:51 - this I think it's extremely beneficial
36:53 - to break it down into small steps so
36:56 - right now I know that I want a
36:58 - dictionary with all of the developer
37:00 - types as keys so let's start off with
37:02 - that so up here above my language
37:06 - counter I am going to create a variable
37:10 - called dev underscore type underscore
37:13 - info and I'm going to set this equal to
37:16 - an empty dictionary and right now I'm
37:18 - just going to remove this language
37:20 - counter here since we're no longer
37:22 - longer using that specific one and I'm
37:25 - also going to remove the total here
37:26 - since we are no longer using that
37:28 - specific total and now within our for
37:31 - loop here I'm going to comment out
37:33 - everything that we have in here so far
37:35 - as a matter of fact I'm going to go
37:37 - ahead and comment out everything below
37:40 - this loop so that we can just work on
37:42 - this small part of this solution for now
37:46 - okay so let me get back up here to being
37:49 - underneath this loop here
37:51 - okay so now let's just break this down
37:53 - one step at a time so right now we just
37:57 - have we just won a dictionary of all of
38:00 - the developer types now like we saw
38:02 - before we can look at the schema dot CSV
38:05 - file that we've seen before in this
38:07 - video to get the column name for this
38:09 - information but I went ahead and wrote
38:11 - this down earlier to save us some time
38:13 - so the column name that we want is
38:15 - called dev type and just like our
38:17 - programming languages this is a list of
38:20 - values separated by semicolons so if so
38:24 - people can also select multiple
38:26 - developer types that match their line of
38:28 - work so right now let's just split those
38:30 - developer types on a semicolon just like
38:32 - we did the programming languages and go
38:35 - ahead and loop over those so I'll go
38:37 - ahead and copy when we did this for
38:39 - languages and I'm just going to say dev
38:42 - underscore types is equal to and this is
38:46 - called dev type so we want to split
38:49 - those dev types on a semicolon and now I
38:53 - will say for dev type in dev types let's
38:58 - go ahead and create or say dev type info
39:04 - and remember we wanted this to be a
39:06 - dictionary with all the developer types
39:08 - so we will set that key just equal to an
39:11 - empty dictionary for now and now I'm
39:14 - going to print those keys from that dev
39:16 - type info dictionary to see if it looks
39:19 - like we got all of those developer types
39:21 - and remember print this outside of the
39:23 - loop so that it doesn't trigger that
39:25 - print statement multiple times so
39:27 - outside of the loop here I will say
39:30 - print and we want to or actually what we
39:34 - want to do is loop over those keys so
39:35 - I'll say for key in dev type info and we
39:40 - will print out each of those keys so now
39:43 - if I run this then our response should
39:46 - be all of the different development
39:48 - types that people filled in on the
39:50 - survey so if I scroll up here we can see
39:53 - okay there's that n a value which means
39:55 - that somebody didn't answer but we can
39:58 - see that we have desktop developers
40:01 - front-end developers designers back in
40:04 - full staff
40:05 - academic researchers all kinds of
40:08 - different types here we can even see
40:11 - that we have the embedded applications
40:12 - or devices that the person and was
40:15 - specifically asking about on that reddit
40:17 - post ok so right now we have a
40:20 - dictionary and all of these developer
40:23 - types here are the keys for that
40:25 - dictionary now we want the values of
40:28 - those dictionaries or we want the values
40:30 - of these developer types to be
40:32 - dictionaries themselves and these nested
40:35 - dictionaries will have a key for the
40:37 - total number of people who said that
40:39 - they were this type of developer and
40:41 - they will also have a language counter
40:44 - of the counter of the count of the
40:47 - languages for that developer type now
40:49 - first we have to think about the loop
40:52 - where we are setting the values of the
40:55 - dev type keys if that key doesn't exist
40:58 - then we just want to create a new
41:00 - dictionary with the keys of total set to
41:03 - zero and language counter sent to a new
41:07 - empty counter if if the key does exist
41:10 - then we just want to grab the current
41:12 - total and the language counter and
41:14 - update those accordingly so one way that
41:17 - we can do this in Python is by using the
41:19 - set default method so let me put this in
41:22 - and I'll explain a bit what it's doing
41:23 - so instead of setting the key like this
41:26 - here I'm instead going to say dev type
41:30 - info dot set default and now we want to
41:35 - set the default for our dev type key and
41:39 - if this doesn't have a value yet then
41:43 - now we are putting in our default value
41:47 - so our default value is just going to be
41:49 - a total set to zero and a language
41:54 - counter which is just an empty counter
41:58 - so let me go over this again just to
42:00 - make sure that this is clear so what set
42:03 - default does here is that it checks if
42:05 - we already have a value for the key of
42:08 - dev type and if we do then it just
42:10 - returns those values and leaves them
42:12 - unmodified and if it doesn't have a
42:14 - value for that key yet then it creates a
42:17 - new dictionary with the
42:19 - and this is the new dictionary here with
42:21 - the keys of total set to zero and the
42:25 - language counter set to a new counter
42:27 - instance so we now we can just update
42:30 - those values like we did before in our
42:33 - commented out section of code and we'll
42:35 - use these keys instead so let me scroll
42:38 - down to our commented out code here and
42:40 - this is where we were updating the
42:44 - different languages in the loop before
42:46 - so let me actually cut these out and
42:49 - paste them up here so now for each
42:53 - developer type in those dev types we
42:56 - still want to grab all of the languages
42:58 - that they work with and we still want to
42:59 - split those on a semicolon but now the
43:02 - language counter here that we are
43:03 - updating is no longer going to be the
43:07 - global language counter that we created
43:09 - out here instead we want it to be the
43:12 - language counter for this developer type
43:15 - so we want this to be dev type info and
43:18 - then access the dev type key here and
43:22 - then we want this to be that language
43:26 - counter key so now we are updating those
43:29 - languages for that language counter for
43:32 - that specific developer type and now the
43:35 - same thing for the total instead of this
43:37 - being a global total here instead this
43:40 - is going to be dev type info dev type
43:43 - and it's going to be that total key for
43:46 - that developer type okay so that should
43:48 - give us the values that we're looking
43:49 - for
43:49 - so now let's loop over all of those
43:52 - developer types and print out the top
43:54 - five languages and percentages using a
43:57 - similar approach to what we did before
43:58 - with our commented out code here at the
44:02 - bottom so now I'm still going to loop
44:04 - over our dev type info dictionary here
44:07 - but instead let me make this more clear
44:09 - instead of using from ki I'm gonna say
44:12 - or for ki I'm gonna say for dev type and
44:15 - also let's access the values of the keys
44:19 - as well and so I'll call that info and
44:22 - now when we're accessing the key and the
44:25 - value we need to say dev type info dot
44:28 - items
44:29 - don't forget the dot items there because
44:31 - if you just loop over dev type in
44:32 - whoa it'll only loop over the keys to
44:35 - get both the key and the value you want
44:37 - to do dev info dot items there
44:39 - okay so first let's print out the
44:42 - developer type just to see what
44:44 - developer type these are languages for
44:47 - and now let me uncomment out everything
44:51 - else that we have here and I can get rid
44:54 - of these yes and no percentages here
44:56 - that's from awhile ago
44:59 - all we need now is our language counter
45:01 - so now when we're looping over this
45:04 - language counter here we want this to be
45:06 - the language counter for this specific
45:08 - developer type so that is going to be
45:11 - remember this info here is going to be
45:14 - the dictionary for that developer type
45:16 - so we want info we want to access that
45:19 - language counter key of that developer
45:22 - type and just one more change here
45:24 - instead of total we want this to
45:27 - actually be the total for that developer
45:29 - type as well so we will access the total
45:32 - key for that developer type as well and
45:35 - lastly I'm going to add a tab to our
45:38 - inner loop here where we are printing
45:40 - this out that way it visually separates
45:42 - this information for each developer type
45:44 - and we'll see what this looks like just
45:47 - in a bit when we print this out okay so
45:50 - that should be all of the changes that
45:52 - we need to make so if I run this let me
45:55 - make this a little larger here then if I
45:58 - did this correctly now we should have
46:00 - the most popular the five most popular
46:01 - languages for each developer type so
46:04 - here at the bottom we can see marketing
46:06 - and sales professional that most of them
46:09 - knew HTML CSS that sounds correct but
46:13 - let's grow up and look at some of these
46:15 - and again you can filter out na up here
46:18 - in our loop if you want to but we can
46:20 - see that desktop use JavaScript HTML CSS
46:24 - front-end developers mostly use
46:27 - JavaScript almost 88% that makes sense
46:30 - JavaScript HTML CSS SQL are the top
46:33 - three that makes sense so designers are
46:36 - mostly HTML back-end developers Java
46:39 - Script full stack developers academic
46:42 - researchers are mostly Python so I
46:44 - believe that makes sense as well because
46:46 - pythons becoming very popular in the
46:49 - data science field and yeah we can see a
46:53 - lot of them here data Sciences
46:54 - specifically or machine learning
46:56 - specialists 80% Python database
47:00 - administrators mostly SQL that makes
47:02 - sense as well now let's actually go down
47:04 - to the embedded systems since that was
47:07 - the specific question that the person
47:09 - asked on reddit so if I keep scrolling
47:12 - down here system administrator we can
47:14 - see that bash made that list that makes
47:16 - sense
47:17 - scientist 70% Python oh I think I missed
47:22 - the embedded applications yes here it is
47:24 - right here okay so we can see that 60%
47:27 - of people who said that they worked in
47:29 - embedded applications new JavaScript 57%
47:33 - said HTML CSS now C++ made this list and
47:37 - it didn't make many other lists and that
47:39 - makes sense because C++ is a very
47:41 - popular language and embedded
47:43 - applications and then we also have SQL
47:45 - and Python here setting at roughly 51%
47:49 - okay so the calculation that we did here
47:51 - broken down by developer type is a bit
47:53 - more advanced than what we started out
47:55 - with but with the data that's available
47:57 - to us we can make just about any
47:59 - analysis that we'd like and this is
48:01 - great practice for anyone who's getting
48:03 - into data science because this is a good
48:06 - example of downloading some real world
48:08 - data and parsing out exactly the
48:10 - information that you'd want it's also
48:13 - gonna make it fun since this is a survey
48:16 - about the developer field it's kind of
48:18 - fun to just poke around in the numbers
48:20 - and see what we can find so for example
48:22 - we can parse out the median salaries for
48:25 - these developer types what programming
48:27 - languages have the highest job
48:28 - satisfaction what the most preferred
48:31 - development environment is for the
48:33 - different development types and
48:34 - languages all kinds of stuff like that
48:36 - to keep it interesting while learning
48:39 - how to do this stuff at the same time
48:40 - and like I said before this would
48:43 - probably be a bit easier if we were
48:45 - using a library like pandas but I didn't
48:47 - want to overwhelm anyone with that
48:48 - library who isn't familiar with it
48:50 - so once I release the pandas series then
48:53 - I'll re release an updated video doing
48:56 - the same thing that we did here but I'll
48:58 - use pandas to parse out this information
49:00 - instead now before we finish up here I'd
49:02 - like to mention the sponsor of this
49:04 - video and that is brilliant org so we've
49:06 - been talking a lot about data science in
49:08 - this video and how to analyze this data
49:10 - but to learn more about data science I
49:12 - would definitely recommend brilliant org
49:14 - so brilliant is a problem-solving
49:17 - website that helps you understand
49:18 - underlying concepts by actively working
49:21 - through guided lessons and they've
49:22 - recently added some brand-new
49:24 - interactive content that makes solving
49:27 - puzzles and challenges even more fun and
49:29 - hands-on and if you'd like to learn more
49:31 - about data science and programming with
49:33 - Python then I would recommend checking
49:35 - out their new probability course that
49:37 - covers everything from the basics to
49:39 - real-world applications and also fun
49:41 - things like casino games they even use
49:44 - Python in their statistics courses and
49:46 - will quiz you on how to correctly
49:48 - analyze the data within the language so
49:50 - they're guided lessons will challenge
49:52 - you but you also have the ability to get
49:54 - hints or even solutions if you need them
49:55 - it's really tailored towards
49:57 - understanding the material they even
49:59 - have a coding barment built into their
50:01 - website so that you can run code
50:02 - directly in the browser and that is a
50:05 - great compliment to watching my
50:06 - tutorials because you can apply what
50:08 - you've learned in their act of problem
50:09 - solving environment and that helps to
50:11 - solidify that knowledge so to support my
50:14 - channel and learn more about brilliant
50:15 - you can go to brilliant org ford slash
50:18 - CMS to sign up for free and also the
50:22 - first 200 people that go to that link
50:23 - will get 20% off the annual premium
50:26 - subscription and you can find that link
50:27 - in the description section below and
50:29 - again that is brilliant dot org ford
50:32 - slash CMS ok so I think that is going to
50:35 - do it for this video I hope you found a
50:37 - video like this helpful where we go over
50:39 - a real-world example of some data
50:40 - analysis using Python and like I said
50:42 - this is great practice for anyone
50:44 - looking to get into the field and it's
50:46 - also pretty fun just playing with the
50:47 - numbers and seeing what we get from that
50:49 - data but if anyone has any questions
50:51 - about will be covered in this video then
50:52 - feel free to ask in the comment section
50:54 - below and I'll do my best to answer
50:55 - those and if you enjoy these tutorials
50:57 - and would like to support them then
50:58 - there are several ways you can do that
51:00 - the easiest ways to simply like the
51:01 - video and give it a thumbs up and also
51:03 - to huge help to share these videos with
51:05 - anyone who you think would find them
51:06 - useful and if you have the means you can
51:07 - contribute through patreon and there's a
51:09 - link to that page in the description
51:10 - section below be sure to subscribe for
51:12 - future videos and thank you
51:14 - for watching
51:25 - you