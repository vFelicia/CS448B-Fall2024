00:00 - hey there how's it going everybody in
00:01 - this video we're going to be learning
00:02 - how to run code concurrently using the
00:04 - threading module now this has been a
00:06 - highly requested video for some time now
00:08 - so I'm glad that I finally am getting
00:10 - around to this now I'm also going to be
00:11 - doing a follow-up video showing how to
00:13 - run code in parallel using the multi
00:15 - processing module and we'll also look at
00:17 - when you would want to use one over the
00:19 - other now if you don't know the
00:21 - difference between threading and multi
00:22 - processing then you should have a grasp
00:24 - on the difference between those once
00:26 - we're finished up now I would like to
00:27 - mention that we do have a sponsor for
00:29 - this video and that is brilliant dot org
00:31 - so I really want to thank brilliant for
00:33 - sponsoring this video and it would be
00:34 - great if you all could check them out
00:36 - using the link in the description
00:37 - section below and support the sponsors
00:38 - and I'll talk more about their services
00:40 - in just a bit
00:41 - so with that said let's go ahead and get
00:43 - started ok so first why would we want to
00:45 - use threading so basically we want to
00:47 - use threading whenever it's going to
00:49 - significantly speed up our program now
00:51 - this speed-up comes from running
00:53 - different tasks concurrently and we'll
00:55 - talk more about concurrency and what
00:57 - that means in just a second now speed
01:00 - ups aren't really guaranteed so it
01:02 - really just depends on what you're doing
01:03 - so in this video we're gonna start off
01:05 - with a basic example where we learn how
01:08 - to run some simple sleep methods
01:10 - concurrently but then we'll finish up
01:12 - with a real-world example where we
01:13 - download some high resolution images
01:15 - from the internet now I want to show
01:17 - that real world example because you know
01:19 - personally when I watch tutorials that
01:21 - only show how it works with a basic
01:22 - example then I always feel like it
01:24 - doesn't really not that I don't walk
01:26 - away with any actual useful knowledge so
01:29 - we'll use the sleep method to get a good
01:30 - idea of how to use threading and then
01:32 - we'll be sure to go over the more
01:33 - complicated real world example of
01:35 - downloading images online so let's go
01:37 - ahead and get started so I have a
01:39 - starting script open up here and if
01:41 - you'd like to follow along then I'll be
01:42 - sure to have a link to this code in the
01:44 - description section below as well and
01:45 - like I said we'll start with a very
01:47 - simple example and see how this works
01:49 - and then build up to more realistic
01:51 - examples so for the script here I'm just
01:54 - importing the time method and then I am
01:56 - starting a counter this is just so we
01:58 - can measure how long this entire script
02:00 - takes so you really don't have to pay
02:02 - attention at least on these lines here
02:04 - but then we just have a simple function
02:06 - called do something and this is printing
02:08 - that we're going to sleep for one second
02:10 - then we actually sleep for a second and
02:11 - then I print that we are done
02:13 - and then we are running that function
02:15 - and then I am getting the finished time
02:18 - here and then I'm printing out that our
02:20 - script finished and I'm printing out the
02:22 - total number of seconds okay so if I run
02:24 - the code that we have right now we can
02:26 - see that it said that we're sleeping for
02:28 - one second that we're done sleeping and
02:29 - that we finished in one second and that
02:32 - sounds about right since we're running
02:33 - the do something function one time and
02:35 - that's sleeping for one second and if we
02:38 - were to run that function twice then our
02:41 - program will likely take two seconds so
02:43 - let's go ahead and see that so I'm just
02:45 - going to copy that and execute that
02:47 - function again and if I run this then we
02:50 - can see sleeping for a second sleeping
02:52 - for a second finished in a little over
02:54 - two seconds so we can see that each time
02:56 - we run the do something function it's
02:58 - adding about one second to our script
03:00 - but it's not really doing anything on
03:02 - the CPU in that function it's just
03:04 - sleeping so our script is just waiting
03:06 - around sleeping for a second and once
03:08 - that's done it moves on to run that next
03:11 - function and set around sits around
03:13 - waiting for another second sleeping and
03:14 - then at that point we're basically done
03:17 - and our script finishes now I created a
03:19 - quick graphic here to represent what
03:22 - this looks like so let me pull this open
03:24 - here in my browser so basically this is
03:26 - what our script looks like right now
03:27 - we're running a function here and then
03:30 - it is sleeping for one second but this
03:32 - is just us sitting around waiting and
03:34 - after that second we run another
03:36 - function here and then it comes up here
03:38 - and waits
03:38 - another second and then finally we are
03:40 - done and running everything in order
03:42 - like this is called running it
03:44 - synchronously and so anytime our program
03:47 - is running synchronously it actually
03:49 - isn't doing much on the CPU and it's
03:51 - just waiting around like this and that's
03:53 - usually a good sign of when we can get
03:55 - some benefits from using threading and
03:57 - concurrency
03:57 - now these are called CPU bound and i/o
04:00 - bound task now CPU bound tasks are
04:03 - things that are crunching a lot of
04:05 - numbers and using the CPU and the i/o
04:07 - bound tasks are things that are just
04:09 - waiting for input and output operations
04:11 - to be completed and not really using the
04:13 - CPU all that much so some other examples
04:15 - of i/o bound tasks include you know
04:18 - reading and writing from the file system
04:20 - and other file system operations network
04:23 - operations downloading stuff online and
04:25 - things like that
04:26 - when it comes to threading we're gonna
04:28 - see benefits when our tasks are IO bound
04:30 - which again means that we're doing a lot
04:32 - of waiting around for input and output
04:35 - operations like you know reading data
04:37 - from disk or network operations now if
04:40 - our tasks are doing a lot of data
04:41 - crunching and our CPU bound then we're
04:44 - not going to get that much of a benefit
04:45 - from using threading as a matter of fact
04:47 - so some programs actually run slower
04:50 - using threads because of the added
04:52 - overhead cost when they're creating and
04:55 - destroying different threads now if a
04:56 - task is CPU bound then we'll likely want
04:59 - to use multi processing and run it in
05:01 - parallel instead and again we're gonna
05:03 - take a look at that in the next video so
05:05 - when we run something concurrently using
05:07 - threads it's not actually going to run
05:09 - the code at the same time it just gives
05:11 - the illusion of running code at the same
05:13 - time because when it comes to a point
05:15 - where it's just waiting around it's just
05:17 - going to go ahead and move forward with
05:19 - the script and run other code while the
05:21 - i/o operations finish and I've got
05:23 - another graphic put together of what
05:25 - this looks like so here's an example of
05:27 - what our code would look like when we
05:29 - use threading so we're gonna run this
05:31 - function and we can see that it comes up
05:33 - here and waits a second but as soon as
05:35 - that starts waiting our code is just
05:37 - gonna move on and go ahead and run
05:39 - another function while we're waiting for
05:41 - this one second to be done sleeping and
05:43 - then we kick off this other second so
05:45 - these are actually overlapped here but
05:48 - we never actually ran any of this code
05:50 - at the same time it's just going to give
05:52 - the illusion of running the code at the
05:53 - same time and then finally we can see
05:55 - that we are done a little bit sooner now
05:58 - this graph isn't a scale you know these
06:00 - weights here would actually be much
06:02 - shorter okay so now that we've actually
06:04 - talked about concurrency and when to use
06:06 - threads now let's see how to actually do
06:08 - this with our current script
06:10 - so first let's import the threading
06:12 - module now this is in the standard
06:14 - library so we don't need to install
06:16 - anything so I'm going to come up here to
06:18 - the top and I'm just going to import
06:21 - threading now I'm going to show an older
06:24 - way of how to do threading first so that
06:26 - we can get a good idea of what's going
06:27 - on but if it seems confusing at first
06:29 - then definitely stick around because I'm
06:31 - also going to show some newer ways of
06:33 - doing threading using pools that allow
06:36 - us to add threading to our programs with
06:38 - a lot fewer lines
06:39 - of code okay so first instead of running
06:42 - the do something function twice in a row
06:44 - like this let's instead turn both of
06:46 - these into threads so to do this I'm
06:49 - going to create two threads for both of
06:51 - these so to do this I'm just going to
06:53 - overwrite where we are setting these
06:54 - functions here and I'm gonna create one
06:56 - thread called t1 and this is going to be
06:59 - threading dot thread and now we want to
07:02 - set a target and our target is the
07:05 - function that we want to run and that is
07:07 - the do something function now we
07:08 - actually want to pass in the function
07:10 - here we don't want to execute the
07:12 - function so don't put on parentheses
07:14 - like this we just want to pass in the
07:16 - function by itself uh neck's acute 'add
07:18 - okay so now let me copy this line and
07:20 - let's create another thread so I will
07:22 - call this t2 and we will keep everything
07:26 - else the same we're just creating a
07:28 - thread with that target of do something
07:30 - okay so at this point we've created two
07:33 - thread objects but we're not actually
07:35 - running that code so if I run this then
07:38 - we can see that it finished immediately
07:39 - but nothing from our function got
07:41 - printed out so our function actually
07:43 - didn't run so in order to get our
07:45 - threads to run we need to use the start
07:47 - method on each thread so here below T -
07:51 - I'm just gonna say t1 dot start and t2
07:55 - dot start and that will actually run our
07:59 - thread but it not might not actually do
08:02 - exactly what we think it'll do so if we
08:04 - run this right now then we can see that
08:07 - it now runs the functions and we can see
08:09 - that it printed out the first lines from
08:12 - both of those functions here let me make
08:13 - this a little larger so it printed out
08:15 - that both of our threads were going to
08:17 - sleep for a second and then it said that
08:19 - our script was finished in zero seconds
08:21 - and then it printed out that it's done
08:23 - sleeping now our script actually took
08:25 - around one second to complete but the
08:27 - reason that it says that it completed in
08:29 - zero seconds is because it started both
08:31 - of those threads and while the threads
08:33 - were sleeping our script ran
08:35 - concurrently and continued on with the
08:37 - rest of the script so it immediately
08:39 - came down and calculated our finish time
08:42 - here and printed out our last print
08:44 - statement as our threads were still
08:45 - sleeping and then once that one second
08:48 - was up our threads continued on and both
08:50 - printed that they were done sleeping now
08:52 - what if we
08:53 - our threads to finish before we
08:54 - calculated the finish time and before we
08:57 - printed out that our script was finished
08:58 - so in order to do this we can use the
09:01 - join method so to do this just below our
09:03 - starts I'm also going to run the join
09:06 - method on both of these and that will
09:08 - make sure that they complete before
09:10 - moving on to calculate the finish time
09:12 - and to print out this statement here
09:15 - so if I save this and run it then we can
09:18 - see that both of our threads started at
09:20 - almost the exact same time and then they
09:22 - both printed out that they were done
09:24 - sleeping after a second and then our
09:26 - script continued on to print that our
09:28 - script finished after one second now if
09:31 - using threads seems a bit complicated
09:32 - right now
09:33 - then definitely stick around until the
09:35 - end of the video because we're gonna see
09:36 - an easier way of how to do what we're
09:38 - doing here but I think it's important to
09:40 - understand what this is doing so far
09:42 - even if we use other methods where we
09:44 - don't manually call these start and join
09:46 - methods okay so right now we're not
09:48 - really getting that big of a speed-up
09:50 - here so our code ran in two seconds
09:52 - before and now it's running in one
09:55 - second but that's because our function
09:57 - doesn't take too long and we're only
09:58 - running it twice but what if we wanted
10:01 - to run our function ten times well if we
10:03 - were to run our code synchronously where
10:05 - it runs one after the other then we can
10:08 - take a guess that it would take about
10:09 - ten seconds since one would have to
10:11 - finish before another started but if we
10:13 - ran this with threads then it should
10:16 - still be around one second to complete
10:18 - so let's go ahead and see an example
10:20 - with this now instead of manually
10:21 - creating ten different threads let's
10:23 - instead create and start these threads
10:25 - and a loop so to do this I'm going to
10:28 - come up here and copy this threading
10:31 - part here and now I'm just going to
10:34 - remove everything that we had here
10:35 - before and now I'm just going to create
10:38 - a loop so I'll say for underscore in
10:40 - range of ten and then I'm gonna say T
10:45 - for our thread is equal to threading dot
10:48 - thread with a target of do something and
10:51 - now let's also start that thread within
10:53 - our loop now if none of you have ever
10:55 - seen an underscore in Python here
10:58 - basically this just means it's a
10:59 - throwaway variable because all we want
11:01 - to do is a loop over these ten numbers
11:04 - here but we're not actually doing
11:05 - anything with it
11:06 - I just have an underscore variable so
11:09 - that just to say that we're not using
11:11 - anything within the loop okay so now we
11:13 - have our loop here and our threads are
11:14 - starting but we can't actually do a tea
11:17 - or a thread dot join within the loop
11:20 - because it would join on the thread
11:22 - before looping through and creating and
11:24 - starting the next thread so it would
11:26 - basically be the same as running the
11:28 - code synchronously so we need a way that
11:30 - we can start all of these threads in one
11:32 - loop and then loop through the threads
11:34 - again and run the join method on them so
11:37 - that they all finish before the end of
11:38 - our script so to do this we can append
11:41 - each thread that we create to a list of
11:43 - threads so above the for loop here I'm
11:46 - going to create a list of threads and
11:49 - this is just going to be empty for now
11:51 - and now below T dot start I'm going to
11:54 - say threads dot append and we will
11:58 - append each thread that we started so
12:01 - now once we go through this loop we
12:03 - should have a list of all these threads
12:05 - that we started so now let's run join on
12:07 - all of those so I'll say for thread in
12:11 - threads and then we will do a thread dot
12:17 - join ok so now we're actually running
12:20 - this do something function ten times and
12:22 - it sleeps for one second every time but
12:25 - since we're using threads it's just
12:27 - going to keep moving forward each time
12:29 - we sleep so instead of taking ten
12:31 - seconds let's run this and see how long
12:33 - it takes so we can see all those got
12:35 - kicked off and our scripts still
12:37 - finished in just one second okay so
12:40 - that's pretty good so we've already
12:41 - taken a script that normally would take
12:43 - ten seconds and we've instead finished
12:45 - it in one second okay so now let's look
12:48 - at how we can pass in arguments into our
12:50 - function so right now we're running a
12:52 - function that doesn't accept any
12:54 - arguments but let's add a couple real
12:56 - quick so we can see what this looks like
12:57 - so right now we're just sleeping for one
12:59 - second but let's add an argument that
13:02 - specifies how long we actually want to
13:04 - sleep so up here and our dosomething
13:07 - function I'm going to pass in an
13:08 - argument and I'll just call this seconds
13:11 - and now I will say that we are sleeping
13:14 - for however many seconds and this needs
13:18 - to now be
13:20 - and F string so that we can pass in the
13:22 - variable like that and now instead of
13:25 - sleeping for one second we'll sleep for
13:27 - the number of seconds that we passed in
13:30 - as a variable here and just so this
13:32 - doesn't say sleeping for 10 second or
13:35 - something like that let's also say that
13:37 - this could be seconds as well okay okay
13:39 - so now our function is expecting an
13:41 - argument for the number of seconds to
13:43 - sleep so let's pass in seconds as an
13:46 - argument and we need to pass that in as
13:48 - a list of arguments so down here where
13:51 - we create our thread this is where we're
13:53 - going to pass in our arguments so this
13:55 - is just an args argument and we will
13:58 - pass this in as a list now we only have
14:00 - one argument so this is just going to be
14:02 - a list of one value so let's sleep for
14:05 - 1.5 seconds and stell and instead so now
14:08 - we should expect our function to take
14:10 - about 1.5 seconds every time so if I
14:13 - save this and run it then we can see
14:15 - that now we are finished with our entire
14:19 - script in 1.5 seconds and this still ran
14:22 - at this function ten times so normally
14:24 - this would take 15 seconds if we were
14:26 - growing this synchronously but now we're
14:28 - finishing it in 1.5 seconds okay so I
14:31 - said before that I was going to show you
14:32 - the older way of doing threads and then
14:35 - I'd also show you what I believe is a
14:37 - faster and easier way of doing this now
14:39 - I still wanted to show you the manual
14:41 - way of creating these threads because I
14:43 - think this can still be useful depending
14:45 - on what you're doing but I also think
14:47 - it's better to learn this manual way
14:49 - first to understand a little bit better
14:51 - of what's going on in the background but
14:54 - in Python 3.2 they added something
14:56 - called a thread pool executor and in a
14:59 - lot of cases this is going to be an
15:00 - easier and more efficient way to run
15:02 - these threads and it also allows us to
15:04 - easily switch over to using multiple
15:07 - processes instead of threads as well
15:09 - depending on the problem that we're
15:11 - trying to solve so let's replace what we
15:14 - currently have and instead use this
15:16 - thread pool executors now this is
15:18 - actually not in the threading module
15:20 - it's in the concurrent futures module so
15:23 - at the top instead of using importing
15:26 - the threading module I'm going to import
15:29 - and I don't think I even need threading
15:31 - anymore so I'm just going to import
15:33 - current dot futures and when we use this
15:37 - thread pool executors it's usually best
15:39 - to use this with a context manager so
15:42 - above our threads list here I'm just
15:44 - going to do the same thing that we
15:45 - already have
15:46 - using the concurrent futures module
15:49 - instead so to do this I'm just gonna say
15:51 - with and let me go ahead and exit out so
15:54 - we can see a little bit more of the
15:55 - screen here so I'm gonna say with
15:57 - concurrent dot futures dot and this is
16:01 - thread pull whoops let me spell that
16:04 - correctly thread pull executors and we
16:09 - will say as executor there and now with
16:14 - our executors there are a couple of
16:16 - different methods that we can use so if
16:18 - we want to execute the function once at
16:20 - a time then we can use the submit method
16:23 - so the submit method schedules a
16:25 - function to be executed and returns a
16:27 - future object so let's add this in and
16:30 - I'll explain this a little bit more so
16:32 - I'll say F 1 is equal to executors dot
16:36 - submit and we will now pass in the
16:40 - function and the arguments so I'm gonna
16:43 - say do something is the function that we
16:45 - want to run and we'll just pass in an
16:48 - argument of one for one second so again
16:51 - the submit method schedules a function
16:53 - to be executed and returns a future
16:55 - object now a future object basically
16:58 - encapsulate s' the execution of our
17:00 - function and allows us to check in on it
17:03 - after it's been scheduled so we can
17:05 - check that it's running or if it's done
17:07 - and also check the result so if we grab
17:10 - the result then it'll give us the return
17:12 - value of the function now right now
17:14 - we're just printing out values and not
17:16 - returning anything but let me add a
17:18 - return value so that we can grab that so
17:21 - instead of printing out that we are done
17:23 - sleeping here instead let me return that
17:26 - string of done sleeping and okay let me
17:30 - take out these parentheses here okay so
17:33 - now we are returning that string instead
17:35 - of printing it out so if we still want
17:38 - to print that then we need to print the
17:40 - return value of that function so let's
17:42 - grab that by using the result method so
17:45 - here within
17:46 - the context manager I'm just going to
17:49 - say print and we will print f1 dot
17:52 - result now if we run the result method
17:55 - here then it will actually wait around
17:57 - until the function completes
17:59 - okay so let's comment out what we had
18:01 - before
18:02 - so all of this code here is how we did
18:04 - threads previously and now let's run
18:08 - this code with our new thread pool
18:11 - executors here okay so we can see that
18:13 - that works and that's a lot less code
18:15 - than we had down here that's commented
18:17 - out and if we wanted to run this
18:19 - multiple times then we could run submit
18:22 - multiple times as well so above our f1
18:27 - result let me create another future
18:31 - object here so this will be F two we'll
18:35 - just keep everything else the same and
18:36 - now let's also print out the f2 result
18:41 - so if I save that and run it then we can
18:45 - see both of those got kicked off at the
18:46 - same time and that we finished our
18:48 - script in one second and if we wanted to
18:50 - run this ten times like we did before
18:52 - then we likely wouldn't want to run
18:54 - submit ten two different times so we
18:56 - could use a loop like we did before so
18:59 - instead of running one at a time I'm
19:01 - instead going to use a loop and we could
19:04 - use a regular loop like we did before
19:05 - but I'll go ahead and use a list
19:08 - comprehension to create these instead so
19:10 - we could say let me just copy this
19:14 - entire submit line here and instead I'm
19:18 - going to say results is equal to and now
19:22 - let's create a list comprehension so I'm
19:25 - going to say that we want to run
19:26 - executors dot submit with our do
19:29 - something function and an argument of
19:31 - one second four and then just an
19:34 - underscore for two as a throwaway
19:36 - variable in range of ten now if you've
19:40 - never used a list comprehensions before
19:41 - then I do have a separate video on that
19:44 - if you'd like to see exactly how this
19:46 - works but again if you're not familiar
19:47 - with list comprehensions then you can
19:50 - use a regular for loop like we did down
19:52 - here at the bottom okay so now we've
19:54 - created a list comprehension that's
19:56 - running our submit function ten
19:57 - different times with an argument of one
19:59 - sec
20:00 - now in order to get these results we can
20:02 - actually use another function from the
20:04 - concurrent futures module called as
20:06 - completed now this will give us an
20:08 - iterator that we can loop over that will
20:11 - yield the results of our threads as they
20:13 - are completed so I think this is a
20:15 - really useful method so to use this we
20:18 - can just say I'm going to get rid of our
20:21 - lines here and I'm just going to say for
20:23 - F in concurrent dot futures and then dot
20:29 - as underscore completed and we want to
20:32 - pass in our results list here to our as
20:36 - completed method and within this list we
20:39 - can just say print F dot result so if we
20:44 - run this then we can see that it still R
20:47 - in it ran that ten times and if we
20:50 - scroll down to the bottom here then we
20:51 - can see that it still ran this in one
20:53 - second now to prove that these are
20:55 - actually coming in as they're completed
20:57 - let me actually pass in a different
20:59 - range of seconds for our threads to
21:01 - sleep and those should print out in the
21:03 - order that they complete so I'll create
21:05 - a list of seconds to sleep here so above
21:09 - our results I'm just going to create
21:11 - another list and I will call this sex is
21:15 - equal to and I'll do five four three two
21:18 - and one
21:19 - and now instead of use passing in one
21:23 - here I'm instead going to pass in a
21:25 - second for a second in our list of
21:31 - seconds and I'm also going to print out
21:34 - the seconds in the return statement as
21:35 - well that way we can see which ones are
21:38 - finishing and in what order so I'm going
21:40 - to make this an F string as well and
21:42 - just here at the end I will just print
21:45 - out the seconds argument that we are
21:47 - passing in so again what our list
21:50 - comprehension here is doing is we are
21:53 - submitting this do something second with
21:55 - this argument of SEC and we are doing
21:58 - that for each value of seconds in this
22:00 - seconds list so this should get
22:02 - submitted five times with a 5 4 3 2 and
22:05 - a 1 so if I save this and run it then we
22:09 - can see that it says sleeping 5 seconds
22:12 - 4 3 but then
22:13 - the order that he's finished was that it
22:15 - was done sleeping for one second first
22:17 - then two then three them for them five
22:19 - and our total script took five seconds
22:22 - to complete now we actually started the
22:24 - five-second thread first but since we
22:26 - use that as completed method it printed
22:29 - out our results in the order that they
22:31 - completed okay so with the submit method
22:33 - its submitting each function once at a
22:36 - time now in order to run submit on an
22:38 - entire list then we need to do a loop or
22:41 - a comprehension like we did here but if
22:43 - you're familiar with the built-in map
22:45 - method in Python then there's actually
22:47 - something similar that we can do with
22:49 - threads where we can use a map method to
22:52 - run our function over a list of values
22:54 - now if you're familiar with that
22:55 - built-in Python map method then this is
22:58 - actually very similar except it uses
23:00 - threads instead so it runs the function
23:03 - with every item of the interval that we
23:06 - pass in so let's say that I want to map
23:09 - our function to our list of seconds so
23:11 - to do this we could say here let me let
23:16 - me just overwrite all of this that we
23:17 - have now and instead I will use a map
23:20 - method and say results is equal to
23:23 - executors dot map and we want to map the
23:27 - do something function and we want to
23:30 - pass in our iterator of seconds here so
23:34 - again what map is going to do is it is
23:36 - going to run the do something function
23:38 - with every value in this list of seconds
23:41 - here now when we use the submit method
23:44 - it returned a future object and when we
23:47 - use map it instead returns the results
23:50 - now it's going to still run those
23:52 - threads concurrently but instead of
23:54 - running the results as they completed
23:56 - like we saw before map is going to
23:59 - return the results and the order that
24:01 - they were started so to loop over these
24:03 - results we can just say for result in
24:08 - results and then let's just print out
24:11 - that result so if I run this then we can
24:15 - see that it started off all of our
24:17 - sleeps but nothing has returned yet and
24:20 - then it returned the done sleeping for
24:23 - five seconds four three two one
24:26 - so we can see that all of
24:27 - threads kicked off at pretty much the
24:28 - same time but then it looked like they
24:31 - completed all at the same time as well
24:33 - now they didn't actually all complete at
24:36 - the same time but when you loop over
24:38 - your results using map like we did here
24:40 - then it returns the results and the
24:42 - order that they were started so since we
24:44 - slept for five seconds first then we
24:47 - waited for that one to finish before
24:49 - printing out the other results but it
24:52 - still didn't slow us down at all we can
24:54 - see that our entire script still took
24:56 - about five seconds in total to finish
24:58 - now another thing to point out here is
25:00 - that if our function raises an exception
25:02 - then it won't actually raise the
25:04 - exception while running the thread the
25:07 - exception will be raised when its value
25:09 - is retrieved from this results iterator
25:11 - so if you need to handle exceptions then
25:14 - you can do that within the iterator if
25:16 - you'd like now if you'd like to learn
25:18 - more about handling exceptions then I do
25:20 - have a more in-depth video if you'd like
25:22 - to learn more about that and I'll be
25:24 - sure to leave a link to that video in
25:25 - the description section below for anyone
25:28 - who is interested now even if we don't
25:30 - grab all of our results within the
25:32 - context manager here it's still going to
25:34 - automatically join all of those and let
25:37 - them finish after the context manager
25:39 - ends so if we comment out where we're
25:42 - printing the results and I run this then
25:46 - we can see that it still waits until
25:48 - these are done until it gets down to the
25:51 - end of our script so it didn't do like
25:52 - it did before when we didn't have joins
25:54 - and say that we finished in zero seconds
25:56 - even though it actually wasn't finished
25:58 - yet so it's still waited for the threads
26:00 - in that thread pool to complete before
26:02 - printing out that our script was done
26:04 - okay so now that we've looked at a basic
26:07 - example using sleep now let's take a
26:09 - look at a more real-world example of
26:11 - where threading would be useful so I've
26:13 - got another script open here where I'm
26:15 - not using threading at the moment so let
26:18 - me pull this up and let's take a look at
26:20 - what this is doing and again I'm gonna
26:22 - have a link to this code in the
26:23 - description section below for anyone who
26:25 - wants to follow along so this is a
26:27 - script that goes out and downloads some
26:29 - high resolution photos from unsplash now
26:32 - if you don't know what unsplash is it's
26:34 - a website that has some really nice free
26:36 - photos available for anyone to use so
26:39 - let me go over this script and
26:41 - show how someone might do this normally
26:44 - so normally you might have a bunch of
26:46 - image URLs here that you want to
26:48 - download and now let's say we actually
26:50 - want to download those so somebody might
26:52 - say okay so for each image URL and our
26:55 - image URLs let's use the request library
26:58 - to go out and get that content and now
27:01 - I'm just doing some string parsing here
27:03 - to parse out the image name which would
27:05 - just be this section right here so I'm
27:07 - grabbing the image name and then putting
27:09 - a dot jpg on to the end of that and now
27:11 - I'm opening a file here in byte mode and
27:14 - then I am writing those image bytes that
27:17 - we downloaded from the internet onto our
27:19 - file system and then we're just printing
27:21 - out here that our image was downloaded
27:23 - okay so this script should go all
27:25 - through all of these image URLs and
27:27 - download all of these images into my
27:30 - current directory so if I run this right
27:33 - now then let's see how long this takes
27:35 - now we can see that these are
27:37 - downloading and I do have this pulled up
27:39 - here in my file system as well so we can
27:42 - see that it is going out and downloading
27:44 - these but it's downloading them one at a
27:46 - time so there should be 15 total here so
27:50 - once this is finished
27:51 - then we can get an idea of how long this
27:53 - took and it should be done any second
27:56 - now okay so we can see that this
27:59 - finished in 23 seconds to download those
28:02 - 15 high-resolution photos online now
28:06 - when we're downloading a lot of things
28:07 - online this is actually a great
28:09 - candidate to use threading because this
28:11 - is one of those IO bound operations that
28:13 - is actually spending a lot of time just
28:16 - waiting around it's not it's going out
28:18 - and waiting for a response from the site
28:20 - and it's not moving on to the next URL
28:23 - until that gets an entire response back
28:26 - so if we use threads that then it can
28:28 - actually go ahead and move on to the
28:31 - next URL while that's waiting around for
28:33 - a response and we can make other
28:35 - requests at the same time okay so now
28:37 - let's see how we can change this code
28:39 - that someone might normally write and
28:41 - instead change this to where it's using
28:44 - threads instead and see if we can speed
28:46 - this up so first let's think about what
28:48 - we're doing here
28:49 - so we're looping over our list of image
28:52 - URLs and then using the request
28:55 - library to download those one at a time
28:57 - so if we remember from our previous
28:59 - example this would be a pretty good
29:01 - candidate for the threading pull map for
29:05 - the threading pull map method where we
29:07 - can pass in a function and a list and
29:10 - have that function run with every value
29:13 - in that list
29:14 - and if that doesn't make sense right now
29:15 - then well it should make more sense once
29:18 - we actually change this code here but
29:20 - first we're gonna have to actually
29:22 - create a function that will download the
29:25 - data from a single URL so to do that we
29:28 - can just say I'm just going to change
29:30 - this for loop here and I'm gonna turn
29:32 - this into a function so I'm gonna say
29:34 - download underscore image and we want to
29:38 - pass in an argument of the image URL and
29:42 - everything within this function can just
29:44 - stay the same because we were looping
29:45 - over that before and now we just turn
29:49 - that into a function where we are just
29:51 - downloading one image URL at a time so
29:53 - it's basically the same thing as our for
29:55 - loop for now ok so now that we have a
29:57 - function that downloads one image at a
29:59 - time now we can create a thread pool and
30:02 - map our list of URLs using that function
30:05 - that we just created
30:06 - so first let's import the concurrent
30:09 - futures module so that we can use that
30:10 - so here at the top I'm going to actually
30:14 - let me put this below time here I will
30:16 - import concurrent dot futures and now
30:21 - down here below our function let's
30:25 - create a thread pool executor so just
30:28 - like before that was concurrent dot
30:31 - futures and we're using this within a
30:33 - context manager we want this to be a
30:35 - thread pool executors make sure I spell
30:39 - that correctly and we will say as
30:43 - executor therefore our context manager
30:46 - okay so now if we use that map method so
30:50 - I'm going to say executors dot map and
30:52 - we want to run this function and let's
30:58 - pass in our list of image URLs and again
31:03 - just to go over this one more time the
31:06 - map method here what it
31:08 - do is it will run this download image
31:10 - function with each value in this image
31:13 - URLs list but since we're using a thread
31:16 - pool executors it's going to actually
31:18 - down those download those with a
31:20 - different thread for each one so just
31:23 - with those small changes this will
31:25 - actually use threads and make those
31:27 - requests asynchronously instead of
31:29 - synchronously like we saw before so now
31:32 - if I run this code to download all these
31:36 - images again then we can see that these
31:38 - are coming in a lot faster because it's
31:40 - using threads instead of doing this
31:42 - synchronously so now we can see that it
31:44 - finished in five seconds instead and if
31:47 - you remember before we ran that it was
31:48 - taking 23 seconds so that's a pretty
31:51 - significant speed-up and this would be
31:53 - even more significant if we were doing
31:55 - even more requests so the speed ups can
31:58 - be you know pretty drastic depending on
32:00 - what we're actually doing now what would
32:03 - be an example of something that wouldn't
32:05 - be i/o bound well if something is doing
32:07 - a lot of computation then threads
32:10 - actually wouldn't be ideal for that type
32:12 - of task so if we are processing the
32:14 - photos and resizing them and things like
32:17 - that instead of just downloading them
32:18 - from line then the threads wouldn't
32:21 - actually speed that up all that much so
32:24 - that would actually be an example of
32:25 - something that is CPU bound and not IO
32:27 - bound and like I said before in those
32:30 - kinds of scenarios threads can actually
32:32 - slow down our script instead because the
32:35 - threads have some overhead when being
32:36 - created and destroyed so it really
32:39 - depends on what you're doing and what
32:40 - are to decide if the right choice to
32:43 - speed up your program is threading or
32:45 - multi-processing
32:46 - so when you're doing something that
32:47 - requires a lot of processing then we can
32:50 - use multi processing instead of
32:52 - threading so with that said in the next
32:54 - video let's go ahead and process these
32:57 - photos that we just downloaded and do
32:59 - some image manipulation to them and then
33:01 - we can take a look at the multi
33:03 - processing module to see how we can
33:05 - speed up that task as well that way we
33:08 - can see the difference between threading
33:10 - and multi processing and when you might
33:12 - want to use one over the other now
33:14 - before we finish up here I'd like to
33:16 - mention the sponsor of this video and
33:17 - that is brilliant org so we've been
33:20 - talking a lot about thread
33:22 - and multiprocessing and these topics are
33:24 - especially useful in the field of data
33:26 - science and data science is a field that
33:29 - is growing at a very rapid pace if you'd
33:32 - like to learn more about programming and
33:33 - data science then I would definitely
33:35 - recommend checking out brilliant org so
33:37 - brilliant is a problem-solving website
33:39 - that helps you understand underlying
33:41 - concepts by actively working through
33:43 - guided lessons and they've recently
33:45 - added some brand-new interactive content
33:48 - that makes solving puzzles and
33:50 - challenges even more fun and hands-on
33:52 - and if you'd like to learn more about
33:53 - data science and programming with Python
33:55 - then I would recommend checking out
33:57 - their new probability course that covers
33:59 - everything from the basics to real-world
34:01 - applications and also fun things like
34:04 - casino games they even use Python in
34:06 - their statistics courses and will quiz
34:08 - you on how to correctly analyze the data
34:11 - within the language so they're guided
34:13 - lessons will challenge you but you also
34:14 - have the ability to get hints or even
34:16 - solutions if you need them it's really
34:18 - tailored towards understanding the
34:20 - material they even have a coding barment
34:22 - built into their website so that you can
34:24 - run code directly in the browser and
34:26 - that is a great complement to watching
34:28 - my tutorials because you can apply what
34:30 - you've learned in their active
34:31 - problem-solving environment and that
34:33 - helps to solidify that knowledge so to
34:35 - support my channel and learn more about
34:37 - brilliant you can go to brilliant org
34:39 - forge / CMS to sign up for free and also
34:43 - the first 200 people that go to that
34:45 - link will get 20% off the annual premium
34:48 - subscription and you can find that link
34:49 - in the description section below and
34:51 - again that is brilliant dot org forge /
34:54 - CMS okay so I think that is going to do
34:57 - it for this video I hope you feel like
34:59 - you've got a good idea of how to use the
35:00 - threading module and how we can use this
35:02 - to speed up our scripts now there are
35:04 - some more advanced topics that we could
35:06 - cover in the future with threads such as
35:08 - thread local data race conditions locks
35:11 - and things like that but we'll save that
35:13 - for a future video if anyone is
35:14 - interested and like I said in the next
35:17 - video we'll see how to use the multi
35:18 - processing module to do the same thing
35:20 - that we did in this video but instead
35:23 - the task will be image processing
35:25 - instead of downloading images but if
35:28 - anyone has any questions about what we
35:29 - covered in this video then feel free to
35:31 - ask in the comment section below and
35:32 - I'll do my best to answer those and if
35:34 - you enjoy these tutorials and would like
35:35 - to spore
35:36 - them then there are several ways you can
35:37 - do that the easiest ways to simply like
35:39 - the video and give it a thumbs up and
35:40 - also it's a huge help to share these
35:42 - videos with anyone who you think would
35:43 - find them useful and if you have the
35:44 - means you can contribute to patreon and
35:46 - there's a link to that page in the
35:48 - description section below be sure to
35:49 - subscribe for future videos and thank
35:51 - you all for watching
36:02 - you