00:00 - hey there how's it going everybody in
00:01 - this video we're gonna be learning how
00:02 - to run code in parallel using the multi
00:04 - processing module now if you'd also like
00:07 - to learn about running code concurrently
00:08 - using the threading module then I did
00:11 - recently put out a video on that as well
00:12 - so I'll be sure to leave a link to that
00:14 - video in the description section below
00:15 - now if you don't know the difference
00:17 - between threading and multi processing
00:19 - then you should have a grasp on a
00:20 - difference between those once we're
00:22 - finished now I would like to mention
00:23 - that we do have a sponsor for this video
00:25 - and that is brilliant org so I really
00:28 - want to thank brilliant for sponsoring
00:29 - the video and it would be great if y'all
00:31 - could go and check them out using the
00:32 - link in the description section below
00:33 - and support the sponsors and I'll talk
00:36 - more about their services in just a bit
00:37 - so with that said let's go ahead and get
00:39 - started
00:40 - ok so first why would we want to use
00:43 - multi processing so basically we want to
00:45 - use multi processing whenever it's going
00:47 - to significantly speed up our program
00:49 - now the speed-up comes from different
00:52 - tasks running in parallel now in this
00:54 - video we're gonna start off with a basic
00:56 - example of where we learn how to run
00:58 - some simple sleep methods in parallel
01:00 - but then we'll finish up with a
01:02 - real-world example where we do some
01:04 - image processing on a directory of high
01:06 - resolution images I want to show that
01:08 - real world example because personally
01:10 - when I watch tutorials that only show
01:13 - how it works on basic examples then I
01:15 - always feel like I don't really walk
01:16 - away with any useful knowledge so we'll
01:18 - use the sleep method to get a good idea
01:20 - of how to use multi processing and then
01:23 - we'll be sure to go over the more
01:24 - complicated real world example of image
01:26 - processing so let's go ahead and get
01:28 - started so I have a starting script open
01:31 - here and if you'd like to follow along
01:32 - then I'll be sure to have a link to this
01:35 - code in the description section below
01:36 - and like I said we'll start with a very
01:39 - simple example to see how this works and
01:41 - then build up with more realistic
01:43 - examples so let me go over the script
01:45 - that I currently have open here so first
01:48 - I'm importing time and I'm just using
01:50 - time to measure how long it takes the
01:53 - script to run and that's also what this
01:55 - is here this is just a start time for
01:58 - our script and then we have a function
02:00 - here called do something and all this is
02:02 - doing is printing that we are sleeping
02:04 - for one second then we actually sleep a
02:06 - second using that time module and then
02:09 - we are printing out that we are done
02:10 - sleeping and then we are actually
02:12 - executing that function
02:13 - so it should do all of this and then we
02:16 - are calculating the finish time and
02:17 - printing out that our script is finished
02:19 - okay so if I run the code that we have
02:22 - right now we can see that it said that
02:24 - it was sleeping for one second
02:25 - done sleeping and that we finished in
02:27 - about one second and that sounds about
02:29 - right since we were running our do
02:31 - something function one time and that
02:33 - sleeps for one second and if we were
02:35 - running that function twice then our
02:36 - program will likely takes two seconds so
02:39 - let's go ahead and see that so right
02:41 - below do something here I'm going to run
02:44 - this again and if I run that then we can
02:48 - see that now that it printed out that it
02:50 - was sleeping for one second twice and
02:52 - that it took about two seconds so we can
02:55 - see that each time we run at this do
02:57 - something function it's adding about one
02:59 - second to our script so our script is
03:01 - just waiting around sleeping for a
03:03 - second and once that's done it moves on
03:06 - to run that next function and sits
03:08 - around waiting for another second and
03:10 - then at that point we're basically done
03:12 - and our script finishes now I created a
03:15 - quick graphic to try to represent what
03:16 - this looks like so let me bring that up
03:18 - here in my browser real quick and this
03:21 - is actually the second graphic we'll go
03:22 - over that in just a second okay so this
03:25 - is basically what it looks like for our
03:28 - script to be executed right now so we
03:30 - are running a function in this case it's
03:33 - that do something function and then this
03:35 - is just coming up here and waiting and
03:37 - executing for one second and once that
03:39 - one second is over then we come back and
03:41 - we execute this another function and
03:43 - it's that same function again so then it
03:46 - comes up here and executes this sleep
03:48 - for one second again and when that one
03:50 - second is done then we can come down
03:52 - here and print that our script is done
03:54 - and running everything in order like
03:56 - this is called running it synchronously
03:58 - now if you have some tasks that don't
04:00 - need to be run synchronously then we can
04:02 - use the multi processing module to split
04:04 - these tasks up onto other CPUs and run
04:07 - them at the same time now if you watch
04:09 - my last video on threading then I
04:11 - mentioned that tasks we're going to
04:14 - either be I Oh bound or CPU bound so CPU
04:18 - bound tasks are things that are
04:19 - crunching a lot of numbers and using the
04:21 - CPU and i/o bound tasks are things that
04:24 - are waiting for input and output
04:26 - operations to
04:27 - completed and they're not really using
04:29 - the CPU all that much so some other
04:31 - examples of i/o bound tasks include file
04:34 - system operations and network operations
04:36 - like downloading stuff online
04:38 - now in that threading video I mentioned
04:40 - that we wouldn't get much of a speed-up
04:42 - when using threading on CPU bound tasks
04:44 - because those threads are still only
04:47 - running one process but with multi
04:49 - processing we're going to actually
04:51 - spread the work out on the multiple
04:52 - processors on our machine and run those
04:55 - tasks on at the same time so we can use
04:57 - this with both IO bound tasks and CPU
05:00 - bound tasks so it really just depends on
05:02 - what we're doing and your computer's
05:04 - hardware that will determine if it's
05:06 - better to use threading or multi
05:07 - processing but with that said let's look
05:10 - at what it looks like to run something
05:12 - in parallel using multi processing and
05:14 - I've got another graphic put together of
05:16 - what this would look like so in this
05:18 - example we can see that we still have
05:20 - our two tasks but now we're just
05:22 - breaking these up onto two different
05:24 - processes and unlike with threading
05:27 - where we were running these concurrently
05:29 - and I said that running concurrently
05:30 - doesn't necessarily mean that they're
05:32 - running at the same time with multi
05:35 - processes these actually are running at
05:37 - the same time on different processes so
05:39 - we can see here that once we kick off
05:42 - our multiple processes and we spread out
05:45 - our tasks onto those processes then we
05:47 - can just run each of these functions one
05:50 - time and then both of these will sleep
05:52 - for a second and then once they're both
05:54 - done we'll come down here and print that
05:57 - they're done okay so now that we've
05:58 - talked about multiply processing and
06:00 - what it looks like to run code in
06:01 - parallel now let's see how to actually
06:05 - do this with our current script
06:07 - so first let's import the multi
06:09 - processing module so this is in the
06:11 - standard library so we don't need to
06:13 - install anything so up here at the top
06:16 - I'm just going to say import multi
06:19 - processing now I'm gonna show an older
06:22 - way of how to do multi processing first
06:23 - so that we can get a good idea of what's
06:25 - going on but if it seems confusing at
06:27 - first then definitely stick around
06:28 - because I'm also going to show some
06:30 - newer ways of doing multi processing
06:32 - using pools that allow us to add this to
06:35 - our program with just a few lines of
06:37 - code
06:38 - okay so first instead of run
06:41 - do something function twice in a row
06:43 - like we have here let's instead turn
06:46 - both of these and two processes so to do
06:48 - this I'm just going to create two
06:50 - processes and for both of these we can
06:53 - just say p1 is equal to multiprocessing
06:56 - dot process and now we are going to pass
07:00 - in a target and the target is the
07:03 - function that we want to run so if I
07:05 - want to run let's do something function
07:07 - then I can pass in do something now we
07:10 - want to pass in the actual function and
07:13 - not the return value of the function so
07:15 - we don't want to execute the function
07:16 - with parentheses like this we just want
07:19 - to pass it in with no parentheses okay
07:22 - so now that will be one process and now
07:25 - if I do a p2 is equal to
07:28 - multi-processing process with a target
07:31 - of do something then that will be our
07:33 - second process okay so at this point
07:36 - we've created two process objects but
07:39 - we're not actually running that code so
07:41 - if I run this right now then we can see
07:45 - that it says that it finished
07:46 - immediately but nothing from our
07:48 - function printed out
07:49 - so our functions act didn't actually run
07:51 - so in order to get our processes to run
07:54 - we need to use the start method on each
07:56 - one so down here below our p2 I'm going
08:00 - to say p1 dot start to start that first
08:03 - process and P 2 dot start to start that
08:07 - second process okay so now that will
08:11 - actually run our processes but it might
08:13 - not do exactly what we think it'll do so
08:16 - if we run this then we can see that now
08:20 - it runs the functions but it said that
08:22 - our script was finished in zero seconds
08:25 - and then it said that we were sleeping
08:28 - for one second twice because we ran that
08:30 - function twice and then it said that it
08:32 - was done sleeping now our entire script
08:35 - didn't actually complete in zero seconds
08:37 - it actually took around one second but
08:40 - the reason that it says that it
08:41 - completed at zero seconds is because
08:43 - after it started both of these processes
08:46 - here while those processes were sleeping
08:50 - our script continued running and came
08:52 - down here and calculated out
08:55 - finish time and printed out that our
08:57 - script was finished in zero seconds and
08:59 - then it kicked off these processes now
09:03 - actually I think that I just said that
09:05 - it started sleeping first before it
09:07 - printed it out that we were finished but
09:09 - these processes take a little bit longer
09:11 - to spin up than threads so it actually
09:13 - didn't even start our processes first it
09:15 - actually came down here and printed that
09:17 - we were finished before the sleep
09:19 - statements even first got executed so it
09:22 - printed that before it said we were
09:24 - sleeping and then after a second we were
09:27 - done so basically what this is doing is
09:29 - it's kicking off our processes but then
09:31 - it's going down here and running the
09:33 - rest of our script before our process is
09:36 - finished now what if we wanted our
09:37 - processes to finish before we calculated
09:40 - the finish time and before we print it
09:41 - out that our script is finished so in
09:44 - order to do this we can use the join
09:46 - method so to do this right below start
09:49 - I'm gonna say p1 dot join and P 2 dot
09:54 - join so when we run that join method it
09:57 - means that the process will finish
09:58 - before moving on in the script so now if
10:02 - we run this then we can see that both
10:05 - processes started at almost the same
10:08 - time and then they both printed that
10:10 - they were done sleeping after one second
10:12 - and then our script continued on to
10:14 - print that our script had finished in
10:16 - about one second now if using multi
10:20 - processing seems a bit complicated right
10:21 - now then definitely stick around until
10:24 - the end of the video because we're going
10:26 - to see an easier way of how to do what
10:28 - we're doing here but I think it's
10:29 - important to understand what this is
10:31 - doing so far even if we use other
10:34 - methods where we don't actually manually
10:36 - call these start methods and join
10:38 - methods ok so right now we're not really
10:41 - getting that big of a speed-up
10:42 - now so our code ran in two seconds
10:45 - before and now it's running in one
10:47 - second but that's because our function
10:49 - doesn't take too long and we're only
10:51 - running it twice but what if we wanted
10:53 - to run our function ten times well if we
10:56 - were to run our code synchronously then
10:58 - we can take a guess that it would take
11:00 - ten seconds since our since one would
11:03 - have to finish before the other and we'd
11:05 - be running ten in a row but if we ran
11:07 - this with multiple
11:08 - then it should be significantly faster
11:11 - so let's see an example of this
11:13 - now instead of manually creating ten
11:16 - different processes let's instead create
11:18 - and start these in a loop so to do this
11:21 - I can come up here and I'm gonna copy
11:24 - this whole part here and now I'm just
11:28 - going to overwrite all the code that we
11:30 - have here so far and I'm gonna say for
11:32 - underscore in range of ten and we'll say
11:38 - P is equal to multiprocessing dot
11:41 - process with a target set to the do
11:43 - something function and now let's also
11:46 - start that process here within our loop
11:49 - now if you're unfamiliar with the
11:51 - underscore in Python basically that's
11:53 - just a throw away variable name it's
11:55 - just saying that we're not actually
11:57 - using the integer from this range and
12:00 - the loop so we just have something as a
12:02 - throwaway variable there so we're
12:04 - starting all these processes here within
12:06 - our loop but we can't do a P dot join
12:10 - within the loop because it would run
12:12 - join on the process before looping
12:15 - through and creating and starting the
12:17 - next process in the loop so it would
12:20 - basically be the same as running it
12:21 - synchronously so we need a way that we
12:24 - can start all of these processes in one
12:26 - loop and then loop through those
12:28 - processes again and run the join method
12:30 - on them so that they all finish before
12:33 - the end of our script so to do this
12:35 - let's just append each process to a list
12:39 - so above our for loop here I'm just
12:42 - going to create a list called processes
12:45 - and set that to an empty list and then
12:48 - below P dot start I'm going to say
12:50 - processes dot append and I will append
12:54 - each process to our processes list and
12:57 - now here below our for loop I'm going to
13:02 - say for process in processes let's do a
13:07 - process dot join okay so just one more
13:12 - time here we are looping over a range of
13:16 - 10 so we're going to do this loop 10
13:18 - times here and each time through the
13:20 - loop we are creating a new process
13:22 - with this target of do something and we
13:25 - are starting that process and then we
13:27 - are appending that process to a
13:30 - processes list so then after that loop
13:33 - is complete and all of our processes
13:35 - have been started we're coming through
13:36 - and looping over all those processes and
13:38 - we are joining them and again when we
13:40 - join a process when we run the joint
13:42 - method it means that it is going to wait
13:45 - until that finishes before continuing on
13:48 - to the rest of the script so it'll
13:49 - finish before it comes down here and
13:51 - calculates the finish time and prints
13:53 - that our script is finished so we're
13:55 - running this do something function ten
13:57 - times and it sleeps for one second every
14:00 - time but since we're using multiple
14:01 - processes it'll just run all of these in
14:04 - parallel at the same time so instead of
14:06 - it taking ten seconds let's save this
14:08 - and run this and see how long it
14:10 - actually takes so we can see that even
14:14 - running the function ten times we're
14:16 - still finishing this in about one second
14:19 - now that might seem a little strange
14:20 - because I don't actually have ten cores
14:23 - on this machine but your computer has
14:25 - ways of switching off between cores when
14:29 - one of them isn't too busy so even
14:31 - though we had more processes than we do
14:33 - cores it's still finished in about a
14:35 - second so that's pretty good okay so now
14:37 - let's look at how we can pass in
14:39 - arguments into our function so right now
14:41 - we're running a function that doesn't
14:43 - accept any arguments but let's add a
14:46 - couple of arguments real quick so right
14:48 - now we're just sleeping for one second
14:50 - so let's add an argument that specifies
14:52 - how long to sleep so up here we will
14:56 - accept an argument and I'm just going to
14:58 - pass in an argument of seconds and let's
15:01 - also change that we are going to sleep
15:04 - for that number of seconds and let me
15:09 - also put a parenthesis there as well now
15:13 - this needs to be an EPS string since
15:15 - we're now using this variable here
15:17 - within our string now I want to sleep
15:20 - for that number of seconds okay so with
15:23 - that small change our dosomething
15:25 - function now accepts an argument of
15:27 - seconds and then it'll print out that
15:29 - we're sleeping for that number of
15:31 - seconds and then it will actually sleep
15:32 - for that number of seconds so let's pass
15:35 - in seconds as an argument to this
15:38 - function and we need to pass that in as
15:41 - a list of arguments to our process so
15:44 - I'll say down here where we are saying
15:47 - that our target is that do something
15:49 - function we can also pass in an argument
15:51 - of args and we'll pass that in as a list
15:55 - of arguments so I'll do 1.5 so now
15:58 - instead of sleeping for one second ever
16:01 - for 10 different times now it's going to
16:03 - sleep for 1.5 seconds for 10 different
16:06 - times now unlike with threads in order
16:09 - to pass arguments to a multi-processing
16:11 - process the arguments must be able to be
16:14 - serialized using pickle now if you don't
16:17 - know what that means
16:18 - basically serializing something with
16:20 - pickle means that we're converting
16:22 - Python objects into a format that can be
16:25 - deconstructed and reconstructed in
16:27 - another Python script so now we should
16:31 - expect our function to take 1.5 seconds
16:34 - instead so if I save this and run it
16:37 - then we can see that now our script is
16:39 - finishing in about 1.5 seconds ok so I
16:43 - said before that I was going to show you
16:45 - the older way of doing multi processing
16:47 - and then I'd show you what I believe is
16:49 - a faster easier way of doing this and I
16:52 - still wanted to show you the manual way
16:54 - of creating these processes because I
16:56 - think this can still be useful depending
16:58 - on what you're doing and also I think
17:00 - it's better to learn this manual way
17:02 - first to understand a bit better what's
17:04 - going on in the background but in Python
17:07 - 3.2 they added something called a
17:09 - process pull executor and in a lot of
17:12 - cases this will be an easier and more
17:14 - efficient way to run multiple processes
17:16 - and it also allows us to easily switch
17:19 - over to using multiple threads instead
17:21 - of processes as well depending on the
17:23 - problem that we're trying to solve so
17:25 - let's replace what we're current what we
17:27 - currently have and instead use at this
17:30 - process pull executor now this actually
17:33 - isn't in the multi processing module
17:35 - it's in the concurrent futures module
17:37 - instead so up here at the top let's
17:41 - instead import concurrent dot futures
17:43 - and I actually don't think I need multi
17:45 - processing anymore so I'm just going to
17:47 - say import
17:48 - concur
17:49 - dot futures now I'm gonna leave
17:52 - everything else that I have here for now
17:54 - so that we can see the difference
17:56 - between these now when we use this
17:58 - process pull executors it's usually best
18:01 - to use this with a context manager so
18:04 - above our processes list here I'm going
18:06 - to do the same thing that we already
18:08 - have but just with our concurrent
18:11 - futures module instead so I'm going to
18:13 - say with concurrent dot futures dot
18:17 - process pool executors and make sure you
18:21 - get those capitalizations in the right
18:23 - place and then we will say whoops will
18:28 - say as executor and now within our or
18:32 - with our executor here there are a
18:34 - couple of different methods that we can
18:36 - use now if we want to execute the
18:38 - function once at a time then we can use
18:41 - the submit method so the submit method
18:43 - schedules a function to be executed and
18:45 - returns a future object so let's add
18:48 - this in and then I'll explain this a bit
18:50 - more so I'm going to say F 1 is equal to
18:54 - executors dot submit and I will submit
18:58 - that do something function and let's
19:01 - also pass in an argument of one so again
19:04 - the submit method schedules a function
19:08 - to be executed and returns a future
19:11 - object so a future object basically
19:14 - encapsulates the execution of our
19:16 - function and allows us to check on it
19:19 - after it's been scheduled so we can
19:21 - check that it's running or if it's done
19:24 - and also check the result so if we grab
19:27 - the result then it'll give us the return
19:29 - value of the function now right now
19:32 - we're just printing out values but let
19:34 - me add in a return value so that we can
19:36 - grab that so instead of just printing
19:39 - that we are done sleeping up here
19:40 - instead I'm going to return that string
19:44 - so I'm going to say return done sleeping
19:47 - instead of just printing that out okay
19:50 - so now that's returning that string so
19:52 - if we still want to print that out then
19:54 - we'll need to print that return value so
19:57 - let's grab that by using the result
19:59 - method on that future object so
20:02 - I'm gonna say print and we will print
20:05 - out f1 dot result now if we run the
20:09 - return method then this will wait until
20:12 - the function completes
20:13 - okay so let's comment out while we had
20:16 - before and run our code so I'm gonna
20:19 - comment out this processes list here and
20:22 - our previous starts and joins and
20:25 - instead we're just going to use this
20:27 - process pull executors okay so if I run
20:30 - this then we can see that that still
20:33 - works and that's a lot less code than we
20:35 - had down here that's commented out but
20:38 - we're still not running this multiple
20:39 - times yet like we were down here so if
20:42 - we wanted to run this multiple times
20:43 - then we could just run submit multiple
20:46 - times so I could say let me go above our
20:50 - result here I'm gonna add in another
20:53 - execution of this do something function
20:55 - so I'm going to call this f2 is equal to
20:58 - executors not submit do something with
21:02 - one second and then I will also print
21:05 - out the f2 result so if I run this then
21:11 - we can see that it's the same thing it
21:12 - kicks both of these off at the same time
21:14 - and we finished in about one second and
21:16 - if we wanted to run this ten times like
21:18 - we did below then we likely wouldn't
21:20 - want to run submit ten two different
21:22 - times so we could use a loop like we did
21:24 - before so instead of running one at a
21:27 - time I'm gonna use a loop and we could
21:29 - use a regular loop like we did below but
21:32 - I'm gonna go ahead and use a list
21:33 - comprehension to create these instead so
21:36 - we could say I'm just going to copy this
21:39 - executors dot submit part and I'm just
21:42 - going to overwrite all of this other
21:44 - stuff right now and I'm gonna say
21:45 - results are equal to then I will start a
21:49 - list comprehension here and say
21:51 - executors dot submit do something for
21:54 - one second for underscore range ten now
22:00 - if you're not familiar with list
22:01 - comprehensions like we have here then i
22:03 - do have a separate video on that as well
22:05 - so I'll put a link to that in the
22:07 - description section below if you've
22:09 - never seen this type of code before and
22:11 - if you're not comfortable using list
22:13 - comprehensions then you can always use a
22:14 - regular loop like
22:15 - we did down here below okay so now we've
22:18 - created a list comprehension that's
22:20 - running our submit method with this do
22:23 - something function and an argument of
22:25 - one second ten different times now in
22:28 - order to get these results we can
22:30 - actually use another function from the
22:32 - concurrent futures module called as
22:34 - completed and this will give us an
22:36 - iterator that we can loop over that will
22:39 - yield the results of our processes as
22:40 - they're completed so I think this is
22:43 - really useful and it's one of the good
22:45 - things about using these processing pool
22:47 - executors so to use this we can say just
22:52 - for F in concurrent oops sorry about my
22:56 - typing their concurrent dot futures dot
23:00 - as underscore completed and now we want
23:03 - to pass in this list of results which is
23:06 - a list of futures objects and now within
23:10 - this list let's print out F dot result
23:14 - so if we run this oops and it looks like
23:19 - I have some invalid syntax here oh I
23:21 - forgot to say I should have said for
23:24 - underscore in range of ten some of you
23:26 - probably saw that as I was typing it out
23:29 - okay so now if I run this then we can
23:32 - see that we slept for one second now it
23:36 - still ran ten different times but if we
23:39 - scroll down to the bottom then we can
23:41 - see how much time it took so we can see
23:43 - here that it actually took three seconds
23:46 - this time now the reason behind that is
23:48 - that our pool may have made a decision
23:51 - based on our hardware not to a lot as
23:54 - many processes so that's why it might
23:56 - take longer but even though it took
23:58 - longer in our simple little example here
24:01 - I still you like to use these processing
24:03 - pool executors most of the time because
24:06 - I trust it too a lot the processes a lot
24:09 - more than I trust myself so I pass that
24:12 - off to the process pool executors to do
24:14 - and to make that decision for me now to
24:17 - prove that these results are actually
24:18 - coming in as they're completed let me
24:21 - actually pass in a different range of
24:23 - seconds for our processes to sleep and
24:26 - those should print out and the order
24:28 - that they complete so
24:29 - I'm gonna create a list of seconds to
24:31 - sleep and I'll make that sleep from five
24:34 - seconds all the way down to one second
24:36 - so above our results here I'm going to
24:39 - make a list of seconds and I will just
24:42 - make a list of five four three two one
24:45 - and I'll also print out the seconds in
24:48 - the return statement of our do something
24:51 - function so that we can tell which ones
24:54 - are finishing and in what order
24:56 - so again I'm going to make this an F
24:59 - string by putting an F right there and
25:00 - I'm just going to pass that in two so we
25:05 - can see which seconds is actually done
25:08 - sleeping so now let me also change our
25:12 - list comprehension here so that we are
25:14 - running or do something function with
25:17 - each of these seconds in this seconds
25:19 - list so I'm gonna say executors dot
25:22 - submit do something and I want to do
25:26 - that for whatever second so for SEC in
25:30 - our seconds list okay so now if I run
25:35 - this then we can see that it actually
25:37 - started our five-second process first
25:41 - and then our four then our 3 then our
25:43 - two then our one but it finished these
25:46 - in the order that they came in and the
25:49 - lowered number seconds are towards the
25:51 - top now I'm not sure why the 1 second
25:54 - process took so much longer than the 2
25:57 - and the 3 second processes I guess it
25:59 - just got hung up on something but the 4
26:01 - and the 5 second processes were down
26:03 - here at the bottom actually let me run
26:05 - that one more time and oh okay so that's
26:08 - why it's because our 1 second process
26:12 - was down here and since I have 4 cores
26:15 - on my machine it started these four
26:18 - processes here first and it didn't start
26:21 - the 1 second process until this 2 was
26:25 - finished right here so that's why that
26:27 - took a little bit longer but since we
26:29 - are using this as completed method this
26:32 - actually did print our result out our
26:34 - results in the order that they completed
26:36 - so this two second one finished first
26:39 - and then this 3 then 1 then 4 then 5 and
26:42 - can see here down at the bottom that our
26:44 - script is still finishing in about five
26:46 - seconds so that's pretty good okay so
26:49 - with this submit method right now it's
26:52 - submitting each function once at a time
26:54 - but in order to run submit on an entire
26:58 - list then we need to do a loop or a
27:00 - comprehension like we did here but if
27:03 - you're familiar with the built-in map
27:05 - method then there is actually something
27:07 - similar that we can do with processes
27:09 - where we can use the map method to run
27:11 - our function over a list of values so if
27:14 - you're familiar with the built-in map
27:15 - method then this is very similar except
27:18 - it uses processes instead so it runs the
27:21 - function every time or with every item
27:24 - of the integral that we pass in so let's
27:27 - say that I want to map our function to
27:29 - our list of seconds so to do this I am
27:32 - just going to overwrite our list
27:36 - comprehension here and I'm not going to
27:39 - be using this as completed anymore
27:40 - either so I'm also going to get rid of
27:42 - that so now in order to do this we can
27:46 - simply say executors dot map and now we
27:53 - will map our dosomething function and we
27:58 - will map our list of seconds so again
28:02 - what this map method does if you're not
28:04 - familiar with the built-in Python map
28:06 - method and what it does basically map
28:08 - will run this do something function with
28:12 - every item of this list with every item
28:16 - of whatever iterable you pass in so that
28:19 - is what map does now when we were using
28:21 - the submit method it returned future
28:23 - objects but when we use map it just
28:26 - returns the results now it is going to
28:29 - run those processes in parallel but
28:31 - instead of returning the results as
28:33 - they're completed like we saw before map
28:36 - is going to return the results and in
28:38 - the order that they were started so to
28:40 - loop over these results we can simply
28:43 - just do a for loop so I'm going to say
28:45 - for result in results and then I will
28:49 - just print out our result look make sure
28:53 - that I'm printing out the result and not
28:55 - that result list
28:56 - okay so now if I run this then we can
29:00 - see that all of our processes kicked off
29:02 - at pretty much the same time except for
29:05 - that one second one it looked like it
29:06 - got outside of the pool like it did
29:09 - before but they actually didn't all
29:12 - complete at the same time but when you
29:14 - loop over your results using map like we
29:17 - did here then it returns the results and
29:19 - the order that they were started so
29:22 - since we slept for five seconds first
29:24 - then we waited for that one to finish
29:26 - before printing out the other results
29:29 - but it still didn't slow us down we can
29:31 - see that our entire script still
29:33 - finished in five seconds here but it
29:35 - looks like our five seconds was done
29:38 - sleeping first and then our four then
29:40 - three then two then one it actually
29:41 - didn't finish in that order but it
29:44 - printed out in that order because again
29:47 - it prints out the ones that in the order
29:50 - that they were started and not in the
29:52 - order that they were finished now
29:54 - another thing to point out here is that
29:56 - if our function raised it as an
29:57 - exception it won't actually raise that
29:59 - exception while running the process the
30:01 - exception will be raised when its value
30:04 - is retrieved from the results iterator
30:07 - so if you need to handle any exceptions
30:09 - then you can do that here within the
30:11 - iterator if you'd like and if you'd like
30:13 - to learn more about handling exceptions
30:15 - then I do have a more in-depth video if
30:17 - you'd like to learn more about that so
30:20 - I'll be sure to leave a link to that
30:21 - video in the description section below
30:23 - for anyone who's interested now even if
30:25 - we don't grab our results within the
30:27 - context manager it's still going to
30:28 - automatically join all of those
30:31 - processes and let them finish after the
30:34 - context manager ends so if I comment out
30:37 - where we are printing out our results
30:40 - let me also get rid of our old way of
30:43 - doing this here so that we can see our
30:45 - code below our processes here so now I'm
30:48 - commenting out where we're printing
30:49 - those results and if I run this then we
30:53 - can see that it still didn't move on to
30:56 - our finish time here until it returned
30:59 - the results from our processes so any
31:02 - time you're using a context manager like
31:04 - this it's going to automatically join
31:06 - those processes and they're going to
31:08 - complete
31:09 - for that context manager finishes okay
31:12 - so now that we've looked at a basic
31:14 - example of using sleep now let's take a
31:16 - look at a more real-world example of
31:18 - we're using multiple processes would be
31:20 - useful so I've got another script open
31:23 - here where I'm not using multiple
31:25 - processes at the moment so let me open
31:27 - this up and let's go over what this is
31:30 - doing and again I'll have a link to this
31:32 - code in the description section below
31:34 - for anyone who wants to follow along so
31:36 - in our last video on threading I showed
31:39 - how we could use threads to go out and
31:41 - download some high resolution photos
31:43 - from unsplash now if you don't know what
31:45 - unsplash is it's a website that has some
31:47 - really nice photos available for anyone
31:49 - to use now downloading images is
31:52 - something that is io bound since we're
31:55 - waiting for the images to download so
31:57 - for this multi-processing example we
32:00 - want something that is more CPU bound so
32:02 - in this script I'm doing some image
32:04 - processing on the images that we
32:06 - downloaded in the threading video and
32:07 - I'll have these images available in the
32:10 - description section below as well in
32:11 - case anyone didn't follow along with
32:13 - that threading video so let me go over
32:15 - this script to show you how someone
32:17 - might do this image processing normally
32:20 - so I'm using the pillow library here
32:23 - which if you don't know what the pillow
32:25 - library is it's a image library for
32:28 - Python that makes it makes image
32:30 - processing easy I also have a video on
32:32 - pillow if you'd like to learn more about
32:34 - image processing but I have a list here
32:37 - of image names and these are all of the
32:40 - images or all of the image names that we
32:42 - downloaded in the last video using
32:44 - threading so I am starting a counter
32:48 - here so that we can measure how long our
32:50 - script took I am setting a size of 1200
32:53 - pixels and that is what we are going to
32:56 - resize these high rollaz resolution
32:58 - photos to okay and now what I am doing
33:00 - is I am looping over all of those image
33:03 - names so with one image at a time I am
33:07 - opening that image and then I am running
33:10 - running this image filter and we're just
33:13 - doing a Gaussian blur on that image and
33:16 - then I am doing an image thumbnail and
33:19 - setting it to this 1200 pixel size
33:23 - then we are saving that image into a
33:25 - processed folder with that the image
33:29 - name and then we are printing out that
33:31 - that image was processed now I do have a
33:35 - processed folder here within my
33:37 - directory if you don't you'll probably
33:38 - get an error and I also have all of
33:41 - these photos here within my directory if
33:44 - you don't have those then you're also
33:45 - going to get an error so you want to
33:48 - have all of those photos in order for
33:50 - this code to work then after that's done
33:52 - I am printing out the time that it took
33:55 - and then I am printing out that our
33:58 - script is finished okay so this is
34:00 - processing 15 high-resolution photos so
34:03 - if I run this now then let's see how
34:06 - long this takes so I'm running this we
34:08 - can see that it is just going through
34:10 - synchronously and running these one at a
34:12 - time and then we will print out or the
34:16 - final time once this is done now I think
34:20 - that my processing here I think that
34:22 - this still might be more i/o bound than
34:25 - CPU bound because opening the image and
34:28 - saving this here is going to be more of
34:30 - an i/o bound thing I don't know how much
34:33 - is actually getting a CPU bound here
34:37 - using this filter but if we were doing
34:40 - some more computations then this would
34:41 - be more CPU bound and we can even test
34:44 - this in a second but anyways we can see
34:47 - that our script finished in 22 seconds
34:49 - so that's how long it took to do this
34:52 - image processing here on 15 of these
34:55 - high resolution photos now when we're
34:58 - processing a lot of items like this this
35:00 - is actually a great candidate to use
35:02 - multi processing because this can be one
35:05 - of those CPU bound operations that's
35:07 - spending a lot of time processing each
35:09 - image and it's not moving on to the next
35:12 - image until the previous one finishes
35:14 - and if we use multiple processes then it
35:16 - can actually go ahead and move on to the
35:18 - to process another image while the
35:20 - previous one is finishing and even if
35:23 - this is i/o bound
35:24 - unlike threading CPR multi-processing is
35:27 - actually going to be beneficial for i/o
35:29 - bound processes as well so now let's see
35:32 - how we can change this code so that it's
35:34 - using multiple processes instead
35:36 - so first let's think about what we're
35:39 - doing here
35:39 - so we're looping over our list of images
35:43 - and processing each one at a time so if
35:46 - we remember from our previous examples
35:48 - then this would probably be a good
35:50 - candidate for the processing pull map
35:53 - method where we can pass in a function
35:55 - and a list and have that function run
35:58 - with every value in that list but first
36:01 - we'll have to create a function that
36:04 - will process a single image so to do
36:07 - that if we think about this we can
36:09 - basically just replace our for loop
36:11 - because our for loop is processing a
36:14 - single image from our images list so
36:17 - instead we can just change this one line
36:20 - here and just turn this into a process
36:22 - image function and we will just accept
36:26 - this image name as the argument and now
36:29 - that we have that function that
36:30 - processes a single image then we can
36:33 - create a process pool and map our list
36:36 - of images using that function so first
36:39 - let's import the concurrent futures
36:41 - module so that we can use that so up
36:44 - here at the top I'm going to import
36:47 - concurrent dot futures and now down here
36:53 - below our function we can do this by
36:58 - saying with concurrent dot futures dot
37:03 - process pull executors as executors and
37:09 - now within our context manager we can
37:13 - just say executors dot map and we want
37:19 - to map this process image function and
37:23 - we want to pass in the list of these
37:28 - image names now just in case that was
37:32 - confusing let me go over exactly what we
37:35 - did again in order to change our
37:38 - previous script in order to use
37:40 - multi-processing
37:41 - so we were using a for loop here but
37:44 - instead we changed this to a function
37:46 - that processes one image at a time and
37:48 - now we're using our process
37:50 - simple executors like we saw before
37:51 - within a context manager
37:53 - we're running executor dot map and we
37:56 - are passing in that function that we
37:59 - created and then we're passing in our
38:01 - list of image names and again what map
38:04 - does is it runs this process image
38:07 - function with every item in this image
38:11 - names list and just with those small
38:13 - changes this will actually use multiple
38:16 - processes to process those images and
38:18 - run these in parallel instead of running
38:21 - these synchronously so if I run this
38:24 - whoops and I made another mistake here
38:27 - you guys probably saw that one also but
38:30 - I needed to put a colon there okay
38:32 - hopefully that's my only mistake okay so
38:34 - if I run this then we can see now these
38:37 - are processing faster and I'm gonna open
38:39 - up my activity monitor here and scroll
38:41 - down to the peas and we can see here
38:44 - that we have multiple Python processes
38:47 - running here so we can actually see
38:49 - these in our activity monitor and now
38:51 - that this script is finished then we can
38:53 - see most of those go away the only one
38:56 - that's still here is probably just one
38:58 - that is open here in my sublime text so
39:01 - we could see all of those kick off in
39:03 - our Activity Monitor and we could see
39:05 - that they were all returning faster
39:07 - that's because they were running in
39:08 - parallel and now instead of taking 22
39:11 - seconds like it did before now it
39:13 - finished in seven seconds so more than a
39:16 - third of the time so that's a pretty
39:18 - significant speed up there and this
39:20 - would be even more significant if we
39:22 - were processing even more images so the
39:25 - speed ups can be pretty drastic
39:26 - depending on what you're doing now again
39:29 - you might want to experiment when using
39:31 - multiple threads or processes for
39:33 - specific tasks depending on what you're
39:35 - doing and what kind of hardware you're
39:37 - running one might be drastically
39:39 - different than the other and it's hard
39:41 - to tell exactly what you should be using
39:43 - without some benchmarks but again a good
39:45 - rule of thumb is that you want to use
39:47 - threads for things that are i/o bound
39:49 - and you'll want to use processes for
39:51 - things that are CPU bound but you may
39:54 - actually see significant speed ups using
39:56 - threads with this example since this is
39:59 - reading and writing to disk which is an
40:02 - i/o bound operation now
40:04 - one nice thing about using the
40:05 - concurrent futures library like this is
40:07 - that switching between threads and
40:09 - processes is just as simple as changing
40:11 - this process pull executors and just
40:14 - using a thread pull executors instead
40:17 - and you can do that vice versa to change
40:20 - from threads to processes with your
40:22 - programs so if I change this to a thread
40:26 - pool executors let me see if I'm right
40:29 - about a lot of this being IO bound here
40:31 - if I run this then we'll see how long
40:34 - this takes us to finish this script
40:37 - using threads instead of multiple
40:38 - processes and that was actually faster
40:41 - so that was 7.2 seconds so even though I
40:44 - tried to put together an example that
40:46 - was doing a lot of processing on the CPU
40:48 - it looks like most of this is IO bound
40:51 - from opening and saving these files and
40:53 - not CPU bound but from doing some image
40:56 - processing here with these Ghazni and
40:58 - blurs and these resizes and things like
41:00 - that but that's ok that's why you want
41:02 - to always experiment and you know if you
41:05 - try it with a process pull then maybe
41:08 - try it once with threads and see if you
41:09 - get better execution and also whenever
41:13 - you add in even more items maybe
41:15 - processes will start to become more
41:18 - performance than threads so it really
41:21 - just depends on what you're doing now
41:22 - before we finish up here I'd like to
41:24 - mention the sponsor of this video and
41:26 - that is brilliant org so when we're
41:29 - talking about threading and
41:30 - multi-processing these topics are
41:32 - especially useful in the field of data
41:34 - science and the data science field is
41:36 - growing at a very rapid pace if you'd
41:38 - like to learn more about programming and
41:40 - data science then I would definitely
41:42 - recommend checking out brilliant org so
41:44 - brilliant is a problem-solving website
41:46 - that helps you understand underlying
41:48 - concepts by actively working through
41:50 - guided lessons and they've recently
41:51 - added some brand-new interactive content
41:54 - that makes solving puzzles and
41:56 - challenges even more fun and hands-on
41:58 - and if you'd like to learn more about
42:00 - data science and programming with Python
42:02 - then I would recommend checking out
42:04 - their new probability course that covers
42:06 - everything from the basics to real-world
42:08 - applications and also fun things like
42:11 - casino games they even use Python in
42:13 - their statistics courses and will quiz
42:15 - you on how to correctly analyze
42:17 - the data within the language so they're
42:19 - guided lessons will challenge you but
42:21 - you also have the ability to get hints
42:23 - or even solutions if you need them it's
42:25 - really tailored towards understanding
42:27 - the material they even have a coding
42:28 - barment built into their website so that
42:30 - you can run code directly in the browser
42:32 - and that is a great compliment to
42:34 - watching my tutorials because you can
42:36 - apply what you've learned in their
42:37 - active problem-solving environment and
42:39 - that helps to solidify that knowledge so
42:42 - to support my channel and learn more
42:43 - about brilliant you can go to brilliant
42:46 - org forge / CMS to sign up for free and
42:50 - also the first 200 people that go to
42:52 - that link will get 20% off the annual
42:54 - premium subscription and you can find
42:56 - that link in the description section
42:57 - below and again that is brilliant dot
42:59 - org ford slash CMS ok so I think that's
43:04 - going to do it for this video I hope you
43:05 - feel like you've got a good idea of how
43:07 - to use the multi-processing module and
43:09 - how we can use these to speed up our
43:11 - scripts now I hope you also feel like
43:13 - you got a good overview of threads and
43:15 - processes and when you should use those
43:17 - but like I said if you're unsure then
43:20 - there's no hurt and simply trying both
43:22 - on a subset of your data to see what
43:24 - gives you the most speed up now there
43:27 - are some more advanced topics that we
43:28 - could cover in future videos such as
43:30 - race conditions locks and things like
43:33 - that but we'll save that for a future
43:35 - video if anyone is interested but if
43:37 - anyone has any questions about what we
43:39 - covered in this video then feel free to
43:40 - ask in the comment section below and
43:42 - I'll do my best to answer those and if
43:43 - you enjoy these tutorials and would like
43:45 - to support them then there are several
43:46 - ways you can do that the easiest ways to
43:48 - simply like the video and give it a
43:50 - thumbs up and also it's a huge help to
43:52 - share these videos with anyone who you
43:53 - think would find them useful and if you
43:55 - have the means you can contribute
43:56 - through patreon and there's link to that
43:57 - page in the description section below be
43:59 - sure to subscribe for future videos and
44:01 - thank you all for watching
44:03 - you
44:13 - you