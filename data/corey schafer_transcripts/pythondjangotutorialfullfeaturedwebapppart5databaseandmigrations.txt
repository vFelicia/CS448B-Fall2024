00:00 - hey there how's it going everybody in
00:01 - this video we'll be creating our own
00:02 - database tables for our application so
00:05 - that we can create real posts instead of
00:07 - relying on dummy data and to work with
00:10 - these databases Jango has its own
00:12 - built-in ORM now if you don't know what
00:14 - an ORM is it stands for object
00:17 - relational mapper and basically it
00:19 - allows us to access our database and and
00:22 - easy to use object oriented way and the
00:25 - thing that I like about it most is that
00:26 - you can use different databases without
00:28 - changing your code so if you want to use
00:30 - an SQLite database for testing and a
00:33 - Postgres database for production then
00:36 - all you need to do is set up a different
00:38 - database in our settings but all of the
00:40 - code to query the database will still be
00:42 - the same and that's what we'll be doing
00:44 - in this series we'll use an SQLite
00:47 - database for development and a Postgres
00:49 - database for production so let's go
00:51 - ahead and get started so that we can see
00:53 - what this looks like now the great thing
00:55 - about the django ORM is that we can
00:57 - represent our database structure as
00:59 - classes and you'll hear those classes be
01:01 - called models and doing the database
01:03 - structure this way is actually very
01:05 - intuitive after you get the hang of it
01:06 - so within our blog app django has
01:10 - already created a model stop py file for
01:13 - us so within the blog app directory
01:15 - let's open up that models dot py so
01:18 - within our models top py file we need to
01:20 - think about what we actually want to
01:21 - save to the database so the main things
01:23 - that we're going to have for our blog
01:25 - application are going to be users and
01:27 - those will be the authors of our posts
01:29 - and then we're gonna have the posts
01:31 - themselves now like we saw in the
01:32 - previous video Django already has a
01:34 - built-in authentication system and
01:36 - already has a user model that it's
01:39 - created for us and we've already seen
01:40 - how to create some users with that so
01:43 - we're not going to make a new user model
01:45 - just yet now in a future video we'll see
01:47 - how to add custom fields to that user
01:49 - model that aren't already there but for
01:52 - now we are simply going to just make a
01:54 - post model and this will be a class that
01:57 - inherits from Django model class and we
01:59 - can see that it's already imported these
02:01 - models for us so let's go ahead and
02:03 - create our post class or our post model
02:06 - so I'm going to delete the comment that
02:08 - we have here and now let's create this
02:10 - post model so I'm going to say class PO
02:13 - and we are going to inherit from models
02:16 - dot model so each class is going to be
02:19 - its own table in the database and now
02:22 - we'll create some attributes and each
02:24 - attribute will be a different field in
02:26 - the database so let's add the fields
02:28 - that we want for a post so one field
02:31 - that we'll have for a post will be the
02:32 - title so we can say that the title is
02:35 - equal to models dot char field so this
02:39 - is going to be a character field and we
02:42 - can set some arguments here that will
02:45 - specify some restraints on these fields
02:48 - so I can set a max length here equal to
02:51 - 100 so now we have a title that will be
02:54 - a field of our post table in the
02:57 - database and that title field will be a
03:00 - character field that has a restriction
03:02 - of a max length of a hundred so now what
03:05 - else do we want for a post so we also
03:07 - want content for the post
03:09 - so we'll say content is equal to and
03:11 - we'll set this equal to models
03:13 - dot text field now the text field is
03:17 - similar to the character field but with
03:19 - our content here it's going to be you
03:22 - know possibly lines and lines and lines
03:24 - of text so a text field here is just
03:27 - unrestricted text okay and lastly for a
03:29 - post we're also going to want a date
03:32 - posted field so that we can keep track
03:33 - of when these posts were created so I'll
03:36 - say date posted is equal to models dot
03:39 - and this will be a date/time field okay
03:43 - so for our date/time field we have a few
03:45 - different options here now we could set
03:47 - an argument of Auto underscore now equal
03:50 - to true which means that we would update
03:53 - the date posted to the current date time
03:55 - every time the post was updated now
03:59 - that's not exactly what we want so that
04:01 - would be great for a last modified field
04:03 - or something like that
04:05 - but this is going to be when the post
04:07 - was actually created now we could also
04:09 - set an argument of Auto underscore now
04:12 - underscore add equal to true and that
04:14 - would set the date posted to the current
04:17 - date time only when this object is
04:19 - created and that sounds exactly like
04:22 - what we want but there's a caveat there
04:25 - so with that auto now
04:27 - now add argument you can't ever update
04:30 - the value of the date posted so it will
04:33 - have to keep the exact date time of when
04:35 - the post was created now maybe that's
04:37 - what you'll want but I like having the
04:39 - option of changing these dates if I want
04:41 - to so instead I'm going to use an
04:44 - argument I'm going to use neither of
04:46 - those Auto now arguments and instead I'm
04:48 - going to use an argument of default and
04:50 - we're going to import a Django utility
04:52 - for this default so here at the top I
04:55 - will say from Django dot utils import
05:01 - timezone and this will be a date time
05:03 - that takes our timezone settings into
05:05 - consideration so now for our default we
05:08 - can simply say default is equal to
05:11 - timezone dot now and also notice that we
05:14 - didn't put the parentheses after
05:17 - timezone dot now like this now this is a
05:21 - function but we don't actually want to
05:23 - execute that function at that point we
05:27 - just want to pass in the actual function
05:29 - as default value so be sure that you
05:31 - don't put parentheses there to execute
05:33 - that okay so now moving on we also need
05:36 - to have an author for each post and this
05:39 - will be the user who created the post
05:41 - now our user is a separate table so
05:44 - first we need to import the user model
05:46 - and Django created that in the location
05:49 - so up here in our imports will say from
05:53 - Django
05:54 - oops from Django dot country dot auth
05:58 - dot models import user so the post model
06:03 - and the user model are going to have a
06:05 - relationship since users are going to
06:07 - author post specifically this is going
06:10 - to be called a one-to-many relationship
06:12 - because one user can have multiple posts
06:15 - but a post can only have one author and
06:18 - to do this in Django we can simply use a
06:20 - foreign key so I will come down here to
06:23 - our other field and say author is equal
06:26 - to models dot foreign key and then the
06:31 - argument that we want to pass into that
06:33 - foreign key is the related table and
06:36 - that will be user now we're also going
06:38 - to need a second argument here called on
06:41 - underscore delete so undelete and this
06:43 - is needed because we need to tell Django
06:45 - what we want to do if the user who
06:48 - created this post gets deleted so if a
06:51 - user created post and then the user was
06:53 - deleted then do we want to delete the
06:55 - post or do we want to set that author to
06:58 - none or what do we want to do well for
07:01 - this app we'll just say that if a user
07:03 - is deleted then we're also going to
07:05 - delete their posts as well so the
07:08 - argument we're going to pass in here is
07:10 - on delete is equal to
07:12 - oops is equal to models dot cascade and
07:17 - cascade is going to be all uppercase so
07:21 - again that's just telling Django that if
07:22 - a user is deleted then we want to delete
07:25 - their posts as well but that's only a
07:27 - one-way street so if you delete a post
07:30 - then it's not going to delete the user
07:31 - because you know that would be
07:33 - definitely a bad design okay so that
07:35 - does it for our post model so that is
07:37 - all of the information that we need so
07:40 - now that we've made some changes to what
07:42 - our Django database is going to hold now
07:44 - if you remember in the last video we
07:47 - needed to run migrations in order to
07:49 - update the database with any changes so
07:52 - let me pull up the command line here and
07:54 - now we need to rerun those migrations in
07:57 - order to get any changes to our database
07:59 - so if you remember in order to create
08:03 - those migrations we need to say python
08:04 - managed py make migrations so let's run
08:09 - that and we can see that it says that it
08:11 - made a migration in this location blog
08:14 - migrations 0 0 0 1 underscore initial
08:18 - dot pi now I never really touched these
08:20 - files myself but they are files that we
08:22 - can open up and look at so within our
08:25 - app if we go back to sublime here within
08:29 - my blog app I'm going to expand this
08:32 - migrations directory and within this
08:35 - migrations directory we can see this 0 0
08:39 - 0 1 underscore initial dot pi so let's
08:42 - open this up so this is what got created
08:45 - when we ran and make migrations and we
08:47 - can see a bunch of information in here
08:48 - about what it will do once we actually
08:50 - run the migrate command so the make
08:53 - migrations command
08:54 - made these files for what it will do and
08:57 - the migrated command will actually run
08:59 - these and we can see a couple of things
09:01 - about this migration so we can see that
09:03 - it says initial is set to true we can
09:05 - see that the name of the model that it's
09:08 - creating is post and we can see some
09:10 - that we can see all of the fields that
09:13 - we created here so that's a lot more
09:15 - information than what we put in but it
09:18 - created that for us ok so before we
09:20 - actually run the migrate command to
09:22 - actually create this table in our
09:24 - database let me show you how you can
09:26 - view the actual SQL code that this will
09:28 - run on the database now this is great if
09:30 - you're having issues and need to see the
09:32 - exact xql code or SQL code that is going
09:36 - to be generated whenever this is run so
09:39 - to do this let's pull back up our
09:41 - command line and the things that we're
09:42 - going to want to remember are the blog
09:45 - here which is the app name and also the
09:47 - migration number which is the zero zero
09:49 - zero one that's how we can view the SQL
09:52 - that's going to be run so I can take
09:54 - that information and say Python managed
09:57 - py SQL migrate and now the now the app
10:02 - name which is blog and then the
10:04 - migration number which is zero zero zero
10:06 - one so if I run that then this actually
10:09 - prints out the SQL code that it's going
10:11 - to run so we can see here that it does a
10:14 - create table of blog post and then an ID
10:18 - field here which we didn't specify but
10:20 - it does a primary key automatically that
10:22 - auto increments we have a title which is
10:25 - a varchar' of a hundred characters so it
10:27 - takes that simple class that we created
10:29 - and it writes out the SQL for all of the
10:32 - fields that will be compatible for the
10:34 - database that we're using which right
10:36 - now is SQL Lite so this saves us a ton
10:39 - of time and a lot of effort if we had to
10:42 - write that SQL ourselves and really it
10:44 - made it so that we didn't even need to
10:46 - know SQL to work with this database
10:48 - we just used that Python model class and
10:51 - our models not py file and it wrote this
10:54 - back-end SQL for us so that's why these
10:56 - object relational mapper ZAR so
10:58 - convenient we don't actually have to get
11:00 - our hands dirty with the SQL code a lot
11:02 - of the time ok so now let's run the
11:04 - migrate command so that it runs the
11:06 - migration and these changes take effect
11:08 - on the actual database so I'm going to
11:10 - clear my screen here and now let's run
11:13 - that migrate command so I'll say Python
11:16 - manage py migrate so if we run that then
11:22 - we can see that worked and that we get
11:23 - an ok status there now I should also
11:26 - mention why migrations are so useful so
11:28 - migrations are useful because it allows
11:30 - us to make changes to our database even
11:33 - after it's created and has data in that
11:36 - database so if we didn't have a way to
11:38 - run migrations then we would have to run
11:40 - some complicated SQL code to update our
11:42 - database structure so that it didn't
11:45 - mess with the current data but with
11:46 - migrations we can simply make whatever
11:49 - changes we need run make migrations and
11:51 - then run migrate and it will make all of
11:54 - those changes for us ok so now that
11:56 - those changes have been added to the
11:57 - database let's see how we can query the
12:00 - database using these models now the
12:02 - Django ORM lets us do this through the
12:04 - classes as well so to illustrate this
12:06 - I'm going to run the Django Python shell
12:09 - which will allow us to work with these
12:12 - models interactively line by line so we
12:15 - can run the shell by saying python
12:18 - managed py and that is the shell command
12:22 - so if we run that then we can see that
12:25 - we get what looks to be a Python prompt
12:27 - and that's exactly what it is we can run
12:29 - Python code in here but we can also work
12:31 - with our Django objects so for example
12:34 - let's import both our post model and our
12:38 - user model so let me clear the screen
12:40 - here first and now to import that post
12:43 - model we can say from blog which is our
12:46 - app blog dot models we want to import
12:49 - post and now let's also import that user
12:52 - model now if you don't remember where
12:54 - that is that is in Django dot country
12:58 - dot auth dot models and we want to
13:02 - import user now if you were following
13:04 - along with the last video where we
13:05 - created two users in the admin page then
13:08 - we know that we already have two users
13:10 - so let's query our users table and see
13:13 - if we can see those so if we want to
13:15 - just get all of the users then we can
13:17 - simply say user dot objects dot all
13:22 - so if I run that then we can see that it
13:25 - returns a query set result and within
13:27 - that query set we have this user for
13:30 - core EMS and this user for test user so
13:33 - it returned both of the users that we
13:34 - created in the last video now if we just
13:36 - wanted to get the first user then we
13:39 - could access it from that list or we
13:42 - could use the first method that just
13:44 - gives you the first result so if I was
13:46 - instead to say user objects dot first
13:49 - then we can see that now we just get
13:51 - that first user and there is also a last
13:54 - method to give us the last result now we
13:57 - can also filter the results by using the
13:59 - filter method so if I was to say user
14:02 - objects dot filter now we can filter by
14:06 - a field so I can say username is equal
14:10 - to and I'll say username equal to core
14:12 - EMS now that gives me a query set as a
14:15 - result but the query set only has one
14:17 - user since the user names are unique now
14:21 - if that field wasn't unique then it's
14:23 - possible a filter could return multiple
14:25 - results so we could use the first method
14:28 - here as well just so we can Garrett grab
14:31 - the first result of that filter so if I
14:34 - run that filter again then I can do dot
14:36 - first and now we can see that we just
14:39 - get that user instead of the query set
14:42 - with the one user and that the query set
14:45 - so now let's actually take a look at
14:46 - this user that is getting returned so
14:49 - I'm going to run that same query again
14:51 - where we grab the first user from that
14:54 - filter but now I'm going to capture this
14:56 - in a variable so I'm going to say user
14:58 - is equal to user object stop filter with
15:02 - a user name of query MS and grab the
15:04 - first result of that filter so if I run
15:08 - that then now we have this user captured
15:11 - in this user variable now let me clear
15:13 - my screen here so that we have some more
15:15 - room so again we now have that user
15:18 - variable and now we can actually look at
15:20 - the attributes of this user so I can say
15:23 - user dot ID and see that this user has
15:26 - an ID of 1 now we can also use the PK
15:30 - attribute to get that ID which stands
15:33 - for primary key so if we say user
15:36 - piqué then it gets the primary key which
15:38 - is the same as the ID now we can
15:40 - actually perform a queries using that ID
15:42 - as well so we already saw user dot
15:45 - objects dot all and user dot objects not
15:47 - first but if we were to say you know
15:50 - user is equal to user dot objects dot
15:54 - get then we can get by an ID so I'll say
15:58 - ID is equal to one and if I look at that
16:01 - user then it's that same user that we
16:04 - saw had an ID of one okay so now let me
16:06 - clear the screen again so now we have
16:09 - this user variable that is equal to this
16:13 - user so now let's create a new post and
16:16 - make this user the author of this new
16:19 - post so first of all we shouldn't have
16:22 - any post right now so if I run a query
16:25 - on the post model and say post dot
16:28 - objects dot all and run that then we get
16:32 - an empty query set and that's how it
16:34 - should be because there are no posts so
16:36 - now let's create some post written by
16:37 - this user so that we can see what this
16:39 - looks like so I can say post underscore
16:42 - one is equal to post and now we can fill
16:46 - in the fields so I'll say title is equal
16:49 - to blog one and then we'll set the
16:53 - content equal to
16:56 - oops I'm sorry that content should not
16:58 - be in a string like that
17:00 - sorry about that I wanted the string to
17:02 - be the actual content so for the content
17:04 - I'll just fill in first post content
17:07 - with an exclamation point and now we
17:09 - also need to set the author so I'll say
17:12 - author and sorry it's going on to
17:14 - multiple lines there but I'll say author
17:15 - is equal to and I'll just pass in at
17:18 - that user variable so now let me run
17:20 - this and we can see that it doesn't give
17:22 - us an error so that probably worked now
17:24 - also notice that I didn't specify a date
17:27 - for this post now if we remember from
17:29 - our model we have a default date of the
17:32 - current date time so it should populate
17:34 - that with the current time if we don't
17:37 - provide it anything
17:38 - so now let's query our post table again
17:41 - so I'll hit up here a couple of times
17:42 - and rerun that post out objects not all
17:45 - and we can see that this is still an
17:47 - empty query set so there are still no
17:50 - and the reason is because we created a
17:53 - post object as this post underscore one
17:55 - variable but we didn't actually save it
17:58 - to our database so to do that we can say
18:01 - post underscore one dot save and if we
18:05 - run that save then now let's require our
18:08 - post object or our post table again so
18:11 - post dot objects not all if we run that
18:13 - then we can see now we get a query set
18:16 - with one post object and since our
18:19 - screens getting a little crowded let me
18:20 - clear the screen and rerun that again
18:23 - okay so this is good that we have one
18:25 - post object now this post object isn't
18:28 - very descriptive so if you remember when
18:30 - we printed out our users it showed us
18:32 - the usernames of the user which is nice
18:34 - and descriptive so in order to get this
18:37 - post object to be more descriptive we
18:39 - have to tell it what we want to see when
18:41 - we print it out and we can do that with
18:43 - the dunder STR method so I'm going to go
18:47 - back to our models and add this so I'm
18:49 - going to keep the shell open here and
18:51 - open our project back up I'm going to
18:54 - close out of the migrations file and go
18:56 - back to our models py where we created
18:58 - this post model and within our models we
19:00 - want to create a dunder STR method and
19:04 - thunder means double underscore so this
19:06 - is gonna be def double underscore STR
19:09 - double underscore and we need to take
19:12 - self as an argument and now we can
19:15 - return how we want this to be printed
19:18 - out so I just want a pose to be printed
19:20 - out by the title so I'll just say return
19:22 - self dot title now if anyone has seen my
19:26 - object-oriented series then I go into
19:28 - more details about these double
19:29 - underscore methods they're also called
19:32 - magic methods or special methods so if
19:34 - you're interested in this stuff then you
19:36 - can watch my object-oriented series
19:37 - where I go into this stuff in a lot more
19:39 - detail okay so with that dunder STR
19:42 - method in place let's open back up our
19:45 - command line here now in order to get
19:47 - those changes to take effect we're going
19:49 - to need to exit the shell and open it
19:51 - back up so I will exit out of that and
19:54 - now let's rerun that Python shell
19:56 - command so python managed type py shell
19:58 - and now we need to re-import our post
20:00 - and user models so
20:02 - to import the post model I'll say from
20:05 - blog models import post and import our
20:09 - user model remember that is in Django
20:13 - dot country dot auth dot models import
20:19 - user so now if we query all of our post
20:22 - objects again so I'm just going to grab
20:24 - the same query that we did before so
20:25 - post dot objects all if we query that
20:29 - again then now we can see that we get a
20:31 - query set and the object now says post
20:34 - of blog one so now it's using that blog
20:37 - title in order to print that out ok so
20:40 - now let me clear the screen here so now
20:43 - let's add one more post that is similar
20:45 - to the one that we just created now
20:47 - remember I exited the shell and opened
20:49 - it back up so I lost our user variable
20:51 - that we were working with so let's
20:53 - create that again so I will just say
20:55 - user is equal to user dot objects dot
21:00 - filter and we wanted to grab the user
21:03 - with the username equal to Corrie m/s
21:06 - you can use whatever user you created
21:08 - and then we'll just grab the first user
21:11 - that matched to that filter so now that
21:14 - user we can see is user query MS and now
21:17 - let's add one more post that is similar
21:19 - to our first with this user as the
21:21 - author so I'll say post underscore 2 is
21:24 - equal to post and then we'll pass in a
21:29 - title equal to blog two and we will pass
21:33 - in and I put those strings there again
21:36 - we could pass in the content equal to a
21:39 - string of second post content and let me
21:43 - make the screen a little smaller here so
21:46 - that this new line it gets pushed a
21:48 - little early here okay so now last time
21:52 - we created post we for our last item we
21:56 - said author oops and it looks like when
21:58 - I resize that messed up our text a
22:00 - little bit so let me just run that early
22:02 - and get an error and then rerun this so
22:06 - second post content so now the last time
22:10 - we created an host object we said author
22:13 - is equal to
22:15 - user but instead of setting that author
22:17 - equal to our user we can also use the ID
22:21 - as well so we can say author underscore
22:24 - ID is equal to user dot ID so now if I
22:29 - run that then we could see now we didn't
22:31 - get any errors there so that probably
22:32 - worked now remember if we actually want
22:34 - to save that to the database then we
22:36 - have to run the save method so you don't
22:38 - want to forget that so we can say post
22:40 - du dot save and run that and now let's
22:44 - query all of our posts again so we can
22:46 - say post dot objects dot all and now we
22:50 - can see that we have two blog posts so
22:53 - again my screens get a little crowded so
22:54 - let me clear that out and rerun that so
22:58 - now let me grab that first post and give
23:00 - that a look so I'm going to save it into
23:02 - a variable so I'll say post is equal to
23:05 - post dot objects and I'll just grab the
23:09 - first one so I'll say dot first and now
23:12 - we should be able to access all of the
23:14 - fields added to our model so if I say
23:17 - post dot content then we can see the
23:20 - content of that post and like I said our
23:23 - date posted should have been added
23:25 - automatically even though we didn't
23:27 - actually set it whenever we created that
23:29 - post object so let's test that to make
23:32 - sure that that is true so I'll say post
23:34 - dot date underscore posted I think is
23:37 - the field that we gave and we can see
23:40 - that that is a date time object and this
23:42 - is the date time that this was posted
23:44 - and lastly if we look at the post author
23:48 - so if I say post dot author then we can
23:51 - see that it returns that user object and
23:53 - that is actually the entire user object
23:56 - so you could even access that user
23:58 - objects attributes so for example if I
24:01 - wanted this users email address then
24:04 - instead of rerunning another query or
24:06 - anything like that I could simply say
24:08 - post dot author dot email and we can see
24:11 - that now we get that authors email
24:13 - address and that's a really nice feature
24:15 - that we're able to get that extra
24:16 - information from that foreign key like
24:18 - that okay so now let's see how we would
24:22 - get all of the posts that were written
24:24 - by a specific user so let's say that we
24:27 - wanted to get all of the posts that were
24:28 - written
24:29 - this user here now you might think that
24:31 - we need to fetch the user and then do a
24:34 - query on the post model filtering by
24:36 - posts with that user as the author and
24:39 - that is definitely one way to do it but
24:41 - Jango also adds a special query set to
24:45 - the user model that allows us to do this
24:47 - a lot more easily and the naming
24:49 - convention for this query set is the
24:52 - name of the related model then
24:54 - underscore set so it would look like
24:56 - this it would be a model name underscore
24:59 - set so when it comes to our user the
25:03 - related model is named post so we can
25:07 - access the post of our user variable
25:09 - simply by saying so let me say user so
25:14 - we have this user here with this
25:15 - username now if we wanted to get all of
25:17 - the posts that they have written then
25:19 - this is user dot post underscore set so
25:23 - if I run that then we can see that it
25:26 - returns something that isn't too
25:27 - readable but we can actually use that
25:29 - post set to run queries on the post that
25:32 - this user has created so if we wanted to
25:35 - get all of the posts then we could
25:37 - simply say user dot post underscore set
25:40 - dot all and if we run that then we can
25:44 - see that now we have a query set of the
25:47 - two posts that we've just created
25:49 - because this user is the author of both
25:51 - of those posts so let me clear the
25:53 - screen here and show this one more time
25:56 - so if we want to get all of the posts
25:58 - that a user has created we can use the
26:01 - post underscore set and that gives us
26:04 - something that we can run queries
26:05 - against so if we say post set dot all
26:08 - then that gives us the two posts that
26:12 - they offered now we can actually create
26:14 - a post directly using that post set so
26:17 - if I wanted to create a third post
26:19 - directly using this user then I could
26:22 - simply say user dot post underscore set
26:26 - dot create and then we can create a post
26:30 - I'll set a title equal to blog three and
26:34 - we will set the content and I keep
26:38 - putting that and stream for some reason
26:39 - then we can set content equal to
26:43 - third post content with an exclamation
26:46 - point and now I can hit enter and it
26:49 - will create that post now notice that we
26:51 - didn't specify an author for that post
26:54 - because Django knows that we wanted to
26:56 - create that post for that users post set
26:59 - which means that it automatically makes
27:01 - them the author and we don't need to run
27:04 - dot save or anything like that either it
27:06 - automatically saved that to the database
27:08 - so now if I query all of our posts again
27:11 - so I'll say post dot objects dot all
27:14 - then we can see that now we have three
27:17 - blog posts okay so I think that's a
27:19 - pretty good overview of the database
27:20 - queries that we can make now I know that
27:23 - that's a lot to take in so if you need
27:25 - to go back and re-watch that section a
27:27 - couple of times then it might take a
27:28 - while for some of that to sink in so now
27:31 - let me exit out of our shell here so I
27:33 - will exit and now let's do two more
27:35 - things before we finish this video so
27:37 - first let's use the database queries
27:39 - that we just learned in order to use
27:42 - this real data that we've added to our
27:44 - database instead of the dummy data that
27:46 - we have right now and second let's also
27:48 - see how we can edit this post data
27:51 - within the admin page of our site so
27:54 - first let's make some queries in order
27:56 - to grab this data in our database and
27:58 - pass it to our views so let's open up
28:01 - our blog views where we currently have
28:03 - that dummy data
28:04 - so within sublime text I'm going to
28:07 - navigate to my blog app and open the
28:10 - blog views and we can see here that we
28:12 - currently have this dummy data of these
28:15 - posts and we're passing in that dummy
28:18 - data into our context so instead of
28:21 - using that dummy data let's instead run
28:23 - a query on our post model and pass in
28:26 - all of that data instead so first we
28:28 - need to import our post model so at the
28:31 - top where we're doing our imports we can
28:34 - say from dot models
28:37 - now since this models is in the same
28:39 - directory that's why we're using that
28:40 - dot models and we can import post and
28:44 - again that dot in front of the models
28:46 - layer just means from the models file in
28:49 - the current package import our post
28:51 - class so now with when within our
28:54 - contacts down here in the home
28:56 - instead of passing in that dummy data
28:58 - let's instead query all of our posts
29:00 - from the database like we saw in the
29:03 - command line so we can simply say post
29:05 - dot objects dot all and as long as those
29:09 - dictionary keys were the same names as
29:11 - our database fields then we shouldn't
29:14 - have to change anything it should have
29:16 - just worked now if your database fields
29:18 - are different than the keys that you put
29:20 - here in your dummy data dictionary then
29:24 - you'll have to go into your templates
29:26 - and change those accordingly
29:28 - but for now mine were the same so let's
29:30 - open up our site and see if we're
29:32 - getting the blog post from our database
29:35 - now so I will go back to our command
29:37 - line and we need to run our development
29:40 - server so I'll say Python manage py run
29:43 - server and now let's run the openness in
29:47 - our browser so we'll run that so when I
29:50 - reloaded that you could see that it
29:52 - brought in different posts so now these
29:55 - are the posts from our database and not
29:57 - the dummy data that we had before now it
29:59 - might be hard to notice but there is one
30:02 - difference here our dates aren't the
30:05 - same format as they were in our dummy
30:07 - data and that's because it's using the
30:09 - date/time directly from the database
30:11 - without any formatting so you can see
30:14 - that the date/time here says August 28th
30:16 - 2018 to 46 a.m. so that's kind of a
30:20 - weird formatting for it to have on our
30:22 - page so really we would just want this
30:25 - to display the whole month the day and
30:27 - then the year we don't really need the
30:29 - exact time and the display you know
30:32 - unless you were doing something like a
30:33 - Twitter application or something where
30:35 - you expected tons of post then it would
30:37 - might be nice to have the exact time
30:38 - there but I'm gonna change this to where
30:40 - it's just the whole month the day and
30:42 - then the year so let's open up our
30:44 - homepage template and see how we can
30:46 - change the formatting of these dates so
30:49 - I'm going to go back to our application
30:51 - and within our blog app I'm going to
30:53 - open up templates and then the blog
30:55 - subdirectory and then the home template
30:59 - okay so we have our home template here
31:01 - where we're looping through our post so
31:02 - now let's find where we're printing out
31:04 - that date posted so that is right here
31:07 - where we're printing out that posted
31:09 - date so within our template tags there
31:13 - are different filters that we can use to
31:15 - change our data around a little bit so
31:17 - for dates
31:18 - there is a date filter so to use this we
31:22 - can use the vertical bar character and
31:25 - then the filter so I can put in a
31:27 - vertical bar and then use date as a
31:30 - filter and then after that date filter
31:33 - then we can put a colon and inside of a
31:36 - string we're going to specify how we
31:38 - want to format our date now in order to
31:41 - get the formatting codes for how you
31:43 - specify a certain date then you're
31:45 - probably going to have to look in the
31:46 - documentation and I have this linked in
31:48 - the description section below now I
31:50 - never remember these either and I always
31:52 - have to look at the docs so I have this
31:55 - actually pulled up in my browser so if I
31:57 - go back to my browser here then I have
31:59 - the Django date documentation pulled up
32:02 - here so let me make this a little bit
32:04 - larger so that everyone can see so I
32:08 - think that is good there so these are
32:11 - the date format characters and what they
32:13 - are equal to so remember we want the
32:17 - full month and then the day of the month
32:20 - and then the year so if I scroll down
32:22 - here a little bit then we can see the
32:25 - full month over here so the format
32:28 - character for that is capital F and then
32:31 - we want the day of the month after that
32:33 - and if we look up here then that's
32:36 - actually the first one here the
32:38 - lowercase D is the day of the month two
32:41 - digits with leading zeros and then we'll
32:43 - also want to print out the full year and
32:46 - if we scroll down a little bit then we
32:47 - can see a full year here and the format
32:49 - code for that is a capital y and you can
32:52 - use whatever formatting code you want to
32:54 - print out the date in any way that you
32:56 - want but for this application I'm going
32:58 - to use that capital F to do the full
33:01 - month lowercase D for the day and then
33:03 - the uppercase Y for the year so now
33:05 - let's go back to our template and fill
33:07 - in that information so I will go back to
33:10 - our template here and with this date
33:13 - filter I'm going to specify that we want
33:16 - this as capital F for the full month and
33:19 - then a space lowercase D to specify the
33:22 - day
33:23 - then I'm going to put in a comma to
33:24 - separate the day in the year and then a
33:27 - space and then a capital Y so let's save
33:30 - that and now with that save let's look
33:32 - back at our home page in our browser so
33:34 - if I pull the browser back up here and
33:38 - reload the home page then we can see
33:41 - that now that time is no longer there it
33:43 - just says August 28th 2018 okay so
33:47 - that's great so now we can see that
33:48 - those dates are formatted how we want
33:50 - them to be so now let's go back to our
33:52 - views and delete that post dummy data
33:55 - that we were using in previous videos
33:57 - because now we don't need that anymore
33:59 - and it's taken up a lot of room in our
34:02 - views so here within our views we're now
34:04 - using that post out objects not all for
34:06 - our context so we no longer need this
34:09 - list of dummy data dictionaries there so
34:13 - now we can save that okay so I know that
34:14 - this video is getting a little long but
34:17 - there is one more thing that I'd like to
34:18 - cover while we're on the topic of
34:20 - database models so we saw in a previous
34:22 - video how the admin panel allowed us to
34:25 - create update and delete different users
34:28 - using a GUI on the admin page now we can
34:31 - do that within or with this new post
34:33 - model but we'll have to do something
34:36 - first
34:36 - so what I mean by that is if I go to our
34:39 - website right now and go to our admin
34:42 - panel and let me make this a little bit
34:44 - larger so everyone can see so within our
34:47 - admin panel we can still see our groups
34:51 - and our users but where are the posts
34:54 - well in order to see that model here we
34:56 - actually have to register that with our
34:58 - admin page so if we look in our app
35:02 - directory so let me open back up our
35:04 - page here if we look in our blog app
35:07 - directory then we should be able to see
35:10 - an admin dot py file so that is in the
35:14 - same directory as your model snot py and
35:16 - your views top UI and things like that
35:18 - so let's open that blog admin dot py
35:22 - file and we can see that it says
35:24 - register your models here and we're
35:26 - already importing this admin class so
35:29 - let's get rid of that so this is where
35:31 - we can register our models so that they
35:34 - show up on our admin page so to do that
35:36 - we
35:37 - first need to import our model so here
35:39 - at the top I'll say from dot models
35:42 - import post and now to register this
35:46 - model with our admin site we can say
35:49 - admin dot site dot register and pass in
35:53 - that post model and save that and it's
35:57 - just as easy as that
35:58 - so now if I reload our admin page and go
36:03 - back to our browser and reload that now
36:05 - you can see that it just popped up with
36:07 - these post objects so now within our
36:10 - admin page we can go inside these posts
36:12 - and we can see that we have blog one
36:14 - blog to block three and we could you
36:17 - know create new posts or update these
36:19 - however we want so within a blog one I
36:22 - could say my first updated content and
36:25 - blog one updated and we could save that
36:30 - here and we can see that we were able to
36:32 - actually update that blog post from
36:34 - within our admin page and we can also
36:36 - change the authors of these blogs so if
36:38 - I was to click on this blog 3 post then
36:41 - if we scroll down here we can see that
36:43 - the author is set to Cory M s now if I
36:46 - wanted to change this then I could just
36:47 - simply click on that drop-down and we
36:50 - can see that test user which is our
36:51 - other user that we've created is an
36:53 - option so if I select him then I can
36:56 - save that and now with those changes
36:58 - that we made in the admin site if we go
37:00 - back to our main page and let me reset
37:03 - the size of our browser here if we go
37:05 - back to our main page then now we can
37:07 - see that our blog 1 was updated with a
37:10 - new title and down here at blog 3 it's
37:13 - now saying that test user is the author
37:16 - of that blog so that's awesome that's
37:18 - extremely powerful that right out of the
37:20 - box with Django we have the ability to
37:22 - go into the admin page and just change
37:25 - all of our models and all of our objects
37:28 - using that back in admin view and it has
37:31 - a nice GUI to where we can go in and
37:33 - change all of that stuff on the fly all
37:35 - right out of the box so that is perfect
37:37 - ok so I think that is going to do it for
37:39 - this video I hope that you got a good
37:41 - sense for how the databases work and how
37:43 - we can create models also how we can add
37:46 - data and query data and also get this
37:49 - hooked up to our admins
37:50 - in order to see and work with it in an
37:53 - easier way within that admin panel so in
37:56 - the next video we'll be learning how to
37:57 - create and validate a user registration
38:01 - form so that we can get started with
38:02 - creating some accounts on the front end
38:04 - of our website so that users who don't
38:06 - have access to the admin page can still
38:09 - have that functionality but if anyone
38:10 - has any questions about what we covered
38:12 - in this video then feel free to ask in
38:13 - the comment section below and I'll do my
38:15 - best to answer those and if you enjoy
38:17 - these tutorials and would like to
38:18 - support them then there are several ways
38:19 - you can do that the easiest way is to
38:21 - simply like the video and give it a
38:22 - thumbs up and also it's a huge help to
38:24 - share these videos with anyone who you
38:25 - think would find them useful and if you
38:26 - have the means you can contribute
38:28 - through patreon and there's a link to
38:29 - that page in the description section
38:30 - below be sure to subscribe for future
38:32 - videos and thank you all for watching
38:44 - you