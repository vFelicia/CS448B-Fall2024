00:00 - hey there how's it going everybody in
00:01 - this video we're going to be taking a
00:02 - look at the inter tools module so
00:04 - itertools is a collection of tools that
00:06 - allows us to work with iterators in a
00:08 - fast and memory efficient way now if you
00:11 - don't know what an iterator is it's
00:12 - basically sequential data that we can
00:14 - iterate or loop over now I would
00:16 - recommend being familiar with the
00:18 - concept of iterators and generators
00:19 - before watching this video I do have a
00:22 - video that I released a little over a
00:24 - week ago that I'll leave in the
00:25 - description section below if you want to
00:27 - watch that video first it's probably not
00:29 - absolutely necessary but understanding
00:31 - how an iterator is exhausted or how some
00:34 - only hold one object in memory at a time
00:36 - is going to help with understanding how
00:38 - itertools is working as well so the
00:40 - inter tools module contains a number of
00:42 - commonly used iterators as well as
00:44 - functions for combining several
00:46 - iterators now The Sitter tools module is
00:48 - available in the Python standard library
00:49 - so there's nothing that you need to
00:51 - install in order to use this now if
00:53 - you're looking for a specific itertools
00:55 - function then I'm going to try to put a
00:57 - timestamp in the description section
00:59 - below
00:59 - to each of the functions that we go over
01:01 - in this video so you can look there for
01:03 - a time step to whichever function that
01:05 - you're looking for so first off let's go
01:08 - ahead and import this so that we can see
01:10 - what we can do with this so first I'll
01:12 - just say import it err tools ok so right
01:16 - off the bat let me show you one of the
01:17 - most simple itertools functions so the
01:19 - first function that we're going to look
01:21 - at is called count and just like it
01:23 - sounds it simply returns an iterator
01:25 - that counts so we can say that use that
01:28 - just by saying counter is equal to
01:31 - itertools dot count and by default if we
01:35 - don't pass in any arguments then count
01:37 - will just start at 0 and count out by
01:39 - one each iteration and this is just
01:42 - going to go on forever so right now if
01:44 - we were to loop over this it would just
01:46 - start counting up from zero by one and
01:47 - never stop so if you're not careful then
01:50 - you can get stuck in an infinite loop
01:51 - now I'm going to show you what this
01:52 - looks like but I wouldn't recommend you
01:54 - do this on your machine because
01:56 - sometimes it's hard to stop from
01:57 - executing and can freeze up your
01:59 - computer or program but I'm going to try
02:01 - to run this and just stop it quickly so
02:03 - I'm just going to say for num in counter
02:06 - oops in counter and we will just print
02:10 - out num now again this is going to be an
02:12 - infinite loop
02:13 - but I'm just
02:13 - run this and stop it quickly okay so I
02:17 - ran that and then quickly stopped it by
02:19 - hitting ctrl C but even in that short
02:21 - time it already counted up by a lot we
02:23 - already got up over two hundred thousand
02:25 - here now if you are familiar with
02:27 - iterators then we can actually get the
02:29 - next value without using a for loop we
02:32 - can simply just use the next function
02:34 - and pass in our iterator so instead of
02:37 - looping through it like this instead
02:38 - let's do something like I will remove
02:41 - this for loop and just say print next
02:44 - and then next counter so let's save that
02:48 - and run it and when we run that we can
02:50 - see that we get a zero now if I copy and
02:52 - paste this a couple of times and run
02:54 - this again so I'll copy and paste this a
02:56 - few times here and run it then we can
02:58 - see that each time we run next we get 0
03:01 - 1 2 3 and it just keeps on going and
03:04 - this is one big key take away from these
03:06 - iterators some of them can go on forever
03:08 - but even if they do we can still just
03:10 - get one item at a time ok so why is this
03:14 - useful well there's a lot of different
03:15 - scenarios that this might be useful but
03:17 - let's just look at one example so it's
03:19 - very common to have a list of values and
03:22 - want to have some kind of index assigned
03:24 - to them so to show an example let me
03:26 - create a quick list here so I'm going to
03:28 - comment out these print statements and
03:31 - I'm just going to make a quick list of
03:33 - data here and say that I want 100 200
03:37 - 300 and 400 so here we just have a list
03:40 - of some random numbers so let's say that
03:42 - we wanted this data to be paired up with
03:44 - an index value for some reason well for
03:46 - example let's say that our data took
03:48 - place over a daily basis and we wanted
03:51 - to graph this so we want to pair it up
03:53 - by saying ok 100 is associated with day
03:56 - 0 200 is associated with day 1 300 is
03:59 - day 2 and so on now if we don't know how
04:02 - much data there's going to be then we
04:04 - can simply use the count function to
04:07 - provide values for any amount of data so
04:09 - for example we could simply say
04:11 - something like this so I will say daily
04:15 - underscore data is equal to and I'm
04:18 - going to use the zip function here and
04:20 - then I will pass in itertools dot count
04:23 - and as the first argument and then our
04:26 - data list as the
04:27 - the second argument now if you don't
04:29 - know what the built-in zip function does
04:30 - basically it combines two intervals and
04:33 - pairs the values together so it will get
04:35 - the first value of the count function
04:37 - which by default is zero and it will
04:40 - pair it with the first value of data
04:42 - which in this example is 100 and then it
04:44 - will move on and pair one with two
04:47 - hundred and two with three hundred and
04:48 - so on now the zip function will return
04:51 - an iterator itself that needs to be
04:53 - looped over in order to get all the
04:55 - values now if we want we can simply
04:57 - convert the results to a list and get
04:59 - them all at once so I could just convert
05:02 - this entire thing to a list by wrapping
05:05 - all of that in a list function so now
05:08 - that we've done that let me print out
05:09 - our daily data variable here so I will
05:12 - print that out then we can see that it
05:14 - paired those values up in our result and
05:17 - since we use itertools count it just
05:19 - kept grabbing the next value until our
05:21 - data list had gone through all of its
05:23 - values so that count function will work
05:25 - with any size of data okay so we can
05:28 - also pass some arguments into our count
05:30 - function in order to start at a
05:31 - different place and we can also step by
05:34 - a different amount as well so let me
05:37 - uncomment out these print statements
05:40 - here and for now I'm just going to
05:41 - comment out our data example here and
05:45 - let me actually grab these print
05:48 - statements and put these up here okay so
05:51 - now let's look at passing some arguments
05:52 - into our count function so if I wanted
05:55 - to start from something other than zero
05:57 - then I could simply pass in a value of
05:59 - start equals five for example if I save
06:02 - that and run it we can see that now our
06:04 - counter starts at five and we get five
06:05 - six seven eight now it's still counting
06:08 - up by one and we can also pass a step
06:10 - argument to change how the counter is
06:12 - incremented so if I started at five then
06:15 - I could also pass in an argument of step
06:17 - equals five if I save that and run it
06:20 - then we can see it now starts at five
06:22 - and now it's counting up by five each
06:24 - time so 5 10 15 20 now the counter is
06:27 - pretty versatile it can also count
06:29 - backwards and can also count by decimal
06:31 - numbers as well so if I was to instead
06:34 - say that our step is negative two point
06:37 - five for example and then run that then
06:40 - we can see that it starts at
06:41 - five and subtracts 2.5 from each step
06:44 - and then even goes into the negatives
06:46 - okay so that's a look at the count
06:48 - function now since we've already seen an
06:50 - example using the built-in zip function
06:53 - down here let me show you a knitter
06:54 - tools function that is just like this
06:56 - except it doesn't end until the longest
06:59 - iterable is exhausted and again the
07:01 - built in zip function ends on the
07:03 - shortest iterable
07:04 - so this itertools function is called zip
07:07 - longus so a pretty obvious name for what
07:09 - it does now remember this pairs
07:12 - iterables together so if it doesn't end
07:14 - until the longest interval is exhausted
07:16 - then it means it will need to pair some
07:20 - other values with some placeholders so
07:21 - by default that's going to be a none
07:24 - value so let me comment out these lines
07:26 - up here and uncomment out this example
07:29 - where we used this zip function here now
07:32 - this worked before because zip ends
07:35 - after our shortest interval is exhausted
07:37 - and we're not going to be able to use
07:39 - the itertools count function with the
07:41 - zip longest the way that we have it
07:43 - right here because we're converting it
07:46 - into a list and since count goes on
07:48 - forever then that would just run out of
07:50 - memory trying to convert that to a list
07:52 - now you could still use count and just
07:55 - not cast it to a list but then you just
07:57 - need to get the next values one at a
07:59 - time but let's leave this list here and
08:02 - simply replace count with a range of
08:04 - values instead so instead I'm going to a
08:07 - switch count out here and instead just
08:10 - say something like range of 10 values so
08:13 - if I run this right now while we're
08:14 - still just using this regular zip
08:16 - built-in then we can see that it runs
08:19 - just like it did before
08:20 - it just pairs those values up until our
08:22 - shortest interval is exhausted and the
08:25 - shortest interval here is data so as
08:27 - soon as all of our data is paired
08:29 - together then it just cuts off those
08:31 - values and it doesn't pair the rest of
08:33 - our range here but if instead we use zip
08:36 - longest from itertools
08:37 - so I'll say it err Tools dot zip
08:40 - underscore longest if I save that and
08:43 - run it then we can see that it pairs
08:45 - those intervals together but when our
08:47 - data variable runs out it continues and
08:50 - just pairs the rest of our range with
08:52 - none values so that can be useful
08:54 - depending on
08:55 - the type of problem that you're trying
08:56 - to solve so we can see here that it
08:59 - paired up the values and then this is
09:01 - where our data ran out but then it
09:03 - continued with the range and just put
09:05 - none values here for four or five six
09:07 - seven eight and nine okay so that was a
09:09 - quick detour looking at the zip longest
09:11 - function and now let's get back to
09:12 - looking at a couple more iterative tools
09:14 - functions that can go on indefinitely
09:16 - so let's look at the cycle function so
09:19 - cycle also returns an iterator that goes
09:22 - on forever basically it takes an
09:24 - iterable as an argument and will cycle
09:27 - through those values over and over so
09:29 - let me get rid of this example that we
09:31 - have here and uncomment out this so that
09:35 - we can see an example of this cycle
09:37 - function okay so instead of count I'm
09:39 - going to say itertools dot cycle and
09:42 - this takes in an iterator and basically
09:45 - like I said it's just going to cycle
09:46 - over these over and over so I will just
09:49 - pass in a list of one two three and four
09:52 - our print statements here I only have
09:54 - four here right now
09:55 - let me make this six total here so that
09:57 - we can see exactly what this is doing so
09:59 - I will save this and run it and let me
10:02 - zoom up a little bit okay so we can see
10:03 - that our output is just one two three
10:07 - one two three so it loops through our
10:10 - list that we just passed into cycle but
10:13 - once it hits the end of the list
10:15 - it just cycles back through so that's a
10:17 - pretty simple concept but there's a lot
10:19 - that you could do with it so for example
10:21 - if you wanted to simulate a switch of
10:24 - something getting turned on or off or
10:25 - something like that then you could
10:27 - simply create a cycle with two values so
10:30 - that could either be a 1 and a negative
10:32 - 1 or a 1 and a 0 or you could even pass
10:35 - in a list of strings of on and off so
10:38 - for example if I came up here instead of
10:41 - a list I'll actually use a tuple just to
10:43 - show a different data structure here and
10:46 - I'll say on and off as our two values in
10:49 - that tuple so if I save that and run it
10:51 - then if I screw up to the top here we
10:53 - can see that it just cycles between the
10:55 - values of on off on off on off each time
10:59 - the next value is fetched so that's a
11:01 - look at the cycle function it's super
11:03 - simple but there's a lot of different
11:05 - ways that we could use it okay so now
11:07 - let's look at the last
11:08 - infinite iterator and itertools and
11:10 - that's going to be the repeat function
11:12 - and this one is also super simple it
11:15 - just takes some input and repeats it
11:17 - indefinitely so for example if I was to
11:20 - come up here and say itertools dot
11:22 - repeat and then just pass in a value of
11:25 - two for example if I save that and run
11:28 - it then we can see that it simply
11:30 - repeats the same value over and over
11:32 - each time we fetch the next value and we
11:35 - can set a limit on this too so if I was
11:37 - to instead come up here and say repeat
11:39 - and then just say times equal to three
11:43 - and save that and run it then if I
11:45 - scroll up here a little bit then we can
11:46 - see that it repeats the value for the
11:49 - first three times and then it throws a
11:51 - stop iteration exception now if we had
11:53 - run that through a for loop then it
11:55 - would have just looped through that
11:56 - three times and we wouldn't have seen
11:57 - that exception since the for loop
12:00 - handles those stop iteration exceptions
12:02 - for us now on the surface this might not
12:04 - seem very useful but it's usually used
12:06 - for passing in a stream of constant
12:08 - values two functions like map or zip
12:10 - that also operate on intervals so for
12:13 - example if you wanted to get the square
12:16 - of the values one through ten then you
12:18 - could do something like this for example
12:21 - so I'm just going to comment out these
12:23 - print statements here so let me type out
12:26 - an example of this and I actually got
12:27 - this from the Python documentation so
12:29 - I'm going to say squares is equal to map
12:32 - and with map will use the pal function
12:36 - which takes the power of values and we
12:38 - will pass in arguments of a range of ten
12:42 - and also we'll do a knitter tools dot
12:45 - repeat and we'll just pass in a value of
12:48 - two there as well now if you don't know
12:50 - what map does basically it takes a
12:52 - function in this case we're using pal
12:54 - which raises a number to a certain power
12:56 - and then it takes iterables and uses the
12:59 - values from those to pass as arguments
13:02 - to that function and it will loop
13:03 - through and pass values from those
13:05 - intervals into a function until the
13:08 - shortest list of arguments has run
13:10 - through all of its values so this will
13:12 - start off by passing in the next value
13:14 - from our range and that would start at
13:16 - zero and it will also pass in the first
13:19 - value of our repeat iterable which is
13:22 - always going to
13:22 - - so the first value it will calculate
13:25 - is going to be zero to the second power
13:27 - and then the next time through it'll do
13:29 - one to the second power and then two to
13:31 - the second power and so on so if I print
13:34 - this out this is actually going to be
13:36 - needed to be converted to a list as well
13:40 - otherwise it's just going to be an
13:42 - iterator waiting to be iterated on but
13:44 - I'll cast it to a list so I'll just put
13:46 - out print out a list of those squares
13:48 - and run that now we can see that we got
13:50 - a list of the squares of all the values
13:52 - from zero to nine so that's a little
13:55 - more practical of an example of where
13:57 - you would use that repeat function like
14:00 - I said it's usually used for passing in
14:02 - a stream of constant values to a
14:04 - function like map or zip now since we're
14:06 - already using the map function this
14:08 - would be a good time to look at another
14:10 - itertools function that modifies the map
14:12 - function a little bit and this is called
14:14 - star map basically star map is very
14:17 - similar to map but instead of taking
14:20 - arguments from iterables like we're
14:21 - doing here it instead takes arguments
14:24 - that are already paired together as
14:25 - tuples so for example let's use star map
14:29 - to get these first few powers so instead
14:32 - of passing in range and this repeat here
14:35 - I'm just going to pass in a list and
14:37 - these are going to be a list of tuples
14:39 - that have the arguments already paired
14:42 - together and I'm just going to do the
14:43 - first few here so I'm going to go 0 to
14:46 - the second power and then let me go
14:48 - ahead and copy this to make this a
14:51 - little quicker so I'll do 0 to the
14:53 - second power then 1 to the second power
14:55 - and then 2 to the second power and
14:57 - instead of map we instead want to use
15:00 - itertools dot star map so if I save that
15:04 - and run it then you can see that it ran
15:08 - our arguments here as tuples into our
15:10 - power function and we got 0 1 & 4 for
15:15 - the results of those arguments so pretty
15:17 - similar to map but instead it takes its
15:19 - arguments as a list of tuples instead so
15:21 - depending on the problem that you're
15:22 - trying to solve that might be more
15:24 - useful for you ok so so far we've gone
15:26 - over itertools functions that produce
15:28 - iterators that can go on forever
15:30 - but now let's look at some useful
15:31 - functions that will eventually terminate
15:34 - so first let's go over two of the moe
15:36 - popular in Turtles functions and those
15:38 - are combinations and permutations so
15:41 - these allow us to take an iterable and
15:43 - return all of the combinations or
15:45 - permutations from that interval and if
15:47 - you don't know the difference between
15:48 - combinations and permutations basically
15:51 - combinations are all the different ways
15:53 - that you can group a certain number of
15:55 - items or the order does not matter and
15:58 - permutations are all the different ways
16:00 - that you can group a certain number of
16:02 - items where the order does matter so
16:05 - let's look at some examples and this
16:06 - will be more clear so I'm going to use a
16:08 - couple of lists hear from our snippets
16:11 - file and I'll post this snippets file in
16:13 - the code to this snippets file in the
16:15 - description section below if you want to
16:16 - use this as well but I'm just going to
16:18 - grab three code snippets here and I'm
16:21 - going to paste these up here at the top
16:23 - and to clean up what we have so far let
16:25 - me go ahead and just remove what we
16:28 - already have here and save that okay so
16:31 - for this example I'm going to use our
16:33 - letters list here that consists of the
16:35 - values of a b c d so let's say that i
16:38 - want to get all of the possible
16:40 - combinations of two values from those
16:42 - letters so to do that I can simply say
16:45 - I'll say result is equal to itertools
16:48 - dot combinations and I want to get the
16:51 - combinations of the letters and I want
16:54 - to get all the different combinations of
16:55 - two values and now let me make this
16:59 - output a little smaller here and now let
17:02 - me do a for loop where I say for item in
17:04 - result print the item so let me save
17:08 - that and run it and make this a little
17:11 - larger again okay so we can see that
17:13 - when we loop through those it gives us
17:15 - all the different combinations of two
17:17 - values that we can make from our
17:19 - original list of ABCD now remember with
17:22 - combinations the order does not matter
17:24 - so we can see that we have a combination
17:27 - here of a B but we don't see a
17:30 - combination of B a and that's because
17:33 - they are seen as the same combination
17:35 - and sometimes this is exactly what we
17:37 - want so for example if we're simulating
17:39 - a poker hand or something like that
17:41 - then it wouldn't matter what order your
17:44 - hand is in so an ace King would be the
17:46 - same thing as a king ace so you would
17:49 - need to produce bow
17:50 - of those combinations now if order does
17:52 - matter then you'll want to use
17:54 - permutations instead that will give you
17:57 - all of the different ways that you can a
17:58 - group certain number of items where the
18:01 - order does matter so let's go ahead and
18:03 - look at that so I'm going to just
18:05 - replace combinations here with our
18:07 - permutations function and rerun this so
18:10 - instead of combinations I will say
18:12 - permutations save that and run it and
18:14 - now if I scroll up here we can see that
18:16 - we got more values there and that's
18:19 - because we're going to get all the
18:20 - different ways that we can arrange two
18:21 - values from our original iterable where
18:24 - the order does matter so we can see that
18:27 - we have a value for a B here at the top
18:30 - but if we scroll down a little bit then
18:32 - we also have a permutation for BA as
18:34 - well now you can think of this as trying
18:36 - to simulate all of the different
18:37 - possible results of a race or something
18:40 - like that so if a came first and then B
18:43 - then that would be different than B
18:45 - coming first and then a so permutations
18:48 - is what you would want to use in a
18:49 - situation like that now one thing that
18:51 - you'll notice is that combinations and
18:53 - permutations don't repeat values so what
18:56 - I mean by that so for example with our
18:58 - permutations here we have all the
19:00 - different ways that we can arrange two
19:02 - items from our original list but it
19:04 - doesn't repeat any of those values so
19:06 - for example it doesn't give us a a as
19:09 - one of the permutations and that's
19:11 - because there's only one a in our
19:13 - original list but what if we wanted to
19:15 - allow repeats so for example let's use
19:18 - our numbers list so you can see how
19:20 - having numbers list here of 0 1 2 and 3
19:22 - so let's pretend that we wanted to see
19:25 - all the different ways that we could
19:26 - create a four-digit code using these
19:29 - values and that would include repeats so
19:31 - we could have a code that's 0 0 0 or 0 1
19:35 - 0 1 or anything like that
19:37 - well for that we couldn't use
19:39 - combinations or permutations because
19:42 - that will only give us the ways that we
19:44 - can range the values in that list if we
19:46 - wanted the values to be able to repeat
19:48 - then we could use the product function
19:50 - which will give you the Cartesian
19:53 - product of iterables that you pass in
19:55 - now if we only pass in one iterable then
19:57 - we can tell it how many times we want it
19:59 - to be able to repeat those values so
20:01 - with that said
20:03 - let's look at an example here so I'm
20:05 - gonna say itertools dot product and
20:07 - we're going to use our numbers here and
20:10 - let's say that we want to set repeat
20:13 - equal to four so what this is going to
20:16 - do is it's going to give us all the
20:17 - different ways that we could arrange
20:18 - these numbers where repeats are allowed
20:21 - so if I save this and run it and scroll
20:24 - up here to the top then we can see that
20:26 - this gives us what we were looking for
20:27 - in terms of going through all the
20:29 - different ways that we could arrange
20:30 - these numbers in groups of four now this
20:33 - is also a way that you could build some
20:34 - kind of password cracker so for example
20:37 - you could create a loop where you go
20:39 - through all the different ways to
20:40 - arrange alphanumeric characters in you
20:43 - know a pattern of six or something like
20:45 - that now I should also mention that
20:47 - there's a way to get combinations with
20:49 - repeated values as well and we do that
20:51 - with a function called combinations with
20:53 - replacements so if I just go up here and
20:56 - replace product with combinations whoops
21:00 - be sure to spell this right combinations
21:02 - underscore with underscore replacement
21:05 - and instead of repeat here we can just
21:07 - pass that and as a positional argument
21:10 - instead so if I save that and run it and
21:13 - go up here to the top then we can see
21:14 - that now we get all the different
21:16 - combinations of those four numbers but
21:18 - it allows repeated values as well so
21:21 - that's a look at some of the ways to get
21:23 - different groups of arrangements from an
21:25 - iterable and always find it fascinating
21:26 - to use combinations and permutations and
21:29 - products and they're definitely useful
21:30 - depending on what you're trying to solve
21:33 - okay so now let's look at some other
21:35 - useful itertools functions that allow us
21:37 - to solve certain types of problems so
21:40 - now let's look at the chain function so
21:43 - chain allows us to chain together
21:45 - intervals so that it will go through all
21:47 - the items in the first interval and
21:49 - after that has been exhausted then it'll
21:51 - go through all the items in the second
21:52 - interval and so on so I have three
21:54 - different lists here that I pulled from
21:56 - my snippets are there and let's pretend
21:58 - that we want to loop over all of these
22:00 - values and all of these lists so how
22:03 - would we do this so one way would be
22:05 - that we could create a new list that
22:07 - combines all three of these lists and
22:09 - then loops over those so we could say
22:12 - something like let me overwrite this
22:14 - part here so I could just say
22:17 - combined is equal to you know letters
22:20 - plus numbers plus names now the problem
22:24 - with an approach like this is that it
22:26 - creates a new list with all of those
22:28 - values in memory so the sample list that
22:31 - we have here are really short so it
22:33 - wouldn't be a big deal using it in this
22:35 - situation but what if these lists
22:37 - contain millions of items it would be
22:39 - majorly inefficient for us to make
22:41 - copies of all of those and put them into
22:43 - another variable or what if those
22:46 - weren't even list a that they were
22:48 - generators or something like that
22:49 - instead then how would we loop over all
22:52 - of those at once well to do this we can
22:54 - use chain so instead of doing it the way
22:57 - we have here let's instead say combined
23:00 - is equal to itertools dot chain and I
23:04 - will just pass in all of those to our
23:06 - chain so letters numbers and names so
23:10 - now if we loop over these I'll say for
23:13 - item in combined then we will print out
23:18 - the item if I save that and run it then
23:21 - if I scroll up here then we can see that
23:23 - first loop through our letters and after
23:25 - those were exhausted it looped there our
23:26 - numbers and then our names at the end so
23:29 - we can see that it looped over all of
23:30 - the items in all three of those
23:32 - iterables so that can be extremely
23:34 - efficient depending on the data that
23:36 - you're iterating over okay so now let's
23:38 - look at a function that will allow us to
23:40 - get a slice of an iterator so you can
23:43 - think of this like list slicing where
23:45 - you can specify that you only want the
23:47 - first five item items of a list or
23:49 - something like that but this function
23:50 - will allow us to perform slicing on an
23:53 - iterator and this function is called I
23:55 - slice so to use this there are three
23:57 - different arguments that we can pass in
23:59 - we can pass in a stopping point to go
24:01 - from the beginning of an iterator until
24:03 - it hits a stopping point so for example
24:06 - let's say that I wanted to slice a range
24:08 - from 0 to 9 and stop on the fifth index
24:12 - so to do that I could just come up here
24:14 - and say itertools dot I slice and we
24:18 - will slice a range of 10 values and I
24:22 - will pass in a stopping value of 5 now
24:26 - instead of combined here I'm just going
24:28 - to change that to result so that that
24:29 - variable makes more
24:30 - I also have to change it in the for loop
24:32 - here as well so if I save that and run
24:35 - it then we can see that it gives us the
24:37 - first five items of that iterable now if
24:39 - you're thinking to yourself you know why
24:41 - is this useful because I can already do
24:43 - that with list slicing well don't worry
24:45 - we'll look at some useful examples here
24:47 - in just a minute okay so we can also
24:49 - pass in a starting point argument into I
24:52 - slice as well now if there's only one
24:54 - argument like we have here then it will
24:56 - assume that it's the stopping point but
24:58 - if we put in two arguments then it will
25:00 - assume that it is the starting point and
25:02 - stopping point so if we wanted to skip
25:05 - the first value then I could come in
25:07 - here and just say one as our first
25:10 - argument and then five and it'll think
25:12 - that one is the starting point and five
25:14 - is the stopping point so if I save that
25:16 - and run it then we can see that now it
25:18 - started at index 1 and stopped at index
25:21 - 5 and lastly we can also do steps so if
25:24 - we want to do the same slice that we
25:26 - have now but only get every other value
25:28 - then we can simply say that we want to
25:30 - step by 2 so up here I can also pass in
25:34 - another argument there as a 2 and
25:37 - that'll be the step so if I save that
25:39 - and run it then we can see that we get
25:41 - the values from the 1st to 5th index but
25:44 - it steps by 2 okay so why is this useful
25:48 - so this is useful because like with our
25:51 - other examples so far we may have an
25:53 - iterator that is just too large to put
25:55 - into memory so we don't want to cast it
25:58 - to a list just to get a certain slice of
26:00 - that iterator so for example let's
26:03 - imagine that we have some log files on
26:04 - your machine that are thousands and
26:06 - thousands of lines but you only want to
26:08 - grab the top few lines that are the
26:11 - header of the log file so to do this
26:13 - efficiently we can use I slice now I
26:16 - have a sample file here where I'm going
26:18 - to do this so I have a sample file
26:20 - called test log and this is it here and
26:23 - we can see that we have some fake data
26:24 - in here but the top three lines have the
26:27 - date the author and the description so I
26:31 - just want to grab those and ignore
26:32 - everything else so let's do this using I
26:35 - slice so I'm going to come back to the
26:38 - demo here I'll make this a little
26:40 - smaller here and for now I'm just going
26:42 - to comment out our previous example
26:44 - and scroll down here a little bit and
26:46 - now let's use this I slice on this log
26:51 - file so I'm gonna say with open to open
26:54 - this file and that file was called test
26:57 - dot log now this is in the same
26:59 - directory as my python file so I don't
27:01 - have to pass in a full path if it's in
27:03 - the same directory then it'll work just
27:05 - like this and I want to read that file
27:08 - and now that we have that file open
27:11 - files are actually iterators themselves
27:14 - and whenever you call next on them it
27:16 - gets the next line in the file so we can
27:19 - use them just like any other iterator so
27:21 - in order to just grab the header I'm
27:23 - going to say that the header is equal to
27:25 - itertools
27:26 - dot I slice I've spelled that wrong I
27:29 - slice we will pass in the file as the
27:32 - first argument and let's just pass in a
27:35 - 3 and remember with one argument that's
27:38 - just going to be the stopping point so
27:40 - it's gonna start at the beginning which
27:41 - is the first line and just go up to 3 so
27:44 - that should grab me the first three
27:46 - lines of the file so now I'm going to
27:48 - loop over those so I'm gonna say 4 line
27:50 - in header go ahead and print each of
27:54 - those lines so I will save that and run
27:58 - it and we can see that it prints those
28:00 - first few lines from the log file now
28:02 - those are broken up on two different
28:03 - lines but that's just because the line
28:05 - itself has a newline character in it and
28:08 - the print function also adds a line
28:10 - between print statements now if we
28:12 - wanted to get rid of that then we could
28:14 - just simply come up here to our print
28:15 - statement and say end is equal to an
28:19 - empty string and it won't add an empty
28:21 - line between those print statements so
28:24 - if I save that and run it then we can
28:26 - see that now it just gets those first
28:28 - few lines so that's useful because if we
28:30 - were looping over tons of large files
28:32 - and getting just these few lines then
28:35 - doing it this way will allow us to get
28:36 - those values without loading the entire
28:38 - contents of that file into memory ok so
28:42 - now that we've seen that now let's look
28:44 - at a few functions and Inter tools that
28:46 - allow us to select certain elements from
28:49 - an iterable first let's look at the
28:51 - compressed function so compress is a
28:54 - function that I could see being used in
28:56 - data science style problems
28:58 - where you have some data and some
28:59 - selectors that you can use to filter
29:01 - down that data so let's say that we have
29:04 - a list of true/false values that
29:06 - correspond to my letters list here so
29:09 - first let me just get rid of this file
29:11 - example here and scroll back up and now
29:14 - like I was saying let's say that we have
29:18 - a list of true/false values and they're
29:20 - gonna correspond to my letters list here
29:22 - and I'm going to call these selectors so
29:24 - I'll say selectors is equal to and this
29:27 - will just be a list and I'll just pass
29:29 - in a list of true true false true so we
29:34 - can just pretend that this is another
29:36 - column of data of true/false values and
29:38 - we could pretend that this is anything
29:40 - like if someone is over the age of 21 or
29:42 - if they're married or whatever so we can
29:45 - use the compress function and pass in
29:48 - our iterable with these selectors and it
29:50 - will return a new iterable that only
29:52 - contains the items in our iterable that
29:55 - had a corresponding true value so this
29:58 - will make more sense when we see this
30:00 - example so let me uncomment out our code
30:03 - here and instead of I slice I'm going to
30:06 - instead look at the compressed function
30:09 - so I'll say compress and let's pass in
30:12 - our letters here and also pass in those
30:16 - selectors now like I said this compress
30:18 - function should return and iterable that
30:22 - has all of our corresponding letters
30:24 - that had true values and our selectors
30:27 - so if I save that and run it then we can
30:29 - see that it gives us the values of a B
30:31 - and D so C wasn't included because it's
30:35 - corresponding selector was false now you
30:38 - might notice that this is kind of
30:39 - similar to the built-in filter function
30:41 - the difference is that filter uses a
30:44 - function to determine whether something
30:46 - is true or false but with compress those
30:48 - values are just passed in as an iterable
30:51 - so depending on your problem that you're
30:53 - trying to solve you would use whichever
30:55 - of those are most appropriate so let me
30:57 - show you how filter works really quick
30:59 - just so we can compare the two
31:00 - so with filter we need to create a
31:03 - function so I'm going to create a
31:05 - function here at the top and I'm just
31:07 - going to say I'm going to call this LT
31:10 - to for values
31:11 - less than two and we'll take in a value
31:14 - of in there and so I'll just say if n is
31:17 - less than 2 then we want to return true
31:20 - otherwise we'll just return false and
31:23 - now if we run an interval through that
31:25 - built-in filter function using this
31:27 - function that we just created
31:29 - then it will give us all of the values
31:31 - that are less than 2 so for our result
31:34 - here I'll just say filter and I will use
31:37 - that function that we just created which
31:40 - was LT 2 and I'll pass in our numbers
31:43 - list here so let me save that and run it
31:45 - and we can see that when we run that we
31:47 - get the numbers that are less than 2 now
31:50 - there are some functions and itertools
31:51 - that compliment these built-in functions
31:53 - so there is one integer tools called
31:56 - filter false and it's just like this
31:58 - built-in filter function except instead
32:01 - it gives you the values that return
32:02 - false instead of true so instead of
32:05 - using this built-in filter function here
32:08 - if I instead said itertools dot filter
32:13 - false if i save that and run it then we
32:16 - can see that now we get the values that
32:18 - are greater than or equal to 2 because
32:20 - those are what returned false from our
32:23 - function now there are two more
32:25 - itertools functions that are similar to
32:28 - filter but these stop filtering once a
32:31 - function returns true now I don't think
32:33 - I've ever found the need to actually use
32:35 - these but I'm sure they could be useful
32:37 - in certain situations so first let's
32:39 - look at drop while so the drop while
32:42 - function will drop values from an
32:44 - iterable until one of the values returns
32:47 - true so for and then from that point on
32:49 - it simply returns the rest of the
32:51 - iterable so to show you the difference
32:52 - from filter let me put in some other
32:55 - values at the end of our numbers list
32:56 - here that would have been filtered out
32:59 - so I will say 0 1 2 3 then 2 1 0 so if I
33:06 - save this with those new values and run
33:08 - this then we can see that the values
33:10 - greater than or equal to 2 still get
33:13 - filtered out but instead let's use drop
33:16 - while instead of filter false so I will
33:19 - say drop while and use the same
33:21 - arguments and if I save that and run
33:24 - that now
33:24 - and scroll up here a little bit then we
33:27 - can see that our first couple of values
33:29 - were less than two so it dropped those
33:32 - but once it hit a value that was greater
33:34 - than or equal to two then it stopped
33:37 - applying that filter and just returned
33:38 - the rest of the iterable so it doesn't
33:41 - filter out all of those values just the
33:43 - drops the first few ones that met that
33:45 - criteria so our result down here was
33:48 - equal to two three two one zero so
33:51 - everything after those first couple of
33:53 - values now again I don't think I've ever
33:54 - personally used this but I'm sure there
33:56 - are situations where it could be useful
33:58 - and for the opposite of that we also
34:00 - have the take while function so take
34:03 - while well instead grab all the values
34:05 - that return true and as soon as it hits
34:08 - a value that doesn't return true then it
34:10 - will just return the values that it has
34:12 - at that point so see what this looks
34:15 - like
34:15 - instead of drop while I will simply
34:17 - replace this with take while so let's
34:19 - save that and run it and we can see that
34:21 - what it did there was take the values
34:23 - that return to true from our function
34:26 - until it hit a value that returned false
34:29 - and after it got a value that returned
34:31 - false then it just returned the values
34:33 - that it had up until that point so 0 was
34:36 - less than 2 so it added that one was
34:38 - less than 2 so that added that then it
34:40 - hit 2 which is equal to or greater than
34:43 - 2 and so it just stopped at that point
34:45 - and return 0 and 1 ok so we're just
34:48 - about finished up I know that this video
34:49 - is getting a little long but we only
34:51 - have a couple more functions to go over
34:53 - so another function that we're going to
34:55 - look at is called accumulate so just
34:58 - like it sounds
34:59 - this takes an iterable and returns
35:00 - accumulated sums of each item that it
35:03 - sees and it keeps using addition by
35:06 - default but you can use other functions
35:08 - as well you know such as multiply or
35:11 - something like that
35:12 - so let's pass our numbers list and the
35:14 - through this accumulate function and see
35:17 - what this does so let me scroll up here
35:19 - a little bit I'm gonna get rid of our
35:20 - selectors and our function here we're
35:23 - not gonna need those anymore and now I
35:27 - just want to use this accumulate
35:31 - function and I want to pass in our
35:33 - numbers in to this function okay so if I
35:37 - run this
35:38 - then we can see that each time through
35:41 - the loop it just keeps a running total
35:44 - of the values that it has seen so far so
35:47 - it starts at 0 and then 0 plus 1 is 1
35:50 - and then 1 plus 2 is equal to 3 and then
35:55 - 3 plus 3 is equal to 6 and it just keeps
35:59 - doing that all the way through our list
36:01 - so whenever we scroll down here it kept
36:04 - a total sum of 9 at the end and we can
36:07 - pass in different functions as well so
36:09 - if we wanted to multiply these values
36:11 - instead of adding them then we can
36:13 - simply say so we'll have to actually
36:16 - import something here I'm gonna import
36:19 - it here at the top actually so I'll say
36:21 - import operator because we need to grab
36:24 - this multiply function so down here I
36:28 - can now say for the function that we
36:30 - want to use operator dot mu L for
36:33 - multiply function and now if we run that
36:36 - using this data now this isn't very
36:39 - exciting because all of our values are
36:41 - going to be 0 since our first value here
36:43 - was 0 everything multiplied by 0 is
36:45 - going to be 0 so instead let me just get
36:48 - rid of that first 0 there and rerun this
36:51 - scroll up then now we can see that it's
36:53 - keeping a running product so 1 times 2
36:56 - is 2 2 times 3 is 6 6 times 2 is 12 and
37:00 - so on okay so that is the accumulate
37:03 - function okay so now let's take a look
37:06 - at our last major function in itertools
37:08 - and that is going to be called group by
37:10 - now I saved this one for last since it's
37:12 - a little harder to explain but hopefully
37:15 - after you see the examples it'll be a
37:17 - bit easier so this will go through an
37:19 - iterable and group values based on a
37:21 - certain key and then it will return a
37:24 - stream of tuples now the tuples consist
37:27 - of the key that the items were grouped
37:29 - on and the segment value of the tuple is
37:32 - an iterator that contain all of the
37:34 - items that were grouped by that key so I
37:36 - know that that sounds confusing but
37:38 - let's take a look at an example and
37:40 - hopefully this will sink in so to show
37:42 - this I'm gonna grab some code from my
37:44 - snippets here so up here and my snippets
37:46 - I'm gonna grab this big list of
37:48 - dictionaries here and I'm going to
37:52 - this right here into our code and
37:55 - actually just to make this more clean
37:57 - I'm just going to replace everything
37:59 - except our itertools import so let me
38:02 - repay stat in there and like I said I'll
38:04 - have a link to these code snippets and
38:06 - the description section below
38:07 - if you'd like to follow along with this
38:09 - so what we have here is a list of
38:12 - dictionaries and each dictionary in this
38:14 - list contains some information so we
38:17 - have a person's name and a city and a
38:21 - state
38:22 - so let's say that we wanted to group all
38:24 - of our people by the state that they're
38:26 - from so how would we do that
38:28 - well that's what our group by function
38:31 - can help us with but first we're going
38:33 - to need a function that tells group by
38:35 - exactly what we want to group on and
38:38 - that's going to be our key so we need to
38:40 - write a function that tells us what to
38:42 - return from a single item in our
38:44 - iterable so I'm gonna go up here to the
38:47 - top and I'm going to create a function
38:49 - here just called get state and this is
38:52 - going to take in a person because that's
38:54 - what a single item from our interval is
38:55 - going to be is it's going to be a
38:57 - dictionary that represents a person and
38:59 - now we just want to return what we want
39:02 - our key to be so I'm just going to say
39:04 - return person and we're going to access
39:07 - that state value so that is going to
39:11 - tell group by that for every item in our
39:13 - interval we want to group by the state
39:15 - so now let's actually run this so down
39:18 - here at the bottom and you can see that
39:20 - this list we have several people here in
39:22 - our list now down here at the bottom I'm
39:25 - gonna say person underscore group and
39:28 - I'm gonna set this equal to and we will
39:30 - say itertools itertools dot group by and
39:35 - we want to group this list and this list
39:38 - is called
39:39 - people so I'll scroll back down here so
39:41 - this is called people and we want the
39:43 - key to be equal to that get state
39:46 - function that we created and now let's
39:49 - loop over this so each item in this
39:51 - person group is going to be a tuple of
39:54 - two things so the first thing is going
39:56 - to be our key and the key that we used
39:59 - was the state and the second is going to
40:02 - be an iterable of all the items in that
40:05 - so it should be an iterable of each
40:07 - person in that state so let's print both
40:10 - of these out just so we can see what
40:11 - this looks like so I'm gonna say four
40:13 - key and group in our person group and
40:17 - for now let's just print out both the
40:21 - key and the group so if I save this and
40:24 - run it then we can see let me make this
40:26 - a little larger here we can see that we
40:28 - have four different groups one for each
40:31 - state that was present in our list of
40:34 - people and our group variable here is an
40:37 - iterable that should contain all of the
40:39 - people from that state so let's also
40:42 - loop over that group and print those out
40:44 - as well so within our for loop here I'm
40:48 - just going to print the key on the first
40:50 - line and now I'm gonna loop over that
40:52 - group so I'm gonna say for person in
40:55 - group and we just want to print out that
41:00 - person and I'm also going to put a print
41:03 - statement here at the end and that's
41:05 - just going to be to spread out our
41:06 - output a little bit so now let me save
41:09 - this and run it and scroll up here to
41:12 - the top and again let me make this just
41:15 - a little larger okay so in our output
41:18 - here we can see that we are first
41:20 - printing out our key and that's what we
41:22 - print it out right here which is the
41:24 - state and then we're looping over the
41:26 - group which are the people that are in
41:28 - that state so we can see that from New
41:31 - York we have John Doe and Jane Doe and
41:33 - then it moves on to Colorado and prints
41:35 - out the people from there then it goes
41:37 - to West Virginia and prints those out
41:38 - and finally North Carolina so our group
41:41 - by function did a lot of work in the
41:42 - background there for us just to get
41:45 - those results in a nice efficient way
41:47 - now there are all kinds of interesting
41:49 - problems that we can solve using this
41:51 - group by function so for example what if
41:53 - instead of printing out all the people
41:55 - from that state we just wanted to print
41:56 - the number of people in our list from
41:58 - there so instead I'm just going to
42:00 - comment out our for loop there instead
42:02 - I'm just going to print out our key and
42:04 - then just the length of our group so if
42:07 - I save that and run it oh and that's
42:09 - actually an iterator I forgot so we have
42:11 - to cast that to a list before we can get
42:13 - the length so if I cast that to a list
42:17 - and then rerun this then we can see that
42:19 - in our
42:19 - list we had two of those people from New
42:21 - York two from Colorado two from West
42:22 - Virginia and three from North Carolina
42:24 - so you can probably think of all
42:25 - different types of problems that you
42:27 - could use to solve with this group by
42:28 - function so for example how many
42:30 - students in your class got AIDS versus
42:33 - bees versus C's and so on sorts of
42:35 - problems like that now one thing that I
42:37 - should mention is that group by expects
42:40 - the initial iterable to be sorted so
42:42 - that it can group properly so if we look
42:45 - at the initial list of our values then
42:47 - the people are already sorted by state
42:49 - so we have the people from New York
42:51 - first people from Colorado second and so
42:54 - on now if we were to put someone from
42:56 - New York onto the end of that list then
42:58 - it wouldn't include them in the first
43:00 - group of people from that state so group
43:02 - by is a little different than the SQL
43:04 - version of the group by function in the
43:06 - sense that it needs the values to be
43:08 - sorted beforehand and we won't cover
43:10 - sorting in this video but if you want to
43:13 - see how we'd sort a list of dictionaries
43:15 - like this then I do have a separate
43:17 - video on sorting where I covered all of
43:19 - that and I'll be sure to put that in the
43:21 - description section below as well
43:22 - okay so we're basically finished up but
43:24 - I wanted to show you one last thing that
43:26 - we'll just take about two seconds so
43:28 - let's say that we wanted to replicate an
43:30 - iterator now this can sometimes be
43:32 - harder to do than we think
43:34 - well the inner tools module gives us a
43:36 - nice simple function for replicating
43:38 - iterators easily and we can do this
43:41 - using the T function so let's say that I
43:44 - wanted to replicate this person group
43:47 - and to do two different intervals so to
43:49 - do that I could simply come down here
43:52 - and say copy one copy to is equal to
43:56 - itertools dot t and that is te e and
44:00 - then just pass in that person group and
44:03 - if you were to run that then now your
44:05 - copy 1 and copy 2 will be their own
44:08 - individual intervals and if we wanted
44:10 - more copies then we could just pass in
44:12 - an argument to this T function and
44:14 - return however many that we'd like and
44:17 - one thing to note is that you should no
44:20 - longer use the original iterator after
44:22 - you copy it so in this example it means
44:25 - that we should only use these copies of
44:27 - copy one and copy two and not use this
44:30 - original person group iterator
44:32 - after that we've made the copy or it
44:34 - could have unintended consequences of
44:36 - exhausting the items in the replicates
44:38 - so that's something to keep in mind
44:40 - there now on a side note I actually have
44:43 - no idea what T stands for or why they
44:47 - named it that rather than something a
44:48 - little more intuitive so if anyone knows
44:50 - what that means then feel free to let me
44:52 - know in the comments I think it comes
44:54 - from a Linux command with the same name
44:56 - but I'm not too familiar with that Linux
44:58 - command either but anyways with that
45:00 - said I think that is going to do it for
45:02 - this video hopefully now you have some
45:04 - ideas for how you can begin to use the
45:06 - itertools module and your daily coding
45:08 - and possibly write some more efficient
45:10 - code but if you do have any questions
45:12 - about what we covered in this video then
45:14 - feel free to let ask in the comment
45:15 - section below and I'll be sure to answer
45:17 - those and if you enjoy these tutorials
45:19 - and would like to support them then
45:20 - there are several ways you can do that
45:21 - these its ways to simply LIKE the video
45:23 - and give it a thumbs up and also it's a
45:25 - huge help to share these videos with
45:26 - anyone who you think would find them
45:28 - useful and if you have the means you can
45:29 - contribute through patreon and there's a
45:31 - link to that page in the description
45:32 - section below
45:33 - be sure to subscribe for future videos
45:34 - and thank you all for watching
45:47 - you