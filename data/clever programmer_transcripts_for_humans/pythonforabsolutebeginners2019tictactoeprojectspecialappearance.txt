With timestamps:

00:00 - - Hey you.
00:01 - In this video we have put together
00:03 - an amazing app for you with Python,
00:05 - it's the Tic Tac Toe app
00:07 - and we're gonna go through
the process of building it
00:10 - from complete scratch all
the way to the finish.
00:13 - Something special that we
got for you in this video
00:15 - is that we're going to gift
you this app at the end.
00:19 - So all it will be is
it's gonna be just a link
00:23 - and we're gonna send you that link
00:24 - and you'll be able to use
this application on your own,
00:27 - and steal it and also have
access to the entire code base
00:31 - just in case for some reason,
00:32 - if you're trying to build it with us,
00:34 - you cannot complete it or you
run into any kind of errors.
00:38 - This way you will be error free.
00:40 - So with that said, and
before we jump right into it,
00:44 - this video is made by Aaron Bernath,
00:48 - who is our software developer
00:49 - and a new addition to the
Clever Programmer team.
00:53 - He's an amazing developer.
00:54 - He's new to the team
00:56 - in terms of making
trainings and tutorials.
00:59 - So this is his first
app, show him some love
01:02 - and our goal in the future is to get Aaron
01:04 - to make a lot of awesome coding
tutorials for this channel.
01:09 - I hope you love it.
01:10 - Please leave a comment and
tell him something encouraging.
01:13 - With that said, let's jump right into it.
01:16 - (jingle music)
01:20 - (beeps)
01:32 - - [Aaron] Hey, what's up guys?
01:34 - This is Aaron from Clever Programmer
01:35 - and today we are going to be coding
01:37 - a Tic Tac Toe app in Python.
01:40 - So let's jump right into it.
01:42 - (hip hop beats)
01:47 - First, let's go to repl.it,
01:49 - just type that in the URL bar,
01:50 - follow along please so you can learn.
01:54 - Make an account if you haven't already.
01:55 - This is called Repl It.
01:57 - Once you are done with
that and click on my repls,
01:59 - you'll be on this page.
02:01 - It'll probably be empty.
02:02 - You want to have this stuff here.
02:03 - Click on the red plus
sign, click on Python,
02:05 - which will automatically be Python three
02:08 - and Boom, you will be
in an empty repl here.
02:10 - So all this is, is just
a nice little environment
02:12 - where you can code on this website.
02:14 - You don't have to worry
about any setup or anything.
02:16 - It's just nice and clean
and it doesn't break
02:18 - which is very nice because sometimes
02:19 - recording on your own computer,
02:21 - there's a lot of weird edge
cases and it's just the.
02:25 - So on left here, we have
a little file directory.
02:27 - We're only gonna have one
file for this project,
02:29 - so you don't really have
to worry about that.
02:30 - Over here we have our one
and only file open main.py
02:33 - and over on the right side
02:34 - we have a little Python environment.
02:36 - So let's, check this out.
02:38 - Yoyoyoyoyoyoyo.
02:41 - Okay, yo see so it works.
02:44 - This is where all the
game will be played at.
02:46 - This little command line
here and let's jump right in.
02:49 - So Tic Tac Toe.
02:53 - Sometimes I attack small
problems this just straight in.
02:55 - I just start coding, just kind of hacky,
02:58 - but it's kind of too
for these little things.
02:59 - But if you are working on a big code base,
03:02 - you actually want to think about it first.
03:05 - So let's at least do that first.
03:07 - Just have like a little bit
of a overarching game logic.
03:11 - So let's think about it.
03:12 - Well, we're gonna need a board.
03:15 - And then we're going to need to be able
03:16 - to display that board.
03:19 - We're also going to need to play a game.
03:24 - So start the game and
then have it keep going,
03:27 - alternating turns from X to O to X to O.
03:30 - I'm assuming you guys don't
have to play Tic Tac Toe.
03:31 - If you don't, please look it up.
03:35 - All right, welcome back.
03:36 - So we're gonna need a
function to play game.
03:41 - We're also gonna need a function
03:42 - to check if there's a win.
03:43 - So check win.
03:44 - We're also gonna need to function
03:46 - for checking if it's a tie.
03:48 - We'd also maybe need a function
to flip between players.
03:54 - So flip from player X to player O.
03:57 - Flip player and yeah.
03:59 - And within check win, then
we're probably going to do
04:01 - something check rows
to see if there's a win
04:06 - and then maybe check columns.
04:09 - To check the whole, all the columns
04:12 - and then also you're gonna
have to check diagonals.
04:15 - So to check if there is a win
04:17 - we'll check all these
things and then at the end
04:19 - if there's a three in
a row in any of these,
04:21 - then we can say, yeah, somebody won
04:23 - and then just return to
player and so on and so forth.
04:26 - Checking after the tie
04:27 - and maybe we could just be like, hey,
04:29 - if the entire board is full
and then there's no winner,
04:34 - then yeah, then it's a tie.
04:37 - I think maybe something like that.
04:40 - Maybe even one more like play game.
04:42 - Maybe there could be
something like handle a turn.
04:47 - I forgot to put a little
comment sign here, but yeah,
04:48 - handled a turn like that.
04:51 - Maybe this is a nice general over overview
04:54 - kind of high level idea of the game.
04:56 - So we're gonna need a board.
04:57 - We're getting to a way
to display that board,
04:59 - we're gonna need something to
run in an overarching game.
05:02 - We're gonna be able to handle turns
05:03 - when somebody takes a
turn like taking input,
05:05 - putting it on the board making
sure that it's valid input
05:08 - and then after we handle a turn
05:09 - we have to check if there's a win.
05:11 - We can check the rows,
columns and diagonals
05:13 - and then we can check
if there's a tie as well
05:15 - and then after all that's done,
05:17 - then we can flip to the other player.
05:19 - And then go back and then
just repeat the whole process.
05:23 - Something like that.
05:23 - I mean it might change as we go,
05:25 - but just have a general
idea of what's going on
05:28 - when you want to code something.
05:30 - If I was actually coding a different game
05:32 - like rock, paper, scissors, maybe I would
05:33 - I'm not gonna type it all,
but I'll just tell you guys.
05:35 - If I was trying to pull
the rock paper scissors,
05:37 - I would need, okay rock, paper, scissors.
05:39 - I could have the words and
then I would need some way
05:43 - to select rock, paper, scissors
05:45 - and then some way for the computer
05:47 - to randomly generate
rock, paper, scissors.
05:49 - And then I'll need a way to compare them
05:51 - and then a way to see who
wins and so on and so forth.
05:56 - So just thinking,
breaking the problem down
05:59 - into its little pieces we did here
06:00 - and then actually start
implementing it from there.
06:05 - I it will most likely change.
06:06 - It always changes for me.
06:07 - I mean as long as you have an overarching
06:09 - high level understanding,
06:11 - then you are at least
equipped to start coding.
06:13 - So I might delete this
06:15 - but I'll probably just
keep it here at the bottom.
06:16 - Why not?
06:18 - So let's just start.
06:19 - So nice and easy.
06:20 - What are we gonna need first?
06:21 - We'll first, we're going to need a board.
06:25 - Very simple.
06:26 - I am just gonna make it list.
06:28 - Let's just do that and
I want each one to be,
06:34 - each position on the
board to be an empty spot.
06:36 - If it's empty, I just want
it to be a minus like that.
06:39 - And then let's just a copy this.
06:43 - Nine times four or five,
six, seven, eight, nine.
06:54 - And voila.
06:56 - Our game board was coated
in approximately 27 seconds.
06:59 - Awesome.
07:00 - It's just a simple list.
07:01 - I just spread it out like
this, so it's easier to see.
07:04 - So now we have our empty
game board for Tic Tac Toe.
07:07 - Awesome, right?
07:08 - Let's move on.
07:09 - Next, we are going to need
a way to display that board.
07:13 - So, let's get that going because
right now when we hit run,
07:16 - absolutely nothing happens.
07:19 - Let's do that first.
07:20 - So what would that look like?
07:23 - We just gonna need a function, define.
07:28 - I don't know, display board just like that
07:32 - and then maybe print board at zero.
07:45 - Yeah, let's do it like this.
07:48 - Print the board at zero plus board at one
07:56 - plus board at two
08:04 - and yeah, let's just do that three times
08:11 - but so position zero one, two,
08:13 - we're gonna need three, four,
08:16 - five there and then six, seven and eight.
08:23 - Boom.
08:24 - All right.
08:26 - Yeah, let's just see how this looks.
08:28 - Run, it didn't work
08:30 - because we didn't call
the function of course.
08:34 - So display board just like that.
08:38 - Now let's run it and boom,
we have an empty board.
08:42 - Pretty cool, right?
08:44 - All right, so the positioning would be
08:51 - one, two, three.
08:52 - Yeah, so now that we have
our board, we can move on.
08:55 - From here, maybe let's
try to start a game.
09:01 - So this is the first place to start.
09:07 - Let's just make it a
function called play game.
09:12 - Game, just let that.
09:18 - Define, I suck at this you guys.
09:22 - Why am I teaching this?
09:24 - Anyways, so play game.
09:29 - Play game will probably be
probably be the function
09:32 - that drives the entire game.
09:36 - So maybe the first thing
that we would do is
09:38 - okay, the first thing is display the board
09:41 - because when we're playing a game,
09:42 - the first thing I want to
do is display initial board.
09:46 - Just like that.
09:47 - Always put comments in your code guys.
09:48 - If it's really, really
simple, you don't need to
09:50 - like actually here, maybe
you wouldn't have to
09:52 - because this is so well named by me
09:55 - that you don't actually need a comment,
09:57 - but hey, might as well throw it in there.
09:59 - It makes it easier for other people
10:00 - to understand what the
heck you're trying to do.
10:02 - They can't read your mind, okay.
10:06 - I've had some jobs, some internships
10:07 - where that was an issue.
10:10 - I'll stop there.
10:12 - Anyways so let's display the board
10:16 - but now, we are going to
need to call play game
10:21 - to actually start the
whole function chain.
10:25 - So, when Python's going through this,
10:27 - it will create this board.
10:28 - It'll see this as a function.
10:29 - It'll save all this code somewhere.
10:30 - It'll see this as a function.
10:31 - It will save this code somewhere
10:34 - and then it will see this and they'll say,
10:35 - oh, I want to play game.
10:36 - So it calls this function here
10:39 - and then it'll actually
call this, which calls this,
10:42 - which prints all this,
which reads from this,
10:45 - which makes it look like this.
10:48 - If you're not watching.
10:49 - If you're looking away from your screen,
10:50 - that made absolutely zero sense.
10:52 - So make sure you rewind
and watch the screen
10:54 - because I do a lot of highlighting here.
10:56 - I went to school for highlighting.
10:59 - Yeah I'm filled with a lot of bad jokes.
11:01 - Just ask Qazi.
11:03 - You get used to it.
11:04 - Anyways, where was I?
11:07 - So so display the initial board
11:09 - and then from here, maybe the
next thing would have to do
11:12 - is I don't know, like handle a turn.
11:15 - So let's just try to handle
the first turn first.
11:18 - So handle turn will be a function.
11:21 - I always like to put things in functions
11:22 - if it's a different concept,
so displaying the board,
11:25 - I stuck that on a function.
11:26 - If I want to handle a turn,
11:27 - I'm gonna stick it in a function.
11:29 - Let's just do that here.
11:30 - So define, handle turn, boom.
11:34 - You have a little function coded up.
11:35 - I like two spaces.
11:39 - Two lines between my
functions just to be easier
11:42 - to read and hear too.
11:46 - So handle turn.
11:49 - What could we have in handled turn.
11:51 - Well handle turn would need to first,
11:56 - probably get the position from the player
12:02 - that they want to go into.
12:03 - So maybe something like
this position equals,
12:13 - what's the function input.
12:14 - I was trying to remember the
python function for input.
12:17 - So input will ask for something
12:19 - from the command line over here
12:20 - and then when they enter
it and press enter,
12:22 - then that whatever they press enter
12:23 - will actually go into
position here as a string.
12:28 - So let's say, I don't
know, choose a position
12:33 - from one to nine.
12:37 - And just like that.
12:39 - I chose one to nine because
it just makes sense.
12:41 - If this is position one,
this is position two,
12:43 - this is position three, so on
12:45 - four, five, six, seven, eight and nine.
12:47 - You can just type in the number
12:48 - and whatever position you choose,
12:50 - that is where your piece will go.
12:52 - So handle turn, how are
we doing here so far?
12:56 - Let's just try to run
this and see what happens.
12:58 - Boom, so as you can see,
this actually gets reached.
13:02 - This input here and then
I can just put it in a one
13:05 - and nothing happens
because we didn't tell any,
13:07 - we're not doing anything
with position here,
13:09 - but actually one went into
position here and then from there
13:13 - we can actually deal with the game logic.
13:19 - So now let's actually do
something with position.
13:29 - First of all, because
position is a string,
13:31 - we are probably going to want
it to actually be an integer
13:35 - so that we can index into our list
13:38 - with an integer instead of a string.
13:39 - So let's do that first.
13:40 - Position equals int position.
13:45 - And remember, position
is one through nine,
13:47 - but the elements in our
array is zero through eight.
13:51 - So actually, if we get position one,
13:54 - what we actually want to zero.
13:55 - So let's subtract one from here
13:58 - just so we get the correct index in here.
14:02 - So now position is correctly cast it
14:06 - and subtract the one from it
14:09 - so that we know where and the board to go.
14:13 - All right, so now that
we have our position.
14:15 - Let's just try to put
something in the board.
14:21 - So let's just say board
at position equals X.
14:29 - Okay, easy enough.
14:32 - And then, just throwing a
quick display board here.
14:38 - Let's hit run so we have an
empty board printing out,
14:40 - and then it says, choose a
position from one to nine.
14:43 - Let's put in one and boom, look.
14:46 - We chose position one which is here.
14:50 - We cast to an int and then
we went into the board
14:53 - and we stuck an X in that spot
14:57 - and then we displayed
the board again and look,
15:00 - that's what we have.
15:01 - And that's all from what?
15:03 - 20 not even 29, 30 lines of code,
15:07 - not even cause there's because
there's a lot of space.
15:10 - 30 lines of code and we
already have this whipped up
15:12 - where we have a board, we have a prompt,
15:14 - we input something and then
we actually edit the board
15:17 - and display it again.
15:18 - Pretty cool, right?
15:19 - So let's leave this here just like this
15:25 - but now I want to go back
up to play game up here
15:28 - and actually work out some of
the overarching game logic.
15:31 - So after we display the initial board,
15:34 - what we want to do is
we want to have a loop
15:36 - that can loop through turns over and over
15:39 - and over again until the game is over.
15:42 - So it'll keep going.
15:43 - Every single turn, X's turn,
O's, turn, X's, turn, O's turn
15:46 - over and over and over
again until somebody wins
15:49 - or there's a tie.
15:51 - So this is what it would look like.
15:54 - Usually I kind of have something in here
15:57 - and then by hack I just mean
15:59 - type something that I think might work
16:00 - and then I just try to see if it runs
16:04 - and then just go from there.
16:05 - So just follow along.
16:07 - So while game is still going okay,
16:15 - if the game is still going,
16:16 - then I want to handle a turn.
16:23 - And then after I handle a turn,
16:25 - actually if we're handling turn,
16:27 - we should probably have
some way to differentiate
16:30 - if it's X's turn O's turn.
16:31 - So let's go like this.
16:33 - Let's just give it a thing
called current player
16:37 - that'll just be an X or O, but later.
16:39 - We'll do that later.
16:40 - So after we handle a turn, X
or O goes and takes their turn,
16:44 - then we want to check if the game is over
16:46 - or check of the game if
somebody want or if they tied.
16:50 - So I call that check if game over.
16:59 - I don't know how I got there,
but yeah, check if game over.
17:03 - And then, after that,
17:06 - then assuming that the game is not over
17:08 - and I don't break out of this loop,
17:10 - then we will want to flip
from one player to the other.
17:14 - So I'm just gonna call this flip player
17:15 - from X to O or O to X.
17:18 - And then after that, then
we're gonna go back up
17:21 - and then we're gonna go again.
17:22 - We're gonna handle turn
with the other player
17:24 - because we flipped it and then we'll check
17:26 - of there's a just the game over
17:27 - and then flip the player
again and go back up
17:29 - and then take another player's turn
17:31 - and then check if the game's over
17:33 - and then flip and his so on and so forth
17:34 - until somebody wins or there's a tie.
17:38 - That's pretty much it.
17:40 - So let's make these functions real quick.
17:45 - We already have handle turn.
17:46 - Let me put it down here.
17:54 - So we need check if game over.
17:57 - Check if game over.
18:03 - Well that needs to be a function.
18:06 - And all this is gonna do
18:07 - is actually just call to other functions.
18:10 - Check if win and check if tie.
18:15 - See how that works.
18:17 - See how I'm breaking up
the code, the game logic.
18:21 - What are the criteria
for a game to be over
18:24 - is if somebody wins, if
somebody gets three in a row
18:27 - or if there's a tie, if
the entire board is full
18:29 - and nobody has one yet.
18:30 - So those are the two
criteria for the game ending.
18:34 - And so that's why I use that up here.
18:37 - I handle a turn and that's
because the board state changes.
18:39 - And then I see if there's a game over
18:44 - after they placed a piece.
18:46 - And then depending on
that, I will either stop,
18:48 - I'll break out of this loop somehow
18:50 - by maybe sitting this equal
to false instead of true
18:53 - and then, break out.
18:54 - But first we need to
check if the game is over.
18:57 - So we're gonna do that by
checking if there's a win
18:59 - and checking if there's a tie.
19:01 - Next let's code up this one.
19:05 - Check if win.
19:10 - This is also a function,
I keep forgetting that.
19:13 - Check if wins.
19:13 - So here I'm just gonna put a return thing
19:16 - just to keep it nice and clean for now,
19:19 - but pretty much we're
going to have check rows.
19:23 - Like I said earlier, check
columns and check diagonals.
19:29 - So we'll leave that there for now.
19:32 - I'll just put it return here
19:33 - so that it doesn't break when we hit run.
19:35 - I don't want any red things
over here popping up any errors
19:37 - because it's just kind of gross.
19:39 - It's inevitable but it's still gross.
19:45 - Also need to check if there's a tie.
19:47 - So define check if tie, just like that
19:52 - and then I'll just return as well.
19:55 - I'll populate these a little bit later
19:57 - but I just want to get the
overarching logic done first.
20:00 - So check off when and check if tie.
20:04 - So check if win, check if tie.
20:06 - Those are all right.
20:07 - So check if game over.
20:07 - So that's all taken care of.
20:09 - Check if game over.
20:11 - So I have, this is already made down here.
20:13 - Check if game over is already coded.
20:15 - Now we just need flip player.
20:16 - That's the one I was missing.
20:17 - So now we need one last
function called flip player.
20:22 - Just like this and this is
just going to flip the player
20:27 - from X to O so that we know
which piece to place down
20:32 - and stuff like that pretty much.
20:34 - In the display it is currently X's turn,
20:37 - it is currently O's turn.
20:38 - Please choose a position,
something like that.
20:41 - I think I might have most
of the functions I need.
20:46 - I just need these three functions,
20:48 - but I will do those later.
20:52 - Let me see.
21:00 - All right, let's actually just see
21:03 - if we're getting any errors.
21:03 - Run it.
21:04 - Yeah, there's an error, of course.
21:06 - Games still going is not defined.
21:09 - So usually errors will happen a lot
21:11 - if you're new to programming.
21:12 - They usually come back and read
21:13 - and they usually say trace back something.
21:15 - Oh my God, my life is over.
21:17 - My parents don't like me.
21:18 - My best friend just left me.
21:21 - Somebody else just left me.
21:25 - Look for the error it'll
usually tell you what's wrong.
21:29 - So it says, game's still
going is not defined.
21:32 - I think that's here.
21:34 - So this is a Boolean.
21:36 - I'm just going to make this
a global variable up here.
21:42 - Actually let's put a comment up here
21:43 - because I like having all
of my global variables
21:51 - just like that, nice and tidy there.
21:56 - Game board, boom and then
we are going to need,
22:00 - if game is still going.
22:04 - We'll call it game still going
22:09 - and we'll set it equal to true by default
22:11 - because we want that loop
to run by default initially.
22:14 - The game is going from the very beginning.
22:15 - This is only gonna be false
when there's a game over.
22:18 - So whenever we get a game over,
22:19 - we're gonna set this to
false and then automatically,
22:22 - because this is what this relies on,
22:26 - if this is true, it'll run until it's good
22:28 - but then if there's a game
over and we get a false
22:30 - and we set this equal to false.
22:32 - Then next time this goes,
it'll jump out of it
22:34 - because we know that there's a game over.
22:38 - While we're at it, why don't we just
22:40 - make a couple other ones.
22:41 - I think maybe, who won or tie?
22:47 - Let's just put winner equals none for now.
22:53 - I guess there's one no winner right now.
22:54 - And then maybe we could
change winner to X or O
22:56 - when there's a winner so
we know who the winner is
22:58 - or if there's a tie, then
winner we'll just say none
23:00 - because yeah, there's no winner.
23:03 - It makes sense.
23:04 - And maybe I'll also,
23:05 - I think one last thing we'll probably need
23:06 - is a whose turn is it?
23:10 - We'll just be a current player
23:15 - and let's just have X go first.
23:17 - Yeah like that.
23:18 - So let's try run this and
see if you get any errors.
23:20 - We get an error again.
23:22 - A handle turn takes zero
position but one was given
23:27 - handle turn I see.
23:29 - So we're trying to give
something to handle turn,
23:31 - but we're getting an error.
23:34 - Yeah because we're trying
to give something here
23:36 - when it doesn't take
anything in the function.
23:38 - So let's just say okay, current player.
23:40 - Now let's see if we run us.
23:41 - Hey, okay.
23:42 - So we got rid of their
big or red lines of doom.
23:46 - I just just get used to errors.
23:50 - They happen all the time.
23:51 - It's just a part of coding.
23:53 - I'll read them, definitely read them.
23:55 - They usually tell you what's wrong.
23:56 - They tell you what line number is wrong
23:57 - so you can actually just go
into the code to that line,
24:00 - figure out what is wrong,
24:01 - maybe you put a few
debugging statements in there
24:05 - and then just keep working out from there.
24:08 - All right, cool.
24:08 - So let's go back to play game.
24:11 - So we have the loop going
and then like I said earlier,
24:17 - if the game ever stops from here,
24:20 - if the game is over and
this loop jumps out,
24:22 - then we're gonna jump out of this loop.
24:24 - So let's actually put something here.
24:26 - So the game has ended right here.
24:30 - And then we can just say,
24:33 - remember that thing at the beginning,
24:33 - earlier, the global variables?
24:36 - We have a winner.
24:38 - Let's use that here.
24:40 - So let's say if winner
equals X or winner equals O,
24:52 - that means X or O won.
24:53 - We don't know who won yet.
24:55 - Then we'll just say,
24:56 - I guess we do know who won
24:57 - because the winner will
have who won, X or O.
25:01 - At least that's the idea.
25:01 - I'm gonna put the winner in that
25:03 - once we know if there's a winner.
25:04 - We'll just be like okay.
25:05 - If this person won, then winner equals X,
25:08 - or if X won, then winner equals X.
25:09 - If O won, then winner equals O
25:11 - and then we can just get
25:13 - that global winner variable from here.
25:14 - So we'll just say print winner.
25:18 - So that will be X or O plus space WN.
25:24 - So this'll be com X won or O won.
25:28 - That's an easy.
25:30 - Else if winner equals none,
25:36 - then this will be a tie.
25:40 - So let's just put that in like that, boom.
25:45 - Let's see if anything is broken.
25:46 - Everything's running good.
25:47 - Good practice is actually to unit test
25:49 - which means to keep running
your code over and over again
25:53 - and make sure there's no errors
25:55 - and then whenever you do get
an error, fix it immediately
25:58 - so that you're not swamped with bugs
26:00 - because sometimes you fix one bug
26:01 - and then it creates 10 others
26:03 - and then this just gets
really out of hand.
26:04 - But if you fix every bug
one by one as they come
26:08 - and then everything's
always working nicely,
26:10 - then you know exactly
what caused the error
26:12 - because you just made a
small change to the code.
26:14 - So try to do that.
26:14 - Always try to run it.
26:15 - If something's wrong, fix
it before you move on.
26:18 - All right, cool.
26:19 - So we have play game.
26:21 - I might not touch it for a little bit.
26:22 - I think this is almost fleshed out
26:24 - because we'll display the initial board
26:26 - and then we'll have the game
26:27 - going, going, going, going,
going and then when it ends,
26:29 - then we'll just print if there's a winner
26:31 - or if it was a tie.
26:31 - So that's kind of the
overarching idea of play game.
26:34 - So I actually think this
function is pretty much done.
26:36 - It might be a little, a few
little changes here or there
26:38 - but yeah, let's just put in some comments
26:40 - because good practice.
26:41 - I haven't been doing that.
26:42 - I'm not being a good example.
26:43 - I was never a good example.
26:47 - So my mom always tells me,
I have a little sister.
26:51 - Anyways, we're just gonna
flip to the other player
26:56 - just like that.
26:58 - Check if the game has ended.
27:02 - You don't really need do this
27:03 - because the names are so descriptive,
27:05 - but hey, I'm a little bit OCD, so why not?
27:07 - Handle a single turn
of an arbitrary player?
27:14 - Big words, big words.
27:15 - And while the game is still going.
27:23 - So this will just loop while
the game is still going
27:24 - and then once there's a
game over, it'll break out
27:27 - because this will be turned to false
27:28 - and then we'll jump out here
and print out the stuff.
27:30 - So, yeah.
27:32 - Play a game of Tic Tac Toe.
27:36 - Okay, cool.
27:39 - Why don't we just fill all these in.
27:41 - Display board, I'm so bad at this.
27:44 - I'm actually an English major.
27:51 - And then handle a single
turn of an arbitrary player.
27:58 - I also can't spell sometimes or type
28:00 - or do anything for that matter.
28:03 - So let's end that there.
28:07 - So yeah, we are going to move on now.
28:13 - Currently, our current
functionality is this.
28:16 - We have it running here
and then when we never,
28:19 - we put in a number of valid
number from one to nine,
28:22 - it will populate that spot in the board.
28:25 - So if I put two then it'll go on to three
28:27 - and we can keep doing this forever.
28:31 - As you notice, I can put
it in every single spot
28:34 - and I can also overwrite old spots.
28:36 - It'll just keep overriding it as X.
28:38 - But that doesn't really seem
like correct functionality.
28:40 - I mean nobody's winning, nobody's losing.
28:42 - Where's the O.
28:43 - So at least we have this
basic functionality happening,
28:47 - but now we need to actually clean it up
28:48 - so that the right player plays
28:51 - and then if somebody
wins or if there's a tie,
28:52 - then the game actually ends
28:54 - and then it notifies
us that the game ends.
28:55 - So, I think the place that I want to do,
28:58 - that I want to start, next
is actually check if win.
29:04 - I'm actually gonna change
this to check for winner.
29:07 - I just prefer that name.
29:08 - Yeah, check for winner, check
if tie, check for winner.
29:12 - So if I change this function name,
29:14 - I think I called it somewhere.
29:15 - So let's copy this and go back up.
29:19 - Check if game over.
29:22 - Okay, let's just command F.
29:24 - Check if win.
29:29 - There's only one match.
29:31 - Oh, it's right here.
29:31 - Yeah check if game over.
29:32 - So let's change that.
29:33 - So check for winner and check if tie.
29:35 - I prefer that.
29:37 - You can leave it the
other way if you want.
29:39 - It doesn't really matter.
29:40 - This is just personal preference.
29:41 - They will both do but anyways,
29:43 - so this is, the next one
that we need to code up.
29:47 - So check for winner.
29:49 - If we get three X's in a row,
29:51 - then we want the game to
say, hey X won, somebody won
29:57 - if we get three X's in a row.
30:00 - So how do we check if we
have three X's in a row?
30:05 - Well, we can either have
three X's in a row in a row,
30:08 - we can have them in a
column, going straight down
30:11 - or we can have the diagonals.
30:14 - So, let's just break it up
into those three pieces.
30:17 - So check for winner is going to start by.
30:25 - Well actually, do we even
have these functions made yet?
30:27 - No, we don't.
30:28 - So actually what we need to do
30:29 - is actually make a function for
each of these comments here.
30:33 - So check for let's find, define.
30:36 - Check rows, that'll do.
30:41 - Check rows, return.
30:44 - Define check, columns.
30:50 - Return and the final check diagonals.
30:59 - I like that word.
31:03 - So now we have three functions
31:05 - that will check each of these
31:07 - and all I need these functions to do
31:09 - is if is check the rows in the board
31:15 - or the columns are the diagonals
31:17 - and then whatever, if
there's three in a row
31:22 - in any of those rows, then
it basically returns true.
31:28 - It flags the wild loop
that the game is over
31:30 - and then it returns either X are O.
31:33 - So I want it to return
X or O if somebody won
31:36 - and then two flag this up here,
31:39 - game's still going to fall
so that the game ends.
31:42 - So return to X or an O and
flag this so that it jumps out.
31:45 - And then, if we return X or O,
31:47 - then we can actually know
that winner is X or O here.
31:55 - So let's do that.
31:58 - We have these, maybe
I'll code these in a bit.
32:00 - Let's, start up here.
32:03 - So let's just fill this out, check rows.
32:07 - We're going to say row
winner equals check rows.
32:14 - If we have that column winner
32:21 - equals check columns and I misspelled that
32:31 - and diagonal winner
equals check diagonals.
32:42 - Winder, that is not right.
32:46 - Okay, so now we have those going.
32:50 - Let's see if you have any errors.
32:51 - No errors, cool.
32:54 - What next?
32:55 - So I'm assuming that when I call these,
32:58 - then if there's a winner in
a row or a winner and a co.
33:02 - I said there was no typos.
33:04 - There's one right there.
33:05 - Okay so if there's a winner in a row
33:07 - or winner in a column
or winner in a diagonal,
33:09 - then these will either be
returned, true or false.
33:13 - As a Boolean, it'll say
there was a winner there.
33:16 - So maybe we can say if
row winner then okay.
33:24 - Then there was a win.
33:27 - I don't know quite yet.
33:29 - If there was a column winner,
then yeah, there was a win.
33:35 - And then else if diagonal winner,
33:40 - once again there was a win.
33:43 - Else there was no win.
33:45 - So, if there was no win,
33:48 - I think we had a variable.
33:51 - Didn't we set a variable up here?
33:52 - Yeah, winner.
33:54 - So winner equals none.
33:55 - I guess we could utilize this now.
33:57 - Winner equals none.
33:58 - We're gonna have there was no win.
34:03 - Let's just try winner equals none.
34:07 - And then if there was a win,
34:08 - then winner equals diagonal winner.
34:18 - There was no win.
34:20 - Winner equals column winner
34:24 - and then for rows, winner
equals real winner.
34:29 - I think that'll work for now.
34:30 - There might be some bugs, but if there is,
34:32 - we'll go back to them
and solve them together.
34:36 - All right, cool.
34:36 - One thing I forgot to mention.
34:38 - If you are trying to access
any global variables up here,
34:43 - that is outside of a function
34:44 - and you're trying to
access it within a function
34:47 - or when the axis you
can read it just fine,
34:49 - but if you're trying to write to it,
34:50 - if you're trying to write to a variable
34:52 - outside the function, you
actually need to declare
34:54 - that variable within
the function as global.
34:57 - So this winner is outside the function.
34:59 - It's considered a global
variable as I noted here.
35:03 - So if we're going to try to set winner,
35:06 - that means we're trying
to set a global variable.
35:08 - So therefore we actually
need to write this here.
35:11 - Let me just show you, it
might be a little bit,
35:13 - make me a little bit more sense.
35:15 - So what I'm doing here is
I'm saying global winners.
35:17 - So this winner will actually match up
35:20 - to the winner outside here.
35:22 - And then, whenever we
set winner down here,
35:26 - when we set these are the
winner to a different value,
35:28 - this will allow us to set the global one.
35:31 - So we actually need this
35:32 - if we're gonna access global variables.
35:35 - So set up global variables just like that.
35:40 - That should be good for now.
35:41 - Now let's move on to
check rows, check columns,
35:48 - check diagonals and check if tie in these,
35:50 - 'cause I think we need
to fill these out still.
35:52 - So check rows.
35:53 - What are we gonna do if you want to check
35:55 - the rows of the game board?
35:57 - Well, very simple.
35:58 - We could probably just pick
out each element of the row
36:01 - and then see if they're
all equal to each other.
36:03 - And then if they are
then return X the winner,
36:07 - X or O, whoever the
winner is or return none
36:10 - if there's no three in a row.
36:13 - So let's just try that.
36:14 - Let's see what we can do.
36:16 - Row one, okay.
36:18 - So the board is a list, right?
36:19 - To check for the first row here,
36:22 - we would have to check element zero,
36:25 - element one and element two.
36:26 - So let's just say board at zero.
36:29 - We want to see if board at
zero equals board at one,
36:33 - which also equals board at two.
36:36 - So all this is saying is
we are checking row one.
36:39 - Row one is these three up here.
36:40 - So we're just seeing if
board one, board two.
36:43 - Well board at zero, board
at one and board at two
36:48 - are all equal.
36:50 - So if at the same value
36:52 - then this will come out to be true.
36:54 - And then we know that row one
is actually a winning row.
36:58 - Maybe we should add one more thing,
37:01 - because I just noticed that if these three
37:03 - are all equal to each other
but they're actually dashes,
37:06 - then it'll think this is a win
37:07 - when this is just three
empty cells in a row.
37:10 - So let's say these three spots in the row
37:15 - all need to be equal to each other
37:16 - and they also should
not be equal to a dash.
37:20 - So if all three are equal and
it is not equal to a dash,
37:25 - then this is a winning row.
37:26 - I hope that makes sense.
37:27 - Now we're just going
to copy and paste this
37:29 - into row two and row three
37:35 - and we're just going to
mirror the same exact logic.
37:38 - So zero one, two, three,
four, five is the second row
37:42 - and six, seven, eight is the third row.
37:47 - So now this logic here is if the first row
37:50 - has a winning configuration,
then this becomes true.
37:54 - Likewise for row two and three,
37:55 - the same kind of deal happens.
37:57 - Now, if there is,
38:00 - if either of these are true,
then that means somebody won
38:03 - and if somebody won then we
actually need to end the game.
38:05 - So actually I remember we
had this variable up here
38:08 - called game's still going equals true.
38:09 - It is also a global variable.
38:11 - So we're actually going to
need to set this to false
38:14 - if somebody wins.
38:14 - So let's set up that
global variable down there.
38:18 - Let's do that first.
38:19 - Global game's still going and then,
38:25 - let's put in some comments here.
38:26 - Set up global variables.
38:31 - Here we can see if
check if any of the rows
38:35 - have all the same value and is not empty.
38:40 - That's kind of a long comment
38:41 - but at least it's descriptive.
38:43 - And then after we check that,
38:47 - then we can actually say
if row one or row two
38:54 - or row three, meaning if there's
a win in any of those rows,
38:59 - then we are going to a set
game still going to false,
39:04 - which will stop the game,
because we know somebody won.
39:06 - So now I felt the comment.
39:08 - If any row does have a match
flag that there is a win.
39:14 - So that's what's happening there.
39:16 - So now we know that there has been a win
39:18 - and we actually stopped the game,
39:20 - but now we also need to know who won
39:22 - so we can return and be
like okay, X won or O one.
39:25 - So let's just, we don't
actually know which row one,
39:28 - so we're gonna have to actually
39:30 - check each one individually.
39:31 - So if row won, then we know that row one
39:36 - has a winning streak,
a winning configuration
39:39 - but we don't know what value is in there.
39:41 - So it's as simple as
checking board at zero
39:44 - because row one board at
zero is within row one.
39:47 - So whatever's there, if it's an X or an O,
39:49 - then we know that that's the
value that we want to get.
39:51 - So we can just return board at zero.
39:53 - Same thing for row two.
39:57 - We can just return board at three
40:01 - and then same for row three.
40:04 - If that's the winning row
then we want to return
40:06 - whatever player is at row six.
40:09 - I got the zero three six from here.
40:10 - Zero, three, six.
40:11 - I also could to use one for
seven or two, five, eight.
40:14 - I just need one of them.
40:15 - I just need to know if
it's X or O that won
40:17 - and you can just leave
this last return here.
40:19 - That's just like a clean up
just in case something happens.
40:22 - let's run this and see
if we get any errors.
40:24 - We do not, that is good.
40:26 - So hopefully that made sense.
40:27 - Let me just pop a quick comment in here.
40:30 - Return the winner, X or O.
40:35 - Yeah, hopefully that made sense
40:38 - because I believe check
columns and check diagonals
40:41 - are gonna be extremely similar.
40:43 - Let's just actually, let's
just copy and paste it
40:47 - straight into here and
then just edit it as we go.
40:49 - You can follow me.
40:50 - This is very common to do.
40:50 - If you have code that's very similar,
40:52 - you can just copy and paste it
40:54 - and edit the numbers a little bit.
40:55 - So check columns, obviously
we're gonna have to check
40:58 - change all these from rows to column.
41:01 - Check columns.
41:03 - Yeah, we're also getting
the game's still going
41:05 - because if there's a win,
41:06 - we need to set that equal to false,
41:07 - which is the same down here.
41:08 - Actually I'm just gonna copy column here,
41:11 - copy, paste, paste, paste.
41:16 - If any column does have
a match, then yeah.
41:21 - If column one or column
two or column three,
41:26 - actually return statement here.
41:28 - So now this looks pretty
much exactly the same
41:30 - as the check rows.
41:32 - Only difference is these
numbers are not correct.
41:33 - This is still checking if the first row
41:35 - is a winning configuration.
41:36 - Wat we actually need to check
is if foe the first column.
41:39 - So actually it's not
gonna be zero one two.
41:42 - It's actually going to be I believe zero.
41:45 - Okay, zero one, two,
three and four five six.
41:49 - So zero, three, six is
what this should be.
41:51 - Zero, three, six is the
first column right here.
41:54 - So we're checking out
the first column is good.
41:56 - The second column should be
one, four, seven, I believe.
41:59 - One, four, seven and then the last one
42:02 - should be two, five, eight.
42:04 - I just did this by counting here.
42:06 - So if this is a zero and this is one, two,
42:09 - then you can just kind of figure out
42:10 - what numbers should be in each column.
42:12 - You can just check it that way.
42:13 - So, this is actually done now
unless I missed something,
42:16 - I don't think I did.
42:18 - Oh, I did here actually.
42:19 - So here we need to all return
42:22 - the first element of the
columns, not the rows
42:25 - in case either of these is
a winning configuration.
42:29 - So check columns, very
similar to check rows.
42:31 - Check diagonals is also
gonna be very similar.
42:33 - Let me just copy this into here.
42:36 - Copy and paste.
42:41 - Again, we need game's still
going in case there is a win
42:44 - and then we need to set it equal to false.
42:46 - Hopefully, that's making
sense to you guys.
42:48 - There's only two diagonals,
so we actually only need two.
42:51 - We can get rid of this third one.
42:52 - We can get rid of this third
one here just like that
42:57 - but now we need to change
all the columns to diagonals.
43:00 - Diagonals, paste that in there.
43:05 - If diagonal one or diagonal two.
43:08 - Diagonal one or diagonal two.
43:10 - So now that all the variable
names and comments are changed,
43:15 - now we just need to change the
numbers to the correct ones.
43:17 - So let's think about it.
43:18 - What is the first diagonal?
43:19 - The positions in the board?
43:21 - So zero is correct because
we need this top left one.
43:24 - And we also need the middle one.
43:26 - So what is the middle one?
43:27 - Zero, one, two, three, four.
43:29 - So this should be four
and then the last one
43:31 - is the bottom right, which would be eight,
43:33 - the very last position.
43:36 - Same here, let's start
with the bottom left.
43:39 - So zero one, two, three, four, five, six.
43:43 - Should be six and then the middle one,
43:45 - zero, one, two, three, four.
43:46 - That's already correct
and then the top right
43:49 - would be zero, one, two.
43:50 - So this shouldn't be two.
43:52 - So now that we have
checking if the diagonals
43:55 - equal to each other and
checking if the other diagonal
43:58 - is equal to each other.
43:59 - Then this function should also be done,
44:03 - except for down here again.
44:04 - Again, we need to check
what value which player won.
44:06 - So this would actually be zero and six.
44:07 - You can just mirror these first here
44:09 - because you already know that
these are in the diagonal
44:12 - and these are in the diagonal.
44:13 - So you can just choose anyone you want
44:14 - and throw them here to
get the correct value.
44:16 - All right, so now let's
try running it again
44:19 - and see what happens.
44:21 - Let's just try to...
44:25 - Number two, let's see if we win.
44:27 - Oh, we get an error.
44:29 - String objects is not callable.
44:33 - Winner equals row winner.
44:35 - Type of string object is not callable.
44:37 - Line 76.
44:40 - Let's go to line 76.
44:41 - What is it complaining about?
44:42 - Here, winner equals row winner
44:47 - So I found a mistake here
and the mistake is actually,
44:50 - I'm trying, I have this
winner variable here.
44:53 - I'm trying to set it equal to row winner,
44:57 - but row winner is actually
a variable, not a function.
44:59 - So these parentheses should not be here.
45:02 - Simple mistake, now let's try to run.
45:05 - All right, cool.
45:06 - So only X is playing right now,
45:09 - but if we get three in
a row, it should check
45:12 - in the check rows or check for winner
45:17 - as you go to check for winner
45:19 - and then it'll run check rows
45:20 - and then it'll see if any of
these rows is all the same.
45:24 - And then if it is, it'll end the loop
45:26 - and then it'll return X and
then up here, it'll print.
45:30 - If when it equals to X, what
you just set then X one.
45:34 - So we were about to do that now.
45:36 - Position three, we're about to put an X.
45:38 - Let's put that in here
now and see what happens.
45:41 - And there we go, it says X one
45:43 - because it checks that the first
row had all the same value,
45:48 - that wasn't dashes and
then it returned this,
45:53 - the first one we chose.
45:54 - The first X and then
return it and ended loop
45:58 - and then printed this out and say X one.
46:00 - So that's kind of what's going on.
46:03 - Now we fixed that.
46:06 - So that's pretty cool.
46:07 - So we have the winning,
checking for winning is set.
46:09 - If they were all O's it would also work
46:11 - because it's just
checking if they're equal,
46:13 - not checking if the X's and O's won
46:15 - and you put an O here, it would say,
46:17 - well then it would put an O
here and it would say, O won.
46:20 - So let's also get that worked out.
46:24 - The X and O part.
46:28 - So where are we sitting?
46:30 - Here it is.
46:31 - So going back to handle, turn up here.
46:34 - We want to handle a single
term for either X or O.
46:37 - So that's why we actually
sent in player here
46:41 - because then we know if it's
X or O instead of just X.
46:43 - So actually whatever
the current player is,
46:45 - that's what we want to put on the board.
46:46 - If you don't just want to
put an X automatically,
46:48 - we actually want to
put player on the board
46:51 - because this will be X or O
depending on whose turn it is.
46:54 - And we'll put that at
the position they choose.
46:56 - So that's the first change.
46:57 - Let's see if that broke anything.
46:58 - Well there's no errors, that's good.
47:02 - Let's try winning.
47:05 - Winning still works, awesome.
47:07 - But now we also need
to oh yeah flip player,
47:11 - I forgot about this.
47:13 - I put this little function
in here so that after X goes,
47:17 - then it'll flip and then
this handle term player
47:19 - will be called with the opposite player.
47:21 - So if it was X, then O will be next
47:23 - and if it was O then X will be next.
47:25 - So, I know player will get an input.
47:28 - We do that.
47:30 - Where did I call flip player from up here
47:32 - and game's still going.
47:35 - Current player is X, so I guess, yeah,
47:40 - when we call handle turn here,
47:41 - current player is what
we send to the turns.
47:44 - So all we need to do is in foot player
47:46 - is change current player.
47:48 - So let's go down to flip player rates here
47:52 - and pretty much all we need to do
47:54 - is if current player equals X,
48:00 - then current player equals O.
48:04 - There we go.
48:06 - Just be very careful here.
48:07 - This is checking if they're equal
48:10 - and then if they're equal,
48:11 - then you actually want to
set current player to O.
48:13 - So this has a double equals
and this has a single equals.
48:17 - Very common mistake to make.
48:19 - And then else if current player equals O,
48:25 - then we want current player to become X.
48:31 - And since this is a global variable,
48:33 - the only way we can
write to it or change it
48:35 - is to put this here.
48:38 - Current player.
48:39 - So let's just put some comments in here.
48:41 - Global variables we need.
48:44 - If the current player was X or then yeah.
48:49 - Then change it to O and if
the current player was O,
48:56 - then change it to X and yeah,
see if that broke anything.
49:01 - It did.
49:04 - Sometimes repl it lags a little bit
49:06 - and it gets a little bit screwed up.
49:08 - So sometimes actually
just refresh the page.
49:10 - Let me copy all of this just in case.
49:12 - I don't want to lose all this work.
49:14 - So I'll refresh the page.
49:17 - We get brought back here.
49:19 - I'll move this over and then
49:24 - go back down to where we just were.
49:26 - Flip player.
49:27 - Let's hit run and there we go.
49:29 - It's running good again.
49:31 - So now every time X goes, then
we'll flip the player to O
49:39 - and then O will go and
then I'll flip back to X
49:43 - and so on and so forth.
49:44 - And now we actually have two
players playing the game.
49:46 - Cool, right?
49:47 - And boom, X won.
49:50 - X on this diagonal here.
49:54 - So actually we have a working game.
49:58 - So now the only thing we
haven't done yet is if they tie.
50:02 - If the board fills up, the
game also needs to end.
50:05 - So oops, got an error there.
50:08 - That's another thing
we're gonna have to handle
50:09 - is if they put an improper input,
50:11 - we need to handle that
to make it more robust
50:12 - so that the game just doesn't break
50:14 - and it prints out all
this error messaging here.
50:17 - So let's, first just try to tie.
50:24 - Nine and four.
50:27 - Yeah, so as you can see,
we have a draw here, a tie,
50:31 - but nothing happens.
50:32 - It just keeps going.
50:33 - We could just keep
putting in more variables
50:37 - and then it'll just keep overriding
50:38 - which is improper, incorrect execution.
50:43 - So we need to actually change that.
50:46 - We can check for tie.
50:49 - The first thing that comes to mind for me
50:51 - is all we can do is just
check if there's a dash
50:56 - in the list, in the board.
50:58 - If there is a dash,
then there's no tie yet.
51:00 - But if there's no dash,
51:01 - that means every spot has been filled up
51:03 - and a tie needs to happen.
51:05 - Very, very simple.
51:05 - Since board is just a list,
51:07 - we can literally just go like this.
51:09 - If dash is not in board,
then we can just say
51:14 - game's still going cool to false.
51:17 - This is the thing that
ends the game, remember?
51:20 - Game's still going is false
51:21 - and because it's a global variable, again,
51:22 - we need to declare it as a global variable
51:26 - so we can write to it
51:27 - 'cause we write to it,
we read it false here.
51:29 - That is not on board getting the game ends
51:32 - and then also, you can just return.
51:34 - Let's try that for now.
51:36 - Let's see what happens.
51:37 - So putting one, two, three,
51:39 - five, six, seven, eight, nine, four.
51:43 - And there we go, it worked.
51:45 - So if the whole board fills
up and nobody has one yet,
51:51 - then it'll just say tie
and then the game is over.
51:54 - So that's all we need.
51:56 - That is done, very simple
checking for a tie.
51:59 - We're actually getting pretty
close to being done now.
52:01 - I think the only thing
that we need to do next
52:03 - is to make it so that if
we put in improper input,
52:07 - then it doesn't break it.
52:10 - If there's an is improper input,
52:12 - then we just want the
game to ask the user again
52:15 - or just pass it and just be like, okay
52:18 - just choose a position again.
52:19 - Choose another position
or something like that.
52:21 - So let's actually go up
to handle turn, I believe.
52:25 - That's where we actually get the input.
52:28 - Yeah, that's right.
52:29 - So handle turn is where
we get the input in
52:32 - and now we're actually
going to need to check
52:35 - to make sure that input is correct.
52:38 - So first of all, actually we should notify
52:41 - which player's turn it is.
52:43 - So let's just put a simple print in here.
52:47 - Since we know the player,
the player's either X or Y,
52:50 - we can actually putting the
string here and go like that.
52:55 - So it will, this will
say O's turn or X's turn
52:58 - and then then it'll ask for input
53:00 - from the user just like that.
53:01 - But then we also want to make sure
53:03 - that the input is valid before we cast it
53:07 - because, we can put in any
string the input function
53:10 - from Python can take in any string.
53:13 - But then if we try to put that in here
53:15 - and cast it to an int,
53:16 - like if they put something
53:16 - that's not able to be cast to an int,
53:18 - then we're gonna get an error.
53:19 - So let's try that first.
53:22 - If position not in and
this is a little trick
53:27 - that I found on Google.
53:30 - We could use regular expressions,
53:31 - if any of you guys know what that is,
53:33 - but that's a little bit advanced.
53:35 - Like it's a whole another thing.
53:36 - So this is actually a quick solution.
53:38 - Basically we just want to make sure
53:40 - that the input the user
gives is in this list
53:45 - because we only want a
specifically nine different inputs.
53:48 - Then we're only gonna
allow these nine inputs.
53:53 - Obviously this wouldn't
work if you wanted to allow
53:56 - a million different kinds of inputs,
53:57 - we can't type it all out.
53:58 - But since we only have nine,
53:59 - we can just make it nice
and clean and simple.
54:01 - So we can say position,
54:03 - which is the thing that we get
from input from the keyboard,
54:05 - it needs to be a string that matches one,
54:08 - matches two matches three
or so on and so forth,
54:10 - all the way up to nine.
54:11 - If it doesn't, then we need to ask again.
54:16 - So if it doesn't, then we need to say,
54:18 - hey, position equals and actually
54:21 - let's just copy and paste this.
54:24 - Input invalid input.
54:25 - Choose a position from one to nine.
54:28 - So let's try to run this now.
54:31 - Oops, what is wrong?
54:32 - Oh, the is statement.
54:33 - I forgot to put a semi colon at the end
54:35 - or I mean our regular colon at the end.
54:36 - Syntax errors.
54:39 - That just means that Python,
there's something wrong.
54:41 - if I forgot the F in if, that
I would get a syntax error.
54:44 - Like what is that?
54:47 - So just keep that in mind.
54:48 - We're gonna run it now, no more error.
54:50 - Actually now we added
this it says X's turn.
54:52 - It lets us know who's turn it is
54:54 - which is a very handy.
54:57 - So choose a position from one to nine.
54:59 - One and then we can go
55:01 - but then let's say we put something
55:02 - that's not in one to nine.
55:03 - Let's put z, let's put a 35.
55:06 - Hit enter, it says invalid input.
55:08 - Choose a position from one to nine.
55:10 - Yeah, so it's good that it caught it
55:11 - and then re ask again.
55:13 - Let's try again.
55:13 - Let's put in 55 this time
55:15 - and then we get an error.
55:18 - So the reason this is happening is because
55:20 - let's say they put an invalid input
55:22 - and they say it's invalid
and then this catches it
55:25 - and it says the input
55:27 - is not in the correct
range of valid inputs.
55:31 - So it asks again and it
says, okay, invalid input.
55:33 - Please choose a position from one to nine
55:35 - and then it tries it again
55:36 - and then it gets down
here and then it's invalid
55:38 - and it tries to do it anyways.
55:40 - Which means it only checks if you put
55:42 - an invalid input one time.
55:44 - So actually what we need to do
55:45 - is actually put this in a while loop
55:47 - so that it's constantly
asking over and over again
55:50 - for valid input until it is valid.
55:52 - So this is a very common
thing you do in programming.
55:54 - Instead of using an if statement,
55:55 - you actually use a while loop.
55:57 - So it'll be like while
position is not in here,
56:00 - just keep asking over
and over and over again.
56:04 - And actually we don't really
need an invalid input.
56:05 - We can just ask again.
56:07 - So it'll say, the first
it will initially say,
56:11 - okay, X's turn, choose a
position from one to nine
56:14 - and then it will, get the
position and then it'll say,
56:17 - if position isn't in here,
ask for position again.
56:21 - Again, if it isn't in here,
ask for position again.
56:24 - And then again, if position
isn't in this list over here,
56:29 - if it is in here, then ask
for position input again.
56:32 - Over and over again until
position is in this range
56:35 - and then it will continue down here.
56:36 - And then since we are
only allowing these digits
56:38 - from one to nine, this
casting to an int here,
56:41 - if position is in this
range from one to nine
56:44 - we put it in this in here,
and then we cast it to an int,
56:47 - then it won't throw this ugly error here.
56:49 - Let's try this again.
56:52 - Please choose position from one to nine.
56:54 - We put it into one, that works just fine.
56:56 - Let's put in a 20, error.
56:59 - It asks again.
57:00 - 20, 20 letters, random, nothing at all.
57:05 - Random stuff, anything
we put that doesn't exist
57:10 - in this list, it will
actually just ignore it
57:13 - and then just keep
asking for your position
57:14 - over and over over again
57:15 - until we give it something that works.
57:18 - And as you can see, the O
one and right in the middle.
57:21 - So that's working nicely, cool.
57:22 - One of the things that we
forgot to implement in this
57:25 - though is what if we put something
57:27 - in a spot where there's already a piece.
57:30 - That's an issue.
57:31 - So let's say we put X
in one and O at five.
57:34 - Now, it says it's X's turn
57:37 - and it says choose a
position from one to nine.
57:39 - So let's try to overwrite this
O by putting a five there.
57:42 - I hit enter and as you can see,
57:44 - the O was actually overwritten.
57:46 - That's a problem because that violates
57:48 - the rules of Tic Tac Toe.
57:49 - So what we need to do is actually
put in another check here
57:52 - to see if the position we
chose is valid on the board.
57:57 - We could check that here
after we pick the position
58:00 - and we've cast it and
subtracted one from it
58:02 - to get the right index and the list.
58:04 - We can just check and be like,
58:06 - if board at position equals
empty or doesn't equal empty,
58:14 - then print you can't go there.
58:20 - Go again.
58:21 - All right, let's try this.
58:24 - Colon again, there we go.
58:26 - One, five and then let's
try to override it again
58:32 - and see what it says.
58:34 - It says you can't go there, go again.
58:36 - So cool.
58:38 - So it actually, this popped up.
58:40 - So it noticed that it was
trying to override it,
58:42 - but as you can see it's still overrided.
58:45 - I think that's because we
didn't actually implement
58:49 - or ask for the new new input again.
58:51 - It continued to override it.
58:53 - I think it just went on here.
58:55 - It went on to setting the
board position to player.
58:59 - Anyways, so actually what we
need here is another wire loop.
59:02 - This part gets a little bit tricky
59:04 - but just try to follow along.
59:05 - I'll explain it the very end clearly
59:07 - so that it makes sense.
59:10 - So actually what we're going to do
59:11 - is we're going to add a nother wild loop
59:14 - around this wild loop and just call it
59:16 - and just run it on a Boolean, called valid
59:20 - or while not valid.
59:22 - If the input is not valid,
59:23 - it's just gonna keep
asking over and over again
59:25 - and we of course need to
create valid originally
59:28 - and we'll just start it as false
59:29 - 'cause we'll assume it's not valid.
59:32 - So while not valid, then
we are going to keep asking
59:37 - for input in this range, get
it and then check the position
59:42 - and then if it doesn't equal,
59:45 - well actually would it be
easier if this makes more sense.
59:49 - Let's do it this way.
59:50 - If we're positioned does
equal an empty spot,
59:54 - then that means valid equals true.
59:58 - We can set value equal to true
59:59 - to finally break out of this other loop
60:01 - and then else then we can print this.
60:05 - So now let's try to run it.
60:07 - This should work now.
60:08 - So let's try to put one and
then five and then five again.
60:12 - And this says, you can't go there.
60:14 - Go again.
60:15 - Let me try to put five.
60:16 - You can't go there, go again.
60:17 - Five, you can't go there, go again.
60:18 - Over and over again until I
choose something that is valid
60:22 - like six and then you can see
60:24 - that it puts the value in position six
60:26 - and leave this one alone.
60:28 - All right, so this is a little bit tricky.
60:29 - Let me explain what's happening.
60:31 - So, we have this wild loop
60:33 - that is running on this
Boolean called valid.
60:38 - And then, once we enter this,
60:40 - then we'll make sure that
the position inputted
60:42 - is within this range and then after that,
60:45 - then we'll change that
to the board position
60:47 - and then we'll check again,
60:48 - is this board position available?
60:51 - And then if it is available,
then we set this equal to true
60:55 - so that we can jump out
of here and go onto here
60:57 - to actually placing
the piece on the board.
61:01 - But if it isn't, then it will say
61:02 - you can't go there and go again.
61:03 - This will stay vulnerable, stay false,
61:06 - it'll come back up here and
then it'll run this again.
61:09 - It'll ask for more input
over and over again
61:11 - and then once it gets a valid input,
61:12 - it'll check to see if
the board is available.
61:14 - And then again, if it's a
valid, then it'll go on,
61:17 - but if it's not, then it'll just say
61:18 - you can't go again, it'll loop back up
61:20 - and then continue over
and over and over again.
61:22 - So a little bit tricky.
61:23 - Sometimes it's input stuff kind of sucks.
61:27 - But if you're using a
lot of other frameworks
61:29 - when you are actually
building bigger apps,
61:31 - a lot of this input stuff is
taken care of for you already.
61:34 - It's a not too often that you have
61:36 - to actually do it yourself like this.
61:38 - But I mean, it's good exercise
61:40 - to understand the logic
that's going around.
61:43 - I think that's actually it.
61:45 - I mean I haven't put comments everywhere,
61:47 - but I think we have a fully
functioning Tic Tac Toe app.
61:50 - Pretty cool.
61:51 - So, let's just try to row it one last time
61:55 - and go through this game and
then go through all the cases
61:59 - and see if everything's working correctly.
62:00 - So if we put it a valid
input in, then yeah,
62:03 - it puts it in the right spot.
62:05 - Put another valve in and put in
62:06 - and puts it in the right spot.
62:07 - If we try to overwrite by
putting it in position two
62:11 - it says you can't go there.
62:13 - Okay, let's put it in
position three instead.
62:14 - Okay, now it's O's turn again.
62:17 - Let's put it in position five.
62:21 - And then X's turn let's
put it in position six
62:24 - and then change position from one to nine.
62:26 - Let's put it here so it's one, two, three,
62:28 - four, five, six, seven, eight.
62:29 - Position eight, so we can
put O and an O should win
62:33 - and as you can see, O won,
62:36 - Very cool.
62:37 - Now let's run it again.
62:40 - If O wins, then X can also win
62:42 - but let's try to put in
some, let's try to tie.
62:45 - One, two, three.
62:47 - I memorize this little
a sequence here quickly.
62:52 - So this looks like a tie and game.
62:55 - If we put this in here
then yeah, I'll print tie.
62:58 - So it looks our Tic Tac Toe
game is working as expected.
63:01 - Everything is working nicely.
63:04 - It is pretty robust because it only allows
63:05 - for certain inputs.
63:07 - It doesn't allow for
overwriting your certain pieces
63:09 - and it out prints everything.
63:11 - Ii lets the players know whose turn it is,
63:14 - it lets them know what
the input and everything.
63:16 - So this is a very nice
small self contained
63:19 - and robust little application
and you guys followed along
63:22 - and you coded it yourself, so good job.
63:24 - I would actually advise
you to look at the code.
63:28 - I'm going to upload the
code with full comments,
63:30 - probably somewhere maybe in
the description of this video
63:35 - or something and then you can click on it
63:36 - and really read it.
63:37 - I'll try to explain everything
as best I can in the comments
63:39 - so that you can really trace
the entire thing yourself
63:42 - and then things will just be clear.
63:45 - You could also maybe perhaps
try do little exercises
63:49 - like change the code
63:50 - See if you can change it instead of having
63:52 - X's and O's as the players.
63:53 - Maybe changes so that it's A and B
63:55 - or something cool like
that little challenges.
63:58 - But other than that, good job guys.
64:01 - You created your first
Tic Tac Toe app with me
64:03 - and I hope you enjoyed it.
64:05 - I hope you learned a lot.
64:06 - I hope you guys liked me.
64:07 - I'm a new person on
this channel right now.
64:09 - Qazi kind of allowed me in here
64:13 - after I begged and begged
and begged and begged.
64:16 - But yeah, I'm here now.
64:17 - So expect to hear more from me.
64:20 - Thank you all for listening
64:21 - and I'll get better at this as I go.
64:24 - So if there's anything
that'll offer anything,
64:27 - just give me a chance.
64:28 - I'm gonna keep working at this real hard
64:30 - to give all you guys
as much value as I can.
64:33 - A lot of free value, any
kind of value I can offer
64:36 - and programming and what not.
64:38 - But yeah, again, I am Aaron
from Clever Programmer
64:41 - and thank you all for watching.
64:44 - Good bye.
64:46 - (hip hop music)

Cleaned transcript:

Hey you. In this video we have put together an amazing app for you with Python, it's the Tic Tac Toe app and we're gonna go through the process of building it from complete scratch all the way to the finish. Something special that we got for you in this video is that we're going to gift you this app at the end. So all it will be is it's gonna be just a link and we're gonna send you that link and you'll be able to use this application on your own, and steal it and also have access to the entire code base just in case for some reason, if you're trying to build it with us, you cannot complete it or you run into any kind of errors. This way you will be error free. So with that said, and before we jump right into it, this video is made by Aaron Bernath, who is our software developer and a new addition to the Clever Programmer team. He's an amazing developer. He's new to the team in terms of making trainings and tutorials. So this is his first app, show him some love and our goal in the future is to get Aaron to make a lot of awesome coding tutorials for this channel. I hope you love it. Please leave a comment and tell him something encouraging. With that said, let's jump right into it. (jingle music) (beeps) [Aaron] Hey, what's up guys? This is Aaron from Clever Programmer and today we are going to be coding a Tic Tac Toe app in Python. So let's jump right into it. (hip hop beats) First, let's go to repl.it, just type that in the URL bar, follow along please so you can learn. Make an account if you haven't already. This is called Repl It. Once you are done with that and click on my repls, you'll be on this page. It'll probably be empty. You want to have this stuff here. Click on the red plus sign, click on Python, which will automatically be Python three and Boom, you will be in an empty repl here. So all this is, is just a nice little environment where you can code on this website. You don't have to worry about any setup or anything. It's just nice and clean and it doesn't break which is very nice because sometimes recording on your own computer, there's a lot of weird edge cases and it's just the. So on left here, we have a little file directory. We're only gonna have one file for this project, so you don't really have to worry about that. Over here we have our one and only file open main.py and over on the right side we have a little Python environment. So let's, check this out. Yoyoyoyoyoyoyo. Okay, yo see so it works. This is where all the game will be played at. This little command line here and let's jump right in. So Tic Tac Toe. Sometimes I attack small problems this just straight in. I just start coding, just kind of hacky, but it's kind of too for these little things. But if you are working on a big code base, you actually want to think about it first. So let's at least do that first. Just have like a little bit of a overarching game logic. So let's think about it. Well, we're gonna need a board. And then we're going to need to be able to display that board. We're also going to need to play a game. So start the game and then have it keep going, alternating turns from X to O to X to O. I'm assuming you guys don't have to play Tic Tac Toe. If you don't, please look it up. All right, welcome back. So we're gonna need a function to play game. We're also gonna need a function to check if there's a win. So check win. We're also gonna need to function for checking if it's a tie. We'd also maybe need a function to flip between players. So flip from player X to player O. Flip player and yeah. And within check win, then we're probably going to do something check rows to see if there's a win and then maybe check columns. To check the whole, all the columns and then also you're gonna have to check diagonals. So to check if there is a win we'll check all these things and then at the end if there's a three in a row in any of these, then we can say, yeah, somebody won and then just return to player and so on and so forth. Checking after the tie and maybe we could just be like, hey, if the entire board is full and then there's no winner, then yeah, then it's a tie. I think maybe something like that. Maybe even one more like play game. Maybe there could be something like handle a turn. I forgot to put a little comment sign here, but yeah, handled a turn like that. Maybe this is a nice general over overview kind of high level idea of the game. So we're gonna need a board. We're getting to a way to display that board, we're gonna need something to run in an overarching game. We're gonna be able to handle turns when somebody takes a turn like taking input, putting it on the board making sure that it's valid input and then after we handle a turn we have to check if there's a win. We can check the rows, columns and diagonals and then we can check if there's a tie as well and then after all that's done, then we can flip to the other player. And then go back and then just repeat the whole process. Something like that. I mean it might change as we go, but just have a general idea of what's going on when you want to code something. If I was actually coding a different game like rock, paper, scissors, maybe I would I'm not gonna type it all, but I'll just tell you guys. If I was trying to pull the rock paper scissors, I would need, okay rock, paper, scissors. I could have the words and then I would need some way to select rock, paper, scissors and then some way for the computer to randomly generate rock, paper, scissors. And then I'll need a way to compare them and then a way to see who wins and so on and so forth. So just thinking, breaking the problem down into its little pieces we did here and then actually start implementing it from there. I it will most likely change. It always changes for me. I mean as long as you have an overarching high level understanding, then you are at least equipped to start coding. So I might delete this but I'll probably just keep it here at the bottom. Why not? So let's just start. So nice and easy. What are we gonna need first? We'll first, we're going to need a board. Very simple. I am just gonna make it list. Let's just do that and I want each one to be, each position on the board to be an empty spot. If it's empty, I just want it to be a minus like that. And then let's just a copy this. Nine times four or five, six, seven, eight, nine. And voila. Our game board was coated in approximately 27 seconds. Awesome. It's just a simple list. I just spread it out like this, so it's easier to see. So now we have our empty game board for Tic Tac Toe. Awesome, right? Let's move on. Next, we are going to need a way to display that board. So, let's get that going because right now when we hit run, absolutely nothing happens. Let's do that first. So what would that look like? We just gonna need a function, define. I don't know, display board just like that and then maybe print board at zero. Yeah, let's do it like this. Print the board at zero plus board at one plus board at two and yeah, let's just do that three times but so position zero one, two, we're gonna need three, four, five there and then six, seven and eight. Boom. All right. Yeah, let's just see how this looks. Run, it didn't work because we didn't call the function of course. So display board just like that. Now let's run it and boom, we have an empty board. Pretty cool, right? All right, so the positioning would be one, two, three. Yeah, so now that we have our board, we can move on. From here, maybe let's try to start a game. So this is the first place to start. Let's just make it a function called play game. Game, just let that. Define, I suck at this you guys. Why am I teaching this? Anyways, so play game. Play game will probably be probably be the function that drives the entire game. So maybe the first thing that we would do is okay, the first thing is display the board because when we're playing a game, the first thing I want to do is display initial board. Just like that. Always put comments in your code guys. If it's really, really simple, you don't need to like actually here, maybe you wouldn't have to because this is so well named by me that you don't actually need a comment, but hey, might as well throw it in there. It makes it easier for other people to understand what the heck you're trying to do. They can't read your mind, okay. I've had some jobs, some internships where that was an issue. I'll stop there. Anyways so let's display the board but now, we are going to need to call play game to actually start the whole function chain. So, when Python's going through this, it will create this board. It'll see this as a function. It'll save all this code somewhere. It'll see this as a function. It will save this code somewhere and then it will see this and they'll say, oh, I want to play game. So it calls this function here and then it'll actually call this, which calls this, which prints all this, which reads from this, which makes it look like this. If you're not watching. If you're looking away from your screen, that made absolutely zero sense. So make sure you rewind and watch the screen because I do a lot of highlighting here. I went to school for highlighting. Yeah I'm filled with a lot of bad jokes. Just ask Qazi. You get used to it. Anyways, where was I? So so display the initial board and then from here, maybe the next thing would have to do is I don't know, like handle a turn. So let's just try to handle the first turn first. So handle turn will be a function. I always like to put things in functions if it's a different concept, so displaying the board, I stuck that on a function. If I want to handle a turn, I'm gonna stick it in a function. Let's just do that here. So define, handle turn, boom. You have a little function coded up. I like two spaces. Two lines between my functions just to be easier to read and hear too. So handle turn. What could we have in handled turn. Well handle turn would need to first, probably get the position from the player that they want to go into. So maybe something like this position equals, what's the function input. I was trying to remember the python function for input. So input will ask for something from the command line over here and then when they enter it and press enter, then that whatever they press enter will actually go into position here as a string. So let's say, I don't know, choose a position from one to nine. And just like that. I chose one to nine because it just makes sense. If this is position one, this is position two, this is position three, so on four, five, six, seven, eight and nine. You can just type in the number and whatever position you choose, that is where your piece will go. So handle turn, how are we doing here so far? Let's just try to run this and see what happens. Boom, so as you can see, this actually gets reached. This input here and then I can just put it in a one and nothing happens because we didn't tell any, we're not doing anything with position here, but actually one went into position here and then from there we can actually deal with the game logic. So now let's actually do something with position. First of all, because position is a string, we are probably going to want it to actually be an integer so that we can index into our list with an integer instead of a string. So let's do that first. Position equals int position. And remember, position is one through nine, but the elements in our array is zero through eight. So actually, if we get position one, what we actually want to zero. So let's subtract one from here just so we get the correct index in here. So now position is correctly cast it and subtract the one from it so that we know where and the board to go. All right, so now that we have our position. Let's just try to put something in the board. So let's just say board at position equals X. Okay, easy enough. And then, just throwing a quick display board here. Let's hit run so we have an empty board printing out, and then it says, choose a position from one to nine. Let's put in one and boom, look. We chose position one which is here. We cast to an int and then we went into the board and we stuck an X in that spot and then we displayed the board again and look, that's what we have. And that's all from what? 20 not even 29, 30 lines of code, not even cause there's because there's a lot of space. 30 lines of code and we already have this whipped up where we have a board, we have a prompt, we input something and then we actually edit the board and display it again. Pretty cool, right? So let's leave this here just like this but now I want to go back up to play game up here and actually work out some of the overarching game logic. So after we display the initial board, what we want to do is we want to have a loop that can loop through turns over and over and over again until the game is over. So it'll keep going. Every single turn, X's turn, O's, turn, X's, turn, O's turn over and over and over again until somebody wins or there's a tie. So this is what it would look like. Usually I kind of have something in here and then by hack I just mean type something that I think might work and then I just try to see if it runs and then just go from there. So just follow along. So while game is still going okay, if the game is still going, then I want to handle a turn. And then after I handle a turn, actually if we're handling turn, we should probably have some way to differentiate if it's X's turn O's turn. So let's go like this. Let's just give it a thing called current player that'll just be an X or O, but later. We'll do that later. So after we handle a turn, X or O goes and takes their turn, then we want to check if the game is over or check of the game if somebody want or if they tied. So I call that check if game over. I don't know how I got there, but yeah, check if game over. And then, after that, then assuming that the game is not over and I don't break out of this loop, then we will want to flip from one player to the other. So I'm just gonna call this flip player from X to O or O to X. And then after that, then we're gonna go back up and then we're gonna go again. We're gonna handle turn with the other player because we flipped it and then we'll check of there's a just the game over and then flip the player again and go back up and then take another player's turn and then check if the game's over and then flip and his so on and so forth until somebody wins or there's a tie. That's pretty much it. So let's make these functions real quick. We already have handle turn. Let me put it down here. So we need check if game over. Check if game over. Well that needs to be a function. And all this is gonna do is actually just call to other functions. Check if win and check if tie. See how that works. See how I'm breaking up the code, the game logic. What are the criteria for a game to be over is if somebody wins, if somebody gets three in a row or if there's a tie, if the entire board is full and nobody has one yet. So those are the two criteria for the game ending. And so that's why I use that up here. I handle a turn and that's because the board state changes. And then I see if there's a game over after they placed a piece. And then depending on that, I will either stop, I'll break out of this loop somehow by maybe sitting this equal to false instead of true and then, break out. But first we need to check if the game is over. So we're gonna do that by checking if there's a win and checking if there's a tie. Next let's code up this one. Check if win. This is also a function, I keep forgetting that. Check if wins. So here I'm just gonna put a return thing just to keep it nice and clean for now, but pretty much we're going to have check rows. Like I said earlier, check columns and check diagonals. So we'll leave that there for now. I'll just put it return here so that it doesn't break when we hit run. I don't want any red things over here popping up any errors because it's just kind of gross. It's inevitable but it's still gross. Also need to check if there's a tie. So define check if tie, just like that and then I'll just return as well. I'll populate these a little bit later but I just want to get the overarching logic done first. So check off when and check if tie. So check if win, check if tie. Those are all right. So check if game over. So that's all taken care of. Check if game over. So I have, this is already made down here. Check if game over is already coded. Now we just need flip player. That's the one I was missing. So now we need one last function called flip player. Just like this and this is just going to flip the player from X to O so that we know which piece to place down and stuff like that pretty much. In the display it is currently X's turn, it is currently O's turn. Please choose a position, something like that. I think I might have most of the functions I need. I just need these three functions, but I will do those later. Let me see. All right, let's actually just see if we're getting any errors. Run it. Yeah, there's an error, of course. Games still going is not defined. So usually errors will happen a lot if you're new to programming. They usually come back and read and they usually say trace back something. Oh my God, my life is over. My parents don't like me. My best friend just left me. Somebody else just left me. Look for the error it'll usually tell you what's wrong. So it says, game's still going is not defined. I think that's here. So this is a Boolean. I'm just going to make this a global variable up here. Actually let's put a comment up here because I like having all of my global variables just like that, nice and tidy there. Game board, boom and then we are going to need, if game is still going. We'll call it game still going and we'll set it equal to true by default because we want that loop to run by default initially. The game is going from the very beginning. This is only gonna be false when there's a game over. So whenever we get a game over, we're gonna set this to false and then automatically, because this is what this relies on, if this is true, it'll run until it's good but then if there's a game over and we get a false and we set this equal to false. Then next time this goes, it'll jump out of it because we know that there's a game over. While we're at it, why don't we just make a couple other ones. I think maybe, who won or tie? Let's just put winner equals none for now. I guess there's one no winner right now. And then maybe we could change winner to X or O when there's a winner so we know who the winner is or if there's a tie, then winner we'll just say none because yeah, there's no winner. It makes sense. And maybe I'll also, I think one last thing we'll probably need is a whose turn is it? We'll just be a current player and let's just have X go first. Yeah like that. So let's try run this and see if you get any errors. We get an error again. A handle turn takes zero position but one was given handle turn I see. So we're trying to give something to handle turn, but we're getting an error. Yeah because we're trying to give something here when it doesn't take anything in the function. So let's just say okay, current player. Now let's see if we run us. Hey, okay. So we got rid of their big or red lines of doom. I just just get used to errors. They happen all the time. It's just a part of coding. I'll read them, definitely read them. They usually tell you what's wrong. They tell you what line number is wrong so you can actually just go into the code to that line, figure out what is wrong, maybe you put a few debugging statements in there and then just keep working out from there. All right, cool. So let's go back to play game. So we have the loop going and then like I said earlier, if the game ever stops from here, if the game is over and this loop jumps out, then we're gonna jump out of this loop. So let's actually put something here. So the game has ended right here. And then we can just say, remember that thing at the beginning, earlier, the global variables? We have a winner. Let's use that here. So let's say if winner equals X or winner equals O, that means X or O won. We don't know who won yet. Then we'll just say, I guess we do know who won because the winner will have who won, X or O. At least that's the idea. I'm gonna put the winner in that once we know if there's a winner. We'll just be like okay. If this person won, then winner equals X, or if X won, then winner equals X. If O won, then winner equals O and then we can just get that global winner variable from here. So we'll just say print winner. So that will be X or O plus space WN. So this'll be com X won or O won. That's an easy. Else if winner equals none, then this will be a tie. So let's just put that in like that, boom. Let's see if anything is broken. Everything's running good. Good practice is actually to unit test which means to keep running your code over and over again and make sure there's no errors and then whenever you do get an error, fix it immediately so that you're not swamped with bugs because sometimes you fix one bug and then it creates 10 others and then this just gets really out of hand. But if you fix every bug one by one as they come and then everything's always working nicely, then you know exactly what caused the error because you just made a small change to the code. So try to do that. Always try to run it. If something's wrong, fix it before you move on. All right, cool. So we have play game. I might not touch it for a little bit. I think this is almost fleshed out because we'll display the initial board and then we'll have the game going, going, going, going, going and then when it ends, then we'll just print if there's a winner or if it was a tie. So that's kind of the overarching idea of play game. So I actually think this function is pretty much done. It might be a little, a few little changes here or there but yeah, let's just put in some comments because good practice. I haven't been doing that. I'm not being a good example. I was never a good example. So my mom always tells me, I have a little sister. Anyways, we're just gonna flip to the other player just like that. Check if the game has ended. You don't really need do this because the names are so descriptive, but hey, I'm a little bit OCD, so why not? Handle a single turn of an arbitrary player? Big words, big words. And while the game is still going. So this will just loop while the game is still going and then once there's a game over, it'll break out because this will be turned to false and then we'll jump out here and print out the stuff. So, yeah. Play a game of Tic Tac Toe. Okay, cool. Why don't we just fill all these in. Display board, I'm so bad at this. I'm actually an English major. And then handle a single turn of an arbitrary player. I also can't spell sometimes or type or do anything for that matter. So let's end that there. So yeah, we are going to move on now. Currently, our current functionality is this. We have it running here and then when we never, we put in a number of valid number from one to nine, it will populate that spot in the board. So if I put two then it'll go on to three and we can keep doing this forever. As you notice, I can put it in every single spot and I can also overwrite old spots. It'll just keep overriding it as X. But that doesn't really seem like correct functionality. I mean nobody's winning, nobody's losing. Where's the O. So at least we have this basic functionality happening, but now we need to actually clean it up so that the right player plays and then if somebody wins or if there's a tie, then the game actually ends and then it notifies us that the game ends. So, I think the place that I want to do, that I want to start, next is actually check if win. I'm actually gonna change this to check for winner. I just prefer that name. Yeah, check for winner, check if tie, check for winner. So if I change this function name, I think I called it somewhere. So let's copy this and go back up. Check if game over. Okay, let's just command F. Check if win. There's only one match. Oh, it's right here. Yeah check if game over. So let's change that. So check for winner and check if tie. I prefer that. You can leave it the other way if you want. It doesn't really matter. This is just personal preference. They will both do but anyways, so this is, the next one that we need to code up. So check for winner. If we get three X's in a row, then we want the game to say, hey X won, somebody won if we get three X's in a row. So how do we check if we have three X's in a row? Well, we can either have three X's in a row in a row, we can have them in a column, going straight down or we can have the diagonals. So, let's just break it up into those three pieces. So check for winner is going to start by. Well actually, do we even have these functions made yet? No, we don't. So actually what we need to do is actually make a function for each of these comments here. So check for let's find, define. Check rows, that'll do. Check rows, return. Define check, columns. Return and the final check diagonals. I like that word. So now we have three functions that will check each of these and all I need these functions to do is if is check the rows in the board or the columns are the diagonals and then whatever, if there's three in a row in any of those rows, then it basically returns true. It flags the wild loop that the game is over and then it returns either X are O. So I want it to return X or O if somebody won and then two flag this up here, game's still going to fall so that the game ends. So return to X or an O and flag this so that it jumps out. And then, if we return X or O, then we can actually know that winner is X or O here. So let's do that. We have these, maybe I'll code these in a bit. Let's, start up here. So let's just fill this out, check rows. We're going to say row winner equals check rows. If we have that column winner equals check columns and I misspelled that and diagonal winner equals check diagonals. Winder, that is not right. Okay, so now we have those going. Let's see if you have any errors. No errors, cool. What next? So I'm assuming that when I call these, then if there's a winner in a row or a winner and a co. I said there was no typos. There's one right there. Okay so if there's a winner in a row or winner in a column or winner in a diagonal, then these will either be returned, true or false. As a Boolean, it'll say there was a winner there. So maybe we can say if row winner then okay. Then there was a win. I don't know quite yet. If there was a column winner, then yeah, there was a win. And then else if diagonal winner, once again there was a win. Else there was no win. So, if there was no win, I think we had a variable. Didn't we set a variable up here? Yeah, winner. So winner equals none. I guess we could utilize this now. Winner equals none. We're gonna have there was no win. Let's just try winner equals none. And then if there was a win, then winner equals diagonal winner. There was no win. Winner equals column winner and then for rows, winner equals real winner. I think that'll work for now. There might be some bugs, but if there is, we'll go back to them and solve them together. All right, cool. One thing I forgot to mention. If you are trying to access any global variables up here, that is outside of a function and you're trying to access it within a function or when the axis you can read it just fine, but if you're trying to write to it, if you're trying to write to a variable outside the function, you actually need to declare that variable within the function as global. So this winner is outside the function. It's considered a global variable as I noted here. So if we're going to try to set winner, that means we're trying to set a global variable. So therefore we actually need to write this here. Let me just show you, it might be a little bit, make me a little bit more sense. So what I'm doing here is I'm saying global winners. So this winner will actually match up to the winner outside here. And then, whenever we set winner down here, when we set these are the winner to a different value, this will allow us to set the global one. So we actually need this if we're gonna access global variables. So set up global variables just like that. That should be good for now. Now let's move on to check rows, check columns, check diagonals and check if tie in these, 'cause I think we need to fill these out still. So check rows. What are we gonna do if you want to check the rows of the game board? Well, very simple. We could probably just pick out each element of the row and then see if they're all equal to each other. And then if they are then return X the winner, X or O, whoever the winner is or return none if there's no three in a row. So let's just try that. Let's see what we can do. Row one, okay. So the board is a list, right? To check for the first row here, we would have to check element zero, element one and element two. So let's just say board at zero. We want to see if board at zero equals board at one, which also equals board at two. So all this is saying is we are checking row one. Row one is these three up here. So we're just seeing if board one, board two. Well board at zero, board at one and board at two are all equal. So if at the same value then this will come out to be true. And then we know that row one is actually a winning row. Maybe we should add one more thing, because I just noticed that if these three are all equal to each other but they're actually dashes, then it'll think this is a win when this is just three empty cells in a row. So let's say these three spots in the row all need to be equal to each other and they also should not be equal to a dash. So if all three are equal and it is not equal to a dash, then this is a winning row. I hope that makes sense. Now we're just going to copy and paste this into row two and row three and we're just going to mirror the same exact logic. So zero one, two, three, four, five is the second row and six, seven, eight is the third row. So now this logic here is if the first row has a winning configuration, then this becomes true. Likewise for row two and three, the same kind of deal happens. Now, if there is, if either of these are true, then that means somebody won and if somebody won then we actually need to end the game. So actually I remember we had this variable up here called game's still going equals true. It is also a global variable. So we're actually going to need to set this to false if somebody wins. So let's set up that global variable down there. Let's do that first. Global game's still going and then, let's put in some comments here. Set up global variables. Here we can see if check if any of the rows have all the same value and is not empty. That's kind of a long comment but at least it's descriptive. And then after we check that, then we can actually say if row one or row two or row three, meaning if there's a win in any of those rows, then we are going to a set game still going to false, which will stop the game, because we know somebody won. So now I felt the comment. If any row does have a match flag that there is a win. So that's what's happening there. So now we know that there has been a win and we actually stopped the game, but now we also need to know who won so we can return and be like okay, X won or O one. So let's just, we don't actually know which row one, so we're gonna have to actually check each one individually. So if row won, then we know that row one has a winning streak, a winning configuration but we don't know what value is in there. So it's as simple as checking board at zero because row one board at zero is within row one. So whatever's there, if it's an X or an O, then we know that that's the value that we want to get. So we can just return board at zero. Same thing for row two. We can just return board at three and then same for row three. If that's the winning row then we want to return whatever player is at row six. I got the zero three six from here. Zero, three, six. I also could to use one for seven or two, five, eight. I just need one of them. I just need to know if it's X or O that won and you can just leave this last return here. That's just like a clean up just in case something happens. let's run this and see if we get any errors. We do not, that is good. So hopefully that made sense. Let me just pop a quick comment in here. Return the winner, X or O. Yeah, hopefully that made sense because I believe check columns and check diagonals are gonna be extremely similar. Let's just actually, let's just copy and paste it straight into here and then just edit it as we go. You can follow me. This is very common to do. If you have code that's very similar, you can just copy and paste it and edit the numbers a little bit. So check columns, obviously we're gonna have to check change all these from rows to column. Check columns. Yeah, we're also getting the game's still going because if there's a win, we need to set that equal to false, which is the same down here. Actually I'm just gonna copy column here, copy, paste, paste, paste. If any column does have a match, then yeah. If column one or column two or column three, actually return statement here. So now this looks pretty much exactly the same as the check rows. Only difference is these numbers are not correct. This is still checking if the first row is a winning configuration. Wat we actually need to check is if foe the first column. So actually it's not gonna be zero one two. It's actually going to be I believe zero. Okay, zero one, two, three and four five six. So zero, three, six is what this should be. Zero, three, six is the first column right here. So we're checking out the first column is good. The second column should be one, four, seven, I believe. One, four, seven and then the last one should be two, five, eight. I just did this by counting here. So if this is a zero and this is one, two, then you can just kind of figure out what numbers should be in each column. You can just check it that way. So, this is actually done now unless I missed something, I don't think I did. Oh, I did here actually. So here we need to all return the first element of the columns, not the rows in case either of these is a winning configuration. So check columns, very similar to check rows. Check diagonals is also gonna be very similar. Let me just copy this into here. Copy and paste. Again, we need game's still going in case there is a win and then we need to set it equal to false. Hopefully, that's making sense to you guys. There's only two diagonals, so we actually only need two. We can get rid of this third one. We can get rid of this third one here just like that but now we need to change all the columns to diagonals. Diagonals, paste that in there. If diagonal one or diagonal two. Diagonal one or diagonal two. So now that all the variable names and comments are changed, now we just need to change the numbers to the correct ones. So let's think about it. What is the first diagonal? The positions in the board? So zero is correct because we need this top left one. And we also need the middle one. So what is the middle one? Zero, one, two, three, four. So this should be four and then the last one is the bottom right, which would be eight, the very last position. Same here, let's start with the bottom left. So zero one, two, three, four, five, six. Should be six and then the middle one, zero, one, two, three, four. That's already correct and then the top right would be zero, one, two. So this shouldn't be two. So now that we have checking if the diagonals equal to each other and checking if the other diagonal is equal to each other. Then this function should also be done, except for down here again. Again, we need to check what value which player won. So this would actually be zero and six. You can just mirror these first here because you already know that these are in the diagonal and these are in the diagonal. So you can just choose anyone you want and throw them here to get the correct value. All right, so now let's try running it again and see what happens. Let's just try to... Number two, let's see if we win. Oh, we get an error. String objects is not callable. Winner equals row winner. Type of string object is not callable. Line 76. Let's go to line 76. What is it complaining about? Here, winner equals row winner So I found a mistake here and the mistake is actually, I'm trying, I have this winner variable here. I'm trying to set it equal to row winner, but row winner is actually a variable, not a function. So these parentheses should not be here. Simple mistake, now let's try to run. All right, cool. So only X is playing right now, but if we get three in a row, it should check in the check rows or check for winner as you go to check for winner and then it'll run check rows and then it'll see if any of these rows is all the same. And then if it is, it'll end the loop and then it'll return X and then up here, it'll print. If when it equals to X, what you just set then X one. So we were about to do that now. Position three, we're about to put an X. Let's put that in here now and see what happens. And there we go, it says X one because it checks that the first row had all the same value, that wasn't dashes and then it returned this, the first one we chose. The first X and then return it and ended loop and then printed this out and say X one. So that's kind of what's going on. Now we fixed that. So that's pretty cool. So we have the winning, checking for winning is set. If they were all O's it would also work because it's just checking if they're equal, not checking if the X's and O's won and you put an O here, it would say, well then it would put an O here and it would say, O won. So let's also get that worked out. The X and O part. So where are we sitting? Here it is. So going back to handle, turn up here. We want to handle a single term for either X or O. So that's why we actually sent in player here because then we know if it's X or O instead of just X. So actually whatever the current player is, that's what we want to put on the board. If you don't just want to put an X automatically, we actually want to put player on the board because this will be X or O depending on whose turn it is. And we'll put that at the position they choose. So that's the first change. Let's see if that broke anything. Well there's no errors, that's good. Let's try winning. Winning still works, awesome. But now we also need to oh yeah flip player, I forgot about this. I put this little function in here so that after X goes, then it'll flip and then this handle term player will be called with the opposite player. So if it was X, then O will be next and if it was O then X will be next. So, I know player will get an input. We do that. Where did I call flip player from up here and game's still going. Current player is X, so I guess, yeah, when we call handle turn here, current player is what we send to the turns. So all we need to do is in foot player is change current player. So let's go down to flip player rates here and pretty much all we need to do is if current player equals X, then current player equals O. There we go. Just be very careful here. This is checking if they're equal and then if they're equal, then you actually want to set current player to O. So this has a double equals and this has a single equals. Very common mistake to make. And then else if current player equals O, then we want current player to become X. And since this is a global variable, the only way we can write to it or change it is to put this here. Current player. So let's just put some comments in here. Global variables we need. If the current player was X or then yeah. Then change it to O and if the current player was O, then change it to X and yeah, see if that broke anything. It did. Sometimes repl it lags a little bit and it gets a little bit screwed up. So sometimes actually just refresh the page. Let me copy all of this just in case. I don't want to lose all this work. So I'll refresh the page. We get brought back here. I'll move this over and then go back down to where we just were. Flip player. Let's hit run and there we go. It's running good again. So now every time X goes, then we'll flip the player to O and then O will go and then I'll flip back to X and so on and so forth. And now we actually have two players playing the game. Cool, right? And boom, X won. X on this diagonal here. So actually we have a working game. So now the only thing we haven't done yet is if they tie. If the board fills up, the game also needs to end. So oops, got an error there. That's another thing we're gonna have to handle is if they put an improper input, we need to handle that to make it more robust so that the game just doesn't break and it prints out all this error messaging here. So let's, first just try to tie. Nine and four. Yeah, so as you can see, we have a draw here, a tie, but nothing happens. It just keeps going. We could just keep putting in more variables and then it'll just keep overriding which is improper, incorrect execution. So we need to actually change that. We can check for tie. The first thing that comes to mind for me is all we can do is just check if there's a dash in the list, in the board. If there is a dash, then there's no tie yet. But if there's no dash, that means every spot has been filled up and a tie needs to happen. Very, very simple. Since board is just a list, we can literally just go like this. If dash is not in board, then we can just say game's still going cool to false. This is the thing that ends the game, remember? Game's still going is false and because it's a global variable, again, we need to declare it as a global variable so we can write to it 'cause we write to it, we read it false here. That is not on board getting the game ends and then also, you can just return. Let's try that for now. Let's see what happens. So putting one, two, three, five, six, seven, eight, nine, four. And there we go, it worked. So if the whole board fills up and nobody has one yet, then it'll just say tie and then the game is over. So that's all we need. That is done, very simple checking for a tie. We're actually getting pretty close to being done now. I think the only thing that we need to do next is to make it so that if we put in improper input, then it doesn't break it. If there's an is improper input, then we just want the game to ask the user again or just pass it and just be like, okay just choose a position again. Choose another position or something like that. So let's actually go up to handle turn, I believe. That's where we actually get the input. Yeah, that's right. So handle turn is where we get the input in and now we're actually going to need to check to make sure that input is correct. So first of all, actually we should notify which player's turn it is. So let's just put a simple print in here. Since we know the player, the player's either X or Y, we can actually putting the string here and go like that. So it will, this will say O's turn or X's turn and then then it'll ask for input from the user just like that. But then we also want to make sure that the input is valid before we cast it because, we can put in any string the input function from Python can take in any string. But then if we try to put that in here and cast it to an int, like if they put something that's not able to be cast to an int, then we're gonna get an error. So let's try that first. If position not in and this is a little trick that I found on Google. We could use regular expressions, if any of you guys know what that is, but that's a little bit advanced. Like it's a whole another thing. So this is actually a quick solution. Basically we just want to make sure that the input the user gives is in this list because we only want a specifically nine different inputs. Then we're only gonna allow these nine inputs. Obviously this wouldn't work if you wanted to allow a million different kinds of inputs, we can't type it all out. But since we only have nine, we can just make it nice and clean and simple. So we can say position, which is the thing that we get from input from the keyboard, it needs to be a string that matches one, matches two matches three or so on and so forth, all the way up to nine. If it doesn't, then we need to ask again. So if it doesn't, then we need to say, hey, position equals and actually let's just copy and paste this. Input invalid input. Choose a position from one to nine. So let's try to run this now. Oops, what is wrong? Oh, the is statement. I forgot to put a semi colon at the end or I mean our regular colon at the end. Syntax errors. That just means that Python, there's something wrong. if I forgot the F in if, that I would get a syntax error. Like what is that? So just keep that in mind. We're gonna run it now, no more error. Actually now we added this it says X's turn. It lets us know who's turn it is which is a very handy. So choose a position from one to nine. One and then we can go but then let's say we put something that's not in one to nine. Let's put z, let's put a 35. Hit enter, it says invalid input. Choose a position from one to nine. Yeah, so it's good that it caught it and then re ask again. Let's try again. Let's put in 55 this time and then we get an error. So the reason this is happening is because let's say they put an invalid input and they say it's invalid and then this catches it and it says the input is not in the correct range of valid inputs. So it asks again and it says, okay, invalid input. Please choose a position from one to nine and then it tries it again and then it gets down here and then it's invalid and it tries to do it anyways. Which means it only checks if you put an invalid input one time. So actually what we need to do is actually put this in a while loop so that it's constantly asking over and over again for valid input until it is valid. So this is a very common thing you do in programming. Instead of using an if statement, you actually use a while loop. So it'll be like while position is not in here, just keep asking over and over and over again. And actually we don't really need an invalid input. We can just ask again. So it'll say, the first it will initially say, okay, X's turn, choose a position from one to nine and then it will, get the position and then it'll say, if position isn't in here, ask for position again. Again, if it isn't in here, ask for position again. And then again, if position isn't in this list over here, if it is in here, then ask for position input again. Over and over again until position is in this range and then it will continue down here. And then since we are only allowing these digits from one to nine, this casting to an int here, if position is in this range from one to nine we put it in this in here, and then we cast it to an int, then it won't throw this ugly error here. Let's try this again. Please choose position from one to nine. We put it into one, that works just fine. Let's put in a 20, error. It asks again. 20, 20 letters, random, nothing at all. Random stuff, anything we put that doesn't exist in this list, it will actually just ignore it and then just keep asking for your position over and over over again until we give it something that works. And as you can see, the O one and right in the middle. So that's working nicely, cool. One of the things that we forgot to implement in this though is what if we put something in a spot where there's already a piece. That's an issue. So let's say we put X in one and O at five. Now, it says it's X's turn and it says choose a position from one to nine. So let's try to overwrite this O by putting a five there. I hit enter and as you can see, the O was actually overwritten. That's a problem because that violates the rules of Tic Tac Toe. So what we need to do is actually put in another check here to see if the position we chose is valid on the board. We could check that here after we pick the position and we've cast it and subtracted one from it to get the right index and the list. We can just check and be like, if board at position equals empty or doesn't equal empty, then print you can't go there. Go again. All right, let's try this. Colon again, there we go. One, five and then let's try to override it again and see what it says. It says you can't go there, go again. So cool. So it actually, this popped up. So it noticed that it was trying to override it, but as you can see it's still overrided. I think that's because we didn't actually implement or ask for the new new input again. It continued to override it. I think it just went on here. It went on to setting the board position to player. Anyways, so actually what we need here is another wire loop. This part gets a little bit tricky but just try to follow along. I'll explain it the very end clearly so that it makes sense. So actually what we're going to do is we're going to add a nother wild loop around this wild loop and just call it and just run it on a Boolean, called valid or while not valid. If the input is not valid, it's just gonna keep asking over and over again and we of course need to create valid originally and we'll just start it as false 'cause we'll assume it's not valid. So while not valid, then we are going to keep asking for input in this range, get it and then check the position and then if it doesn't equal, well actually would it be easier if this makes more sense. Let's do it this way. If we're positioned does equal an empty spot, then that means valid equals true. We can set value equal to true to finally break out of this other loop and then else then we can print this. So now let's try to run it. This should work now. So let's try to put one and then five and then five again. And this says, you can't go there. Go again. Let me try to put five. You can't go there, go again. Five, you can't go there, go again. Over and over again until I choose something that is valid like six and then you can see that it puts the value in position six and leave this one alone. All right, so this is a little bit tricky. Let me explain what's happening. So, we have this wild loop that is running on this Boolean called valid. And then, once we enter this, then we'll make sure that the position inputted is within this range and then after that, then we'll change that to the board position and then we'll check again, is this board position available? And then if it is available, then we set this equal to true so that we can jump out of here and go onto here to actually placing the piece on the board. But if it isn't, then it will say you can't go there and go again. This will stay vulnerable, stay false, it'll come back up here and then it'll run this again. It'll ask for more input over and over again and then once it gets a valid input, it'll check to see if the board is available. And then again, if it's a valid, then it'll go on, but if it's not, then it'll just say you can't go again, it'll loop back up and then continue over and over and over again. So a little bit tricky. Sometimes it's input stuff kind of sucks. But if you're using a lot of other frameworks when you are actually building bigger apps, a lot of this input stuff is taken care of for you already. It's a not too often that you have to actually do it yourself like this. But I mean, it's good exercise to understand the logic that's going around. I think that's actually it. I mean I haven't put comments everywhere, but I think we have a fully functioning Tic Tac Toe app. Pretty cool. So, let's just try to row it one last time and go through this game and then go through all the cases and see if everything's working correctly. So if we put it a valid input in, then yeah, it puts it in the right spot. Put another valve in and put in and puts it in the right spot. If we try to overwrite by putting it in position two it says you can't go there. Okay, let's put it in position three instead. Okay, now it's O's turn again. Let's put it in position five. And then X's turn let's put it in position six and then change position from one to nine. Let's put it here so it's one, two, three, four, five, six, seven, eight. Position eight, so we can put O and an O should win and as you can see, O won, Very cool. Now let's run it again. If O wins, then X can also win but let's try to put in some, let's try to tie. One, two, three. I memorize this little a sequence here quickly. So this looks like a tie and game. If we put this in here then yeah, I'll print tie. So it looks our Tic Tac Toe game is working as expected. Everything is working nicely. It is pretty robust because it only allows for certain inputs. It doesn't allow for overwriting your certain pieces and it out prints everything. Ii lets the players know whose turn it is, it lets them know what the input and everything. So this is a very nice small self contained and robust little application and you guys followed along and you coded it yourself, so good job. I would actually advise you to look at the code. I'm going to upload the code with full comments, probably somewhere maybe in the description of this video or something and then you can click on it and really read it. I'll try to explain everything as best I can in the comments so that you can really trace the entire thing yourself and then things will just be clear. You could also maybe perhaps try do little exercises like change the code See if you can change it instead of having X's and O's as the players. Maybe changes so that it's A and B or something cool like that little challenges. But other than that, good job guys. You created your first Tic Tac Toe app with me and I hope you enjoyed it. I hope you learned a lot. I hope you guys liked me. I'm a new person on this channel right now. Qazi kind of allowed me in here after I begged and begged and begged and begged. But yeah, I'm here now. So expect to hear more from me. Thank you all for listening and I'll get better at this as I go. So if there's anything that'll offer anything, just give me a chance. I'm gonna keep working at this real hard to give all you guys as much value as I can. A lot of free value, any kind of value I can offer and programming and what not. But yeah, again, I am Aaron from Clever Programmer and thank you all for watching. Good bye. (hip hop music)
