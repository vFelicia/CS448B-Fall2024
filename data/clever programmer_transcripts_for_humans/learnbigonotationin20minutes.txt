With timestamps:

00:00 - yo what is up guys coach daniel here and
00:02 - today
00:03 - i want to talk to you exactly why you
00:05 - want to use big o notation
00:06 - so that you can crush technical
00:09 - interviews now guys in the past i've
00:11 - actually had the opportunity to
00:12 - interview and get job offers from top
00:14 - tech companies like youtube and
00:16 - microsoft and i have to say it was
00:18 - honestly thanks to what i was able to
00:20 - learn
00:20 - with big old notation because it is an
00:22 - important concept
00:24 - when it comes to software development
00:25 - and if you can get this down
00:27 - you're going to be able to cross your
00:28 - technical interviews but not only that
00:30 - you're gonna be able to create
00:31 - successful algorithms and use data
00:33 - structures properly
00:35 - in the future now we've heard you i did
00:37 - the last data structure video
00:38 - and a little bit high level but you guys
00:40 - wanted me to go deeper so before i start
00:42 - to go deeper into all these other data
00:45 - structures
00:46 - you need to learn about big o notation
00:48 - which is exactly
00:49 - what we're gonna learn today guys this
00:52 - is the foundations the basics
00:54 - what you need to know so that you can
00:55 - make sure you're creating the most
00:57 - optimal algorithm
00:58 - and when you show up to those technical
00:59 - interviews by google or microsoft
01:01 - you absolutely crush it so before we get
01:04 - into it guys please go ahead
01:06 - like this video send this video out
01:09 - there to the world
01:10 - let's beat the youtube algorithm let's
01:12 - pummel it down so that we can share
01:14 - our message with more people and only
01:16 - that don't forget to subscribe and hit
01:17 - that bell notification icon
01:19 - so we could keep on doing deep dive
01:22 - content for you so that you'll know
01:24 - exactly what you could do
01:26 - to land your job as a full stack
01:28 - developer as a web developer
01:30 - but you understand the nuances and the
01:32 - high technicalities of everything so
01:35 - with that being said
01:36 - let's go ahead and get into the video so
01:38 - to start it all off
01:40 - i want to tell you about an analogy a
01:42 - story that really helped me
01:44 - to understand the concept of big-o
01:46 - notation and
01:47 - why it is so useful how it actually
01:49 - allows us
01:50 - to see how something is more optimal
01:52 - compared to something else
01:54 - and this story is very very simple
01:56 - imagine you live somewhere in the united
01:58 - states
01:58 - in the west coast right and you have a
02:00 - friend of yours who lives on the east
02:02 - coast
02:03 - now you want to send your friend an
02:05 - amazing video that you were able to get
02:08 - in beautiful sunset in california and
02:10 - they're all the way in florida
02:12 - now you could send it to them two
02:13 - different ways you could send it by
02:15 - uploading it to the cloud
02:16 - and they download it or you could send
02:18 - it by downloading it to a solid state
02:20 - drive
02:21 - and sending it over the airplane so that
02:23 - when it gets over there to florida
02:25 - he gets it and then he can download it
02:27 - and he gets the video
02:28 - now right off the bat you might be
02:29 - thinking well yeah obviously the video
02:31 - would be faster
02:32 - it would be until some point because
02:35 - let's think about it if this was just a
02:37 - simple
02:38 - one minute video it would probably take
02:41 - that video to send over the cloud maybe
02:43 - just about
02:44 - five to ten minutes at most if you were
02:47 - to send it over an airplane
02:49 - it would take the six hours just to get
02:51 - from
02:52 - la all the way down to jacksonville
02:54 - florida but now
02:55 - let me ask you this what if the video
02:58 - was
02:59 - actually a humongous video what if it
03:01 - was like this
03:03 - 10 hour video what if it was all the
03:05 - clips that would be needed to create one
03:07 - of these amazing movies
03:08 - unedited raw video something like 300
03:12 - gigabytes some
03:13 - ridiculous amounts well now the story
03:15 - changes because now if you happen to
03:17 - upload it to the cloud that might take
03:19 - around like
03:20 - five to ten hours and if they're
03:22 - downloading it that might take another
03:23 - five to ten hours
03:24 - but think about this downloading it down
03:27 - to your ssd would just take a couple
03:28 - minutes
03:29 - flying it over to florida would take six
03:31 - hours
03:32 - and then downloading it from the ssd
03:34 - will just take a couple more minutes
03:36 - so now if you have this humongous video
03:38 - it would actually be
03:40 - faster for you to send it over the
03:42 - airplane
03:43 - as ridiculous as it sounds and this
03:46 - is exactly why big o notation is so
03:50 - useful when it comes to code when it
03:52 - comes to functions that you're running
03:54 - big o notation is essentially how
03:57 - long a chunk of code takes to run
04:00 - depending on how big the input is and
04:03 - how does that scale
04:04 - over time so again taking it back to the
04:07 - analogy
04:07 - if i just had a small input or a small
04:09 - video then it would be faster to just
04:11 - send it over the cloud but if i had a
04:13 - huge
04:14 - input or a huge video it would actually
04:16 - be faster to send it over the airplane
04:18 - so when we start to look at code and we
04:20 - look at a chunk of code
04:21 - we want to ask depending on the input if
04:24 - the input grows over time
04:26 - how is this code going to execute over
04:28 - time is it going to take
04:30 - longer and longer like uploading and
04:32 - downloading to the cloud or is it going
04:33 - to stay
04:34 - constant like just sending it over the
04:36 - airplane so this epic analogy
04:38 - allowed me to understand why it is that
04:40 - we want to look at the code
04:42 - and start to see where it will be
04:44 - optimal and where it's going to take
04:46 - longer and how it acts over a long
04:48 - period of time and how it scales
04:50 - with the input but now the second
04:52 - question becomes well how do you
04:53 - actually
04:54 - now keep track of this time how do you
04:56 - actually see how something is going to
04:58 - scale with time well it's very simple
05:00 - this is specifically where
05:02 - the big o notation comes whenever you
05:03 - see the o with the parenthesis and you
05:05 - see some function inside
05:07 - all it is is a representation of how
05:10 - long the chunk of code is going to take
05:12 - over a long period of time
05:14 - so quite simply put if i were to ask you
05:17 - if you were to run a mile on the track
05:19 - how many laps would it be
05:21 - you would tell me four laps if i say 3
05:23 - miles you would tell me 12 laps
05:25 - so it's just a different way of
05:26 - representing how long something takes
05:29 - and this all comes down to just
05:30 - understanding that the computer is going
05:33 - to take
05:33 - x amount of time whether it's
05:35 - milliseconds or microseconds to execute
05:37 - just
05:38 - one line of code so you could come up
05:40 - with the mathematical equations
05:42 - how long something is going to take now
05:44 - in big ol notation these equations don't
05:46 - have to be perfect
05:47 - but they just have to give a good model
05:49 - of how it's going to act over time guys
05:51 - today's sponsor is hostinger and the
05:54 - reason
05:54 - why we decided to partner up with
05:56 - hostinger is because if you really
05:58 - want to start to generate money and make
06:01 - money as a developer whether it's
06:03 - freelancer or whatever that is
06:05 - you're gonna have to learn how to build
06:07 - websites and that could be for either
06:08 - specific clients that you get
06:10 - as a freelancer or even for yourself if
06:13 - you're trying to build your own
06:14 - portfolio where you could showcase your
06:16 - own projects
06:17 - so what i want to do is i want to get
06:19 - into the website builder to show you how
06:21 - simple quick and easy it is to make
06:23 - websites
06:24 - so once you start going to the web
06:26 - builder you could start to build
06:28 - a website from all these different
06:30 - templates that they have available to
06:32 - you
06:32 - when you get the template and you select
06:34 - it you can now go to the website and it
06:36 - makes it easy to be able to modify
06:38 - anything from the website whether that's
06:39 - just changing the pictures
06:41 - or changing the text so again if you do
06:43 - have a client who's looking for a good
06:44 - website that you're able to get
06:46 - from as a freelancer you can then create
06:49 - fast websites for them and again you can
06:51 - make it super
06:52 - beautiful design is easy to use easy to
06:56 - implement
06:57 - and the websites you'll be creating from
06:58 - this you could definitely charge
07:00 - a lot of money for you can start to
07:02 - build your own online portfolio because
07:04 - when you're submitting job applications
07:06 - or when you're trying to get a next
07:08 - contract
07:09 - you're going to want to show them the
07:10 - work that you've done so by
07:12 - creating an amazing website putting your
07:14 - projects on this website this becomes
07:16 - your portfolio this becomes
07:18 - your way of showing yourself and
07:20 - branding yourself so that you can land
07:22 - that six-figure developer job so if you
07:24 - want to create a website
07:25 - or host your domains what you could do
07:27 - is click the link
07:29 - below and you're gonna get a special
07:31 - seven percent discount from us just make
07:33 - sure to use
07:34 - the coupon code clever programmer that
07:37 - is one word clever programmer so guys
07:39 - make sure to go check out hostinger so
07:42 - that you can start to build beautiful
07:43 - websites or buy your domains
07:45 - very quickly very easily and very
07:48 - effortlessly so let's go ahead
07:50 - and jump into the code so i could give
07:51 - you a better example so simply put
07:53 - if we just look at this function right
07:56 - here
07:56 - all we want to do is we're looking for
07:58 - an item so we have a for loop that's
08:00 - going to loop
08:01 - through an array or a list and it's
08:03 - going to just find for the specific
08:05 - match that we want whenever matches it
08:07 - returns
08:08 - the specific index when it doesn't match
08:10 - it'll just return negative one because
08:11 - it didn't find the index now what you
08:13 - need to understand
08:14 - is each line of code is gonna take
08:17 - some time for the computer to execute it
08:20 - so the minute the computer starts with
08:22 - the function
08:23 - it's going to take milliseconds for it
08:25 - to execute this line of code
08:26 - and it's going to take another fraction
08:28 - of a millisecond to execute this code
08:30 - and it's going to take another fraction
08:31 - of a millisecond to execute this code so
08:33 - on and so forth
08:34 - so now we can start to see why it's
08:37 - important to look at the input
08:38 - so in this case the input would be the
08:41 - items this would be the list
08:42 - of items what we're noticing is this for
08:45 - loop
08:46 - is going to go through every single item
08:49 - just one time if the list of items is of
08:51 - size
08:52 - 20 that means worst case scenario where
08:54 - there is not a match
08:56 - this is going to loop 20 times so now if
08:58 - the
08:59 - the items is 50 it's gonna loop 50 times
09:01 - the items is 1000
09:03 - it's gonna loop 1 000 times so we start
09:06 - to notice
09:06 - a trend here as the input grows
09:09 - the time is going to grow or the time
09:11 - that it takes is going to grow in the
09:12 - exact
09:13 - same proportion and this starts to
09:16 - represent
09:16 - a line called big o of n or it's linear
09:20 - where n is just some representation
09:23 - of the input where n is just the size of
09:26 - the input now it could be m
09:27 - it could be x it could be whatever
09:29 - variable you want but just it is
09:30 - standardized to start with
09:32 - n as the initial size of an input so now
09:34 - that that's making sense and we
09:36 - understand that each line of code is
09:37 - going to take a fraction of a
09:38 - millisecond to run
09:40 - and if we have to run it x amount of
09:42 - times because of the size of the input
09:44 - now we can start to graph how long
09:46 - something is going to take over
09:48 - a specific period of time now again i
09:50 - said we don't have to be specific
09:51 - so very often it's gonna boil down to
09:53 - just a few
09:54 - different types of functions that we can
09:57 - get so let's dive into it real quick and
09:58 - let me show you what functions these are
10:00 - now here in front of me i have this
10:01 - amazing graph
10:02 - i think it's amazing because it's color
10:04 - coordinated it's going to help you
10:06 - to see what is an optimal algorithm
10:08 - versus what is not an optimal algorithm
10:09 - before we get into that let's observe
10:11 - and see what some of these lines are
10:13 - so if you remember your ti 89 you could
10:16 - just go into the calculator
10:17 - put y equals x and they'll graph
10:19 - something for you so if you were to
10:20 - graph
10:21 - all these functions you would see a very
10:23 - similar thing
10:24 - so here at the very bottom we have big o
10:27 - of one
10:28 - which is just a constant this is very
10:30 - similar to when you have like your y
10:31 - equals five and you just see a straight
10:33 - line this means
10:35 - this is the most optimal type of
10:37 - algorithm because it doesn't matter how
10:39 - big your input gets right or it doesn't
10:41 - matter how many operations you have
10:43 - it's always going to be instantly
10:45 - whenever you
10:46 - ask for that operation right above that
10:49 - we have
10:49 - log of n log of n would be like if you
10:51 - were to divide something by two
10:53 - every single time very similar to binary
10:56 - search you get somewhere really really
10:58 - quick
10:58 - after that we have big o van which is
11:00 - what we just talked about where
11:02 - depending on how large the input is
11:04 - that's probably going to take
11:06 - the same amount of time because you're
11:07 - just scaling those operations
11:09 - linearly and then we have n login which
11:11 - might be hit up by some
11:13 - sort of sorting algorithms like merge
11:15 - sort where you would multiply n
11:17 - times log in and it would start to grow
11:19 - over time and then we have the gross
11:20 - algorithms that nobody likes which is
11:22 - like
11:22 - n squared 2 to the power of n and n
11:25 - factorial
11:26 - now again the color coordination is
11:27 - going to tell you which are the type of
11:29 - algorithms you want to achieve and you
11:30 - want to go for
11:31 - so if you have an algorithm if you have
11:34 - a way of solving something that takes n
11:36 - squared that's
11:37 - probably a horrible way to go about it
11:40 - right they labeled it here red for
11:41 - horrible
11:42 - so you're going to want to try to
11:43 - improve that at least to end login if
11:45 - you can't
11:46 - improve it to n or log in as far as you
11:48 - can but here's the reality
11:49 - there's going to be some things that
11:51 - just cannot get better than n squared
11:53 - there's going to be something that just
11:54 - can't get better
11:55 - than two to the power of n for example
11:58 - the hanoi towers
12:00 - you could look at that problem and see
12:01 - how that's gonna be something that can't
12:03 - really get
12:04 - any faster so the reason i show you this
12:06 - is because these are the different types
12:07 - of time
12:08 - functions that it's going to boil down
12:10 - to most of the time
12:12 - now the reason i say boil down to most
12:14 - of the time is because
12:15 - depending on the function it's always
12:17 - going to change and what your function
12:19 - actually is but there are several rules
12:21 - that allow you to simplify the function
12:23 - because again we don't want the perfect
12:24 - function
12:25 - we we just want the function that can
12:27 - describe
12:29 - how this algorithm is going to act or
12:30 - how this chunk of code
12:32 - is going to act over a long period of
12:34 - time with the bigger input so i want to
12:36 - get into some of these rules that you're
12:37 - gonna encounter
12:38 - whenever you're really trying to
12:39 - understand how this piece of code is
12:41 - gonna function over a long period of
12:43 - time
12:43 - so as you've seen the code before here
12:45 - we have a simple for loop that is gonna
12:47 - take
12:47 - big o of n time so it's gonna be linear
12:50 - and then here we have another for loop
12:51 - that's gonna
12:52 - take n squared because it's two for
12:54 - loops that are nested
12:55 - so the first thing i want you to realize
12:56 - if i was to ask you
12:58 - what is the run time of both of these
13:00 - put together
13:01 - what you're gonna do is you're going to
13:03 - add all of the different steps
13:05 - so if you have one that's going to take
13:07 - big o of n and you have another one
13:09 - that's going to be
13:09 - n squared you're going to create a
13:11 - function that is called big o of n
13:13 - squared
13:14 - plus n they want to make sure that the
13:15 - more dominant parts of the function are
13:17 - put up front
13:18 - the reason n squared is more dominant
13:20 - than n because if we were to refer
13:22 - back to this chart n squared is going to
13:25 - take
13:25 - a lot longer than n over a long period
13:28 - of time
13:28 - so n literally becomes irrelevant and
13:32 - that's the rule
13:33 - for number three whenever you do have a
13:35 - long function like that
13:36 - you can take off all the non-dominant
13:39 - factors here and this big o of n
13:43 - squared plus n is literally equivalent
13:45 - to big o of n
13:46 - it gets simplified to big o of n squared
13:49 - because if we look at this
13:50 - graph if we increase the input
13:53 - the operations are going to be way more
13:56 - with big o of n squared to where
13:58 - this is irrelevant the x operations that
14:00 - you add with big o of n
14:02 - are completely irrelevant when you start
14:05 - thinking
14:06 - 10 000 inputs 100 000 inputs 1
14:09 - million inputs so the first rule is you
14:11 - want to add the steps the second rule is
14:13 - you want to simplify everything by just
14:15 - leaving the most dominant algorithm or
14:17 - the algorithm that's going to take the
14:18 - most amount of time
14:19 - the third thing you want to do is you
14:21 - want to take off constants because in
14:23 - reality they're not going to matter so
14:25 - let me give you the perfect example if
14:26 - we go back to this function that are
14:27 - labeled as big o of n in reality this
14:29 - would be big
14:30 - o of 2n now the reason is because if the
14:33 - size
14:33 - n is 100 we're gonna see
14:36 - this if statement 100 times but we're
14:38 - also going to hit this for loop
14:40 - 100 times and assuming we never see the
14:42 - match then we're finally gonna return
14:44 - right because if you start to see how
14:46 - something acts over
14:48 - hundreds of thousands of inputs millions
14:50 - of inputs that difference with the
14:51 - coefficient
14:52 - in front of the input variable is
14:55 - literally
14:55 - irrelevant so you want to make sure you
14:57 - drop the constant so if you have big o
14:59 - of 2 n it would just become big o of n
15:02 - if you have big o of 3 n squared it
15:04 - would just become
15:05 - big o of n squared and here in line 24 i
15:08 - have the perfect example even if it was
15:10 - 5n
15:10 - even if it was 500 n it would still
15:13 - become just
15:14 - big o of n because the coefficient or
15:16 - the constant
15:17 - is irrelevant to how it's going to act
15:19 - over a long period of time because it's
15:20 - just the constant now finally the last
15:23 - rule is you have to take into account
15:24 - the inputs if you're bringing in
15:26 - two different inputs then you just can't
15:28 - call them both n because again n is just
15:30 - like a variable and it's just
15:31 - representing a specific input but
15:33 - imagine if we were to go to this one
15:35 - where it's n
15:35 - squared this is n squared because this
15:38 - for loop
15:39 - is iterating through items items is
15:42 - input number one
15:43 - and then this for loop inside is
15:44 - iterating through the same thing which
15:46 - is items which is one
15:47 - so that would be like n times n which is
15:49 - why it's n
15:50 - squared but what if the outside loop was
15:53 - iterating
15:54 - through items and then the inside loop
15:56 - was iterating through a different
15:57 - array well now items would be input n
16:00 - and that would just depend on however
16:02 - long n is if it's a thousand variables n
16:05 - is a thousand
16:05 - if it's ten thousand twenty thousand
16:07 - whatever number that is but then
16:09 - input m or a different variable would be
16:12 - representing of the second array so you
16:15 - would get something like big o of
16:16 - n times m but the reality is is this is
16:19 - very similar to
16:20 - n squared because you depend on two
16:22 - different arrays but the reality is
16:24 - worst case scenario they both get really
16:26 - really big and then it's going to take a
16:28 - long time and it would take the same
16:29 - amount of time as
16:30 - big o of n squared so guys that is a
16:33 - deep dive into big o notation again i
16:35 - just
16:36 - want to remind you big o notation isn't
16:38 - about having the exact formula
16:40 - you can come up with the exact formula
16:42 - you can literally count and estimate
16:44 - every single line of code that is going
16:46 - to be executed depending on the size
16:48 - of your input but the point isn't that
16:51 - the point is just to see
16:53 - how your function how your piece of code
16:55 - is going to act when the input grows
16:57 - over time when it goes from an input of
16:59 - size 10
17:00 - to 100 to 10 000 to 100 000 to 1 million
17:03 - to 10 million
17:04 - how much longer is your function going
17:06 - to take over specific period of time
17:08 - i hope this was able to start to bring
17:10 - some value and solidify
17:11 - some of these ideas because very often
17:13 - people tend to be a little bit scared of
17:14 - big on notation because yes
17:16 - it has to do a little bit of math but if
17:18 - you start to nail down these skills if
17:20 - you start to practice it if you throw
17:22 - yourself into a bunch of different types
17:23 - of for loops nested for loops and all
17:25 - these crazy things
17:26 - you can start to see a lot of different
17:27 - algorithms you can start to see how fast
17:29 - they act you're gonna start to
17:30 - understand how pieces of code are going
17:31 - to act over a long period of time
17:33 - and it's going to become almost second
17:34 - nature for you to be able to get the
17:36 - time complexity
17:37 - of a specific thing now again the reason
17:39 - the time complexity is super important
17:41 - is because you're probably going to be
17:42 - asked these things in technical
17:44 - interviews for one specific reason
17:46 - because if you can understand how a
17:48 - function will act over time you'll be
17:50 - able to solve the right problem with the
17:52 - right data structure with the right
17:53 - algorithm and you become a problem
17:55 - solver because if you don't know these
17:57 - nuances if you don't know these
17:58 - difference
17:59 - of how a piece of code will act over
18:01 - time then you might implement the wrong
18:03 - solution
18:03 - and that is not good especially if
18:06 - you're trying to become a six
18:07 - figure developer right because someone
18:09 - who gets paid six figures
18:11 - wouldn't be making these kinds of
18:12 - mistakes right someone gets paid six
18:14 - figures will be going
18:16 - through those technical interview
18:17 - questions so if you do want to get on
18:19 - that path of becoming a six figure
18:21 - developer
18:22 - not only that we also have a free
18:24 - training for you
18:25 - go ahead click the link below in this
18:26 - training we're going to teach you
18:27 - exactly
18:28 - how you can become a six figure
18:30 - developer
18:31 - give you the exact road map that you
18:33 - need and you can master
18:35 - front end javascript so that you can
18:37 - start to get the right skills
18:39 - in place and become that six figure
18:41 - developer because it's not just about
18:43 - big o notation you also need to have the
18:44 - skill
18:45 - of developing websites you also need to
18:47 - have the skill of creating beautiful
18:49 - software that solves
18:50 - hard problems to solve in the most
18:53 - optimal way so click the link below
18:55 - watch the training get started and get
18:57 - enrolled with profitable javascript so
18:58 - you can become
18:59 - an amazing master of javascript from
19:01 - development and get those interviews
19:03 - for your dream job as a six figure
19:05 - developer and then with everything that
19:06 - we just talked about today
19:08 - you absolutely crush those interviews so
19:11 - guys
19:12 - that is it for this video i hope you got
19:14 - a lot of value
19:16 - i hope that you now understand what big
19:18 - o notation is and time complexity and
19:20 - how you can use it so that when you go
19:22 - out to those interviews
19:23 - you absolutely crush it if you haven't
19:24 - yet already go ahead smash that like
19:27 - button i don't know what you're doing if
19:28 - you haven't and also make sure to
19:30 - subscribe because i
19:31 - am going to be getting on here i'm be
19:32 - dropping more content more of these tips
19:35 - more of these things that allowed me to
19:37 - land job offers from companies such as
19:39 - blue origin google and microsoft i just
19:41 - want to give you guys
19:43 - everything that i've learned everything
19:44 - in this head i'm trying to transfer you
19:46 - so guys give us a like please make sure
19:48 - to subscribe and hit that bell
19:50 - notification icon so you can get
19:51 - notified the minute we drop these fire
19:53 - videos
19:53 - because i'm gonna create a series on
19:55 - data structures so that you could crush
19:56 - those technical interviews you could
19:58 - become
19:58 - a master javascript developer and land
20:01 - that six
20:01 - figure job all right guys that is it for
20:04 - this video
20:05 - i hope to see in the next one this is
20:06 - coach daniel signing out
20:08 - [Music]
20:15 - peace

Cleaned transcript:

yo what is up guys coach daniel here and today i want to talk to you exactly why you want to use big o notation so that you can crush technical interviews now guys in the past i've actually had the opportunity to interview and get job offers from top tech companies like youtube and microsoft and i have to say it was honestly thanks to what i was able to learn with big old notation because it is an important concept when it comes to software development and if you can get this down you're going to be able to cross your technical interviews but not only that you're gonna be able to create successful algorithms and use data structures properly in the future now we've heard you i did the last data structure video and a little bit high level but you guys wanted me to go deeper so before i start to go deeper into all these other data structures you need to learn about big o notation which is exactly what we're gonna learn today guys this is the foundations the basics what you need to know so that you can make sure you're creating the most optimal algorithm and when you show up to those technical interviews by google or microsoft you absolutely crush it so before we get into it guys please go ahead like this video send this video out there to the world let's beat the youtube algorithm let's pummel it down so that we can share our message with more people and only that don't forget to subscribe and hit that bell notification icon so we could keep on doing deep dive content for you so that you'll know exactly what you could do to land your job as a full stack developer as a web developer but you understand the nuances and the high technicalities of everything so with that being said let's go ahead and get into the video so to start it all off i want to tell you about an analogy a story that really helped me to understand the concept of bigo notation and why it is so useful how it actually allows us to see how something is more optimal compared to something else and this story is very very simple imagine you live somewhere in the united states in the west coast right and you have a friend of yours who lives on the east coast now you want to send your friend an amazing video that you were able to get in beautiful sunset in california and they're all the way in florida now you could send it to them two different ways you could send it by uploading it to the cloud and they download it or you could send it by downloading it to a solid state drive and sending it over the airplane so that when it gets over there to florida he gets it and then he can download it and he gets the video now right off the bat you might be thinking well yeah obviously the video would be faster it would be until some point because let's think about it if this was just a simple one minute video it would probably take that video to send over the cloud maybe just about five to ten minutes at most if you were to send it over an airplane it would take the six hours just to get from la all the way down to jacksonville florida but now let me ask you this what if the video was actually a humongous video what if it was like this 10 hour video what if it was all the clips that would be needed to create one of these amazing movies unedited raw video something like 300 gigabytes some ridiculous amounts well now the story changes because now if you happen to upload it to the cloud that might take around like five to ten hours and if they're downloading it that might take another five to ten hours but think about this downloading it down to your ssd would just take a couple minutes flying it over to florida would take six hours and then downloading it from the ssd will just take a couple more minutes so now if you have this humongous video it would actually be faster for you to send it over the airplane as ridiculous as it sounds and this is exactly why big o notation is so useful when it comes to code when it comes to functions that you're running big o notation is essentially how long a chunk of code takes to run depending on how big the input is and how does that scale over time so again taking it back to the analogy if i just had a small input or a small video then it would be faster to just send it over the cloud but if i had a huge input or a huge video it would actually be faster to send it over the airplane so when we start to look at code and we look at a chunk of code we want to ask depending on the input if the input grows over time how is this code going to execute over time is it going to take longer and longer like uploading and downloading to the cloud or is it going to stay constant like just sending it over the airplane so this epic analogy allowed me to understand why it is that we want to look at the code and start to see where it will be optimal and where it's going to take longer and how it acts over a long period of time and how it scales with the input but now the second question becomes well how do you actually now keep track of this time how do you actually see how something is going to scale with time well it's very simple this is specifically where the big o notation comes whenever you see the o with the parenthesis and you see some function inside all it is is a representation of how long the chunk of code is going to take over a long period of time so quite simply put if i were to ask you if you were to run a mile on the track how many laps would it be you would tell me four laps if i say 3 miles you would tell me 12 laps so it's just a different way of representing how long something takes and this all comes down to just understanding that the computer is going to take x amount of time whether it's milliseconds or microseconds to execute just one line of code so you could come up with the mathematical equations how long something is going to take now in big ol notation these equations don't have to be perfect but they just have to give a good model of how it's going to act over time guys today's sponsor is hostinger and the reason why we decided to partner up with hostinger is because if you really want to start to generate money and make money as a developer whether it's freelancer or whatever that is you're gonna have to learn how to build websites and that could be for either specific clients that you get as a freelancer or even for yourself if you're trying to build your own portfolio where you could showcase your own projects so what i want to do is i want to get into the website builder to show you how simple quick and easy it is to make websites so once you start going to the web builder you could start to build a website from all these different templates that they have available to you when you get the template and you select it you can now go to the website and it makes it easy to be able to modify anything from the website whether that's just changing the pictures or changing the text so again if you do have a client who's looking for a good website that you're able to get from as a freelancer you can then create fast websites for them and again you can make it super beautiful design is easy to use easy to implement and the websites you'll be creating from this you could definitely charge a lot of money for you can start to build your own online portfolio because when you're submitting job applications or when you're trying to get a next contract you're going to want to show them the work that you've done so by creating an amazing website putting your projects on this website this becomes your portfolio this becomes your way of showing yourself and branding yourself so that you can land that sixfigure developer job so if you want to create a website or host your domains what you could do is click the link below and you're gonna get a special seven percent discount from us just make sure to use the coupon code clever programmer that is one word clever programmer so guys make sure to go check out hostinger so that you can start to build beautiful websites or buy your domains very quickly very easily and very effortlessly so let's go ahead and jump into the code so i could give you a better example so simply put if we just look at this function right here all we want to do is we're looking for an item so we have a for loop that's going to loop through an array or a list and it's going to just find for the specific match that we want whenever matches it returns the specific index when it doesn't match it'll just return negative one because it didn't find the index now what you need to understand is each line of code is gonna take some time for the computer to execute it so the minute the computer starts with the function it's going to take milliseconds for it to execute this line of code and it's going to take another fraction of a millisecond to execute this code and it's going to take another fraction of a millisecond to execute this code so on and so forth so now we can start to see why it's important to look at the input so in this case the input would be the items this would be the list of items what we're noticing is this for loop is going to go through every single item just one time if the list of items is of size 20 that means worst case scenario where there is not a match this is going to loop 20 times so now if the the items is 50 it's gonna loop 50 times the items is 1000 it's gonna loop 1 000 times so we start to notice a trend here as the input grows the time is going to grow or the time that it takes is going to grow in the exact same proportion and this starts to represent a line called big o of n or it's linear where n is just some representation of the input where n is just the size of the input now it could be m it could be x it could be whatever variable you want but just it is standardized to start with n as the initial size of an input so now that that's making sense and we understand that each line of code is going to take a fraction of a millisecond to run and if we have to run it x amount of times because of the size of the input now we can start to graph how long something is going to take over a specific period of time now again i said we don't have to be specific so very often it's gonna boil down to just a few different types of functions that we can get so let's dive into it real quick and let me show you what functions these are now here in front of me i have this amazing graph i think it's amazing because it's color coordinated it's going to help you to see what is an optimal algorithm versus what is not an optimal algorithm before we get into that let's observe and see what some of these lines are so if you remember your ti 89 you could just go into the calculator put y equals x and they'll graph something for you so if you were to graph all these functions you would see a very similar thing so here at the very bottom we have big o of one which is just a constant this is very similar to when you have like your y equals five and you just see a straight line this means this is the most optimal type of algorithm because it doesn't matter how big your input gets right or it doesn't matter how many operations you have it's always going to be instantly whenever you ask for that operation right above that we have log of n log of n would be like if you were to divide something by two every single time very similar to binary search you get somewhere really really quick after that we have big o van which is what we just talked about where depending on how large the input is that's probably going to take the same amount of time because you're just scaling those operations linearly and then we have n login which might be hit up by some sort of sorting algorithms like merge sort where you would multiply n times log in and it would start to grow over time and then we have the gross algorithms that nobody likes which is like n squared 2 to the power of n and n factorial now again the color coordination is going to tell you which are the type of algorithms you want to achieve and you want to go for so if you have an algorithm if you have a way of solving something that takes n squared that's probably a horrible way to go about it right they labeled it here red for horrible so you're going to want to try to improve that at least to end login if you can't improve it to n or log in as far as you can but here's the reality there's going to be some things that just cannot get better than n squared there's going to be something that just can't get better than two to the power of n for example the hanoi towers you could look at that problem and see how that's gonna be something that can't really get any faster so the reason i show you this is because these are the different types of time functions that it's going to boil down to most of the time now the reason i say boil down to most of the time is because depending on the function it's always going to change and what your function actually is but there are several rules that allow you to simplify the function because again we don't want the perfect function we we just want the function that can describe how this algorithm is going to act or how this chunk of code is going to act over a long period of time with the bigger input so i want to get into some of these rules that you're gonna encounter whenever you're really trying to understand how this piece of code is gonna function over a long period of time so as you've seen the code before here we have a simple for loop that is gonna take big o of n time so it's gonna be linear and then here we have another for loop that's gonna take n squared because it's two for loops that are nested so the first thing i want you to realize if i was to ask you what is the run time of both of these put together what you're gonna do is you're going to add all of the different steps so if you have one that's going to take big o of n and you have another one that's going to be n squared you're going to create a function that is called big o of n squared plus n they want to make sure that the more dominant parts of the function are put up front the reason n squared is more dominant than n because if we were to refer back to this chart n squared is going to take a lot longer than n over a long period of time so n literally becomes irrelevant and that's the rule for number three whenever you do have a long function like that you can take off all the nondominant factors here and this big o of n squared plus n is literally equivalent to big o of n it gets simplified to big o of n squared because if we look at this graph if we increase the input the operations are going to be way more with big o of n squared to where this is irrelevant the x operations that you add with big o of n are completely irrelevant when you start thinking 10 000 inputs 100 000 inputs 1 million inputs so the first rule is you want to add the steps the second rule is you want to simplify everything by just leaving the most dominant algorithm or the algorithm that's going to take the most amount of time the third thing you want to do is you want to take off constants because in reality they're not going to matter so let me give you the perfect example if we go back to this function that are labeled as big o of n in reality this would be big o of 2n now the reason is because if the size n is 100 we're gonna see this if statement 100 times but we're also going to hit this for loop 100 times and assuming we never see the match then we're finally gonna return right because if you start to see how something acts over hundreds of thousands of inputs millions of inputs that difference with the coefficient in front of the input variable is literally irrelevant so you want to make sure you drop the constant so if you have big o of 2 n it would just become big o of n if you have big o of 3 n squared it would just become big o of n squared and here in line 24 i have the perfect example even if it was 5n even if it was 500 n it would still become just big o of n because the coefficient or the constant is irrelevant to how it's going to act over a long period of time because it's just the constant now finally the last rule is you have to take into account the inputs if you're bringing in two different inputs then you just can't call them both n because again n is just like a variable and it's just representing a specific input but imagine if we were to go to this one where it's n squared this is n squared because this for loop is iterating through items items is input number one and then this for loop inside is iterating through the same thing which is items which is one so that would be like n times n which is why it's n squared but what if the outside loop was iterating through items and then the inside loop was iterating through a different array well now items would be input n and that would just depend on however long n is if it's a thousand variables n is a thousand if it's ten thousand twenty thousand whatever number that is but then input m or a different variable would be representing of the second array so you would get something like big o of n times m but the reality is is this is very similar to n squared because you depend on two different arrays but the reality is worst case scenario they both get really really big and then it's going to take a long time and it would take the same amount of time as big o of n squared so guys that is a deep dive into big o notation again i just want to remind you big o notation isn't about having the exact formula you can come up with the exact formula you can literally count and estimate every single line of code that is going to be executed depending on the size of your input but the point isn't that the point is just to see how your function how your piece of code is going to act when the input grows over time when it goes from an input of size 10 to 100 to 10 000 to 100 000 to 1 million to 10 million how much longer is your function going to take over specific period of time i hope this was able to start to bring some value and solidify some of these ideas because very often people tend to be a little bit scared of big on notation because yes it has to do a little bit of math but if you start to nail down these skills if you start to practice it if you throw yourself into a bunch of different types of for loops nested for loops and all these crazy things you can start to see a lot of different algorithms you can start to see how fast they act you're gonna start to understand how pieces of code are going to act over a long period of time and it's going to become almost second nature for you to be able to get the time complexity of a specific thing now again the reason the time complexity is super important is because you're probably going to be asked these things in technical interviews for one specific reason because if you can understand how a function will act over time you'll be able to solve the right problem with the right data structure with the right algorithm and you become a problem solver because if you don't know these nuances if you don't know these difference of how a piece of code will act over time then you might implement the wrong solution and that is not good especially if you're trying to become a six figure developer right because someone who gets paid six figures wouldn't be making these kinds of mistakes right someone gets paid six figures will be going through those technical interview questions so if you do want to get on that path of becoming a six figure developer not only that we also have a free training for you go ahead click the link below in this training we're going to teach you exactly how you can become a six figure developer give you the exact road map that you need and you can master front end javascript so that you can start to get the right skills in place and become that six figure developer because it's not just about big o notation you also need to have the skill of developing websites you also need to have the skill of creating beautiful software that solves hard problems to solve in the most optimal way so click the link below watch the training get started and get enrolled with profitable javascript so you can become an amazing master of javascript from development and get those interviews for your dream job as a six figure developer and then with everything that we just talked about today you absolutely crush those interviews so guys that is it for this video i hope you got a lot of value i hope that you now understand what big o notation is and time complexity and how you can use it so that when you go out to those interviews you absolutely crush it if you haven't yet already go ahead smash that like button i don't know what you're doing if you haven't and also make sure to subscribe because i am going to be getting on here i'm be dropping more content more of these tips more of these things that allowed me to land job offers from companies such as blue origin google and microsoft i just want to give you guys everything that i've learned everything in this head i'm trying to transfer you so guys give us a like please make sure to subscribe and hit that bell notification icon so you can get notified the minute we drop these fire videos because i'm gonna create a series on data structures so that you could crush those technical interviews you could become a master javascript developer and land that six figure job all right guys that is it for this video i hope to see in the next one this is coach daniel signing out peace
