With timestamps:

00:00 - in this video you're going to be
00:01 - building Sushi swap in xjs we're gonna
00:04 - be using solidity we're also going to be
00:06 - using infuro to build this app on the
00:09 - ethereum blockchain we're also going to
00:11 - be using rainbow kit to connect our meta
00:13 - mask this is going to be an amazing
00:14 - build let's just get started all right
00:16 - now let's go ahead and get started
00:18 - building these Sushi swap cone so as
00:21 - always we're gonna be using the custom
00:23 - CLI tool that we built for you so just
00:25 - pop in your email name and then just
00:27 - start typing in sushi swap it should
00:29 - show up and hit return on it and then
00:32 - let it do its thing now it will also
00:35 - open up infuria for you so go ahead log
00:37 - in or make an account if you don't have
00:39 - one already and then select web3 API as
00:42 - Network and then just name it Sushi swap
00:44 - or whatever you want to and then in the
00:47 - meantime likely the CLI tool will be
00:49 - done and we'll open the will open vs
00:52 - code for your convenience so it's full
00:54 - screen that and go back to inferior you
00:56 - should be good to go there no need to
00:58 - worry about it so finish setting up your
01:00 - if you're a project and copy or API key
01:03 - and that should be pretty much your
01:05 - first step all right now as your first
01:08 - step we're going to be doing is we're
01:09 - going to be creating a custom token so
01:12 - let's just get started so inside your
01:14 - contract slash custom decks Sol file you
01:19 - can start typing it and just like with
01:22 - any solidity file you will need an spdx
01:24 - license identifier which is going to be
01:26 - MIT and we are going to be working on
01:29 - the 0.8.0 version of solidity so just
01:33 - use that and right the gate we're going
01:35 - to go ahead and import some open
01:37 - Zeppelin contracts and libraries so the
01:40 - first one is going to be the erc20 and
01:43 - we're also going to be importing the
01:45 - safe math Library let's just do that and
01:48 - now we're going to go ahead and actually
01:49 - create the contract the token contract
01:51 - itself so as usual we're going to be
01:54 - building on top of the erc20 library and
01:57 - we're going to have obviously the name
02:00 - and the sale of that talk so let's just
02:03 - build out the contractor with those and
02:05 - then create the minting function so that
02:08 - will be that will look like that you're
02:10 - going to pass in the account and the
02:12 - amount and the amount and that is pretty
02:15 - much it we're just gonna get started
02:17 - with the custom decks in a little bit
02:19 - all right let's build the first step or
02:23 - for the custom decks so we're going to
02:25 - be using safe math in here so let's just
02:28 - import that and now we're gonna do a
02:32 - couple of pre-steps or whatever they
02:34 - they are called so we're gonna go ahead
02:36 - and create an array of strings and we're
02:38 - just gonna put in the names of the coins
02:40 - so you can rename those coins however
02:42 - you want to I'm just going to call it
02:44 - coin ABC and now I'm going to create a
02:47 - mappings later on this is going to be
02:49 - useful so what we're going to be doing
02:51 - is we're going to be mapping the actual
02:53 - ERC instances to these coin names
02:57 - themselves so mapping string to erc20
03:00 - and it's going to be public and then
03:02 - we're just gonna name it token instance
03:03 - map these are going to be the conversion
03:05 - values so one custom coin will cost you
03:10 - 0.0001 East and then one coin will cost
03:13 - you one coin so this is just for later
03:16 - for for reference and the dexis
03:19 - Constructor will will be a for Loop so
03:22 - what we're going to be doing is we're
03:23 - going to Loop through the array that
03:26 - contains the names and it's just gonna
03:27 - basically run the coin instructor itself
03:30 - so basically let's generate a new token
03:34 - for you and then we're gonna be minting
03:36 - a bunch of them into the contract
03:38 - address itself so that's what address
03:40 - dot address this means meaning that all
03:44 - the coins that are going to be minted
03:46 - and this step are going to be minted
03:48 - onto the contract itself so nobody's
03:52 - actual wallet it will be minted onto the
03:54 - contract so the contract will own all
03:57 - the tokens and you just want to put in
03:59 - like a big number like a huge number
04:01 - that's because you don't want to run out
04:03 - while you're testing just put in as big
04:05 - of a number as you can think of and then
04:07 - what we want to do is we want to save
04:10 - this token into the token instance map
04:13 - just so we have access to it later and
04:16 - we can access it so once you're done and
04:18 - your contract looks like this you are
04:21 - pretty much good to go okay now for the
04:24 - next step we're gonna be implementing
04:25 - the get balance function so let's just
04:28 - get started with that and that all have
04:30 - two arguments one of them is going to be
04:31 - token name and the other one is going to
04:34 - be underscore address so basically when
04:38 - you call this function you should pass
04:39 - in coin a and then whatever your own
04:42 - wallet address is so this function will
04:45 - return the balance in the given wallet
04:49 - of the given token so this will be a
04:53 - function that will return a number and
04:56 - so the only thing that we will have to
04:58 - implement is returns token instance map
05:01 - passing the token name and then balance
05:04 - off and then the address
05:06 - so if you let's say if you have five
05:08 - coin a tokens and you're passing coin
05:10 - eight and your own wallet address it
05:12 - should return five
05:14 - so that is pretty much the get balance
05:16 - function all right let's test all the
05:19 - functionality that we implemented so far
05:22 - so first of all what you want to do is
05:25 - start your remix server on your in your
05:28 - vs code this is just a free ethereum
05:31 - remix extension and what you want to do
05:34 - is if you don't have ganache installed
05:36 - go ahead obviously install ganache and
05:39 - spin it up and then just make sure that
05:41 - the ports are matching so that it
05:43 - connects and once you're done with that
05:45 - you can go ahead hit compile and then
05:47 - hit Deploy on your custom decks.sol file
05:51 - and there you go you will have the the
05:53 - instance right there and there will be
05:55 - an issue which which I forgot because
05:58 - when you import from open Zeppelin you
06:01 - should import from contracts as a plural
06:04 - so just go ahead fix that redeploy the
06:06 - contract and then you should be good now
06:08 - once you're in there you will see all
06:10 - these functions that you can call
06:12 - so let's just go ahead and start
06:14 - checking out if we have all the tokens
06:17 - so the first item is going to be coin a
06:19 - coin B coin see those so that works and
06:23 - then now if you want to test out get
06:24 - balance like I said a minute ago you can
06:27 - just pass in coin a and then the address
06:29 - which is in case it's going to be the
06:31 - the contract address itself and you
06:34 - should just get back the initial
06:36 - the initial number of coins that you
06:39 - minted onto the contract so you see
06:41 - those bunch of zeros after a one so that
06:44 - means this functionality is working so
06:47 - with that said let's move on all right
06:49 - now let's make a function that actually
06:51 - Returns the address of the coin so
06:55 - function get token address you will pass
06:58 - in a token name and then it will return
07:00 - an address so what we're going to say is
07:03 - return address token instance map
07:06 - and the token name that's literally all
07:09 - it is now let's go ahead and test it so
07:11 - I'm just going to go ahead redeploy the
07:13 - contract and let's try it out so I'm
07:16 - going to pass in coin a in there and
07:18 - there is your address so that is pretty
07:21 - much this function all right now
07:23 - actually let's start swapping eth to
07:26 - these custom tokens so what you want to
07:28 - do is just create a brand new function
07:30 - and we will be passing in token name
07:33 - because now this is where you're gonna
07:35 - pass in coin a b or c or whatever this
07:38 - is going to be a public payable function
07:40 - that will return a number first of all
07:43 - let's create a variable and let's just
07:46 - store however much eth was sent to the
07:49 - contract so input value equals
07:51 - message.value and now what we're gonna
07:54 - say is output value so basically the
07:57 - amount of coins that we'll be sending
07:59 - back to the user will be calculating
08:01 - that by saying input value.div and this
08:05 - is coming from the safe math things so
08:07 - basically we'll divide the input value
08:09 - with the each value now e value you can
08:13 - just create another variable somewhere
08:15 - outside of this function and then just
08:17 - give it a value totally totally doesn't
08:19 - matter just make sure it's in weight and
08:22 - then we're going to be multiplying that
08:23 - by 10 to the power of the token instance
08:26 - map like how are the decimals we have
08:29 - with the token instance map token name
08:32 - dot decimals so these are all things
08:34 - that are coming from the a safe map so
08:37 - just feel free to pause the video check
08:39 - out what's what it is doing exactly and
08:41 - then continue from there and next up
08:43 - we're going to need to require that we
08:46 - are able to actually send that money so
08:50 - that we have that we have the funds in
08:53 - the contract to send the send back the
08:55 - output value to the user so that's going
08:57 - to be a requirement and then where is
08:59 - going to be returning the output value
09:01 - just so the user knows okay this is
09:03 - actually how much you you can go ahead
09:05 - check your wallet now mind you on line
09:08 - 54 I have a typo in the required so just
09:11 - be mindful of that this test will fail
09:14 - but let's go ahead and compile there you
09:16 - go there's the air so hit compile deploy
09:20 - the contract and let's go ahead and test
09:22 - it out so swap beat the token I'm just
09:24 - going to say coin a and then you have to
09:26 - pass in a value there so I'm just going
09:28 - to say ether point zero zero zero one
09:31 - whatever and I should technically I
09:33 - think be getting one coin a so that
09:36 - should be somewhere there so I'm just
09:38 - gonna paste in my wallet address and
09:41 - there it is that's the amount in way so
09:43 - that's literally one piece all right so
09:46 - with that said now let's go ahead and
09:48 - swap tokens to eth alright so now we're
09:52 - going to be swapping tokens back to eth
09:55 - so let's create that function we're
09:57 - going to be passing a token name and the
10:00 - amount and we're going to be returning
10:02 - the obviously the amount of heat the
10:04 - user will get we're gonna need to do
10:06 - some some conversions here first so
10:09 - we're going to say a un256 exact amount
10:12 - and we're going to be dividing the
10:15 - amount that we're sending to the user or
10:18 - the user sends us so basically the user
10:20 - sends Us in way and we will have to
10:22 - convert it to eth so we're going to be
10:25 - doing that there and now we're going to
10:28 - be saying is to be transferred exact
10:30 - amount multiply by each value so the
10:34 - user sends us their coin in the value of
10:38 - way we have we convert it up to eth and
10:41 - then we're going to be multiplying that
10:43 - with the conversion rate so after this
10:46 - once this is done we're going to need to
10:48 - make sure that we are able to cover that
10:51 - a transaction so the contract has to
10:54 - have enough eth balance otherwise this
10:57 - transaction cannot go through if that is
11:01 - if that requirement is met we will just
11:03 - go ahead and transfer the eth that we
11:06 - need to transfer so that will happen
11:09 - through this we're going to say token
11:11 - instance map token name transfer
11:14 - transfer from from the map from the
11:16 - message sender basically the user we're
11:19 - going to be sending the amount that they
11:21 - are sending to the contract and we're
11:23 - going to be storing it and after that
11:25 - we're gonna and we're gonna be sending
11:28 - the you after that we're going to be
11:30 - sending the eth back to the user so with
11:32 - that said we're just going to return the
11:34 - value and that is pretty much this
11:36 - function now mind you this this function
11:40 - will need to be confirmed by the user
11:42 - we'll collect that on the front so now
11:45 - with that said there is only one thing
11:46 - left to do and that is to create a token
11:49 - swap function all right so the last
11:52 - thing we need to implement here in the
11:54 - contract is actually the token token
11:58 - swap so let's create the function and
12:01 - we're going to have to pass in the
12:02 - source token name and the destination
12:05 - token name so basically which token do
12:07 - you want to convert to which token and
12:09 - then obviously the amount now this will
12:12 - be a public func and we will need to
12:14 - make sure that both the source token and
12:16 - the destination token has enough
12:19 - balance in the contract to cover this
12:22 - transaction so once that is done we are
12:25 - pretty much basically good to go and
12:26 - inside the require function we can just
12:29 - get done the transfer immediately and
12:32 - obviously this will need to be approved
12:35 - by the user which again will be done on
12:38 - the front end so with that said now
12:40 - let's go ahead and deploy this contract
12:43 - okay so go into your truffle config and
12:47 - then whatever is inside your networks
12:49 - just go ahead get rid of it it's not
12:51 - really necessary and once you're done
12:53 - just go into our truffle and connect to
12:55 - a network now we'll as I said earlier
12:58 - we're going to be using infuro connect
13:00 - to infuria and your sushi swap project
13:03 - that we created at the very beginning of
13:05 - this tutorial should already show up so
13:09 - once that's there you click it you're
13:11 - good to go it pretty much connects your
13:13 - vs code to that Sushi swap project and
13:15 - now if you if you start deploying the
13:18 - product by
13:19 - you can just say right click and then
13:22 - hit deploy you just select the sushi
13:24 - swap girly Network and then you should
13:26 - be good to go it will get get started
13:29 - everything for you now we'll take a
13:31 - little bit to deploy but just wait for
13:34 - it and you should be pretty much ready
13:36 - soon and there you go if you see your
13:39 - contract address at the end you are good
13:43 - and the project has been successfully
13:45 - deployed and once you're done deploying
13:48 - we're going to be doing a couple things
13:50 - to get our front end ready for for this
13:53 - project so go into your build slash
13:56 - contracts folder and just copy your
13:59 - custom decks.json file we're going to be
14:01 - using it in a little bit and now go
14:04 - inside your Source folder and just
14:06 - create a new folder called utils and
14:09 - then just paste it in there and now
14:11 - we're going to cut go ahead and copy the
14:13 - custom
14:14 - token.json file and paste that there too
14:17 - we're going to be using that in a little
14:18 - bit this is the Abi this is what will
14:21 - help our front end to interact with the
14:23 - contract now once that is done just go
14:26 - ahead create a new file contract.js and
14:29 - we're going to be importing ether
14:30 - because in this project we're actually
14:32 - using ethers and now you're going to go
14:35 - ahead import custom decks ABI the file
14:38 - we just copied and the custom token API
14:41 - the other file was just copied so we're
14:43 - just going to import both of those
14:45 - and now we're going to create a couple
14:46 - of helper functions that we will be
14:49 - taking advantage of later on so we will
14:51 - need to create two functions one for the
14:53 - token and one for the decks itself so
14:56 - we're going to say export cons token
14:58 - contract it'll be an async function and
15:00 - we'll create a provider ethers provider
15:02 - web3 provider and then we're just going
15:04 - to pass in Windows ethereum don't worry
15:06 - about that part that stuff if you have
15:08 - metamask installed the ethereum object
15:11 - will be immediately injected into every
15:13 - single website you visit and now we're
15:15 - gonna deconstruct ethereum out of window
15:18 - and we're going to be working with that
15:21 - now you will need to create a signer
15:23 - which is going to be provider dot get
15:25 - signer and the provider again two lines
15:28 - above that's where it comes from we're
15:30 - going to also create a contract reader
15:32 - now this is something that is only
15:34 - possible with ethers GS so we're going
15:36 - to say new ethers.contract we're gonna
15:39 - pass in the address that will be created
15:41 - with the text and then we're going to
15:43 - pass in custom token API AI because
15:45 - inside your file there is a bunch of
15:47 - things but we need the ABI so that
15:51 - specific part of the object and we're
15:53 - also going to pass in the signer that
15:55 - will help us later on with all the
15:57 - transactions and we're going to go ahead
16:00 - and return the contract reader now we're
16:03 - going to go ahead and repeat this exact
16:05 - same thing for the Dex contract as well
16:09 - so the only difference that's gonna
16:11 - we're gonna have is we're just gonna
16:14 - hard code the contract address so that
16:17 - comes from your output and now we're
16:20 - gonna pass in the custom decks ABI that
16:22 - API and with designer so with that said
16:26 - we are pretty much good with this part
16:29 - let's move on to the next all right so
16:32 - now we're gonna go ahead and set up two
16:34 - conversion functions so inside utils
16:36 - just create a new file ethers Dash utils
16:39 - JS import ethers and we're going to be
16:42 - creating a two-way and a two eth
16:44 - function these are literally just going
16:46 - to convert as the name says export
16:49 - function to way amount decimals and
16:51 - decimals by default is going to be 18.
16:54 - so you're going to pass in the amount
16:56 - you want to convert to a in ethers and
17:00 - then just use the library so
17:03 - ethers.us.parse units and then it will
17:06 - just do the conversion for you so you
17:08 - don't even have to worry about that and
17:09 - then just return the string version of
17:12 - that number and then this is going to be
17:14 - the exact same thing but the other but
17:17 - in the other direction and instead of
17:18 - Parts units we're going to use the
17:20 - format units method from the ethers
17:24 - Library so that's pretty much that
17:27 - function now let's actually set up the
17:30 - metamask wallet connection as well so
17:32 - I'm just going to spin up the app and
17:34 - let's take a look at it so right now
17:36 - this is how the app looks like and
17:38 - there's your connect wallet button not
17:40 - working so far let's take a look at
17:42 - what's happening so inside of app.js
17:44 - that's all you're Imports and
17:46 - wagmeconfig and everything so as you can
17:49 - see it requires infuro to connect to the
17:53 - blockchain so copy your API key and go
17:56 - back now you want to obviously put it in
17:58 - your EnV file and then that will make
18:01 - rainbow kit work perfectly that's
18:03 - literally the only thing you have to do
18:05 - and now let's just render out the
18:08 - connect wall button and as you can see
18:10 - inside of heather.jsx down at the bottom
18:13 - you can just there's a static connect
18:15 - wallet there so let's just go ahead and
18:18 - replace that with metamask we already
18:21 - pre-built this component for you so you
18:23 - can just use it and that will go ahead
18:26 - and take care of your wallet connection
18:28 - if you and if your wallet address shows
18:31 - up at the top where the button was you
18:33 - are good to go and you can disconnect
18:35 - connect whatever wallets you want to so
18:39 - with that said let's go ahead and
18:40 - implement the conversion functions and
18:44 - we're done let's go ahead and create a
18:46 - new file in the utils folder and this is
18:48 - going to be a queries.js we're going to
18:50 - be importing big number and ethers from
18:52 - ethers and contract and token contract
18:55 - from contracts so this is what we're
18:58 - going to be using by the way to just get
19:00 - the East balance Also let's import to
19:02 - eat from the ether's utils file that we
19:05 - just created so we're going to say
19:07 - export const get balanced this is going
19:08 - to be an async function we're going to
19:10 - pass in the wallet address and the usual
19:13 - trial try catch so if if there's an
19:15 - error let's just console log it and see
19:17 - what's up and then in a try we're going
19:19 - to have a transaction that that's just
19:21 - going to convert the value or whatever
19:24 - amount so we're going to make sure that
19:26 - our wallet is connected meaning the
19:28 - ethers is not undefined after that we're
19:31 - going to go ahead create the provider
19:32 - how we already created multiple times
19:34 - and now we're going to go ahead and get
19:36 - the user's balance so we're going to
19:39 - grab the account so all the accounts
19:42 - that are connected to the app so away
19:44 - provider the list accounts and the
19:47 - user's account is very like the first
19:48 - one that is being connected and that's
19:50 - usually the active one because metamask
19:52 - sorts it like that now next up the
19:55 - balance in way is going to be
19:57 - provider.gap balance and then we're just
20:00 - pass in the user address and now we have
20:02 - to convert that into East so we can use
20:06 - either the two eth function that we
20:08 - created or
20:10 - we can just type it out again and then
20:13 - we're going to be going to returning it
20:15 - however if if you remember this is going
20:17 - to be a big number so later on we'll
20:20 - have to deal with this so let's go back
20:22 - to our index.js and in there we're going
20:25 - to be handling the balance so this is
20:27 - going to be an async function and this
20:30 - is going to be useful later on but
20:31 - basically when you try to swap you will
20:34 - have to select the source in the
20:35 - destination token and so that's what's
20:37 - going to get passed in here so if that
20:39 - if one of the tokens that the user wants
20:42 - to interact with is eth will have to get
20:45 - the each balance of the user and then
20:47 - display it I'll show you show it to you
20:49 - in a little bit so if the first drop
20:51 - down is going to be eth we're gonna need
20:54 - to go ahead and get the balance of that
20:58 - and actually do that let's grab the
21:02 - connected wallet so use account from
21:05 - wagme and then let's just save it so
21:07 - we're just gonna pass it in there and
21:09 - then we're gonna be be setting the first
21:12 - balance to that balance and we're going
21:15 - to convert it to a number and then cut
21:17 - down or I mean like what does it attach
21:20 - to decimals if it's the second drop down
21:23 - that is B that is selected as eth we're
21:26 - gonna get the we're gonna literally just
21:28 - repeat the same exact function but we're
21:31 - going to be saving it in obviously the
21:33 - second balance U state so now what we
21:36 - need to do is pass it into these coin
21:39 - drop downs as you can see we already
21:41 - have it highlighted for you so just find
21:43 - the find those two and then replace the
21:46 - string with the function name itself so
21:49 - just you can remove the apostrophes and
21:51 - then you should be good to go now if you
21:54 - run this app it looks like there is some
21:57 - sort of an error in our contract.js so
22:00 - let's check it out and it looks like
22:02 - that we imported the wrong file so we
22:05 - need to import custom decks.json not
22:07 - custom decks API all right let's see if
22:10 - it it works so I just selected Ethan it
22:13 - doesn't seem like it's working if you
22:15 - see the balance is still zero which is
22:18 - not ideal so let's take a look at what's
22:20 - happening and apparently if we had or
22:23 - apparently when we are selecting
22:25 - anything we are not running the function
22:28 - itself as you can see it's not even like
22:30 - completely white it's like this grayish
22:32 - color which means that vs code is
22:35 - recognizing that we are not calling that
22:37 - function so let's just pass it in there
22:39 - both in the first drop drop drown and
22:41 - then the second drop down as well so
22:44 - with that said now this should work so
22:47 - if I'm selecting it and there you go it
22:50 - updates so as you can see now it shows
22:53 - up as
22:54 - 4.54 eth over there so that looks good
22:59 - let's move on to the next step okay now
23:02 - let's repeat that same process but for
23:04 - the custom token so inside of queries
23:07 - we're going to have another function
23:08 - that will get the custom token balances
23:10 - because we have to handle those
23:12 - differently so we're going to say get
23:13 - token balance and then we're gonna pass
23:15 - in the token name and the wallet address
23:17 - where we're interested in the balance so
23:20 - we will have the contract object
23:23 - which will be coming from the contract
23:25 - file and then we're going to use the get
23:27 - balance function that we actually wrote
23:30 - in the contract and then passing token
23:33 - name and the wallet address after that
23:35 - we're going to go ahead and return the
23:38 - balance and again this is going to be a
23:40 - big number so let's go back to index.js
23:43 - import get token balance from this
23:46 - function or from this and write down at
23:49 - handle ballot let's just add an IFL yeah
23:52 - an a file statement in there let's go
23:55 - into the else statement and another if a
23:58 - statement in there and so if it's the
24:00 - first drop down then we're gonna get it
24:02 - for the first drop down if it's gonna be
24:04 - and set it as the first ballot we're
24:06 - going to be using a different we're
24:08 - going to get the balance using the
24:11 - freshly created function and then
24:13 - because it's coming back in way we'll
24:16 - have to turn it into ethers and then
24:19 - we're going to be set it as the first
24:21 - balance and then we're gonna repeat this
24:24 - same process but for second drop down
24:26 - with second balance now I'm gonna go
24:30 - ahead and cut this out so it's gonna
24:31 - disappear a little bit and then we're
24:33 - gonna may add a try catch function
24:35 - that's that's just good practice to do
24:37 - with blockchain apps so let's test out
24:41 - if it works and it looks like there are
24:44 - some errors that's because the address
24:47 - seems like it's off so that's probably
24:49 - because the use account dot address is
24:53 - how we're gonna get back the address add
24:55 - that there and when we're trying to get
24:57 - it from wag me and now it seems like the
25:01 - ethers package has not been imported so
25:03 - let's do that because that looks like
25:05 - it's going to be useful and as you can
25:08 - see now it works so eth is getting
25:11 - fetched and then we don't have any
25:13 - Bitcoin so it returns zero we don't have
25:15 - any solanos that returns zero as well
25:18 - that looks like it's working now let's
25:22 - work on the swap functionality and we
25:24 - should be good okay so let's actually
25:27 - swap from east to custom token so let's
25:31 - create the function pass in the
25:32 - destination token name and the amount of
25:36 - ethyl one to convert usual try catch and
25:40 - then we're gonna create the transaction
25:42 - value which is we're gonna figure it out
25:45 - by converting the amount from ether to
25:47 - way and then saving it in a object I
25:51 - don't know we're going to create the
25:52 - contract object using the contract
25:54 - function we've already created then
25:56 - we'll get we'll create the data which is
25:58 - going to be await contract objects swap
26:01 - East to token and then pass in token
26:03 - name and the transaction value then that
26:06 - will generate a receipt once we wait for
26:09 - it so let's return that and then this
26:12 - function is essentially done go into
26:15 - back to your index file import this
26:18 - function and now we're going to handle
26:19 - it so handle the whole swap so try catch
26:22 - and and if either of the inputs are
26:26 - empty or if the first input is empty
26:28 - we're just going to return because
26:30 - there's nothing to do then and the
26:32 - transfer coins from value is eth meaning
26:35 - the first value is eth and the second
26:37 - value is not eth we're going to be run
26:40 - this function so we're going to get the
26:42 - receipt from the freshly created
26:44 - function and then we're gonna say
26:47 - transfer coin to backend value and first
26:51 - input these are the these are the
26:54 - arguments we're going to be passing into
26:56 - the function so the first one is going
26:58 - to send the name the second one is going
27:01 - to send the value and there is the
27:04 - function being called and that when you
27:07 - hit that button alright so that should
27:10 - in theory work so I'm just adding
27:13 - numbers but it doesn't work yet now
27:15 - we're going to implement that it
27:17 - automatically calculates how much you
27:19 - will be getting by sending the X amount
27:22 - of eth all right so we're going to say
27:24 - handle output that will return that
27:26 - value so usual try catch and we're going
27:29 - to make sure that the first input is not
27:31 - empty and then we're going to be if the
27:34 - first one the transfer the destination
27:37 - coin is not eth and like we're going to
27:39 - make sure that it is an East to coin
27:41 - transaction and if so we're going to
27:44 - calculate the output value and that will
27:46 - be the we're going to get the first
27:48 - input converted to weight and make sure
27:51 - that we pass in 14 decimal digits and
27:54 - then convert it to eighth and then we're
27:56 - going to convert it to number and add
27:59 - two and no decimal with no decimals and
28:01 - set it as the second input and that
28:04 - should in theory get it all done now
28:07 - we're going to run this same
28:09 - functionality if the values are changed
28:12 - up so if we want to transfer from Custom
28:14 - token to eth otherwise it's literally
28:18 - just the same value so if if it might if
28:20 - it's E3 obviously it's going to be the
28:22 - same value if it's token to token
28:24 - because those their value are equal it's
28:27 - going to be again the same that is good
28:30 - and up there in index we're going to be
28:33 - adding a new use effect that will
28:34 - basically just update the pen the output
28:38 - value every time either we change one of
28:42 - the drop downs or the input input boxes
28:45 - so let's test it out and it looks like
28:47 - that two-way is not defined in index.js
28:50 - so let's go ahead and import it
28:51 - apparently we forgot it and now let's
28:55 - just put in random values let's see if
28:57 - it works and it looks like it's it's
28:59 - looking so if we try to trade it looks
29:03 - like two ways again not being defined so
29:07 - apparently we have to import it into a
29:09 - queries.js as well and now it looks like
29:12 - the conversion from eth to custom token
29:15 - is working perfectly so with that said
29:17 - let's move on to converting back okay so
29:22 - before we are able able to swap back to
29:24 - eth or between tokens we'll need to add
29:27 - something called an allowance and that
29:29 - basically just allows you allows the app
29:32 - to do these sort of transactions so in
29:36 - our queries we're going to need to check
29:37 - for this allowance so we're going to
29:39 - create a function for that and we're
29:41 - going to pass in owner token name and
29:42 - amount usual try catch and then usual
29:45 - contact object get the address of the
29:48 - contract or the token so contract not
29:50 - mentioned get token address pass in
29:52 - token name and we're going to create a
29:54 - contract token contract object it's just
29:57 - the usual drill and for the transaction
29:59 - data we're going to be saying that token
30:02 - contract object allowance passing owner
30:05 - and the contract address and we're going
30:07 - to save the allowance and we're going to
30:10 - generate a big number from the data
30:12 - that's being returned we're going to
30:15 - convert that to way and then we're going
30:17 - to check if it's zero or below the the
30:21 - requirement require
30:23 - required amount if yes then we're going
30:26 - to return false otherwise we're going to
30:28 - return true and now we're going to
30:30 - import that has valid allowance function
30:33 - into our index and in our handle swap
30:36 - we're going to create an else statement
30:38 - and we're going to check if we have
30:42 - allowance for for the transaction to go
30:45 - and by passing in the current account
30:47 - and the with as the owner transfer coin
30:50 - from as in the like the token name and
30:52 - then the value if it returns true then
30:55 - we're good and we can go ahead execute
30:57 - the transaction otherwise we're gonna
30:59 - we're gonna have to just console off no
31:01 - user allowance for now and then in a
31:04 - little bit we're going to increase the
31:05 - allowance so let's see what do we got
31:08 - apparently we wrote that decimal value
31:11 - to the wrong place so let's fix that
31:13 - real quick all right let's see what we
31:15 - got and now it shows that there is no
31:17 - user allowance so that's good because we
31:20 - never increased the allowance so that's
31:22 - how it's supposed to all right now go
31:23 - back to your queries and now we're gonna
31:26 - actually increase the allowance so let's
31:28 - create a function for that and usual try
31:31 - catch pass in token name and the amount
31:33 - and we're going to say contract object
31:35 - in the usual drill import everything
31:37 - create all the objects and instances so
31:40 - we're gonna have the contract object
31:41 - address and then token contract object
31:44 - and then with data we're going to
31:46 - generate the usual stuff so now the
31:50 - transaction data will be generated by
31:54 - calling tokencontract object dot approve
31:57 - pass in the contract address and then
32:00 - the amount in way so now it looks like
32:03 - it's still not running that's because we
32:05 - haven't called it so we will have to
32:07 - import it in our index and where we
32:11 - console like no user allowance we're
32:13 - going to have to call that function that
32:15 - we just created cost receipt equals
32:17 - weight increase allowance pass in the
32:20 - token name and the value and now let's
32:23 - console log what happens and there you
32:25 - go now we have to confirm that we want
32:28 - to increase the allowance and we should
32:30 - be good to go moving forward with
32:33 - converting tokens okay so the last two
32:37 - steps are swapping tokens to eth and
32:40 - then token to token they are going to be
32:43 - very similar so we're just going to
32:44 - blast through these and we're going to
32:46 - be done in a matter of minutes okay
32:49 - so in our aquarius.js we're going to be
32:52 - creating two functions the first one is
32:54 - going to be swept token swap token eth
32:57 - async function we're going to pass in
32:59 - which token do we want to and how much
33:02 - of it do we want to usual try catch and
33:05 - then just create all your objects
33:08 - generate the data however the
33:10 - transaction data is going to be using
33:12 - the swap token to eth function from the
33:14 - contract and then pass in required
33:16 - arguments a token name and the amount in
33:19 - way generating the receipt and we're
33:22 - going to return that receipt we're going
33:25 - to import this function in our index.js
33:28 - and if the user has sufficient allowance
33:31 - where we already wrote the if statement
33:33 - we're going to be calling this so let's
33:35 - remove that console log and we're going
33:38 - to be just saying conspiracy then we're
33:40 - going to save that in a variable or a
33:42 - constant and then passing the required
33:45 - arguments the name and the amount and we
33:48 - also want to run in again once we
33:51 - increase the allowance so there are two
33:53 - scenarios one the allowance is already
33:56 - there we just want to run the
33:57 - transaction otherwise we want to
34:00 - increase the allowance and then run the
34:02 - transaction so the user doesn't have to
34:04 - keep click so that looks good let's go
34:06 - ahead test it out there you go I'm
34:08 - increasing the allowance now and now the
34:12 - swap is going through so that looks
34:14 - amazing now let's go ahead and actually
34:18 - implementing the Tony token swap so for
34:21 - that we're gonna have a very similar
34:23 - function in the queries.js usual stuff
34:26 - now the slight difference is that we are
34:28 - going to have a source token and a
34:30 - destination token so we need three
34:32 - arguments instead of two we're going to
34:34 - generate the usual contract object and
34:37 - then this is going to be a swap token
34:39 - the token method that we're going to be
34:41 - calling we're gonna need to pass in both
34:43 - the source destination token and the
34:45 - amount obviously and we will generate
34:48 - the transaction receipt based on that
34:50 - and return that now we're going to be
34:52 - importing that in our index file and so
34:57 - far we only have two types of
35:00 - transactions one is when it is being
35:03 - converted to not eth and everything else
35:05 - but that's not the reality so let's add
35:08 - another if statement in after the so the
35:12 - second type of transaction that we are
35:14 - handling is the not East to eth type of
35:17 - transactions and and now we're we just
35:20 - implemented the token to token so the
35:22 - custom erc20 token to custom erc20 token
35:26 - type of transactions so we're going to
35:28 - be doing the exact same thing so we're
35:30 - gonna check for a valid allowance based
35:33 - on the required arguments and then if we
35:36 - have enough allowance then we're going
35:38 - to run the function otherwise we're
35:40 - going to increase the allowance and that
35:44 - is basically the application so once
35:46 - again let's just test it out let's just
35:48 - see if everything works we're going to
35:51 - go from a custom token to another custom
35:53 - token we're going to go through the
35:56 - whole transaction flow so now the token
35:59 - spend is approved and now we're going to
36:01 - just reject it because it showed up as a
36:04 - duplicate so we're gonna go ahead
36:06 - confirm it and now the transaction is
36:09 - going through that conversion is working
36:12 - so with that said thank you so much guys
36:14 - for following along this was an amazing
36:16 - build and with that I'll see you the
36:19 - next one peace

Cleaned transcript:

in this video you're going to be building Sushi swap in xjs we're gonna be using solidity we're also going to be using infuro to build this app on the ethereum blockchain we're also going to be using rainbow kit to connect our meta mask this is going to be an amazing build let's just get started all right now let's go ahead and get started building these Sushi swap cone so as always we're gonna be using the custom CLI tool that we built for you so just pop in your email name and then just start typing in sushi swap it should show up and hit return on it and then let it do its thing now it will also open up infuria for you so go ahead log in or make an account if you don't have one already and then select web3 API as Network and then just name it Sushi swap or whatever you want to and then in the meantime likely the CLI tool will be done and we'll open the will open vs code for your convenience so it's full screen that and go back to inferior you should be good to go there no need to worry about it so finish setting up your if you're a project and copy or API key and that should be pretty much your first step all right now as your first step we're going to be doing is we're going to be creating a custom token so let's just get started so inside your contract slash custom decks Sol file you can start typing it and just like with any solidity file you will need an spdx license identifier which is going to be MIT and we are going to be working on the 0.8.0 version of solidity so just use that and right the gate we're going to go ahead and import some open Zeppelin contracts and libraries so the first one is going to be the erc20 and we're also going to be importing the safe math Library let's just do that and now we're going to go ahead and actually create the contract the token contract itself so as usual we're going to be building on top of the erc20 library and we're going to have obviously the name and the sale of that talk so let's just build out the contractor with those and then create the minting function so that will be that will look like that you're going to pass in the account and the amount and the amount and that is pretty much it we're just gonna get started with the custom decks in a little bit all right let's build the first step or for the custom decks so we're going to be using safe math in here so let's just import that and now we're gonna do a couple of presteps or whatever they they are called so we're gonna go ahead and create an array of strings and we're just gonna put in the names of the coins so you can rename those coins however you want to I'm just going to call it coin ABC and now I'm going to create a mappings later on this is going to be useful so what we're going to be doing is we're going to be mapping the actual ERC instances to these coin names themselves so mapping string to erc20 and it's going to be public and then we're just gonna name it token instance map these are going to be the conversion values so one custom coin will cost you 0.0001 East and then one coin will cost you one coin so this is just for later for for reference and the dexis Constructor will will be a for Loop so what we're going to be doing is we're going to Loop through the array that contains the names and it's just gonna basically run the coin instructor itself so basically let's generate a new token for you and then we're gonna be minting a bunch of them into the contract address itself so that's what address dot address this means meaning that all the coins that are going to be minted and this step are going to be minted onto the contract itself so nobody's actual wallet it will be minted onto the contract so the contract will own all the tokens and you just want to put in like a big number like a huge number that's because you don't want to run out while you're testing just put in as big of a number as you can think of and then what we want to do is we want to save this token into the token instance map just so we have access to it later and we can access it so once you're done and your contract looks like this you are pretty much good to go okay now for the next step we're gonna be implementing the get balance function so let's just get started with that and that all have two arguments one of them is going to be token name and the other one is going to be underscore address so basically when you call this function you should pass in coin a and then whatever your own wallet address is so this function will return the balance in the given wallet of the given token so this will be a function that will return a number and so the only thing that we will have to implement is returns token instance map passing the token name and then balance off and then the address so if you let's say if you have five coin a tokens and you're passing coin eight and your own wallet address it should return five so that is pretty much the get balance function all right let's test all the functionality that we implemented so far so first of all what you want to do is start your remix server on your in your vs code this is just a free ethereum remix extension and what you want to do is if you don't have ganache installed go ahead obviously install ganache and spin it up and then just make sure that the ports are matching so that it connects and once you're done with that you can go ahead hit compile and then hit Deploy on your custom decks.sol file and there you go you will have the the instance right there and there will be an issue which which I forgot because when you import from open Zeppelin you should import from contracts as a plural so just go ahead fix that redeploy the contract and then you should be good now once you're in there you will see all these functions that you can call so let's just go ahead and start checking out if we have all the tokens so the first item is going to be coin a coin B coin see those so that works and then now if you want to test out get balance like I said a minute ago you can just pass in coin a and then the address which is in case it's going to be the the contract address itself and you should just get back the initial the initial number of coins that you minted onto the contract so you see those bunch of zeros after a one so that means this functionality is working so with that said let's move on all right now let's make a function that actually Returns the address of the coin so function get token address you will pass in a token name and then it will return an address so what we're going to say is return address token instance map and the token name that's literally all it is now let's go ahead and test it so I'm just going to go ahead redeploy the contract and let's try it out so I'm going to pass in coin a in there and there is your address so that is pretty much this function all right now actually let's start swapping eth to these custom tokens so what you want to do is just create a brand new function and we will be passing in token name because now this is where you're gonna pass in coin a b or c or whatever this is going to be a public payable function that will return a number first of all let's create a variable and let's just store however much eth was sent to the contract so input value equals message.value and now what we're gonna say is output value so basically the amount of coins that we'll be sending back to the user will be calculating that by saying input value.div and this is coming from the safe math things so basically we'll divide the input value with the each value now e value you can just create another variable somewhere outside of this function and then just give it a value totally totally doesn't matter just make sure it's in weight and then we're going to be multiplying that by 10 to the power of the token instance map like how are the decimals we have with the token instance map token name dot decimals so these are all things that are coming from the a safe map so just feel free to pause the video check out what's what it is doing exactly and then continue from there and next up we're going to need to require that we are able to actually send that money so that we have that we have the funds in the contract to send the send back the output value to the user so that's going to be a requirement and then where is going to be returning the output value just so the user knows okay this is actually how much you you can go ahead check your wallet now mind you on line 54 I have a typo in the required so just be mindful of that this test will fail but let's go ahead and compile there you go there's the air so hit compile deploy the contract and let's go ahead and test it out so swap beat the token I'm just going to say coin a and then you have to pass in a value there so I'm just going to say ether point zero zero zero one whatever and I should technically I think be getting one coin a so that should be somewhere there so I'm just gonna paste in my wallet address and there it is that's the amount in way so that's literally one piece all right so with that said now let's go ahead and swap tokens to eth alright so now we're going to be swapping tokens back to eth so let's create that function we're going to be passing a token name and the amount and we're going to be returning the obviously the amount of heat the user will get we're gonna need to do some some conversions here first so we're going to say a un256 exact amount and we're going to be dividing the amount that we're sending to the user or the user sends us so basically the user sends Us in way and we will have to convert it to eth so we're going to be doing that there and now we're going to be saying is to be transferred exact amount multiply by each value so the user sends us their coin in the value of way we have we convert it up to eth and then we're going to be multiplying that with the conversion rate so after this once this is done we're going to need to make sure that we are able to cover that a transaction so the contract has to have enough eth balance otherwise this transaction cannot go through if that is if that requirement is met we will just go ahead and transfer the eth that we need to transfer so that will happen through this we're going to say token instance map token name transfer transfer from from the map from the message sender basically the user we're going to be sending the amount that they are sending to the contract and we're going to be storing it and after that we're gonna and we're gonna be sending the you after that we're going to be sending the eth back to the user so with that said we're just going to return the value and that is pretty much this function now mind you this this function will need to be confirmed by the user we'll collect that on the front so now with that said there is only one thing left to do and that is to create a token swap function all right so the last thing we need to implement here in the contract is actually the token token swap so let's create the function and we're going to have to pass in the source token name and the destination token name so basically which token do you want to convert to which token and then obviously the amount now this will be a public func and we will need to make sure that both the source token and the destination token has enough balance in the contract to cover this transaction so once that is done we are pretty much basically good to go and inside the require function we can just get done the transfer immediately and obviously this will need to be approved by the user which again will be done on the front end so with that said now let's go ahead and deploy this contract okay so go into your truffle config and then whatever is inside your networks just go ahead get rid of it it's not really necessary and once you're done just go into our truffle and connect to a network now we'll as I said earlier we're going to be using infuro connect to infuria and your sushi swap project that we created at the very beginning of this tutorial should already show up so once that's there you click it you're good to go it pretty much connects your vs code to that Sushi swap project and now if you if you start deploying the product by you can just say right click and then hit deploy you just select the sushi swap girly Network and then you should be good to go it will get get started everything for you now we'll take a little bit to deploy but just wait for it and you should be pretty much ready soon and there you go if you see your contract address at the end you are good and the project has been successfully deployed and once you're done deploying we're going to be doing a couple things to get our front end ready for for this project so go into your build slash contracts folder and just copy your custom decks.json file we're going to be using it in a little bit and now go inside your Source folder and just create a new folder called utils and then just paste it in there and now we're going to cut go ahead and copy the custom token.json file and paste that there too we're going to be using that in a little bit this is the Abi this is what will help our front end to interact with the contract now once that is done just go ahead create a new file contract.js and we're going to be importing ether because in this project we're actually using ethers and now you're going to go ahead import custom decks ABI the file we just copied and the custom token API the other file was just copied so we're just going to import both of those and now we're going to create a couple of helper functions that we will be taking advantage of later on so we will need to create two functions one for the token and one for the decks itself so we're going to say export cons token contract it'll be an async function and we'll create a provider ethers provider web3 provider and then we're just going to pass in Windows ethereum don't worry about that part that stuff if you have metamask installed the ethereum object will be immediately injected into every single website you visit and now we're gonna deconstruct ethereum out of window and we're going to be working with that now you will need to create a signer which is going to be provider dot get signer and the provider again two lines above that's where it comes from we're going to also create a contract reader now this is something that is only possible with ethers GS so we're going to say new ethers.contract we're gonna pass in the address that will be created with the text and then we're going to pass in custom token API AI because inside your file there is a bunch of things but we need the ABI so that specific part of the object and we're also going to pass in the signer that will help us later on with all the transactions and we're going to go ahead and return the contract reader now we're going to go ahead and repeat this exact same thing for the Dex contract as well so the only difference that's gonna we're gonna have is we're just gonna hard code the contract address so that comes from your output and now we're gonna pass in the custom decks ABI that API and with designer so with that said we are pretty much good with this part let's move on to the next all right so now we're gonna go ahead and set up two conversion functions so inside utils just create a new file ethers Dash utils JS import ethers and we're going to be creating a twoway and a two eth function these are literally just going to convert as the name says export function to way amount decimals and decimals by default is going to be 18. so you're going to pass in the amount you want to convert to a in ethers and then just use the library so ethers.us.parse units and then it will just do the conversion for you so you don't even have to worry about that and then just return the string version of that number and then this is going to be the exact same thing but the other but in the other direction and instead of Parts units we're going to use the format units method from the ethers Library so that's pretty much that function now let's actually set up the metamask wallet connection as well so I'm just going to spin up the app and let's take a look at it so right now this is how the app looks like and there's your connect wallet button not working so far let's take a look at what's happening so inside of app.js that's all you're Imports and wagmeconfig and everything so as you can see it requires infuro to connect to the blockchain so copy your API key and go back now you want to obviously put it in your EnV file and then that will make rainbow kit work perfectly that's literally the only thing you have to do and now let's just render out the connect wall button and as you can see inside of heather.jsx down at the bottom you can just there's a static connect wallet there so let's just go ahead and replace that with metamask we already prebuilt this component for you so you can just use it and that will go ahead and take care of your wallet connection if you and if your wallet address shows up at the top where the button was you are good to go and you can disconnect connect whatever wallets you want to so with that said let's go ahead and implement the conversion functions and we're done let's go ahead and create a new file in the utils folder and this is going to be a queries.js we're going to be importing big number and ethers from ethers and contract and token contract from contracts so this is what we're going to be using by the way to just get the East balance Also let's import to eat from the ether's utils file that we just created so we're going to say export const get balanced this is going to be an async function we're going to pass in the wallet address and the usual trial try catch so if if there's an error let's just console log it and see what's up and then in a try we're going to have a transaction that that's just going to convert the value or whatever amount so we're going to make sure that our wallet is connected meaning the ethers is not undefined after that we're going to go ahead create the provider how we already created multiple times and now we're going to go ahead and get the user's balance so we're going to grab the account so all the accounts that are connected to the app so away provider the list accounts and the user's account is very like the first one that is being connected and that's usually the active one because metamask sorts it like that now next up the balance in way is going to be provider.gap balance and then we're just pass in the user address and now we have to convert that into East so we can use either the two eth function that we created or we can just type it out again and then we're going to be going to returning it however if if you remember this is going to be a big number so later on we'll have to deal with this so let's go back to our index.js and in there we're going to be handling the balance so this is going to be an async function and this is going to be useful later on but basically when you try to swap you will have to select the source in the destination token and so that's what's going to get passed in here so if that if one of the tokens that the user wants to interact with is eth will have to get the each balance of the user and then display it I'll show you show it to you in a little bit so if the first drop down is going to be eth we're gonna need to go ahead and get the balance of that and actually do that let's grab the connected wallet so use account from wagme and then let's just save it so we're just gonna pass it in there and then we're gonna be be setting the first balance to that balance and we're going to convert it to a number and then cut down or I mean like what does it attach to decimals if it's the second drop down that is B that is selected as eth we're gonna get the we're gonna literally just repeat the same exact function but we're going to be saving it in obviously the second balance U state so now what we need to do is pass it into these coin drop downs as you can see we already have it highlighted for you so just find the find those two and then replace the string with the function name itself so just you can remove the apostrophes and then you should be good to go now if you run this app it looks like there is some sort of an error in our contract.js so let's check it out and it looks like that we imported the wrong file so we need to import custom decks.json not custom decks API all right let's see if it it works so I just selected Ethan it doesn't seem like it's working if you see the balance is still zero which is not ideal so let's take a look at what's happening and apparently if we had or apparently when we are selecting anything we are not running the function itself as you can see it's not even like completely white it's like this grayish color which means that vs code is recognizing that we are not calling that function so let's just pass it in there both in the first drop drop drown and then the second drop down as well so with that said now this should work so if I'm selecting it and there you go it updates so as you can see now it shows up as 4.54 eth over there so that looks good let's move on to the next step okay now let's repeat that same process but for the custom token so inside of queries we're going to have another function that will get the custom token balances because we have to handle those differently so we're going to say get token balance and then we're gonna pass in the token name and the wallet address where we're interested in the balance so we will have the contract object which will be coming from the contract file and then we're going to use the get balance function that we actually wrote in the contract and then passing token name and the wallet address after that we're going to go ahead and return the balance and again this is going to be a big number so let's go back to index.js import get token balance from this function or from this and write down at handle ballot let's just add an IFL yeah an a file statement in there let's go into the else statement and another if a statement in there and so if it's the first drop down then we're gonna get it for the first drop down if it's gonna be and set it as the first ballot we're going to be using a different we're going to get the balance using the freshly created function and then because it's coming back in way we'll have to turn it into ethers and then we're going to be set it as the first balance and then we're gonna repeat this same process but for second drop down with second balance now I'm gonna go ahead and cut this out so it's gonna disappear a little bit and then we're gonna may add a try catch function that's that's just good practice to do with blockchain apps so let's test out if it works and it looks like there are some errors that's because the address seems like it's off so that's probably because the use account dot address is how we're gonna get back the address add that there and when we're trying to get it from wag me and now it seems like the ethers package has not been imported so let's do that because that looks like it's going to be useful and as you can see now it works so eth is getting fetched and then we don't have any Bitcoin so it returns zero we don't have any solanos that returns zero as well that looks like it's working now let's work on the swap functionality and we should be good okay so let's actually swap from east to custom token so let's create the function pass in the destination token name and the amount of ethyl one to convert usual try catch and then we're gonna create the transaction value which is we're gonna figure it out by converting the amount from ether to way and then saving it in a object I don't know we're going to create the contract object using the contract function we've already created then we'll get we'll create the data which is going to be await contract objects swap East to token and then pass in token name and the transaction value then that will generate a receipt once we wait for it so let's return that and then this function is essentially done go into back to your index file import this function and now we're going to handle it so handle the whole swap so try catch and and if either of the inputs are empty or if the first input is empty we're just going to return because there's nothing to do then and the transfer coins from value is eth meaning the first value is eth and the second value is not eth we're going to be run this function so we're going to get the receipt from the freshly created function and then we're gonna say transfer coin to backend value and first input these are the these are the arguments we're going to be passing into the function so the first one is going to send the name the second one is going to send the value and there is the function being called and that when you hit that button alright so that should in theory work so I'm just adding numbers but it doesn't work yet now we're going to implement that it automatically calculates how much you will be getting by sending the X amount of eth all right so we're going to say handle output that will return that value so usual try catch and we're going to make sure that the first input is not empty and then we're going to be if the first one the transfer the destination coin is not eth and like we're going to make sure that it is an East to coin transaction and if so we're going to calculate the output value and that will be the we're going to get the first input converted to weight and make sure that we pass in 14 decimal digits and then convert it to eighth and then we're going to convert it to number and add two and no decimal with no decimals and set it as the second input and that should in theory get it all done now we're going to run this same functionality if the values are changed up so if we want to transfer from Custom token to eth otherwise it's literally just the same value so if if it might if it's E3 obviously it's going to be the same value if it's token to token because those their value are equal it's going to be again the same that is good and up there in index we're going to be adding a new use effect that will basically just update the pen the output value every time either we change one of the drop downs or the input input boxes so let's test it out and it looks like that twoway is not defined in index.js so let's go ahead and import it apparently we forgot it and now let's just put in random values let's see if it works and it looks like it's it's looking so if we try to trade it looks like two ways again not being defined so apparently we have to import it into a queries.js as well and now it looks like the conversion from eth to custom token is working perfectly so with that said let's move on to converting back okay so before we are able able to swap back to eth or between tokens we'll need to add something called an allowance and that basically just allows you allows the app to do these sort of transactions so in our queries we're going to need to check for this allowance so we're going to create a function for that and we're going to pass in owner token name and amount usual try catch and then usual contact object get the address of the contract or the token so contract not mentioned get token address pass in token name and we're going to create a contract token contract object it's just the usual drill and for the transaction data we're going to be saying that token contract object allowance passing owner and the contract address and we're going to save the allowance and we're going to generate a big number from the data that's being returned we're going to convert that to way and then we're going to check if it's zero or below the the requirement require required amount if yes then we're going to return false otherwise we're going to return true and now we're going to import that has valid allowance function into our index and in our handle swap we're going to create an else statement and we're going to check if we have allowance for for the transaction to go and by passing in the current account and the with as the owner transfer coin from as in the like the token name and then the value if it returns true then we're good and we can go ahead execute the transaction otherwise we're gonna we're gonna have to just console off no user allowance for now and then in a little bit we're going to increase the allowance so let's see what do we got apparently we wrote that decimal value to the wrong place so let's fix that real quick all right let's see what we got and now it shows that there is no user allowance so that's good because we never increased the allowance so that's how it's supposed to all right now go back to your queries and now we're gonna actually increase the allowance so let's create a function for that and usual try catch pass in token name and the amount and we're going to say contract object in the usual drill import everything create all the objects and instances so we're gonna have the contract object address and then token contract object and then with data we're going to generate the usual stuff so now the transaction data will be generated by calling tokencontract object dot approve pass in the contract address and then the amount in way so now it looks like it's still not running that's because we haven't called it so we will have to import it in our index and where we console like no user allowance we're going to have to call that function that we just created cost receipt equals weight increase allowance pass in the token name and the value and now let's console log what happens and there you go now we have to confirm that we want to increase the allowance and we should be good to go moving forward with converting tokens okay so the last two steps are swapping tokens to eth and then token to token they are going to be very similar so we're just going to blast through these and we're going to be done in a matter of minutes okay so in our aquarius.js we're going to be creating two functions the first one is going to be swept token swap token eth async function we're going to pass in which token do we want to and how much of it do we want to usual try catch and then just create all your objects generate the data however the transaction data is going to be using the swap token to eth function from the contract and then pass in required arguments a token name and the amount in way generating the receipt and we're going to return that receipt we're going to import this function in our index.js and if the user has sufficient allowance where we already wrote the if statement we're going to be calling this so let's remove that console log and we're going to be just saying conspiracy then we're going to save that in a variable or a constant and then passing the required arguments the name and the amount and we also want to run in again once we increase the allowance so there are two scenarios one the allowance is already there we just want to run the transaction otherwise we want to increase the allowance and then run the transaction so the user doesn't have to keep click so that looks good let's go ahead test it out there you go I'm increasing the allowance now and now the swap is going through so that looks amazing now let's go ahead and actually implementing the Tony token swap so for that we're gonna have a very similar function in the queries.js usual stuff now the slight difference is that we are going to have a source token and a destination token so we need three arguments instead of two we're going to generate the usual contract object and then this is going to be a swap token the token method that we're going to be calling we're gonna need to pass in both the source destination token and the amount obviously and we will generate the transaction receipt based on that and return that now we're going to be importing that in our index file and so far we only have two types of transactions one is when it is being converted to not eth and everything else but that's not the reality so let's add another if statement in after the so the second type of transaction that we are handling is the not East to eth type of transactions and and now we're we just implemented the token to token so the custom erc20 token to custom erc20 token type of transactions so we're going to be doing the exact same thing so we're gonna check for a valid allowance based on the required arguments and then if we have enough allowance then we're going to run the function otherwise we're going to increase the allowance and that is basically the application so once again let's just test it out let's just see if everything works we're going to go from a custom token to another custom token we're going to go through the whole transaction flow so now the token spend is approved and now we're going to just reject it because it showed up as a duplicate so we're gonna go ahead confirm it and now the transaction is going through that conversion is working so with that said thank you so much guys for following along this was an amazing build and with that I'll see you the next one peace
