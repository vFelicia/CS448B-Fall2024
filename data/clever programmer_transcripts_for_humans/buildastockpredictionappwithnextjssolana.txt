With timestamps:

00:00 - in this video we are going to be making
00:01 - stock prediction dap with an xjs I'll be
00:04 - showing you guys how to utilize
00:05 - something called the pith network if you
00:07 - don't know what the pith network is it
00:09 - delivers real-time on-chain Market data
00:11 - to the Solana blockchain you'll learn
00:13 - how to utilize this Oracle in your
00:15 - Solana smart contract to get real-time
00:17 - data on stocks like AMC Amazon Google
00:20 - and even crypto if you like as a bonus
00:22 - I'll show you guys how to make price
00:23 - predictions on these stocks so that you
00:25 - can bet money and win big and get some
00:28 - soul of course I'll also teach you how
00:29 - to connect your wallet to this app using
00:31 - Phantom wallet and also how to get your
00:34 - funding connected to your Solana program
00:36 - so without further Ado let's get started
00:38 - alright so here's the app in its full
00:40 - entirety with all the functionality
00:42 - working I have it open up twice because
00:44 - this needs two players so that means
00:46 - when you deploy this app you can have
00:48 - any of your friends or somebody else
00:50 - play against you to bet on the stocks of
00:52 - this app so as you can see 3w is player
00:55 - two 4A is going to be player one so and
00:58 - you have a couple options there's
01:00 - Bitcoin Amazon Google right so let's
01:03 - work with AMC for now and what we want
01:05 - to do is put a prediction out there so
01:08 - the current stock price is four so let's
01:10 - do something simple I want to make
01:12 - player one the winner so we're going to
01:13 - do four it's gonna be four dollars and
01:16 - two minutes essentially and I'll even
01:18 - bet two Solana for this so I hit submit
01:21 - and you can see when you approve the
01:23 - transaction it says send to Seoul so
01:25 - when I hit approve it's going to send it
01:27 - to a third-party account it's an escrow
01:29 - so when the BET's finished it's going to
01:31 - distribute it to the winner whether
01:33 - that's player one or player two
01:35 - let's hit approve and after a second you
01:38 - should see approved bet
01:41 - or failed to approve it and there you go
01:43 - created the BET and it should load we
01:45 - can go to player two and you can see the
01:48 - BET once it loads and there it is so
01:50 - let's enter this and I'll say eight
01:52 - dollars in two minutes
01:54 - it should be wrong and it's going to
01:55 - send two Soul as well because that is
01:58 - the uh pot amount to enter right so the
02:02 - player one always sets the pot amount so
02:04 - as you can see the total pot amount is
02:06 - four to the winner and now we can hit
02:09 - claim so if I go here this should update
02:12 - to claim and in just a second so now
02:14 - it's claim and after the two minutes is
02:16 - up we can go ahead and claim the BET and
02:19 - the cool thing is that no matter who is
02:22 - the winner you can still claim it so
02:23 - let's say player two lost you can still
02:26 - hit claim but the money will still go to
02:29 - the right person player a okay and let's
02:32 - set up in the logic which I'll show you
02:34 - later in the video so I'm gonna wait
02:36 - till the time is up and we can hit
02:37 - Clinton
02:38 - alrighty so I think enough time has
02:40 - passed so let's go to player a and claim
02:42 - the bet
02:43 - hey see that we received four Soul
02:46 - because that means Solana determined
02:48 - that we won and our prediction was
02:49 - closer to the actual price so let's hit
02:52 - proof
02:53 - claim bet and now you should see the
02:56 - state update so player A1 as well player
02:59 - a is on a win streak he's killing it he
03:00 - knows all the right answers so if you
03:02 - look now we have five cylinder when I
03:04 - just had three earlier and if he goes to
03:06 - player B
03:08 - if you look at his
03:10 - uh right here he should have
03:14 - two Soul right he had four now he has
03:16 - two there you go that is the demo so if
03:18 - you want to learn how to build this
03:19 - let's just Dive Right In All right so
03:21 - you're probably wondering how do I get
03:22 - started Lance well you could copy what I
03:24 - do as I get started but we have front
03:26 - end for you guys and all you have to do
03:27 - is use our CLI tool to get it so let's
03:30 - do command J and make sure you see the
03:32 - into a folder where you put your
03:34 - projects I put mine here so that's fine
03:35 - so all you guys have to write is npx
03:38 - cleverprogrammer at latest you'll get
03:41 - all the modules all the front end that
03:43 - you need and have access to every single
03:45 - build in our YouTube channel within the
03:47 - last year and from there you could copy
03:50 - and change these projects and add it to
03:52 - your own portfolio or follow along on
03:54 - YouTube so let's do npx clever
03:56 - programmer latest
03:59 - be sure to build this project with me
04:02 - and try to do it on your own as well so
04:04 - that you have a deep understanding of it
04:06 - so all you have to do to get access to
04:08 - everything is just type in your email
04:09 - address like so
04:11 - type in your name and ba or bam I said
04:15 - bot but there you go we have tons of
04:17 - projects here a lot of solidity a lot of
04:18 - Solana but the one that we care about is
04:20 - the Solana prediction app so hit enter
04:22 - and this will make sure that you have
04:24 - all the modules and files you need so
04:26 - there's no more of those node module
04:28 - dependency errors and all you have to do
04:31 - is just wait for this to finish and I'll
04:33 - open a new vs code for you so once
04:34 - that's done I'll cut back and we'll get
04:36 - started alrighty so if you made it this
04:39 - far you've successfully downloaded the
04:40 - files that you need to get started so
04:42 - all you have to do now is just say yarn
04:45 - Dev
04:46 - and start the server right it's going to
04:49 - be on localhost 3000 so you can do like
04:51 - a control click and if you do that your
04:53 - browser should open and you can see this
04:56 - is what we're working on it's different
04:58 - than the demo because if you look at the
05:00 - top right there's no Phantom wallet
05:02 - connection and none of the other
05:04 - features work just yet right our goal
05:06 - together is to make this static site
05:09 - work right so we can learn a lot about
05:13 - salonout by making this work together so
05:14 - right now it says creating BET right
05:17 - here
05:18 - which means it's just a function that
05:21 - just counts allows creating bit but
05:22 - nothing actually happens so what do we
05:24 - need to do first the first thing that we
05:25 - should probably do is let's get Phantom
05:29 - right so if you don't know what Phantom
05:30 - is it is a wallet that we can use to
05:33 - connect to our dapps right there's
05:36 - multiple different kinds of wallets but
05:37 - today we're going to be using Phantom so
05:39 - if you've never had Phantom before all
05:41 - you have to do is type in Phantom wallet
05:43 - and it's going to work with chrome
05:45 - because there's an extension for it so
05:47 - it's Phantom one extension is actually
05:49 - what you need
05:51 - now I hit Chrome and there it is I
05:54 - already have it so we're good to go and
05:55 - if you know how to set Phantom feel free
05:57 - to skip a little bit ahead in the video
05:58 - to the next part but go ahead and add
06:01 - this extension open up the Phantom here
06:05 - and it's going to ask you to set your
06:06 - password and remember your phrase so
06:09 - don't share that phrase anybody or I'll
06:11 - still be able to get into your wallet so
06:13 - I'm just going to write my password as
06:15 - you can see once you make an account you
06:18 - should see something like this so it
06:19 - says wallet number one I have nine
06:21 - Solana and
06:23 - you can go ahead and go to your settings
06:25 - just click this button right here
06:27 - developer settings and make sure your
06:30 - network is devnet I repeat make sure
06:32 - your net network is devnet otherwise a
06:36 - lot of your stuff isn't going to work
06:37 - there is also the mainnet which is your
06:39 - is going to use real Salt test net and
06:42 - devnet and localhost so again devnet and
06:44 - you should be good
06:46 - once that's done if you want to add some
06:48 - Salon to your wallets there's a couple
06:49 - different resources but you can use what
06:51 - I call Soul faucet just take your wallet
06:55 - right here
06:56 - and you can copy the address with this
07:00 - paste it on here you can add up to two
07:02 - and click devnet look at that
07:05 - successfully airdrops to Seoul and now
07:08 - let's see how much I have
07:10 - and we have 11 Solana so
07:13 - you stock up on Solana because we're
07:14 - going to be testing with it a lot so
07:17 - with that said you should have Phantom
07:19 - extension installed what we can do next
07:22 - is set it up on our app so we can we
07:24 - don't have to worry about the browser
07:25 - right now let's go ahead go to your vs
07:28 - code and we're going to be working on
07:30 - the index page or actually the
07:33 - underscore app page
07:36 - and now when you're in your app.js this
07:38 - is where we're going to set up the pro
07:39 - connection provider for our wallet and
07:42 - so that we can connect to the Solana
07:44 - chain so one thing that we can do to
07:46 - make our lives easier is if you go into
07:48 - the utils folder you'll see a couple
07:49 - files that I set up for you what you
07:51 - want to do is go to con constants.js and
07:54 - let's set up a couple different things
07:56 - the first thing I'm going to write is
07:59 - expert const RPC underscore endpoint all
08:04 - right if you don't know what our PC
08:06 - endpoint is this is essentially a node
08:08 - that we use to connect to the Solana
08:11 - blockchain and there's a lot of
08:12 - different uh endpoint providers out
08:14 - there like infuria
08:16 - um quick node Alchemy but today we're
08:18 - going to be using quick note
08:21 - all right so do something like this and
08:24 - all you have to do is go to quick note
08:26 - and let's get an endpoint together so
08:28 - we're going to go back to the browser
08:30 - right right here let's head over to
08:33 - quick note okay so go to quickenow.com
08:35 - or click in the link in the description
08:36 - so that you can get in right away
08:41 - all you have to do is Click sign in and
08:43 - create your or create your account so go
08:46 - ahead and do that verify your email and
08:48 - your endpoint should be good to go I
08:50 - already have an account so I'll just
08:51 - quickly log in
08:54 - and Bam once you confirm your email you
08:57 - should see uh something that says create
08:59 - your endpoint so right now I have this
09:03 - endpoint called bold stylish voice right
09:05 - but I'm going to go ahead and archive it
09:08 - so that we can create one together if
09:10 - it's your first time
09:12 - all right so feel free to use whatever
09:13 - endpoint you like
09:16 - meantime we'll do with this so archive
09:19 - that endpoint and this is the exact
09:21 - screen that you guys should see I'm
09:22 - gonna go click create an endpoint and
09:25 - again it supports multiple different
09:28 - chains eth Bitcoin polygon Avalanche
09:31 - right but we're using Solana of course
09:33 - and quick question which net are we
09:36 - going to be using main test net or
09:37 - devnet exactly good job George that's
09:41 - gonna be definite we're gonna go ahead
09:43 - continue
09:44 - there's a couple other extra features
09:46 - like an nft fetch tool but we don't need
09:48 - that let's just make the endpoint down
09:50 - in the bottom right
09:52 - all right give it a second
09:57 - there you go right guess what that's it
10:00 - that's all you have to do is set up an
10:01 - endpoint if you were to do this yourself
10:02 - it would take a lot longer so let's go
10:06 - ahead and click this copy and this HTTP
10:09 - provider and that's all we need so you
10:11 - can go back into your code now and in
10:14 - the quotes after you made this variable
10:16 - in your constant.js you should have one
10:19 - just paste that bad boy in there and
10:21 - guess what you have an end point ready
10:24 - all right so now that you have your
10:26 - endpoint and you're exporting we can now
10:29 - go back to our app and we're going to be
10:32 - using that endpoint soon to use it
10:36 - though all you have to do is if I make
10:38 - this bigger for you guys
10:39 - go into here if you export it you're
10:41 - allowed to do something like this
10:43 - restructure here and say RPC uh end
10:48 - point
10:50 - oh I think it's underscore endpoint
10:52 - and then you can see the Auto Import go
10:54 - ahead and click that or write it out
10:56 - like this and now now that uh endpoint
11:00 - is successfully imported into our
11:01 - underscore app right so that's not all
11:03 - that we need to do we need to import a
11:05 - lot of other things such as the Solano
11:08 - wallet
11:09 - um modules
11:11 - so I'm gonna go ahead and do that
11:13 - let's import the connection provider so
11:16 - I'll say connection
11:18 - provider and you can see this is coming
11:20 - from our module Solano wallet adapter
11:23 - react right so all these modules are
11:26 - already installed if you did it with our
11:27 - CLI tool if you didn't use our CLI tool
11:30 - go ahead and do yarn add this right here
11:34 - go
11:36 - and there's actually another thing that
11:37 - we need to get from Solana wallet
11:39 - adapter rack which is going to be a
11:41 - wallet
11:43 - provider
11:45 - okay so we need to provide the
11:46 - connection and then we need to provide
11:48 - the wallet this is how you can look at
11:50 - these Imports and it's cool because
11:51 - again Solana modules are helping us make
11:54 - it a lot easier for us so we can do is
11:57 - another import
11:59 - ant okay
12:01 - if you remember in any other videos when
12:03 - I click on the connect wallet button you
12:06 - should see a nice modal that comes up
12:08 - that shows the different wallets right I
12:10 - didn't make that myself you actually can
12:12 - get that provided for you from Solana as
12:15 - well as you can say wallet
12:17 - modal provider right here and you can
12:21 - see this is the module that it comes
12:23 - with so Solano wallet adapter react UI
12:28 - the next thing we're going to say import
12:30 - and I'm going to hit enter here because
12:31 - there could be a bunch of imports that
12:34 - you'd want but you can do a phantom
12:37 - wallet
12:40 - adapter
12:41 - and if you want to add more wallets put
12:45 - more options for the users you can add
12:47 - all the wallets here there's a couple
12:49 - different other adapters that Salon
12:51 - provides and you can get this from
12:55 - at Solana wallet adapter Dash wallets
12:59 - right here okay so once you do that
13:01 - that should be it for wallets we can do
13:04 - import this last thing which is the CSS
13:07 - so you can say uh Solana wallet adapter
13:10 - react UI and then the slash styles
13:14 - dot CSS right because if you don't have
13:17 - this we're going to have a really blank
13:18 - Phantom or connect wallet button rather
13:22 - okay so all of our actors are set
13:25 - now let's put it together
13:27 - [Music]
13:30 - so one thing I'm going to do is we've
13:32 - imported use state from react all right
13:34 - that was given to you what we need to do
13:36 - is make the state for something called
13:39 - mounted
13:41 - okay
13:42 - so to set up a state you're just going
13:43 - to say const uh mounted and then set
13:49 - I'm just going to SQL that to use State
13:52 - and the default for this is actually
13:54 - going to be false
13:56 - okay
13:57 - cool
13:58 - hit save and the next thing you want to
14:01 - do is let's set up all the wallets that
14:02 - we're going to use and like I said it's
14:04 - going to be one so make a variable
14:05 - called wallets and equal set it equal to
14:08 - use memo
14:10 - right and then to use use memo it's
14:13 - going to take an arrow function
14:16 - and then put this array here
14:18 - and then you're going to say new and
14:20 - let's use all our Imports so the first
14:23 - thing that we're going to use is this
14:24 - Phantom wallet adapter
14:26 - so we're gonna make a new instance of
14:28 - this adapter hit comma
14:33 - for this variable
14:34 - and hit save uh after this array it does
14:38 - need a dependency module so just do this
14:42 - cool
14:45 - and let's set up a used effect right
14:48 - because there is this SSR arrow with
14:49 - next so I just want to set up a use
14:51 - effect right here
14:52 - [Music]
14:55 - boom boom and then here we can set
14:58 - mounted to true
15:01 - okay and again let's add another
15:03 - dependency module right there
15:05 - cool
15:06 - all right so if you didn't know it in
15:09 - line 28 this component with dot dot dot
15:11 - page props this is what represents our
15:14 - index.js right so what we need to do is
15:18 - wrap all of our providers
15:21 - around our app right or our index so the
15:24 - first thing we can do is at the top say
15:26 - connection
15:27 - provider like so right if you're
15:30 - wondering where did my where am I
15:31 - getting this well we imported it right
15:33 - here now it's not grayed out
15:36 - and we could do is essentially just put
15:38 - it
15:39 - and wrap it like this so now our
15:41 - connection provider
15:43 - oops
15:44 - sorry about that but as I was saying
15:46 - what we did there was all we wrapped our
15:48 - app with this provider and we're gonna
15:51 - do the same thing with the wallet
15:54 - provider right so how it should go it
15:56 - should be the connection provider on the
15:58 - top and inside that is the wall provider
16:00 - and inside that is the modal provider
16:02 - okay makes sense so I'm going to enter
16:05 - right here and just say wallet provider
16:09 - okay and I'm gonna close it and then
16:11 - take this
16:12 - and put it right here right make sure
16:14 - that this closing wallet provider isn't
16:17 - under connection right because this is
16:18 - nested
16:20 - okay and then from there one more we're
16:23 - going to hit enter
16:25 - hit this curly bracket right so we can
16:27 - use some jsx and what we want to do here
16:29 - is essentially say mounted and and all
16:33 - right so where's my and button right so
16:34 - this means if this is true right then we
16:37 - can load our app right because then we
16:41 - know that it's mounted and put the
16:43 - component inside of that
16:46 - okay
16:48 - cool
16:50 - and actually above that is the model
16:53 - provider so we can say wallet model
16:55 - provider
17:00 - amazing so this is how it should look
17:02 - connection wallet wallet model and then
17:05 - this mounted check right here it wants
17:08 - to make sure this is true and then we'll
17:09 - load the index
17:11 - okay
17:13 - cool and this will automatically become
17:15 - true because the use effect is going to
17:17 - run this right when the app or this
17:19 - app.js component loads okay
17:22 - and the next thing we should do is let's
17:25 - put in a couple different properties
17:28 - right so in this connection provider the
17:30 - opening tag if you hit enter it has a uh
17:34 - prop or attribute called endpoint and
17:37 - it's going to take in an endpoint that
17:39 - we use so
17:41 - um we're going to use our RPC endpoint
17:43 - right so now it's coming into play
17:44 - essentially it's going to be what it
17:47 - looks like underneath the hood is quotes
17:48 - and then your long link that you have so
17:51 - we have that stored in the variable so
17:53 - we can just write this
17:55 - okay and next it should take in this Con
17:58 - fig and it's going to be equal to object
18:01 - object
18:02 - commitment and you're going to say
18:06 - confirmed awesome
18:08 - one more thing it's going to be the
18:10 - wallet provider we need to provide this
18:12 - with the wallets that we set up which we
18:14 - did with this variable right so kind of
18:16 - like the end point you're just going to
18:18 - go into the opening tag of this hit
18:20 - enter
18:22 - okay
18:23 - enter and then do wallets is equal to
18:27 - well well because that's what we call
18:29 - okay awesome and then there's another
18:32 - cool thing that we have uh built in
18:34 - which is the auto connect right so when
18:37 - you're already logged into your Phantom
18:38 - it'll automatically connect that wallet
18:41 - to your app if it's been connected
18:42 - before
18:43 - so this is a cool feature to have if you
18:45 - don't want this you don't have to have
18:46 - it
18:48 - alrighty that said
18:50 - we got our wallet set up right so how do
18:52 - we start using it well we have to figure
18:54 - out where we want to add this connection
18:56 - so if I go quickly back to my app
18:59 - and I asked you guys what component is
19:03 - going to be holding
19:05 - this connect wallet button right well if
19:08 - you ask me I think it's going to be what
19:10 - we have as the header component so go
19:12 - into your components it's nice and
19:14 - organized for you guys click on
19:15 - header.js and let's scroll to line 35
19:19 - right there it is the connect wallet
19:22 - button so what can we do to start using
19:24 - the wallet that Salon provides for us we
19:26 - can just import it right so we can say
19:28 - import and it's called wallet
19:32 - a multi button like so see this
19:36 - all right hit save
19:39 - we can do now is remove this whole div
19:41 - and just use that very component wallet
19:43 - multi button
19:45 - okay all right so with that said let's
19:47 - take a look so I'm gonna go look into
19:49 - here and look at that there's my wallet
19:52 - and I've connected this before but this
19:54 - is what it would look like initially
19:55 - right so I can hit refresh if you want
19:57 - to see the full process you can hit
20:00 - select wallet and Bam
20:02 - all right if you want to give it more
20:04 - styling because it does look a little
20:05 - small right what we could do is I have
20:07 - styling ready and I think it's called
20:10 - menu item right I gave it that same
20:13 - styling so all you need to do
20:16 - is just put class name is equal to
20:19 - [Music]
20:20 - styles
20:21 - dot menu item so hit save there and Bam
20:25 - right it's not so it's small and Tiny
20:27 - anymore and it has that nice hover
20:28 - effect so don't be afraid if you don't
20:30 - want to use the default uh CSS styling
20:33 - of the button you can give it a custom
20:34 - one to match your theme so there you go
20:38 - we're connected guys this is it that's
20:40 - how you set up your Phantom connection
20:41 - let's move on to the next step alrighty
20:44 - so with that out of the way let's get to
20:46 - the main part of the video I xed out the
20:48 - quick note tab so if you don't need it
20:50 - go ahead and get rid of it what we need
20:52 - to do is head over to seoul.pg or rather
20:56 - beta.soul.pg or if you don't know what
20:58 - this is this is a browser where you can
21:01 - write your very own Salama smart
21:03 - contract usually we can use vs code and
21:06 - create our anchor project here but this
21:08 - is a nice tool that lets us test
21:10 - functions create functions and
21:12 - everything we need without downloading
21:13 - all the files that we usually do so if
21:15 - you've seen our other tutorials this is
21:17 - what we've been using
21:18 - so I can see this is our lib.rs our
21:22 - anchor file and each of these is part of
21:26 - the program this is called the account
21:27 - struct right with and every single
21:30 - function like this one right here
21:31 - initialize is going to have a struct
21:33 - that goes with it so let's get started
21:36 - the first thing we're going to do is
21:37 - let's create a new project actually and
21:39 - as you can see there's three different
21:41 - types of Frameworks native rust anchor
21:43 - which is a framework of rust and then
21:45 - now it supports seahorse python so if
21:48 - you want to see us use seahorse follow
21:50 - the Instagram tutorial where I use
21:52 - Python for that build so what we're
21:54 - going to do is write prediction
21:57 - right
21:58 - tap and hit create open select the
22:02 - framework
22:03 - bam cool so nothing should change right
22:05 - this is pretty much the app but let's go
22:07 - ahead and erase everything and start
22:10 - from scratched and before we move any
22:11 - further let's figure out what are we
22:13 - trying to do with this Solana smart
22:15 - contract well what do we know and this
22:17 - is called pseudocode so what I'm going
22:18 - to do is say prediction
22:21 - dap right and the goal of this smart
22:24 - contract is what right we need to
22:27 - get the price
22:30 - of the stock using
22:34 - the pith Network right or pyth
22:37 - and then the functionality of it because
22:40 - we can easily just get the price of the
22:42 - stock using this with the key
22:45 - but the fun part about this is that
22:47 - we're making it uh so that users can bet
22:50 - on if the stock is going to go high or
22:52 - low
22:53 - and during a certain amount of time so
22:54 - what we need is
22:56 - player a to choose an asset
23:02 - that's available
23:05 - in pith all right so that makes sense
23:08 - and
23:10 - and inputs the length
23:13 - of the bed right because that user
23:15 - should select something like AMC stock
23:18 - and say like hey within the next two
23:20 - minutes let's see if the price is going
23:22 - to go up or down okay that's player a
23:25 - and this is important because if we
23:26 - don't know how the logic works we might
23:28 - get into some trouble so this is for us
23:31 - to understand if you feel like you
23:32 - understand this and you just want to see
23:33 - me code skip a little bit ahead in the
23:35 - video and let's keep on going but player
23:37 - B though
23:39 - well other players can see all existing
23:43 - beds so after the bed is created all
23:45 - right so this is basically creating a
23:47 - bit
23:48 - create bet
23:51 - you can see all existing bets right so
23:53 - how does that have work well we're going
23:54 - to be able to fetch the bets right
23:58 - and then
24:01 - after that player
24:03 - B can match
24:05 - Penny bets so what does match mean to
24:07 - you guys so matching a bet let's say I
24:10 - create a bet over here and I bet two
24:13 - soul that AMC is going to go up in two
24:16 - minutes right player B will also a bit
24:19 - too so that could go down or go even
24:21 - higher right so that's why it's going to
24:23 - match any bet
24:26 - that's and inputs his own prediction
24:30 - okay does that make sense good awesome
24:33 - so another thing is uh if the timing is
24:38 - over whoever whoever is closest to the
24:42 - price
24:43 - can claim
24:46 - the whole amount right so if player one
24:49 - player one or player a bets two Soul
24:51 - player B matches that with another two
24:53 - Soul What's the total price that they
24:54 - get after winning it's gonna be four
24:56 - right so again
24:59 - logic is very similar to the lottery bet
25:01 - except now we're actually inputting our
25:04 - predictions here instead of just a
25:06 - random or semi-random uh algorithm cool
25:15 - alrighty cool so that should be enough
25:17 - pseudocode for now let's get to coding
25:20 - and one of the first things we need to
25:22 - do is import anchor Lang into our
25:24 - project right so usually in JavaScript
25:26 - you've seen like import anchor from
25:28 - whatever right but we are on Rust right
25:32 - now or rather anchor so to import it in
25:35 - Rust you just say use right you can see
25:37 - this little suggestion is helpful input
25:39 - right you're going to literally say use
25:41 - anchor underscore Lang and then colon
25:45 - colon right you can think of colon colon
25:48 - like us going into a folder right we're
25:49 - gonna CD into anchor Lang and if we do
25:53 - this we can destructure what we want
25:55 - inside of anchor link so what do I want
25:57 - inside of anchor Lang well there's going
25:59 - to be something called Prelude
26:01 - right and if I do a colon colon here
26:03 - what does that mean we're going inside
26:04 - Prelude exactly so you guys are getting
26:06 - it all right so what I want inside
26:08 - Prelude is going to be a star or an
26:10 - Asterix this means I want everything
26:13 - inside the Prelude right and then if you
26:15 - put a comma here we're gonna get
26:16 - something else that's inside is it going
26:18 - to be Prelude or anchor length
26:20 - you've got it it's gonna be
26:22 - inside of anchor Lang we can get
26:24 - something called system underscore
26:26 - program
26:28 - right and another key thing about anchor
26:31 - is make sure you put semicolons right
26:33 - semicolons Mark The End Of The Line in
26:36 - code in JavaScript it's not like that
26:39 - and you don't need to put it but here we
26:40 - do so if you see any errors it's
26:42 - probably because you missed a semicolon
26:44 - so
26:45 - now the important thing that we need to
26:47 - import is we need to be able to get the
26:50 - price of the stock using the network
26:52 - right so what we could do is say pith
26:55 - underscore SDK underscore salon right
26:58 - the pith network has an SDK that we can
27:00 - use in our Solana program to load the
27:03 - price feed into our smart contract right
27:06 - so we can get that by going into it
27:08 - right and we don't need to destructure
27:11 - it you can say load
27:12 - price oops price underscore feed from
27:18 - underscore account underscore info and
27:21 - then semicolon right don't worry about
27:23 - memorizing a lot of this for me I had to
27:25 - read a lot of documentation
27:27 - um test some code and I was like okay
27:29 - this is what we need right
27:31 - cool so we are using that library and
27:36 - the next thing we should do is we should
27:37 - have the declare ID all right so oops
27:42 - declare
27:43 - ID
27:44 - and I enter and looks like this right
27:46 - this is going to be where our uh the pub
27:50 - program key of our app is going to be
27:52 - right which essentially is the key to
27:56 - access this program on the Solana
27:58 - blockchain so for now you can just put
28:00 - empty quotes because when we press this
28:02 - build button it's going to generate that
28:04 - public key for us all right think of it
28:06 - as the address of this program on the
28:09 - salon chain
28:10 - okay cool and the next thing you need to
28:13 - do is use this program macro so you do a
28:16 - hashtag and the right program because
28:18 - everything underneath this is going to
28:21 - represent the program right so then
28:24 - right underneath it if you hit enter say
28:26 - mod
28:27 - prediction underscore dab right this is
28:31 - the name
28:33 - of the program right which we also have
28:35 - right here okay
28:37 - so if you want to change the name of
28:38 - your Solano Pro Smart contract like on
28:41 - chain change this all right next thing
28:44 - you can do is put these curly brackets
28:45 - and everything within these curly
28:47 - brackets represents the program right
28:50 - that's the code blue
28:52 - okay cool
28:54 - and now that you guys made the program
28:55 - what you write in between these query
28:58 - brackets is all the functionality right
29:00 - so this should be familiar to you right
29:02 - how do we make a function an anchor
29:05 - right so to make it I would just say Pub
29:08 - all right public FN and then the
29:11 - function name so if you open up the
29:14 - default version of beta soul.pg you
29:17 - would see something like initialize
29:18 - right we need to initialize our app in
29:21 - here so it's a function called
29:22 - initialize what do we need for this
29:24 - prediction dap well we need to do
29:28 - something called creating the master so
29:30 - let's call that create
29:32 - underscore Master right because before
29:36 - we can create bets right and have player
29:39 - a player B we need to set up what's
29:40 - called a master account that's gonna
29:43 - hold the information of our program and
29:46 - you know all the functionality okay
29:49 - so how do we make the rest of the
29:52 - skeleton of the function we're just
29:54 - going to say uh Arrow here and then
29:56 - you're going to say result right
29:59 - boom and then open and close it and then
30:02 - parentheses inside of there and put
30:05 - these curly brackets in there and that's
30:07 - it this is the skeleton of a function in
30:10 - Anchor right see this so function name
30:13 - right this is basically the result and
30:16 - then
30:17 - curly brackets to put the scope
30:20 - got it okay cool so what's next
30:24 - now usually
30:26 - when you're making a function in Anchor
30:28 - you have to create what's called a
30:30 - struct that goes along with it so we
30:31 - need to make well the master struct so
30:35 - usually you can do it right here but
30:38 - what we could do is just make another
30:40 - file right so go to right here under
30:44 - source and we should be able to make
30:46 - another file let's create
30:48 - let's go here
30:50 - new file there we go and this new file
30:53 - we can call it state DOT RS right make
30:55 - sure it's RS and in this file we'll hold
30:58 - all of our structs that go along with
31:01 - our function right I've done it before
31:03 - where you put it all inside of the
31:04 - program right but the idea is to
31:06 - organize it and split it to files and
31:08 - then import the states
31:11 - into our program okay so I'm just going
31:14 - to make a state.rs alright so go ahead
31:16 - and do that and once you do that we can
31:18 - use anchor
31:21 - laying
31:23 - colon colon Prelude colon colon star and
31:28 - then semicolon
31:30 - nice cool so make sure you're using
31:32 - anchor link and we're getting preload
31:34 - and how do we set up
31:36 - um the struct for creating the master
31:39 - [Music]
31:41 - so the first thing you have to do is use
31:44 - this macro called account right because
31:46 - these structs they're essentially
31:48 - opening up what we call accounts on
31:50 - Solana the closest thing I could think
31:53 - of to help you understand it is that
31:55 - think of it as a object that you're
31:57 - creating on the Solana blockchain and
31:59 - anytime you put stuff on this line of
32:01 - blockchain it's gonna cost some soul
32:03 - right you're going to pay for the space
32:04 - that you're using depending on the size
32:07 - so what we're doing here is we're
32:09 - creating the uh the struct of the master
32:12 - account like what is that Master object
32:14 - look like what kind of properties does
32:16 - it have right so to start doing that you
32:18 - do the hashtag account then you can say
32:21 - Pub struct Master right
32:25 - okay and after that we can Define what
32:28 - is the master right uh this is going to
32:30 - make more sense to you if we make the
32:32 - bet but think about the reason we need
32:34 - the master is because we want to keep
32:35 - track of the last bet ID right so that
32:38 - every time we make a new bet we can just
32:40 - increment the master so we know how many
32:43 - bets exist so we could say Pub last
32:46 - underscore bet underscore ID and then
32:49 - colon right
32:50 - another thing that you need to know
32:52 - about Russ is that it needs to know the
32:54 - type of this like that it's expecting
32:57 - right so you say unsigned integer and
33:00 - then 64 is how many bits or bytes is
33:03 - this gonna be the limit right of the ID
33:05 - so it's going to be 64.
33:08 - and with that said that's it that's it
33:10 - for the master
33:11 - right but at this moment right now this
33:14 - master does not exist in the lip so how
33:16 - do we make it exist in the lib.rs right
33:19 - you guessed it we need to import it
33:22 - right so the way we import stuff you can
33:24 - go top here and you can say mod and then
33:27 - say the name of the file state
33:29 - all right oops and then afterwards we're
33:32 - not done yet we have to use crate right
33:35 - so what is use crate uh crates and
33:38 - anchor is kind of like package.json
33:41 - right it's the equivalent so you can say
33:43 - create use crate clone colon and inside
33:46 - of the crate we want to get a couple
33:48 - things
33:49 - and right now we just want to get a
33:52 - state right and remember what this means
33:54 - get me everything inside of this state
33:56 - all right so essentially we are bringing
34:00 - everything inside of the state into the
34:03 - top level of our lib.rs right
34:07 - so
34:09 - um in order to use it in here we have to
34:10 - do something like state DOT or whatever
34:12 - but if you just want to just use it
34:14 - straight up we can do something called
34:17 - use super right so at the top uh right
34:21 - here line 20 for me
34:23 - you can say use super colon colon star
34:26 - and then semicolon and don't forget to
34:29 - put the semicolon after the use crate as
34:31 - well
34:32 - boom cool so what does U super do it's
34:34 - going to bring everything in the top
34:35 - level of your lib into the program so
34:39 - you don't have to do state DOT or state
34:40 - whatever right you can just straight up
34:42 - use this master struct that we created
34:46 - okay
34:48 - awesome and I will just put this comma
34:50 - here because it's nice
34:53 - all right
34:55 - looks pretty good to me so next thing we
34:57 - gotta do is inside of this program here
34:59 - we have to create the struct for create
35:02 - master like I said for every function
35:03 - you need to have a struct with the same
35:05 - name all right you like that's the case
35:07 - like most of the time so I'm gonna go
35:10 - into line 25 for me make some space and
35:13 - let's get started on that
35:15 - all right so what can we do to get
35:17 - started well what I would probably do is
35:19 - go into here start up a macro and this
35:22 - one is going to be called derive oops to
35:24 - arrive accounts right so we're gonna use
35:27 - accounts right
35:29 - when we're defining the struct of create
35:31 - master so we can say Pub struct right
35:33 - anything under here is going to be using
35:36 - this so we're going to do Pub struct
35:39 - create master right and then give it a
35:43 - lifetime variable of info
35:46 - which just has one apostrophe in front
35:48 - of it basically a lifetime variable lets
35:50 - you know how long does this struct live
35:52 - in the smart contract right with the
35:54 - anchor uh and rust essentially it needs
35:57 - to know how big everything is how long
35:59 - everything will last so that you can
36:01 - manage your space really well look in
36:03 - JavaScript uh we're kind of uh we're
36:06 - they hold our hand in JavaScript because
36:08 - they have a garbage collector that
36:09 - collects it the unused variables that we
36:11 - don't use anchor you gotta do it all
36:13 - yourself
36:14 - anyways
36:15 - after you create the name of the struct
36:17 - you add this lifetime variable info
36:19 - right you just want to go ahead
36:22 - have this account macro here and put
36:24 - parentheses right and it's going to we
36:26 - have to initialize uh the account so
36:29 - it's going to say an account here right
36:31 - so let me just do it manually first
36:34 - and what you want to do is inside this
36:36 - parentheses say init
36:38 - and you're going to say pair
36:40 - uh payer who's going to pay for the
36:42 - space of this account and it's you the
36:44 - payer should equal the pair
36:46 - right and then comma the space is going
36:50 - to be uh eight which is how big
36:53 - this is going to be it's just going to
36:55 - be eight and then after that you're
36:56 - going to say Plus 8 so this second eight
37:00 - is what we call the account
37:01 - discriminator right how much space uh
37:03 - this account takes there's always going
37:05 - to be an account discriminator which you
37:07 - can think of it as the spacing between
37:08 - all the accounts in your program
37:11 - okay cool and then we have something
37:14 - called the seeds
37:16 - right
37:19 - so what are the seeds right essentially
37:22 - seeds are what the you know shuck takes
37:26 - in which is going to help generate a
37:28 - unique public key for this account right
37:31 - because after a while when we build this
37:33 - app we're gonna get a string of numbers
37:35 - and letters that's going to showcase the
37:37 - address of where our program lives every
37:40 - account is also going to have a public
37:42 - key Associated and it's going to be
37:43 - dependent on the seeds right so let's
37:47 - say it's inside the seeds it's going to
37:49 - take in the string Master right so we
37:52 - don't have that yet so let's just leave
37:54 - that blank for now let's finish writing
37:56 - this rest of it we're going to say bump
37:57 - and I'll explain that in a second as
37:59 - well but after in line 35 after the end
38:02 - of the macro
38:04 - enter
38:05 - and you're gonna say Pub Master right
38:08 - and what is what does this master mean
38:11 - this is the account itself right so this
38:13 - is the account macro this is the account
38:15 - that we're talking about right I'm
38:17 - talking about the master account what is
38:18 - the master account guys come on you made
38:21 - it right here the master object itself
38:23 - with this ID
38:25 - all right so that means we want create
38:27 - the create master struck to be aware of
38:31 - the master account so that's why we're
38:32 - doing this right here so how do we get
38:34 - this state all right we can just say
38:38 - count all right get the account
38:42 - give it info comma and then say the name
38:45 - of the um
38:47 - account which is going to be Master okay
38:49 - cool and what other information do we
38:52 - want in this struct
38:55 - Ure well it's going to be the account
38:56 - mute this is how we're going to get the
38:59 - payer right so we're gonna say Pub pair
39:01 - right because when we said pair equals
39:03 - payer at the moment you don't know what
39:05 - who that is right well payer is going to
39:08 - be the signer right whoever signs a
39:12 - transaction
39:13 - and you might be thinking Lance when did
39:15 - you write sign or we didn't make that in
39:16 - our state well guess what sign there
39:19 - comes from Prelude yeah so again this is
39:23 - stuff that you can do by reading a lot
39:25 - of the documentation I'm just
39:26 - simplifying it in my explanations if
39:28 - this is your first time
39:30 - okay
39:31 - amazing so the pair now exists right
39:35 - we're good to go in that and the last
39:37 - thing is we always have to put the
39:39 - system
39:41 - underscore program
39:43 - and this is going to be the type of
39:46 - program right so this is just defining
39:47 - what type
39:49 - uh to expect from this so Master is an
39:51 - account payer is the signer System
39:54 - Program is coming from program
39:57 - and then again info system
40:00 - okay which is coming from another
40:02 - library that we're importing at the top
40:05 - okay well believe it or not this is it
40:07 - this is the create master struct we just
40:09 - need to put in the seeds right so what
40:12 - I'll do is create another file
40:14 - and this one I'm going to be calling
40:16 - constants const the install RS and this
40:19 - is where we're going to hold all of our
40:20 - variables our constant variables right
40:23 - and again
40:25 - another way to do this is putting it all
40:27 - at the top here
40:28 - but we could just make a constants.rs
40:31 - all right so what I'll do first is say
40:32 - use
40:33 - anchor Prelude right there you go
40:36 - uh and we don't necessarily want
40:38 - everything but
40:40 - Let's see we can leave this for now all
40:42 - right we're gonna add more to it later
40:43 - but let's say our first variable is
40:47 - gonna be Pub const and remember this is
40:50 - for the seeds we'll say master
40:51 - underscore seed colon and what type is
40:56 - the master seed well it's going to be
40:58 - and brackets u8 is equal to B
41:04 - don't make sure you do B quotes master
41:08 - all right this is essentially a binary
41:11 - string right cool and we want to take
41:14 - this binary string and put it
41:17 - into our seeds all right so bear with me
41:21 - for a second
41:22 - so that should be it put make sure you
41:24 - put on the comma put a semicolon and
41:27 - we're going to be adding to this every
41:28 - single time as we go through the app
41:31 - and let's get imported our constant so
41:35 - you know if you want to test yourself
41:37 - try pausing the video and see if you can
41:38 - get the constants.rs into your lib.rs
41:42 - awesome
41:43 - if you tried it the answer is you need
41:45 - to put mod right here
41:48 - and it doesn't really matter what order
41:49 - you do it but you can just say constant
41:53 - constants and then you can put a
41:54 - semicolon
41:57 - okay and then in your crates you can do
41:59 - a comma
42:02 - and say constants
42:05 - constant colon colon and get everything
42:08 - from constants even though there's one
42:10 - thing we're going to get more later
42:12 - so constant state boom so now we can
42:15 - just use it directly onto here and
42:17 - instead of getting you know the fair
42:20 - like saying it's constant and then
42:22 - getting Master seed right we can just
42:25 - say master seed
42:27 - right
42:31 - all right so like I said just write
42:33 - Master C
42:35 - all right me doing this is almost the
42:37 - same thing as writing uh binary string
42:41 - Master inside of the seats okay
42:44 - but we want this one because that's
42:46 - going to hold the variable
42:47 - all right so now for my explanation what
42:49 - the hell is the seeds lens well you
42:51 - could think of it like this I'm going to
42:52 - use something called a dice bear
42:54 - right which generates an avatar
42:57 - based on your seed right season
43:00 - um what's called Solana is a little bit
43:02 - different right oh I'm not going to go
43:04 - over like how it works exactly but the
43:06 - way that I understand it you can go into
43:09 - here right depending on what you write
43:12 - as your seed we'll get a unique Avatar
43:14 - that's how dice Spirit works so if I
43:16 - write Master here
43:17 - this is my avatar when I put in master
43:20 - as a string and a seat
43:22 - right so it's the same idea with Solana
43:26 - if I put uh the Master Seat here it's
43:29 - gonna instead of generating an avatar
43:31 - it's going to generate a public key
43:34 - for my master account right so let's add
43:38 - let's do a little diagram right
43:41 - let's say this is our app and this is
43:44 - the Solana blockchain Solana
43:47 - right my app is going to create an
43:52 - account or a master account and what it
43:54 - does is it's going to create some space
43:56 - in here
43:57 - this is going to be the master account
43:59 - right and this master account is going
44:02 - to have a unique public key so it's
44:04 - going to be something like this right
44:05 - well there's not those special
44:06 - characters but it's going to be a random
44:08 - set of letters numbers or whatever and
44:11 - this is going to be the essentially the
44:13 - address of this account so when I go to
44:15 - fetch it right I just type this in my
44:18 - app and I'll be able to fetch that
44:21 - Master based on the public key
44:24 - so that's why we need to generate a
44:27 - unique uh public key we have to put in
44:29 - the seed
44:30 - right and this bump right here let's say
44:32 - there's already
44:35 - there's already something that exists
44:37 - with this public key bump is going to
44:40 - essentially go to the next available
44:42 - public key right so you can imagine this
44:44 - like oh there's already something that
44:45 - exists with Master let's Sprite that's
44:48 - right um
44:49 - Master one and this is our unique Avatar
44:52 - or our unique public key hopefully that
44:54 - made sense right essentially let's
44:57 - generate a new public key and if it's
44:59 - not available bump it cool and then from
45:02 - there we can test it by building right
45:05 - there might be an error but let's just
45:07 - see if it works if
45:09 - we cannot compile
45:11 - you can use Imports constants oh okay
45:13 - okay
45:15 - I see
45:16 - all right so we got the error
45:19 - um I think oh yeah we need to add commas
45:22 - here right I can't forget that and the
45:25 - last thing we should probably do is
45:26 - finish up our function
45:28 - so the only thing we need to do with
45:29 - create master right the struct handles
45:32 - it already right in this truck we're
45:34 - initializing the account so we don't
45:36 - have to write any new functionality for
45:37 - that anchor is handling that for us so
45:40 - what let's do is just say okay right
45:42 - it's an enum basically saying like we're
45:44 - done we're oh it's successful right okay
45:49 - all right so now let's try to build
45:52 - there is a error custom attribute
45:57 - panicked
46:00 - oh and how could I forget I think I know
46:02 - the reason why the reason is because if
46:05 - you look in here the function it needs
46:07 - to take in what we call context right
46:11 - and usually to do that you just write
46:13 - CTX for context and if it's unused in
46:16 - the function you have to put underscore
46:18 - and now what is the type of the context
46:20 - what is context well usually like I said
46:23 - when you create a function you have to
46:26 - create a struct with a similar name
46:28 - right because what you want to do is
46:29 - bring in all of this into the function
46:32 - so you could just say the type of this
46:34 - is context
46:36 - inside of it it's going to have the
46:39 - create master struct okay and boom this
46:43 - is like a return the result and then
46:45 - we'll do a building
46:47 - come on let's go build successful guys
46:50 - so that's it that's how you create a
46:53 - master their very first function on the
46:55 - Solana smart contract all right so the
46:57 - next thing you want to do is go ahead
46:59 - and deploy the app and you might need
47:02 - some Solana to do so right so if you
47:05 - need more Solana on your app you're just
47:07 - going to say Solana airdrop 2.
47:13 - right cool
47:15 - uh it says success internal error that's
47:19 - fine sometimes it does that you just
47:20 - have to wait a bit and you should get
47:22 - some soul but I think I have enough
47:24 - because there's not much in our program
47:25 - I'm gonna go ahead and hit deploy
47:29 - and once it's deployed right
47:32 - we're essentially taking our smart
47:33 - contract and the pl this is our smart
47:36 - contract it's kind of the big deployed
47:37 - onto the Solana blockchain right so
47:40 - that's why we have to pay some soul and
47:42 - luckily it's not real right so we can
47:44 - deploy as much as we want and then later
47:46 - on we need to fetch that program into
47:48 - our app
47:50 - okay so that's the idea
47:52 - [Music]
47:56 - all right so I'll just check back in
47:57 - when it's done
47:58 - hey let's go deployment successful right
48:01 - and as you can see we lost uh three soul
48:04 - for that the point uh deployment
48:07 - so now that's deployed we can go ahead
48:09 - and test our functions and see if they
48:12 - work right so let me show you guys how
48:14 - to test your function so anything that
48:15 - says instruction that's your function
48:17 - and now this is also the accounts as you
48:20 - can see here that we created so if I
48:22 - asked you guys do we have any Master
48:24 - accounts that we created
48:26 - no we have none and it comes in an array
48:28 - so keep that in mind so how do we create
48:30 - a master well we can test that function
48:32 - right here without even connecting our
48:35 - app which is awesome so first thing we
48:37 - need is the master uh public key and we
48:41 - can generate this from seed so what did
48:43 - we put in here right remember in our
48:45 - constants we have a binary string called
48:48 - Master it doesn't have to write a binary
48:50 - anything here you could just say master
48:51 - for this and it interprets it
48:54 - and the program ID is going to be there
48:56 - by default hit generate and the payer
48:58 - right who did we say the payer is guys
49:01 - the payer is payer or in other words the
49:04 - signer right so we can say my address
49:06 - because I'm the payer so now uh if you
49:10 - don't have any Solana you should
49:11 - probably get some now but it doesn't
49:12 - usually cost much much to create this
49:15 - and I know that because it's only 64
49:18 - bytes
49:19 - so let's go ahead and hit test
49:22 - let's go test pass creating the master
49:26 - so now if I fetch all
49:28 - we can see that this master has this
49:31 - address right so to visually show you
49:33 - guys this master has this public key as
49:36 - the address right
49:38 - and
49:39 - it has the traits of the account that we
49:42 - gave so it has the last last bet ID okay
49:46 - so what do we want to do with this every
49:48 - time we make a bet we have to go into
49:50 - our master account here and update it
49:53 - with plus one right
49:56 - so once we do that uh our last bet ID
49:58 - will be one so keep that in mind this is
50:01 - the master I'm glad the test passed
50:03 - what's next all right so if you
50:04 - understood everything that just happened
50:06 - you essentially finished the tutorial
50:08 - let's move on to the beta count itself
50:11 - okay so what we need to look at right we
50:14 - don't need to see this that much anymore
50:16 - we need to look at is creating a
50:18 - function guys so how do we create a
50:20 - function inside of this app
50:22 - all right we can say
50:24 - Pub
50:25 - FN oops FN create underscore BET right
50:30 - and how does the skeleton look like it's
50:33 - going to be parentheses Arrow result
50:36 - like this
50:38 - and then
50:40 - so the curly brackets like so another
50:42 - thing I'll do is I'll move uh this
50:45 - struct outside of the program because it
50:47 - doesn't need to be there all right and
50:49 - see if it builds still
50:51 - I might not build because we didn't we
50:52 - actually didn't finish uh right in the
50:55 - function so I'm going to just take it
50:56 - out temporarily or comment it out
50:59 - it's still acceptable
51:02 - yes okay so this is acceptable still and
51:05 - we updated our build now let's continue
51:08 - writing our function so we made the
51:10 - function what else do we need to do we
51:12 - need to create a struct that also has
51:15 - this function so the struct that has
51:18 - this function is called create BET right
51:21 - and what should create bet do right what
51:25 - should create
51:27 - but do
51:30 - it should create
51:33 - a bet account right so we want to create
51:36 - a better account first we have to Define
51:37 - what a better account is so I'm going to
51:41 - stop doing that and go to state.rs
51:44 - and let's create a bit account so to
51:46 - start creating or defining an account
51:48 - right
51:50 - we can say attribute account and then
51:54 - you can say Pub struct bet
51:57 - okay that's all you have to do and then
52:00 - after that
52:02 - you have to identify what goes into a
52:04 - bit so what are the attributes of a bet
52:06 - if you guys made classes before in
52:08 - JavaScript it's essentially this is
52:10 - essentially making a class so every bet
52:13 - should have what should have in ID
52:17 - all right
52:18 - and what should be the type of an ID an
52:20 - unsigned intrader 64. kind of like this
52:23 - all right and we can use the master to
52:27 - Define what the idea is all right what's
52:28 - the last one plus one of that there you
52:30 - go it's the new ID okay
52:32 - uh next is we need the pub
52:37 - amount right how much is the BET Worth
52:40 - right how much does it cost and another
52:42 - thing is usually we talk about it in
52:45 - Seoul when you're in the Solana smart
52:47 - contract it's going to be in what we
52:48 - call Lamp ports right which is a smaller
52:51 - unit of Soul so if you think about a
52:53 - dollar uh
52:55 - a sense is what land boards are
52:57 - essentially
52:59 - okay the next thing we need is Pub
53:03 - prediction underscore a right this is
53:07 - the essentially the prediction of player
53:09 - a
53:10 - and the type of this is going to be
53:12 - pretty interesting right it's gonna be
53:14 - something else that we call a bet
53:17 - prediction all right and I'll explain
53:18 - that later but
53:20 - prediction
53:21 - [Music]
53:23 - like so
53:24 - cool and then next we need Pub
53:27 - prediction
53:29 - B right and it's not going to be the
53:32 - same thing right because there's going
53:34 - to be an option right because by default
53:37 - uh when you create a bet you're always
53:39 - going to be prediction a that's always
53:40 - going to exist but when you're creating
53:43 - a bet player B doesn't exist yet so it
53:45 - should be null at first so that's why
53:47 - we're going to say option and then
53:49 - inside of that we'll put but prediction
53:52 - okay
53:54 - and then after that uh we should have
53:57 - the state right
54:00 - and by state I just mean what is the
54:02 - current state of this bet is it it was
54:04 - just created did the BET start did
54:07 - somebody win right that's going to be
54:09 - controlled by something called a bad
54:10 - State and we're going to be defining
54:13 - what this is and this is just a bit uh
54:16 - last but not least we need the pyth
54:20 - price key right the pub
54:22 - both or piss price
54:26 - key
54:28 - and that's gonna be a public
54:31 - key
54:32 - and you can simplify by writing Pub Key
54:34 - so what is pith price key well we're
54:38 - going to be using
54:39 - we're going to be using the uh what's it
54:42 - called the pith Network so what we can
54:43 - do is make a new tab
54:46 - and say pith Network
54:52 - right and essentially they're getting
54:54 - real-time data from Real World Markets
54:57 - as it says here and if you look there's
55:00 - many different stocks and crypto that's
55:02 - keeping track of and if you let's go
55:04 - ahead and click AMC
55:06 - you can see that it's fluctuating
55:09 - between its price and you can see from
55:11 - the graph here it's that three point
55:14 - eight nine right now right and you can
55:16 - see that all the transactions where it's
55:18 - updating that price and it's pretty fast
55:19 - it's going to be from two seconds to you
55:22 - know two minutes and to get the price or
55:27 - to know what the price is you need this
55:29 - public key right here this is called the
55:30 - price key and the cool thing is that you
55:33 - should understand what this is now
55:34 - because this
55:35 - public key is going to go to the account
55:39 - in the Solana chain that holds the price
55:42 - which is like 3.8 right and this account
55:45 - constantly gets updated over and over
55:47 - again
55:48 - right over and over
55:51 - within that time frame so it's always
55:53 - going to know right it's real time of
55:55 - the stock of AMC
55:57 - okay and to utilize that right that's
55:59 - why we're using the SDK
56:01 - all right we also need the public key
56:04 - stored into that bet itself right so we
56:08 - know which one to look for
56:10 - all right
56:11 - uh the last thing we need is something
56:13 - called the timestamp right we need to
56:16 - know how long is this bet going to last
56:18 - for it's going to last for one minute
56:19 - two minutes five months right so we need
56:22 - to say uh expiry expiry
56:27 - underscore TS colon
56:30 - and then you can say uh I 64. this is
56:34 - different than u64.
56:37 - to sign an integer
56:39 - and comma
56:42 - okay so I'm just gonna add comments
56:44 - really quickly so that you understand
56:46 - what and remember what each of these are
56:47 - [Music]
56:49 - there we go so I just paused it take a
56:51 - moment and write some comments for you
56:53 - guys so you can understand so pause the
56:55 - video if you want to take a look and add
56:58 - these yourself but essentially it's what
57:00 - I explained as I was typing
57:05 - so we need to define a bet prediction so
57:07 - I'm going to come down below here
57:09 - and we need to write something like this
57:13 - derived
57:14 - and then we need anchor
57:17 - serialize and to deserialize
57:21 - and it should be coming from Prelude as
57:23 - well and then there's last thing called
57:24 - clone because we need to add some more
57:27 - attributes or I guess properties inside
57:29 - of this prediction a right because
57:31 - prediction a
57:32 - is going to have a struct called bet
57:35 - prediction all right and this is also
57:38 - going to be inside prediction B
57:40 - the goal with this is to store the
57:43 - player right so you say Pub play
57:46 - and that's going to have a public key
57:48 - right every this is going to be the
57:50 - wallet essentially that's playing so
57:52 - your wallet if you remember has a public
57:54 - key all right
57:57 - and my public key is this 8tkz round
58:00 - okay so that's done
58:02 - um another thing is it needs to know the
58:04 - price right the price prediction right
58:06 - what did I predict that it would be all
58:09 - right and I want to use this
58:13 - right inside b as well so I'm going to
58:16 - reuse bit prediction right and give it
58:18 - an option because the option can be none
58:20 - or it can be these
58:23 - okay
58:25 - and this is the Safari comments this is
58:29 - the price prediction in USD and of
58:33 - course this is just the address
58:38 - that bets all right it could be player a
58:40 - or player B and then after that we need
58:43 - to make another one
58:46 - this is for the BET state right because
58:48 - it's going to be different things and we
58:50 - need to serialize it and deserialize it
58:53 - again so anchor serialize comma oops
58:56 - anchor oops
59:00 - deserialize
59:05 - clone and then there's a partial EQ that
59:08 - we need
59:09 - okay because this is going to be an enum
59:11 - right so Pub enum uh bet State and again
59:17 - it's going to be created
59:20 - started
59:21 - uh what's another one uh player
59:25 - a one
59:28 - and it's also
59:30 - player B one and then there could be a
59:34 - draw where they both somehow guessed the
59:36 - same exact price not likely but it could
59:38 - happen Okay so there's created started
59:41 - player a player B and draw right there's
59:44 - actually a lot of logic that goes into
59:45 - this uh I did simplify it so that you
59:47 - can get just a better understanding
59:49 - so keep that in mind
59:51 - and that should be it
59:53 - so believe it or not all the states
59:55 - should be done unless we need any more
59:57 - later but I feel pretty good about this
59:59 - so that state is done now that's next is
60:02 - let's finish the create bet struct
60:06 - so I'm here at the create bet uh struct
60:09 - right at the lib.rs and what we need to
60:12 - do is just derive accounts again so
60:14 - we're gonna say derive
60:15 - oops the rice derive
60:19 - accounts
60:21 - like that and then just say Pub instruct
60:24 - create BET right as you can see it's
60:26 - similar to create master and even the
60:30 - info part is going to be the same
60:32 - okay put the color brackets to identify
60:35 - the scope and next let's initialize the
60:37 - account so again uh anchor has a way to
60:40 - initialize the account already oops
60:44 - you can initialize it by literally
60:45 - writing a name now we're done it's
60:46 - initialized right next to Define who's
60:49 - paying for this you guys should know
60:51 - it's going to be the payer which we'll
60:52 - Define later
60:53 - next is how much space it needs right so
60:56 - we need to essentially figure out how
60:58 - much space does a bet need and depending
61:02 - on the type right we need to tell him
61:04 - all right it's this plus this plus this
61:06 - plus this right you can find this out by
61:08 - looking in the anchor documentation how
61:10 - much is each thing
61:13 - uh but I can tell you already it's going
61:15 - to be eight plus eight plus thirty two
61:20 - plus 8 plus 8 plus 32 plus 8 plus 1 plus
61:29 - 32.
61:32 - plus eight plus one and let me just
61:35 - double check this is it
61:37 - yep that looks good to me let's put a
61:39 - little space here yep this takes a lot
61:40 - of space because the BET has a lot of
61:43 - information right even has uh some more
61:45 - properties within that
61:47 - okay
61:49 - so that is the account initialization we
61:52 - just have to put the account right
61:53 - underneath that so we can say the pub
61:55 - bet
61:56 - colon is account
61:59 - right and what is the account well first
62:01 - you got to put the lifetime variable of
62:03 - info and then you can say the account is
62:05 - BET
62:06 - cool
62:08 - next we need this struct should also
62:11 - have in the in the context when we bring
62:13 - it in it should know about the master
62:15 - account so we need to get the master
62:17 - account so we don't need to initialize
62:19 - it keep that in mind we just need to get
62:21 - it
62:23 - so
62:25 - yeah I might have a comma here there you
62:27 - go now it's the correct color we say
62:29 - account and instead of saying init we
62:32 - want to say mute because it can change
62:34 - it says seeds is equal to master seed so
62:39 - what do we do here we're getting an
62:40 - account with this seed right and again
62:44 - if it's what exists was Bump there cool
62:49 - Pub master
62:52 - is gonna be the account
62:54 - info comma master all right so there we
62:57 - go we got we're able to pull the master
62:59 - account
63:01 - by doing this next is gonna be the
63:05 - player account right we need the player
63:08 - so actually this I named this player now
63:11 - same thing it's going to be the exact
63:13 - same thing
63:14 - uh account
63:16 - is mute
63:18 - because it can be there can be different
63:20 - players here and you're just gonna write
63:23 - Pub player so now this is defined but
63:25 - what the type is this it's just like
63:27 - before it just has a different name guys
63:28 - it's gonna be signer with info
63:32 - okay I should keep forgetting to add
63:34 - these commas
63:36 - there you go
63:37 - and last but not least the pub system
63:41 - program and we can pull program from
63:45 - there
63:48 - a lot of anchor code is uh just
63:50 - repeating
63:51 - it's like boilerplate
63:53 - so once you get the pattern it's going
63:55 - to be easier for you to create whatever
63:57 - smart contracts you want so that is the
64:00 - create bet struct
64:02 - okay now for the functionality of create
64:05 - bet so what does that need to do well
64:07 - create bet uh you can do a couple of
64:09 - things
64:11 - the first thing is needs to take in the
64:12 - context so
64:14 - get the context and this is actually
64:15 - gonna take a couple of things you can
64:16 - say CTX right comma you can say amount
64:20 - uh when you create a bet what else do
64:22 - you need you need the price prediction
64:25 - right
64:26 - duration
64:29 - um and the pith
64:31 - price key or pyth Price key I don't know
64:34 - how to say price key
64:37 - okay
64:38 - cool and then close it off next you have
64:41 - to put the type of it right so the
64:43 - context is going to be context
64:47 - and the context is going to be the
64:49 - create bed struct the amount right how
64:52 - much are we betting is u64 what is the
64:55 - price prediction uh remember it's going
64:57 - to be in USD so it's going to be f64 and
65:01 - then duration is going to be u32
65:04 - and I'll just make a little comment here
65:06 - that this should be in seconds
65:08 - rights seconds
65:12 - and then we have this which is a pub key
65:15 - right this is the price key that we will
65:18 - get from here
65:19 - and I've already hardcoded that into the
65:21 - code so you don't need to pull it
65:23 - okay next is the result right so what is
65:26 - the actual logic of this function well
65:28 - the first thing you need to do is uh
65:31 - increase
65:32 - the last
65:35 - ID
65:36 - on each back creation
65:39 - on the master right it's the master ID
65:42 - should be increased and to get the
65:44 - master ID right
65:46 - we first have to make a variable called
65:49 - let Master right this is normal
65:51 - is equal to
65:53 - and mute so this is new right so we want
65:56 - to say that the whatever after this can
65:58 - change it's not one static thing Russ
66:00 - needs to know that right so if it does
66:02 - change or if we do update it it's going
66:04 - to be CTX dot accounts all right so what
66:07 - CTX it's our context okay what's in our
66:10 - context
66:12 - all of these two accounts so that means
66:15 - if I do
66:16 - T accounts I now have access to the BET
66:21 - account and the master account so how do
66:23 - I get the master account from here right
66:25 - think about what an object is you have
66:26 - to say dot Master cool and let's get the
66:29 - BET while we're here too is equal to and
66:31 - mute
66:33 - ctx.accounts.bet make sense right this
66:36 - is essentially the object and we're
66:38 - getting the master from the accounts and
66:40 - we also have the bet there it all exists
66:42 - because we ourselves created obstruct
66:45 - okay so now we can do whatever we want
66:47 - so like I said how do we increase the
66:48 - last ID
66:49 - on the master well this variable holds
66:52 - the account so I can say master
66:55 - right and then
66:57 - in if this is an object what properties
66:59 - does it have so we can even look at it
67:00 - here if it makes sense for you
67:02 - it has
67:04 - last bet ID so all we have to do guys
67:07 - right is dot last bet underscore ID and
67:12 - do plus equals one right just not scary
67:16 - code Solana isn't scary all right you
67:18 - just need to get used to the wording the
67:20 - documentation and why we do things right
67:22 - and again I'm no expert right I just do
67:25 - this a couple times until I get it I've
67:27 - had help right ask questions on the
67:30 - anchor Discord or the Solana Discord
67:33 - and it'll help you get better at this so
67:35 - keep doing this over and over watch this
67:36 - tutorial several times and it'll make
67:38 - more sense so then the BET ID is going
67:40 - to be the master last
67:44 - remember I told you right the bed ID is
67:47 - going to be whatever the master was plus
67:49 - one we already initialize it here
67:51 - or update it rather and we can just use
67:54 - that same variable here
67:57 - cool and this will happen every time I
67:59 - want to create a threat so it's pretty
68:00 - good logic here the next thing is the
68:02 - bet
68:03 - dot pith underscore price key
68:08 - our pipe key
68:09 - is going to be equal to
68:12 - this right the one that we passed into
68:14 - the argument right because we're going
68:16 - to do that in the front end
68:17 - oops sorry
68:19 - pyth or pith price key and then don't
68:23 - forget the semicolon here
68:25 - uh and then it's it's pretty
68:26 - straightforward you just plug and play
68:28 - everything you wrote down so it's going
68:30 - to be better amount is equal to the
68:31 - amount I passed in
68:33 - the BET
68:36 - dot expiryts right this is the timestamp
68:40 - and you need to do something something
68:42 - like this function called the get Unix
68:46 - timestamp right we're able to just get
68:48 - the current timestamp using this and
68:51 - we're going to add a duration
68:54 - as I 64. and then semicolon
68:59 - right because what's happening is I'm
69:00 - saying
69:01 - um the bet is going to take uh 150
69:05 - seconds which is like two minutes
69:07 - it's going to take what's the timestamp
69:09 - now and then add the two minutes and
69:12 - that is when the BET expires and you
69:14 - can't enter anymore right or else it's
69:16 - unfair
69:17 - all right next is the bet.prediction
69:21 - underscore a right we're actually going
69:23 - to Define that the bet
69:25 - prediction
69:27 - right it's the object here and the
69:30 - player because we Define bet projection
69:32 - has player is going to be CTX we need
69:35 - the public key of the player we can get
69:37 - that by viewing dot accounts dot player
69:39 - dot key okay and then come
69:43 - then from there you can say price
69:46 - okay
69:47 - and then semicolon here
69:52 - after the bad prediction and the last
69:54 - thing to do is uh we need to actually
69:56 - get the Solana from our Phantom wallet
70:00 - and put it into a third-party account or
70:02 - an escrow to hold that bet right so the
70:04 - idea is both players put money into the
70:07 - third party account and then when it's
70:09 - done that third party account will send
70:11 - the winner the total pot
70:14 - okay so we can use an escrow for this so
70:16 - we can do this and I'll just write a
70:18 - comment here transfer the amount to
70:21 - the BET PDA so we can say system
70:26 - underscore program transfer
70:31 - and say CPI context new there you go and
70:35 - that's exactly what we'll write so we
70:36 - say c p i
70:38 - context I'll go into that and say new
70:42 - I just how you oops oh well okay uh
70:45 - don't need that
70:47 - boom
70:49 - all right this is the how we go and
70:50 - transfer it
70:52 - CTX dot accounts dot system
70:56 - underscore program
70:59 - dot okay oh sorry dot two account I
71:02 - think two underscore account underscore
71:05 - info
71:06 - and boom okay so essentially we're
71:09 - putting that's the player's Solana into
71:12 - the BET PDA or the account
71:16 - okay and here we can do the transfer
71:18 - System Program let's get the transfer
71:22 - [Music]
71:25 - and we're gonna get this from
71:27 - the player so we do is
71:31 - ctx.accounts.player.2 underscore account
71:34 - info
71:37 - and then we can do two
71:40 - bet so we're taking the money
71:43 - the soul putting it into the bed account
71:45 - and once the BET's over we'll give it to
71:48 - the winner
71:52 - uh and we can comma here but the BET dot
71:56 - amount
72:00 - okay and there's some things you need to
72:01 - add like this
72:03 - of course when the function is done
72:05 - we're going to hit OK
72:09 - so I know it's done
72:12 - um so that should be it for this and now
72:15 - I'm just gonna run build there might be
72:16 - some type of errors or I might have
72:17 - spelled something wrong so let's just
72:19 - see do a check yep there it is
72:24 - oh there's a little M here all right
72:26 - it's insane with uh rust because one
72:29 - error is going to mess up the whole code
72:31 - let's do this one more time
72:33 - believe there's still more
72:38 - yep forgot some semicolons
72:41 - so let's go to where I wrote bet
72:45 - semicolon
72:47 - semicolon
72:49 - [Music]
72:55 - and then it says
73:04 - beta expiry
73:08 - TS is unknown
73:11 - okay let me just check this state
73:14 - oh underscore TS whoops
73:19 - where is that
73:21 - it should be better expiry underscore TS
73:24 - okay and I think there was one more
73:26 - issue it was
73:30 - [Music]
73:32 - CPI context oh is it because I forgot
73:36 - the add 30
73:37 - let's see build
73:39 - [Music]
73:43 - okay cool
73:44 - uh now we need to fix the get
73:48 - you next time stamp
73:50 - [Music]
73:52 - get your next time stamp doesn't exist
73:55 - oh right okay I need to make one more
73:59 - file it's gonna be the utils right
74:01 - there's some functions that we need to
74:03 - create uh to make a lot of the code
74:07 - doable again this is a pretty big
74:09 - program that I have to scale down so if
74:11 - you do use anchor Lang in here
74:13 - get a couple things
74:16 - oops and we want to get Prelude of
74:19 - course
74:21 - Prelude
74:23 - colon colon star
74:26 - comma means Solana
74:28 - program
74:34 - clock
74:41 - Unix
74:43 - time stamp
74:45 - okay
74:46 - uh the main thing we want to do with
74:48 - this is create that uh get your next
74:50 - timestamp function right because it
74:52 - doesn't exist so let's make it exist and
74:55 - we can bring in our variables here
74:57 - because we're going to use them later
74:59 - so let's do a use crate
75:01 - let's get constants
75:04 - star and also State Hong Kong star so we
75:08 - can use them here
75:10 - and what we want to do with this is
75:11 - create that function so we need to make
75:13 - a function Pub FN get Unix timestamp so
75:17 - now it's going to exist uh boom
75:21 - and we can do an arrow here
75:25 - yep so now let's define a
75:27 - type of time step
75:31 - boom and this is literally just going to
75:33 - pull the clock from the
75:37 - anchor program and unwrap it
75:41 - and then we could store it Unix
75:44 - time step so this is what it returns get
75:48 - the timestamp
75:49 - at this current moment when it's run and
75:52 - then we can just go to the lib this
75:55 - should exist now because we need to
75:57 - import it so to get this into our
75:59 - program you say utils
76:02 - say comma
76:04 - utils colon colon star
76:08 - you super brings it into this and
76:11 - crossing my fingers let's go
76:14 - ah
76:15 - still doesn't work
76:20 - oh unexpected token okay that that's
76:22 - that error is usable
76:24 - expected a semicolon here can't forget
76:27 - those
76:29 - [Music]
76:31 - and try again
76:36 - foreign
76:39 - missing something
76:45 - new next time stamp not found in scope
76:50 - that's weird should be in scope
76:59 - oh anchor land that's probably why yeah
77:02 - so spelling is really important guys I
77:05 - messed that up a lot but we should be
77:07 - better now
77:11 - warnings are okay
77:17 - use clay
77:20 - just create constants
77:27 - let's go all right cool so again none of
77:30 - it was the logic it was just me putting
77:32 - semicolons and then the spelling so
77:34 - build successful right we can go ahead
77:36 - and deploy this now right
77:41 - yep
77:42 - let's hit build
77:47 - and boom right uh one thing is that we
77:50 - can't really test this just yet be
77:52 - because uh if you want to test it on
77:54 - Solana playground it uses the local
77:57 - local host and we can't it doesn't this
77:59 - python pith network doesn't work with
78:00 - localhost so I'm gonna have to transfer
78:02 - it into our app and then test it there
78:04 - but that is essentially the create bet
78:07 - all right so with that out of the way
78:09 - let's get to the next function so the
78:13 - next function is going to be entering
78:15 - the BET right so what does entering the
78:17 - bet mean
78:19 - it just means we should be able to uh
78:22 - participate in the bets that are already
78:24 - created right so we're not creating a
78:26 - brand new one we are becoming this is
78:28 - essentially player B's ticket to
78:31 - participate all right so it's gonna be
78:32 - called enter bet okay and the arrow and
78:38 - then the result at this point you guys
78:41 - should be picking up on the pattern
78:43 - to make the function okay and we know
78:46 - that this is going to have CTX and we
78:49 - know that it's going to take in the
78:50 - price right this is player B's price
78:52 - prediction okay so what do we need to do
78:55 - when we enter the BET guys well we need
78:57 - to create the context right or the
79:00 - struct that goes with uh entering the
79:02 - bit
79:03 - okay so let's go down here great bet and
79:07 - underneath this
79:08 - enter the bin so again we first need to
79:12 - derive accounts
79:14 - all right so oops
79:17 - I'd ask you guys do we need to crew
79:19 - initialize a bit account nope we don't
79:22 - need to do that we can just get the bed
79:25 - account so we'll just say Pub struct
79:26 - enter
79:28 - but
79:29 - and then put the info inside
79:32 - [Music]
79:34 - okay and then from there we can have the
79:38 - count and again we're not initializing
79:40 - it we just need to get that account so
79:43 - it can be the bets that we enter can be
79:45 - different so you want to make sure it's
79:47 - mutable
79:48 - the C
79:50 - oh did I put a seed for the BET
79:53 - I did not all right so that's one thing
79:55 - we need to remember I put the space here
79:57 - but so go back to your creep bet struct
80:00 - and we need to put the seeds in there
80:03 - all right otherwise it's not going to be
80:05 - able to create a new BET with the right
80:07 - public key all right so the seeds this
80:10 - takes in is going to be into state or
80:13 - sorry constants we're going to say Pub
80:16 - uh which we call this it should be
80:20 - I can just be bed seed so there's a pub
80:22 - const bet seed and it's gonna be similar
80:26 - it's gonna be and you ate oops
80:31 - [Music]
80:32 - is equal to Binary string
80:37 - and say a bit
80:39 - and semicolon
80:41 - cool oh and this should be Capital bad
80:43 - seat
80:45 - nice so now we have that it's already
80:46 - being imported so now for the create bet
80:49 - we're still back in Korea but we just
80:51 - want to say uh bet here bet seed
80:57 - seed not not seed but
81:02 - okay there is one more thing that we
81:04 - need we need to have the Masters last ID
81:07 - right so this is different than last
81:09 - time right we have the binary string bet
81:12 - and the master's last ID so if it was
81:14 - zero this would be the publicly if the
81:16 - last video is one two right so it's
81:18 - Unique every time depending on the last
81:20 - ID
81:21 - okay so it's going to be and
81:26 - master that last
81:29 - bit ID you can't just write Master last
81:32 - bit ID because you need to format it
81:34 - like so plus one
81:36 - and then you say dot two
81:39 - lip bites you have to convert this into
81:41 - bytes
81:42 - because that's what the seeds need to
81:44 - read it
81:46 - okay and then this should be come right
81:48 - here boom
81:51 - all right so we'll check on the facts
81:53 - give us any errors later on but we also
81:55 - need to add bump right because if it
81:56 - exists go to the next available public
81:59 - key
82:00 - cool so now you know good thing we did
82:03 - that because now remember to get the
82:05 - when we enter the bet
82:08 - to get to the bet that we want we need
82:10 - to get it by seats all right so that's
82:12 - the purpose of seeds you can also
82:14 - get the public key you want by putting
82:16 - in the matching seeds all right so to do
82:19 - that we'll say Bad Seed all right
82:24 - let's put in the bed ID because the BET
82:25 - ID is the same as that last Master uh
82:29 - bet ID
82:31 - all right the last one so let's do end
82:33 - that's that ID and we gotta convert this
82:35 - to bytes again so that to l e bytes
82:39 - [Music]
82:40 - and then to uh method there you go
82:44 - all right don't forget to add bump here
82:46 - then there is some constraints
82:48 - some seed constraints so we gotta say
82:50 - constraint is equal to
82:52 - validate enter underscore bet and you
82:57 - say and
82:58 - uh asterisk bet
83:01 - you can say at bet error
83:06 - can't
83:08 - enter right
83:10 - so basically if there is already some
83:13 - the bet is already entered you cannot
83:15 - enter that bed so this is an error
83:18 - better that we need to grab and create
83:20 - and this is another thing in our utils
83:22 - function
83:23 - okay so we'll come back to that in a
83:25 - second
83:26 - but let's just write out the rest of
83:27 - this it says Pub BET right all of this
83:29 - information is in this bet and what is
83:33 - the type of it it's an account that
83:35 - already exists it's info
83:39 - and then
83:41 - cool next thing we need is going to be
83:43 - the player right
83:46 - so there's no account for player it's
83:48 - just going to be stored
83:49 - as the signer right Pub player is the
83:53 - signer
83:58 - [Music]
84:00 - the assistant program right we always
84:02 - need this one system program is the
84:04 - program
84:08 - and look at the system
84:10 - nice cool cool so that is the enter bet
84:14 - struck where we didn't have to make a
84:15 - new account uh we do need to work on
84:17 - this part though so remember we got to
84:19 - check if
84:20 - uh player B is allowed to enter this BET
84:23 - right so we can go back to our utils
84:25 - we're gonna make a new function again
84:28 - say Pub FN uh validate enter underscore
84:33 - bet and it's going to take in the bet
84:36 - and bet
84:38 - and it's gonna be a Boolean here
84:42 - okay and essentially this is what we
84:45 - were going to return a Boolean and we're
84:47 - gonna get that Boolean by saying bit
84:49 - prediction
84:51 - right underscore B dot is
84:54 - none
84:56 - okay and then you can enter here and
84:59 - I'll just say end and
85:01 - we gotta check for the expiration so
85:06 - basically what I want to say is let's
85:08 - say player a makes a bet for AMC and he
85:12 - says it's going to go up within two
85:15 - minutes right
85:17 - you can kind of cheat that bet right if
85:19 - you think about it you can look at you
85:20 - can stare at this and if there's like
85:22 - two seconds left I want to say oh the
85:24 - price actually is 3.9 right you'll have
85:26 - a more accurate guess if you bet later
85:28 - so we shouldn't make an expiration time
85:32 - right
85:34 - so to make that expiration time we can
85:37 - just head over to Constance and make it
85:40 - right so
85:41 - uh let me just write that comment the
85:43 - closer
85:45 - we are to the expiry
85:49 - the more chances a player has to win
85:52 - right so we want to make an expiration
85:55 - time to make it more fair right we can
85:57 - add even more logic to like check for
85:59 - that but again this tutorial will be way
86:01 - too long but if you do want to see that
86:03 - comment down below and see like a
86:04 - full-on uh like full scale build of a
86:08 - betting system so let's go adjust this
86:11 - to make it more fair
86:13 - right so what I mean by that is we can
86:16 - say Pub const it's a really long
86:19 - variable minimum
86:22 - remaining
86:25 - time until
86:28 - expiry
86:31 - right and to get this you can use
86:34 - um
86:34 - printing another Library
86:41 - honestly don't even need Prelude here
86:42 - and it's going to be unused so let's
86:44 - actually get Solana program
86:46 - yeah we need this Library instead
86:48 - program
86:50 - inside program there should be a clock
86:52 - inside the clock it should be you next
86:55 - time stamp that's what we need
87:01 - yep okay so then now we can say Unix
87:05 - timestamp here
87:09 - okay oh sorry and set this equal to uh
87:13 - 120 seconds right so the last 120
87:16 - seconds
87:17 - they can't enter the BET right uh we can
87:21 - adjust this to make it more fair you can
87:22 - say like oh after one hour before the
87:24 - bet you can't enter the bet anymore
87:26 - all right so this is essentially like a
87:28 - minute
87:29 - okay so I think it's a pub const
87:32 - maximum
87:33 - claimable period
87:37 - right
87:38 - since we're here this one is for let's
87:41 - say somebody wins they should be able to
87:43 - claim the money
87:44 - all right after a certain amount of time
87:46 - uh
87:48 - the money will
87:50 - actually just go to the user or be given
87:52 - back to the user right
87:55 - cool so maximum claimable period
87:57 - 300.
87:58 - [Music]
88:00 - okay so we have that we would really
88:03 - care about though right now is this one
88:04 - right here so let's go back to the lib
88:07 - and go back to our validate interpet
88:11 - and now that we made that variable and
88:14 - we're importing it here still we can use
88:16 - it so Twitter was I again now they bet
88:20 - we need the expiry expiry I can't forget
88:23 - the underscore
88:25 - and minus
88:27 - all right so the the time that the bed
88:29 - expires minus the minimum
88:33 - remaining
88:34 - time until expiring right there could be
88:38 - a better name but it's what we got is
88:40 - greater than the get
88:42 - Unix
88:45 - timestamp
88:48 - there you go right so this is how we can
88:50 - validate if player B can enter the bet
88:54 - or not all right it's going to be true
88:55 - or false right that's what is running
88:59 - right here so we're gonna have a
89:02 - constraint we're gonna check okay can
89:03 - player B enter the BET yes all right if
89:07 - he can't
89:08 - if it's false then we need to run this
89:10 - error this bet error right but right now
89:12 - bet error doesn't exist so we can make
89:15 - the error so to make an error
89:18 - we can have a file to have all of our
89:20 - errors so we can say error.rs
89:23 - and inside this this is the one that's
89:25 - going to use anchor Prelude so I'll hit
89:26 - oops
89:27 - let's see if I can use their import here
89:30 - nice
89:31 - and to set up your error codes which you
89:33 - can do in Solana is error underscore
89:36 - code and then say Pub enum bet
89:40 - ever like that
89:42 - okay
89:43 - so next we can do hashtag
89:46 - array
89:48 - oops
89:50 - and then just do message right so we're
89:53 - going to send a message and it's going
89:54 - to be can not enter
89:58 - right and the the name of this error is
90:01 - going to be cannot enter right so what's
90:04 - happening now
90:06 - uh is in here we're gonna the constraint
90:10 - of entering the bet is we check if this
90:12 - is true or false
90:14 - if they could enter the bet if it's
90:15 - false and there's going to be an error
90:18 - and the name of that specific error is
90:20 - the cannot enter one
90:22 - right and one thing we should do is
90:24 - import error as well so let's get mod
90:27 - error.rs oh sorry error
90:30 - and we need to put this in here as well
90:32 - so comma error
90:34 - colon star
90:37 - okay I think we are good
90:40 - uh we do need to finish up the rest of
90:42 - the
90:44 - what's it called the rest of the
90:46 - functionality of interbet so let's go
90:49 - ahead and do that
90:50 - so we finished the struct we're on the
90:52 - functionality now uh the context is the
90:57 - enter bet struct
90:59 - so we can add that right now enter
91:02 - bet
91:03 - the price is something that we're going
91:05 - to input through the front end and we
91:07 - say f 64.
91:09 - like it's going to be in USD right
91:11 - [Music]
91:13 - or like at least a decimal so it's
91:15 - float64 and let's get the BET into a
91:18 - variable and we need something here guys
91:20 - do you remember
91:21 - yes exactly good job Jeffrey it's and
91:24 - mute ctx.accounts.bet
91:28 - okay
91:29 - but that prediction underscore B
91:33 - is equal to right because this is for
91:35 - the the whole purpose of this function
91:37 - is for prediction B
91:38 - and remember prediction B
91:41 - um what is it again it has
91:44 - or state it has bet prediction and it
91:48 - starts off as an option right so we got
91:49 - to keep that in mind and so it's going
91:51 - to equal to sum
91:54 - bet prediction
91:56 - and kind of like how we set up the
91:58 - prediction a when and creating a bet
92:01 - you're gonna do the same thing so the
92:03 - player is going to be the player that's
92:05 - entering so that's the CTX that accounts
92:07 - that player and then we need their key
92:10 - so that's how you get their key again
92:13 - and then we need the price right so
92:15 - we're taking our argument and placing it
92:17 - here
92:19 - okay
92:20 - and then we should update the BET state
92:22 - to equal the bet
92:25 - state of started right where is this pet
92:29 - State started coming from guys all right
92:31 - if you remember our state
92:32 - we made that right here it's an enum
92:34 - which which means it could either be
92:36 - created started or any of these
92:39 - cool so the BET state is equal to
92:41 - started right we're not done yet though
92:43 - because when you enter a bet you gotta
92:45 - give us some soul to enter right we're
92:47 - gonna match the price so if it's two
92:48 - Soul give me two Soul so transfer
92:51 - the amount to the bad PDA once again
92:58 - uh-huh and then we do the system
93:00 - underscore program let's get the
93:02 - transfer in here
93:04 - and let's run that and we can say CPI
93:08 - context so it won't forget the T this
93:10 - time the new
93:11 - [Music]
93:12 - and pass it oops pass in these arguments
93:17 - which is going to be the
93:20 - System Program so to get that is ctx.com
93:23 - System Program
93:27 - dot two account underscore info
93:33 - okay and then in there we're going to
93:35 - say System Program
93:38 - transfer
93:42 - all right and so here we'll do the
93:44 - transfer we need the from and two so who
93:46 - is this from this is from player B which
93:48 - is
93:49 - the person signing so we can say card
93:52 - accounts.player.2
93:55 - count underscore info
93:58 - and it's going to go to the betpda
94:02 - right so the better count
94:04 - so it's gonna go to that bed account
94:07 - okay comma here comma here right bet dot
94:11 - amount I go with the amount that goes in
94:13 - and we do need this question mark
94:17 - and there we go
94:19 - uh last thing we do need though is the
94:21 - okay
94:23 - and boom
94:25 - all right this okay if you don't know uh
94:28 - you can think of it as a return so if
94:29 - this function is all done and it's good
94:31 - you can return like the number five
94:33 - right I don't know how you do that but
94:34 - you don't need to we're gonna put
94:36 - nothing in here because all the
94:38 - functionality is happening right here
94:40 - [Music]
94:42 - okay
94:44 - looks pretty good to me
94:47 - um that should be interbet let's just
94:49 - build this and check for any errors
94:51 - which is normal
94:54 - right if there is a time that I never
94:56 - had errors I get so happy so prediction
94:58 - B
95:01 - uh
95:03 - some
95:04 - bet
95:06 - okay something wrong I might be the
95:08 - spelling yeah predict cyton
95:11 - prediction B
95:15 - and
95:17 - let's go build successful again don't
95:20 - worry about all these warnings right you
95:22 - can build even though the warnings are
95:24 - here it's just letting anchor letting
95:26 - you know like hey uh you wrote this but
95:27 - you didn't use it but we're all gonna
95:29 - use it eventually right
95:31 - so I'm just setting some stuff up so
95:33 - build is done that is entered in all
95:35 - right so we have enter bet let's get
95:37 - started on claiming BET right because
95:40 - what we have so far logic wise is we can
95:43 - you know create a bet put duration on
95:46 - the price player B can now enter it but
95:48 - now once the bet is over we need a
95:51 - function that's going to let us claim
95:53 - that said bet so once again how do we
95:55 - make a function it's just Pub FN and
95:58 - then the function name right from here
96:00 - you need to put the parentheses for the
96:01 - argument the arrow and then result boom
96:06 - okay and then after that Charlie
96:08 - brackets to put the scope and the only
96:10 - thing that we're going to need for the
96:12 - argument is going to be CTX right and
96:14 - we're going to Define what the context
96:16 - type is in just a moment all right so
96:18 - the first thing we're going to do is
96:20 - scroll down to the bottom right here and
96:22 - let's find and create claim bet all
96:25 - right so we have enter BET right here
96:27 - and then we need to claim bit all right
96:29 - so claiming bet
96:30 - how do we start this all right the first
96:32 - thing we need to do is get the accounts
96:34 - that are relevant for the function right
96:35 - so to derive accounts we need to say
96:38 - derive
96:41 - accounts right and what accounts do you
96:43 - think we'll need for this BET right
96:44 - after I write the name so as I'm writing
96:46 - this think about that Pub struct claim
96:52 - okay and then we need this info here
96:54 - info
96:56 - and color brackets all right from there
96:58 - we can do the account that we need and
97:01 - you guessed it it's going to be the BET
97:03 - account right so we don't want to
97:05 - initialize an account so we don't need
97:06 - to write init here we should write
97:08 - though mute right and then how do we get
97:11 - the specific bet that we need we need to
97:14 - put in the seeds all right so to put in
97:16 - the seeds we're gonna do a seed equals
97:19 - oops C equals and then we have to say I
97:22 - believe bet underscore seed
97:25 - comma and then we have to say the and
97:28 - bet dot ID Dot and turn this into bytes
97:33 - so do two underscore Le bytes and that
97:37 - is a method so parentheses boom and that
97:39 - should give us the bet that we enter uh
97:42 - and then boom right and then the
97:45 - constraint so there is also a constraint
97:47 - here oh compataro right constraint
97:52 - so what's the constraint here well we
97:54 - need to validate the enter the not the
97:57 - intimate the claimed like can we claim
97:59 - this bet that's what we need to validate
98:00 - so we need to go back into our utils and
98:03 - let's create that function real quick
98:05 - so I'm going to go under here and say
98:07 - Pub FN validate right this time the
98:11 - claim but can we claim this BET right so
98:14 - there's two things you need to think
98:15 - about one is uh
98:18 - is the is this over right is it expired
98:21 - is the BET expired can we still claim it
98:23 - is time not up yet if it is up we
98:28 - shouldn't be able to claim it right if
98:29 - the bet is two minutes long and it's
98:31 - only been 30 seconds I can't claim this
98:33 - BET right you should get an error for
98:34 - that which is like six thousand and two
98:36 - I believe
98:38 - Okay cool so what we can do to check
98:40 - this is a match statement and say
98:43 - bet.state
98:44 - all right
98:46 - if the bet that state bet State colon
98:50 - colon started
98:52 - and if you're wondering what uh BET's
98:54 - date is if you go back to our state.rs
98:56 - we made bet prediction and we made bet
98:58 - state so what are the couple different
98:59 - states we can have created started right
99:02 - so which one do we need
99:04 - right so let's go back to our utils so
99:07 - if the bet is started right what does
99:10 - that mean
99:12 - okay then say equals Arrow
99:15 - and then curly brackets
99:17 - all right so if the bed is started let
99:19 - current timestamp or TS equal to get
99:24 - Unix timestamp all right get the current
99:27 - timestamp with this method
99:29 - okay and set that to current TS
99:31 - and don't forget the semicolons here
99:33 - and what we need to check for is this
99:36 - variable let's say let time past
99:40 - since expiry
99:43 - right is equal to the current time so
99:46 - the current underscore TS minus the when
99:50 - the BET expires because the bet that's
99:51 - another condition you think about the
99:53 - bet is expired uh we shouldn't be able
99:55 - to claim it anymore
99:56 - expiry dot oh underscore TS
100:01 - okay
100:02 - and then uh if zero is less than the
100:07 - timed past
100:07 - [Music]
100:12 - expiry and oops and the time passed
100:18 - since
100:20 - expiry that would mean it is less than
100:23 - or equal to less than
100:26 - or equal to
100:29 - I wonder if I do this
100:31 - yeah there you go that's the symbol we
100:32 - need maximum
100:36 - claimable period right we're checking if
100:39 - this total statement is less than the
100:42 - claimable period because if it is we
100:44 - should still be able to claim it if it's
100:46 - not then this will return false which
100:48 - means we cannot claim it right so that's
100:52 - what's Happening Here we can do a comma
100:56 - and then we have to do a dash I believe
100:59 - what underscore then do equals Arrow
101:02 - false
101:03 - and then come cool so that's how we can
101:06 - get it to be false and then if that's
101:07 - false then we get the Boolean false as
101:10 - well
101:10 - [Music]
101:12 - let's go that's going to be the validate
101:14 - claim bet which means we can come back
101:16 - to our lib.rs and actually use that
101:18 - function we just created which is going
101:20 - to be validate
101:23 - oops valid date claim
101:27 - underscore bet okay and then it should
101:29 - be like a and star
101:32 - but just like before up here and the BET
101:35 - error that we want is cannot claim so at
101:38 - bet error
101:41 - cannot oops
101:43 - cannot claim it means let's make just
101:46 - sure we have that error so check error.s
101:48 - we do not have cannot claim so we need
101:51 - to create it right so put a comma here
101:54 - oops I need to put a message
101:57 - that says
101:59 - [Music]
102:02 - I cannot
102:03 - clean
102:04 - all right so now it exists after we
102:06 - Define it
102:07 - [Music]
102:09 - okay and there's a couple different
102:10 - errors that we're going to need since
102:11 - we're here and you get the idea I'm
102:13 - going to do the rest of them now so
102:14 - let's do another message
102:17 - this one's going to be cannot close
102:18 - right
102:19 - [Applause]
102:21 - [Music]
102:23 - okay not close
102:26 - okay uh there's a couple other error
102:29 - messages where it's gonna be like if you
102:31 - have an invalid pith key so we can say
102:34 - given
102:36 - key for the pyth count I'm always saying
102:40 - the different way to say it does not
102:42 - match right so let's say you're right
102:45 - you put in the Amazon stocks key and
102:48 - then later you're trying to use Google
102:49 - it's gonna know it's gonna be like
102:51 - that's not the same one so then you say
102:53 - invalid
102:54 - this will help us troubleshoot
102:57 - okay there's another one
103:00 - message
103:01 - uh there's also another invalid pith
103:03 - account right
103:06 - so we can say invalid
103:09 - fifth account
103:12 - my hands doesn't need to be capital
103:18 - invalid
103:21 - count this one has to be capital
103:24 - one last one I believe it's gonna be the
103:26 - price is too big to parse right because
103:29 - if you remember when you create a bet
103:30 - you parsed it with u64 right so if I go
103:34 - to state
103:36 - yeah u32
103:40 - so this is the limit of the space so we
103:43 - don't want to do anything bigger than
103:45 - that and just to be safe we need to put
103:48 - it to 32. so we can say uh this error
103:52 - happens when
103:54 - price is too big to parse to you 32
103:58 - right
103:59 - even that's the limit is u64. we don't
104:01 - want to hit that limit right so we can
104:03 - just say a price too big
104:05 - [Music]
104:07 - all right
104:09 - cool so we might not use all these
104:11 - errors but we're definitely going to use
104:12 - these three for sure but this if you
104:14 - want to add more unique errors for other
104:15 - situations because there's a lot of
104:17 - Logics in a fully functioning lottery
104:19 - app make sure to add them here so this
104:22 - is all the errors and now back to the
104:24 - lib.rs this bet cannot claim error is
104:29 - gonna run now because it exists and all
104:31 - I have to do is put a comma here
104:33 - and the whole point of this oops the
104:36 - whole point of this was underneath this
104:38 - whole account information
104:40 - we're gonna set up the bed so we're
104:41 - gonna say Pub BET right and the type is
104:45 - an account
104:46 - info
104:48 - and a bit and now I'll put the
104:50 - apostrophe in a second
104:52 - there we go all right we're good and
104:54 - then a comma here
104:58 - to set up the pyth Oracle account right
105:01 - the pith price Oracle account so we can
105:03 - say say like this
105:06 - all right because remember each of these
105:08 - is an account as well so there's an
105:10 - account for AMC and it's going to
105:11 - contain a price and in in the back end
105:13 - this is constantly updating to the
105:16 - latest price so for here to get that
105:18 - account we have to put parentheses and
105:21 - don't press init because that's making a
105:22 - new one we're going to say the address
105:24 - of this account that we want
105:27 - is gonna be the BET right because now we
105:30 - have access to the bed account if in
105:32 - this truck the BET dot uh sorry bet that
105:38 - dot pith
105:40 - underscore price underscore key and then
105:43 - there we go all right so how did we know
105:46 - that this is where the pith price key is
105:48 - well if you go back to your state
105:50 - there is a attribute or property where
105:52 - we store that and it should be there
105:54 - after you create your bet right so you
105:58 - can say is equal to that
106:00 - and then you can say at bet error right
106:04 - because what does this do it means that
106:05 - if
106:07 - there's an error here it's probably
106:09 - because uh it's an invalid
106:14 - right so that's why I made those errors
106:17 - and then from there uh we can say Pub
106:19 - pyth or pith account info boo
106:25 - so essentially get me the address of the
106:30 - bet.pets price key and if it's not the
106:32 - same then we'll get the invalid
106:35 - or it's not correct it's going to be the
106:37 - invalid error
106:38 - next thing we need to initialize is both
106:40 - players so let's get their accounts as
106:43 - well or their the part of their accounts
106:46 - which is going to be account
106:47 - mute and their address
106:50 - is equal to the BET oops bet dot
106:55 - prediction underscore B
106:58 - dot as underscore ref
107:01 - dot unwrap right because whenever you do
107:03 - this you have to unwrap it and then you
107:06 - get the player from that bet all right
107:08 - so we're going to the bed account and if
107:10 - you remember in the bed account there is
107:12 - a uh prediction bet prediction here
107:15 - there's two actually one for a and one
107:16 - for B so we need the one for
107:20 - a right so this is for B
107:23 - so let's do one for a actually I'll come
107:25 - back to that because that's for B and
107:26 - I'm thinking about it so we need to
107:27 - count
107:28 - address is equal to oh sorry mute this
107:32 - could be different
107:34 - address is equal to
107:36 - but that prediction and how do we get a
107:40 - a DOT player
107:43 - yes and then from here we could say Pub
107:45 - player underscore a
107:48 - is equal to account info
107:50 - all right because we just want the info
107:52 - of this account
107:54 - apostrophe
107:56 - not quotes
107:58 - info
108:00 - keep pressing that
108:03 - okay in oh there we go
108:07 - then the comma
108:10 - after here
108:11 - cool so that's player a and this is
108:14 - player B and the reason why I did this
108:15 - for player B is because they they are in
108:18 - an option so we're gonna unwrap it first
108:20 - get the then get the player
108:22 - [Music]
108:25 - oh man this one's gonna be Pub player
108:27 - underscore B is equal to count info
108:34 - what's going on Pub player
108:38 - foreign
108:39 - oh it's not equal sorry colon
108:42 - colon account info
108:46 - info
108:48 - .com
108:49 - hey there you go cool and uh the next
108:52 - thing we need is the things that we
108:54 - always do every time we create a struct
108:55 - which is identify the signer who's
108:57 - signing this transaction and the system
108:59 - program so honestly we could just copy
109:02 - this
109:02 - [Music]
109:05 - and paste it right here
109:08 - and hit save oops we don't have to save
109:11 - it like that
109:12 - and then the player right this is gonna
109:14 - be confusing because there's two players
109:15 - we can just change the name of this to a
109:18 - signer
109:19 - signer and System Program can stay the
109:23 - same and with that said that is the clan
109:27 - bedroom struct right so we have all the
109:29 - account information we're accessing
109:31 - player a player B within the struct
109:33 - let's bring that struct into our
109:35 - function right as context and say
109:38 - context
109:40 - Arrow
109:42 - claim bet
109:45 - and let's start working on the function
109:47 - itself so this function has a lot of
109:49 - logic that goes into it because not only
109:52 - does it need to run a couple checks it
109:54 - needs to take the money right from that
109:56 - third-party escrow account the BET
109:58 - account to the winner and that winner
110:00 - could be player a or player B and we can
110:03 - also need to check for can they even
110:05 - claim it so let's go ahead and work on
110:07 - that function now all right so now we're
110:09 - working on claimbet and what I want to
110:11 - do is write a couple comments so that we
110:13 - can identify each section so the first
110:15 - uh thing that we should think about is
110:17 - check the winner and send the prize
110:22 - to the winner
110:23 - or return them back if it's a draw right
110:29 - because that's also a possibility right
110:31 - so how can we do that well first what
110:33 - we've done before was set a variable and
110:36 - set the account in that variable so
110:38 - let's do the same thing again so let's
110:40 - set the bed right it's a variable equal
110:42 - to and mute right and mute
110:47 - CTX right our context argument and from
110:50 - that object you can get the accounts and
110:52 - the account that we want is the BET
110:54 - awesome
110:55 - Okay cool so we have the better count
110:57 - and what is the prize Well the prize is
111:00 - let prize is equal to oops
111:04 - to bet.amount dot checked Mo to
111:10 - uh dot on rap
111:12 - okay
111:14 - and then from there we can do this right
111:16 - here
111:17 - bet dot two account oops account
111:20 - info under uh parentheses Dot
111:24 - fry
111:26 - borrow all right try borrow mute Lan
111:30 - ports
111:34 - equal to the price
111:37 - all right this is important that we do
111:38 - this because we need to figure out how
111:40 - much the prize was so we can do that by
111:42 - getting the BET amount right and then we
111:45 - can go into the bed accounts info and
111:49 - get the all the Lan ports that we put in
111:51 - there we're going into the third party
111:52 - account and subtracting it by the prize
111:55 - which should be the whole thing that's
111:57 - in there or that we put into there
112:00 - and then from there let's get the pith
112:02 - price because we need to determine the
112:04 - winner right so we do that by saying let
112:07 - pith or pyth account info
112:10 - is equal to and CTX Dot accounts.pit
112:17 - okay cool
112:19 - so then let's say the feed right so we
112:21 - gotta load the price feed now
112:23 - right because if you remember this this
112:25 - right here is updating constantly so we
112:27 - need to know as you can see it's like
112:29 - moving slightly
112:31 - we need to know what the the current
112:33 - price is at the moment so we said load
112:35 - price underscore feed from underscore
112:39 - account underscore info
112:41 - pith underscore account underscore info
112:46 - and then you can add a DOT map here
112:48 - right after.map
112:50 - uh map error sorry
112:52 - error
112:53 - and then this bar oops
112:58 - okay I learned a lot of this from
112:59 - looking at the documentation and testing
113:02 - so oops let me do this
113:05 - and then you can say space error
113:09 - exclamation point and then if there's
113:12 - anything that goes wrong we say bet
113:14 - error you got the invalid
113:18 - python remember that error we made
113:20 - earlier so we're going to use it here
113:23 - if that error exists all right so if
113:25 - it's good it doesn't there's no error we
113:27 - can keep continuing so we say price data
113:29 - is equal to feed dot get price on
113:34 - checked all right so now we can get the
113:36 - price in price data and I'm gonna hit
113:38 - enter again
113:40 - and let's do a require here and we need
113:43 - the price dot data dot price right so
113:47 - yeah and then a less than equal to again
113:49 - for f64 that float 64. and the max that
113:55 - it can accept
113:58 - as
113:59 - signed into juror 64.
114:02 - comma
114:03 - bet error right so remember the price
114:05 - too big error that we made so we're
114:06 - gonna do that here
114:08 - so here's another check
114:10 - price is
114:12 - too big too big
114:15 - cool so first we're checking if it's a
114:17 - valid pith account then we're checking
114:19 - if the price is too big and then we can
114:23 - after all that's good we know that the
114:24 - pith price now
114:26 - fifth price
114:28 - is valid and it's equal to this variable
114:31 - which is going to be the price data dot
114:35 - price and make sure it's as a f64.
114:40 - okay and then now we can put in the
114:42 - message here
114:44 - for ourselves so we say pith price is
114:48 - colon and then if you put this curly
114:50 - bracket here it's Gonna Fill this is
114:52 - kind of like a placeholder right where
114:55 - if I put a pith
114:58 - dot price here it's gonna take whatever
115:01 - the price is so let's say the price is
115:02 - like two dollars it's gonna put this in
115:04 - the code bracket and the message will
115:05 - need that the price is to Solana or to
115:08 - sold or two dollars whatever it is cool
115:13 - now we need to adjust
115:15 - prices to compare them with pits price
115:21 - right so we need to compare the guesses
115:24 - essentially that player a and player B
115:26 - wrote and compare it to the current
115:28 - price and see who's the closest right so
115:30 - this is another place with a lot of
115:32 - checks okay
115:36 - and then we also want to just make a
115:38 - note here real price
115:40 - is equal to pith
115:42 - price
115:45 - times 10. this is something that took me
115:46 - a while to figure out but there's
115:48 - something called pith exponent and
115:50 - that's just the conversion that we need
115:51 - to compare all right so the real price
115:54 - is this the real price of the stock is
115:56 - this price time step
115:58 - you guys keep that in mind so we can say
116:00 - the mult we can store that multiplier in
116:02 - a variable I'll call multiplier is equal
116:05 - to uh 10 F 64 dot p
116:10 - o w i
116:12 - and then you can say Dash price
116:15 - underscore data dot Expo right yeah
116:18 - there's going to be a lot of
116:19 - troubleshooting after this because this
116:21 - is where their apple can go wrong most
116:23 - of the time so you're gonna might be
116:25 - here a while
116:27 - cool that multiplier is equal to that
116:29 - and then we could say we need to get the
116:31 - player a and player B's adjusted uh bet
116:35 - prediction so we can say let
116:38 - adjusted
116:40 - player a is what I'll call it
116:43 - equal to bet Dot prediction underscore a
116:48 - DOT price times the multiplier
116:53 - okay and then we could do it let
116:56 - adjusted player B
116:59 - is equal to bet that
117:01 - prediction underscore B
117:04 - Dot and this is the one that's in the
117:06 - option right so we have to do the B dot
117:09 - as ref dot unwrap it first
117:14 - and then we could do a DOT price
117:17 - yep and then times it by the multiplier
117:19 - to get it to compare to the pith price
117:23 - and multiply
117:26 - nice okay now we can say the message
117:28 - here just for sanity's sake
117:31 - and say the adjusted player a prediction
117:35 - is now
117:38 - this right and then what we're going to
117:40 - put in the color brackets is this
117:41 - variable player a
117:44 - cool okay same thing here I might just
117:47 - copy and paste it to save some time
117:49 - [Music]
117:52 - and just make sure you change this from
117:54 - player A to B and this should be player
117:57 - b as well
117:59 - okay
118:00 - awesome
118:01 - now we have to uh compare the price
118:03 - who's the closest so we need to do this
118:07 - by saying another variable let ABS
118:09 - player all right a is equal to
118:12 - parentheses here fifth price or what the
118:16 - pith price is minus the adjusted
118:20 - oops adjusted underscore player
118:23 - underscore a and then dot absolute abs
118:28 - and then same thing player B ABS player
118:31 - B is equal to pith underscore price
118:35 - minus adjusted player
118:38 - B
118:39 - dot abs and then whoever is closest
118:42 - should win so
118:45 - how do we check for that well we're
118:47 - going to need an if statement here if
118:49 - ABS player
118:51 - a
118:52 - is less than
118:54 - ABS player B
118:57 - who should win guys all right think
118:59 - about that for a second if the
119:01 - difference of the pith price and the
119:02 - adjusted player is less than the
119:04 - difference of this and player B
119:07 - who should win
119:09 - all right well if the the price adjusted
119:12 - price is lower that means there's less
119:13 - of a difference which means it's the
119:15 - closest right so then you can say if
119:18 - uh this is true
119:19 - [Music]
119:20 - the winner is
119:22 - drum roll winner is player a and then
119:26 - you can say sending uh this much lamp
119:28 - ports right because all everything
119:30 - that's happening here is done through
119:31 - Lan ports
119:34 - and then later we gotta convert that to
119:36 - Seoul when we uh give it to the player
119:39 - and then comma
119:40 - uh the thing we'll put in the curly
119:42 - brackets is the prize
119:45 - okay
119:46 - cool
119:48 - so now we can do a bit dot state is
119:51 - equal to
119:52 - but state right we gotta change the
119:55 - state because it was it was started but
119:57 - now if the player a wins we have to say
119:59 - the state is player a one
120:03 - if you've got an error here it's because
120:05 - you probably spelled it wrong
120:07 - okay and then now we have to update the
120:10 - CTX account so we can say CTX oops CTX
120:13 - and I'm gonna hit enter here and then
120:15 - tab so that I can format it like so that
120:18 - accounts nope
120:20 - dot player a right so I'm just going to
120:23 - my contacts I'm getting the accounts I'm
120:24 - going to the player a and I'm going to
120:27 - get the account info in there
120:29 - so uh oops
120:33 - so to get the account info I'm gonna say
120:35 - dot to account info
120:39 - then let's get the Lan ports try
120:42 - borrow
120:43 - mute Lan ports
120:47 - question mark If there is landports plus
120:49 - equals prize
120:52 - let's go cool all right you with me so
120:55 - far guys
120:56 - if that's the case it's gonna add uh get
120:59 - Lan Port from this equal to the and add
121:02 - it to the prize variable
121:04 - and then we can close it off so where is
121:08 - the closing one for this it's right here
121:10 - because now we need an else if what's
121:11 - going to be the else if condition
121:14 - I'm gonna give you guys three seconds
121:15 - three two one right the lsif is the
121:18 - opposite right so which is ABS player B
121:21 - is less than uh ABS player underscore a
121:26 - all right and then this is going to be
121:27 - the same thing uh we can copy this
121:29 - message and the BET State actually
121:32 - [Music]
121:35 - accept change this to player B make sure
121:37 - you change it and the BET state is not
121:39 - player A1 it's gonna be player B1 okay
121:43 - cool and then from there uh same thing I
121:46 - need to go into the context again so CTX
121:48 - and then I'll do this format
121:52 - oops dot accounts or in the accounts
121:55 - [Music]
121:57 - now we can go into player B but remember
122:00 - player B
122:02 - should be option but then we can just
122:05 - get the account info because we
122:08 - got it before to account info of player
122:12 - B
122:15 - and then let's try to borrow
122:18 - try
122:19 - borrow
122:21 - mute and then get the lamp Port then
122:24 - plus equals prize as well
122:26 - Okay cool so we have the situation for a
122:28 - you have the situation for B
122:33 - oh yeah there is an else statement right
122:35 - because the last possibility is what
122:37 - it's the draw right so then we can say
122:41 - and what should happen in the drop right
122:43 - let's think about this in a draw
122:44 - everyone just gets their money back
122:46 - right let's for say whatever reason you
122:47 - have the same exact guest and you're the
122:49 - same distance from the uh real price
122:52 - then we can set up a variable called
122:54 - Draw amount is equal to the BET dot
122:57 - amount right
122:59 - and then you can say
123:01 - message here
123:03 - and let them know it's a draw draw
123:05 - sending both players
123:11 - lamp ports oops you don't need to put
123:14 - this in color brackets lamp ports okay
123:17 - and then what is in that color bracket
123:20 - you can put the draw amount so sending
123:22 - both players like two Souls the the
123:25 - price to match is to sold and then uh
123:28 - the winner would usually get four but in
123:31 - a draw they just get two they both get
123:32 - two
123:33 - [Music]
123:35 - so the draw amount is here and then
123:37 - semicolon we say the BET dot state but
123:42 - that state is equal to bet State colon
123:46 - draw
123:47 - cool yeah like I said there's a lot of
123:49 - checks in this lot in this uh bet
123:52 - prediction app
123:53 - um again there was a way it can get even
123:55 - more insane right depending on uh the
123:58 - complexity right so this is a simplified
124:00 - version actually so let's return both
124:02 - players
124:08 - all right
124:10 - okay so let's return it so we have to do
124:12 - this twice so CTX
124:15 - [Music]
124:17 - dot accounts let's do player a
124:22 - player a oh underscore a
124:26 - dot two underscore account info
124:34 - and then try borrow mute Lan ports
124:40 - there is available Plus
124:43 - equals draw amount so we're both sending
124:46 - them the two
124:49 - okay
124:51 - and then same thing here but we're just
124:52 - gonna do this for player B and since
124:54 - it's the exact same thing which is going
124:55 - to change one thing player a to player B
124:58 - uh we should be good to go so after that
125:01 - closing else statement I'm gonna hit
125:04 - enter and from here we can just say okay
125:10 - okay that was a hefty function
125:13 - um I'm gonna do is hit build and let's
125:15 - just troubleshoot this because I'm not
125:16 - sure if it's perfect or there could be
125:18 - some spelling errors or some semicolons
125:20 - I forgot so let's go ahead and do some
125:22 - troubleshooting all right let's see what
125:24 - we need to work on so let's do build
125:27 - and yep as expected so let's go over all
125:31 - these errors there's a lot right so the
125:33 - first thing is going to be missed match
125:35 - closing limiters that should be an easy
125:37 - fix going to line 222
125:40 - 222 and it might seem like a lot but
125:43 - maybe some of these are caused because
125:45 - of the first air right because that's
125:46 - how strict rust is so let's take a look
125:49 - and taking a look at this I can see that
125:52 - usually this has a closing parenthesis
125:54 - opening parenthesis and it doesn't close
125:55 - right here so let's close that off
125:58 - and let's just wonder One More Time
126:04 - okay so building here
126:06 - expected semicolon bound bit so again
126:09 - means we forgot semicolon line 114
126:13 - to do
126:15 - and the lib
126:19 - oh yes in our message we need to copy
126:22 - that and I'm pretty sure we did copy
126:25 - paste this so we need to make sure you
126:26 - copy paste the semicolon as well
126:28 - so did we do that yep here's a message
126:30 - and one hack is that you can actually
126:33 - clear the terminal by saying clear so we
126:35 - can start fresh all right easy on the
126:37 - eyes hit build
126:39 - okay
126:42 - expected a comma or a closing credit
126:44 - bracket but found an exclamation point
126:46 - again in our lib so 122
126:51 - oh see notice how this message here
126:54 - right isn't the same color as this
126:56 - message here right so that means
126:59 - there is something weird with this
127:05 - hmm trying to sit here think about what
127:07 - this is
127:09 - something to do with what's before there
127:12 - is a curly bracket for it oh I see there
127:15 - is a space here hey okay there you go
127:18 - awesome
127:19 - all right I forgot to put underscore B
127:20 - let's just clear this again hit build
127:24 - all right what's next
127:26 - so cannot find context in the scope
127:30 - that's interesting so let's go to 87
127:33 - and can't find a claim bet so let's just
127:36 - check down below did we have clean bet
127:39 - yeah we do
127:45 - oh did I write context wrong
127:49 - con oh context without the T so we need
127:53 - the T in there don't forget your little
127:55 - tea
127:56 - so let's go ahead clear
127:58 - hit build
128:03 - all right so we need 99
128:08 - yeah this is why it's good we're doing
128:09 - this now
128:11 - but require uh needs and exclamation
128:15 - point
128:19 - all right so let's add that exclamation
128:20 - point did we use require anywhere else
128:22 - here
128:23 - nope
128:25 - [Music]
128:26 - let's do it clear
128:29 - and build
128:32 - [Music]
128:37 - price
128:39 - 99
128:41 - yeah there's no such thing as price.data
128:43 - it should be underscored data
128:49 - okay
128:52 - I think build again
128:58 - good price not fine let's go cool so
129:00 - it's a lot less errors than before
129:03 - pith price is not found in scope and I
129:07 - should it's probably one of those things
129:08 - where it's like underscore price again
129:18 - okay 107
129:22 - cannot find
129:25 - multiplier spelling right
129:30 - yeah at least the the errors are not
129:33 - like code breaking so far it's just
129:35 - smelling
129:36 - uh
129:40 - 99
129:43 - and needs Max
129:46 - all right so I just took a moment to
129:48 - clear a lot of these spelling errors and
129:50 - semicolons the next thing that's not
129:52 - either of those things is this Arrow
129:54 - right here all right if you look closely
129:56 - it says uh could not de-reference that's
129:59 - what this star star is and it's in line
130:01 - 2124 so let's take a look we should be
130:04 - able to de-reference it because it
130:05 - didn't give us any problems in 116 right
130:08 - but it's giving us problems in 124. so
130:10 - let's take a look
130:13 - hmm okay so this looks like it's fine
130:18 - we are going into accounts player B to
130:20 - account info same try borrow Lan ports
130:23 - oh oh okay I see let's see if we add
130:26 - this semicolon here because we have to
130:27 - make sure
130:28 - that we're able to do that first
130:31 - awesome okay cool I think that fixed it
130:34 - yep needs a question mark here and now
130:37 - we just have the one error which is uh
130:39 - 219 and I feel like it's a spelling
130:42 - error which you guys know that we could
130:43 - fix so 219
130:46 - per dick saiton right this switching of
130:50 - the two letters can break your whole
130:51 - code but if you put it back to normal it
130:54 - should be good to go
130:55 - fingers crossed
130:58 - building come on one let's go build
131:01 - successful guys so that means no errors
131:05 - not even any warnings anymore notice
131:07 - that it's nice and clean all right we're
131:09 - using all the Imports that we have
131:11 - and now for one last function which is
131:14 - the close bet and then we can move into
131:17 - the front end and put this into an app
131:19 - all right everybody so we're on to the
131:21 - last function if you made it this far
131:23 - you guys are crushing it so really proud
131:26 - of you if you're here comment down below
131:28 - let's go so I know that you made it this
131:31 - far right we have one function left on
131:33 - the smart contract and that's gonna be
131:35 - the ability to close the BET account
131:39 - right because let's say uh you wanna you
131:42 - claim the BET already right you got the
131:45 - money you need to close the account
131:47 - right when you close the account these
131:49 - the the money that you spent to get
131:51 - Space there which is not a lot of soul
131:52 - in the devnet you get that money back
131:54 - right so you can do that by saying Pub
131:57 - FN close underscore bet
132:01 - and then we can say the arrow like so
132:04 - result
132:07 - and then curly bracket and then from
132:10 - here you can say the CTX and one rule is
132:13 - if you don't use the CTX in the function
132:15 - the context you have to put an
132:17 - underscore and we're not all right so
132:18 - let's quickly make the close bet struct
132:21 - so I'm going to come down below to the
132:23 - bottom and
132:25 - you guys know the deal by now you guys
132:27 - are Pros right spent almost an hour
132:29 - right at this point so we can say derive
132:32 - counts right derive accounts and then
132:36 - from there we can say enter name your
132:38 - struct which should be just close bet
132:43 - info curly bracket boom so this curly
132:46 - bracket represents the information of
132:49 - this struct so let's get what account do
132:51 - we need the better count so we say
132:53 - account right do we want to initialize
132:56 - nope we want to get the mute right
132:59 - because this could be different bets
133:01 - that we're closing so we need to make
133:02 - sure it's mutable the seeds how do we
133:04 - get the bet the exact bet that we want
133:07 - well you need to put in the string the
133:10 - binary string and then you got to pass
133:12 - in the ID and they should have different
133:14 - IDs right
133:16 - since we're incrementing it each time we
133:19 - are making a bet
133:20 - cool to convert it into bytes because
133:22 - that's what the seeds need to read and
133:24 - then we can say bump then we can say
133:27 - close is equal to play it right you
133:30 - haven't seen this one before close just
133:32 - like you knit when you're writing it
133:33 - initialize it this struct actually
133:36 - handles the closing of the account for
133:38 - you so you don't need to write anything
133:39 - so you can say close right it's equal to
133:41 - player meaning the player who created
133:44 - the bet or assigning is allowed to close
133:46 - so you can say
133:48 - and then we can make that functionality
133:50 - by adding this constraint here which is
133:53 - validate uh close bet and now do we have
133:56 - that in utils we do not so we do have
133:58 - one more utils function to make so let
134:00 - me just write this out uh it's going to
134:02 - be and oops reference this and then star
134:06 - bet comma player dot key parentheses
134:12 - and then you can have outside of this at
134:14 - the bet arrow which we should have which
134:16 - is cannot close right only the one who
134:21 - created the BET should be able to close
134:22 - and then we can make that functionality
134:24 - in our utils so all we have to do is
134:28 - come below here and say Pub FN
134:32 - uh validate close BET right and then you
134:37 - can get the BET like so
134:41 - and then you can do that by saying bet
134:44 - here the type uh reference the bet
134:48 - and we do need the user key right so we
134:50 - can say user key
134:53 - takes in user key and it has to be Pub
134:56 - Key that's the type and this will return
134:59 - a Boolean
135:00 - right and then we need to do a match
135:03 - statement here so we say match bet.state
135:06 - and bet state
135:13 - equals Arrow
135:15 - bet dot prediction right by prediction
135:18 - right yeah underscore a DOT player
135:23 - is equal to user
135:27 - key right because the one who created
135:28 - the bet is always going to be user a or
135:31 - player a so we can set that equal to the
135:34 - user key all right uh we can also do bet
135:38 - State started right
135:42 - the is player oops
135:47 - is player
135:49 - pass in
135:51 - the bet
135:52 - right so you're probably wondering what
135:54 - his player is this is the actual
135:56 - function that checks if the user is a
135:58 - player so we can pause that for a second
135:59 - we can say uh FN here because it doesn't
136:02 - have to be public so we say FN is player
136:05 - because this is the only place we're
136:06 - going to call this function uh it's
136:08 - gonna be bet reference to bet again
136:13 - comma get the user key once again
136:17 - Pub Key
136:20 - turns another Boolean
136:27 - forgot to put bull here
136:29 - and put bull here
136:32 - so is player we can check if there is a
136:35 - player
136:37 - by doing bet dot prediction underscore a
136:39 - DOT player is equal equal to the user
136:42 - key all right
136:43 - just like before
136:46 - and then you can also do or
136:49 - right and I press tab here to format it
136:51 - or
136:53 - parentheses
136:54 - the bet.prediction B that is underscore
136:59 - sum all right checking the option and
137:02 - bet dot prediction underscore B dot as
137:08 - ref
137:10 - dot unwrap
137:12 - right because remember B is an option we
137:14 - need to unwrap it then we can go into
137:15 - the player and then check that is and
137:18 - check if that is a player
137:20 - okay
137:23 - cool so now this should make a little
137:25 - more sense we check if uh his player is
137:29 - in here passing the user key of player a
137:36 - yeah and then we can do an and
137:41 - get
137:43 - your next time stamp
137:47 - bet dot expiry underscore TS plus the
137:52 - maximum
137:54 - claimable period
138:02 - okay
138:03 - cool and now we can just check the other
138:06 - states right because the BET state
138:09 - the BET state is player A1
138:16 - then the BET prediction underscore a DOT
138:20 - player is equal equal to the user key
138:24 - comma
138:26 - then the same thing for B
138:28 - player B one
138:33 - all right so these are basically all the
138:35 - times that you can close the BET right
138:37 - if the BET state is a then you know
138:39 - player a can close it started player a
138:42 - we have to check if the player is a
138:44 - player and then uh the maximum claimable
138:48 - period
138:49 - it's greater than that with the
138:50 - timestamp the current timestamp we can
138:52 - we can close the BET and then at player
138:55 - AO player B1 you can still close the
138:56 - button so bet dot prediction B dot as
139:01 - ref because this is an option like I
139:02 - said before so we gotta unwrap it
139:05 - dot player
139:07 - is equal to the user equal equal to the
139:10 - user key
139:13 - yep
139:14 - bets date draw
139:18 - and then we can use this player here
139:19 - again
139:25 - [Music]
139:27 - bet and the user underscore key
139:31 - cool
139:33 - and we just need a comma here
139:36 - and that should be it for the utils so
139:38 - let's go back to our lib right so we
139:40 - then we have to validate the closed bet
139:42 - pass in the player key as the user key
139:44 - and then it'll run through the logic
139:46 - depending on the state thanks to our
139:48 - match statement and if it returns a
139:51 - Boolean that is false error cannot close
139:54 - right so that's how our error handling
139:57 - works right now so we can make this the
140:00 - BET account count
140:02 - uh info
140:04 - and I'm back
140:05 - comma and then let's get the player
140:10 - [Music]
140:11 - so we can say mute and the player is
140:13 - basically the signer so player colon
140:16 - signer we don't need to get an account
140:17 - for that one
140:19 - then you can do Pub system underscore
140:22 - program
140:26 - info
140:28 - system
140:31 - okay cool and that's it guys closed bet
140:34 - is pretty simple because all you have to
140:36 - do since the struct is handling the
140:39 - close all you need to do and here is
140:42 - just write okay and that's the logic of
140:44 - the closed bet guys and that isn't that
140:45 - insane
140:46 - oh okay I'm struggling with this
140:49 - let's try one more time
140:52 - not that one this one hey okay that's
140:56 - the close bet that should be all the
140:58 - functions let's just test for any
140:59 - spelling mistakes or errors and then we
141:01 - can move on to adding this to the front
141:03 - end and this time let's just actually
141:05 - look at the closed bet I'm just gonna do
141:08 - a sweep so maybe we can minimize the
141:10 - error just by just proofreading it so
141:12 - back to Here Close bet let's put in the
141:14 - context I just noticed that context is
141:17 - going to be close but
141:20 - okay and a lot of that logic was
141:27 - in here
141:29 - validate close bet player key
141:32 - what about in utils
141:35 - did I spell prediction right
141:37 - print D I see one predict for the action
141:40 - right that's it that's one way to spell
141:42 - it uh create should be created
141:48 - and I think the rest might be some
141:50 - spelling errors I missed that's about
141:52 - prediction right
141:54 - protection
141:56 - okay looks like I spelled it right
141:59 - that's a build
142:01 - ah yes of course so lib 248
142:06 - [Music]
142:08 - oh yeah commas can't forget that
142:13 - oops let me hit clear
142:18 - oh let's go that is like a world record
142:21 - it's one error and it's just a
142:23 - context spelling again 149 keep
142:27 - forgetting that t
142:29 - don't forget your teas guys so context
142:34 - right
142:35 - and now we have build
142:41 - successful let's go all right now next
142:45 - step let's take this code and move it to
142:49 - our front end and to do that we first
142:51 - need to hit upgrade
142:54 - all right and to upgrade I went ahead
142:56 - and cleared my terminal right and all I
142:59 - have to do is make sure you have some
143:00 - Solana
143:01 - let's hit upgrade
143:04 - and it's going to deploy and if any
143:05 - issues come up it should let us know but
143:07 - that's why we do build first before we
143:10 - do before we deploy so let's go ahead
143:12 - and wait and I'll check back in when
143:14 - it's done
143:16 - a deployment successful so we have our
143:20 - upgraded smart contract the next thing
143:22 - that you should do is look at this IDL
143:24 - and make sure you hit export right here
143:28 - and uh if you're on Chrome or any other
143:30 - browser it should show your ideal here
143:32 - don't mind the number nine that's just
143:34 - how many ideas I have in my downloads
143:36 - right what you could do is go ahead and
143:37 - click it and I'll open it in vs code
143:40 - okay
143:42 - oops what you want to do next is uh alt
143:45 - Ctrl B and you want to get this IDL
143:48 - inside of your utils right and just
143:52 - rename it to just say uh idea if it
143:56 - doesn't already
143:57 - boom okay if I hit save here it should
144:00 - format it
144:02 - [Music]
144:10 - there you go cool I couldn't see it for
144:12 - a second but if you look this
144:14 - essentially is all the information about
144:16 - our Solana program right create master
144:19 - create bet we need this because we're
144:21 - going to be pulling that IDL in here so
144:23 - go to your constants and let's fill out
144:25 - any constant variables that we're going
144:27 - to reuse over and over
144:29 - so what I'll do is at the top here we do
144:31 - need one to import one thing and let's
144:33 - import
144:34 - public key from Solana web3
144:37 - public key Solano web3.js and this stays
144:41 - the same but we need to do is export
144:44 - cons we also need to get the program ID
144:46 - so what is the program ID guys well it's
144:50 - going to be a variable that holds I'm
144:52 - going to use this import
144:53 - make a new instance of a public key
144:56 - based on this string okay what string do
144:59 - we use well simply just go to your beta
145:02 - soul.pg
145:03 - click copy this whole thing this is the
145:06 - address of where your program lives on
145:08 - the blockchain and we can just hit paste
145:11 - here oops there's already quotes in
145:13 - there so we don't need these extra
145:14 - quotes boom right so this is our program
145:16 - yours is going to look different than
145:18 - mine but it should be similar
145:21 - okay next is we should also keep the
145:24 - export const minimum
145:28 - remaining
145:31 - time until
145:34 - expiry right this is the one that we can
145:37 - change to make it more fair
145:40 - boom minimum remaining time until
145:42 - expired cool and that should be all of
145:44 - our constants
145:46 - awesome so remember when I was
145:48 - explaining how each of the functions
145:50 - work some of the things we can do is put
145:53 - that in our front end and pass it into
145:55 - our Solana smart contracts such as this
145:57 - minimum remaining time until expiry we
145:59 - can use this right another thing we
146:01 - should do is head over to our program.js
146:04 - so it should be in here and inside
146:07 - program.js we can have a lot of our
146:10 - helper functions for our Solana program
146:12 - so let me show you what I mean by that
146:13 - by doing something like this and let's
146:16 - hit import and let's get a couple things
146:18 - I want
146:20 - anchor
146:22 - provider
146:25 - provider and then we want big number
146:28 - which is BN program
146:31 - and this is going to come from
146:33 - project serum anchor okay another thing
146:36 - we need is that public key again because
146:37 - we're going to convert a couple of
146:38 - strings into public keys
146:40 - okay and let's get some of our constants
146:43 - in here
146:44 - and then what we need from the the
146:46 - constants is import the minimum
146:49 - remaining time until expiry and the
146:52 - program
146:53 - ID
146:54 - cool
146:57 - what's up next we need to get uh is well
147:01 - actually we can get that later but we
147:02 - need to get the program right so we can
147:04 - create a function all right create a
147:07 - function that gets the Solana program we
147:13 - created right so how do we do that we
147:14 - need to
147:16 - say export const oops
147:19 - const get program that's what we'll call
147:22 - it is equal to
147:24 - a function
147:26 - all right so what does our function do
147:29 - connection takes in and it takes in a
147:32 - wallet
147:34 - right and then we can say const IDL
147:39 - right what do we have we seen IDL before
147:41 - we seen it
147:43 - not there right here the IDL we just
147:45 - brought in so make sure you have your
147:47 - ideal so RDL is equal to require
147:52 - dot forward slash idl.json right so we
147:56 - can get the ID bring it in here and then
147:58 - we have to set up what's called a
147:59 - provider so the provider is going to be
148:02 - given through anchors so say new anchor
148:04 - provider and it's an object here also an
148:07 - object it's a parentheses here and you
148:10 - can say connection
148:11 - and wallet right so the connection and
148:13 - wallet that we passed in is going to
148:15 - come into here
148:16 - and then you say anchor
148:18 - provider.default options parentheses
148:22 - there you go so that's the provider
148:23 - variable setup next thing we need is the
148:25 - program so let's set the variable cons
148:27 - program is equal to new program right
148:30 - one of our Imports and set the IDL the
148:34 - program ID and the provider and that
148:37 - should give us
148:38 - um the program
148:40 - information and create a new instance of
148:43 - it and then all you do is just return it
148:44 - and there you go that's our program
148:46 - so get program texting connection wallet
148:49 - set up the IDL the provider and may use
148:52 - that to make the new instance of our
148:54 - program all right
148:57 - cool now a couple other things while
149:00 - we're here we also should
149:03 - remember how we have to fetch bets right
149:07 - usually when you fetch a bet you can
149:09 - just do a fetch all right or
149:12 - uh fetch of Master right but you can
149:14 - just get a specific account by putting
149:17 - in the public key so let's look what
149:19 - happens when I take the master and just
149:21 - put that to fetch boom that's This One
149:23 - Singular account object right so we need
149:27 - to do the same thing and write a
149:28 - function that gets the program account
149:31 - right so we can do that by saying can't
149:33 - get uh oops other way around
149:37 - export const get
149:40 - program account yeah and PK stands for
149:44 - public key so this is going to be an
149:46 - asynchronous function because we're
149:48 - going to make a promise
149:51 - all right this is going to take in the
149:52 - seeds right usually when you get an
149:53 - account you need the seeds
149:55 - [Music]
149:56 - okay so then we're going to return
149:59 - and say oh wait
150:02 - a public key and we have public key
150:04 - right yep
150:06 - and it has a built-in method dot find
150:08 - program address right this is how you
150:10 - can find a program using this you pass
150:12 - in the seeds and the program underscore
150:15 - ID
150:15 - and then you have to do bracket
150:18 - parenthesis parentheses zero
150:21 - okay
150:23 - cool
150:25 - I think wait boom
150:30 - okay and then uh this shouldn't be here
150:35 - so let's do a fine program address there
150:38 - you go and this doesn't need to be
150:41 - exported because we're going to be
150:42 - reusing that a lot when we get the other
150:44 - account so that's fine
150:46 - okay and then let's start using a
150:48 - function so we can say export const get
150:52 - master account PK right because we want
150:55 - to be able to fetch the master account
150:58 - that we create and to do that we're
151:01 - going to say async you don't need to
151:03 - pass anything in
151:05 - all we need to do is just say return
151:08 - a weight uh get program
151:12 - I can't PK and then pass in the C's
151:16 - right so if you think back to
151:19 - our app in the soul playground right if
151:22 - you go here how do we create the master
151:24 - we had to put in the seeds and then how
151:26 - do we even fetch the specific Master we
151:29 - have to pass in the master seed and if
151:31 - you know this is the string so we have
151:33 - to format that here and press basically
151:36 - an array and do this buffer
151:38 - Dot from and then you can say uh Master
151:42 - right this is the same thing as us
151:44 - writing that binary straight master in
151:46 - Seoul PG
151:48 - all right works the same way
151:50 - cool so after we did that we should get
151:53 - the bets right so how do we get the bets
151:56 - you can say export cons get oh sorry get
152:00 - bet account PK
152:03 - this is asynchronous and does it need to
152:06 - be passed in anything
152:08 - it does right it needs to get past the
152:10 - ID so get the ID in there and we're
152:13 - going to do something with it
152:14 - we're going to say return oh wait get
152:18 - program account PK
152:22 - okay and we say this
152:25 - and we want to put is that buffer
152:27 - because we do put a string in here and
152:29 - what was that string it was bent right
152:32 - so bet
152:34 - comma and then we need to pass in the ID
152:36 - and we can turn that into bytes right so
152:38 - to do that in the front end in
152:40 - JavaScript you say new BN that import we
152:43 - used ID dot two array like
152:47 - buffer comma and then remember we did
152:50 - the Le so comma and then eight and
152:53 - that's how you do it okay there you go
152:56 - [Music]
152:58 - okay so the next thing that we have to
153:00 - do is let's go ahead and set up our
153:03 - state so if you go open up this folder
153:05 - go to Global you're going to see that
153:07 - it's empty well we got to set this up
153:09 - and then wrap our entire app with our
153:12 - state and you'll see what we'll use it
153:13 - for in just a second all right so
153:14 - essentially our global.js is going to be
153:17 - our context so in order to create the
153:19 - context we need to say import and say
153:22 - create
153:23 - context and you get that from react
153:26 - all right but there is a couple more
153:27 - things that we need to import which is
153:29 - going to be a use callback hook as well
153:32 - as the use effect and I believe you stay
153:35 - yep
153:37 - use state
153:39 - awesome all right and then from there uh
153:42 - we can get this import it's called Lamp
153:45 - ports per Soul all right because we're
153:47 - going to do some conversions from Seoul
153:49 - to Lan ports and vice versa because
153:51 - that's what our contract likes to read
153:53 - it in so let's import another thing
153:55 - which is going to be use anchor wallet
153:59 - and use connection and it's going to
154:02 - come from Solana wall adapter react
154:03 - which we used before all right
154:06 - cool
154:08 - now we remember those functions that we
154:10 - created bring them all in here so we
154:11 - could say get program get uh master
154:15 - account PK and get bet account PK as
154:21 - well
154:22 - all right and another thing I like to do
154:24 - here is use toast so if you saw the demo
154:27 - this is where we got those notifications
154:28 - where you can get react hot post
154:31 - awesome
154:32 - all right and then to create a context
154:34 - to get started you just say export const
154:37 - and you can give the name of your
154:38 - context here I called it Global so it's
154:40 - a global context it's equal to
154:43 - the create context hook so I say create
154:47 - context parentheses and then inside
154:50 - takes in an object with all of the stuff
154:53 - we want to pass
154:55 - all right so I could tell you all the
154:56 - variables that we want to pass on
154:58 - throughout our app and it's going to be
155:01 - is connected is one
155:03 - and that can be set to null or we could
155:05 - have the wallet
155:07 - no all these are going to be set to null
155:09 - and they will be defined later on
155:12 - right has user account no
155:15 - uh all bets right we need to have a
155:18 - variable that holds all the bad accounts
155:20 - and that's no we need something that
155:22 - fetches the bets
155:25 - we also need create user
155:29 - create post
155:33 - now
155:36 - and then create now create sorry update
155:39 - the post
155:41 - no
155:42 - delete
155:43 - post
155:45 - no
155:47 - actually now we need to we don't need
155:49 - these we don't need these
155:52 - okay and go back
155:58 - yeah I think those are fine we can
156:00 - delete those uh fetch pets doing
156:03 - anything else
156:04 - no I think that's it so we have those
156:07 - and then we can get the global speed so
156:09 - export const
156:11 - Global state
156:14 - and set that equal to
156:17 - the children
156:19 - okay and from there we just do an arrow
156:21 - function here and then say const
156:25 - program comma set program right this is
156:29 - a
156:30 - State variable that's going to hold the
156:32 - program on our app
156:35 - and while we're here let's go ahead and
156:37 - set up the other states like is
156:39 - connected
156:40 - set is connected
156:43 - [Music]
156:46 - uh we can also say const master account
156:49 - right because we should save the master
156:52 - account and it should only be one per
156:53 - program so it sets master account
156:56 - is equal to your state
156:59 - and we can say const all
157:02 - bets
157:04 - set all bets right so this is a state
157:06 - variable that holds all the bets that we
157:08 - fetch set that equal to use State as
157:11 - well
157:12 - and there's also an optional one which
157:15 - is going to be user bets so we want to
157:17 - save all the bets that are relevant to
157:19 - the user and say set user that's like so
157:22 - equals use state
157:26 - okay and last one is just essentially
157:28 - just
157:30 - uh yeah we could have one more but I
157:33 - think we'll save that for later it's
157:34 - gonna make more sense and then from
157:36 - there we can just set up the connection
157:38 - so if we see our Imports we have can use
157:42 - connection here let's set that up by
157:45 - destructuring it and saying connection
157:46 - and saying equals use connection
157:49 - [Music]
157:50 - and then there's also anchor wallet so
157:53 - we can set that in a variable it's a
157:54 - constant wallet is equal to use anchor
157:58 - well because this will return for us a
158:00 - wallet and store it in this variable
158:03 - all right cool so now that we have a lot
158:05 - of the things set up let's get to
158:06 - writing out the logic of the global.js
158:09 - okay and then don't forget we need to
158:12 - return here and then put parentheses and
158:15 - then what you want to return is the
158:16 - provider so you say Global context
158:18 - provider or sorry contact stop provider
158:22 - yep
158:24 - and press enter and the key here is that
158:27 - the global context sub provider is going
158:29 - to have a attribute called value
158:33 - value set this equal to
158:35 - object and anything you put in this
158:38 - value is going to be what is going to be
158:41 - in our context right and in between the
158:44 - provider itself you have to pass in the
158:46 - children
158:48 - okay so make sure you have children here
158:51 - make sure you have children here and in
158:52 - the value let's say we make a variable
158:54 - it's going to be pulled out
158:55 - by writing it inside of here awesome uh
159:00 - one thing we do have to do is go to
159:01 - Hooks and if you don't have this make a
159:03 - file called use globalstate.js and then
159:06 - you can uncomment this used context so
159:09 - now it exists right because it's just
159:11 - using it's using the context now and
159:14 - what context are we using the global
159:16 - context right but one thing though is
159:19 - that our app doesn't have it just yet
159:21 - because we have to import it over here
159:23 - so at this point you are in your app.js
159:26 - and what we have to do is around here we
159:30 - have to say import Global state right
159:33 - import
159:34 - ant Global state from state slash Globe
159:38 - right the point of this is so that we
159:40 - can wrap our app with the global state
159:43 - so we can go
159:46 - um
159:48 - should go like right here
159:50 - and say Global state
159:52 - and then put that in between our app
159:55 - and there's only one way to test if this
159:56 - works is let's say uh is connected
160:01 - is a variable here let's make a variable
160:03 - let's call it
160:04 - let
160:06 - it connect it all right let connected is
160:08 - equal to true
160:10 - right and we can pass connected like so
160:14 - okay now it's not grayed out and then we
160:17 - can go to let's go to our index page
160:21 - and let's import
160:23 - the global here
160:25 - yep here's the hook use Global state
160:28 - and we can say something around here
160:33 - const oops const
160:37 - use Global state
160:39 - and we want to connect it
160:42 - is connected
160:44 - and let's see if this works console.log
160:46 - oops
160:50 - connected
160:52 - and
160:54 - hello I'm putting this comment here so I
160:56 - know which console log this is so let's
160:59 - go back to playground it's been a while
161:02 - since I opened this one
161:04 - are we running our app svr
161:07 - let's see it might be blank oh it's true
161:09 - let's go right so that means our Global
161:12 - stays working right so how does the
161:13 - context work so let's picture our app so
161:16 - I'm back in the Whiteboard this is our
161:19 - app right
161:20 - and it has a bunch of components like
161:24 - index and the index has header and
161:28 - portfolio right so this is the header
161:31 - and this is the charts right and this is
161:36 - the index all right so usually all
161:39 - components have a hierarchy apparent
161:41 - child relationship and let's say I
161:43 - wanted to have a connected variable in
161:46 - order to get that to the header I would
161:48 - first have to pass it to the index and
161:50 - then pass it down to header as a prop
161:52 - right if you have a long list of
161:54 - components that's going to be called
161:55 - prop Drilling and it may cause some
161:57 - issues down the line another alternative
161:59 - to instead of passing it like so oops
162:02 - lost the rectangles here boom boom
162:06 - another alternative instead of making it
162:08 - an app is to create what's called a
162:10 - store or a context and put it here
162:12 - because with this context I can just
162:15 - pull it from anywhere
162:17 - I don't have to pass it down from parent
162:18 - to child parent to child right so that's
162:20 - why we did that
162:21 - so that's my really really fast crash
162:24 - course explanation on that context but
162:27 - as you can see we have connected
162:29 - available to us so
162:32 - we can put in a lot of our functionality
162:35 - in here so we can erase that and now
162:37 - global.js is all set up so the first
162:40 - thing that I want to do is let's use use
162:42 - effect and let's set the program right
162:45 - set program
162:47 - so users spec is going to run several
162:50 - times depending on how you structure it
162:52 - so if I do something like comma array
162:55 - this is called a dependency module and
162:57 - it will only run once right we want this
163:00 - to run more than once but the first
163:02 - thing we should do is if a connection
163:04 - right if there's a connection
163:06 - then we can set the program to get
163:10 - program right and we can do that by
163:13 - because we passed in that program from
163:16 - our util so all the setup is coming into
163:18 - play guys don't worry it was all part of
163:20 - the plant so we say connection then we
163:22 - say wallet and then you do question mark
163:25 - question mark uh object here okay so if
163:28 - there's no wallet just use an empty
163:30 - object that's what that is saying and
163:32 - then the else right if there is no
163:34 - connection then set the program to no
163:38 - right and the cool thing about our
163:40 - program it does have a master already so
163:42 - we don't need to create that uh one
163:45 - thing to note is again this makes it run
163:48 - once or it runs once when it first loads
163:51 - or whenever the connection changes right
163:53 - so if the connection ever changes it's
163:55 - going to try to set the program again
163:57 - if the wallet ever changes when I switch
163:59 - wallets it's going to set the program
164:01 - again with that new wallet so that is
164:04 - important
164:05 - okay uh one thing I should have is
164:07 - another check which is gonna just check
164:10 - for the wallet connection right so we
164:13 - can do this with another use effect
164:14 - there's gonna be a lot of use effects
164:16 - guys so get used to it
164:18 - so use effect set is connected right I
164:23 - think I have that yep
164:24 - so you can say this if there is a wallet
164:27 - essentially that public key like so
164:31 - it's a double negative in that sense and
164:33 - we can have a dependency module that
164:36 - only happens when the wallet changes oh
164:38 - not that one this one
164:42 - nice cool and if you don't know what
164:44 - this question mark means is if it exists
164:45 - right so if I don't put this question
164:47 - mark you might get an error that says uh
164:50 - undefined Dot Public key right because
164:53 - it doesn't know what this is right this
164:55 - is only going to run if wallet exists
164:57 - it'll only get the dot part if there is
164:59 - a wallet which happens sometimes when
165:02 - you first load the page
165:04 - all right now for the first uh tangible
165:06 - thing that we can see is is a checking
165:09 - if the master account is there right so
165:11 - we can say const fetch master account
165:14 - right it's going to use callback so
165:17 - we're going to say use callback
165:20 - and say async Arrow
165:24 - and all you have to do is uh if there's
165:26 - no program then we can just return right
165:30 - this won't even run
165:33 - okay there's still more because we can
165:35 - do a try catch here
165:37 - not page transition try
165:39 - and then catch
165:41 - I just set up my catch first it doesn't
165:43 - really matter and then for the console
165:46 - log
165:48 - couldn't
165:51 - Fetch Master
165:53 - count and then we could just put the E
165:56 - Dot message here
165:58 - Dot message
166:01 - okay and then for the try the try
166:03 - we're gonna say we have to get the
166:06 - public key first to get the master count
166:08 - right so we can say cons master account
166:11 - PK is equal to and usually you have to
166:14 - write a lot of code just to get the
166:16 - master account PK but luckily for us we
166:19 - made a reusable way to do that it's this
166:22 - function right here Boop so bring that
166:25 - function down here and to say get master
166:29 - count PK
166:31 - so we did it right this should work and
166:33 - then she get us the variable and then we
166:35 - could say cons the master account itself
166:38 - right we can say our way to program
166:40 - because program is going to have all the
166:42 - accounts without account.master
166:45 - .fetch fetch the master with the with
166:50 - the specific master account PK and then
166:52 - set it to this variable and then once
166:55 - that's done we can set to the master
166:56 - account to that variable right so it all
167:00 - should make sense
167:02 - uh if this fails the semester count
167:04 - should just be no so we know it failed
167:06 - and what we could do is just pass that
167:08 - master account
167:11 - all right I think that's what I called
167:12 - it yep so I passed it in in value which
167:15 - means it's in our context
167:18 - so I can go into here instead of
167:19 - connected Let's Do master
167:22 - account
167:23 - and let's say master okay so it should
167:26 - show the master account that's created
167:28 - if it exists so I'm going to go back to
167:31 - here
167:31 - to refresh
167:35 - to inspect
167:36 - undefined so it doesn't seem to have the
167:39 - master account
167:41 - [Music]
167:42 - and if I double check
167:44 - yeah still undefined if I double check
167:46 - here
167:48 - it should have one
167:49 - right should say it should have an
167:51 - object like this that we fetch so that
167:54 - means there's somewhere where it went
167:55 - wrong let's go double check
167:58 - let's see if it's even getting the
167:59 - program so let's pass in program
168:05 - is there a programming program
168:13 - oh what program I'm going to be here it
168:15 - should be here
168:16 - program
168:17 - yep
168:19 - set program
168:22 - [Music]
168:27 - oh I mean
168:30 - it would be helpful to call the function
168:33 - so let's call this function it's still
168:34 - grayed out so we should call this in a
168:37 - use effect so what I'm going to do is
168:40 - down below here we could say
168:42 - check for
168:44 - master account
168:46 - so then we can say use effect
168:49 - [Music]
168:51 - and just do a check if no master account
168:55 - and program
168:57 - oops and
169:00 - program
169:02 - then Fetch Master account
169:07 - dependency module should just be a
169:09 - master account changes try this again or
169:11 - if the program changes then try this
169:12 - again right so if there's no master
169:14 - account and the ad there's a program we
169:17 - need to get the master account
169:19 - okay
169:21 - so let's see that works now
169:24 - hey all right we got it look at this
169:26 - last bed ID BN right it's BN because
169:30 - that's the format it's in so it should
169:32 - be zero
169:33 - um if you want to read it you have to go
169:35 - into index right the trick with big
169:38 - numbers is that JavaScript can't really
169:39 - read BNS so you can just do a DOT the
169:42 - property which should be last uh last
169:46 - bet ID
169:48 - dot to string and then we should be able
169:51 - to see it right zero so anytime you want
169:53 - the actual number itself do a DOT two
169:56 - string so that's the pattern that's the
169:58 - logic we're using that's the master
170:00 - account
170:01 - [Music]
170:02 - amazing
170:04 - okay so master account is done
170:08 - so we successfully created a way to
170:10 - fetch all the master accounts and then
170:12 - check for them we should do the same
170:14 - thing for all the bets so let's make a
170:16 - function called Fetch bets is equal to
170:18 - use callback
170:20 - and then say async Arrow
170:24 - boom okay uh and then same check we
170:27 - always do this if there's no program
170:29 - then you should just return
170:31 - uh same thing is const all
170:34 - bets results right result right and we
170:38 - can get all the bets if we do await
170:40 - program dot account dot bet.all this is
170:45 - how you get all the better counts in
170:47 - your program if there's none you'll get
170:49 - none but then from there you can say
170:51 - const all bets is equal to all bets
170:57 - result dot map right because the reason
171:00 - we want to map is to get every single
171:02 - post right
171:06 - and then well every single bet not post
171:10 - but
171:11 - and then from here we can say
171:13 - bet.account
171:15 - and that should give us just the BET
171:17 - object itself because otherwise you get
171:19 - the whole thing you don't want the whole
171:20 - thing so we can just do this
171:22 - and then take that and set all
171:25 - bets to all bets
171:29 - okay and then if I were to pass this
171:31 - down here it should give us nothing uh
171:33 - we can also just filter user bets but I
171:36 - don't think we need to filter user bets
171:37 - just yet
171:39 - you can just make it to show all the
171:41 - bets in general
171:42 - [Music]
171:47 - so yeah I'm just going to comment if you
171:49 - want you can use that filter
171:52 - to get
171:54 - just the user's bets right but the way
171:59 - our app works we should see all the
172:00 - available bets even if we didn't create
172:02 - it ourselves
172:04 - okay uh and then there should be a comma
172:08 - here dependency module program
172:10 - okay and then now
172:14 - yeah get and update all bets so it's
172:16 - kind of like we did with the the master
172:19 - account we can set up one more use
172:20 - effect
172:22 - like so
172:23 - and in this use effect we want to fetch
172:26 - our bets if our bets if all bets does
172:32 - not exist
172:34 - all right so if it doesn't exist already
172:36 - let's get them so if uh
172:41 - okay then we can say fetch
172:43 - [Music]
172:45 - okay
172:47 - comma and say oh oh if all bets change
172:51 - then run it again it fetch bets changes
172:54 - then run it again
172:56 - [Music]
172:57 - so now this function is being called and
173:00 - just to test it out it should be nothing
173:01 - because we don't have any bits we'll
173:03 - just pass this down
173:10 - oh
173:11 - bits
173:14 - okay and then index
173:17 - [Music]
173:20 - do all bets
173:22 - then console.log all bets
173:25 - should be empty array
173:28 - yep empty right because we don't have
173:29 - any and we could double check that with
173:31 - playground and you can see empty array
173:33 - so it's still pretty accurate
173:36 - awesome
173:38 - okay now we can go back to global.js and
173:41 - work on the next thing all right keeping
173:43 - it moving we are going to our first
173:45 - function which is going to be creating
173:47 - bits and we can actually test if
173:49 - creating bet uh works on our contract as
173:52 - well if this goes well so good to create
173:55 - a bet I'm gonna go down here const
173:58 - create bit and this is going to be use
174:00 - callbacks just like the other ones and
174:03 - it's going to take in
174:05 - uh an async not a misfunction right
174:09 - make sure it's a narrow function
174:13 - and inside of this async function what
174:15 - do we need to create a bet guys right
174:17 - think about it we need the amount we
174:20 - need the price prediction we need how
174:23 - long is your bet going for and we need
174:25 - the
174:26 - with pyth
174:28 - price T right so we need all those
174:32 - things and then inside this async
174:34 - function we have to do the if there is
174:37 - no master account right we can't do this
174:40 - otherwise the mastercount can't
174:42 - increment each bit
174:44 - all right so make that check in there
174:45 - it's our Edge case and then we have the
174:48 - try catch
174:50 - so I'll set up just now e and boom
174:54 - okay toast dot error
174:58 - [Music]
174:59 - yeah so as our first toaster error that
175:02 - we will see a visual cue I'll say failed
175:05 - failed to create BET right and then we
175:09 - can have a console log of the
175:11 - error.message
175:13 - okay
175:15 - cool because we'll get the toast
175:18 - notification it failed and then a
175:19 - console log of what exactly happened so
175:21 - that sounds good to me and in the try
175:23 - catch we can just say const bet ID is
175:25 - equal to the master account
175:28 - right which we'll have access to dot
175:30 - last
175:32 - bet ID and then to increment it we can
175:36 - just do the add in one add one
175:40 - next is we have to make a variable
175:41 - called response or res as equal to 08
175:45 - we have to get the BET account PDA or PK
175:50 - and pass in the bed ID right
175:54 - and again if it doesn't exist if that if
175:56 - we if there's no better count that
175:58 - exists yet it will create one so we can
176:01 - say console.log and then we can just
176:02 - visually see it
176:05 - case but
176:06 - okay
176:07 - [Music]
176:08 - and inside we say rest
176:12 - okay
176:13 - so then after that we can make a
176:15 - transaction hash it's going to show us
176:17 - when it finishes program dot methods and
176:21 - we can look at this through Soul scan or
176:22 - Soul Explorer from here
176:25 - every program has a DOT methods and the
176:28 - methods that we can call on is our
176:30 - Solana instructions that we created
176:31 - together so we can do that by saying Dot
176:34 - all right
176:36 - Dot wait dude I can't press tab here is
176:39 - hit back Dot create bit so I'm calling
176:43 - the create bet function from Solana
176:45 - playground a month amount amount price
176:48 - and duration we're gonna pass that in as
176:50 - well
176:51 - [Music]
176:54 - pith price key
176:58 - ounce
176:58 - I gotta pass in accounts this is our
177:00 - like context
177:01 - [Music]
177:03 - the accounts that we need to pass in is
177:05 - the BET account
177:06 - just gonna be a way to get bad account
177:09 - PK bet ID
177:16 - plus we need we need the master right
177:17 - because if it doesn't exist we can't run
177:19 - this anyways
177:20 - a way to get master like this is why I
177:23 - love that we made those helper functions
177:24 - it makes it nice and easy I don't need
177:26 - to pass anything into that one though
177:28 - and then the player right the player is
177:30 - easy to get because we have access to
177:32 - that when we say wallet
177:35 - and then we can just get the public key
177:37 - because that's what it needs
177:39 - you don't need to turn it to a string
177:40 - and then last but not least you should
177:43 - write this dot RPC
177:45 - okay and then
177:47 - we can say await connection dot confirm
177:50 - transaction and then pass in the hash
177:53 - right so we need to confirm that this
177:55 - transaction went through and usually
177:58 - what you could do is console log
178:00 - uh created
178:02 - bet and then show me the hash
178:06 - that's why we made the variable and then
178:07 - I also like to put a toast.success here
178:10 - and say created
178:14 - cool so there is our creates bet
178:17 - function
178:22 - okay and then there is one more thing
178:24 - though uh there's catch here then there
178:28 - is this here we can put a comma and then
178:31 - we have to put in the dependency module
178:33 - is if the master count is different then
178:36 - uh that's the that is going to determine
178:38 - the BET ID so that should be here
178:41 - okay so let's put fetch bets and let's
178:45 - try it out so I'm going to go to the
178:46 - index and let's figure out where to
178:48 - fetch the BET all right so how do we
178:50 - fetch a bit it should be through the
178:52 - submit button right so I'm gonna go to
178:55 - find out where that submit button is it
178:57 - might be in the index it's been a while
178:58 - yeah it is
179:00 - and you can see that I actually
179:02 - commented out what we need to do so
179:04 - erased static bit and then comment out
179:07 - this right here so the first thing that
179:09 - you should understand is this e dot
179:11 - prevent default this is needed here
179:14 - otherwise if you hit submit on a form
179:16 - it's going to refresh your page and we
179:17 - lose all our states that we set up so
179:20 - make sure you have this so that it
179:21 - doesn't refresh
179:23 - next we need to get create BET right
179:25 - because right now it doesn't exist
179:27 - [Music]
179:29 - we should go back to our globals I put
179:30 - fetch bets but it really is create
179:34 - bets
179:35 - yep great bets
179:38 - create
179:40 - bet
179:41 - cool that exists save and back to our
179:45 - index
179:47 - and instead of all bets all we can keep
179:49 - our best then we say create
179:51 - [Music]
179:53 - then we console log create bet
179:55 - [Music]
179:59 - to see if it exists
180:01 - and it should give us a function that's
180:03 - not running
180:05 - we did this right yep function amount
180:07 - nice so it does exist it's really it's
180:09 - the right name
180:11 - and make sure it's in the on click of
180:17 - the submit button right so what's what's
180:19 - happening here it's going to take the
180:21 - amount of soul that we type in right in
180:24 - the input field that's what this soul is
180:26 - and convert it into lamp ports right
180:28 - because when we take something into
180:30 - Solana he doesn't work with Seoul it
180:32 - works with Lan ports and one billion Lan
180:34 - ports are in one Soul so next is the
180:36 - guest right what is the prediction price
180:38 - of the stock and then lastly the time
180:42 - which I'm going to put to like 150
180:44 - seconds for example
180:45 - and then lastly the price key so how are
180:48 - we getting the price key right remember
180:49 - uh if you look at here you have to come
180:52 - down below get the price key that you
180:54 - want right so that's what you have to do
180:56 - normally but I've hard coded some of
180:58 - that for you here so if you look in
181:03 - data
181:08 - stock data right this is coming from
181:11 - data variable I mean data.js
181:15 - should be somewhere around here
181:18 - yep
181:19 - you can see that I have a price key of
181:22 - each of these stocks so that you don't
181:24 - have to and then the the graph that
181:26 - you're seeing that's not real it's still
181:28 - static right if you want the real stock
181:30 - prices you could just use an API not
181:32 - really through the pith Network the the
181:34 - main functionality that we're teaching
181:35 - here is how to use it in your salon
181:38 - program but again if you want to see
181:40 - that comment down below so
181:43 - back to whatever I was doing we want to
181:46 - set up the create bets
181:49 - so let's just double check one more time
181:51 - and let's just try it
181:53 - okay so creating bet
181:56 - awesome and let's see what happens so
181:58 - I'm going back to our app let's say
182:01 - let's use the AMC stock right you can
182:03 - see Bitcoin you can see Amazon let's go
182:06 - to AMC and then we can X this out and
182:09 - see so my prediction I will predict that
182:11 - the price will go lower to
182:15 - 3.8 right and I'm going to bet two soul
182:18 - and let's make the BET 150 seconds which
182:20 - should be around two minutes
182:22 - oh yeah I need to log in
182:25 - oh okay so my wallet is there
182:28 - uh this might fail them failed to create
182:30 - bet
182:31 - see is there any what's the reason
182:35 - I see it constraint was violated
182:38 - okay that's something we can work with
182:40 - so one Theory I have is when we call the
182:43 - function we might have passed in
182:45 - something that wasn't correct so we can
182:47 - go back to our global
182:49 - go to Korea bet and let's just take a
182:51 - look at all of these accounts so I want
182:54 - to console log them before we create the
182:57 - bed itself so let's do console.log
183:00 - um
183:00 - [Music]
183:02 - get this bad ID
183:06 - [Music]
183:07 - yes let's do this let's say let a bet is
183:11 - equal to
183:12 - this
183:14 - let Master is equal to
183:19 - this
183:21 - oops
183:27 - [Music]
183:28 - and let player is equal to this
183:32 - okay so what I'm doing is I'm just
183:34 - checking to see if these are the right
183:38 - accounts that we need to pass in
183:40 - otherwise the error might be when we're
183:42 - calling the account PKS so let's do
183:46 - this and then we can say
183:48 - a console log
183:49 - [Music]
183:51 - and say
183:54 - the bet is
183:56 - the bet
183:59 - then we can say player I'm sorry Master
184:04 - we should do that to string too by the
184:06 - way so it can be more readable
184:09 - got two string
184:15 - [Music]
184:17 - and then the player
184:19 - that two string
184:23 - player
184:25 - all right this is only going to run when
184:27 - we call create bet so let's try that
184:29 - so hit this one more time
184:35 - okay prediction uh 3.8
184:39 - Soul it's gonna be two seconds 150.
184:42 - it's mint
184:46 - okay so those are our three console logs
184:51 - yeah so the seed constraints are still
184:53 - violated all right so let's see this is
184:57 - the BET account
185:01 - and let's see if that is accurate so
185:04 - create bet
185:07 - hmm
185:09 - great bet master
185:12 - player is that the master account
185:16 - yep four five eight four five eight the
185:20 - player is a t so a seeds constraint was
185:23 - violated
185:24 - [Music]
185:25 - program log six seven so I didn't like
185:27 - when we did the bet so let's take a look
185:29 - at our utils function
185:33 - that's my next guess all right this is
185:35 - live debugging right here when you're
185:36 - making your app
185:40 - program sorry
185:42 - and get the bet so there's something
185:43 - around here oh this isn't nine why is
185:46 - this a nine it should be an eight okay
185:48 - let me just double check
185:49 - yep late yeah so that's the first that's
185:54 - the C constraint right so this is where
185:55 - we pass in the seats to get the better
185:57 - count PK I put a nine here that's
185:58 - definitely wrong so let's see if that
186:01 - fixes it might not it might might not do
186:05 - anything but it definitely shouldn't be
186:06 - a nine there
186:08 - okay so again the prediction is uh let's
186:11 - just say two or three point eight
186:14 - pass into Seoul 150 seconds is the
186:18 - duration submit
186:20 - different account
186:22 - let's go minus two Soul this works guys
186:26 - oh I can't get too excited but usually
186:27 - when you see that number that's a good
186:28 - sign
186:30 - a create a bet awesome
186:34 - so we have a bet here right and we have
186:36 - to notice something we have to see if
186:38 - the available bets show up right so
186:41 - uh what we could do
186:43 - is go to our
186:46 - index and I think not that index I I
186:49 - think we already have all bets
186:54 - all right we have all bets here so let's
186:56 - console log it and see if that array is
186:58 - still empty if it is when then we're not
187:01 - um we didn't make the bet it doesn't
187:03 - exist array one
187:06 - oh let's go array one so our bet is
187:09 - there right so what do you want to do
187:11 - then
187:12 - what do you want to do after you have
187:13 - all the bets we need to get that
187:14 - component that shows all the BET
187:16 - information which we have made so let's
187:18 - take a look at our app once again and
187:21 - scroll all the way to the bottom see
187:23 - this available bets right here this is
187:26 - what we need to go to so available bets
187:28 - is all of those components so let's
187:30 - click on that
187:32 - boom
187:36 - right
187:37 - as you can see we have a static all bets
187:40 - here we don't want the static all bets
187:41 - we want the real thing so we need to
187:43 - import to Global context again so I'll
187:46 - say oh it's already here it's already
187:48 - imported nice
187:50 - and line 17 so I'll just say const
187:53 - all bets is equal to use Global state
187:58 - and now it should map through
188:01 - the actual bet so let's see if it works
188:05 - [Music]
188:07 - a and it's the right bet we did AMC
188:10 - there's two soul and we should be able
188:14 - to enter the bet but we can't just yet
188:17 - because we need to set up that
188:18 - functionality let's go so we have bets
188:21 - all right so let's work on another
188:22 - simple one as you can see here there's
188:24 - already a x right here where you can
188:26 - close the bet so let's do that it says
188:29 - static closing bet function let's get
188:32 - the real deal in here so if I ask you
188:34 - guys where are we going to write the
188:36 - function to close the bet for our front
188:38 - end
188:39 - that's right if you said global.js you
188:42 - are correct so go down below here 116
188:45 - for me and say const close but right
188:49 - it's gonna use call back not anchor
188:51 - wallet callback and it's going to take
188:54 - in a asynchronous Anonymous function
188:58 - all right so when you close a bet you do
188:59 - need uh to pass in what the bet is right
189:02 - the specific bet you want to close and
189:04 - if you say if master account then return
189:07 - right shouldn't be able to close the bet
189:09 - if there's no master
189:11 - from here we do a try catch you know the
189:13 - deal guys
189:15 - say e
189:17 - we can console log all right first do a
189:19 - toaster error right and say
189:22 - uh
189:25 - failed Too Close bet all right and then
189:30 - the console log to let me know what
189:32 - exactly happened
189:34 - couldn't
189:36 - close bet
189:38 - and then comma here is why dot pair Dot
189:41 - message
189:43 - nice and then what did we want to try we
189:45 - have to do the same thing as we did last
189:46 - time let's set up a transaction hash
189:48 - variable that we will confirm later so
189:51 - we say away to that program.methods
189:54 - right and then uh we can say
189:58 - dot here or press enter to format it dot
190:01 - close bet all right because that's the
190:04 - name of our instruction in our program
190:06 - and then you can do a DOT account and
190:07 - pass in the accounts that you need for
190:10 - the context which is just two things
190:11 - it's going to be bet and then it's gonna
190:14 - be oh wait get bet count PK which we
190:17 - fixed now thank God bet that ID
190:20 - don't forget to comment here and get the
190:22 - player which should be very easy wallet
190:24 - Dot Public key
190:27 - awesome and then the RPC
190:30 - all right cool and then you can console
190:31 - log
190:32 - uh or sorry maybe not console you're
190:34 - going to say toast that success right
190:36 - because if you made it this far it's
190:38 - successful and you could say closed but
190:40 - now to see if this functionality works
190:43 - we have to pass in close bet here and
190:45 - then think about where do you want to
190:47 - call close bet where do you want to run
190:49 - that function so if you look at our app
190:51 - it should run when I click that x button
190:53 - and and do you know which components
190:55 - that is a living I'd say in this one
190:58 - available bets so if let's scroll down
191:01 - for the close
191:02 - yep you can see static closed bet which
191:05 - means we don't want to use this anymore
191:07 - so let's erase that
191:09 - and let's do
191:10 - close
191:12 - okay
191:14 - I believe that's what it's called
191:15 - yep close bet
191:18 - and it does need one thing it does need
191:21 - to pass in the BET right here and as you
191:25 - can see if I highlight it it does know
191:27 - which bit we're talking about because of
191:29 - this map right here
191:31 - okay so when we map and create a
191:33 - component of that bet information
191:36 - it has the BET stored there so we could
191:39 - close it it knows which bet it is all
191:41 - right that's what I did in the front end
191:42 - for you guys
191:43 - so now we can just
191:46 - do a refresh for just in case and let's
191:49 - see if we can close it
191:51 - and we should get refunded our two soul
191:54 - hey look at that plus two so let's hit
191:57 - approve close the BET let's go all right
192:01 - so that's done we are able to close any
192:04 - bet we create now now we just have to
192:06 - enter the BET and then claim the rewards
192:08 - okay so I think we're ready to set up
192:11 - for entering the bet so you know what to
192:14 - do let's go back to our app and let's go
192:17 - to global.js and let's just say the
192:20 - const enter bet now to enter the bit
192:24 - it's the same as all the other functions
192:28 - this is just us calling enter bet in the
192:30 - front end to call the function in Solana
192:33 - right so we're going to do use callback
192:35 - here and it's going to be async
192:36 - anonymous
192:38 - think about it what two uh arguments do
192:41 - we need when we enter a bet we need the
192:44 - um the price prediction of player B
192:47 - and which bet are you predicting on so
192:49 - price bet
192:52 - okay then you can just console.log
192:54 - uh well you don't need to cancel out
192:56 - actually then you can say uh X if
192:59 - there's no master account once again we
193:01 - we should just return
193:04 - and then from there our favorite try
193:07 - catch
193:09 - e
193:11 - and then console.log if it fails uh
193:14 - couldn't
193:16 - enter a bet and then tell me why with
193:19 - the E Dot message
193:21 - okay and then there's the toaster error
193:24 - so it's the visual cue that hey this
193:25 - didn't work so let's say failed to enter
193:28 - but
193:29 - exclamation point
193:31 - all right so what are we gonna try well
193:33 - you know what to do transaction hash is
193:36 - await program dot methods and then we
193:38 - can hit enter just for formatting
193:40 - purposes and say enter bet
193:42 - and we're going to enter the price uh we
193:46 - also need to say dot accounts
193:50 - all right and then put an object and the
193:53 - accounts that we need is the BET itself
193:55 - which you can say await get bet account
193:57 - to make because we made our lives easier
193:59 - and since we passed in bet here
194:02 - just pass that in to get the ID all
194:04 - right and it does all the fetching for
194:05 - us gets the account that we need then
194:07 - it's the player up next and then you can
194:10 - say wallet Dot Public key
194:13 - uh there's an error here because the
194:14 - comma as you can see I'm more
194:16 - comfortable with the front end than
194:18 - Solana so we can just say dot RPC here
194:21 - foreign
194:22 - [Music]
194:34 - and again I didn't do this for the
194:36 - closed bet but if you want you can
194:38 - confirm the transaction entry console
194:40 - log the TX hash
194:45 - again
194:46 - optional you do something like this
194:48 - connection.confirm transaction
194:50 - but if you just want to make sure or you
194:52 - could just console log the transaction
194:54 - hash that comes of this
194:56 - cool
194:59 - all right so that's entering the bet
195:02 - let's put this here
195:04 - and again
195:05 - if you think back it's been a while but
195:07 - if you think back to our demo the enter
195:09 - bet function should be somewhere here
195:11 - with all the other information next to
195:12 - our closed bed so let's go to available
195:15 - bets and let's try to find it so current
195:18 - amount
195:19 - you might have to create it now
195:22 - and here is where we want to set up that
195:25 - enter button or claim button right so we
195:28 - need to uh
195:30 - have a button that changes depending on
195:36 - the state of the BET right so how do we
195:40 - know what the state of the bed is well
195:42 - we have this console log here and you'll
195:44 - see what it's used for so let's just
195:46 - temporarily make a new one let's say one
195:48 - one one one 100 right and submit
195:55 - and Bam created bet
195:57 - [Music]
195:59 - oh
196:01 - accidentally refreshed
196:03 - there you go AMC right we should see an
196:06 - enter or claim button depending on the
196:07 - state here but if we look in our console
196:11 - what is our state our state is created
196:13 - right so if it's created we should be
196:15 - able to enter the BET right so this is
196:18 - how we get the state object.keys give me
196:20 - the state 0 to uppercase right
196:23 - cool so
196:25 - what can we do with that information
196:26 - well we can just do
196:29 - just get that right right away so say
196:31 - object that keys
196:33 - bet that state
196:35 - um in bracket zero and then dot to
196:38 - uppercase I'm making an uppercase so
196:39 - when I do a check
196:41 - all the letters is going to be the exact
196:43 - same or else I'd have to know how to
196:44 - write it exactly so you'll see what I
196:47 - mean in just a second so make that
196:48 - uppercase uh object Keys best case to
196:52 - uppercase is equal equal to starting
196:56 - right so and this is has to be Capital
196:58 - because of the two operators right
197:00 - yeah so this should be
197:02 - started
197:04 - started is when player B enters the pit
197:06 - so this is what I want to do first first
197:08 - get the started one and
197:10 - I have a question mark here because this
197:11 - is a ternary operator essentially if the
197:16 - set of the bait is started
197:19 - then what I want to happen is we have a
197:22 - div here
197:26 - and don't worry about the area it'll go
197:27 - away in a second
197:29 - we have a div here
197:32 - what is in this div well in this div is
197:35 - going to be the class name
197:39 - styles.com see we're still doing some
197:41 - HTML and CSS here styles that button and
197:44 - it's going to happen on click right
197:49 - you set this equal on click of
197:52 - claim bet so we don't have the claim bet
197:55 - function yet so we'll say static claim
197:56 - bit for now
197:57 - like so
197:59 - and inside that very div is where you
198:02 - can write claim right so if I save this
198:05 - um well we're still going to error
198:06 - because we're not done hit claim and
198:08 - then you're going to say uh
198:10 - or right or else this is the else the
198:12 - colon here after you use the question
198:13 - mark So if this is started load the
198:17 - claim div
198:19 - if it's not started then
198:22 - we want uh enter here we want object dot
198:27 - Keys again
198:28 - essentially this whole first part so
198:30 - let's just we can copy that
198:33 - all right so this is a nested ternary
198:35 - statement right here and this setup
198:39 - started we want to check for
198:41 - uh player A1 so we have to do all the
198:44 - states here to make it one button right
198:45 - you could just have multiple buttons
198:47 - like enter claim uh close right but I
198:51 - want to fancy I want it so that changes
198:53 - depending on the state
198:54 - so player A1 so it kind of goes down the
198:57 - nest so first is the BET started no then
199:00 - load player A1 is it player A1 no then
199:03 - that must mean player B1 all right so
199:05 - first we'll do the player A1 so you can
199:07 - copy this dip
199:08 - [Music]
199:11 - right and say player A1 right so player
199:16 - a
199:18 - one and this isn't on click
199:22 - and this also isn't a button this is the
199:25 - uh available bets title which I set up
199:27 - before for you guys
199:29 - and we're not done yet have another one
199:32 - all right another nest
199:35 - right so this one is going to be for the
199:39 - second option b
199:41 - [Music]
199:43 - right so player B1
199:48 - okay and then if that's the case then
199:50 - it's going to be similar to this one I'm
199:53 - sorry this one
199:56 - [Music]
200:00 - tab save boom
200:02 - [Music]
200:04 - and then say player B1 okay and then if
200:09 - none of that happens then what we could
200:11 - do is
200:13 - roll in that's when you just see the uh
200:16 - enter button right so the enter button
200:19 - you don't need another object stack Keys
200:21 - here because it's the only other state
200:24 - that's possible so you can just copy the
200:26 - Styles button one
200:30 - okay and instead of this you just say uh
200:34 - enter and we do need to fix this a
200:37 - little bit because it's not claim bet
200:39 - it's actually
200:40 - enter bet
200:42 - enter bet
200:46 - well actually no we don't even enter But
200:47 - Here guys I was wrong when you enter but
200:49 - you get a little modal that comes up and
200:51 - to make the model come up we have to
200:53 - change this on click
200:55 - to a
200:56 - enter that set selected bet this is a
201:00 - front end function that I have that's
201:02 - going to open up our custom model
201:05 - then it will say set show model to true
201:09 - [Music]
201:14 - I also want to do an on click and we
201:16 - don't want this to run so we'll do
201:18 - something like this
201:21 - there we go so that's how you can make
201:23 - two functions happen one after another
201:25 - is make it Anonymous first and then make
201:27 - the two functions run
201:29 - okay uh let's see what happens
201:33 - [Music]
201:37 - oh
201:37 - [Music]
201:41 - foreign
201:43 - [Music]
201:51 - undefined or no oh okay
201:55 - oh okay so it's not my fault it's I just
201:58 - spelled State wrong I put satatate
202:02 - okay
202:02 - [Music]
202:04 - that should definitely exist now
202:06 - [Music]
202:08 - hey we can now enter the BET right so
202:10 - this doesn't actually enter the bet this
202:12 - does right and this is where I can enter
202:14 - our prize prediction if I hit submit
202:16 - that's where the static one comes in
202:19 - a closing bet okay
202:22 - cool so let's go to that which is the
202:25 - custom model
202:27 - which I haven't opened yet
202:30 - and in here
202:31 - we have static enter bet it says closing
202:33 - bet we don't need that anymore we can
202:36 - just get the import which I should have
202:37 - use Global State and then how do we get
202:40 - it guys you just say const
202:43 - enter bet is equal to use Global State
202:46 - like so and I just got to make sure I'm
202:48 - passing it here yep
202:50 - so now I should have access to it here
202:53 - and we have to go to
202:59 - enter yeah instead of static enter bet
203:02 - we need enter bet and it's going to take
203:04 - in the player 2's guest and the bet that
203:07 - we selected
203:08 - all right now moment of truth I will
203:10 - close this one because it's probably
203:12 - expired in the time span of me
203:13 - explaining and coding that so let's get
203:15 - our soul back
203:18 - and let's test it okay cool so now that
203:21 - I closed that bit Let's test the enter
203:23 - bet functionality and see if it works so
203:26 - let's get a player B so what I'll do is
203:28 - I made another window and we can go to
203:30 - localhost again but this is a different
203:33 - account so as you can see instead of 18
203:34 - my wall address here says 3w so you
203:38 - should be able to see all our bets as
203:39 - well and enter as player B so let's see
203:42 - how much Solana he has he has
203:46 - five Soul all right so five sold for him
203:49 - and
203:51 - player two as well player one actually
203:54 - has how many soul
203:57 - I think this one has a lot should have
203:59 - he has 12. all right so let's make our
204:01 - bet so right now current stock price is
204:03 - 3.9 let's predict it goes to 3.8 and I'm
204:07 - gonna bet three Solana in it and let's
204:10 - say it's about 150 seconds right
204:13 - eventually you can set up a function
204:15 - that converts this from days to months
204:17 - right but right now we still just want
204:18 - seconds and now let's go ahead and
204:21 - submit
204:22 - and again let's test if create but still
204:25 - works
204:26 - let's go minus three that's good hit
204:28 - approve
204:32 - create a bet amazing so we can all tab
204:35 - to here and let's see what it says can
204:37 - we see it yes all right so the mat the
204:39 - pot to match is three let's hit enter
204:41 - and I'll predict it's going to be eight
204:43 - Solana so this one is going to be wrong
204:45 - so let's see minus three Soul approve
204:49 - let's go he entered the BET right so we
204:52 - can X this out and then now if you just
204:54 - look at a t and look at the status of
204:58 - the BET here three Soul it's gonna say
205:00 - claim now right it said enter before but
205:03 - because of our ternary operator it now
205:06 - says clean next thing we have to do is
205:08 - the final function of today guys which
205:10 - is claiming the BET and you remember
205:12 - this is the complicated one but we did
205:14 - the heavy lifting in Solana playground
205:16 - if you look if I did fetch here
205:19 - there's our BET right we can see player
205:22 - a who's eight T and then three W which
205:24 - is player B and you can even see the
205:26 - guesses if you fetch it so cool
205:29 - all right so let's go ahead and work on
205:31 - our last function all right so right now
205:33 - we want to claim the bet but as you can
205:35 - see I'm clicking it there's no
205:37 - functionality so
205:38 - let's give it life and let's go to
205:41 - prediction app and let's go we can go
205:43 - down below here and say const claim
205:47 - BET right and usually guys should know
205:50 - the pattern by now we're going to use
205:51 - callback and and this structure of
205:55 - calling the salon instructions is the
205:57 - same so if you want to make your own dap
206:00 - keep this structure in mind if you don't
206:02 - learn anything from here just learn that
206:04 - this is how I create a function this is
206:06 - how I call the function right those
206:08 - things are going to help you make your
206:10 - app so here we go claiming a bet all it
206:13 - needs is the bet that's selected and
206:15 - then we have our Edge case here what's
206:17 - our Edge case if there's no master
206:19 - account just hit return
206:21 - all right you with me home stretch guys
206:24 - then we do our handy dandy try catch
206:26 - here with e
206:28 - and you know I like to cancel that log
206:32 - couldn't claim and then show me why I
206:35 - couldn't claim with e Dot message
206:38 - and this has to be a comma actually
206:40 - outside the quotes
206:41 - okay
206:42 - and we also do a toast
206:45 - dot error here and then we can say
206:47 - failed
206:49 - failed to claim
206:52 - okay
206:54 - cool now for the try which is going to
206:57 - be simply just const TX hash is equal to
207:01 - program or wait sorry await program
207:05 - [Music]
207:06 - dot methods all right so we're going to
207:09 - call it the last instruction here which
207:11 - is just going to be claim bet
207:13 - okay and claim bets doesn't take
207:16 - anything but what does take stuff is the
207:18 - accounts that we pass in
207:20 - is just going to be the well actually
207:23 - it's going to be a couple of things and
207:24 - I think about it's gonna be the BET
207:25 - right which should be the 08 get
207:29 - bet account
207:31 - PK and pass in the bet.id
207:34 - and then from there we can pass in the
207:36 - pith right the pith is just the
207:38 - bets.pith price key we have to validate
207:42 - if that's the correct key
207:44 - and then we got player a and player B
207:46 - right so player a
207:48 - how do we get their key well we stored
207:50 - it in the BET account itself so we need
207:52 - to get to the prediction
207:54 - prediction
207:55 - a DOT player right how do I know this is
207:59 - what it needs well if I go to salon a
208:01 - playground I go to the account and then
208:04 - inside that go dot prediction a and then
208:06 - go to player to get that same thing with
208:08 - B
208:09 - so let's do that prediction and Dot
208:10 - player
208:12 - comma let's put player B
208:16 - player B here is going to be same thing
208:19 - but dot prediction
208:22 - and then we say B dot player
208:25 - last but not least we need the signer
208:27 - and that is essentially who uh is able
208:30 - who's claiming right so wallets Dot
208:32 - Public key the cool thing is that
208:34 - anybody can claim player a can claim and
208:37 - player B can claim so let's say player
208:39 - A1 and player B lost a player B claims
208:42 - uh the the money still gets transferred
208:44 - to player a right that's how we set it
208:47 - up which is pretty handy so then from
208:49 - here we can just say the RPC
208:51 - and then you can say a toast that's
208:53 - success
208:55 - uh success
208:57 - claimed bet all right hit save
209:02 - and we also I didn't I don't know if I
209:04 - did this for the other one but we need
209:05 - to put the dependency module for master
209:10 - count
209:12 - yeah I don't believe I did that for the
209:13 - last one so let's do dependency module
209:15 - master account
209:17 - [Music]
209:20 - same thing
209:22 - comma
209:24 - this is where they use callback part
209:26 - yep and I did that here
209:28 - alrighty
209:30 - so with that said we can now claim the
209:32 - BET and now we just have to go ahead and
209:35 - test it so I'm going to do this and then
209:38 - where are we going to claim the bet you
209:41 - saw the button so it should be around
209:43 - here so instead of the static claim bit
209:45 - we need the real clan bit and we should
209:48 - also press equals this so it doesn't run
209:51 - right away when the page loads
209:53 - and we should probably get an error
209:55 - because this is here
209:58 - static one and we need to pull it
210:00 - right claim claim
210:03 - Pull It in from here save and we
210:06 - shouldn't have any errors
210:08 - awesome so let's hopefully enough time
210:10 - has passed since I did that so that we
210:12 - can claim the bet
210:13 - so here we go deep breath
210:15 - let's see if the claim works hopefully
210:18 - enough time has passed or it doesn't
210:19 - give me any errors
210:22 - let's go do you see that plus six in our
210:25 - wallet right so this took a lot of work
210:27 - to build if I hit approve it should go
210:30 - through
210:32 - claim the bet uh it might take a while
210:34 - for your soul to update on Phantom
210:37 - should have 15 Soul right we just made a
210:40 - profit from you know predicting whether
210:42 - a stock will go up and down but I hope
210:44 - you guys learned something today comment
210:46 - down below if you liked the video and
210:48 - subscribe I'll see you guys in the next
210:49 - video peace

Cleaned transcript:

in this video we are going to be making stock prediction dap with an xjs I'll be showing you guys how to utilize something called the pith network if you don't know what the pith network is it delivers realtime onchain Market data to the Solana blockchain you'll learn how to utilize this Oracle in your Solana smart contract to get realtime data on stocks like AMC Amazon Google and even crypto if you like as a bonus I'll show you guys how to make price predictions on these stocks so that you can bet money and win big and get some soul of course I'll also teach you how to connect your wallet to this app using Phantom wallet and also how to get your funding connected to your Solana program so without further Ado let's get started alright so here's the app in its full entirety with all the functionality working I have it open up twice because this needs two players so that means when you deploy this app you can have any of your friends or somebody else play against you to bet on the stocks of this app so as you can see 3w is player two 4A is going to be player one so and you have a couple options there's Bitcoin Amazon Google right so let's work with AMC for now and what we want to do is put a prediction out there so the current stock price is four so let's do something simple I want to make player one the winner so we're going to do four it's gonna be four dollars and two minutes essentially and I'll even bet two Solana for this so I hit submit and you can see when you approve the transaction it says send to Seoul so when I hit approve it's going to send it to a thirdparty account it's an escrow so when the BET's finished it's going to distribute it to the winner whether that's player one or player two let's hit approve and after a second you should see approved bet or failed to approve it and there you go created the BET and it should load we can go to player two and you can see the BET once it loads and there it is so let's enter this and I'll say eight dollars in two minutes it should be wrong and it's going to send two Soul as well because that is the uh pot amount to enter right so the player one always sets the pot amount so as you can see the total pot amount is four to the winner and now we can hit claim so if I go here this should update to claim and in just a second so now it's claim and after the two minutes is up we can go ahead and claim the BET and the cool thing is that no matter who is the winner you can still claim it so let's say player two lost you can still hit claim but the money will still go to the right person player a okay and let's set up in the logic which I'll show you later in the video so I'm gonna wait till the time is up and we can hit Clinton alrighty so I think enough time has passed so let's go to player a and claim the bet hey see that we received four Soul because that means Solana determined that we won and our prediction was closer to the actual price so let's hit proof claim bet and now you should see the state update so player A1 as well player a is on a win streak he's killing it he knows all the right answers so if you look now we have five cylinder when I just had three earlier and if he goes to player B if you look at his uh right here he should have two Soul right he had four now he has two there you go that is the demo so if you want to learn how to build this let's just Dive Right In All right so you're probably wondering how do I get started Lance well you could copy what I do as I get started but we have front end for you guys and all you have to do is use our CLI tool to get it so let's do command J and make sure you see the into a folder where you put your projects I put mine here so that's fine so all you guys have to write is npx cleverprogrammer at latest you'll get all the modules all the front end that you need and have access to every single build in our YouTube channel within the last year and from there you could copy and change these projects and add it to your own portfolio or follow along on YouTube so let's do npx clever programmer latest be sure to build this project with me and try to do it on your own as well so that you have a deep understanding of it so all you have to do to get access to everything is just type in your email address like so type in your name and ba or bam I said bot but there you go we have tons of projects here a lot of solidity a lot of Solana but the one that we care about is the Solana prediction app so hit enter and this will make sure that you have all the modules and files you need so there's no more of those node module dependency errors and all you have to do is just wait for this to finish and I'll open a new vs code for you so once that's done I'll cut back and we'll get started alrighty so if you made it this far you've successfully downloaded the files that you need to get started so all you have to do now is just say yarn Dev and start the server right it's going to be on localhost 3000 so you can do like a control click and if you do that your browser should open and you can see this is what we're working on it's different than the demo because if you look at the top right there's no Phantom wallet connection and none of the other features work just yet right our goal together is to make this static site work right so we can learn a lot about salonout by making this work together so right now it says creating BET right here which means it's just a function that just counts allows creating bit but nothing actually happens so what do we need to do first the first thing that we should probably do is let's get Phantom right so if you don't know what Phantom is it is a wallet that we can use to connect to our dapps right there's multiple different kinds of wallets but today we're going to be using Phantom so if you've never had Phantom before all you have to do is type in Phantom wallet and it's going to work with chrome because there's an extension for it so it's Phantom one extension is actually what you need now I hit Chrome and there it is I already have it so we're good to go and if you know how to set Phantom feel free to skip a little bit ahead in the video to the next part but go ahead and add this extension open up the Phantom here and it's going to ask you to set your password and remember your phrase so don't share that phrase anybody or I'll still be able to get into your wallet so I'm just going to write my password as you can see once you make an account you should see something like this so it says wallet number one I have nine Solana and you can go ahead and go to your settings just click this button right here developer settings and make sure your network is devnet I repeat make sure your net network is devnet otherwise a lot of your stuff isn't going to work there is also the mainnet which is your is going to use real Salt test net and devnet and localhost so again devnet and you should be good once that's done if you want to add some Salon to your wallets there's a couple different resources but you can use what I call Soul faucet just take your wallet right here and you can copy the address with this paste it on here you can add up to two and click devnet look at that successfully airdrops to Seoul and now let's see how much I have and we have 11 Solana so you stock up on Solana because we're going to be testing with it a lot so with that said you should have Phantom extension installed what we can do next is set it up on our app so we can we don't have to worry about the browser right now let's go ahead go to your vs code and we're going to be working on the index page or actually the underscore app page and now when you're in your app.js this is where we're going to set up the pro connection provider for our wallet and so that we can connect to the Solana chain so one thing that we can do to make our lives easier is if you go into the utils folder you'll see a couple files that I set up for you what you want to do is go to con constants.js and let's set up a couple different things the first thing I'm going to write is expert const RPC underscore endpoint all right if you don't know what our PC endpoint is this is essentially a node that we use to connect to the Solana blockchain and there's a lot of different uh endpoint providers out there like infuria um quick node Alchemy but today we're going to be using quick note all right so do something like this and all you have to do is go to quick note and let's get an endpoint together so we're going to go back to the browser right right here let's head over to quick note okay so go to quickenow.com or click in the link in the description so that you can get in right away all you have to do is Click sign in and create your or create your account so go ahead and do that verify your email and your endpoint should be good to go I already have an account so I'll just quickly log in and Bam once you confirm your email you should see uh something that says create your endpoint so right now I have this endpoint called bold stylish voice right but I'm going to go ahead and archive it so that we can create one together if it's your first time all right so feel free to use whatever endpoint you like meantime we'll do with this so archive that endpoint and this is the exact screen that you guys should see I'm gonna go click create an endpoint and again it supports multiple different chains eth Bitcoin polygon Avalanche right but we're using Solana of course and quick question which net are we going to be using main test net or devnet exactly good job George that's gonna be definite we're gonna go ahead continue there's a couple other extra features like an nft fetch tool but we don't need that let's just make the endpoint down in the bottom right all right give it a second there you go right guess what that's it that's all you have to do is set up an endpoint if you were to do this yourself it would take a lot longer so let's go ahead and click this copy and this HTTP provider and that's all we need so you can go back into your code now and in the quotes after you made this variable in your constant.js you should have one just paste that bad boy in there and guess what you have an end point ready all right so now that you have your endpoint and you're exporting we can now go back to our app and we're going to be using that endpoint soon to use it though all you have to do is if I make this bigger for you guys go into here if you export it you're allowed to do something like this restructure here and say RPC uh end point oh I think it's underscore endpoint and then you can see the Auto Import go ahead and click that or write it out like this and now now that uh endpoint is successfully imported into our underscore app right so that's not all that we need to do we need to import a lot of other things such as the Solano wallet um modules so I'm gonna go ahead and do that let's import the connection provider so I'll say connection provider and you can see this is coming from our module Solano wallet adapter react right so all these modules are already installed if you did it with our CLI tool if you didn't use our CLI tool go ahead and do yarn add this right here go and there's actually another thing that we need to get from Solana wallet adapter rack which is going to be a wallet provider okay so we need to provide the connection and then we need to provide the wallet this is how you can look at these Imports and it's cool because again Solana modules are helping us make it a lot easier for us so we can do is another import ant okay if you remember in any other videos when I click on the connect wallet button you should see a nice modal that comes up that shows the different wallets right I didn't make that myself you actually can get that provided for you from Solana as well as you can say wallet modal provider right here and you can see this is the module that it comes with so Solano wallet adapter react UI the next thing we're going to say import and I'm going to hit enter here because there could be a bunch of imports that you'd want but you can do a phantom wallet adapter and if you want to add more wallets put more options for the users you can add all the wallets here there's a couple different other adapters that Salon provides and you can get this from at Solana wallet adapter Dash wallets right here okay so once you do that that should be it for wallets we can do import this last thing which is the CSS so you can say uh Solana wallet adapter react UI and then the slash styles dot CSS right because if you don't have this we're going to have a really blank Phantom or connect wallet button rather okay so all of our actors are set now let's put it together so one thing I'm going to do is we've imported use state from react all right that was given to you what we need to do is make the state for something called mounted okay so to set up a state you're just going to say const uh mounted and then set I'm just going to SQL that to use State and the default for this is actually going to be false okay cool hit save and the next thing you want to do is let's set up all the wallets that we're going to use and like I said it's going to be one so make a variable called wallets and equal set it equal to use memo right and then to use use memo it's going to take an arrow function and then put this array here and then you're going to say new and let's use all our Imports so the first thing that we're going to use is this Phantom wallet adapter so we're gonna make a new instance of this adapter hit comma for this variable and hit save uh after this array it does need a dependency module so just do this cool and let's set up a used effect right because there is this SSR arrow with next so I just want to set up a use effect right here boom boom and then here we can set mounted to true okay and again let's add another dependency module right there cool all right so if you didn't know it in line 28 this component with dot dot dot page props this is what represents our index.js right so what we need to do is wrap all of our providers around our app right or our index so the first thing we can do is at the top say connection provider like so right if you're wondering where did my where am I getting this well we imported it right here now it's not grayed out and we could do is essentially just put it and wrap it like this so now our connection provider oops sorry about that but as I was saying what we did there was all we wrapped our app with this provider and we're gonna do the same thing with the wallet provider right so how it should go it should be the connection provider on the top and inside that is the wall provider and inside that is the modal provider okay makes sense so I'm going to enter right here and just say wallet provider okay and I'm gonna close it and then take this and put it right here right make sure that this closing wallet provider isn't under connection right because this is nested okay and then from there one more we're going to hit enter hit this curly bracket right so we can use some jsx and what we want to do here is essentially say mounted and and all right so where's my and button right so this means if this is true right then we can load our app right because then we know that it's mounted and put the component inside of that okay cool and actually above that is the model provider so we can say wallet model provider amazing so this is how it should look connection wallet wallet model and then this mounted check right here it wants to make sure this is true and then we'll load the index okay cool and this will automatically become true because the use effect is going to run this right when the app or this app.js component loads okay and the next thing we should do is let's put in a couple different properties right so in this connection provider the opening tag if you hit enter it has a uh prop or attribute called endpoint and it's going to take in an endpoint that we use so um we're going to use our RPC endpoint right so now it's coming into play essentially it's going to be what it looks like underneath the hood is quotes and then your long link that you have so we have that stored in the variable so we can just write this okay and next it should take in this Con fig and it's going to be equal to object object commitment and you're going to say confirmed awesome one more thing it's going to be the wallet provider we need to provide this with the wallets that we set up which we did with this variable right so kind of like the end point you're just going to go into the opening tag of this hit enter okay enter and then do wallets is equal to well well because that's what we call okay awesome and then there's another cool thing that we have uh built in which is the auto connect right so when you're already logged into your Phantom it'll automatically connect that wallet to your app if it's been connected before so this is a cool feature to have if you don't want this you don't have to have it alrighty that said we got our wallet set up right so how do we start using it well we have to figure out where we want to add this connection so if I go quickly back to my app and I asked you guys what component is going to be holding this connect wallet button right well if you ask me I think it's going to be what we have as the header component so go into your components it's nice and organized for you guys click on header.js and let's scroll to line 35 right there it is the connect wallet button so what can we do to start using the wallet that Salon provides for us we can just import it right so we can say import and it's called wallet a multi button like so see this all right hit save we can do now is remove this whole div and just use that very component wallet multi button okay all right so with that said let's take a look so I'm gonna go look into here and look at that there's my wallet and I've connected this before but this is what it would look like initially right so I can hit refresh if you want to see the full process you can hit select wallet and Bam all right if you want to give it more styling because it does look a little small right what we could do is I have styling ready and I think it's called menu item right I gave it that same styling so all you need to do is just put class name is equal to styles dot menu item so hit save there and Bam right it's not so it's small and Tiny anymore and it has that nice hover effect so don't be afraid if you don't want to use the default uh CSS styling of the button you can give it a custom one to match your theme so there you go we're connected guys this is it that's how you set up your Phantom connection let's move on to the next step alrighty so with that out of the way let's get to the main part of the video I xed out the quick note tab so if you don't need it go ahead and get rid of it what we need to do is head over to seoul.pg or rather beta.soul.pg or if you don't know what this is this is a browser where you can write your very own Salama smart contract usually we can use vs code and create our anchor project here but this is a nice tool that lets us test functions create functions and everything we need without downloading all the files that we usually do so if you've seen our other tutorials this is what we've been using so I can see this is our lib.rs our anchor file and each of these is part of the program this is called the account struct right with and every single function like this one right here initialize is going to have a struct that goes with it so let's get started the first thing we're going to do is let's create a new project actually and as you can see there's three different types of Frameworks native rust anchor which is a framework of rust and then now it supports seahorse python so if you want to see us use seahorse follow the Instagram tutorial where I use Python for that build so what we're going to do is write prediction right tap and hit create open select the framework bam cool so nothing should change right this is pretty much the app but let's go ahead and erase everything and start from scratched and before we move any further let's figure out what are we trying to do with this Solana smart contract well what do we know and this is called pseudocode so what I'm going to do is say prediction dap right and the goal of this smart contract is what right we need to get the price of the stock using the pith Network right or pyth and then the functionality of it because we can easily just get the price of the stock using this with the key but the fun part about this is that we're making it uh so that users can bet on if the stock is going to go high or low and during a certain amount of time so what we need is player a to choose an asset that's available in pith all right so that makes sense and and inputs the length of the bed right because that user should select something like AMC stock and say like hey within the next two minutes let's see if the price is going to go up or down okay that's player a and this is important because if we don't know how the logic works we might get into some trouble so this is for us to understand if you feel like you understand this and you just want to see me code skip a little bit ahead in the video and let's keep on going but player B though well other players can see all existing beds so after the bed is created all right so this is basically creating a bit create bet you can see all existing bets right so how does that have work well we're going to be able to fetch the bets right and then after that player B can match Penny bets so what does match mean to you guys so matching a bet let's say I create a bet over here and I bet two soul that AMC is going to go up in two minutes right player B will also a bit too so that could go down or go even higher right so that's why it's going to match any bet that's and inputs his own prediction okay does that make sense good awesome so another thing is uh if the timing is over whoever whoever is closest to the price can claim the whole amount right so if player one player one or player a bets two Soul player B matches that with another two Soul What's the total price that they get after winning it's gonna be four right so again logic is very similar to the lottery bet except now we're actually inputting our predictions here instead of just a random or semirandom uh algorithm cool alrighty cool so that should be enough pseudocode for now let's get to coding and one of the first things we need to do is import anchor Lang into our project right so usually in JavaScript you've seen like import anchor from whatever right but we are on Rust right now or rather anchor so to import it in Rust you just say use right you can see this little suggestion is helpful input right you're going to literally say use anchor underscore Lang and then colon colon right you can think of colon colon like us going into a folder right we're gonna CD into anchor Lang and if we do this we can destructure what we want inside of anchor link so what do I want inside of anchor Lang well there's going to be something called Prelude right and if I do a colon colon here what does that mean we're going inside Prelude exactly so you guys are getting it all right so what I want inside Prelude is going to be a star or an Asterix this means I want everything inside the Prelude right and then if you put a comma here we're gonna get something else that's inside is it going to be Prelude or anchor length you've got it it's gonna be inside of anchor Lang we can get something called system underscore program right and another key thing about anchor is make sure you put semicolons right semicolons Mark The End Of The Line in code in JavaScript it's not like that and you don't need to put it but here we do so if you see any errors it's probably because you missed a semicolon so now the important thing that we need to import is we need to be able to get the price of the stock using the network right so what we could do is say pith underscore SDK underscore salon right the pith network has an SDK that we can use in our Solana program to load the price feed into our smart contract right so we can get that by going into it right and we don't need to destructure it you can say load price oops price underscore feed from underscore account underscore info and then semicolon right don't worry about memorizing a lot of this for me I had to read a lot of documentation um test some code and I was like okay this is what we need right cool so we are using that library and the next thing we should do is we should have the declare ID all right so oops declare ID and I enter and looks like this right this is going to be where our uh the pub program key of our app is going to be right which essentially is the key to access this program on the Solana blockchain so for now you can just put empty quotes because when we press this build button it's going to generate that public key for us all right think of it as the address of this program on the salon chain okay cool and the next thing you need to do is use this program macro so you do a hashtag and the right program because everything underneath this is going to represent the program right so then right underneath it if you hit enter say mod prediction underscore dab right this is the name of the program right which we also have right here okay so if you want to change the name of your Solano Pro Smart contract like on chain change this all right next thing you can do is put these curly brackets and everything within these curly brackets represents the program right that's the code blue okay cool and now that you guys made the program what you write in between these query brackets is all the functionality right so this should be familiar to you right how do we make a function an anchor right so to make it I would just say Pub all right public FN and then the function name so if you open up the default version of beta soul.pg you would see something like initialize right we need to initialize our app in here so it's a function called initialize what do we need for this prediction dap well we need to do something called creating the master so let's call that create underscore Master right because before we can create bets right and have player a player B we need to set up what's called a master account that's gonna hold the information of our program and you know all the functionality okay so how do we make the rest of the skeleton of the function we're just going to say uh Arrow here and then you're going to say result right boom and then open and close it and then parentheses inside of there and put these curly brackets in there and that's it this is the skeleton of a function in Anchor right see this so function name right this is basically the result and then curly brackets to put the scope got it okay cool so what's next now usually when you're making a function in Anchor you have to create what's called a struct that goes along with it so we need to make well the master struct so usually you can do it right here but what we could do is just make another file right so go to right here under source and we should be able to make another file let's create let's go here new file there we go and this new file we can call it state DOT RS right make sure it's RS and in this file we'll hold all of our structs that go along with our function right I've done it before where you put it all inside of the program right but the idea is to organize it and split it to files and then import the states into our program okay so I'm just going to make a state.rs alright so go ahead and do that and once you do that we can use anchor laying colon colon Prelude colon colon star and then semicolon nice cool so make sure you're using anchor link and we're getting preload and how do we set up um the struct for creating the master so the first thing you have to do is use this macro called account right because these structs they're essentially opening up what we call accounts on Solana the closest thing I could think of to help you understand it is that think of it as a object that you're creating on the Solana blockchain and anytime you put stuff on this line of blockchain it's gonna cost some soul right you're going to pay for the space that you're using depending on the size so what we're doing here is we're creating the uh the struct of the master account like what is that Master object look like what kind of properties does it have right so to start doing that you do the hashtag account then you can say Pub struct Master right okay and after that we can Define what is the master right uh this is going to make more sense to you if we make the bet but think about the reason we need the master is because we want to keep track of the last bet ID right so that every time we make a new bet we can just increment the master so we know how many bets exist so we could say Pub last underscore bet underscore ID and then colon right another thing that you need to know about Russ is that it needs to know the type of this like that it's expecting right so you say unsigned integer and then 64 is how many bits or bytes is this gonna be the limit right of the ID so it's going to be 64. and with that said that's it that's it for the master right but at this moment right now this master does not exist in the lip so how do we make it exist in the lib.rs right you guessed it we need to import it right so the way we import stuff you can go top here and you can say mod and then say the name of the file state all right oops and then afterwards we're not done yet we have to use crate right so what is use crate uh crates and anchor is kind of like package.json right it's the equivalent so you can say create use crate clone colon and inside of the crate we want to get a couple things and right now we just want to get a state right and remember what this means get me everything inside of this state all right so essentially we are bringing everything inside of the state into the top level of our lib.rs right so um in order to use it in here we have to do something like state DOT or whatever but if you just want to just use it straight up we can do something called use super right so at the top uh right here line 20 for me you can say use super colon colon star and then semicolon and don't forget to put the semicolon after the use crate as well boom cool so what does U super do it's going to bring everything in the top level of your lib into the program so you don't have to do state DOT or state whatever right you can just straight up use this master struct that we created okay awesome and I will just put this comma here because it's nice all right looks pretty good to me so next thing we gotta do is inside of this program here we have to create the struct for create master like I said for every function you need to have a struct with the same name all right you like that's the case like most of the time so I'm gonna go into line 25 for me make some space and let's get started on that all right so what can we do to get started well what I would probably do is go into here start up a macro and this one is going to be called derive oops to arrive accounts right so we're gonna use accounts right when we're defining the struct of create master so we can say Pub struct right anything under here is going to be using this so we're going to do Pub struct create master right and then give it a lifetime variable of info which just has one apostrophe in front of it basically a lifetime variable lets you know how long does this struct live in the smart contract right with the anchor uh and rust essentially it needs to know how big everything is how long everything will last so that you can manage your space really well look in JavaScript uh we're kind of uh we're they hold our hand in JavaScript because they have a garbage collector that collects it the unused variables that we don't use anchor you gotta do it all yourself anyways after you create the name of the struct you add this lifetime variable info right you just want to go ahead have this account macro here and put parentheses right and it's going to we have to initialize uh the account so it's going to say an account here right so let me just do it manually first and what you want to do is inside this parentheses say init and you're going to say pair uh payer who's going to pay for the space of this account and it's you the payer should equal the pair right and then comma the space is going to be uh eight which is how big this is going to be it's just going to be eight and then after that you're going to say Plus 8 so this second eight is what we call the account discriminator right how much space uh this account takes there's always going to be an account discriminator which you can think of it as the spacing between all the accounts in your program okay cool and then we have something called the seeds right so what are the seeds right essentially seeds are what the you know shuck takes in which is going to help generate a unique public key for this account right because after a while when we build this app we're gonna get a string of numbers and letters that's going to showcase the address of where our program lives every account is also going to have a public key Associated and it's going to be dependent on the seeds right so let's say it's inside the seeds it's going to take in the string Master right so we don't have that yet so let's just leave that blank for now let's finish writing this rest of it we're going to say bump and I'll explain that in a second as well but after in line 35 after the end of the macro enter and you're gonna say Pub Master right and what is what does this master mean this is the account itself right so this is the account macro this is the account that we're talking about right I'm talking about the master account what is the master account guys come on you made it right here the master object itself with this ID all right so that means we want create the create master struck to be aware of the master account so that's why we're doing this right here so how do we get this state all right we can just say count all right get the account give it info comma and then say the name of the um account which is going to be Master okay cool and what other information do we want in this struct Ure well it's going to be the account mute this is how we're going to get the payer right so we're gonna say Pub pair right because when we said pair equals payer at the moment you don't know what who that is right well payer is going to be the signer right whoever signs a transaction and you might be thinking Lance when did you write sign or we didn't make that in our state well guess what sign there comes from Prelude yeah so again this is stuff that you can do by reading a lot of the documentation I'm just simplifying it in my explanations if this is your first time okay amazing so the pair now exists right we're good to go in that and the last thing is we always have to put the system underscore program and this is going to be the type of program right so this is just defining what type uh to expect from this so Master is an account payer is the signer System Program is coming from program and then again info system okay which is coming from another library that we're importing at the top okay well believe it or not this is it this is the create master struct we just need to put in the seeds right so what I'll do is create another file and this one I'm going to be calling constants const the install RS and this is where we're going to hold all of our variables our constant variables right and again another way to do this is putting it all at the top here but we could just make a constants.rs all right so what I'll do first is say use anchor Prelude right there you go uh and we don't necessarily want everything but Let's see we can leave this for now all right we're gonna add more to it later but let's say our first variable is gonna be Pub const and remember this is for the seeds we'll say master underscore seed colon and what type is the master seed well it's going to be and brackets u8 is equal to B don't make sure you do B quotes master all right this is essentially a binary string right cool and we want to take this binary string and put it into our seeds all right so bear with me for a second so that should be it put make sure you put on the comma put a semicolon and we're going to be adding to this every single time as we go through the app and let's get imported our constant so you know if you want to test yourself try pausing the video and see if you can get the constants.rs into your lib.rs awesome if you tried it the answer is you need to put mod right here and it doesn't really matter what order you do it but you can just say constant constants and then you can put a semicolon okay and then in your crates you can do a comma and say constants constant colon colon and get everything from constants even though there's one thing we're going to get more later so constant state boom so now we can just use it directly onto here and instead of getting you know the fair like saying it's constant and then getting Master seed right we can just say master seed right all right so like I said just write Master C all right me doing this is almost the same thing as writing uh binary string Master inside of the seats okay but we want this one because that's going to hold the variable all right so now for my explanation what the hell is the seeds lens well you could think of it like this I'm going to use something called a dice bear right which generates an avatar based on your seed right season um what's called Solana is a little bit different right oh I'm not going to go over like how it works exactly but the way that I understand it you can go into here right depending on what you write as your seed we'll get a unique Avatar that's how dice Spirit works so if I write Master here this is my avatar when I put in master as a string and a seat right so it's the same idea with Solana if I put uh the Master Seat here it's gonna instead of generating an avatar it's going to generate a public key for my master account right so let's add let's do a little diagram right let's say this is our app and this is the Solana blockchain Solana right my app is going to create an account or a master account and what it does is it's going to create some space in here this is going to be the master account right and this master account is going to have a unique public key so it's going to be something like this right well there's not those special characters but it's going to be a random set of letters numbers or whatever and this is going to be the essentially the address of this account so when I go to fetch it right I just type this in my app and I'll be able to fetch that Master based on the public key so that's why we need to generate a unique uh public key we have to put in the seed right and this bump right here let's say there's already there's already something that exists with this public key bump is going to essentially go to the next available public key right so you can imagine this like oh there's already something that exists with Master let's Sprite that's right um Master one and this is our unique Avatar or our unique public key hopefully that made sense right essentially let's generate a new public key and if it's not available bump it cool and then from there we can test it by building right there might be an error but let's just see if it works if we cannot compile you can use Imports constants oh okay okay I see all right so we got the error um I think oh yeah we need to add commas here right I can't forget that and the last thing we should probably do is finish up our function so the only thing we need to do with create master right the struct handles it already right in this truck we're initializing the account so we don't have to write any new functionality for that anchor is handling that for us so what let's do is just say okay right it's an enum basically saying like we're done we're oh it's successful right okay all right so now let's try to build there is a error custom attribute panicked oh and how could I forget I think I know the reason why the reason is because if you look in here the function it needs to take in what we call context right and usually to do that you just write CTX for context and if it's unused in the function you have to put underscore and now what is the type of the context what is context well usually like I said when you create a function you have to create a struct with a similar name right because what you want to do is bring in all of this into the function so you could just say the type of this is context inside of it it's going to have the create master struct okay and boom this is like a return the result and then we'll do a building come on let's go build successful guys so that's it that's how you create a master their very first function on the Solana smart contract all right so the next thing you want to do is go ahead and deploy the app and you might need some Solana to do so right so if you need more Solana on your app you're just going to say Solana airdrop 2. right cool uh it says success internal error that's fine sometimes it does that you just have to wait a bit and you should get some soul but I think I have enough because there's not much in our program I'm gonna go ahead and hit deploy and once it's deployed right we're essentially taking our smart contract and the pl this is our smart contract it's kind of the big deployed onto the Solana blockchain right so that's why we have to pay some soul and luckily it's not real right so we can deploy as much as we want and then later on we need to fetch that program into our app okay so that's the idea all right so I'll just check back in when it's done hey let's go deployment successful right and as you can see we lost uh three soul for that the point uh deployment so now that's deployed we can go ahead and test our functions and see if they work right so let me show you guys how to test your function so anything that says instruction that's your function and now this is also the accounts as you can see here that we created so if I asked you guys do we have any Master accounts that we created no we have none and it comes in an array so keep that in mind so how do we create a master well we can test that function right here without even connecting our app which is awesome so first thing we need is the master uh public key and we can generate this from seed so what did we put in here right remember in our constants we have a binary string called Master it doesn't have to write a binary anything here you could just say master for this and it interprets it and the program ID is going to be there by default hit generate and the payer right who did we say the payer is guys the payer is payer or in other words the signer right so we can say my address because I'm the payer so now uh if you don't have any Solana you should probably get some now but it doesn't usually cost much much to create this and I know that because it's only 64 bytes so let's go ahead and hit test let's go test pass creating the master so now if I fetch all we can see that this master has this address right so to visually show you guys this master has this public key as the address right and it has the traits of the account that we gave so it has the last last bet ID okay so what do we want to do with this every time we make a bet we have to go into our master account here and update it with plus one right so once we do that uh our last bet ID will be one so keep that in mind this is the master I'm glad the test passed what's next all right so if you understood everything that just happened you essentially finished the tutorial let's move on to the beta count itself okay so what we need to look at right we don't need to see this that much anymore we need to look at is creating a function guys so how do we create a function inside of this app all right we can say Pub FN oops FN create underscore BET right and how does the skeleton look like it's going to be parentheses Arrow result like this and then so the curly brackets like so another thing I'll do is I'll move uh this struct outside of the program because it doesn't need to be there all right and see if it builds still I might not build because we didn't we actually didn't finish uh right in the function so I'm going to just take it out temporarily or comment it out it's still acceptable yes okay so this is acceptable still and we updated our build now let's continue writing our function so we made the function what else do we need to do we need to create a struct that also has this function so the struct that has this function is called create BET right and what should create bet do right what should create but do it should create a bet account right so we want to create a better account first we have to Define what a better account is so I'm going to stop doing that and go to state.rs and let's create a bit account so to start creating or defining an account right we can say attribute account and then you can say Pub struct bet okay that's all you have to do and then after that you have to identify what goes into a bit so what are the attributes of a bet if you guys made classes before in JavaScript it's essentially this is essentially making a class so every bet should have what should have in ID all right and what should be the type of an ID an unsigned intrader 64. kind of like this all right and we can use the master to Define what the idea is all right what's the last one plus one of that there you go it's the new ID okay uh next is we need the pub amount right how much is the BET Worth right how much does it cost and another thing is usually we talk about it in Seoul when you're in the Solana smart contract it's going to be in what we call Lamp ports right which is a smaller unit of Soul so if you think about a dollar uh a sense is what land boards are essentially okay the next thing we need is Pub prediction underscore a right this is the essentially the prediction of player a and the type of this is going to be pretty interesting right it's gonna be something else that we call a bet prediction all right and I'll explain that later but prediction like so cool and then next we need Pub prediction B right and it's not going to be the same thing right because there's going to be an option right because by default uh when you create a bet you're always going to be prediction a that's always going to exist but when you're creating a bet player B doesn't exist yet so it should be null at first so that's why we're going to say option and then inside of that we'll put but prediction okay and then after that uh we should have the state right and by state I just mean what is the current state of this bet is it it was just created did the BET start did somebody win right that's going to be controlled by something called a bad State and we're going to be defining what this is and this is just a bit uh last but not least we need the pyth price key right the pub both or piss price key and that's gonna be a public key and you can simplify by writing Pub Key so what is pith price key well we're going to be using we're going to be using the uh what's it called the pith Network so what we can do is make a new tab and say pith Network right and essentially they're getting realtime data from Real World Markets as it says here and if you look there's many different stocks and crypto that's keeping track of and if you let's go ahead and click AMC you can see that it's fluctuating between its price and you can see from the graph here it's that three point eight nine right now right and you can see that all the transactions where it's updating that price and it's pretty fast it's going to be from two seconds to you know two minutes and to get the price or to know what the price is you need this public key right here this is called the price key and the cool thing is that you should understand what this is now because this public key is going to go to the account in the Solana chain that holds the price which is like 3.8 right and this account constantly gets updated over and over again right over and over within that time frame so it's always going to know right it's real time of the stock of AMC okay and to utilize that right that's why we're using the SDK all right we also need the public key stored into that bet itself right so we know which one to look for all right uh the last thing we need is something called the timestamp right we need to know how long is this bet going to last for it's going to last for one minute two minutes five months right so we need to say uh expiry expiry underscore TS colon and then you can say uh I 64. this is different than u64. to sign an integer and comma okay so I'm just gonna add comments really quickly so that you understand what and remember what each of these are there we go so I just paused it take a moment and write some comments for you guys so you can understand so pause the video if you want to take a look and add these yourself but essentially it's what I explained as I was typing so we need to define a bet prediction so I'm going to come down below here and we need to write something like this derived and then we need anchor serialize and to deserialize and it should be coming from Prelude as well and then there's last thing called clone because we need to add some more attributes or I guess properties inside of this prediction a right because prediction a is going to have a struct called bet prediction all right and this is also going to be inside prediction B the goal with this is to store the player right so you say Pub play and that's going to have a public key right every this is going to be the wallet essentially that's playing so your wallet if you remember has a public key all right and my public key is this 8tkz round okay so that's done um another thing is it needs to know the price right the price prediction right what did I predict that it would be all right and I want to use this right inside b as well so I'm going to reuse bit prediction right and give it an option because the option can be none or it can be these okay and this is the Safari comments this is the price prediction in USD and of course this is just the address that bets all right it could be player a or player B and then after that we need to make another one this is for the BET state right because it's going to be different things and we need to serialize it and deserialize it again so anchor serialize comma oops anchor oops deserialize clone and then there's a partial EQ that we need okay because this is going to be an enum right so Pub enum uh bet State and again it's going to be created started uh what's another one uh player a one and it's also player B one and then there could be a draw where they both somehow guessed the same exact price not likely but it could happen Okay so there's created started player a player B and draw right there's actually a lot of logic that goes into this uh I did simplify it so that you can get just a better understanding so keep that in mind and that should be it so believe it or not all the states should be done unless we need any more later but I feel pretty good about this so that state is done now that's next is let's finish the create bet struct so I'm here at the create bet uh struct right at the lib.rs and what we need to do is just derive accounts again so we're gonna say derive oops the rice derive accounts like that and then just say Pub instruct create BET right as you can see it's similar to create master and even the info part is going to be the same okay put the color brackets to identify the scope and next let's initialize the account so again uh anchor has a way to initialize the account already oops you can initialize it by literally writing a name now we're done it's initialized right next to Define who's paying for this you guys should know it's going to be the payer which we'll Define later next is how much space it needs right so we need to essentially figure out how much space does a bet need and depending on the type right we need to tell him all right it's this plus this plus this plus this right you can find this out by looking in the anchor documentation how much is each thing uh but I can tell you already it's going to be eight plus eight plus thirty two plus 8 plus 8 plus 32 plus 8 plus 1 plus 32. plus eight plus one and let me just double check this is it yep that looks good to me let's put a little space here yep this takes a lot of space because the BET has a lot of information right even has uh some more properties within that okay so that is the account initialization we just have to put the account right underneath that so we can say the pub bet colon is account right and what is the account well first you got to put the lifetime variable of info and then you can say the account is BET cool next we need this struct should also have in the in the context when we bring it in it should know about the master account so we need to get the master account so we don't need to initialize it keep that in mind we just need to get it so yeah I might have a comma here there you go now it's the correct color we say account and instead of saying init we want to say mute because it can change it says seeds is equal to master seed so what do we do here we're getting an account with this seed right and again if it's what exists was Bump there cool Pub master is gonna be the account info comma master all right so there we go we got we're able to pull the master account by doing this next is gonna be the player account right we need the player so actually this I named this player now same thing it's going to be the exact same thing uh account is mute because it can be there can be different players here and you're just gonna write Pub player so now this is defined but what the type is this it's just like before it just has a different name guys it's gonna be signer with info okay I should keep forgetting to add these commas there you go and last but not least the pub system program and we can pull program from there a lot of anchor code is uh just repeating it's like boilerplate so once you get the pattern it's going to be easier for you to create whatever smart contracts you want so that is the create bet struct okay now for the functionality of create bet so what does that need to do well create bet uh you can do a couple of things the first thing is needs to take in the context so get the context and this is actually gonna take a couple of things you can say CTX right comma you can say amount uh when you create a bet what else do you need you need the price prediction right duration um and the pith price key or pyth Price key I don't know how to say price key okay cool and then close it off next you have to put the type of it right so the context is going to be context and the context is going to be the create bed struct the amount right how much are we betting is u64 what is the price prediction uh remember it's going to be in USD so it's going to be f64 and then duration is going to be u32 and I'll just make a little comment here that this should be in seconds rights seconds and then we have this which is a pub key right this is the price key that we will get from here and I've already hardcoded that into the code so you don't need to pull it okay next is the result right so what is the actual logic of this function well the first thing you need to do is uh increase the last ID on each back creation on the master right it's the master ID should be increased and to get the master ID right we first have to make a variable called let Master right this is normal is equal to and mute so this is new right so we want to say that the whatever after this can change it's not one static thing Russ needs to know that right so if it does change or if we do update it it's going to be CTX dot accounts all right so what CTX it's our context okay what's in our context all of these two accounts so that means if I do T accounts I now have access to the BET account and the master account so how do I get the master account from here right think about what an object is you have to say dot Master cool and let's get the BET while we're here too is equal to and mute ctx.accounts.bet make sense right this is essentially the object and we're getting the master from the accounts and we also have the bet there it all exists because we ourselves created obstruct okay so now we can do whatever we want so like I said how do we increase the last ID on the master well this variable holds the account so I can say master right and then in if this is an object what properties does it have so we can even look at it here if it makes sense for you it has last bet ID so all we have to do guys right is dot last bet underscore ID and do plus equals one right just not scary code Solana isn't scary all right you just need to get used to the wording the documentation and why we do things right and again I'm no expert right I just do this a couple times until I get it I've had help right ask questions on the anchor Discord or the Solana Discord and it'll help you get better at this so keep doing this over and over watch this tutorial several times and it'll make more sense so then the BET ID is going to be the master last remember I told you right the bed ID is going to be whatever the master was plus one we already initialize it here or update it rather and we can just use that same variable here cool and this will happen every time I want to create a threat so it's pretty good logic here the next thing is the bet dot pith underscore price key our pipe key is going to be equal to this right the one that we passed into the argument right because we're going to do that in the front end oops sorry pyth or pith price key and then don't forget the semicolon here uh and then it's it's pretty straightforward you just plug and play everything you wrote down so it's going to be better amount is equal to the amount I passed in the BET dot expiryts right this is the timestamp and you need to do something something like this function called the get Unix timestamp right we're able to just get the current timestamp using this and we're going to add a duration as I 64. and then semicolon right because what's happening is I'm saying um the bet is going to take uh 150 seconds which is like two minutes it's going to take what's the timestamp now and then add the two minutes and that is when the BET expires and you can't enter anymore right or else it's unfair all right next is the bet.prediction underscore a right we're actually going to Define that the bet prediction right it's the object here and the player because we Define bet projection has player is going to be CTX we need the public key of the player we can get that by viewing dot accounts dot player dot key okay and then come then from there you can say price okay and then semicolon here after the bad prediction and the last thing to do is uh we need to actually get the Solana from our Phantom wallet and put it into a thirdparty account or an escrow to hold that bet right so the idea is both players put money into the third party account and then when it's done that third party account will send the winner the total pot okay so we can use an escrow for this so we can do this and I'll just write a comment here transfer the amount to the BET PDA so we can say system underscore program transfer and say CPI context new there you go and that's exactly what we'll write so we say c p i context I'll go into that and say new I just how you oops oh well okay uh don't need that boom all right this is the how we go and transfer it CTX dot accounts dot system underscore program dot okay oh sorry dot two account I think two underscore account underscore info and boom okay so essentially we're putting that's the player's Solana into the BET PDA or the account okay and here we can do the transfer System Program let's get the transfer and we're gonna get this from the player so we do is ctx.accounts.player.2 underscore account info and then we can do two bet so we're taking the money the soul putting it into the bed account and once the BET's over we'll give it to the winner uh and we can comma here but the BET dot amount okay and there's some things you need to add like this of course when the function is done we're going to hit OK so I know it's done um so that should be it for this and now I'm just gonna run build there might be some type of errors or I might have spelled something wrong so let's just see do a check yep there it is oh there's a little M here all right it's insane with uh rust because one error is going to mess up the whole code let's do this one more time believe there's still more yep forgot some semicolons so let's go to where I wrote bet semicolon semicolon and then it says beta expiry TS is unknown okay let me just check this state oh underscore TS whoops where is that it should be better expiry underscore TS okay and I think there was one more issue it was CPI context oh is it because I forgot the add 30 let's see build okay cool uh now we need to fix the get you next time stamp get your next time stamp doesn't exist oh right okay I need to make one more file it's gonna be the utils right there's some functions that we need to create uh to make a lot of the code doable again this is a pretty big program that I have to scale down so if you do use anchor Lang in here get a couple things oops and we want to get Prelude of course Prelude colon colon star comma means Solana program clock Unix time stamp okay uh the main thing we want to do with this is create that uh get your next timestamp function right because it doesn't exist so let's make it exist and we can bring in our variables here because we're going to use them later so let's do a use crate let's get constants star and also State Hong Kong star so we can use them here and what we want to do with this is create that function so we need to make a function Pub FN get Unix timestamp so now it's going to exist uh boom and we can do an arrow here yep so now let's define a type of time step boom and this is literally just going to pull the clock from the anchor program and unwrap it and then we could store it Unix time step so this is what it returns get the timestamp at this current moment when it's run and then we can just go to the lib this should exist now because we need to import it so to get this into our program you say utils say comma utils colon colon star you super brings it into this and crossing my fingers let's go ah still doesn't work oh unexpected token okay that that's that error is usable expected a semicolon here can't forget those and try again foreign missing something new next time stamp not found in scope that's weird should be in scope oh anchor land that's probably why yeah so spelling is really important guys I messed that up a lot but we should be better now warnings are okay use clay just create constants let's go all right cool so again none of it was the logic it was just me putting semicolons and then the spelling so build successful right we can go ahead and deploy this now right yep let's hit build and boom right uh one thing is that we can't really test this just yet be because uh if you want to test it on Solana playground it uses the local local host and we can't it doesn't this python pith network doesn't work with localhost so I'm gonna have to transfer it into our app and then test it there but that is essentially the create bet all right so with that out of the way let's get to the next function so the next function is going to be entering the BET right so what does entering the bet mean it just means we should be able to uh participate in the bets that are already created right so we're not creating a brand new one we are becoming this is essentially player B's ticket to participate all right so it's gonna be called enter bet okay and the arrow and then the result at this point you guys should be picking up on the pattern to make the function okay and we know that this is going to have CTX and we know that it's going to take in the price right this is player B's price prediction okay so what do we need to do when we enter the BET guys well we need to create the context right or the struct that goes with uh entering the bit okay so let's go down here great bet and underneath this enter the bin so again we first need to derive accounts all right so oops I'd ask you guys do we need to crew initialize a bit account nope we don't need to do that we can just get the bed account so we'll just say Pub struct enter but and then put the info inside okay and then from there we can have the count and again we're not initializing it we just need to get that account so it can be the bets that we enter can be different so you want to make sure it's mutable the C oh did I put a seed for the BET I did not all right so that's one thing we need to remember I put the space here but so go back to your creep bet struct and we need to put the seeds in there all right otherwise it's not going to be able to create a new BET with the right public key all right so the seeds this takes in is going to be into state or sorry constants we're going to say Pub uh which we call this it should be I can just be bed seed so there's a pub const bet seed and it's gonna be similar it's gonna be and you ate oops is equal to Binary string and say a bit and semicolon cool oh and this should be Capital bad seat nice so now we have that it's already being imported so now for the create bet we're still back in Korea but we just want to say uh bet here bet seed seed not not seed but okay there is one more thing that we need we need to have the Masters last ID right so this is different than last time right we have the binary string bet and the master's last ID so if it was zero this would be the publicly if the last video is one two right so it's Unique every time depending on the last ID okay so it's going to be and master that last bit ID you can't just write Master last bit ID because you need to format it like so plus one and then you say dot two lip bites you have to convert this into bytes because that's what the seeds need to read it okay and then this should be come right here boom all right so we'll check on the facts give us any errors later on but we also need to add bump right because if it exists go to the next available public key cool so now you know good thing we did that because now remember to get the when we enter the bet to get to the bet that we want we need to get it by seats all right so that's the purpose of seeds you can also get the public key you want by putting in the matching seeds all right so to do that we'll say Bad Seed all right let's put in the bed ID because the BET ID is the same as that last Master uh bet ID all right the last one so let's do end that's that ID and we gotta convert this to bytes again so that to l e bytes and then to uh method there you go all right don't forget to add bump here then there is some constraints some seed constraints so we gotta say constraint is equal to validate enter underscore bet and you say and uh asterisk bet you can say at bet error can't enter right so basically if there is already some the bet is already entered you cannot enter that bed so this is an error better that we need to grab and create and this is another thing in our utils function okay so we'll come back to that in a second but let's just write out the rest of this it says Pub BET right all of this information is in this bet and what is the type of it it's an account that already exists it's info and then cool next thing we need is going to be the player right so there's no account for player it's just going to be stored as the signer right Pub player is the signer the assistant program right we always need this one system program is the program and look at the system nice cool cool so that is the enter bet struck where we didn't have to make a new account uh we do need to work on this part though so remember we got to check if uh player B is allowed to enter this BET right so we can go back to our utils we're gonna make a new function again say Pub FN uh validate enter underscore bet and it's going to take in the bet and bet and it's gonna be a Boolean here okay and essentially this is what we were going to return a Boolean and we're gonna get that Boolean by saying bit prediction right underscore B dot is none okay and then you can enter here and I'll just say end and we gotta check for the expiration so basically what I want to say is let's say player a makes a bet for AMC and he says it's going to go up within two minutes right you can kind of cheat that bet right if you think about it you can look at you can stare at this and if there's like two seconds left I want to say oh the price actually is 3.9 right you'll have a more accurate guess if you bet later so we shouldn't make an expiration time right so to make that expiration time we can just head over to Constance and make it right so uh let me just write that comment the closer we are to the expiry the more chances a player has to win right so we want to make an expiration time to make it more fair right we can add even more logic to like check for that but again this tutorial will be way too long but if you do want to see that comment down below and see like a fullon uh like full scale build of a betting system so let's go adjust this to make it more fair right so what I mean by that is we can say Pub const it's a really long variable minimum remaining time until expiry right and to get this you can use um printing another Library honestly don't even need Prelude here and it's going to be unused so let's actually get Solana program yeah we need this Library instead program inside program there should be a clock inside the clock it should be you next time stamp that's what we need yep okay so then now we can say Unix timestamp here okay oh sorry and set this equal to uh 120 seconds right so the last 120 seconds they can't enter the BET right uh we can adjust this to make it more fair you can say like oh after one hour before the bet you can't enter the bet anymore all right so this is essentially like a minute okay so I think it's a pub const maximum claimable period right since we're here this one is for let's say somebody wins they should be able to claim the money all right after a certain amount of time uh the money will actually just go to the user or be given back to the user right cool so maximum claimable period 300. okay so we have that we would really care about though right now is this one right here so let's go back to the lib and go back to our validate interpet and now that we made that variable and we're importing it here still we can use it so Twitter was I again now they bet we need the expiry expiry I can't forget the underscore and minus all right so the the time that the bed expires minus the minimum remaining time until expiring right there could be a better name but it's what we got is greater than the get Unix timestamp there you go right so this is how we can validate if player B can enter the bet or not all right it's going to be true or false right that's what is running right here so we're gonna have a constraint we're gonna check okay can player B enter the BET yes all right if he can't if it's false then we need to run this error this bet error right but right now bet error doesn't exist so we can make the error so to make an error we can have a file to have all of our errors so we can say error.rs and inside this this is the one that's going to use anchor Prelude so I'll hit oops let's see if I can use their import here nice and to set up your error codes which you can do in Solana is error underscore code and then say Pub enum bet ever like that okay so next we can do hashtag array oops and then just do message right so we're going to send a message and it's going to be can not enter right and the the name of this error is going to be cannot enter right so what's happening now uh is in here we're gonna the constraint of entering the bet is we check if this is true or false if they could enter the bet if it's false and there's going to be an error and the name of that specific error is the cannot enter one right and one thing we should do is import error as well so let's get mod error.rs oh sorry error and we need to put this in here as well so comma error colon star okay I think we are good uh we do need to finish up the rest of the what's it called the rest of the functionality of interbet so let's go ahead and do that so we finished the struct we're on the functionality now uh the context is the enter bet struct so we can add that right now enter bet the price is something that we're going to input through the front end and we say f 64. like it's going to be in USD right or like at least a decimal so it's float64 and let's get the BET into a variable and we need something here guys do you remember yes exactly good job Jeffrey it's and mute ctx.accounts.bet okay but that prediction underscore B is equal to right because this is for the the whole purpose of this function is for prediction B and remember prediction B um what is it again it has or state it has bet prediction and it starts off as an option right so we got to keep that in mind and so it's going to equal to sum bet prediction and kind of like how we set up the prediction a when and creating a bet you're gonna do the same thing so the player is going to be the player that's entering so that's the CTX that accounts that player and then we need their key so that's how you get their key again and then we need the price right so we're taking our argument and placing it here okay and then we should update the BET state to equal the bet state of started right where is this pet State started coming from guys all right if you remember our state we made that right here it's an enum which which means it could either be created started or any of these cool so the BET state is equal to started right we're not done yet though because when you enter a bet you gotta give us some soul to enter right we're gonna match the price so if it's two Soul give me two Soul so transfer the amount to the bad PDA once again uhhuh and then we do the system underscore program let's get the transfer in here and let's run that and we can say CPI context so it won't forget the T this time the new and pass it oops pass in these arguments which is going to be the System Program so to get that is ctx.com System Program dot two account underscore info okay and then in there we're going to say System Program transfer all right and so here we'll do the transfer we need the from and two so who is this from this is from player B which is the person signing so we can say card accounts.player.2 count underscore info and it's going to go to the betpda right so the better count so it's gonna go to that bed account okay comma here comma here right bet dot amount I go with the amount that goes in and we do need this question mark and there we go uh last thing we do need though is the okay and boom all right this okay if you don't know uh you can think of it as a return so if this function is all done and it's good you can return like the number five right I don't know how you do that but you don't need to we're gonna put nothing in here because all the functionality is happening right here okay looks pretty good to me um that should be interbet let's just build this and check for any errors which is normal right if there is a time that I never had errors I get so happy so prediction B uh some bet okay something wrong I might be the spelling yeah predict cyton prediction B and let's go build successful again don't worry about all these warnings right you can build even though the warnings are here it's just letting anchor letting you know like hey uh you wrote this but you didn't use it but we're all gonna use it eventually right so I'm just setting some stuff up so build is done that is entered in all right so we have enter bet let's get started on claiming BET right because what we have so far logic wise is we can you know create a bet put duration on the price player B can now enter it but now once the bet is over we need a function that's going to let us claim that said bet so once again how do we make a function it's just Pub FN and then the function name right from here you need to put the parentheses for the argument the arrow and then result boom okay and then after that Charlie brackets to put the scope and the only thing that we're going to need for the argument is going to be CTX right and we're going to Define what the context type is in just a moment all right so the first thing we're going to do is scroll down to the bottom right here and let's find and create claim bet all right so we have enter BET right here and then we need to claim bit all right so claiming bet how do we start this all right the first thing we need to do is get the accounts that are relevant for the function right so to derive accounts we need to say derive accounts right and what accounts do you think we'll need for this BET right after I write the name so as I'm writing this think about that Pub struct claim okay and then we need this info here info and color brackets all right from there we can do the account that we need and you guessed it it's going to be the BET account right so we don't want to initialize an account so we don't need to write init here we should write though mute right and then how do we get the specific bet that we need we need to put in the seeds all right so to put in the seeds we're gonna do a seed equals oops C equals and then we have to say I believe bet underscore seed comma and then we have to say the and bet dot ID Dot and turn this into bytes so do two underscore Le bytes and that is a method so parentheses boom and that should give us the bet that we enter uh and then boom right and then the constraint so there is also a constraint here oh compataro right constraint so what's the constraint here well we need to validate the enter the not the intimate the claimed like can we claim this bet that's what we need to validate so we need to go back into our utils and let's create that function real quick so I'm going to go under here and say Pub FN validate right this time the claim but can we claim this BET right so there's two things you need to think about one is uh is the is this over right is it expired is the BET expired can we still claim it is time not up yet if it is up we shouldn't be able to claim it right if the bet is two minutes long and it's only been 30 seconds I can't claim this BET right you should get an error for that which is like six thousand and two I believe Okay cool so what we can do to check this is a match statement and say bet.state all right if the bet that state bet State colon colon started and if you're wondering what uh BET's date is if you go back to our state.rs we made bet prediction and we made bet state so what are the couple different states we can have created started right so which one do we need right so let's go back to our utils so if the bet is started right what does that mean okay then say equals Arrow and then curly brackets all right so if the bed is started let current timestamp or TS equal to get Unix timestamp all right get the current timestamp with this method okay and set that to current TS and don't forget the semicolons here and what we need to check for is this variable let's say let time past since expiry right is equal to the current time so the current underscore TS minus the when the BET expires because the bet that's another condition you think about the bet is expired uh we shouldn't be able to claim it anymore expiry dot oh underscore TS okay and then uh if zero is less than the timed past expiry and oops and the time passed since expiry that would mean it is less than or equal to less than or equal to I wonder if I do this yeah there you go that's the symbol we need maximum claimable period right we're checking if this total statement is less than the claimable period because if it is we should still be able to claim it if it's not then this will return false which means we cannot claim it right so that's what's Happening Here we can do a comma and then we have to do a dash I believe what underscore then do equals Arrow false and then come cool so that's how we can get it to be false and then if that's false then we get the Boolean false as well let's go that's going to be the validate claim bet which means we can come back to our lib.rs and actually use that function we just created which is going to be validate oops valid date claim underscore bet okay and then it should be like a and star but just like before up here and the BET error that we want is cannot claim so at bet error cannot oops cannot claim it means let's make just sure we have that error so check error.s we do not have cannot claim so we need to create it right so put a comma here oops I need to put a message that says I cannot clean all right so now it exists after we Define it okay and there's a couple different errors that we're going to need since we're here and you get the idea I'm going to do the rest of them now so let's do another message this one's going to be cannot close right okay not close okay uh there's a couple other error messages where it's gonna be like if you have an invalid pith key so we can say given key for the pyth count I'm always saying the different way to say it does not match right so let's say you're right you put in the Amazon stocks key and then later you're trying to use Google it's gonna know it's gonna be like that's not the same one so then you say invalid this will help us troubleshoot okay there's another one message uh there's also another invalid pith account right so we can say invalid fifth account my hands doesn't need to be capital invalid count this one has to be capital one last one I believe it's gonna be the price is too big to parse right because if you remember when you create a bet you parsed it with u64 right so if I go to state yeah u32 so this is the limit of the space so we don't want to do anything bigger than that and just to be safe we need to put it to 32. so we can say uh this error happens when price is too big to parse to you 32 right even that's the limit is u64. we don't want to hit that limit right so we can just say a price too big all right cool so we might not use all these errors but we're definitely going to use these three for sure but this if you want to add more unique errors for other situations because there's a lot of Logics in a fully functioning lottery app make sure to add them here so this is all the errors and now back to the lib.rs this bet cannot claim error is gonna run now because it exists and all I have to do is put a comma here and the whole point of this oops the whole point of this was underneath this whole account information we're gonna set up the bed so we're gonna say Pub BET right and the type is an account info and a bit and now I'll put the apostrophe in a second there we go all right we're good and then a comma here to set up the pyth Oracle account right the pith price Oracle account so we can say say like this all right because remember each of these is an account as well so there's an account for AMC and it's going to contain a price and in in the back end this is constantly updating to the latest price so for here to get that account we have to put parentheses and don't press init because that's making a new one we're going to say the address of this account that we want is gonna be the BET right because now we have access to the bed account if in this truck the BET dot uh sorry bet that dot pith underscore price underscore key and then there we go all right so how did we know that this is where the pith price key is well if you go back to your state there is a attribute or property where we store that and it should be there after you create your bet right so you can say is equal to that and then you can say at bet error right because what does this do it means that if there's an error here it's probably because uh it's an invalid right so that's why I made those errors and then from there uh we can say Pub pyth or pith account info boo so essentially get me the address of the bet.pets price key and if it's not the same then we'll get the invalid or it's not correct it's going to be the invalid error next thing we need to initialize is both players so let's get their accounts as well or their the part of their accounts which is going to be account mute and their address is equal to the BET oops bet dot prediction underscore B dot as underscore ref dot unwrap right because whenever you do this you have to unwrap it and then you get the player from that bet all right so we're going to the bed account and if you remember in the bed account there is a uh prediction bet prediction here there's two actually one for a and one for B so we need the one for a right so this is for B so let's do one for a actually I'll come back to that because that's for B and I'm thinking about it so we need to count address is equal to oh sorry mute this could be different address is equal to but that prediction and how do we get a a DOT player yes and then from here we could say Pub player underscore a is equal to account info all right because we just want the info of this account apostrophe not quotes info keep pressing that okay in oh there we go then the comma after here cool so that's player a and this is player B and the reason why I did this for player B is because they they are in an option so we're gonna unwrap it first get the then get the player oh man this one's gonna be Pub player underscore B is equal to count info what's going on Pub player foreign oh it's not equal sorry colon colon account info info .com hey there you go cool and uh the next thing we need is the things that we always do every time we create a struct which is identify the signer who's signing this transaction and the system program so honestly we could just copy this and paste it right here and hit save oops we don't have to save it like that and then the player right this is gonna be confusing because there's two players we can just change the name of this to a signer signer and System Program can stay the same and with that said that is the clan bedroom struct right so we have all the account information we're accessing player a player B within the struct let's bring that struct into our function right as context and say context Arrow claim bet and let's start working on the function itself so this function has a lot of logic that goes into it because not only does it need to run a couple checks it needs to take the money right from that thirdparty escrow account the BET account to the winner and that winner could be player a or player B and we can also need to check for can they even claim it so let's go ahead and work on that function now all right so now we're working on claimbet and what I want to do is write a couple comments so that we can identify each section so the first uh thing that we should think about is check the winner and send the prize to the winner or return them back if it's a draw right because that's also a possibility right so how can we do that well first what we've done before was set a variable and set the account in that variable so let's do the same thing again so let's set the bed right it's a variable equal to and mute right and mute CTX right our context argument and from that object you can get the accounts and the account that we want is the BET awesome Okay cool so we have the better count and what is the prize Well the prize is let prize is equal to oops to bet.amount dot checked Mo to uh dot on rap okay and then from there we can do this right here bet dot two account oops account info under uh parentheses Dot fry borrow all right try borrow mute Lan ports equal to the price all right this is important that we do this because we need to figure out how much the prize was so we can do that by getting the BET amount right and then we can go into the bed accounts info and get the all the Lan ports that we put in there we're going into the third party account and subtracting it by the prize which should be the whole thing that's in there or that we put into there and then from there let's get the pith price because we need to determine the winner right so we do that by saying let pith or pyth account info is equal to and CTX Dot accounts.pit okay cool so then let's say the feed right so we gotta load the price feed now right because if you remember this this right here is updating constantly so we need to know as you can see it's like moving slightly we need to know what the the current price is at the moment so we said load price underscore feed from underscore account underscore info pith underscore account underscore info and then you can add a DOT map here right after.map uh map error sorry error and then this bar oops okay I learned a lot of this from looking at the documentation and testing so oops let me do this and then you can say space error exclamation point and then if there's anything that goes wrong we say bet error you got the invalid python remember that error we made earlier so we're going to use it here if that error exists all right so if it's good it doesn't there's no error we can keep continuing so we say price data is equal to feed dot get price on checked all right so now we can get the price in price data and I'm gonna hit enter again and let's do a require here and we need the price dot data dot price right so yeah and then a less than equal to again for f64 that float 64. and the max that it can accept as signed into juror 64. comma bet error right so remember the price too big error that we made so we're gonna do that here so here's another check price is too big too big cool so first we're checking if it's a valid pith account then we're checking if the price is too big and then we can after all that's good we know that the pith price now fifth price is valid and it's equal to this variable which is going to be the price data dot price and make sure it's as a f64. okay and then now we can put in the message here for ourselves so we say pith price is colon and then if you put this curly bracket here it's Gonna Fill this is kind of like a placeholder right where if I put a pith dot price here it's gonna take whatever the price is so let's say the price is like two dollars it's gonna put this in the code bracket and the message will need that the price is to Solana or to sold or two dollars whatever it is cool now we need to adjust prices to compare them with pits price right so we need to compare the guesses essentially that player a and player B wrote and compare it to the current price and see who's the closest right so this is another place with a lot of checks okay and then we also want to just make a note here real price is equal to pith price times 10. this is something that took me a while to figure out but there's something called pith exponent and that's just the conversion that we need to compare all right so the real price is this the real price of the stock is this price time step you guys keep that in mind so we can say the mult we can store that multiplier in a variable I'll call multiplier is equal to uh 10 F 64 dot p o w i and then you can say Dash price underscore data dot Expo right yeah there's going to be a lot of troubleshooting after this because this is where their apple can go wrong most of the time so you're gonna might be here a while cool that multiplier is equal to that and then we could say we need to get the player a and player B's adjusted uh bet prediction so we can say let adjusted player a is what I'll call it equal to bet Dot prediction underscore a DOT price times the multiplier okay and then we could do it let adjusted player B is equal to bet that prediction underscore B Dot and this is the one that's in the option right so we have to do the B dot as ref dot unwrap it first and then we could do a DOT price yep and then times it by the multiplier to get it to compare to the pith price and multiply nice okay now we can say the message here just for sanity's sake and say the adjusted player a prediction is now this right and then what we're going to put in the color brackets is this variable player a cool okay same thing here I might just copy and paste it to save some time and just make sure you change this from player A to B and this should be player b as well okay awesome now we have to uh compare the price who's the closest so we need to do this by saying another variable let ABS player all right a is equal to parentheses here fifth price or what the pith price is minus the adjusted oops adjusted underscore player underscore a and then dot absolute abs and then same thing player B ABS player B is equal to pith underscore price minus adjusted player B dot abs and then whoever is closest should win so how do we check for that well we're going to need an if statement here if ABS player a is less than ABS player B who should win guys all right think about that for a second if the difference of the pith price and the adjusted player is less than the difference of this and player B who should win all right well if the the price adjusted price is lower that means there's less of a difference which means it's the closest right so then you can say if uh this is true the winner is drum roll winner is player a and then you can say sending uh this much lamp ports right because all everything that's happening here is done through Lan ports and then later we gotta convert that to Seoul when we uh give it to the player and then comma uh the thing we'll put in the curly brackets is the prize okay cool so now we can do a bit dot state is equal to but state right we gotta change the state because it was it was started but now if the player a wins we have to say the state is player a one if you've got an error here it's because you probably spelled it wrong okay and then now we have to update the CTX account so we can say CTX oops CTX and I'm gonna hit enter here and then tab so that I can format it like so that accounts nope dot player a right so I'm just going to my contacts I'm getting the accounts I'm going to the player a and I'm going to get the account info in there so uh oops so to get the account info I'm gonna say dot to account info then let's get the Lan ports try borrow mute Lan ports question mark If there is landports plus equals prize let's go cool all right you with me so far guys if that's the case it's gonna add uh get Lan Port from this equal to the and add it to the prize variable and then we can close it off so where is the closing one for this it's right here because now we need an else if what's going to be the else if condition I'm gonna give you guys three seconds three two one right the lsif is the opposite right so which is ABS player B is less than uh ABS player underscore a all right and then this is going to be the same thing uh we can copy this message and the BET State actually accept change this to player B make sure you change it and the BET state is not player A1 it's gonna be player B1 okay cool and then from there uh same thing I need to go into the context again so CTX and then I'll do this format oops dot accounts or in the accounts now we can go into player B but remember player B should be option but then we can just get the account info because we got it before to account info of player B and then let's try to borrow try borrow mute and then get the lamp Port then plus equals prize as well Okay cool so we have the situation for a you have the situation for B oh yeah there is an else statement right because the last possibility is what it's the draw right so then we can say and what should happen in the drop right let's think about this in a draw everyone just gets their money back right let's for say whatever reason you have the same exact guest and you're the same distance from the uh real price then we can set up a variable called Draw amount is equal to the BET dot amount right and then you can say message here and let them know it's a draw draw sending both players lamp ports oops you don't need to put this in color brackets lamp ports okay and then what is in that color bracket you can put the draw amount so sending both players like two Souls the the price to match is to sold and then uh the winner would usually get four but in a draw they just get two they both get two so the draw amount is here and then semicolon we say the BET dot state but that state is equal to bet State colon draw cool yeah like I said there's a lot of checks in this lot in this uh bet prediction app um again there was a way it can get even more insane right depending on uh the complexity right so this is a simplified version actually so let's return both players all right okay so let's return it so we have to do this twice so CTX dot accounts let's do player a player a oh underscore a dot two underscore account info and then try borrow mute Lan ports there is available Plus equals draw amount so we're both sending them the two okay and then same thing here but we're just gonna do this for player B and since it's the exact same thing which is going to change one thing player a to player B uh we should be good to go so after that closing else statement I'm gonna hit enter and from here we can just say okay okay that was a hefty function um I'm gonna do is hit build and let's just troubleshoot this because I'm not sure if it's perfect or there could be some spelling errors or some semicolons I forgot so let's go ahead and do some troubleshooting all right let's see what we need to work on so let's do build and yep as expected so let's go over all these errors there's a lot right so the first thing is going to be missed match closing limiters that should be an easy fix going to line 222 222 and it might seem like a lot but maybe some of these are caused because of the first air right because that's how strict rust is so let's take a look and taking a look at this I can see that usually this has a closing parenthesis opening parenthesis and it doesn't close right here so let's close that off and let's just wonder One More Time okay so building here expected semicolon bound bit so again means we forgot semicolon line 114 to do and the lib oh yes in our message we need to copy that and I'm pretty sure we did copy paste this so we need to make sure you copy paste the semicolon as well so did we do that yep here's a message and one hack is that you can actually clear the terminal by saying clear so we can start fresh all right easy on the eyes hit build okay expected a comma or a closing credit bracket but found an exclamation point again in our lib so 122 oh see notice how this message here right isn't the same color as this message here right so that means there is something weird with this hmm trying to sit here think about what this is something to do with what's before there is a curly bracket for it oh I see there is a space here hey okay there you go awesome all right I forgot to put underscore B let's just clear this again hit build all right what's next so cannot find context in the scope that's interesting so let's go to 87 and can't find a claim bet so let's just check down below did we have clean bet yeah we do oh did I write context wrong con oh context without the T so we need the T in there don't forget your little tea so let's go ahead clear hit build all right so we need 99 yeah this is why it's good we're doing this now but require uh needs and exclamation point all right so let's add that exclamation point did we use require anywhere else here nope let's do it clear and build price 99 yeah there's no such thing as price.data it should be underscored data okay I think build again good price not fine let's go cool so it's a lot less errors than before pith price is not found in scope and I should it's probably one of those things where it's like underscore price again okay 107 cannot find multiplier spelling right yeah at least the the errors are not like code breaking so far it's just smelling uh 99 and needs Max all right so I just took a moment to clear a lot of these spelling errors and semicolons the next thing that's not either of those things is this Arrow right here all right if you look closely it says uh could not dereference that's what this star star is and it's in line 2124 so let's take a look we should be able to dereference it because it didn't give us any problems in 116 right but it's giving us problems in 124. so let's take a look hmm okay so this looks like it's fine we are going into accounts player B to account info same try borrow Lan ports oh oh okay I see let's see if we add this semicolon here because we have to make sure that we're able to do that first awesome okay cool I think that fixed it yep needs a question mark here and now we just have the one error which is uh 219 and I feel like it's a spelling error which you guys know that we could fix so 219 per dick saiton right this switching of the two letters can break your whole code but if you put it back to normal it should be good to go fingers crossed building come on one let's go build successful guys so that means no errors not even any warnings anymore notice that it's nice and clean all right we're using all the Imports that we have and now for one last function which is the close bet and then we can move into the front end and put this into an app all right everybody so we're on to the last function if you made it this far you guys are crushing it so really proud of you if you're here comment down below let's go so I know that you made it this far right we have one function left on the smart contract and that's gonna be the ability to close the BET account right because let's say uh you wanna you claim the BET already right you got the money you need to close the account right when you close the account these the the money that you spent to get Space there which is not a lot of soul in the devnet you get that money back right so you can do that by saying Pub FN close underscore bet and then we can say the arrow like so result and then curly bracket and then from here you can say the CTX and one rule is if you don't use the CTX in the function the context you have to put an underscore and we're not all right so let's quickly make the close bet struct so I'm going to come down below to the bottom and you guys know the deal by now you guys are Pros right spent almost an hour right at this point so we can say derive counts right derive accounts and then from there we can say enter name your struct which should be just close bet info curly bracket boom so this curly bracket represents the information of this struct so let's get what account do we need the better count so we say account right do we want to initialize nope we want to get the mute right because this could be different bets that we're closing so we need to make sure it's mutable the seeds how do we get the bet the exact bet that we want well you need to put in the string the binary string and then you got to pass in the ID and they should have different IDs right since we're incrementing it each time we are making a bet cool to convert it into bytes because that's what the seeds need to read and then we can say bump then we can say close is equal to play it right you haven't seen this one before close just like you knit when you're writing it initialize it this struct actually handles the closing of the account for you so you don't need to write anything so you can say close right it's equal to player meaning the player who created the bet or assigning is allowed to close so you can say and then we can make that functionality by adding this constraint here which is validate uh close bet and now do we have that in utils we do not so we do have one more utils function to make so let me just write this out uh it's going to be and oops reference this and then star bet comma player dot key parentheses and then you can have outside of this at the bet arrow which we should have which is cannot close right only the one who created the BET should be able to close and then we can make that functionality in our utils so all we have to do is come below here and say Pub FN uh validate close BET right and then you can get the BET like so and then you can do that by saying bet here the type uh reference the bet and we do need the user key right so we can say user key takes in user key and it has to be Pub Key that's the type and this will return a Boolean right and then we need to do a match statement here so we say match bet.state and bet state equals Arrow bet dot prediction right by prediction right yeah underscore a DOT player is equal to user key right because the one who created the bet is always going to be user a or player a so we can set that equal to the user key all right uh we can also do bet State started right the is player oops is player pass in the bet right so you're probably wondering what his player is this is the actual function that checks if the user is a player so we can pause that for a second we can say uh FN here because it doesn't have to be public so we say FN is player because this is the only place we're going to call this function uh it's gonna be bet reference to bet again comma get the user key once again Pub Key turns another Boolean forgot to put bull here and put bull here so is player we can check if there is a player by doing bet dot prediction underscore a DOT player is equal equal to the user key all right just like before and then you can also do or right and I press tab here to format it or parentheses the bet.prediction B that is underscore sum all right checking the option and bet dot prediction underscore B dot as ref dot unwrap right because remember B is an option we need to unwrap it then we can go into the player and then check that is and check if that is a player okay cool so now this should make a little more sense we check if uh his player is in here passing the user key of player a yeah and then we can do an and get your next time stamp bet dot expiry underscore TS plus the maximum claimable period okay cool and now we can just check the other states right because the BET state the BET state is player A1 then the BET prediction underscore a DOT player is equal equal to the user key comma then the same thing for B player B one all right so these are basically all the times that you can close the BET right if the BET state is a then you know player a can close it started player a we have to check if the player is a player and then uh the maximum claimable period it's greater than that with the timestamp the current timestamp we can we can close the BET and then at player AO player B1 you can still close the button so bet dot prediction B dot as ref because this is an option like I said before so we gotta unwrap it dot player is equal to the user equal equal to the user key yep bets date draw and then we can use this player here again bet and the user underscore key cool and we just need a comma here and that should be it for the utils so let's go back to our lib right so we then we have to validate the closed bet pass in the player key as the user key and then it'll run through the logic depending on the state thanks to our match statement and if it returns a Boolean that is false error cannot close right so that's how our error handling works right now so we can make this the BET account count uh info and I'm back comma and then let's get the player so we can say mute and the player is basically the signer so player colon signer we don't need to get an account for that one then you can do Pub system underscore program info system okay cool and that's it guys closed bet is pretty simple because all you have to do since the struct is handling the close all you need to do and here is just write okay and that's the logic of the closed bet guys and that isn't that insane oh okay I'm struggling with this let's try one more time not that one this one hey okay that's the close bet that should be all the functions let's just test for any spelling mistakes or errors and then we can move on to adding this to the front end and this time let's just actually look at the closed bet I'm just gonna do a sweep so maybe we can minimize the error just by just proofreading it so back to Here Close bet let's put in the context I just noticed that context is going to be close but okay and a lot of that logic was in here validate close bet player key what about in utils did I spell prediction right print D I see one predict for the action right that's it that's one way to spell it uh create should be created and I think the rest might be some spelling errors I missed that's about prediction right protection okay looks like I spelled it right that's a build ah yes of course so lib 248 oh yeah commas can't forget that oops let me hit clear oh let's go that is like a world record it's one error and it's just a context spelling again 149 keep forgetting that t don't forget your teas guys so context right and now we have build successful let's go all right now next step let's take this code and move it to our front end and to do that we first need to hit upgrade all right and to upgrade I went ahead and cleared my terminal right and all I have to do is make sure you have some Solana let's hit upgrade and it's going to deploy and if any issues come up it should let us know but that's why we do build first before we do before we deploy so let's go ahead and wait and I'll check back in when it's done a deployment successful so we have our upgraded smart contract the next thing that you should do is look at this IDL and make sure you hit export right here and uh if you're on Chrome or any other browser it should show your ideal here don't mind the number nine that's just how many ideas I have in my downloads right what you could do is go ahead and click it and I'll open it in vs code okay oops what you want to do next is uh alt Ctrl B and you want to get this IDL inside of your utils right and just rename it to just say uh idea if it doesn't already boom okay if I hit save here it should format it there you go cool I couldn't see it for a second but if you look this essentially is all the information about our Solana program right create master create bet we need this because we're going to be pulling that IDL in here so go to your constants and let's fill out any constant variables that we're going to reuse over and over so what I'll do is at the top here we do need one to import one thing and let's import public key from Solana web3 public key Solano web3.js and this stays the same but we need to do is export cons we also need to get the program ID so what is the program ID guys well it's going to be a variable that holds I'm going to use this import make a new instance of a public key based on this string okay what string do we use well simply just go to your beta soul.pg click copy this whole thing this is the address of where your program lives on the blockchain and we can just hit paste here oops there's already quotes in there so we don't need these extra quotes boom right so this is our program yours is going to look different than mine but it should be similar okay next is we should also keep the export const minimum remaining time until expiry right this is the one that we can change to make it more fair boom minimum remaining time until expired cool and that should be all of our constants awesome so remember when I was explaining how each of the functions work some of the things we can do is put that in our front end and pass it into our Solana smart contracts such as this minimum remaining time until expiry we can use this right another thing we should do is head over to our program.js so it should be in here and inside program.js we can have a lot of our helper functions for our Solana program so let me show you what I mean by that by doing something like this and let's hit import and let's get a couple things I want anchor provider provider and then we want big number which is BN program and this is going to come from project serum anchor okay another thing we need is that public key again because we're going to convert a couple of strings into public keys okay and let's get some of our constants in here and then what we need from the the constants is import the minimum remaining time until expiry and the program ID cool what's up next we need to get uh is well actually we can get that later but we need to get the program right so we can create a function all right create a function that gets the Solana program we created right so how do we do that we need to say export const oops const get program that's what we'll call it is equal to a function all right so what does our function do connection takes in and it takes in a wallet right and then we can say const IDL right what do we have we seen IDL before we seen it not there right here the IDL we just brought in so make sure you have your ideal so RDL is equal to require dot forward slash idl.json right so we can get the ID bring it in here and then we have to set up what's called a provider so the provider is going to be given through anchors so say new anchor provider and it's an object here also an object it's a parentheses here and you can say connection and wallet right so the connection and wallet that we passed in is going to come into here and then you say anchor provider.default options parentheses there you go so that's the provider variable setup next thing we need is the program so let's set the variable cons program is equal to new program right one of our Imports and set the IDL the program ID and the provider and that should give us um the program information and create a new instance of it and then all you do is just return it and there you go that's our program so get program texting connection wallet set up the IDL the provider and may use that to make the new instance of our program all right cool now a couple other things while we're here we also should remember how we have to fetch bets right usually when you fetch a bet you can just do a fetch all right or uh fetch of Master right but you can just get a specific account by putting in the public key so let's look what happens when I take the master and just put that to fetch boom that's This One Singular account object right so we need to do the same thing and write a function that gets the program account right so we can do that by saying can't get uh oops other way around export const get program account yeah and PK stands for public key so this is going to be an asynchronous function because we're going to make a promise all right this is going to take in the seeds right usually when you get an account you need the seeds okay so then we're going to return and say oh wait a public key and we have public key right yep and it has a builtin method dot find program address right this is how you can find a program using this you pass in the seeds and the program underscore ID and then you have to do bracket parenthesis parentheses zero okay cool I think wait boom okay and then uh this shouldn't be here so let's do a fine program address there you go and this doesn't need to be exported because we're going to be reusing that a lot when we get the other account so that's fine okay and then let's start using a function so we can say export const get master account PK right because we want to be able to fetch the master account that we create and to do that we're going to say async you don't need to pass anything in all we need to do is just say return a weight uh get program I can't PK and then pass in the C's right so if you think back to our app in the soul playground right if you go here how do we create the master we had to put in the seeds and then how do we even fetch the specific Master we have to pass in the master seed and if you know this is the string so we have to format that here and press basically an array and do this buffer Dot from and then you can say uh Master right this is the same thing as us writing that binary straight master in Seoul PG all right works the same way cool so after we did that we should get the bets right so how do we get the bets you can say export cons get oh sorry get bet account PK this is asynchronous and does it need to be passed in anything it does right it needs to get past the ID so get the ID in there and we're going to do something with it we're going to say return oh wait get program account PK okay and we say this and we want to put is that buffer because we do put a string in here and what was that string it was bent right so bet comma and then we need to pass in the ID and we can turn that into bytes right so to do that in the front end in JavaScript you say new BN that import we used ID dot two array like buffer comma and then remember we did the Le so comma and then eight and that's how you do it okay there you go okay so the next thing that we have to do is let's go ahead and set up our state so if you go open up this folder go to Global you're going to see that it's empty well we got to set this up and then wrap our entire app with our state and you'll see what we'll use it for in just a second all right so essentially our global.js is going to be our context so in order to create the context we need to say import and say create context and you get that from react all right but there is a couple more things that we need to import which is going to be a use callback hook as well as the use effect and I believe you stay yep use state awesome all right and then from there uh we can get this import it's called Lamp ports per Soul all right because we're going to do some conversions from Seoul to Lan ports and vice versa because that's what our contract likes to read it in so let's import another thing which is going to be use anchor wallet and use connection and it's going to come from Solana wall adapter react which we used before all right cool now we remember those functions that we created bring them all in here so we could say get program get uh master account PK and get bet account PK as well all right and another thing I like to do here is use toast so if you saw the demo this is where we got those notifications where you can get react hot post awesome all right and then to create a context to get started you just say export const and you can give the name of your context here I called it Global so it's a global context it's equal to the create context hook so I say create context parentheses and then inside takes in an object with all of the stuff we want to pass all right so I could tell you all the variables that we want to pass on throughout our app and it's going to be is connected is one and that can be set to null or we could have the wallet no all these are going to be set to null and they will be defined later on right has user account no uh all bets right we need to have a variable that holds all the bad accounts and that's no we need something that fetches the bets we also need create user create post now and then create now create sorry update the post no delete post no actually now we need to we don't need these we don't need these okay and go back yeah I think those are fine we can delete those uh fetch pets doing anything else no I think that's it so we have those and then we can get the global speed so export const Global state and set that equal to the children okay and from there we just do an arrow function here and then say const program comma set program right this is a State variable that's going to hold the program on our app and while we're here let's go ahead and set up the other states like is connected set is connected uh we can also say const master account right because we should save the master account and it should only be one per program so it sets master account is equal to your state and we can say const all bets set all bets right so this is a state variable that holds all the bets that we fetch set that equal to use State as well and there's also an optional one which is going to be user bets so we want to save all the bets that are relevant to the user and say set user that's like so equals use state okay and last one is just essentially just uh yeah we could have one more but I think we'll save that for later it's gonna make more sense and then from there we can just set up the connection so if we see our Imports we have can use connection here let's set that up by destructuring it and saying connection and saying equals use connection and then there's also anchor wallet so we can set that in a variable it's a constant wallet is equal to use anchor well because this will return for us a wallet and store it in this variable all right cool so now that we have a lot of the things set up let's get to writing out the logic of the global.js okay and then don't forget we need to return here and then put parentheses and then what you want to return is the provider so you say Global context provider or sorry contact stop provider yep and press enter and the key here is that the global context sub provider is going to have a attribute called value value set this equal to object and anything you put in this value is going to be what is going to be in our context right and in between the provider itself you have to pass in the children okay so make sure you have children here make sure you have children here and in the value let's say we make a variable it's going to be pulled out by writing it inside of here awesome uh one thing we do have to do is go to Hooks and if you don't have this make a file called use globalstate.js and then you can uncomment this used context so now it exists right because it's just using it's using the context now and what context are we using the global context right but one thing though is that our app doesn't have it just yet because we have to import it over here so at this point you are in your app.js and what we have to do is around here we have to say import Global state right import ant Global state from state slash Globe right the point of this is so that we can wrap our app with the global state so we can go um should go like right here and say Global state and then put that in between our app and there's only one way to test if this works is let's say uh is connected is a variable here let's make a variable let's call it let it connect it all right let connected is equal to true right and we can pass connected like so okay now it's not grayed out and then we can go to let's go to our index page and let's import the global here yep here's the hook use Global state and we can say something around here const oops const use Global state and we want to connect it is connected and let's see if this works console.log oops connected and hello I'm putting this comment here so I know which console log this is so let's go back to playground it's been a while since I opened this one are we running our app svr let's see it might be blank oh it's true let's go right so that means our Global stays working right so how does the context work so let's picture our app so I'm back in the Whiteboard this is our app right and it has a bunch of components like index and the index has header and portfolio right so this is the header and this is the charts right and this is the index all right so usually all components have a hierarchy apparent child relationship and let's say I wanted to have a connected variable in order to get that to the header I would first have to pass it to the index and then pass it down to header as a prop right if you have a long list of components that's going to be called prop Drilling and it may cause some issues down the line another alternative to instead of passing it like so oops lost the rectangles here boom boom another alternative instead of making it an app is to create what's called a store or a context and put it here because with this context I can just pull it from anywhere I don't have to pass it down from parent to child parent to child right so that's why we did that so that's my really really fast crash course explanation on that context but as you can see we have connected available to us so we can put in a lot of our functionality in here so we can erase that and now global.js is all set up so the first thing that I want to do is let's use use effect and let's set the program right set program so users spec is going to run several times depending on how you structure it so if I do something like comma array this is called a dependency module and it will only run once right we want this to run more than once but the first thing we should do is if a connection right if there's a connection then we can set the program to get program right and we can do that by because we passed in that program from our util so all the setup is coming into play guys don't worry it was all part of the plant so we say connection then we say wallet and then you do question mark question mark uh object here okay so if there's no wallet just use an empty object that's what that is saying and then the else right if there is no connection then set the program to no right and the cool thing about our program it does have a master already so we don't need to create that uh one thing to note is again this makes it run once or it runs once when it first loads or whenever the connection changes right so if the connection ever changes it's going to try to set the program again if the wallet ever changes when I switch wallets it's going to set the program again with that new wallet so that is important okay uh one thing I should have is another check which is gonna just check for the wallet connection right so we can do this with another use effect there's gonna be a lot of use effects guys so get used to it so use effect set is connected right I think I have that yep so you can say this if there is a wallet essentially that public key like so it's a double negative in that sense and we can have a dependency module that only happens when the wallet changes oh not that one this one nice cool and if you don't know what this question mark means is if it exists right so if I don't put this question mark you might get an error that says uh undefined Dot Public key right because it doesn't know what this is right this is only going to run if wallet exists it'll only get the dot part if there is a wallet which happens sometimes when you first load the page all right now for the first uh tangible thing that we can see is is a checking if the master account is there right so we can say const fetch master account right it's going to use callback so we're going to say use callback and say async Arrow and all you have to do is uh if there's no program then we can just return right this won't even run okay there's still more because we can do a try catch here not page transition try and then catch I just set up my catch first it doesn't really matter and then for the console log couldn't Fetch Master count and then we could just put the E Dot message here Dot message okay and then for the try the try we're gonna say we have to get the public key first to get the master count right so we can say cons master account PK is equal to and usually you have to write a lot of code just to get the master account PK but luckily for us we made a reusable way to do that it's this function right here Boop so bring that function down here and to say get master count PK so we did it right this should work and then she get us the variable and then we could say cons the master account itself right we can say our way to program because program is going to have all the accounts without account.master .fetch fetch the master with the with the specific master account PK and then set it to this variable and then once that's done we can set to the master account to that variable right so it all should make sense uh if this fails the semester count should just be no so we know it failed and what we could do is just pass that master account all right I think that's what I called it yep so I passed it in in value which means it's in our context so I can go into here instead of connected Let's Do master account and let's say master okay so it should show the master account that's created if it exists so I'm going to go back to here to refresh to inspect undefined so it doesn't seem to have the master account and if I double check yeah still undefined if I double check here it should have one right should say it should have an object like this that we fetch so that means there's somewhere where it went wrong let's go double check let's see if it's even getting the program so let's pass in program is there a programming program oh what program I'm going to be here it should be here program yep set program oh I mean it would be helpful to call the function so let's call this function it's still grayed out so we should call this in a use effect so what I'm going to do is down below here we could say check for master account so then we can say use effect and just do a check if no master account and program oops and program then Fetch Master account dependency module should just be a master account changes try this again or if the program changes then try this again right so if there's no master account and the ad there's a program we need to get the master account okay so let's see that works now hey all right we got it look at this last bed ID BN right it's BN because that's the format it's in so it should be zero um if you want to read it you have to go into index right the trick with big numbers is that JavaScript can't really read BNS so you can just do a DOT the property which should be last uh last bet ID dot to string and then we should be able to see it right zero so anytime you want the actual number itself do a DOT two string so that's the pattern that's the logic we're using that's the master account amazing okay so master account is done so we successfully created a way to fetch all the master accounts and then check for them we should do the same thing for all the bets so let's make a function called Fetch bets is equal to use callback and then say async Arrow boom okay uh and then same check we always do this if there's no program then you should just return uh same thing is const all bets results right result right and we can get all the bets if we do await program dot account dot bet.all this is how you get all the better counts in your program if there's none you'll get none but then from there you can say const all bets is equal to all bets result dot map right because the reason we want to map is to get every single post right and then well every single bet not post but and then from here we can say bet.account and that should give us just the BET object itself because otherwise you get the whole thing you don't want the whole thing so we can just do this and then take that and set all bets to all bets okay and then if I were to pass this down here it should give us nothing uh we can also just filter user bets but I don't think we need to filter user bets just yet you can just make it to show all the bets in general so yeah I'm just going to comment if you want you can use that filter to get just the user's bets right but the way our app works we should see all the available bets even if we didn't create it ourselves okay uh and then there should be a comma here dependency module program okay and then now yeah get and update all bets so it's kind of like we did with the the master account we can set up one more use effect like so and in this use effect we want to fetch our bets if our bets if all bets does not exist all right so if it doesn't exist already let's get them so if uh okay then we can say fetch okay comma and say oh oh if all bets change then run it again it fetch bets changes then run it again so now this function is being called and just to test it out it should be nothing because we don't have any bits we'll just pass this down oh bits okay and then index do all bets then console.log all bets should be empty array yep empty right because we don't have any and we could double check that with playground and you can see empty array so it's still pretty accurate awesome okay now we can go back to global.js and work on the next thing all right keeping it moving we are going to our first function which is going to be creating bits and we can actually test if creating bet uh works on our contract as well if this goes well so good to create a bet I'm gonna go down here const create bit and this is going to be use callbacks just like the other ones and it's going to take in uh an async not a misfunction right make sure it's a narrow function and inside of this async function what do we need to create a bet guys right think about it we need the amount we need the price prediction we need how long is your bet going for and we need the with pyth price T right so we need all those things and then inside this async function we have to do the if there is no master account right we can't do this otherwise the mastercount can't increment each bit all right so make that check in there it's our Edge case and then we have the try catch so I'll set up just now e and boom okay toast dot error yeah so as our first toaster error that we will see a visual cue I'll say failed failed to create BET right and then we can have a console log of the error.message okay cool because we'll get the toast notification it failed and then a console log of what exactly happened so that sounds good to me and in the try catch we can just say const bet ID is equal to the master account right which we'll have access to dot last bet ID and then to increment it we can just do the add in one add one next is we have to make a variable called response or res as equal to 08 we have to get the BET account PDA or PK and pass in the bed ID right and again if it doesn't exist if that if we if there's no better count that exists yet it will create one so we can say console.log and then we can just visually see it case but okay and inside we say rest okay so then after that we can make a transaction hash it's going to show us when it finishes program dot methods and we can look at this through Soul scan or Soul Explorer from here every program has a DOT methods and the methods that we can call on is our Solana instructions that we created together so we can do that by saying Dot all right Dot wait dude I can't press tab here is hit back Dot create bit so I'm calling the create bet function from Solana playground a month amount amount price and duration we're gonna pass that in as well pith price key ounce I gotta pass in accounts this is our like context the accounts that we need to pass in is the BET account just gonna be a way to get bad account PK bet ID plus we need we need the master right because if it doesn't exist we can't run this anyways a way to get master like this is why I love that we made those helper functions it makes it nice and easy I don't need to pass anything into that one though and then the player right the player is easy to get because we have access to that when we say wallet and then we can just get the public key because that's what it needs you don't need to turn it to a string and then last but not least you should write this dot RPC okay and then we can say await connection dot confirm transaction and then pass in the hash right so we need to confirm that this transaction went through and usually what you could do is console log uh created bet and then show me the hash that's why we made the variable and then I also like to put a toast.success here and say created cool so there is our creates bet function okay and then there is one more thing though uh there's catch here then there is this here we can put a comma and then we have to put in the dependency module is if the master count is different then uh that's the that is going to determine the BET ID so that should be here okay so let's put fetch bets and let's try it out so I'm going to go to the index and let's figure out where to fetch the BET all right so how do we fetch a bit it should be through the submit button right so I'm gonna go to find out where that submit button is it might be in the index it's been a while yeah it is and you can see that I actually commented out what we need to do so erased static bit and then comment out this right here so the first thing that you should understand is this e dot prevent default this is needed here otherwise if you hit submit on a form it's going to refresh your page and we lose all our states that we set up so make sure you have this so that it doesn't refresh next we need to get create BET right because right now it doesn't exist we should go back to our globals I put fetch bets but it really is create bets yep great bets create bet cool that exists save and back to our index and instead of all bets all we can keep our best then we say create then we console log create bet to see if it exists and it should give us a function that's not running we did this right yep function amount nice so it does exist it's really it's the right name and make sure it's in the on click of the submit button right so what's what's happening here it's going to take the amount of soul that we type in right in the input field that's what this soul is and convert it into lamp ports right because when we take something into Solana he doesn't work with Seoul it works with Lan ports and one billion Lan ports are in one Soul so next is the guest right what is the prediction price of the stock and then lastly the time which I'm going to put to like 150 seconds for example and then lastly the price key so how are we getting the price key right remember uh if you look at here you have to come down below get the price key that you want right so that's what you have to do normally but I've hard coded some of that for you here so if you look in data stock data right this is coming from data variable I mean data.js should be somewhere around here yep you can see that I have a price key of each of these stocks so that you don't have to and then the the graph that you're seeing that's not real it's still static right if you want the real stock prices you could just use an API not really through the pith Network the the main functionality that we're teaching here is how to use it in your salon program but again if you want to see that comment down below so back to whatever I was doing we want to set up the create bets so let's just double check one more time and let's just try it okay so creating bet awesome and let's see what happens so I'm going back to our app let's say let's use the AMC stock right you can see Bitcoin you can see Amazon let's go to AMC and then we can X this out and see so my prediction I will predict that the price will go lower to 3.8 right and I'm going to bet two soul and let's make the BET 150 seconds which should be around two minutes oh yeah I need to log in oh okay so my wallet is there uh this might fail them failed to create bet see is there any what's the reason I see it constraint was violated okay that's something we can work with so one Theory I have is when we call the function we might have passed in something that wasn't correct so we can go back to our global go to Korea bet and let's just take a look at all of these accounts so I want to console log them before we create the bed itself so let's do console.log um get this bad ID yes let's do this let's say let a bet is equal to this let Master is equal to this oops and let player is equal to this okay so what I'm doing is I'm just checking to see if these are the right accounts that we need to pass in otherwise the error might be when we're calling the account PKS so let's do this and then we can say a console log and say the bet is the bet then we can say player I'm sorry Master we should do that to string too by the way so it can be more readable got two string and then the player that two string player all right this is only going to run when we call create bet so let's try that so hit this one more time okay prediction uh 3.8 Soul it's gonna be two seconds 150. it's mint okay so those are our three console logs yeah so the seed constraints are still violated all right so let's see this is the BET account and let's see if that is accurate so create bet hmm great bet master player is that the master account yep four five eight four five eight the player is a t so a seeds constraint was violated program log six seven so I didn't like when we did the bet so let's take a look at our utils function that's my next guess all right this is live debugging right here when you're making your app program sorry and get the bet so there's something around here oh this isn't nine why is this a nine it should be an eight okay let me just double check yep late yeah so that's the first that's the C constraint right so this is where we pass in the seats to get the better count PK I put a nine here that's definitely wrong so let's see if that fixes it might not it might might not do anything but it definitely shouldn't be a nine there okay so again the prediction is uh let's just say two or three point eight pass into Seoul 150 seconds is the duration submit different account let's go minus two Soul this works guys oh I can't get too excited but usually when you see that number that's a good sign a create a bet awesome so we have a bet here right and we have to notice something we have to see if the available bets show up right so uh what we could do is go to our index and I think not that index I I think we already have all bets all right we have all bets here so let's console log it and see if that array is still empty if it is when then we're not um we didn't make the bet it doesn't exist array one oh let's go array one so our bet is there right so what do you want to do then what do you want to do after you have all the bets we need to get that component that shows all the BET information which we have made so let's take a look at our app once again and scroll all the way to the bottom see this available bets right here this is what we need to go to so available bets is all of those components so let's click on that boom right as you can see we have a static all bets here we don't want the static all bets we want the real thing so we need to import to Global context again so I'll say oh it's already here it's already imported nice and line 17 so I'll just say const all bets is equal to use Global state and now it should map through the actual bet so let's see if it works a and it's the right bet we did AMC there's two soul and we should be able to enter the bet but we can't just yet because we need to set up that functionality let's go so we have bets all right so let's work on another simple one as you can see here there's already a x right here where you can close the bet so let's do that it says static closing bet function let's get the real deal in here so if I ask you guys where are we going to write the function to close the bet for our front end that's right if you said global.js you are correct so go down below here 116 for me and say const close but right it's gonna use call back not anchor wallet callback and it's going to take in a asynchronous Anonymous function all right so when you close a bet you do need uh to pass in what the bet is right the specific bet you want to close and if you say if master account then return right shouldn't be able to close the bet if there's no master from here we do a try catch you know the deal guys say e we can console log all right first do a toaster error right and say uh failed Too Close bet all right and then the console log to let me know what exactly happened couldn't close bet and then comma here is why dot pair Dot message nice and then what did we want to try we have to do the same thing as we did last time let's set up a transaction hash variable that we will confirm later so we say away to that program.methods right and then uh we can say dot here or press enter to format it dot close bet all right because that's the name of our instruction in our program and then you can do a DOT account and pass in the accounts that you need for the context which is just two things it's going to be bet and then it's gonna be oh wait get bet count PK which we fixed now thank God bet that ID don't forget to comment here and get the player which should be very easy wallet Dot Public key awesome and then the RPC all right cool and then you can console log uh or sorry maybe not console you're going to say toast that success right because if you made it this far it's successful and you could say closed but now to see if this functionality works we have to pass in close bet here and then think about where do you want to call close bet where do you want to run that function so if you look at our app it should run when I click that x button and and do you know which components that is a living I'd say in this one available bets so if let's scroll down for the close yep you can see static closed bet which means we don't want to use this anymore so let's erase that and let's do close okay I believe that's what it's called yep close bet and it does need one thing it does need to pass in the BET right here and as you can see if I highlight it it does know which bit we're talking about because of this map right here okay so when we map and create a component of that bet information it has the BET stored there so we could close it it knows which bet it is all right that's what I did in the front end for you guys so now we can just do a refresh for just in case and let's see if we can close it and we should get refunded our two soul hey look at that plus two so let's hit approve close the BET let's go all right so that's done we are able to close any bet we create now now we just have to enter the BET and then claim the rewards okay so I think we're ready to set up for entering the bet so you know what to do let's go back to our app and let's go to global.js and let's just say the const enter bet now to enter the bit it's the same as all the other functions this is just us calling enter bet in the front end to call the function in Solana right so we're going to do use callback here and it's going to be async anonymous think about it what two uh arguments do we need when we enter a bet we need the um the price prediction of player B and which bet are you predicting on so price bet okay then you can just console.log uh well you don't need to cancel out actually then you can say uh X if there's no master account once again we we should just return and then from there our favorite try catch e and then console.log if it fails uh couldn't enter a bet and then tell me why with the E Dot message okay and then there's the toaster error so it's the visual cue that hey this didn't work so let's say failed to enter but exclamation point all right so what are we gonna try well you know what to do transaction hash is await program dot methods and then we can hit enter just for formatting purposes and say enter bet and we're going to enter the price uh we also need to say dot accounts all right and then put an object and the accounts that we need is the BET itself which you can say await get bet account to make because we made our lives easier and since we passed in bet here just pass that in to get the ID all right and it does all the fetching for us gets the account that we need then it's the player up next and then you can say wallet Dot Public key uh there's an error here because the comma as you can see I'm more comfortable with the front end than Solana so we can just say dot RPC here foreign and again I didn't do this for the closed bet but if you want you can confirm the transaction entry console log the TX hash again optional you do something like this connection.confirm transaction but if you just want to make sure or you could just console log the transaction hash that comes of this cool all right so that's entering the bet let's put this here and again if you think back it's been a while but if you think back to our demo the enter bet function should be somewhere here with all the other information next to our closed bed so let's go to available bets and let's try to find it so current amount you might have to create it now and here is where we want to set up that enter button or claim button right so we need to uh have a button that changes depending on the state of the BET right so how do we know what the state of the bed is well we have this console log here and you'll see what it's used for so let's just temporarily make a new one let's say one one one one 100 right and submit and Bam created bet oh accidentally refreshed there you go AMC right we should see an enter or claim button depending on the state here but if we look in our console what is our state our state is created right so if it's created we should be able to enter the BET right so this is how we get the state object.keys give me the state 0 to uppercase right cool so what can we do with that information well we can just do just get that right right away so say object that keys bet that state um in bracket zero and then dot to uppercase I'm making an uppercase so when I do a check all the letters is going to be the exact same or else I'd have to know how to write it exactly so you'll see what I mean in just a second so make that uppercase uh object Keys best case to uppercase is equal equal to starting right so and this is has to be Capital because of the two operators right yeah so this should be started started is when player B enters the pit so this is what I want to do first first get the started one and I have a question mark here because this is a ternary operator essentially if the set of the bait is started then what I want to happen is we have a div here and don't worry about the area it'll go away in a second we have a div here what is in this div well in this div is going to be the class name styles.com see we're still doing some HTML and CSS here styles that button and it's going to happen on click right you set this equal on click of claim bet so we don't have the claim bet function yet so we'll say static claim bit for now like so and inside that very div is where you can write claim right so if I save this um well we're still going to error because we're not done hit claim and then you're going to say uh or right or else this is the else the colon here after you use the question mark So if this is started load the claim div if it's not started then we want uh enter here we want object dot Keys again essentially this whole first part so let's just we can copy that all right so this is a nested ternary statement right here and this setup started we want to check for uh player A1 so we have to do all the states here to make it one button right you could just have multiple buttons like enter claim uh close right but I want to fancy I want it so that changes depending on the state so player A1 so it kind of goes down the nest so first is the BET started no then load player A1 is it player A1 no then that must mean player B1 all right so first we'll do the player A1 so you can copy this dip right and say player A1 right so player a one and this isn't on click and this also isn't a button this is the uh available bets title which I set up before for you guys and we're not done yet have another one all right another nest right so this one is going to be for the second option b right so player B1 okay and then if that's the case then it's going to be similar to this one I'm sorry this one tab save boom and then say player B1 okay and then if none of that happens then what we could do is roll in that's when you just see the uh enter button right so the enter button you don't need another object stack Keys here because it's the only other state that's possible so you can just copy the Styles button one okay and instead of this you just say uh enter and we do need to fix this a little bit because it's not claim bet it's actually enter bet enter bet well actually no we don't even enter But Here guys I was wrong when you enter but you get a little modal that comes up and to make the model come up we have to change this on click to a enter that set selected bet this is a front end function that I have that's going to open up our custom model then it will say set show model to true I also want to do an on click and we don't want this to run so we'll do something like this there we go so that's how you can make two functions happen one after another is make it Anonymous first and then make the two functions run okay uh let's see what happens oh foreign undefined or no oh okay oh okay so it's not my fault it's I just spelled State wrong I put satatate okay that should definitely exist now hey we can now enter the BET right so this doesn't actually enter the bet this does right and this is where I can enter our prize prediction if I hit submit that's where the static one comes in a closing bet okay cool so let's go to that which is the custom model which I haven't opened yet and in here we have static enter bet it says closing bet we don't need that anymore we can just get the import which I should have use Global State and then how do we get it guys you just say const enter bet is equal to use Global State like so and I just got to make sure I'm passing it here yep so now I should have access to it here and we have to go to enter yeah instead of static enter bet we need enter bet and it's going to take in the player 2's guest and the bet that we selected all right now moment of truth I will close this one because it's probably expired in the time span of me explaining and coding that so let's get our soul back and let's test it okay cool so now that I closed that bit Let's test the enter bet functionality and see if it works so let's get a player B so what I'll do is I made another window and we can go to localhost again but this is a different account so as you can see instead of 18 my wall address here says 3w so you should be able to see all our bets as well and enter as player B so let's see how much Solana he has he has five Soul all right so five sold for him and player two as well player one actually has how many soul I think this one has a lot should have he has 12. all right so let's make our bet so right now current stock price is 3.9 let's predict it goes to 3.8 and I'm gonna bet three Solana in it and let's say it's about 150 seconds right eventually you can set up a function that converts this from days to months right but right now we still just want seconds and now let's go ahead and submit and again let's test if create but still works let's go minus three that's good hit approve create a bet amazing so we can all tab to here and let's see what it says can we see it yes all right so the mat the pot to match is three let's hit enter and I'll predict it's going to be eight Solana so this one is going to be wrong so let's see minus three Soul approve let's go he entered the BET right so we can X this out and then now if you just look at a t and look at the status of the BET here three Soul it's gonna say claim now right it said enter before but because of our ternary operator it now says clean next thing we have to do is the final function of today guys which is claiming the BET and you remember this is the complicated one but we did the heavy lifting in Solana playground if you look if I did fetch here there's our BET right we can see player a who's eight T and then three W which is player B and you can even see the guesses if you fetch it so cool all right so let's go ahead and work on our last function all right so right now we want to claim the bet but as you can see I'm clicking it there's no functionality so let's give it life and let's go to prediction app and let's go we can go down below here and say const claim BET right and usually guys should know the pattern by now we're going to use callback and and this structure of calling the salon instructions is the same so if you want to make your own dap keep this structure in mind if you don't learn anything from here just learn that this is how I create a function this is how I call the function right those things are going to help you make your app so here we go claiming a bet all it needs is the bet that's selected and then we have our Edge case here what's our Edge case if there's no master account just hit return all right you with me home stretch guys then we do our handy dandy try catch here with e and you know I like to cancel that log couldn't claim and then show me why I couldn't claim with e Dot message and this has to be a comma actually outside the quotes okay and we also do a toast dot error here and then we can say failed failed to claim okay cool now for the try which is going to be simply just const TX hash is equal to program or wait sorry await program dot methods all right so we're going to call it the last instruction here which is just going to be claim bet okay and claim bets doesn't take anything but what does take stuff is the accounts that we pass in is just going to be the well actually it's going to be a couple of things and I think about it's gonna be the BET right which should be the 08 get bet account PK and pass in the bet.id and then from there we can pass in the pith right the pith is just the bets.pith price key we have to validate if that's the correct key and then we got player a and player B right so player a how do we get their key well we stored it in the BET account itself so we need to get to the prediction prediction a DOT player right how do I know this is what it needs well if I go to salon a playground I go to the account and then inside that go dot prediction a and then go to player to get that same thing with B so let's do that prediction and Dot player comma let's put player B player B here is going to be same thing but dot prediction and then we say B dot player last but not least we need the signer and that is essentially who uh is able who's claiming right so wallets Dot Public key the cool thing is that anybody can claim player a can claim and player B can claim so let's say player A1 and player B lost a player B claims uh the the money still gets transferred to player a right that's how we set it up which is pretty handy so then from here we can just say the RPC and then you can say a toast that's success uh success claimed bet all right hit save and we also I didn't I don't know if I did this for the other one but we need to put the dependency module for master count yeah I don't believe I did that for the last one so let's do dependency module master account same thing comma this is where they use callback part yep and I did that here alrighty so with that said we can now claim the BET and now we just have to go ahead and test it so I'm going to do this and then where are we going to claim the bet you saw the button so it should be around here so instead of the static claim bit we need the real clan bit and we should also press equals this so it doesn't run right away when the page loads and we should probably get an error because this is here static one and we need to pull it right claim claim Pull It in from here save and we shouldn't have any errors awesome so let's hopefully enough time has passed since I did that so that we can claim the bet so here we go deep breath let's see if the claim works hopefully enough time has passed or it doesn't give me any errors let's go do you see that plus six in our wallet right so this took a lot of work to build if I hit approve it should go through claim the bet uh it might take a while for your soul to update on Phantom should have 15 Soul right we just made a profit from you know predicting whether a stock will go up and down but I hope you guys learned something today comment down below if you liked the video and subscribe I'll see you guys in the next video peace
