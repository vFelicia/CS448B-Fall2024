00:00 - hello and welcome to the kubernetes
00:03 - crash course where i will teach you
00:05 - everything you need to know to get
00:07 - started with kubernetes in one hour
00:10 - i am nana and i have taught hundreds of
00:13 - thousands of people how to advance their
00:15 - devops skills through my youtube channel
00:18 - online courses and the devops
00:20 - educational program
00:21 - if you're new here be sure to subscribe
00:24 - because i upload new videos all the time
00:27 - now let's look at an overview of what
00:29 - you will learn
00:30 - first of all we'll see what is
00:32 - kubernetes and why do we need it and why
00:34 - did it become so popular
00:37 - second we will go through the kubernetes
00:38 - architecture and you will see how
00:40 - kubernetes actually works in the
00:42 - background
00:43 - after that we will cover main kubernetes
00:46 - components that you need to learn to
00:48 - work efficiently with kubernetes and
00:51 - finally we will do a hands-on demo
00:53 - project to get your first practical
00:56 - experience with kubernetes now
00:58 - kubernetes is a very popular but also a
01:01 - very complex technology so this crash
01:04 - course will help you get your first
01:06 - experience to get started with
01:08 - kubernetes but if by the end of the
01:10 - video you decide to deepen your
01:12 - knowledge in kubernetes and are thinking
01:15 - about a career as a kubernetes
01:17 - administrator my new complete kubernetes
01:20 - administrator course will be a great
01:22 - resource for you where you will learn
01:24 - how to build configure and manage
01:26 - kubernetes clusters from scratch
01:29 - the course is also dedicated to help you
01:32 - pass the cka exam from linux foundation
01:35 - to become a certified kubernetes
01:37 - administrator now we have a lot to cover
01:40 - in this video so let's jump right into
01:43 - it
01:44 - so let's jump in right into the
01:45 - definition what is kubernetes
01:48 - so kubernetes is an open source
01:49 - container orchestration framework which
01:52 - was originally developed by google so on
01:54 - the foundation it manages containers be
01:57 - docker containers or from some other
01:59 - technology which basically means that
02:02 - kubernetes helps you manage applications
02:05 - that are made up of hundreds or maybe
02:08 - thousands of containers and it helps you
02:11 - manage them in different environments
02:13 - like physical machines virtual machines
02:16 - or cloud environments or even hybrid
02:19 - deployment environments
02:23 - so what problems does kubernetes solve
02:26 - and what are the tasks of a container
02:29 - orchestration tool actually so to go
02:32 - through this chronologically
02:34 - the rise of microservices caused
02:36 - increased usage of container
02:38 - technologies because the containers
02:40 - actually offer the perfect host for
02:43 - small
02:44 - independent applications like
02:46 - microservices
02:48 - and the rise of containers and the micro
02:50 - service technology actually resulted in
02:53 - applications they're now comprised of
02:55 - hundreds or sometimes maybe even
02:57 - thousands of containers managing those
03:00 - loads of containers across multiple
03:02 - environments using scripts and self-made
03:06 - tools can be really complex
03:08 - and sometimes even impossible so that
03:11 - specific scenario actually caused the
03:14 - need for
03:15 - having container orchestration
03:17 - technologies
03:21 - so what those orchestration tools like
03:23 - kubernetes do is
03:25 - actually guarantee following features
03:28 - one is high availability in simple words
03:32 - high availability means that the
03:34 - application has no downtime so it's
03:36 - always accessible by the users a second
03:40 - one is scalability which means you can
03:43 - scale your applications fast when you
03:46 - have more load on it and more users are
03:49 - trying to access it and the same way you
03:51 - can easily scale it down when the load
03:53 - goes down
03:55 - so it makes your application more
03:56 - flexible to adjust to the increasing or
03:59 - decreasing load and the third one is
04:03 - disaster recovery which basically means
04:05 - that if an infrastructure has some
04:06 - problems like data is lost or the
04:09 - servers explode or something bad happens
04:11 - with the service center the
04:12 - infrastructure has to have some kind of
04:14 - mechanism to back up the data and to
04:16 - restore it to the latest state so that
04:19 - application doesn't actually lose any
04:21 - data and the containerized application
04:23 - can run from the latest state after the
04:26 - recovery
04:27 - and all of these are functionalities
04:29 - that
04:30 - container orchestration technologies
04:32 - like kubernetes offer so how does the
04:34 - kubernetes basic architecture actually
04:36 - look like
04:37 - the kubernetes cluster is made up with
04:40 - at least one master node
04:43 - and then connected to it you have
04:45 - a couple of worker nodes where each node
04:49 - has a cubelet process running on it and
04:52 - cubelet is actually a kubernetes process
04:55 - that makes it possible for the cluster
04:58 - to talk to each other to communicate to
05:00 - each other and actually execute some
05:03 - tasks on those nodes like running
05:05 - application processes
05:07 - each worker node has containers of
05:10 - different applications deployed on it so
05:12 - depending on how the workload is
05:15 - distributed you would have different
05:17 - number of docker containers running on
05:20 - worker nodes and worker nodes are where
05:23 - the actual work is happening so here is
05:25 - where your applications are running so
05:28 - the question is what is running on
05:30 - masternode
05:31 - masternode actually runs several
05:34 - kubernetes processes that are absolutely
05:37 - necessary
05:38 - to run and manage the cluster properly
05:41 - one of such processes is an api server
05:44 - which also is a container an api server
05:47 - is actually the entry point to the
05:49 - kubernetes cluster so this is the
05:51 - process
05:52 - which the different kubernetes clients
05:54 - will talk to like ui if you're using
05:56 - kubernetes dashboard an api if you're
05:59 - using some scripts and automating
06:02 - technologies and a command line tool so
06:05 - all of these will talk to the api server
06:07 - another process that is running on
06:09 - master node is a controller manager
06:12 - which basically keeps an overview of
06:14 - what's happening in the cluster whether
06:16 - something needs to be repaired or maybe
06:19 - if a container died and it needs to be
06:21 - restarted etc
06:23 - and another one is
06:25 - scheduler which is basically responsible
06:27 - for scheduling
06:29 - containers on different nodes based on
06:31 - the workload and the available server
06:34 - resources on each node so it's an
06:37 - intelligent
06:38 - process that decides on which worker
06:41 - node the next container should be
06:44 - scheduled on based on the available
06:46 - resources on those worker nodes and the
06:48 - load that that container needs and
06:51 - another very important component of the
06:53 - whole cluster is actually an etcd key
06:56 - value storage which basically holds at
06:59 - any time the current state of the
07:02 - kubernetes cluster so it has all the
07:04 - configuration data inside
07:06 - and all the status data of each node and
07:09 - each container inside of that node and
07:12 - the backup and restore that we mentioned
07:14 - previously is actually made from these
07:16 - etcd snapshots because you can recover
07:20 - the whole cluster state using that etcd
07:24 - snapshot and last but not least also a
07:26 - very important component of kubernetes
07:29 - which enables those nodes worker nodes
07:32 - masternodes talk to each other is the
07:34 - virtual network that spans all the nodes
07:37 - that are part of the cluster and in
07:39 - simple words virtual network actually
07:42 - turns
07:43 - all the nodes inside of a cluster into
07:46 - one powerful machine that has the sum of
07:50 - all the resources of individual nodes
07:53 - one thing to be noted here is that
07:55 - worker knows because they actually have
07:58 - most load because they are running the
08:01 - applications on inside of it usually are
08:04 - much bigger and have more resources
08:07 - because they will be running hundreds of
08:08 - containers inside of them whereas master
08:11 - node will be running just a handful of
08:14 - master processes like we see in this
08:16 - diagram so it doesn't need that many
08:18 - resources however as you can imagine
08:20 - masternode is much more important than
08:23 - the individual worker nodes because if
08:25 - for example you lose a masternode access
08:29 - you will not be able to access the
08:31 - cluster anymore and that means that you
08:34 - absolutely have to have a backup of your
08:36 - master at any time so in production
08:39 - environments usually you would have at
08:41 - least two masters inside of your
08:44 - kubernetes cluster but in more cases of
08:46 - course you're going to have multiple
08:48 - musters where if one muster node
08:51 - is down the cluster continues to
08:54 - function smoothly because you have other
08:56 - masters available
08:59 - in this video we're going to learn about
09:01 - the main kubernetes components that we
09:04 - as kubernetes administrators or users
09:07 - will be working with most of the time to
09:10 - make it easier to understand all these
09:12 - components i'm gonna build a simple use
09:14 - case of a web application with a simple
09:17 - database and i'm gonna show you step by
09:20 - step how each component in kubernetes
09:23 - helps you deploy such an application
09:25 - setup and what is the role of each of
09:27 - these components
09:31 - so let's start with the basic setup of a
09:34 - worker node or in kubernetes terms a
09:37 - node
09:38 - which is a simple server a physical or
09:41 - virtual machine and the basic component
09:43 - or the smallest unit of kubernetes is a
09:47 - pod so what pod is is basically an
09:50 - abstraction over a container so if
09:52 - you're familiar with docker containers
09:55 - or container images so basically what
09:57 - pod does is it creates this running
10:00 - environment or a layer on top of the
10:03 - container
10:04 - and the reason is because kubernetes
10:06 - wants to abstract away the container
10:09 - runtime or container technologies so
10:11 - that you can replace them if you want to
10:14 - and also because you don't have to
10:16 - directly work with docker or whatever
10:19 - container technology you use in a
10:21 - kubernetes so you only interact with the
10:23 - kubernetes layer so we have an
10:25 - application pod which is our own
10:27 - application and that will maybe use a
10:30 - database pod with its own container and
10:32 - this is also an important concept here
10:35 - pod is usually meant to run one
10:38 - application container inside of it you
10:41 - can run multiple containers inside one
10:43 - pod but usually it's only the case if
10:45 - you have one main application container
10:48 - and the helper container or some side
10:51 - service that has to run inside of that
10:54 - pod
10:55 - and as you see this is nothing special
10:57 - you just have one server and two
10:58 - containers running on it with a
11:00 - abstraction layer on top of it so now
11:02 - let's see how they communicate with each
11:04 - other in kubernetes world so kubernetes
11:07 - offers out of the box a virtual network
11:09 - which means that each
11:10 - pod gets its own ip address not the
11:14 - container the pod gets the ip address
11:16 - and each pod
11:18 - can communicate with each other using
11:20 - that ip address which is an internal ip
11:22 - address obviously it's not the public
11:24 - one so my application container can
11:27 - communicate with database using the ip
11:30 - address however pod components in
11:33 - kubernetes also an important concept are
11:36 - ephemeral which means that they can die
11:39 - very easily
11:40 - and when that happens for example if i
11:42 - lose a database container because the
11:45 - container crashed because the
11:47 - application crashed inside or because
11:50 - the nodes the server that i'm running
11:53 - them on
11:54 - ran out resources the pod will die
11:57 - and a new one will get created in its
11:59 - place and when that happens it will get
12:02 - assigned a new ip address which
12:04 - obviously is inconvenient if you are
12:07 - communicating with the database using
12:08 - the ip address because now you have to
12:10 - adjust it every time pod restarts and
12:13 - because of that another component of
12:16 - kubernetes called service is used
12:21 - so service is basically a static ip
12:24 - address or permanent ip address that can
12:27 - be attached so to say to each pod so my
12:31 - app will have its own service and
12:32 - database pod will have its own service
12:35 - and the good thing here is that the life
12:38 - cycles of service and the pod are not
12:41 - connected so even if the pod dies
12:44 - the service and its ip address will stay
12:48 - so you don't have to change that
12:51 - endpoint anymore
12:52 - so now obviously you would want your
12:55 - application to be accessible through a
12:57 - browser right and for this you would
12:59 - have to create an external service so
13:01 - external services a service that opens
13:04 - the communication from external sources
13:07 - but obviously you wouldn't want your
13:09 - database to be open to the public
13:12 - requests and for that you would create
13:14 - something called an internal service so
13:17 - this is a type of a service that you
13:20 - specify when creating one however if you
13:23 - notice the url of
13:26 - the external service is not very
13:29 - practical so basically what you have is
13:32 - an http protocol with a node ip address
13:36 - so of the node not the service and the
13:39 - port number of the service which is
13:42 - good for test purposes if you want to
13:44 - test something very fast but not for the
13:46 - end product so usually you would want
13:48 - your url to look like this if you want
13:50 - to talk to your application with a
13:53 - secure protocol and a domain name and
13:56 - for that
13:57 - there is another component of kubernetes
14:00 - called ingress so instead of service the
14:03 - request goes first to ingress and it
14:05 - does the forwarding then to the service
14:08 - so now we saw some of the very basic
14:10 - components of kubernetes and as you see
14:12 - this is a very simple setup we just have
14:14 - a one server and a couple of containers
14:17 - running and some services nothing really
14:21 - special where kubernetes advantages or
14:24 - the actual cool features really come
14:26 - forward but we're gonna get there step
14:28 - by step so let's continue
14:34 - so as we said pods communicate with each
14:36 - other using a service so my application
14:39 - will have a database endpoint let's say
14:42 - called mongodb service that it uses to
14:45 - communicate with the database but
14:48 - whether you configure usually this
14:50 - database url or endpoint usually you
14:53 - would do it in application properties
14:55 - file or as some kind of external
14:58 - environmental variable but usually it's
15:00 - inside of the built image of the
15:03 - application so for example if the
15:06 - endpoint of the service or service name
15:08 - in this case changed to mongodb you
15:11 - would have to adjust that url in the
15:13 - application so usually you'd have to
15:16 - rebuild the application with a new
15:18 - version and you have to push it to the
15:20 - repository and now you'll have to
15:23 - pull that new image in your pod and
15:26 - restart the whole thing so a little bit
15:28 - tedious for a small change like database
15:32 - url so for that purpose kubernetes has a
15:35 - component called config map so what it
15:38 - does is it's basically your external
15:40 - configuration to your application so
15:43 - config map would usually contain
15:45 - configuration data like urls of a
15:48 - database or some other services that you
15:50 - use and in kubernetes you just connect
15:53 - it to the pod so that pod actually gets
15:56 - the data that config map contains
15:59 - and now if you change the name of the
16:01 - service the endpoint of the service you
16:03 - just adjust the config map and that's it
16:06 - you don't have to build a new image and
16:08 - have to go through this whole cycle now
16:11 - part of the external configuration can
16:13 - also be database username and password
16:16 - right which may also change in the
16:19 - application deployment process but
16:21 - putting a password or other credentials
16:24 - in a config map in a plain text format
16:27 - would be insecure even though it's an
16:29 - external configuration so for this
16:31 - purpose kubernetes has another component
16:34 - called secret
16:36 - so secret is just like config map but
16:39 - the difference is that it's used to
16:41 - store secret data credentials for
16:44 - example and it's stored not in a plain
16:46 - text format but in base 64 in encoded
16:50 - format but of course basics before
16:52 - encoding a secret doesn't make it
16:53 - automatically secure
16:55 - the secret components are meant to be
16:58 - encrypted
16:59 - using third-party tools in kubernetes
17:02 - because kubernetes doesn't encrypt them
17:04 - out of the box
17:05 - and there are tools for that from cloud
17:07 - providers or separate third-party tools
17:10 - that you can
17:11 - deploy on kubernetes to encrypt your
17:13 - secrets and that will make secrets
17:16 - secure
17:17 - so secret would contain things like
17:20 - credentials and of course i mean
17:22 - database user you could also put in
17:23 - config map but what's important is the
17:26 - passwords certificates things that you
17:29 - don't want other people to have access
17:31 - to would go in the secret and just like
17:34 - config map you just connect it to your
17:36 - pod so that pod can actually see those
17:38 - data and read from the secret you can
17:41 - actually use the data from configmap or
17:44 - secret inside of your application pod
17:47 - using for example environmental
17:49 - variables or even as a properties file
17:52 - so now let's see another very important
17:54 - concept generally which is data storage
17:58 - and how it works in kubernetes
18:00 - so we have this database pod that our
18:02 - application uses and it has some data or
18:04 - it generates some data with this setup
18:06 - that you see now if the database
18:09 - container or the pod gets restarted
18:12 - the data would be gone and that's
18:15 - problematic and inconvenient obviously
18:18 - because you want your database data or
18:20 - log data to be persisted reliably long
18:24 - term
18:25 - and the way you can do it in kubernetes
18:27 - is using another component of kubernetes
18:30 - called volumes
18:32 - and how it works is that it basically
18:34 - attaches a physical storage on a hard
18:37 - drive to your pod and that storage could
18:40 - be either on a local machine meaning on
18:42 - the same server node where the pod is
18:45 - running or it could be on a remote
18:47 - storage meaning outside of the
18:49 - kubernetes cluster it could be a cloud
18:52 - storage or it could be your own premise
18:54 - storage which is not part of the
18:56 - kubernetes cluster so you just have an
18:59 - external reference on it so now when the
19:01 - database pod or container gets restarted
19:04 - all the data will be there persisted
19:07 - it's important to understand the
19:08 - distinction between the kubernetes
19:10 - cluster and all of its components and
19:13 - the storage
19:14 - regardless of whether it's a local or
19:17 - remote storage think of a storage as an
19:20 - external hard drive plugged in into the
19:23 - kubernetes cluster because the point is
19:26 - kubernetes cluster explicitly doesn't
19:28 - manage any data persistence which means
19:31 - that you as a kubernetes user or an
19:33 - administrator are responsible for
19:36 - backing up the data replicating and
19:38 - managing it and making sure that it's
19:40 - kept on a proper hardware etc because
19:43 - it's not taking care of kubernetes
19:50 - so now let's see everything is running
19:51 - perfectly and a user can access our
19:53 - application through a browser
19:56 - now with this setup what happens if my
19:59 - application pod dies right crashes or i
20:02 - have to restart the pod because i built
20:06 - a new container image
20:08 - basically i would have a downtime where
20:11 - a user can reach my application which is
20:14 - obviously a very bad thing
20:16 - if it happens in production and this is
20:19 - exactly the advantage of distributed
20:21 - systems and containers
20:23 - so instead of relying on just one
20:25 - application part and one database part
20:28 - etc
20:29 - we are replicating everything
20:32 - on multiple servers
20:34 - so we would have another node where a
20:37 - replica or clone of our application
20:40 - would run which will also be connected
20:43 - to the service so remember previously we
20:45 - said the service is like a persistent
20:48 - static ip address with a dns name so
20:51 - that you don't have to
20:53 - constantly adjust the end point when a
20:56 - pod dies
20:57 - but service is also a load balancer
20:59 - which means that the service will
21:01 - actually catch the request and forward
21:03 - it to whichever part is least busy so it
21:05 - has both of these functionalities
21:08 - but in order to create the the second
21:10 - replica of the my application pod you
21:13 - wouldn't create a second part but
21:15 - instead you will define a blueprint for
21:18 - a my application pod and specify how
21:20 - many replicas of that pod you would like
21:23 - to run and that component or that
21:25 - blueprint is called deployment which is
21:28 - another component of kubernetes and in
21:31 - practice you would not be working with
21:33 - pods or you would not be creating pods
21:36 - you would be creating deployments
21:38 - because there you can specify how many
21:40 - replicas and you can also scale up or
21:43 - scale down the number of replicas of
21:46 - pots that you need so with pot we said
21:48 - that pot is a layer of abstraction on
21:51 - top of containers
21:53 - and deployment is another abstraction on
21:56 - top of pots which makes it more
21:58 - convenient to interact with the pods
22:00 - replicate them and do some other
22:02 - configuration
22:04 - so in practice you would mostly work
22:06 - with deployments and not with pods so
22:09 - now if one of the replicas of your
22:11 - application pod would die the service
22:13 - will forward the requests to another one
22:17 - so your application would still be
22:18 - accessible for the user so now you're
22:20 - probably wondering what about the
22:22 - database pod because if the database
22:25 - part died your application also wouldn't
22:27 - be accessible so we need a
22:30 - database replica as well however we
22:32 - can't replicate database using a
22:35 - deployment and the reason for that is
22:37 - because database has a state which is
22:41 - its data
22:42 - meaning that if we have clones or
22:44 - replicas of the database they would all
22:47 - need to access the same
22:50 - shared
22:50 - data storage and there you would need
22:53 - some kind of mechanism that manages
22:56 - which parts are currently writing to
22:58 - that storage or which pods are reading
23:01 - from the storage in order to avoid data
23:04 - inconsistencies and that mechanism
23:08 - in addition to replicating feature is
23:11 - offered by another kubernetes component
23:14 - called statefulset so this component is
23:17 - meant specifically for applications like
23:20 - databases so mysql mongodb
23:24 - elasticsearch or any other stateful
23:27 - applications or databases
23:30 - should be created using stateful sets
23:32 - and not deployments
23:34 - it's a very important distinction
23:36 - and stateful said just like deployment
23:39 - would take care of
23:40 - replicating the pots and scaling them up
23:44 - or scaling them down but making sure the
23:46 - database reads and writes are
23:48 - synchronized so that no database
23:51 - inconsistencies are offered however i
23:54 - must mention here that deploying
23:56 - database applications using stateful
23:59 - sets
24:00 - in kubernetes cluster can be somewhat
24:03 - tedious so it's definitely more
24:05 - difficult than working with deployments
24:08 - where you don't have all these
24:09 - challenges that's why it's also a common
24:12 - practice to host database
24:14 - applications outside of the kubernetes
24:17 - cluster and just have the deployments or
24:20 - stateless applications
24:22 - that replicate and scale with no problem
24:24 - inside of the kubernetes cluster and
24:27 - communicate with the external database
24:29 - so now that we have two replicas of my
24:31 - application pod and two replicas of the
24:34 - database and they're both load balanced
24:36 - our setup is more robust which means
24:39 - that now even if node one the whole node
24:42 - server was actually rebooted or crashed
24:46 - and nothing could run on it we would
24:48 - still have a second node with
24:50 - application and database pods running on
24:53 - it and the application would still be
24:55 - accessible by the user until these two
24:58 - replicas get recreated so you can avoid
25:01 - downtime
25:04 - so to summarize we have looked at
25:07 - the most used kubernetes components we
25:10 - start with the pods and the services in
25:12 - order to communicate between the parts
25:14 - and the ingress component which is
25:16 - used to route traffic into the cluster
25:19 - we've also looked at external
25:21 - configuration using config maps and
25:23 - secrets and data persistence using
25:26 - volumes and finally we've looked at pod
25:30 - blueprints with replicating mechanisms
25:33 - like deployments and stateful sets where
25:36 - stateful set is used specifically for
25:38 - stateful applications like databases
25:41 - just using these core components you can
25:44 - actually build pretty powerful
25:46 - kubernetes clusters
25:48 - before moving on i want to give a shout
25:50 - out to castin who made this video
25:52 - possible
25:54 - kessen's k10 is the data management
25:57 - platform for kubernetes
25:59 - k10 basically takes off most of the load
26:02 - of doing backup and restore in
26:04 - kubernetes from the cluster
26:06 - administrators it has a very simple ui
26:09 - so it's super easy to work with and has
26:12 - an intelligent logic which does all the
26:14 - heavy lifting for you and with my link
26:17 - you can download k10 for free and get 10
26:20 - nodes free forever to do your kubernetes
26:23 - backups so make sure to check out the
26:25 - link in the video description and now
26:27 - let's continue
26:28 - so now that we have seen the basic
26:30 - concepts of kubernetes how do we
26:32 - actually create those components like
26:34 - pods and services to configure the
26:37 - kubernetes cluster
26:41 - all the configuration in kubernetes
26:43 - cluster actually goes through a master
26:46 - node with the process called api server
26:48 - which we mentioned briefly earlier so
26:51 - kubernetes clients which could be a ui a
26:54 - kubernetes dashboard for example or an
26:56 - api which could be a script or a curl
26:59 - command
27:00 - or a command line tool like cubectl they
27:03 - all talk to the api server and they send
27:05 - their configuration requests to the api
27:08 - server which is the main entry point or
27:10 - the only entry point into the cluster
27:12 - and these requests have to be either in
27:15 - yaml format or json format and this is
27:18 - how example configuration in yaml format
27:21 - actually looks like so with this we are
27:23 - sending a request to kubernetes to
27:26 - configure a component called deployment
27:29 - which is basically a template or a
27:31 - blueprint for creating pods and in this
27:33 - specific configuration example we tell
27:36 - kubernetes to create two replica pods
27:39 - for us called my app with each pod
27:43 - replica having a container based on my
27:46 - image running inside in addition to that
27:49 - we
27:50 - configure what the environment variables
27:52 - and the port configuration of this
27:54 - container inside of the pod should be
27:57 - and as you see
27:58 - the
27:59 - configuration requests in kubernetes are
28:02 - declarative form so we declare what is
28:04 - our desired outcome from kubernetes
28:07 - and kubernetes tries to meet those
28:10 - requirements meaning for example since
28:12 - we declare we want two replica parts of
28:15 - my app deployment to be running in the
28:18 - cluster and one of those parts dies the
28:21 - controller manager will see that the
28:23 - ease and shoot states now are different
28:26 - the actual state is one part our desired
28:29 - state is 2 so it goes to work to make
28:32 - sure that this desired state is
28:35 - recovered automatically restarting the
28:38 - second replica of that pod
28:42 - so here i have examples of a deployment
28:45 - and service configuration files side by
28:48 - side so the first thing is that every
28:51 - configuration file in kubernetes has
28:54 - three parts the first part is where the
28:57 - metadata of that component that you're
29:00 - creating resides and one of the metadata
29:03 - is obviously name of the component
29:05 - itself the second part in the
29:08 - configuration file is specification so
29:11 - each component's configuration file will
29:14 - have a specification where you basically
29:16 - put every kind of configuration that you
29:19 - want to apply for that
29:21 - component the first two lines here as
29:24 - you see is just
29:25 - declaring what you want to create here
29:28 - we are creating deployment and here
29:30 - we're creating a service
29:32 - and this is basically you have to look
29:34 - up for each component there's a
29:36 - different api version
29:37 - so now inside of the specification part
29:40 - obviously the attributes will be
29:44 - specific to the kind of a component that
29:47 - you're creating so deployment will have
29:50 - its own attributes
29:52 - that only apply for deployment and the
29:54 - service will have its own stuff but i
29:57 - said there are three parts of a
29:58 - configuration file and
30:01 - we just see metadata and the
30:03 - specification so where's the third part
30:06 - so the third part will be a status but
30:09 - it's going to be automatically generated
30:12 - and edit by kubernetes so the way it
30:15 - works is that kubernetes will always
30:17 - compare what is the desired state and
30:20 - what is the actual state or the status
30:22 - of that component and if the status and
30:24 - desired state do not match then
30:27 - kubernetes knows there's something to be
30:29 - fixed there so it's gonna try to fix it
30:32 - and this is the basis of the
30:35 - self-healing feature that kubernetes
30:37 - provides for example here you specify
30:40 - you want two replicas of nginx
30:43 - deployment so when you apply this when
30:46 - you actually create the deployment using
30:48 - this configuration file that's what
30:50 - apply means kubernetes will add here the
30:52 - status of your deployment and it will
30:56 - update that state continuously so for
30:59 - example if a status at some point will
31:01 - say just one replica is running then
31:04 - kubernetes will compare that status with
31:07 - the specification and we'll know there
31:09 - is a problem there another replica needs
31:12 - to be created sap now another
31:14 - interesting question here is
31:16 - where does kubernetes actually get the
31:18 - status data to automatically add here or
31:22 - update continuously that information
31:24 - comes from the icd remember the cluster
31:27 - brain one of the master processes that
31:30 - actually stores the cluster data so it
31:33 - cd holds at any time the current status
31:37 - of any kubernetes component and that's
31:40 - where the status information comes from
31:46 - so as you see the format of the
31:48 - configuration files is yemel
31:51 - that's why the extension here and
31:54 - generally it's pretty straightforward to
31:56 - understand it's a very simple format but
31:58 - yaml is very strict about the
32:00 - indentations so for example if you have
32:04 - something wrongly indented here your
32:06 - file will be invalid but other than that
32:09 - it's pretty simple another thing is
32:11 - where do you actually store those
32:13 - configuration files a usual practice is
32:16 - to store them with your code because
32:19 - since the deployment and service is
32:22 - going to be applied to your application
32:24 - it's a good practice to store these
32:26 - configuration files in your application
32:28 - code so usually it will be part of the
32:31 - whole infrastructure as a code concept
32:34 - or you can also have its own git
32:37 - repository just for the configuration
32:39 - files
32:41 - so in this video i'm going to show you
32:43 - what mini cube and cube ctl are and how
32:46 - to set them up
32:47 - so first of all let's see what is mini
32:49 - cube usually in kubernetes world when
32:52 - you are setting up a production cluster
32:55 - it will look something like this so you
32:57 - would have multiple masters at least two
32:59 - in a production setting and you would
33:01 - have multiple worker nodes
33:03 - and master nodes and the worker nodes
33:06 - have their own separate responsibility
33:09 - so as you see on the diagram you would
33:10 - have actual separate virtual or physical
33:13 - machines that each represent a note
33:17 - now if you want to test something on
33:19 - your local environment or if you want to
33:22 - try something out very quickly for
33:23 - example deploying new application or new
33:27 - components and you want to test it on
33:29 - your local machine obviously setting up
33:31 - a cluster like this will be pretty
33:33 - difficult or maybe even impossible if
33:35 - you don't have enough resources like
33:37 - memory and cpu etc and exactly for the
33:41 - use case
33:42 - there's this open source tool that is
33:44 - called a mini cube so what a mini cube
33:46 - is is basically one node cluster where
33:50 - the master processes and the worker
33:52 - processes both run on one node and this
33:56 - node will have a docker container
33:58 - runtime pre-installed so you will be
34:01 - able to run the containers or the pods
34:03 - with containers on this node
34:07 - so now that you have this virtual node
34:10 - on your local machine that represents
34:12 - mini cube you need some way to interact
34:15 - with that cluster so you need a way to
34:17 - create pods
34:18 - and other kubernetes components on the
34:20 - node and the way to do it is using
34:23 - cubectl which is a command line tool for
34:26 - kubernetes cluster so let's see how it
34:28 - actually works remember we said that
34:30 - minicube runs both master and work
34:32 - processes so one of the master processes
34:35 - called api server is actually the main
34:38 - entry point into the kubernetes cluster
34:40 - so if you want to do anything in the
34:42 - kubernetes if you want to configure
34:44 - anything create any component you first
34:46 - have to talk to the api server and the
34:48 - way to talk to the api server is through
34:50 - different clients so you can have a ui
34:52 - like a dashboard you can talk to it
34:54 - using kubernetes api
34:56 - or a command line tool which is cubectl
35:00 - and cubectl is actually the most
35:02 - powerful of all the three clients
35:04 - because with cube cdl you can basically
35:06 - do
35:07 - anything in the kubernetes that you want
35:09 - and throughout this video tutorials
35:11 - we're going to be using cube ctl mostly
35:14 - so once the cube ctl submits commands to
35:16 - the api server to create components
35:18 - delete components etc the work processes
35:22 - on minicube node will actually make it
35:25 - happen so they will be actually
35:27 - executing the commands to create the
35:29 - parts to destroy the parts to create
35:31 - services etc so this is the mini cube
35:34 - setup and this is how cubectl is used to
35:37 - interact with the cluster an important
35:39 - thing to note here is that kipctl isn't
35:42 - just for minikube cluster if you have a
35:44 - cloud cluster or a hybrid cluster
35:47 - whatever cube ctl is the tool to use to
35:51 - interact with any type of kubernetes
35:53 - cluster setup so that's important to
35:55 - note here so now that we know what mini
35:57 - cube and cube ctl are let's actually
35:59 - install them to see them in practice
36:04 - now let's see how to install and run
36:07 - mini cube there are many different ways
36:10 - depending on your operating system and
36:12 - its architecture so the best way is to
36:15 - reference the official documentation and
36:17 - here as you see minicube can run either
36:20 - as a container or a virtual machine and
36:24 - these are the resource requirements to
36:26 - run minicube on your machine so make
36:29 - sure you have enough resources for
36:31 - installation you just select the correct
36:34 - data for your machine in my case it's
36:36 - going to be mac os with a home homebrew
36:39 - installation
36:41 - and with one simple brew installed mini
36:43 - cube command i can basically install
36:46 - mini cube
36:48 - like this and as you see the latest mini
36:51 - cube version has been installed once
36:53 - minicube is installed we want to
36:55 - actually start or create a mini cube
36:58 - cluster
36:58 - which is also super easy as you see
37:01 - we simply execute a mini cube start
37:04 - command
37:05 - however as i mentioned
37:07 - minicube must start either as a
37:09 - container or a virtual machine so we
37:12 - need either a container or a virtual
37:14 - machine tool installed on our laptop to
37:17 - run mini cube and this is going to be
37:19 - the driver for mini cube and opening the
37:22 - drivers page
37:23 - you see the list of supported drivers
37:27 - for linux mac os and windows and you see
37:31 - that docker is actually the preferred
37:34 - driver for running mini cube on all
37:36 - operating systems now this may be a
37:38 - little bit confusing because as you know
37:41 - inside the kubernetes cluster we run
37:44 - docker containers and it's important to
37:46 - note here that mini cube insulation
37:49 - actually comes with docker already
37:51 - installed to run those containers but
37:54 - docker as a driver from minicube means
37:58 - that we are hosting minicube on our
38:01 - local machine as a docker container
38:03 - itself so we have two layers of docker
38:06 - mini cube running is a docker container
38:08 - and inside mini cube we have docker
38:12 - packaged in minikube to run our
38:14 - application containers and for hosting
38:17 - minicube on our machine we can use
38:19 - docker so if you have docker already
38:21 - installed on your machine you're all set
38:24 - up to start a mini cube cluster
38:26 - if not also not a problem you can easily
38:29 - install it from here
38:31 - so clicking on install docker link this
38:34 - will take me to docker hub where i have
38:37 - docker desktop installation for windows
38:40 - and mac
38:42 - so i'm simply going to click in
38:44 - in my case docker desktop for mac and
38:47 - i'm gonna download and install docker
38:50 - and once downloaded just install it
38:55 - drag and drop into the applications
38:57 - folder
38:59 - and now we can start the docker daemon
39:01 - from the applications
39:04 - and as you see docker is starting up so
39:07 - the download and installation may take
39:09 - some time but once docker is installed
39:12 - and running we can switch back to the
39:14 - terminal and start the mini cube cluster
39:17 - using mini cube
39:19 - start command passing docker as a driver
39:23 - option
39:23 - using the driver flag with docker value
39:27 - and let's execute
39:29 - and this may also take a while when
39:32 - you're running it first time because it
39:34 - needs to actually create the cluster and
39:36 - download all the necessary images and
39:38 - components so the next time you do mini
39:40 - cube start it should actually go faster
39:43 - and as you see this command created a
39:45 - local kubernetes cluster on our machine
39:49 - with the latest kubernetes version
39:51 - 1.22 and now we can check the status of
39:54 - the cluster using minicube
39:57 - status command
39:58 - and we see that all the components
40:00 - inside are running and everything is
40:02 - configured and now start to actually
40:06 - interact with our cluster using
40:09 - command line tool and cubectl actually
40:12 - gets installed as a dependency when we
40:15 - install minicube
40:18 - which you see right here installing
40:20 - dependencies for minicube and kubernetes
40:23 - cli is actually cube ctl
40:26 - and that means we already have that
40:28 - available we don't have to install it so
40:31 - now i can do cube ctl get node
40:35 - and this will display all the nodes in
40:37 - the cluster in our case we just have one
40:39 - node which is control plane and the
40:41 - worker node at the same time
40:43 - and we see information for each node
40:46 - like the status the kubernetes version
40:49 - that it's running as well as when it was
40:51 - added to the cluster so with this we now
40:54 - have an actual kubernetes cluster
40:56 - running locally on our machine and we
40:59 - can start deploying applications in it
41:01 - so from this point on we are going to be
41:03 - interacting with the mini cube cluster
41:05 - using cubectl command line tool so
41:08 - minicube is basically just for the
41:10 - startup and for deleting the cluster but
41:13 - everything else configuring we're going
41:15 - to be doing through cubectl now we have
41:18 - enough knowledge to deploy a very simple
41:20 - but realistic application setup in a
41:23 - kubernetes cluster we will deploy a
41:25 - mongodb database and a web application
41:29 - which will connect to the mongodb
41:32 - database using external configuration
41:35 - data from config map and the secret and
41:38 - finally we will make our web application
41:42 - accessible externally from the browser
41:45 - so let's get right in so i have two
41:47 - resources here we're going to reference
41:49 - the kubernetes documentation to create
41:51 - our components which is a realistic way
41:53 - of working with kubernetes and also a
41:56 - docker hub where i have
41:58 - the web application image that i created
42:00 - which is publicly accessible so you can
42:02 - also pull it directly from the docker
42:05 - hub in your kubernetes cluster so first
42:08 - let's go ahead and create
42:10 - all the kubernetes configuration files
42:13 - that we need for deploying our
42:16 - application setup and for that i'm going
42:18 - to go to visual studio code where i have
42:21 - a kubernetes demo folder open and in
42:24 - this folder we're going to create four
42:26 - kubernetes configuration files that we
42:28 - need we're going to create a config map
42:31 - with mongodb
42:32 - database endpoint we're going to create
42:35 - a secret with username and password for
42:38 - mongodb and then we're going to create a
42:41 - configuration file for deploying a
42:42 - mongodb application
42:44 - and its service and then we're going to
42:46 - create kubernetes configuration file for
42:49 - deploying our simple demo app
42:52 - application with its service
42:57 - so the first file will be called
43:00 - config.yml
43:03 - and creating a config map in kubernetes
43:05 - is super simple for the syntax we can
43:08 - reference kubernetes documentation
43:13 - so i'm going to copy the first part here
43:16 - paste it in
43:17 - and that's basically the main syntax
43:19 - we're starting from
43:21 - let's call our config map
43:24 - config
43:28 - so we have the metadata and then we have
43:30 - the actual
43:31 - contents of this config map within the
43:34 - data attribute we have all the key value
43:37 - pairs that we define as external
43:40 - configuration within this config map in
43:42 - our case we just have one which we're
43:44 - going to call
43:46 - url as a key and of course we need a
43:49 - value for the mongodb url and the value
43:53 - will be the service that we're going to
43:56 - create for mongodb application and we're
43:59 - going to call that service
44:01 - service
44:02 - and in a couple of minutes you're going
44:04 - to see how to create this service
44:07 - and that will be basically all the
44:09 - configuration we need for creating
44:11 - config map
44:15 - so that one is done let's now go ahead
44:17 - and create secret
44:20 - dot
44:21 - yaml which will hold the username and
44:24 - password for mongodb application again
44:28 - to reference
44:29 - documentation
44:33 - i'm going to take this one and let's
44:35 - actually copy the whole thing
44:37 - so we have the secret kind instead of
44:40 - config map let's call this secret
44:44 - we have type opaque which is the generic
44:47 - type for defining secret data basically
44:51 - and we have the same data attribute here
44:54 - and let's actually create our own values
44:56 - let's call this
44:58 - [Music]
44:59 - user
45:00 - and
45:03 - password
45:06 - and as you already learned the values in
45:09 - secret are base64 encoded so we can just
45:12 - set the values plain text we have to
45:15 - encode them first and encoding values is
45:18 - super easy we're just gonna do echo
45:21 - and let's call it user
45:24 - and
45:25 - base 64. encode it
45:28 - and the same way let's do
45:31 - password
45:36 - and
45:38 - paste those values
45:44 - and this will be our secret
45:46 - configuration and now when we create
45:49 - deployments for our applications we can
45:51 - reference
45:52 - any of the values defined in the secret
45:55 - or config map so let's see how that
45:57 - works
46:01 - again let's create a new file and let's
46:03 - call this dot yaml this is going
46:07 - to be a configuration file where
46:09 - we're going to create deployment and
46:12 - service for mongodb you can have
46:15 - separate files for them but it's a very
46:17 - common thing to put them together
46:19 - because all the deployments need
46:21 - services so you have them grouped in one
46:24 - yaml file
46:25 - and again
46:26 - let's reference the documentation for
46:31 - the deployment example syntax
46:34 - and we can then adjust the values as we
46:36 - need
46:37 - and as you see deployment configuration
46:39 - file looks a little bit more complex
46:42 - than configmap or a secret so let's go
46:45 - through the configuration and understand
46:47 - all these attributes so we have the
46:49 - metadata section
46:51 - and the specification and these are
46:53 - basically deployment specific
46:56 - configuration that we have in the
46:58 - specification section and let's start
47:01 - with the main part of the deployment
47:02 - which defines the blueprint for the pots
47:06 - and that blueprint is defined as a
47:08 - template so template
47:11 - basically is a configuration of the part
47:15 - within the configuration of deployment
47:18 - and you see that template section has
47:20 - its own metadata and own spec or
47:24 - specification just like deployment has
47:26 - its metadata and specification right so
47:29 - this part actually configures the pod
47:33 - within a deployment and in the
47:35 - specification of the pod we have the
47:37 - definition of containers so this is a
47:40 - list of containers as you learned you
47:42 - can have multiple containers in a pot
47:45 - but mostly one main application per pot
47:49 - and this is where we define which image
47:52 - will be used to create this pod in our
47:55 - case this is going to be a mongodb image
47:58 - and if we
48:00 - search for
48:01 -  in docker hub
48:04 - that's basically the image name and you
48:07 - can find all the text
48:09 - in the text section and we're going to
48:11 - use the tag 5.0
48:14 - so one go
48:17 - 5.0 that's where we define the image
48:20 - of the container within the pot we can
48:22 - name this
48:23 - mongodb this is just the name of the
48:26 - container and we also have the port
48:28 - where the container will listen and
48:30 - let's check our image and as you see
48:33 - mongodb starts at this port so we can
48:35 - just copy it and paste it in here so
48:38 - this basically
48:40 - just configures our deployment to create
48:43 - pods with a mongodb image version
48:46 - 5.0 so that's the core of a deployment
48:50 - now let's see what is all this other
48:51 - stuff here first of all we have this
48:54 - labels attribute in the metadata section
48:58 - and then we also have match labels
49:00 - attribute so what is this about in
49:03 - kubernetes you can give any component
49:06 - a key value pair labels so you can label
49:10 - anything from pod to deployment to
49:12 - configmap etc and labels basically are
49:16 - additional identifiers of the components
49:18 - in addition to the name for example
49:21 - so you can
49:22 - identify and address specific components
49:26 - using their labels
49:27 - now why do we need them first of all
49:30 - when we have multiple replicas of the
49:32 - same part
49:34 - each part will get a unique
49:36 - name however
49:38 - they can share the same label so we can
49:41 - identify all the part replicas of the
49:43 - same application using a specific label
49:47 - that all of them share and that's why in
49:49 - the metadata of the pod we always have
49:52 - this label so for pods labels is a
49:55 - required field for other components like
49:58 - deployment configmap etc labels is
50:01 - optional but it is a good practice to
50:04 - set them
50:05 - now
50:06 - when we create pod replicas how does
50:08 - deployment know which parts actually
50:11 - belong to it or how does kubernetes know
50:13 - which pods belong to which deployments
50:16 - and that is defined using
50:19 - this part right here so
50:21 - selector match labels is in the
50:23 - specification of the deployment as you
50:25 - see and this defines
50:27 - that all the parts that match
50:30 - this label belong to
50:33 - this deployment so that's why we have
50:36 - match labels here
50:38 - so this
50:39 - selector will match the pods created
50:42 - with this configuration
50:44 - because they have label app engine x now
50:47 - are these labels
50:48 - given or can you select any key value
50:51 - pairs well these are totally up to you
50:53 - you can call it whatever you want
50:55 - you can call it my key
50:58 - my value it doesn't really matter
51:00 - however the standard and a common
51:02 - practice in kubernetes is to use app
51:06 - key in the labels when labeling your
51:08 - applications and the value will
51:10 - obviously be whatever application you
51:12 - have so let's actually change and set
51:15 - the values
51:17 - to instead of nginx
51:19 - because that's our application and of
51:21 - course we want to match label app
51:25 - and let's also change
51:27 - this one right here
51:29 - to deployment and finally last
51:32 - attribute we have here is replicas which
51:35 - is super simple and straightforward this
51:38 - just defines how many pods you want to
51:40 - create using this blueprint in our case
51:43 - let's do just one replica because it's a
51:46 - database and as you learned if you want
51:48 - to scale databases in kubernetes you
51:50 - should use stateful set and not a
51:52 - deployment to keep everything simple
51:54 - we're going to stick to one replica and
51:57 - that basically configures our mongodb
52:00 - deployment
52:01 - and the pod blueprint now let's add a
52:04 - service configuration because every
52:06 - application needs a service in
52:07 - kubernetes and
52:10 - that's going to be a separate
52:12 - yaml
52:13 - unit or yaml section and we're going to
52:15 - separate it using
52:17 - three dashes which is basic yaml syntax
52:20 - nothing specific to kubernetes and again
52:23 - let's
52:25 - grab a service example
52:34 - and adjust it as we need now service
52:36 - configuration is much easier than the
52:38 - deployment as you see first let's change
52:41 - the name let's call it service and
52:44 - remember this is the end point
52:47 - which
52:48 - we will use to access and that's
52:50 - what we defined right here so this is
52:53 - the name of the service
52:57 - and in the specification we have
53:00 - service specific attributes first of all
53:03 - we have the selector attribute which you
53:06 - already know from here now why do we
53:08 - need a selector in service because as
53:11 - you know service needs to forward the
53:14 - request that it gets to
53:17 - its endpoint pods how does service know
53:20 - which pods belong to it and which ones
53:23 - it should forward the requests to well
53:25 - using the same label selector as we saw
53:29 - on deployment so this should match
53:32 - the label
53:33 - of the pods that will belong to the
53:36 - service which is
53:37 -  and that's how service and pods
53:41 - will find each other and then we have
53:43 - the ports configuration which is also
53:46 - super simple service is accessible
53:48 - within the cluster using its own ip
53:52 - address and the port and we define its
53:55 - port right here
53:56 - and this can be any port that we decide
53:58 - on this could be 80 8080 doesn't really
54:01 - matter
54:02 - and we have the target port which is the
54:06 - port of the pods that belong to the
54:09 - service and logically enough the target
54:12 - port should always be the same as the
54:15 - container port because that's where the
54:17 - application in the pod is accessible
54:20 - that's where the service should forward
54:23 - the request to so again very important
54:26 - port attribute sets the port of the
54:29 - service and target port tells service
54:33 - to which port it should forward the
54:36 - request to the pods and this should be
54:39 - same as the container port port and
54:41 - target port values can be different or
54:44 - again it's a common standard
54:46 - to
54:47 - select the same port for the service as
54:49 - well just to keep things simple so let's
54:52 - save this and that's our configuration
54:55 - for mongodb deployment and service
55:00 - now i'm going to copy this whole thing
55:03 - and
55:04 - create
55:05 - a deployment in service for web
55:08 - application for our kubernetes demo
55:11 - application and let's call this webapp
55:14 - dot yaml
55:16 - paste
55:17 - everything in
55:19 - and we can just adjust all these
55:22 - values
55:30 - in the service
55:31 - and deployment
55:33 - all the labels and label selectors of
55:35 - course
55:36 - and right here we of course need the
55:39 - correct image of our web application
55:42 - going back to our docker hub
55:44 - this is
55:45 - the name of my image and again this is
55:48 - publicly accessible so you can use it as
55:51 - well
55:52 - and
55:53 - the tag is v
55:55 - 1.0
55:57 - and there you go so this is a very
55:59 - simple node.js application which starts
56:02 - on port 3000 so that's why we need to
56:05 - define container port on 3000 and
56:08 - container port is same as target port
56:11 - on the service and we can set the
56:13 - service port to the same value and this
56:16 - will configure
56:17 - deployment
56:19 - and
56:20 - service for our web application
56:23 - so this is
56:24 - the basic configuration for deployment
56:27 - and service for any application in
56:30 - kubernetes cluster
56:34 - but we have one more thing to configure
56:37 - in our deployment components for both
56:40 -  and web app which is we need to
56:43 - pass the data defined in the config and
56:47 - secret components
56:48 - first of all when starting a mongodb
56:51 - application we need to set user name and
56:54 - password so when mongodb application
56:56 - starts it will automatically generate
56:58 - username and password for mongodb and we
57:00 - can then use that to access it in our
57:03 - cluster
57:04 - now how do we know
57:06 - how username and password can be
57:08 - configured in a mongodb on startup well
57:11 - we go to the image documentation and
57:14 - right here we see the environment
57:16 - variable names
57:18 - for username and password and these are
57:21 - actually required fields in most of the
57:23 - databases we have to set them otherwise
57:26 - we won't be able to access them so the
57:28 - next question is how do we configure
57:30 - environment variables in a container
57:33 - configuration so how do we pass
57:35 - environment variables to this
57:37 - application running inside the container
57:40 - well that's also very easy we have n
57:44 - attribute for that
57:46 - which is a list of environment variables
57:49 - with names
57:50 - and
57:52 - values that's it
57:54 - so
57:55 - very simple so name is the environment
57:58 - variable name and value is
58:00 - the environment variable value so let's
58:03 - copy the name
58:05 - so this is the environment variable name
58:07 - that mongodb expects and we have to set
58:10 - a value whatever we want the username to
58:13 - be now we can directly set
58:16 - the username right here like this
58:19 - or in our case we're going to reference
58:21 - them from secret and config
58:24 - components
58:26 - how do we do that also pretty simple we
58:28 - do value from
58:31 - and we want to reference it
58:32 - from the secret so we do secret
58:36 - key
58:38 - ref
58:40 - and under that we have the name of the
58:42 - secret
58:43 - which we called secret
58:46 - and the key
58:50 - which is user
58:53 - so kubernetes will basically find a
58:55 - secret with this name
58:57 - and get the value set for this key and
58:59 - substitute it as a value for this
59:02 - environment variable and the same way
59:04 - we're gonna
59:06 - configure
59:08 - a password
59:09 - so let's take the password that's the
59:12 - name of the environment variable
59:14 - same secrets
59:16 - component
59:19 - this time with a different key
59:22 - and that's it
59:23 - so our mongodb configuration file is
59:26 - complete
59:28 - and when it starts a user with these
59:30 - credentials will be created
59:35 - when our web application starts it will
59:38 - need to connect to the database so we
59:40 - need to give this web application
59:43 - information about the database endpoint
59:46 - where can it access the database
59:49 - and which username and password to use
59:52 - to authenticate with the database and i
59:54 - have already configured this application
59:57 - inside to expect all these values as
60:00 - environment variables with specific
60:03 - names so we're going to pass
60:05 - these three pieces of data as
60:07 - environment variables
60:09 - to the web app application so let's do
60:13 - that
60:16 - again
60:17 - the name of the environment variable the
60:18 - first one i actually called username
60:22 - and we can actually copy
60:25 - the same configuration and paste it here
60:28 - and you already see an advantage of
60:30 - using
60:31 - configuration from secret or config
60:34 - because if you need the same information
60:37 - in 10 different applications you create
60:39 - it once and reference it 10 times
60:43 - the second
60:44 - environment variable is for password
60:49 - and i called this one user pwd
60:53 - and finally our application needs
60:56 - the database endpoint which
61:01 - will be db url
61:04 - and this value is not in the secret
61:07 - but in configmap and how do we access
61:10 - value from config map very similar as
61:14 - the secret so we have the same value
61:16 - from
61:19 - and instead of secret key ref we have
61:21 - config
61:23 - map
61:24 - kirev
61:25 - or key reference
61:27 - and then we have
61:28 - name which we called config
61:33 - and key
61:36 - which is the name of the key
61:39 - and that's it so we don't have any of
61:41 - the configuration values hard coded in
61:44 - our
61:45 - kubernetes configuration files we only
61:48 - have references which makes our
61:50 - configuration way cleaner so if
61:52 - something changes or the values change
61:54 - here we don't have to adjust anything in
61:57 - our deployments
62:01 - so connectivity with the database is
62:03 - configured and there is one last thing
62:06 - missing in our web application
62:08 - configuration before we deploy all this
62:10 - which is making it accessible from the
62:13 - browser we want to be able to type in
62:16 - some url and access our web application
62:19 - from the browser right and as you
62:22 - learned we have external services for
62:24 - that so we will need to adjust
62:27 - the service configuration a little bit
62:29 - right now
62:30 - these service configurations both of
62:32 - them are internal services
62:35 - so to make it external
62:37 - all we need to do is
62:40 - set a type which is by default cluster
62:43 - ip
62:45 - so that's the default type if we don't
62:47 - specify the type but we're going to set
62:49 - it to
62:50 - node port
62:52 - so node port is an external service type
62:55 - and it requires a third port which is
62:58 - called
62:59 - a node port
63:03 - so what is a node port port
63:05 - this is a port which will open on the
63:08 - kubernetes nodes on which the
63:11 - application will be accessible so on the
63:14 - node ip address in node port combination
63:17 - we will be able to access
63:20 - this service which will then access
63:24 - the pods behind it and node port range
63:27 - is actually defined in kubernetes so we
63:29 - can't just type anything we want here
63:34 - like this it has to be within the range
63:36 - of thirty thousand and thirty two
63:38 - thousand seven hundred sixty seven so
63:42 - anything within this range is fine as a
63:44 - value so we can do 30 000 or 30
63:48 - 100 doesn't really matter
63:51 - so let's set this as a value and this
63:54 - completes the web app configuration file
63:59 - now we have a very simple but also
64:02 - pretty realistic
64:04 - configuration
64:05 - for deploying an application with its
64:07 - database
64:09 - with external configuration in the
64:11 - cluster so as a final step we're just
64:14 - gonna create all these components one by
64:16 - one in kubernetes so i'm gonna open a
64:19 - terminal and we already have a mini cube
64:22 - cluster running
64:27 - but there are no components inside so
64:30 - first we need to create the external
64:32 - configurations because
64:34 - they need to be there when we create
64:36 - mongodb and web application deployments
64:40 - because they reference those
64:41 - configurations so let's create
64:44 -  config and secret first to do that
64:47 - we have cube ctl apply command with
64:50 - minus f which stands for file which
64:53 - takes a kubernetes configuration file as
64:55 - an input
64:57 - like this
64:58 - and creates whatever is defined inside
65:01 - and as you see config was created
65:04 - now let's create longer secret
65:08 - next we're gonna create a database
65:10 - because our web application depends on
65:12 - it
65:14 - so it should start first
65:16 - and again let's do cube ctl apply
65:19 - with mongo.yaml as an input and as you
65:23 - see deployment
65:24 - and service were created and finally
65:28 - let's deploy our web application and
65:30 - there you go so everything seems fine
65:33 - but of course we want to check all the
65:35 - parts and all the components
65:37 - that were created in the cluster
65:42 - so for that i'm going to actually switch
65:44 - to command line so that we can see it
65:46 - better
65:47 - and first we're going to do cube ctl get
65:51 - all
65:52 - which gives you all the components
65:54 - created in the cluster which includes
65:56 - deployments
65:58 - the pods
65:59 - behind the deployment and all the
66:01 - services and as you see we have
66:04 - deployment and web app deployment parts
66:07 - each one with one replica running and we
66:10 - have the services for
66:13 - mongodb and web app
66:15 - and web app service is of node port type
66:18 - which means we can access it externally
66:20 - however we don't see configmap and
66:22 - secret here we can get them using
66:25 - kubectl get config map
66:28 - and cubectl get
66:30 - secret commands so as you see displaying
66:33 - any component is pretty easy using cube
66:35 - ctl you just do kubectl get and the name
66:38 - of the component like pod and you get
66:42 - a list of those components
66:44 - with some additional data
66:46 - and cubesatl is actually a very powerful
66:49 - tool and it has a bunch of sub-commands
66:52 - so as a natural documentation for
66:54 - cubectl to basically have an overview
66:57 - and see what you can do with it you can
67:00 - always use cubectl
67:03 - help as a documentation which lists all
67:06 - the sub-commands you can use with it one
67:09 - of them which we already used
67:11 - get and for each sub-command
67:14 - like cube ctl get you can also get some
67:17 - help
67:18 - and basically see all the examples
67:20 - plus all the available options so you
67:23 - can navigate all the options you have
67:25 - here so cube ctl get is obviously the
67:28 - most common command you're going to use
67:30 - to list all the components
67:33 - if you want to see more details about a
67:35 - certain component
67:37 - you can use cube ctl describe command
67:40 - for it a name of the component like a
67:42 - service for example
67:44 - and the actual instance of that
67:47 - component like web app service and this
67:50 - will give you more detailed output about
67:52 - that specific component same way you can
67:55 - also do cube ctl describe pod and then
67:59 - name of the pod
68:02 - like this one
68:05 - and this will give you details about
68:08 - your pot including the status of how the
68:11 - pod was scheduled
68:13 - the container configuration
68:16 - labels etc
68:18 - and finally
68:22 - of course when you have applications
68:24 - running in your cluster you want to
68:26 - check the logs to troubleshoot debug or
68:29 - just make sure that everything is fine
68:31 - within the pod and you can do that very
68:34 - easily using kubectl locks command
68:37 - and just specifying name of the pot like
68:42 - this
68:42 - this gives you
68:44 - logs of the container inside
68:46 - and you can even stream the logs using
68:49 - minus f option
68:54 - so the final step we want to validate
68:56 - that our application is also accessible
68:58 - from the browser and for that we
69:01 - actually configured the service and we
69:03 - can actually get the service using
69:05 - service or svc
69:08 - comment so how do we access this service
69:11 - from the browser because this is the
69:13 - port we're going to use to access it but
69:15 - which ip address is it accessible at
69:18 - well the node port service is always
69:20 - accessible at the ip address of the
69:23 - cluster node so all the work nodes that
69:26 - the cluster has in our case we just have
69:28 - one which is the mini cube so we need
69:30 - the ip address of the mini cube to get
69:33 - that
69:34 - we just do mini cube ip
69:37 - or using kubernetes we can also get
69:40 - get node which gives you mini cube
69:44 - and
69:45 - a white output
69:47 - or a longer output than what you see
69:49 - here
69:50 - which will give you
69:51 - the ip address
69:54 - of the node which is the same as this
69:57 - one right here and by the way you can
69:59 - use the all white option for any other
70:02 - get command for services pods etc to get
70:06 - some additional information like this
70:09 - so let's grab the mini cube ip address
70:12 - and access the application at this port
70:18 - which is 30
70:20 - 100
70:22 - and there you go this is our web
70:24 - application which is connected to
70:27 - mongodb and we can also validate that by
70:30 - editing something
70:36 - and saving because this request goes to
70:39 - database
70:40 - and if we refresh
70:42 - the changes should still be there
70:45 - awesome so we deployed an application
70:47 - with its database in kubernetes which is
70:50 - a blueprint configuration for most
70:53 - common application
70:54 - setups you're gonna have plus you also
70:56 - learn a couple of cubesitl commands as
70:59 - well as how to reference the kubernetes
71:01 - official documentation to help you
71:04 - configure and create all the components
71:07 - i hope i helped you learn a lot about
71:09 - kubernetes with this crash course and
71:11 - you feel much more confident with
71:13 - kubernetes now if you're serious about
71:16 - learning kubernetes in depth i actually
71:18 - have two more resources for you
71:20 - as i mentioned at the beginning if you
71:22 - want to really become an expert in
71:24 - kubernetes and learn how to build and
71:27 - administer a cluster from scratch then
71:30 - my complete kubernetes administrator
71:32 - course will be a perfect resource for
71:34 - you but if your goal is rather to become
71:37 - a devops engineer then our complete
71:39 - devops educational program will be the
71:42 - best fit for you where during a
71:44 - six-month program you learn all the
71:47 - necessary concepts and technologies
71:49 - including kubernetes which you need to
71:52 - get started in devops or cloud
71:54 - engineering
71:55 - if you're interested you can find the
71:57 - links in the video description below and
71:59 - with that
72:00 - thank you for watching and see you in
72:02 - the next video