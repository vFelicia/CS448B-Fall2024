00:00 - hello and welcome to this python course
00:03 - in this full course you'll learn
00:05 - everything you need to get started with
00:07 - python
00:08 - python is the most popular programming
00:11 - language out there
00:12 - and is used for so many different
00:14 - industries
00:15 - like web development data science
00:18 - machine learning
00:19 - or generally for writing automation
00:22 - programs to automate repetitive tasks
00:26 - so learning python is definitely a good
00:28 - idea
00:29 - let me give you a short overview of all
00:31 - the topics i'll cover
00:32 - in this course after giving a short
00:35 - introduction to python
00:37 - we will start with the basic building
00:39 - blocks of programming
00:41 - the most important data types like
00:43 - strings
00:44 - numbers lists sets dictionaries
00:47 - boolean data types etc and how to work
00:50 - with them
00:51 - learn about variables and functions and
00:54 - why we need them
00:56 - write a program that accepts user input
00:59 - and learn how to validate the user input
01:01 - using conditionals
01:04 - error handling with try accept
01:07 - and also learn loops with while and for
01:10 - loops
01:10 - and again why we actually need them you
01:14 - will learn all these concepts
01:15 - with hands-on examples as a next step
01:19 - you will learn how to modularize your
01:21 - program by writing
01:23 - your own modules and then see how to use
01:25 - some
01:26 - built-in python modules with all this
01:29 - knowledge we can then
01:30 - build our next demo project to write a
01:33 - small program
01:34 - that accepts a goal and a deadline
01:37 - as user input and then outputs the
01:40 - number of days
01:41 - remaining till the goal deadline
01:44 - within this exercise you will learn how
01:46 - to use the date
01:47 - time module to work with dates
01:50 - after that you will learn about packages
01:53 - and comparison of package
01:55 - versus module and we will use an
01:58 - external python package in our next demo
02:02 - project
02:02 - in which we will automate some tasks for
02:05 - working with a spreadsheet file
02:07 - finally we dive into object-oriented
02:10 - programming
02:11 - you will learn what classes and objects
02:13 - are in programming
02:15 - and python specifically and why this
02:17 - concept is
02:18 - so useful in the final demo project you
02:22 - will learn another common use case with
02:24 - python
02:25 - which is communicating with other
02:27 - applications
02:28 - over the internet by making a request
02:31 - to fetch some data from gitlab api
02:34 - in this specific case we will list the
02:37 - gitlab projects
02:38 - of a specific user so that's what we're
02:42 - gonna learn
02:43 - if you like this course don't forget to
02:45 - give this video a thumbs up
02:48 - i'm really excited to teach you all of
02:50 - these so
02:51 - let's get started
02:55 - first of all python is a programming
02:57 - language
02:58 - just like java or javascript python
03:01 - compared to other languages
03:03 - has two very big advantages first of all
03:06 - it's easy to learn it has a simple
03:08 - syntax
03:09 - and it's very easy to set up and get
03:11 - started with
03:12 - for example compared to java where you
03:15 - need
03:15 - some initial configuration before you
03:18 - can even start your application
03:20 - but it's equally or even more powerful
03:22 - than java
03:23 - now what makes a language powerful or
03:26 - how can i say that python is more
03:28 - powerful
03:29 - well that comes from the ecosystem which
03:32 - means
03:33 - libraries and modules that python
03:35 - developers themselves develop
03:37 - but also external developers create and
03:40 - maintain
03:41 - so the more people adopt the language
03:44 - the more powerful it gets because
03:46 - new libraries and so new functionalities
03:49 - get added to it
03:50 - and the second advantage is that it's
03:52 - flexible now what does a
03:54 - flexible mean in this case what makes a
03:57 - language flexible
03:58 - it is easy to mold to your wishes
04:02 - so you are not limited or restricted by
04:04 - the language specifics like
04:06 - syntax or data types or some other
04:09 - constraints
04:10 - or even library functionalities you can
04:13 - extend
04:14 - python widely and as one of the results
04:17 - of this flexibility
04:19 - python also became a multi-purpose
04:22 - language
04:23 - meaning it is used for many different
04:25 - categories
04:26 - so let's see what these categories are
04:31 - first you can use it to write web
04:33 - applications the popular libraries for
04:35 - that are django
04:36 - or more lightweight flask python became
04:40 - extremely popular because of the rise of
04:43 - data science
04:44 - machine learning and artificial
04:46 - intelligence
04:47 - industries and more and more libraries
04:50 - were created
04:51 - and are still being added for python for
04:54 - all these categories
04:56 - they are very popular and highly used
04:58 - libraries for
04:59 - data analysis and data visualization
05:02 - libraries for
05:03 - artificial intelligence projects for
05:05 - things like
05:06 - face recognition voice recognition and a
05:08 - bunch of very powerful
05:10 - and widely used machine learning
05:13 - libraries
05:14 - python is also often used for data
05:17 - collection
05:17 - like scraping the web creating web
05:20 - crawlers
05:21 - that are basically programs that collect
05:23 - data from internet
05:24 - which you can save and then process
05:26 - later again
05:28 - many different powerful libraries to do
05:30 - all of that
05:31 - and finally automation with python
05:34 - python has many great libraries to
05:36 - automate
05:37 - devops tasks for example starting from
05:40 - ci cd
05:41 - pipelines to cloud platforms and
05:43 - monitoring your infrastructure
05:45 - etc you can also write python scripts to
05:48 - do
05:48 - automated backups cleanups on the
05:51 - servers etc
05:52 - in addition to devops tasks you can also
05:55 - automate
05:56 - just general tasks with python like when
05:58 - working with
05:59 - excel sheets which is a common use case
06:02 - in many big companies
06:03 - or automating some tasks on your own
06:05 - laptop
06:07 - and there are also libraries for mobile
06:09 - development
06:10 - gaming desktop applications but
06:13 - these are less likely use cases for
06:15 - python because there are better
06:17 - alternatives
06:18 - for that so you see that the use cases
06:21 - for python are pretty vast and it
06:24 - actually spans
06:25 - several industries and it's mostly
06:27 - concentrated
06:28 - around data analytics machine learning
06:31 - and automation
06:32 - areas and note that this isn't the case
06:34 - for many other programming languages
06:36 - usually one programming language is good
06:39 - for just
06:39 - few things and you should use something
06:42 - else
06:43 - for other use cases so now you see how
06:46 - useful
06:46 - python knowledge could be and how it can
06:49 - help you
06:49 - in your job but also make you more
06:52 - valuable at your work and for your
06:55 - entire team
06:56 - i hope you are already excited to learn
06:58 - python so let's get started
07:03 - as a first step we're going to configure
07:05 - our local
07:07 - python development environment so the
07:09 - first thing we need
07:10 - is install python locally
07:14 - on our laptop so first we
07:17 - install or download python package
07:20 - for your specific operating system and
07:23 - then basically just click through the
07:25 - installer
07:26 - wizard to install python
07:29 - locally on your laptop
07:32 - and note that if you're doing this on
07:34 - windows
07:36 - very important step in the installation
07:38 - process would be to
07:40 - check the ed python to
07:43 - path option basically that you see here
07:46 - because by default it is unchecked and
07:49 - you have to
07:50 - check mark it so that after the
07:52 - installation
07:53 - you'll be able to execute python
07:55 - commands in your terminal
07:58 - now an interesting note here if you're
08:00 - using mac os
08:01 - like i do is that by default
08:05 - on mac os there is python already
08:07 - installed
08:08 - so if i do python version
08:12 - and execute i see that python version
08:15 - 2.7
08:16 - 10 is installed and that is actually
08:19 - python
08:19 - that mac os the operating system itself
08:22 - is using
08:23 - however for our tutorial and generally
08:26 - when working with python
08:28 - we want to be using the newest version
08:30 - which is
08:31 - python 3. so we're going to leave that
08:34 - default python installation
08:36 - alone we're not going to use that or
08:37 - touched it and instead we're going to be
08:39 - using
08:41 - the python version 3 that we just
08:44 - installed locally
08:46 - so now if i clean this up and we want to
08:48 - execute
08:49 - python version 3 commands we're going to
08:52 - do python 3 instead
08:54 - and version and that will give us the
08:58 - version so that's how we can
08:59 - differentiate between
09:01 - the already installed python and
09:04 - the newest version that we just
09:05 - installed so just be
09:07 - aware of that difference
09:12 - now that we have python available
09:14 - locally it's time to
09:16 - download a code editor for python
09:19 - because we're going to be writing files
09:21 - with python code
09:22 - so we need a proper editor for writing
09:25 - python code
09:26 - and actually the best python code editor
09:29 - available
09:30 - out there currently is pycharm which is
09:34 - from jetbrains
09:35 - so that's what we're going to be using
09:37 - throughout our tutorial
09:38 - so let's go to pycharm it is an
09:42 - intelligent code editor which makes it
09:45 - much easier to write code so it makes
09:48 - you actually very productive when
09:50 - writing code
09:51 - and we will see why throughout the
09:53 - course as you can see there are two
09:55 - versions
09:56 - we have the community version and
09:57 - professional one community version is
10:00 - free and
10:01 - already has a lot of powerful features
10:03 - but the professional edition
10:05 - gives you additional very useful
10:07 - features especially if you're creating
10:09 - web applications
10:11 - or scientific projects in python so with
10:13 - professional
10:14 - version additionally you will get
10:16 - scientific tools that you can use
10:18 - in scientific projects with python but
10:21 - also you get support for
10:22 - python web frameworks and database
10:25 - integration which can be of course
10:26 - very helpful if you're developing web
10:28 - applications if you want to get the
10:30 - professional edition jetbrains actually
10:32 - provided me with a code
10:34 - for my channel to try it out for three
10:37 - months for free
10:38 - just use my code when you install it but
10:40 - for this demo
10:41 - community version is absolutely fine so
10:44 - i will go with this one and
10:46 - install it and just click download
10:49 - and once the pycharm installer is
10:52 - fully downloaded we can just click on it
11:02 - move it to the application and now i can
11:05 - actually use it
11:06 - locally so i'm just gonna open the
11:09 - application
11:10 - and we're gonna take a quick tour around
11:13 - pychar
11:18 - it's actually pretty simple to set it up
11:20 - and there you go
11:21 - we have our pycharm and we can now
11:24 - create
11:25 - a new project and let's call it
11:28 - my python project
11:31 - and that's it basically we don't need to
11:34 - change anything else
11:35 - and here you see the location basically
11:38 - of where this application
11:39 - folder will be created you see pycharm
11:42 - projects
11:43 - folder got created in my users directory
11:46 - so this is basically very convenient
11:48 - because all my
11:49 - pycharm projects or my python projects
11:51 - that i create using pycharm
11:53 - will be created in one location and here
11:56 - you also see that python
11:58 - version 3 that we installed is
12:00 - automatically
12:01 - being used for this project which is
12:03 - exactly what we want
12:05 - and you see it says base interpreter
12:08 - and python interpreter is basically
12:11 - a program that knows how to execute
12:14 - python code it will know how to
12:16 - interpret or translate
12:18 - our python code into instructions
12:22 - that computer can understand so with
12:24 - this configuration we don't have to
12:26 - change anything
12:27 - we're gonna create our project so first
12:30 - of all i'm going to
12:32 - make all this a little bit bigger so
12:34 - that you can see
12:35 - the menu here on the side and the code
12:38 - a little bit better so in preferences
12:42 - editor font we're going to set the size
12:45 - to 20. if i apply this
12:50 - right here you see that this code editor
12:53 - font basically got bigger and i also
12:56 - want to
12:56 - increase the size of this menu font here
12:59 - so in
13:00 - appearance i'm going to
13:04 - set it to maybe 18 and there you go
13:07 - so basically everything is bigger now so
13:11 - you can follow along and see exactly
13:12 - what i'm typing
13:14 - and also another note here if you want
13:17 - to configure
13:18 - your theme basically so if you don't
13:21 - want it to be dark
13:22 - or maybe you want some other color
13:24 - scheme then you can select it here
13:26 - in appearance you have four themes
13:29 - available
13:29 - let's actually try this one out
13:33 - and apply and there you go you have a
13:36 - different theme i actually prefer this
13:38 - one so
13:39 - let's leave it at that so as you see we
13:42 - have a very simple
13:43 - project with one
13:47 - main main.pi file the extension is for
13:50 - python files
13:52 - which basically contains very simple
13:54 - code
13:55 - and we're gonna basically just remove
13:57 - all of these
13:58 - and start from a clean python
14:01 - file state and in the next section we're
14:04 - gonna
14:04 - dive right in and write our first
14:07 - simple python application
14:13 - we're gonna start with the simplest
14:15 - example in python
14:17 - to basically learn python syntax and
14:20 - get started as simply as possible so
14:23 - first of all
14:24 - we're gonna write a very simple
14:26 - application that just
14:27 - prints some output and in python when we
14:31 - want to print
14:33 - basically display results of what we
14:35 - wrote
14:36 - we use this syntax where we say print
14:39 - and
14:39 - here we can pass in basically whatever
14:42 - we want to display
14:44 - and now if i want to see whether this
14:46 - super simple application works
14:48 - i can run it or execute it
14:51 - with this triangle here and i have the
14:54 - output so the basically the output
14:56 - is displayed or printed right here and i
15:00 - see
15:00 - the output is 1. i can display some
15:03 - other values
15:04 - like 200 and run it and there you go
15:08 - let's say we want to display some text
15:14 - basically whatever some sentence and
15:17 - again
15:19 - triangle and we have that output here
15:21 - right
15:22 - so again very simple example of
15:26 - writing python code that basically
15:29 - displays some information when we
15:31 - execute it
15:36 - one thing that i want to note here is
15:38 - you see that we write some code
15:41 - basically
15:42 - in this window right here so in our
15:45 - main.pi
15:46 - file and when we run it
15:49 - or execute it our code we see some
15:52 - display in this window so you may be
15:55 - wondering what is this window and why do
15:58 - we see
15:59 - some output right here the answer to
16:01 - that is that whenever you're working
16:03 - with
16:04 - tools like pycharm which basically
16:07 - have all the functionality that you need
16:10 - to
16:10 - write your code and then execute your
16:12 - code you basically have everything in
16:14 - one place
16:15 - so whatever we write we can execute or
16:18 - run
16:19 - right away now without such tool how
16:22 - would we
16:23 - write code and how would we execute that
16:26 - code and this will help you understand
16:28 - what's going on
16:29 - here and to show that i'm going to go
16:32 - back to my terminal
16:33 - and i'm going to create a new file and
16:36 - i'm going to call it
16:39 - test dot py
16:43 - we're going to write the same
16:47 - code basically in this file
16:51 - you can do it in a file editor i'm just
16:53 - doing it directly in the command line
16:56 - and save it so now we have the same
16:59 - identical
16:59 - file as here
17:02 - but not inside our code editor right
17:06 - not inside this pycharm tool and we have
17:10 - python 3 available locally so
17:13 - now how do i actually execute a python
17:16 - file outside this pie chart
17:21 - i can do that using python 3 test
17:24 - dot p y and if i do that
17:29 - i get the same output in the command
17:32 - line
17:32 - so basically what you see right here
17:35 - this whole thing
17:36 - is integrated so basically all
17:39 - in one place where you can write your
17:42 - code
17:43 - the editor right here where you can
17:46 - navigate
17:46 - your files in your project so basically
17:49 - this is just a folder
17:50 - on your laptop and you can navigate the
17:54 - files here
17:55 - and you have the execution environment
17:58 - at the same time so you have to go to
18:00 - terminal and execute python 3
18:03 - whatever you have everything in one
18:05 - place and
18:06 - tools that provide you with this type of
18:08 - environment for different programming
18:10 - languages
18:11 - for python it happens to be pycharm
18:13 - these are called
18:15 - ides which stand for integrated
18:18 - development environment integrated
18:21 - because you have
18:22 - everything in one place so you don't
18:24 - need to
18:25 - use terminal but in addition to this
18:28 - integration you get more cool features
18:30 - which helps you in writing python code
18:33 - for example
18:34 - syntax highlighting highlighting errors
18:37 - or
18:38 - code suggestions autocomplete
18:40 - suggestions
18:41 - and we will see those cool features
18:43 - actually also throughout this course
18:45 - so basically just makes your life as a
18:48 - developer easier
18:49 - however it's good to understand that
18:51 - connection
18:52 - between executing your files on the
18:55 - terminal
18:56 - when you don't have such a tool versus
18:59 - executing and working on your
19:00 - application inside that tool
19:06 - awesome so let's get back to our code
19:09 - editor
19:10 - a file where we write our code and till
19:13 - now we have done something really simple
19:15 - like print
19:16 - a text basically and print
19:19 - a number right and this leads to
19:22 - the first concept in programming
19:25 - languages which
19:26 - are data types so in python
19:29 - just like in any other programming
19:30 - language you have data types
19:33 - for text and numbers the text data types
19:37 - are called
19:38 - strings so everything within the double
19:40 - quotes is basically a string
19:43 - but note that in python you can also use
19:45 - single quotes
19:46 - for strings so double quotes or single
19:49 - quotes
19:50 - they both work the same and there's
19:52 - actually no difference between them
19:55 - and for numbers we actually have
19:57 - different data types
19:58 - so for whole numbers like 2 20
20:02 - but also 0 and negative numbers as well
20:05 - we have
20:06 - a data type called integer and that's
20:09 - also how it's called in most programming
20:11 - languages
20:12 - however you also have numbers for
20:14 - currency for example how much
20:16 - a product costs right so if you have an
20:18 - online shop you would have
20:20 - prices like this for example so these
20:23 - are basically
20:24 - numbers with precision this could also
20:26 - be
20:27 - for example when you're shipping
20:28 - something you could have
20:30 - a weight of a package that is also
20:33 - not a whole number but has a precision
20:35 - so this type of numbers
20:37 - in python and many other programming
20:39 - languages are
20:40 - represented as float data type
20:44 - so again you have integers
20:48 - and float data types and if we execute
20:52 - that
20:52 - you basically see all of that printed as
20:55 - we wrote them
20:59 - now obviously printing values like
21:02 - numbers and text like this doesn't make
21:05 - much sense unless we're getting some
21:08 - useful information
21:09 - from our simple program right here right
21:12 - so let's do something more useful with
21:15 - python now
21:17 - let's clean all this up and let's say we
21:20 - want to do some
21:21 - calculations very simple logic that
21:24 - basically calculates
21:25 - how many minutes there are in 20 days
21:32 - so we have 20 days which have 24 hours
21:36 - per day
21:37 - which have 60 minutes per hour
21:40 - so this line will give us basically
21:42 - calculation of
21:44 - minutes for 20 days and there you go
21:47 - that's our number now this makes a
21:50 - little bit more sense
21:51 - because now we have a program that
21:53 - actually does something for us
21:54 - so basically as you see you can do any
21:57 - math operations on numbers
21:59 - in python and again in many other
22:02 - programming languages
22:03 - you can do plus minus division whatever
22:06 - just like you know it from basic math
22:09 - however i want to note right here
22:11 - something that many people think about
22:14 - programming
22:14 - and maybe are misinformed about
22:18 - which is if you're doing web development
22:21 - or maybe devops automation with python
22:24 - and not something like data science or
22:27 - data analytics
22:28 - this is probably an example of the
22:32 - highest
22:32 - math knowledge that you need for
22:34 - programming in python
22:36 - because even though we're going to use
22:37 - some calculation
22:39 - examples because they're just good as
22:41 - examples to
22:43 - show you the basic concepts of python
22:45 - you do not
22:46 - really need any advanced or even
22:49 - intermediate
22:50 - knowledge of mathematics when
22:52 - programming
22:53 - because it's really not about meth
22:55 - however what you need is
22:57 - logical thinking and we're going to be
22:59 - doing some of that and
23:01 - see that as examples so just bear that
23:04 - in mind
23:05 - in case you are misinformed about that
23:11 - so back to our example we have this
23:13 - number that is displayed here
23:15 - as a result however maybe if we use this
23:18 - program
23:19 - we don't remember or we don't know what
23:21 - this number stands for
23:22 - if somebody else is using so we want to
23:25 - add some descriptive
23:26 - information about this number that says
23:29 - this is how many
23:30 - minutes there are in 20 days so
23:32 - basically we need a line that says 20
23:34 - days
23:35 - are this many minutes
23:40 - and this should basically be exactly
23:42 - this calculation
23:43 - right here so how do we put this
23:47 - calculation basically right here in the
23:49 - middle
23:50 - so that we end up with this whole phrase
23:54 - displayed right here so how do we
23:56 - combine text
23:58 - and numbers basically or calculation
24:02 - of numbers and in programming languages
24:05 - again this is not specific
24:06 - to python we would do that using
24:09 - something called
24:10 - string concatenation and string
24:13 - concatenation is basically a fancy word
24:16 - for
24:16 - gluing together or combining multiple
24:19 - strings
24:21 - now how does the syntax for that look
24:23 - like
24:24 - we combine the strings using plus sign
24:27 - so apart from adding numbers obviously
24:29 - using plus
24:30 - plus is also used in programming for
24:33 - combining
24:34 - multiple strings so in our example we
24:37 - have
24:38 - three string values and we want to put
24:40 - them all together
24:41 - in one string or one sentence we have
24:44 - the first string 20 days r
24:47 - and then we have the second string
24:49 - minutes and in the middle the third
24:50 - string
24:51 - which will be the value of the
24:53 - calculation
24:54 - however if we just put a number here
24:57 - python
24:58 - interpreter tells us it's not a string
25:01 - it's a number so we need to turn it into
25:04 - a string
25:05 - other programming languages do that
25:07 - automatically in python we need to do
25:09 - that
25:10 - explicitly so we need to tell python
25:14 - take this number but not as a number but
25:17 - as
25:17 - a string and we do that using a syntax
25:23 - that looks exactly like that so
25:25 - basically we
25:26 - have a non-string value but we're
25:28 - telling python we want it as a string
25:31 - because it needs to be printed out as a
25:34 - text basically
25:35 - so if i execute this line
25:39 - let's see what happened and there you go
25:40 - we have our output
25:42 - just like we wrote it here but you see
25:45 - that there
25:46 - are no spaces around so basically 50
25:49 - is just really glued together without
25:52 - any space
25:53 - around and how do we put spaces around
25:56 - these 50
25:57 - basically add a space here add a space
26:00 - here
26:00 - now why does that work because this
26:03 - whole thing for python is a string again
26:06 - because we are
26:07 - putting it within these quotes so
26:10 - basically any character
26:11 - that you see on your keyboard right now
26:14 - if you put it
26:15 - between those quotes is
26:19 - interpreted by python as a string
26:22 - including this space character right so
26:25 - if we execute it again
26:27 - we have spaces around 50 and our
26:30 - sentence our phrase looks fine and if
26:33 - you're thinking right now this is
26:35 - actually kind of annoying because
26:37 - first of all it looks ugly and also
26:39 - there's a high chance you're gonna
26:40 - forget it
26:41 - that is absolutely right so in python
26:45 - again
26:45 - specifically there is a way to do it
26:48 - in a more elegant way using a different
26:52 - syntax and the more elegant syntax
26:55 - for that let's actually close this is
26:59 - print
27:03 - and let's write that again and
27:06 - instead of having these plus
27:10 - we have curly braces and we write
27:13 - our number inside or whatever
27:16 - non-textual
27:17 - value and at the beginning right here
27:20 - basically
27:21 - before we start writing a string which
27:24 - starts with
27:24 - quotes we just write the letter f
27:28 - and you see the syntax highlighting as
27:29 - well basically
27:31 - sees that this is not part of the text
27:35 - this is non-text value and if i
27:38 - execute it i should see the same output
27:41 - from the second line and this is really
27:43 - a way cooler way
27:45 - to write this instead of using plus
27:48 - but this is something very common and
27:50 - also something that
27:51 - you would encounter in most programming
27:53 - languages so just
27:54 - important to know that this is a syntax
27:57 - for
27:57 - string concatenation as well so we can
28:00 - basically just
28:02 - remove it and use this syntax for our
28:06 - examples
28:06 - and also note that this syntax is
28:08 - actually a new addition to python
28:11 - so it only works if you have a latest
28:13 - python version
28:14 - in our project if you remember we
28:17 - actually
28:18 - configured and chose version 3.9
28:22 - and that's why it works for us if you
28:25 - use
28:26 - python 2 for example python version 2
28:29 - this syntax is not going to work for you
28:31 - we can actually demonstrate it
28:33 - so i'm going to copy that line
28:36 - and i'm going to change our test.pi
28:48 - and now if i execute it using my python
28:51 - 3
28:53 - you see it works fine if i do it with
28:56 - python which is version
28:58 - two point something
29:01 - let's see what happens there you go
29:04 - syntax error invalid syntax because
29:06 - python version
29:12 - 2.7.10 so older version basically
29:15 - doesn't recognize this syntax so just be
29:18 - aware of that
29:19 - so this syntax actually only works for
29:21 - python versions
29:22 - starting from 3.6 so everything
29:26 - below that every python version
29:28 - basically will not recognize this syntax
29:31 - as we see right here so again back to
29:33 - our code
29:34 - and now we just have a number here
29:38 - but what we actually want is the
29:40 - calculation
29:41 - for getting the correct result right so
29:43 - we want again
29:44 - 20 days
29:48 - in hours and then in minutes and if i
29:51 - execute it
29:52 - you see that the calculation was done
29:55 - and here we have
29:56 - the full complete sentence with the
29:58 - result in it
30:00 - and if you're curious this f actually
30:02 - stands
30:03 - for format so this is basically
30:06 - formatting
30:06 - our text or our string in a correct way
30:13 - awesome so we have this line of code
30:15 - here that basically
30:17 - calculates for us how many minutes there
30:19 - are in 20 days
30:20 - let's say we want to do the same for 35
30:24 - days
30:24 - right what we can do is basically copy
30:27 - that line
30:28 - and replace the values
30:33 - for 20 with 35 and if i execute it
30:37 - i get the same calculation but for 35
30:40 - days
30:41 - and we can do that basically multiple
30:44 - times
30:44 - for different values so let's say we
30:48 - want it
30:48 - for 50 days and we want the same
30:51 - calculation
30:52 - for i don't know let's say 110 days
30:55 - doesn't really matter
30:56 - and we have obviously different
30:59 - number of minutes for each of these
31:02 - values
31:03 - and now let's say we wrote this program
31:05 - it's ready
31:06 - and we're using it and at some point we
31:09 - decide you know what i want
31:11 - this program to actually calculate
31:14 - how many seconds there are for these
31:17 - provided days
31:19 - instead of minutes so what we would need
31:22 - to do in that case
31:23 - is basically change the calculation in
31:26 - all those four lines
31:27 - so instead of minutes it should actually
31:30 - calculate
31:31 - number of seconds in a day right so we
31:33 - have the hours
31:34 - minutes and seconds and we would have to
31:37 - change the text as well here and we
31:40 - would need to do that
31:41 - for each one of those lines right
31:44 - so we would have it here
31:49 - like this and again if we need to modify
31:54 - this for hours or milliseconds or
31:57 - whatever
31:57 - we basically have to do these changes
31:59 - multiple times
32:00 - right even though if you actually look
32:02 - at that this is
32:04 - the same exact calculation for each line
32:06 - that doesn't change right if you want
32:08 - seconds then this is the calculation
32:10 - that you need to do
32:11 - so how can we actually avoid repeating
32:14 - the same calculation
32:16 - and the same text in our code and the
32:19 - answer to that is variables so in
32:22 - programming languages we have
32:24 - variables that basically hold values
32:27 - that will repeat throughout your code
32:30 - that you can set once and
32:33 - use it in multiple different places so
32:35 - instead of
32:37 - basically repeating this calculation
32:41 - four times we basically do this
32:43 - calculation
32:44 - once like this
32:47 - and we basically save this value
32:50 - in a variable so that we can use it
32:53 - whenever we need right
32:55 - and the way that variables are defined
32:58 - in python
32:59 - is variable name let's call it
33:03 - two seconds
33:08 - equals and whatever that value is that
33:12 - repeats itself and that we want to save
33:14 - into a variable
33:16 - now i want to make two notes here
33:19 - regarding the variables
33:20 - in python first of all in python
33:24 - defining or creating a variable and
33:26 - giving it a value like this
33:28 - syntax for that is actually very simple
33:32 - compared to other languages because you
33:34 - just have the variable name
33:35 - and the value in many programming
33:38 - languages you actually have to define
33:40 - here
33:40 - some kind of data type for that variable
33:42 - for example if it's a number
33:44 - like float or integer or string
33:48 - etc in python you don't have to define
33:50 - that
33:51 - you just have name of the variable
33:53 - simple as that
33:54 - the second one is the naming
33:57 - convention or standard for the variables
33:59 - so we have two words for example if we
34:01 - name
34:02 - our variable calculation to seconds
34:04 - right
34:06 - we have actually three words here so
34:08 - variables that are descriptive so
34:10 - basically they tell you
34:11 - what this value actually is about so
34:14 - they have multiple
34:15 - words in them you can separate them
34:18 - using these
34:19 - underlines again in different languages
34:22 - the
34:22 - naming for variables can be different in
34:24 - python this is actually
34:26 - one of the standard ways of defining
34:29 - variable with underscores
34:30 - which i find pretty nice and easy to
34:33 - read
34:34 - so we're gonna use this syntax basically
34:36 - throughout the course
34:37 - it will be totally and absolutely okay
34:39 - if we wrote it like this
34:41 - or if we used capital letters instead
34:45 - but again this is probably the most
34:48 - readable form
34:49 - and this is what we're going to use now
34:51 - here
34:52 - note that we can decide whatever name we
34:55 - want to give
34:55 - our variable but in python there are
34:58 - some specific words
35:00 - that have special meaning to python
35:02 - these are called reserved words
35:05 - so you can't use these words as variable
35:07 - names
35:08 - and we will use some of these reserved
35:11 - words
35:12 - throughout the course so you will see
35:14 - some examples
35:15 - great so we have our variable defined
35:18 - here and
35:19 - this is the value that this variable
35:21 - gives us so how do we replace now
35:24 - these repeating values with this
35:26 - variable
35:27 - so we're going to delete that and again
35:30 - inside we're simply going to copy
35:34 - the name of the variable so let's
35:36 - execute
35:37 - and as you see we have our
35:40 - value printed just fine and we're going
35:43 - to do the same
35:44 - for all those
35:49 - values and again execute
35:53 - everything works just like before now
35:56 - you may be thinking
35:57 - if we change this to minutes
36:00 - we would have to change the variable in
36:03 - all these places
36:04 - so that's our case we can basically just
36:07 - rename our variable something more
36:10 - generic so let's say calculation
36:12 - to units and this could be
36:16 - now any unit that we want second meaning
36:18 - it doesn't matter
36:19 - and this is exactly the advantage of
36:22 - variable
36:23 - because you can name it whatever you
36:24 - want
36:27 - which basically just describes what this
36:30 - variable is about
36:31 - and now you won't have to change that
36:34 - again
36:35 - and we can also replace this one here
36:38 - accordingly since it's a text we can
36:41 - call it a name
36:42 - of unit we can also call it unit doesn't
36:45 - really matter
36:46 - we're the ones deciding what that
36:48 - variable name is
36:49 - and once we have that variable we can
36:52 - now
36:53 - replace it here how do we do this
36:55 - because this is actually
36:56 - part of a text a string the same way we
37:00 - did
37:00 - right here we're gonna delete that
37:04 - and create an expression create a syntax
37:08 - that basically tells python
37:09 - hey this is not a string this is a
37:12 - non-string
37:13 - value and you already know this could be
37:15 - either number
37:16 - or variable itself and so we're going to
37:19 - use the curly braces
37:21 - and the name of the variable and just
37:24 - like that
37:25 - we have substituted these values here
37:29 - and if i execute it works perfectly fine
37:33 - and we can do that
37:38 - in all four lines and our code is still
37:41 - working
37:42 - and this syntax right here with this
37:44 - format
37:45 - at the beginning basically prevents us
37:48 - or avoids
37:49 - basically saves us from having a bunch
37:53 - of
37:53 - plus signs here and then space
37:57 - characters etc
37:58 - this all looks way elegant now and now
38:01 - if
38:01 - at some point we actually decide you
38:03 - know what i want
38:05 - this program to calculate how many hours
38:08 - there are in the given days instead of
38:11 - seconds
38:11 - and we want to change the program to do
38:13 - that we could basically
38:15 - just change the calculation here and
38:19 - instead of seconds we have hours and if
38:22 - i execute
38:23 - there you go we see the changes right
38:25 - away so
38:26 - this is why when you're programming
38:29 - doesn't matter in which language
38:31 - including python using variables will be
38:33 - probably some of the most frequent thing
38:36 - that you do
38:36 - because you always have values that are
38:38 - repeating themselves
38:40 - and you want to write clean code so you
38:42 - create
38:43 - variables and one of the best practices
38:46 - when
38:46 - creating and using variables is as we're
38:49 - using actually here is to name your
38:52 - variables
38:54 - so that you later and also other
38:56 - programmers who are working with you
38:58 - understand what this variable actually
39:01 - does or what type of value
39:03 - it actually has because if you just look
39:05 - at 24 you would probably not know
39:08 - what this 24 is about right but with
39:10 - variable
39:11 - you actually know that this actually
39:13 - represents a number that is used
39:16 - for calculating units right it could
39:19 - also be more descriptive
39:20 - like units for days but generally
39:24 - another advantage of variable is to
39:27 - basically describe that value
39:29 - as well that you're using in your code
39:35 - now another thing you probably also
39:37 - noticed is that
39:38 - even though we're using variables here
39:40 - so that we don't have to change
39:42 - those values in four different places a
39:45 - lot of
39:45 - these four lines are actually pretty
39:47 - similar the only difference
39:50 - in those four lines are actually these
39:52 - numbers
39:53 - right here everything else is exactly
39:55 - the same
39:56 - so what if instead we wanted to
39:59 - make this code cleaner and basically
40:02 - avoid
40:03 - this type of duplication in our code
40:06 - right so for example if we did this for
40:08 - 10 different values
40:09 - we would have the same line this long
40:12 - line basically 10 times right
40:14 - so how do we avoid this type of
40:16 - duplication
40:17 - so right here we actually avoided
40:19 - duplication
40:20 - for specific values right piece of
40:23 - string here
40:24 - a whole calculation here but how do we
40:27 - actually
40:28 - avoid duplicating a whole line right the
40:32 - whole
40:32 - piece of code basically which has
40:34 - multiple different stuff in it
40:36 - not just a value and we do that using
40:39 - functions so functions are basically
40:42 - blocks of code
40:44 - like this right or basically logic in
40:47 - code
40:47 - that does something it's not just simply
40:49 - a value but actually does something more
40:52 - complex
40:53 - that is again used in order to avoid
40:56 - repeating the same logic or most of the
40:59 - same logic
41:00 - in your code so how do we create
41:04 - functions just like we created variables
41:06 - here
41:07 - we create functions and the way we do
41:10 - that
41:10 - is using following syntax
41:15 - right here let's create our first
41:17 - function
41:19 - we start with def so we define
41:22 - a function just like we define a
41:25 - variable
41:25 - but for function we need this keyword
41:28 - basically called def
41:29 - and now we can give our function a name
41:32 - just like we gave name to our variable
41:34 - we can give our function a name
41:36 - and here we can use the same standards
41:39 - like for variable
41:40 - we can name the function something
41:42 - descriptive something that actually says
41:44 - what this function does and let's call
41:46 - our function days
41:48 - to units and then we have the brackets
41:52 - and a column so this line basically
41:55 - defines a function it tells python hey
41:58 - whatever
41:59 - comes after this is actually going to be
42:03 - a block of code that is going to be
42:06 - referred
42:06 - to or is going to be named these two
42:10 - units and how do you write a function
42:13 - i'm just going to copy this one actually
42:15 - here and let's give us some space
42:18 - and again this is very specific to
42:20 - python
42:21 - we need to indent here with spaces
42:25 - and i'm going to paste in what i copied
42:29 - inside these two lines basically tell
42:31 - python
42:33 - this piece of code or this line of code
42:36 - because we just have one line here
42:38 - belongs to a function called these two
42:42 - units
42:42 - and again we just have one line but this
42:45 - could be function with hundreds of lines
42:47 - right
42:48 - so i can write whatever i want the next
42:50 - line
42:52 - all good and then i can do some
42:55 - calculations and i can basically write
42:58 - whatever logic i want
43:00 - here and all these will belong to
43:03 - this function so now this
43:07 - logic is inside a function that is
43:10 - called
43:10 - these two units and we can actually get
43:13 - rid of this
43:15 - and test our function and here if you
43:18 - noticed
43:19 - we have this yellow line under the
43:21 - function name that's actually a warning
43:23 - for our code style
43:25 - it says we need two blank lines before
43:27 - so pycharm has a
43:29 - built-in official style guide for python
43:32 - that tells you how to style your code or
43:35 - how to write your code correctly
43:37 - now why is code style important well
43:40 - just like you write code you need to
43:42 - read code from other developers or
43:44 - your own code to understand what the
43:46 - code is actually doing
43:47 - so it's important that code is easily
43:50 - readable
43:52 - and this is just another example of how
43:54 - an editor like pycharm
43:56 - helps you to write code so to fix the
44:00 - warning
44:00 - we're just going to add a new blank line
44:03 - before the function definition
44:06 - so now what happens if i execute this
44:09 - block of code i have the variables
44:11 - defined here that i'm using in the
44:13 - function and then we have these two
44:16 - print statements
44:17 - so what happens if i execute now and as
44:20 - you see in the
44:21 - output here there is no output right
44:24 - nothing
44:25 - actually got printed so what actually
44:27 - happened because we have
44:29 - those two print statements that we
44:31 - defined in the function
44:33 - but we don't see anything in the output
44:35 - and the way it works is whenever you
44:37 - create a function or define a function
44:40 - like this
44:41 - you actually have to use that function
44:44 - right again this is a similar concept to
44:46 - variables we have
44:47 - created variables here and we're using
44:50 - that
44:50 - variable in our code the same way we
44:53 - create a function and we
44:55 - need to use that function how do we use
44:57 - a function
44:58 - or in programming languages it's called
45:01 - calling a function or executing a
45:03 - function
45:04 - and we do that using the name of the
45:07 - function
45:08 - like this and as you see in the
45:11 - suggestion as well
45:13 - using brackets like this so
45:16 - this syntax here basically is
45:20 - what we call calling the function that
45:22 - we defined right here or using that
45:24 - function
45:25 - so now if we execute it there you go you
45:28 - see
45:28 - that those two lines got executed and we
45:32 - have the results here
45:33 - so we're creating variables and we're
45:36 - using that here
45:37 - we're creating a function and we're
45:39 - using that function here
45:41 - and note the difference between using a
45:43 - variable and using a function
45:45 - python knows this is a function because
45:47 - we are providing these
45:49 - brackets at the end right that tells us
45:51 - we're making a function
45:53 - call basically
45:57 - but as you see now we have these 20 days
46:00 - so this
46:01 - only works for 20 days right what about
46:04 - other
46:05 - values that we had what about 35 days
46:07 - and 100
46:08 - days we haven't de-duplicated that right
46:11 - we have
46:12 - just one case here so how do we use
46:16 - functions so that everything else
46:20 - except for these two values right here
46:23 - actually stay the same and we do that in
46:26 - programming
46:27 - by giving our functions some kind of
46:30 - input value which are also called
46:33 - parameters
46:34 - so instead of having this 20 basically
46:37 - here hard coded as we said here
46:40 - and here we provide that value of 20 or
46:43 - 35 or whatever that value is
46:46 - basically whenever we use the function
46:48 - so we are
46:49 - telling python use these days to units
46:52 - function
46:53 - with a value of 20 or use that
46:56 - function with a value of 35 and way we
46:59 - define this
47:00 - input parameter in functions
47:03 - is very simply by defining this
47:07 - parameter
47:08 - between those brackets right so
47:11 - this is where the input we as
47:13 - programmers
47:14 - define the input parameters so right
47:17 - here
47:18 - how do we define that using our already
47:21 - familiar
47:22 - variables so basically right here i'm
47:25 - going to
47:25 - define a variable and i'm going to call
47:27 - it whatever i want
47:29 - i'm going to call it days or number of
47:32 - days
47:36 - but i'm not assigning a value to that
47:38 - variable right like
47:39 - i did here because i want it to be
47:41 - assigned
47:42 - whenever i use the function so this
47:45 - basically
47:46 - tells python that a function these two
47:49 - units
47:50 - can be used using one input parameter
47:54 - which is called num of dates right
47:56 - number of days
47:57 - so now the last part which is remaining
48:00 - is
48:01 - replacing these values using this
48:04 - variable right
48:05 - and just like we do it in these two
48:08 - places where we're
48:09 - also using variables defined here
48:12 - exactly the same way
48:13 - we're gonna remove this and
48:17 - define a block for non-textual value
48:20 - and we're gonna put our
48:23 - variable num updates here and
48:28 - also here so you see now that our
48:32 - function
48:33 - actually doesn't have any fixed numbers
48:35 - in it
48:36 - instead we're using variables we're
48:39 - using two variables that are defined
48:41 - outside that function and we're using
48:45 - one variable that is defined within that
48:47 - function right
48:48 - this variable actually belongs to that
48:51 - function
48:52 - and now as you see whenever we want to
48:55 - use
48:56 - that function we're telling python hey
48:59 - call this function called days to units
49:01 - with a parameter an input basically
49:05 - of 35. so now if we execute it
49:08 - by the way we can also do it here you
49:10 - see 35 days
49:11 - are and the calculation was done here
49:14 - and
49:15 - hours and now if we go back to
49:18 - our previous example where we wanted to
49:21 - calculate these for
49:22 - four different values right for
49:24 - different number of days
49:26 - we can actually do the same
49:29 - so we had 20 then we had
49:32 - 50 and we had 110
49:36 - right so this basically gives us exactly
49:39 - the same logic that we had previously
49:42 - but with different syntax right so you
49:45 - see the difference
49:47 - that instead of having this basically
49:50 - four times
49:51 - we have much cleaner syntax where we
49:54 - actually see what this logic is doing
49:58 - which is days to units and then
50:01 - we have the number of days that we pass
50:03 - or
50:04 - give our function as parameter and if i
50:07 - execute this you see that
50:10 - it was printed four times for all
50:12 - different values
50:14 - we can actually remove this line
50:17 - and now if we make some change in
50:20 - our function for example we change the
50:23 - name of this
50:25 - variable we want it to be hours instead
50:27 - of units
50:29 - we just do it once in one place
50:32 - and that's basically it so whatever
50:35 - changes we make
50:36 - inside that function and that is
50:38 - actually
50:39 - the big advantage of using functions in
50:41 - code
50:42 - whatever change we make inside here
50:45 - it doesn't affect how we use the
50:48 - function because
50:49 - for using the function we only need the
50:52 - name of that function
50:53 - and the input parameter now probably
50:56 - you're wondering
50:57 - what happens if i do not give my
51:00 - function a value
51:02 - let's delete those lines and let's say
51:04 - we do not provide any value here
51:07 - and we try to execute or
51:10 - call our function without the parameter
51:13 - and let's execute
51:15 - and you see that python interpreter is
51:18 - complaining because we have told python
51:22 - here is a function called these two
51:25 - units
51:25 - and whenever i want to use that or my
51:28 - colleague another programmer wants to
51:30 - use that function
51:31 - they have to provide an input value here
51:34 - right so now whenever python sees
51:38 - the usage of that function and there is
51:40 - no input
51:41 - parameter that we are giving that
51:42 - function it cannot
51:44 - execute that function right because
51:47 - basically this
51:48 - value is missing here right and that's
51:50 - why we get
51:51 - an error which also says missing one
51:54 - required
51:55 - argument so as you see whenever we
51:58 - define a function with a parameter
52:00 - with input parameter we have to also
52:03 - provide that input parameter
52:04 - another thing that you may be also
52:07 - wondering is
52:08 - what if i want to provide multiple input
52:11 - parameters to functions
52:13 - how do i do that it's actually very
52:15 - simple you can do that by
52:17 - simply defining here another input
52:19 - parameter
52:20 - separated by comma and let's say we want
52:24 - to pass
52:25 - here something that we want to print out
52:26 - additionally like a custom message
52:29 - doesn't really matter and the same way
52:33 - exactly the same way as the first one we
52:35 - can actually
52:36 - use it in here we can even create a new
52:39 - line
52:40 - and basically just print out that
52:42 - message right
52:44 - and note that if you are using a
52:46 - variable without
52:47 - stream so basically it's just the
52:49 - variable itself we're not using any text
52:52 - in that case you don't need this format
52:54 - right
52:55 - so you can basically just print it out
52:57 - directly
52:58 - and now again we have told python
53:02 - i have this function and two input
53:05 - parameters are required
53:07 - so i also need to pass to input
53:10 - values whenever i use that function so
53:14 - now let me just pass in some custom
53:17 - message
53:17 - let's say i'm happy about the
53:18 - calculation or i know i'm going to be
53:20 - happy so
53:21 - let's say awesome and
53:26 - let's do another calculation and this
53:28 - time
53:29 - i say looks good
53:32 - and if i execute it you see that i get
53:36 - awesome the first time and then for 35 i
53:38 - get
53:39 - looks good so you can basically define
53:43 - and provide as many
53:44 - input parameters as you want common
53:46 - practice
53:47 - and also what you will see in just
53:49 - normal code basically
53:51 - is just a handful of input parameters
53:54 - maybe one or two
53:56 - so it's not actually overloaded with 10
53:58 - parameters
54:03 - cool now that we know functions and
54:06 - variables
54:07 - why they're used or why are they useful
54:10 - and how we use them
54:11 - there is one point that i want to
54:14 - mention
54:14 - which is variable scopes in functions
54:18 - what does it mean as i mentioned
54:20 - previously in this function we're using
54:22 - multiple variables right we're using two
54:25 - variables
54:25 - that are part of the input right that
54:29 - we provide when using a function and
54:31 - we're using two variables that are
54:33 - defined outside the function right
54:35 - somewhere else in the code
54:37 - so variable scope basically means where
54:40 - is the variable that function uses
54:44 - defined and variable has a global scope
54:47 - for a function
54:48 - if it is defined outside the function
54:51 - like
54:52 - these two variables right here could be
54:54 - completely
54:55 - in a different file not even in the same
54:57 - file where the function is
54:59 - so these are global variables so all the
55:02 - functions that you have
55:04 - in your python code can use those global
55:06 - variables and then you have
55:08 - local variables local variables are
55:11 - variables that are
55:12 - created within that function right
55:15 - so these two variables are basically
55:18 - only
55:19 - available inside that function
55:22 - because it was created within that
55:25 - function
55:26 - so internal scope and global scope
55:29 - so that means that when we create
55:31 - another function
55:35 - let's call it scope check because that's
55:36 - what we're going to do
55:38 - we want to test the scope
55:43 - in this function i can access
55:47 - the global variables like
55:50 - name of units
55:53 - but i cannot access the internal
55:56 - variables
55:57 - like number of days and let's actually
56:01 - test that
56:05 - so i have num of units which is a global
56:08 - variable defined here
56:09 - outside the function and the second one
56:12 - i have a variable that is defined
56:13 - inside another function right
56:17 - so as i said internal and as you see
56:19 - right here
56:20 - we already get a red line underneath
56:23 - that says
56:24 - unresolved reference num of days
56:27 - so for this function basically that
56:30 - variable
56:31 - is not visible it's not accessible it
56:33 - doesn't exist basically at all
56:35 - and we can even test it out actually
56:40 - so again if we want to see the results
56:42 - we have to actually use that
56:44 - function like this run the function and
56:47 - if i execute it
56:48 - you see that we get an error that says
56:52 - name num of days is not defined right it
56:55 - doesn't know that there is a function
56:56 - like that
56:57 - anywhere in code however it does
57:00 - recognize
57:01 - the global variable and that means that
57:04 - variables defined outside function
57:06 - itself global variables are accessible
57:09 - to all the functions
57:10 - and if you have variables defined inside
57:14 - the function then they're only
57:16 - accessible for that specific function
57:18 - and not for other ones and that means
57:21 - actually that if
57:22 - num of days variable does not exist for
57:25 - scope check variable
57:26 - we can actually create a variable
57:29 - inside scope check with the same name
57:32 - and we would have basically
57:34 - no problem at all so this is not going
57:36 - to be a duplicate
57:38 - because this function doesn't know about
57:40 - this variable the number of days here
57:43 - and scope check doesn't know anything
57:45 - about variable
57:46 - num of days right here and if we
57:50 - want to use that function now we have to
57:52 - put provide the value
57:54 - let's do 20 and if i execute
57:58 - there you go you have name of units and
58:01 - the 20 that we provided so global
58:04 - variable
58:05 - local variable defined here another
58:08 - interesting thing is that
58:09 - as i said inside the function
58:12 - body so to say so this is basically
58:14 - whatever
58:15 - is part of the function right in this
58:18 - indentation
58:19 - is called function body so we can
58:22 - create whatever logic we want inside
58:25 - that function body
58:26 - so whatever i can do in python
58:29 - generally i can do inside the function
58:32 - body
58:33 - so one of those things is actually
58:35 - creating variables
58:36 - right just like we created variables
58:38 - here we can create variables
58:41 - here like this let's call it
58:44 - myvariable and
58:47 - variable inside function
58:51 - and we can print that out as well
58:56 - so now we have three types of variables
58:59 - that we are
59:00 - using in this function we have a global
59:03 - variable
59:04 - we have internal variable that is passed
59:07 - in as a parameter and we have internal
59:10 - variable again
59:11 - that is basically defined so the
59:14 - variable isn't
59:15 - provided when we use the function but
59:17 - it's basically just
59:18 - defined inside the variable and again if
59:22 - i
59:22 - execute this
59:27 - see hours num updates and variable
59:31 - inside function
59:32 - text printed out like this
59:36 - and obviously this is just for
59:38 - demonstration but we're going to see
59:39 - more realistic examples of that in our
59:42 - projects
59:43 - so i'm going to clean this up and
59:46 - we can move on to the next concept
59:52 - so now let's go back to the example
59:54 - where we calculate
59:56 - number of hours and we do that for four
59:59 - different values now if you want this
60:02 - application to be really useful
60:04 - for us or somebody else it doesn't help
60:06 - that we have to
60:07 - fixate here just four different values
60:10 - right
60:11 - the application should be able to take
60:13 - any value that we basically
60:15 - fit it right so we should be able to
60:18 - provide any number of days and the
60:20 - program should calculate
60:22 - the number of hours in those days so
60:25 - what we need here
60:26 - is user input so when we give this
60:29 - application
60:30 - program to somebody else or use it
60:33 - ourselves
60:33 - it should allow some user input so
60:36 - how do we write a program that asks for
60:40 - and accepts
60:41 - a user input and then does something
60:44 - some kind of
60:45 - calculation some kind of other logic
60:48 - based on that
60:49 - user input accepting a user input
60:52 - from a python application is actually
60:54 - pretty easy
60:55 - let's get rid of all of these lines
60:58 - first
60:59 - and we can do that by writing input
61:03 - and this will basically give a user a
61:06 - prompt
61:08 - to enter some input value now
61:11 - you probably already see from the syntax
61:14 - that this looks very much like
61:18 - using our days to units function
61:21 - right in this case with the parameter so
61:24 - input is
61:25 - actually a function that python provides
61:28 - us with
61:29 - so we didn't have to write this input
61:30 - function right we wrote the days to
61:32 - units function
61:34 - but input function is available in
61:36 - python
61:37 - so that we can use it whenever we want
61:40 - and this parenthesis here tells python
61:43 - we want to call
61:44 - an input function and we're calling it
61:47 - or using a function without a parameter
61:50 - so now we know that we can write
61:52 - functions
61:53 - ourselves for logic that we need
61:56 - but python has tons of functions
62:00 - that python developers already wrote and
62:02 - is
62:03 - part of python and we can use it in our
62:06 - code so that not everybody
62:07 - has to write their own input function
62:10 - logic
62:11 - and the code or the functions that
62:12 - python provides
62:14 - are again part of this python that we
62:17 - use in a project
62:19 - and obviously if you're using the latest
62:22 - version
62:22 - of python you will get the latest code
62:26 - and latest
62:26 - functions that python basically provides
62:31 - so back to our function execution
62:35 - and let's see what happens when we
62:38 - execute this program
62:40 - i'm going to run it and in the outputs
62:42 - you actually do not see anything
62:44 - other than my cursor is blinking here
62:48 - so it's actually waiting for user input
62:51 - so i can actually type in
62:53 - something here so i can do 20 and enter
62:57 - and process finished with exit code so i
62:59 - was able to
63:00 - input something doesn't really matter
63:05 - it could also be a string actually
63:08 - doesn't
63:08 - really matter and program basically
63:12 - finishes so that's the simplest usage of
63:16 - input however as you noticed here
63:19 - running this program and basically
63:21 - having this blank
63:23 - output here is a little bit confusing so
63:26 - if another user
63:27 - is using our program they will probably
63:30 - be wondering what's happening here
63:31 - so what we can do is in input function
63:35 - we can provide a parameter that actually
63:38 - tells a user something right like
63:41 - enter a value for number of days or
63:45 - something similar so that it's not just
63:47 - a
63:48 - blank prompt right so we can do that by
63:52 - passing in a parameter a string which is
63:55 - going to be our message
63:56 - so we can do a user
64:00 - enter a number of days
64:04 - and i will convert it to
64:07 - hours and here you see right now that
64:11 - the program wasn't finished because we
64:13 - didn't enter
64:14 - anything so this program finished line
64:18 - wasn't output yet and that means the
64:20 - program is still running
64:22 - it is still waiting for our input
64:25 - and in pycharm in this ide
64:28 - if you want to terminate the program
64:31 - manually yourself
64:32 - you can click this stop button
64:36 - and as you see process finished so
64:40 - now we can run the program again and as
64:43 - you see here we
64:44 - already have a message that we're
64:47 - displaying to the user
64:48 - so that they can enter the hours right
64:52 - and here we can provide our input
64:56 - 30 and there you go however
65:00 - this doesn't look nice here we actually
65:02 - want the user
65:04 - to get a prompt on the next line how do
65:07 - we do that
65:08 - as part of a string we can actually add
65:10 - a new line
65:11 - or newline character basically and
65:14 - that in programming is actually
65:16 - represented
65:18 - by backslash n and you see
65:21 - a special highlighting for that one now
65:23 - let's execute
65:24 - and you see that my cursor is on the
65:27 - next line now
65:28 - and again let's provide a value enter
65:32 - and program ended so we have
65:35 - now a more user-friendly way of asking
65:38 - program user for their input
65:40 - instead of just showing an empty prompt
65:43 - and we're getting user input
65:44 - now we're not doing anything with that
65:47 - user input right
65:48 - that input basically just finishes the
65:50 - program and that's it
65:52 - we're not doing any calculation for that
65:55 - input
65:55 - so how do we use the value that user
65:59 - enters here
66:00 - when input function gets executed we do
66:04 - that and this is a very important
66:06 - concept
66:06 - by assigning whatever result
66:10 - this function usage gives us which is
66:13 - in this case user input assigning that
66:17 - result to a variable so right now it's
66:19 - basically
66:20 - executed and it's just wasted right it
66:22 - just disappears
66:23 - so instead we want to save that value
66:25 - that entered
66:26 - input value in a variable so that we can
66:30 - access it later and we do that by
66:33 - let's call it user input variable
66:37 - equals so just like we created variables
66:40 - here
66:40 - with variable name and a value right or
66:44 - even an expression right if we did a
66:47 - calculation here that will be
66:48 - basically a whole expression whole
66:50 - calculation
66:51 - the same way we can use values
66:56 - that function execution gives
66:59 - us to assign it to a variable so now
67:01 - what i'm going to do
67:02 - is i'm just going to print the user
67:05 - input
67:06 - so that we can see what value that
67:09 - user input variable has so let's execute
67:13 - again
67:13 - it asks for our input let's put 20
67:17 - and print user input gives us 20.
67:20 - so user input variable value basically
67:23 - becomes
67:24 - whatever we provide as an input
67:30 - now that's a new concept and it could be
67:31 - a little bit confusing
67:33 - so let's see another example with our
67:35 - own function
67:36 - what would happen if we
67:40 - assigned value of this
67:44 - to a variable
67:47 - we get a warning as you see here in the
67:50 - editor
67:51 - which is one of the great things about
67:53 - ides that it basically gives you
67:55 - warnings when something is not correct
67:57 - and the warning says function doesn't
67:59 - return anything
68:01 - so basically if we want to have some
68:04 - value
68:05 - as a result of function execution we
68:07 - have to return
68:08 - some value in the function and how we do
68:11 - that
68:12 - instead of printing the value right away
68:15 - we can actually return that value
68:19 - using return keyword again you see
68:22 - special highlighting here just like here
68:24 - because return
68:25 - is a special word that python
68:28 - understands
68:29 - that you want to basically give back
68:32 - a value this value right here as a
68:35 - result
68:36 - of using the function right so you could
68:39 - have
68:40 - some logic here doing the calculation
68:43 - whatever
68:44 - and then as the last line you can return
68:48 - that calculated value and now
68:51 - the warning is gone because we're
68:53 - actually returning something
68:55 - from the function and when we return
68:58 - value from a function again we can
69:01 - assign it
69:02 - to a variable so that we can use that
69:04 - value whatever function
69:06 - returned by referencing the variable and
69:09 - one of the usages will be basically just
69:11 - to print it
69:12 - just like we did before like this let's
69:16 - delete it temporarily and
69:20 - test our program
69:23 - and there you go you see that this
69:25 - function
69:26 - got executed with input 20
69:29 - this text this display text basically
69:33 - was put together in the function and was
69:35 - returned or was given back
69:37 - as a result and we saved that
69:41 - this whole string basically this whole
69:43 - sentence in a variable called myvar
69:45 - and when we print that myvar we see that
69:48 - value
69:49 - printed out here and again if we enter
69:52 - some other value we would get different
69:55 - text
69:55 - and again that is actually a very
69:57 - important concept
69:59 - of giving back some results from a
70:02 - function execution and you saw in our
70:04 - examples that
70:05 - you can have a function that doesn't
70:06 - return a value just print something on
70:09 - maybe does something else
70:11 - or function that returns some value you
70:14 - can have
70:14 - both types
70:18 - so back to our example of
70:21 - user input so now hopefully it makes
70:24 - sense
70:25 - that input function returns
70:28 - whatever value the user entered as a
70:31 - result and we can
70:33 - save it in a variable and then access it
70:35 - later again let's
70:36 - get rid of this line and now let's
70:39 - actually do the calculation
70:41 - on the user input number of days how do
70:44 - we calculate number of days
70:46 - very simple by calling our function that
70:48 - actually
70:49 - does that so we're going to call our
70:52 - function
70:53 - to calculate the number of hours for
70:56 - an input and the parameter that we
70:59 - passed
70:59 - in is going to be whatever the user
71:02 - provided
71:02 - so instead of basically hard coding a
71:05 - value here
71:06 - ourselves we give it a value that user
71:09 - provided instead so the num of days will
71:12 - be
71:12 - the user input and now again because
71:15 - this function
71:16 - returns the whole string it doesn't
71:20 - print it
71:21 - remember it just returns it so when i
71:24 - execute this and i provide in
71:27 - some value that's to 200 you see that
71:30 - i don't have any output here because we
71:33 - didn't print anything we
71:34 - basically just returned the value here
71:37 - we didn't do
71:38 - anything with it so the last piece
71:40 - missing here is
71:41 - to display the text the string that
71:44 - function returns so we save that
71:47 - return value first let's do calculated
71:52 - value so we save this thing
71:56 - in calculated value variable and
71:59 - finally we can print it and now let's
72:02 - execute it and
72:04 - let's see what happens i'm going to type
72:06 - in
72:07 - 10 10 days and let's see what we get now
72:11 - and you see we have this weird value
72:14 - here
72:14 - as a result of the calculation so what
72:17 - exactly happened
72:18 - so this part of calculation basically
72:22 - which represents this number didn't do a
72:24 - proper calculation
72:25 - and the reason for that is because the
72:28 - input value that we get
72:29 - with inputs function is always
72:33 - treated as a string and not a number so
72:36 - basically
72:38 - at this place here number of days inputs
72:42 - 10 here is actually treated as a
72:45 - text and not a number and where this
72:48 - weird result comes from is basically
72:50 - number 10 printed out 24
72:54 - times so instead of doing the actual
72:56 - calculation 10 times 24
72:59 - 10 is printed 24 times and that's what
73:01 - happens when this is interpreted as
73:04 - a string so how do we make python
73:07 - see that number see that input value as
73:11 - a number as an integer and not a
73:14 - text or not as a string and it's
73:16 - actually pretty easy to do
73:18 - on the next line the user inputs again
73:21 - we saw
73:22 - right here it is a string so we have to
73:25 - make it into a number and we're going to
73:28 - do that
73:28 - using int and user input
73:33 - and that process of turning a value from
73:36 - one data type into another
73:38 - is called casting if you remember we
73:41 - already saw an example of it when we
73:42 - turned
73:43 - a number into a string in the string
73:47 - concatenation example
73:48 - again from the syntax you should already
73:50 - know that this is a function
73:52 - call so we're calling a function called
73:54 - int again
73:55 - that python itself provides us with
73:58 - because we didn't write that function
73:59 - and we're passing in
74:01 - one parameter which is a string and we
74:03 - should
74:04 - get an integer from that string as a
74:07 - result
74:08 - and we can save that number into a
74:10 - variable and let's call it user
74:12 - input number and
74:16 - now we have 10 as a number instead of as
74:19 - a string
74:19 - and instead of passing in that string
74:22 - user input we can
74:23 - now give our function number
74:26 - that it expects let's save it and
74:29 - execute
74:31 - let's put in 10 and there you go now the
74:34 - calculation
74:35 - is correct what i want to show you now
74:38 - is how this user input actually works
74:41 - without
74:42 - a code editor like pycharm so i'm gonna
74:46 - copy all this code and let's go back to
74:49 - our terminal
74:52 - and in our test dot pi
74:59 - i'm going to paste in our code
75:03 - and save and let's now actually
75:06 - see how the user input works when we
75:08 - execute it
75:09 - in a simple terminal window and as you
75:12 - see here we have the message first
75:15 - and the prompt is right here so we can
75:17 - enter a value
75:19 - let's do 25 enter
75:22 - and we have a result 25 days are
75:26 - 600 hours
75:30 - great so our program is working it is
75:33 - converting
75:34 - the number of days to number of hours
75:37 - and accepts a user input now what
75:40 - happens
75:41 - if a user enters an invalid value here
75:45 - so for example instead of a positive
75:48 - value for number of days
75:49 - maybe they enter a negative value like
75:52 - -10 for example and obviously
75:55 - that input value doesn't make any sense
75:58 - but we are still
75:59 - calculating and giving a value right and
76:02 - this is another
76:04 - important concept in programming
76:07 - generally
76:08 - that when we allow users to give our
76:11 - program
76:12 - some input value we also want to
76:14 - restrict them
76:16 - and basically validate that what they
76:19 - provided as input is a valid value for
76:22 - our program specifically
76:24 - one that it makes sense like in our case
76:28 - -10 program still does a calculation but
76:30 - it doesn't really make sense
76:32 - and second it doesn't crash our program
76:35 - right
76:36 - so now let's see what happens if we
76:38 - enter
76:39 - some text here you see
76:42 - that the calculation didn't happen
76:44 - because
76:45 - we basically crashed the program
76:48 - application
76:49 - using that invalid user input does make
76:52 - sense
76:53 - or an input that crashes our application
76:56 - because the calculation isn't even
76:58 - possible
76:59 - and we want to avoid users basically
77:02 - either providing a nonsense value or a
77:05 - value that will crash our application
77:07 - so we need to validate user input
77:11 - and this is again important concept in
77:13 - program because
77:14 - whenever you allow user input you always
77:17 - have to validate it so in this part
77:20 - we're going to learn
77:21 - concept called conditionals and we're
77:24 - going to learn this concept
77:25 - with an example of validating a user
77:28 - input so
77:30 - where are we going to do the user input
77:32 - validation we can do it
77:34 - in our function right before we
77:37 - actually do the calculation we can first
77:40 - validate
77:41 - is it a positive number and not a
77:44 - negative one
77:46 - so user gives us their input we
77:50 - convert it to a number and then we pass
77:52 - that number
77:53 - to our function so negative 10
77:57 - positive 10 that is a number basically
78:00 - will be
78:00 - passed on to our function and right here
78:03 - we can check whether this
78:07 - variable value here is a negative number
78:09 - or not
78:11 - how do we do that we do that using
78:14 - if else conditional statements so
78:18 - very simple and intuitive to understand
78:21 - we say if number of days
78:24 - is greater than 0
78:29 - means it is a positive number
78:32 - then we want to do the calculation and
78:35 - return
78:35 - all of this but you see that we have a
78:38 - red line here
78:39 - so basically whenever we use if
78:42 - condition we have to have a proper
78:44 - indentation so all of this line
78:46 - basically goes
78:48 - indented for this line kind of the same
78:51 - way as we indented
78:53 - the whole function body inside the
78:56 - function
78:57 - whatever logic and whatever code is
79:00 - right here
79:00 - indented below the if condition
79:03 - will be executed if number of days
79:07 - is really greater than zero so let's try
79:10 - that again
79:11 - i'm going to execute it let's put a
79:14 - positive 10
79:16 - you see 10 days are 240 hours
79:19 - got calculated now let's put
79:22 - -10 as an input and you see none
79:25 - basically no output for us because
79:29 - this line didn't actually get executed
79:32 - for -10 input value now what if we want
79:35 - to tell a user
79:37 - hey this was an invalid value and that's
79:39 - why we didn't do the calculation
79:41 - instead of just showing none we can do
79:45 - that
79:45 - by returning this feedback message or
79:48 - error message
79:49 - whenever this is not true so whenever
79:52 - number of days is not
79:54 - greater than zero we want to return
79:57 - something else right another message
79:59 - and we can do that using else
80:04 - and the same way as for if we have the
80:07 - indentation
80:08 - and whatever we write here will be
80:10 - executed if number of days is not
80:12 - greater than zero
80:14 - so here we are gonna return
80:17 - you entered a negative
80:21 - value so no
80:24 - conversion for you
80:28 - and here it's time for another special
80:30 - term in programming that greater than
80:32 - sign
80:33 - is called a comparison operator and we
80:36 - have three of them we have greater than
80:38 - less than and equals and these are
80:40 - called comparison operators because
80:42 - they are used in an operation to compare
80:45 - two values
80:47 - and before in this course we learned
80:49 - arithmetic operations
80:51 - like plus minus divide multiply so again
80:54 - fancy words for
80:56 - simple concepts but these are the
80:58 - official terms for these
80:59 - so now if someone mentions them you will
81:02 - know what they're talking about
81:04 - so now let's execute the application
81:07 - and let's provide -10 and you see that
81:11 - this line was printed
81:14 - as a feedback to the user
81:18 - so let's go through the flow again user
81:20 - gives us their input
81:22 - in this case -10 we convert it to
81:25 - integer
81:25 - so now it's -10 integer and we pass it
81:29 - on to our days to units
81:31 - function and these two units function
81:34 - basically has this if else statement
81:38 - that's how it's called in programming
81:40 - and our if else
81:42 - statement validates or checks
81:45 - whether this input is greater than zero
81:50 - if it is then the function will return
81:54 - this as a result so basically the
81:56 - calculation with a proper message
81:58 - else so basically if this is not
82:01 - the case then it will return basically
82:05 - just
82:05 - a feedback message for the user and note
82:08 - that
82:08 - else doesn't have such a check here we
82:11 - don't check
82:12 - num of days is less than zero and the
82:16 - reason for that
82:16 - is because it doesn't check for less
82:19 - than zero
82:20 - because it basically just decides if
82:22 - this is not true
82:23 - else or in that case just do this
82:26 - so we don't need additional check here
82:29 - now this segment right here
82:31 - where we're doing the check is called a
82:34 - conditional
82:35 - so basically we're providing our program
82:37 - a condition
82:38 - if this condition is correct
82:41 - then do something otherwise do something
82:45 - else
82:45 - and that conditional can be true
82:49 - or false if we enter 10 then this
82:52 - conditional will be true
82:53 - because it's greater than 0 if we enter
82:56 - -10 then this conditional will be
82:58 - negative it's not greater than 0
83:02 - and those true and false values in
83:05 - programming
83:06 - actually are represented by its own data
83:08 - type which is called
83:10 - boolean and in order to show it to you
83:13 - that this conditional either gives true
83:16 - or false
83:17 - what i'm going to do is i'm going to
83:19 - print
83:21 - this conditional right before i do the
83:24 - check
83:24 - so for a positive number input this
83:27 - should print
83:28 - true and if it's negative so it's not
83:32 - greater than 0 this should print false
83:35 - so let's test it out
83:38 - first i'm going to provide positive 10
83:42 - and right here you see true
83:46 - because this condition is indeed true
83:49 - and note that this is not a string
83:51 - that's why we don't need the quotes here
83:54 - so we can basically just put in the
83:55 - whole expression in a print
83:58 - function and now let's do the same with
84:01 - negative 10 and you see
84:05 - false and as i said true and false
84:09 - values belong to its own data type in
84:11 - programming
84:13 - which is called a boolean and again we
84:15 - can demonstrate that
84:17 - instead of printing it out
84:21 - we can save it into a variable let's
84:24 - call it
84:24 - conditional check
84:28 - and in python there is a function called
84:31 - type which checks or prints out
84:34 - basically
84:35 - a type data type of a variable or
84:38 - a single value so if we
84:41 - pass it so this will give us data type
84:45 - of conditional check
84:46 - and obviously if you want to see that
84:48 - result we need to print it
84:50 - so print the whole thing so it doesn't
84:53 - matter what we pass in
84:55 - this point and right here you see
84:58 - class boolean so this
85:01 - conditional check here which has a value
85:04 - of
85:05 - true or false is of type boolean
85:09 - now there are two things that i want to
85:11 - note here
85:12 - the first one is that you see that
85:15 - i am calling a function here which is
85:18 - type
85:19 - and then whatever that function type
85:22 - returns
85:23 - which is basically this output here we
85:26 - are printing it
85:27 - so we have two function calls that are
85:30 - basically
85:30 - nested and that is absolutely fine you
85:33 - can nest
85:34 - function calls another example of doing
85:37 - this
85:37 - nested function called would be for
85:39 - example right here
85:41 - instead of assigning these to a variable
85:44 - and then passing it here
85:45 - we can actually save us that step
85:48 - and in the days to units function call
85:52 - pass it as a value so this is a
85:55 - perfectly
85:56 - valid syntax and you can do that you can
86:00 - nest in the function calls and you would
86:02 - not need this additional step
86:04 - and you can do that as many times as you
86:06 - want it just looks cleaner when you have
86:09 - that syntax a little bit separated and
86:11 - not have two three
86:13 - four function calls nested so that's one
86:15 - thing
86:16 - and another thing is we just saw a class
86:19 - boolean type here
86:21 - and let's actually see the same output
86:24 - for
86:24 - string and number so just for the
86:27 - demonstration let's actually
86:29 - see the type of string and integer
86:36 - let's get rid of this for a second
86:38 - because we just want to test
86:40 - so we're going to print the type of
86:44 - a string which says this should be a
86:47 - string
86:48 - type and execute
86:52 - and you see class string and
86:55 - now let's provide an integer
86:59 - you see class int and let's provide
87:04 - a float and there you go we have float
87:08 - so this is a very handy way of checking
87:11 - the type and we're going to need that
87:12 - actually in a later example
87:16 - so back to our
87:20 - application and one note about booleans
87:23 - and conditionals
87:24 - is that you're going to be using a lot
87:27 - of those
87:28 - in programming because they're really
87:31 - the major or the core part of writing
87:34 - any kind of logic in programming so
87:37 - you're going to need
87:38 - if else conditions and statements and
87:41 - booleans
87:42 - in your application so it is a very core
87:45 - concept and we're going to be using a
87:46 - lot of them
87:47 - in our coming examples so let's get rid
87:50 - of
87:50 - this code right here and one note before
87:53 - we move on
87:54 - here is that the negative numbers are
87:57 - not
87:58 - being calculated because of this
88:00 - condition
88:01 - now what about zero let's actually try
88:04 - that out
88:05 - so i'm gonna enter zero which is
88:08 - actually
88:09 - also valued that doesn't make sense
88:11 - because
88:13 - zero days input obviously will give zero
88:15 - of any units
88:17 - so enter and
88:20 - right here you see a feedback to user
88:23 - that says you entered a negative value
88:25 - so no conversion for you
88:27 - and the reason for that is because this
88:30 - condition here number of days checks
88:33 - greater than zero
88:34 - which means that negative numbers and
88:37 - zero
88:37 - will not match this condition so they
88:40 - will
88:41 - basically give you this feedback but our
88:43 - message says you entered a negative
88:45 - value
88:45 - right when we entered zero what if we
88:48 - wanted to
88:49 - have a specific message for a user if
88:52 - they enter
88:53 - zero and a specific one if they enter
88:56 - negative value
88:57 - right we want to differentiate between
88:58 - those two how can we do that
89:01 - in the if else statement in programming
89:04 - we can have multiple conditionals so
89:08 - basically we can have multiple ifs so
89:11 - how do we do that first we check number
89:13 - of days is greater than zero
89:15 - okay great now we want to check whether
89:17 - number of days
89:18 - is equal to zero and we can do that
89:22 - using another if here and in python
89:26 - the syntax for that is el if
89:29 - which basically is a combination of else
89:32 - and
89:32 - if so if this is not true
89:36 - then we want to check another condition
89:40 - number of days equals 0.
89:43 - now you know the equation sign generally
89:46 - is this one right here
89:49 - however when we're checking whether
89:52 - something
89:53 - equals to something else in programming
89:56 - that
89:57 - equation check is represented with two
90:00 - equal signs and the reason is because
90:02 - one equal sign is already
90:04 - used to represent assigning a value to a
90:08 - variable
90:09 - so not to confuse those two actions
90:12 - in programming we have two equation
90:14 - signs
90:15 - when we want to check whether something
90:16 - equals a certain value
90:19 - and just like here we
90:22 - execute some logic whenever this
90:26 - condition is
90:27 - true so in our case we want to
90:30 - tell the user you entered
90:34 - a zero please enter
90:37 - a valid positive number
90:41 - so now again to go through this logic
90:44 - flow if the input value is
90:48 - a positive number then function will
90:50 - return
90:51 - the calculation and the message if it's
90:54 - not a positive number then we will check
90:56 - additionally
90:57 - whether it's zero if it's not zero
91:00 - then this is a last condition basically
91:03 - then we know that it has to be a
91:05 - negative number right
91:07 - so let's test this out
91:10 - let's enter a positive number there you
91:13 - go
91:14 - let's enter zero you entered
91:17 - zero please enter a valley positive
91:19 - number and
91:21 - let's enter negative one and everything
91:24 - works
91:25 - perfectly note that you can have
91:26 - multiple alif's
91:28 - between if and else statements and again
91:31 - note that el
91:32 - if has a condition just like if
91:34 - statement
91:35 - else does not have any condition so this
91:38 - is like the fallback so if
91:39 - everything previously stated all the
91:43 - previous conditions did not
91:44 - match so they were all false basically
91:47 - then
91:48 - this is the logic that will get executed
91:51 - in that case
91:55 - great so we have validated input value
91:58 - for
91:58 - users and we may feel pretty good about
92:01 - our
92:01 - program because it doesn't calculate
92:04 - anything for values that don't make any
92:07 - sense
92:08 - however we still have a problem what
92:11 - happens if
92:12 - a user enters a text instead of a number
92:15 - so basically anything that is not
92:17 - a number value doesn't really matter
92:21 - basically some text if i enter
92:24 - you see that our program actually
92:26 - crashed and this is
92:27 - actually a user input that we want to
92:30 - protect our programs from
92:32 - because we don't want to allow users to
92:35 - blow up our application right so let's
92:38 - see what happened
92:39 - it actually says that we provided an
92:42 - invalid
92:42 - literal literal basically means the text
92:46 - itself or
92:46 - a number so basically a value that we
92:49 - entered
92:50 - for int function that's the problem
92:53 - so this function call basically just
92:56 - blew up
92:57 - because in function expects a value
93:00 - which is a string representation of a
93:03 - number
93:04 - so basically ind expects something like
93:06 - this or something like
93:08 - this it doesn't expect
93:11 - my text or some text so our application
93:14 - crashed on some text input now let's see
93:17 - what happens
93:18 - if i provide a number
93:22 - but a float number instead of integer
93:25 - let's enter 19.99
93:30 - and enter and you see the same error
93:33 - this function basically returns an error
93:35 - because it cannot
93:37 - convert float into integer as well
93:40 - so we have a problem here that whenever
93:42 - user enters
93:43 - anything which is not an integer our
93:46 - program
93:46 - will blow up so how do we avoid
93:50 - that so basically before the int
93:52 - function gets executed with an
93:54 - invalid value we need to validate this
93:58 - whole thing and
93:58 - stop our program before that happens so
94:01 - we need the validation before int gets
94:03 - executed and we can do that right here
94:06 - right
94:07 - so before that line gets executed we're
94:10 - gonna do a validation
94:12 - and one way we can do that is using our
94:15 - familiar if else statement
94:18 - so we can say if user input
94:22 - is digit
94:26 - so again from the syntax you know this
94:28 - is calling a function
94:30 - but note that instead of calling the
94:32 - function
94:33 - like this so basically just stand alone
94:37 - we have the syntax where we have the
94:39 - variable
94:40 - dot and then the function name so
94:42 - instead of passing this
94:44 - as a parameter right here in the
94:46 - function
94:47 - brackets we are passing it as a
94:49 - parameter again
94:51 - but using this syntax right so each
94:54 - digit function will execute
94:56 - for user input as a parameter
94:59 - and again in if we have conditions so
95:02 - this will be either true or false
95:04 - it's a boolean and
95:07 - if user input is digit it's a number
95:10 - basically so basically this will filter
95:13 - out
95:15 - input values that are text so basically
95:17 - they're not
95:18 - numbers and if the input is digit
95:22 - then we want to execute this line
95:26 - and also the rest of our application
95:30 - like this and if it's not true
95:33 - so if the user input is not a digit we
95:36 - don't want to execute
95:38 - anything in our application we want to
95:39 - stop the execution and want to tell the
95:42 - user
95:42 - this was an invalid input value i'm not
95:46 - doing anything
95:46 - with my program so that it doesn't crash
95:49 - so
95:49 - else if not digit we
95:52 - are telling the user your input
95:56 - is not a number
96:00 - don't ruin my program
96:03 - so now let's actually test it
96:07 - so i'm going to execute and write some
96:10 - text
96:13 - and there you go so user input is digit
96:16 - was
96:16 - evaluated to false so
96:19 - none of these got executed instead the
96:22 - else
96:23 - block was executed and it printed a
96:26 - message
96:26 - for our user so we basically avoided our
96:29 - application to crash
96:30 - with this check and
96:34 - if we try a proper number
96:37 - it works and if we enter
96:40 - 0 for example the application
96:44 - will get executed and we will get
96:47 - our message from here
96:50 - so our application is more or less
96:53 - protected
96:54 - and we're not allowing for a invalid
96:58 - input number you say not a valid
97:01 - number now we know that in programming
97:03 - there are different types of numbers
97:05 - we have float numbers as well so
97:08 - let's actually see what ease digit
97:12 - function
97:13 - really checks so let's actually try
97:16 - to provide a float number instead of
97:19 - integer which is not a proper valid
97:22 - input for our program so i'm going to
97:24 - type in 19.99
97:27 - and you see that each digit
97:30 - is false for a float number so we got
97:33 - the same
97:34 - your input is not a valid number output
97:37 - for float number as well which is
97:39 - perfect it's exactly what we need
97:41 - and now let's actually try
97:44 - to enter a negative number and let's see
97:47 - if each digit function
97:49 - returns true or false i'm going to enter
97:52 - and you see that else block got executed
97:56 - because
97:57 - is digit was false for a negative number
98:00 - so basically this function
98:02 - filters out a lot of the bad input
98:05 - for us to protect our application
98:08 - from bad user input and that also means
98:11 - that
98:12 - we don't need a check for negative
98:14 - values anymore and
98:16 - by the way in python you can actually
98:19 - have
98:19 - if statement without an else
98:22 - at the end this will work perfectly fine
98:29 - and this could be our application
98:34 - however note that in programming we
98:36 - don't put this type of
98:38 - logic directly like this
98:41 - basically outside a function as a common
98:44 - and best practice we
98:46 - encapsulate most of the logic basically
98:49 - in functions
98:50 - so as a cleanup for our code
98:54 - we can take all this and put it into
98:58 - a function so right here i'm going to
99:01 - create
99:01 - a function and let's call it
99:05 - validate and execute
99:09 - or something like this
99:13 - and all the logic that i copied
99:17 - will be just simply pasted in that
99:20 - function like this
99:22 - so now we have the logic nicely
99:24 - encapsulated in its own function
99:27 - but as you know when we create a
99:29 - function we have to call that function
99:31 - otherwise nothing happens
99:33 - so we're gonna call it right here
99:36 - we don't have parameters and we don't
99:38 - have to provide a user
99:40 - input because user input is a global
99:42 - variable
99:43 - so our function has access to it let's
99:47 - actually test it out
99:50 - and it works and let's provide some bad
99:54 - input
99:58 - and it works too so that's actually a
100:01 - proper way of writing code
100:03 - having every piece of logic in its own
100:06 - function
100:06 - with a proper description for the
100:08 - function
100:12 - now as a next step i want to show you
100:15 - also a concept or something that you
100:17 - will encounter
100:17 - very often in code which is nested
100:21 - if else statements and i'm going to show
100:24 - that example by
100:25 - cleaning up our program a little bit
100:29 - so as you see here we're doing
100:31 - validation in two different places
100:33 - so we're validating user input here but
100:36 - also
100:37 - inside these two units function itself
100:41 - so what we can do is we can put all the
100:43 - validation in one place
100:45 - in this validate and execute function
100:47 - and basically
100:48 - have all the validate logic in here
100:52 - and let the days to units function just
100:55 - do the
100:56 - calculation and not the validation and
100:58 - this way
100:59 - our functions and code will be a little
101:01 - bit
101:02 - cleaner and more logically built
101:06 - so after we validate that user input is
101:09 - digit we convert it into an integer
101:13 - so right here we have an integer value
101:16 - of the user input
101:17 - so we can actually check whether that
101:19 - integer value is
101:20 - greater than zero or equal to zero and
101:23 - we can do that
101:24 - right here without passing it on to the
101:27 - days to units
101:28 - function and just like this if
101:31 - conditional
101:32 - we're gonna do user input number
101:35 - greater than zero if that's the case
101:39 - we want the calculation to happen so
101:42 - both of these lines will get executed
101:44 - only if user input number is greater
101:46 - than zero
101:47 - and else in our case if it's
101:50 - exactly zero we want to print a message
101:54 - to user you entered zero and remember
101:56 - we've got the negative numbers already
101:58 - covered using
102:00 - this condition here so that's the one
102:03 - remaining
102:03 - i'm just going to copy that and paste it
102:06 - right here
102:07 - variable is called user input number so
102:10 - we'll fix that
102:11 - and we're going to print out that
102:14 - message
102:17 - so that means we don't need any
102:20 - validation
102:21 - right here we can
102:26 - simply do the calculation
102:30 - so to go through this logical flow of if
102:33 - else or nested e-files
102:36 - statements we have the first if right
102:38 - here
102:39 - also note that indentations for
102:42 - these if else so basically they are on
102:45 - the same
102:46 - line here same position and
102:49 - the nested if else or in our case alif
102:53 - they're also in the same position so
102:55 - again first
102:56 - that's the big validation the first one
102:58 - is
102:59 - is the user input digit in the first
103:02 - place if not
103:03 - we basically shut down the program we
103:06 - print out a message to the user and
103:08 - that's it
103:10 - if it is a digit then we need additional
103:13 - validation is that digit a positive
103:16 - number
103:17 - or is it a zero so we do that additional
103:20 - validation using a nested ifall
103:22 - statement
103:23 - and basically this line gets executed
103:26 - only if it is a valid number and if it's
103:29 - a positive number and because of that
103:32 - we don't need any additional validation
103:35 - once the
103:36 - these two units function gets cold
103:40 - and you probably already think and
103:42 - notice that nested
103:43 - if else statements are not the most
103:46 - beautiful thing in the world they are
103:48 - pretty
103:48 - ugly actually and especially we have
103:50 - multiple of them or
103:52 - multiple else ifs in between
103:55 - the function may actually end up looking
103:57 - pretty bad
103:58 - so it's not recommended to have multiple
104:01 - levels of these
104:02 - nested if else statements in your code
104:05 - to basically just keep it clean but as i
104:08 - said
104:09 - you will encounter it a lot in programs
104:12 - in application code
104:14 - because sometimes you just have to write
104:16 - it like this
104:20 - thing i want to show you here is
104:22 - something called
104:23 - a try accept in python so right here as
104:27 - you see we're validating
104:28 - user input right and then we're
104:30 - executing this part of code
104:33 - only if that condition is true
104:36 - what if we had logic here where
104:39 - there were multiple places where
104:43 - something could go wrong let's say a
104:45 - function
104:46 - execution could basically just blow up
104:49 - because of
104:50 - a wrong input or even
104:53 - as an example maybe this is digit
104:56 - doesn't actually cover all the use cases
104:59 - so maybe there is a value that user can
105:01 - input that will still
105:03 - blow up our program so instead of
105:05 - checking each such possible scenario
105:08 - using if statements and then doing the
105:10 - actual calculation once
105:12 - all those things have been validated
105:15 - what we can do instead
105:17 - is basically tell python
105:20 - something like try
105:23 - executing this part of code here
105:27 - and if something goes wrong so if any
105:30 - line any function call or any logic
105:33 - execution
105:34 - fails we want to catch that error and we
105:37 - want to control what happens
105:39 - with that error ourselves
105:42 - programmatically
105:43 - and then catch logic will be
105:46 - accept and we're going to specify
105:50 - what type of value we want to catch
105:53 - basically using this block
105:57 - and the name of that error type is
106:00 - actually what we saw in the output when
106:03 - we provided
106:04 - some text and a float which
106:07 - is value error
106:10 - so that's the error that we want to
106:12 - catch basically so
106:14 - again we tell python you know what try
106:17 - to
106:17 - execute this block of code here
106:20 - and if one of those lines in that code
106:24 - results into a value error then instead
106:27 - of just
106:28 - crashing the program basically catch
106:30 - that error
106:31 - and print out a friendly message to a
106:34 - user
106:35 - so let's actually try this out
106:38 - and note that try doesn't have any
106:40 - validation
106:41 - like if statement so
106:45 - when i entered some text here
106:49 - int function will actually be called
106:51 - with some text
106:52 - and it will result in a value error and
106:55 - this block will then handle that error
106:58 - so i'm going to enter and and you see
107:02 - that
107:02 - your input is not a valid number message
107:06 - got printed and the same will work
107:09 - for a float number
107:12 - that also doesn't convert to integer and
107:15 - for a proper integer value
107:20 - it will work fine and
107:23 - again difference between if else
107:25 - statement and using try except
107:27 - is that you can cover multiple such
107:30 - errors
107:31 - with this whole try except block right
107:34 - so you don't have to do the validation
107:37 - specifically and that is especially
107:40 - useful for cases where you can't
107:42 - really validate something using if
107:45 - condition right if there is a chance
107:48 - that you might miss
107:49 - something in that condition check so
107:51 - basically you just say you know what
107:53 - just try to execute with whatever value
107:56 - and
107:57 - if error happens then i still got it
108:00 - covered
108:00 - and an obvious difference between this
108:03 - if else
108:04 - is that here nothing actually crashes
108:06 - the program the program will still work
108:08 - is just
108:09 - a nonsense value with zero days right
108:12 - and as you see here we have specified
108:15 - an error type but with try
108:18 - except what can also do is you can
108:20 - basically say you know what
108:21 - i want to cover any type of air i don't
108:24 - care if it's
108:25 - value air or some other type of air let
108:28 - me
108:28 - handle any type of air in this case you
108:31 - can basically just leave it without a
108:33 - specific type
108:34 - you get a warning though that it's too
108:36 - general
108:37 - however this would work and you will be
108:40 - covering all the air cases with it
108:42 - but we can go back to our value error
108:44 - and know that in many programming
108:46 - languages this is actually called a try
108:48 - catch so accept is actually pretty
108:51 - specific
108:52 - for python i personally think try catch
108:54 - makes more sense because you are
108:55 - catching
108:56 - any error that may happen right here and
108:59 - then basically
109:01 - handling it in the catch block so if you
109:04 - happen to hear or see
109:05 - try catch in other programming languages
109:07 - note that
109:08 - this is the same thing as try except in
109:10 - python
109:11 - one thing that we're missing because we
109:13 - converted that if statement
109:14 - into try except is now we need to
109:18 - validate the negative numbers again
109:20 - because negative numbers will not cause
109:22 - an error
109:23 - in our application so they're not
109:25 - covered by this
109:26 - except block here so let's add back
109:30 - our previous else block
109:34 - and again if neither of these
109:38 - are true it means automatically would
109:41 - mean that it is a negative number
109:44 - so let's
109:47 - print that message for a user enter
109:50 - negative number
109:55 - no conversion for you
110:01 - so now we got all the cases covered
110:04 - again
110:05 - so let's try that out -10
110:09 - and there you go
110:13 - now there is one minor problem with our
110:16 - application
110:17 - and that is we can only use it once
110:21 - so basically whenever we type in a value
110:24 - it either calculates it or gives us
110:28 - a message that we provided an invalid
110:30 - value
110:31 - then the program basically exits so if
110:34 - we want to do a calculation
110:35 - for another value then we have to
110:37 - restart the application
110:39 - provided value and then do the same
110:42 - so that's not very convenient if we want
110:45 - to use that program to
110:47 - basically calculate a number of hours
110:50 - for many different values so basically
110:52 - we want to
110:53 - keep fitting it some different values
110:56 - for calculation
110:57 - because we don't want to restart the
110:59 - application over and over again
111:01 - so how can we actually make the program
111:04 - continue after it's calculated the first
111:08 - value
111:09 - so we want the program to basically just
111:11 - keep running and
111:12 - accepting our values so how do we do
111:16 - that
111:16 - and we can implement the logic using
111:19 - something called
111:20 - while loop concept of loops in
111:23 - programming
111:24 - is basically you do the same thing
111:28 - so the same logic gets executed
111:31 - multiple times in a loop and how many
111:35 - times
111:36 - that logic gets executed is basically
111:38 - defined
111:39 - in the condition of that loop and the
111:42 - condition could be
111:43 - it should run 10 times or condition
111:45 - could also be
111:46 - it should run until some specific
111:50 - event happens in the application and
111:53 - conditions you already know from if else
111:56 - statement
111:57 - conditions are basically logic that
112:00 - gives you either true
112:02 - or false so condition is checking some
112:04 - logic and then
112:05 - giving you a result which is either true
112:08 - or false
112:09 - so now the question is how many times do
112:11 - we want this application to run
112:13 - in our case let's say we want to run
112:16 - indefinitely
112:16 - right until we actually stop it from
112:19 - here until we kill the program
112:21 - so it means the condition for that
112:24 - should
112:24 - always be true and for our application
112:29 - we're going to use a while loop which is
112:31 - one
112:32 - type of a loop and very simple syntax
112:36 - while and while just like if actually
112:40 - takes
112:40 - a condition this is going to be the
112:42 - condition for the loop
112:44 - so basically we want to tell the while
112:46 - loop how many times
112:48 - it should run the logic coming after it
112:51 - and again you know our familiar
112:54 - indentation
112:55 - these two lines should execute in a loop
112:58 - over and over again with some condition
113:01 - right here so how many times do we want
113:04 - the program to execute
113:06 - in our specific case well we want the
113:09 - program to
113:10 - run indefinitely until we actually stop
113:14 - it from here
113:14 - right from our editor so
113:18 - that means that condition of the loop
113:21 - that decides whether the next lines
113:24 - should get executed or not in our case
113:27 - should always be
113:28 - true because if it's false then
113:32 - the loop will stop right no execution
113:35 - anymore
113:36 - so how can we make sure it's always true
113:38 - we just write
113:40 - true right here and you remember i told
113:43 - you that true and false in
113:45 - programming languages have their own
113:47 - data types well they are also reserved
113:50 - words
113:50 - even though this is just text
113:52 - representation basically you see the
113:54 - highlighting here
113:55 - just like for these other words because
113:57 - python knows
113:58 - this is a boolean value of
114:02 - true and note that again specifically
114:05 - for python we actually
114:07 - write true with capital t
114:10 - unlike in other programming languages so
114:13 - this
114:13 - will basically be just a string
114:16 - so python doesn't know what to do with
114:18 - it but it recognizes
114:20 - true width capital t so we're telling
114:24 - our loop
114:26 - our while loop the condition is always
114:28 - true
114:29 - so basically run these two lines
114:31 - indefinitely because the condition
114:33 - will never change it's always going to
114:34 - be true and
114:36 - the syntax is probably already familiar
114:39 - to you
114:39 - we have the keyword just like if
114:42 - or try we can actually compare the
114:45 - syntax to the if statement
114:46 - so we have the while keyword here
114:50 - then we have the condition so this is
114:52 - the same type of condition
114:54 - as this one right here it's just that
114:56 - with us
114:57 - is basically fixed true value
115:00 - here it could be true or it could be
115:02 - false based on the condition
115:04 - and then we have the colon and then we
115:06 - have the indentation
115:07 - for the next lines so all of these
115:10 - belong to
115:10 - the while loop so that's basically it
115:14 - we can now execute the application and
115:17 - see that our program runs indefinitely
115:19 - so this is the first one
115:21 - let's say we enter 10 awesome we have a
115:24 - result
115:24 - and then we have again the next
115:28 - execution where it's asking for our
115:30 - input again
115:32 - and we can do -10 now it's telling us we
115:36 - provide a negative value
115:37 - but we can enter the value again let's
115:40 - enter some
115:41 - invalid value that should be
115:44 - handled by this value error block
115:47 - execute
115:48 - it's not a valid number and application
115:51 - basically continues so again as you see
115:54 - if you
115:55 - have an application that should continue
115:57 - running and basically get user input
115:59 - over and over again
116:00 - you don't want that application to be
116:02 - crashed at some point by some
116:05 - bad input you want to catch and handle
116:08 - every type of input so that your
116:11 - application
116:12 - continues to run and if we want to stop
116:15 - it
116:16 - we can basically just shut it off here
116:19 - and process finished
116:24 - now we can do one optimization in our
116:27 - program
116:28 - and this would be to allow users
116:31 - themselves
116:32 - to stop the application using
116:36 - some specific input value so for example
116:40 - when they type in exit for example the
116:43 - application
116:44 - should stop only for that specific
116:48 - word so it shouldn't run anymore so how
116:51 - can we do that
116:52 - so basically instead of having a
116:54 - condition that is
116:55 - always true we want a condition that
116:58 - says
116:58 - if the user did not input
117:02 - word exit then continue running the
117:05 - program
117:06 - if user entered exit then basically just
117:09 - stop it right so we need to change our
117:12 - condition right here
117:13 - so here we want user input is not
117:16 - exit right so user input
117:20 - is not exit now we didn't learn
117:24 - how to check for not equals
117:28 - something right we have check for
117:30 - equality so we check whether
117:33 - input number equals zero or if it's
117:35 - greater than
117:36 - or smaller than however we didn't learn
117:39 - how to check for
117:41 - not equals not equals in programming and
117:44 - this is not specific for
117:45 - python is expressed like this
117:49 - so instead of two equation
117:52 - signs we have an exclamation mark and
117:55 - equals
117:55 - and if we want to compare it to a string
117:59 - obviously
118:00 - we type that string in our case it's
118:04 - exit so basically this condition
118:07 - tells our while loop while
118:11 - user input is not exit
118:14 - continue running the program so while
118:17 - this is true
118:18 - basically just keep moving on but if
118:20 - user enters
118:21 - exit this will not be true anymore it
118:23 - will be false
118:24 - so loop will basically break and
118:27 - application will
118:28 - end now you see that we have a warning
118:31 - on this user input
118:32 - that we're using here and if i hover
118:35 - over it you see a message that says
118:37 - name user input can be undefined
118:41 - so it's not always undefined but it can
118:43 - be and here i want to mention again
118:45 - that pycharm because it's an intelligent
118:49 - editor
118:50 - can give you actually this warning when
118:52 - otherwise
118:53 - in a simple or normal code editor
118:56 - you probably wouldn't get such a warning
118:59 - so again it helps you
119:01 - in avoiding some of the mistakes that
119:03 - you might accidentally
119:05 - make when writing code so basically it
119:08 - detects the errors or possible errors
119:10 - for you
119:11 - and tells you to fix it so again
119:15 - this kind of intelligent warnings and
119:17 - error messages
119:18 - can be a lot of help when programming an
119:21 - application
119:22 - and now let's fix that warning so what's
119:25 - that all about
119:26 - the problem is on the very very first
119:29 - run of
119:30 - this while loop user input
119:34 - variable itself will not exist
119:37 - why because we're creating that user
119:39 - input variable
119:41 - on this line first so our
119:44 - application will basically complain
119:47 - because
119:48 - when our while loop runs for the first
119:50 - time it will not be able to find
119:52 - user input variable let's actually try
119:54 - that
119:55 - and as you see user input is not defined
119:58 - so we need to create that user input
120:00 - variable before
120:02 - the first execution of the loop
120:05 - so right here
120:09 - we're going to create user input so
120:12 - we're going to create this user input
120:14 - variable
120:15 - before the while loops first run
120:18 - and it doesn't really matter what the
120:20 - value of that user input variable will
120:22 - be because
120:23 - what matters is the variable exists so
120:26 - the value is basically just empty
120:28 - and as long as it's not exit the
120:32 - loop will start running and our
120:34 - application will get executed
120:37 - so again to go through the flow of this
120:40 - we're creating a
120:41 - user input variable then we're making
120:43 - sure it's not
120:44 - exit if it's not this line will get
120:47 - executed so we get the
120:48 - input from the user that's going to be
120:50 - our first input
120:52 - and then we call validate and execute
120:55 - function
120:56 - that basically does all the checks and
120:58 - execution
120:59 - so that's going to be the first run of
121:02 - that loop
121:02 - on the second run of the loop the
121:05 - condition will get
121:06 - re-evaluated so now the user input is
121:09 - what the user provided so again python
121:13 - will check is the user input
121:14 - exit no cool let's execute the program
121:18 - again user will have to enter another
121:21 - value
121:22 - and then that value will get
121:25 - re-evaluated
121:26 - so note that after each time
121:29 - that this block of code has run and
121:31 - executed
121:33 - every single value that user will give
121:35 - as an input
121:36 - will be evaluated over and over again
121:40 - in that condition and while user input
121:43 - is something else then exit it will run
121:46 - the program
121:47 - if it is exit then the loop will break
121:51 - so let's actually test that
121:55 - so this is our first message and our
121:57 - first input
121:58 - let's do 10 it got calculated
122:02 - let's do minus
122:06 - again calculate it and we can do that
122:08 - over and over and over again
122:10 - and now let's actually enter exit and
122:12 - let's see what happens
122:14 - and as you see a process finished with
122:17 - exit code so our application actually
122:19 - stopped because this condition was not
122:22 - true anymore it was
122:23 - false because we entered exit
122:26 - so that's how we can allow users to
122:30 - finish the application and two takeaways
122:33 - here
122:34 - one is a conditional in a loop
122:37 - and the second one is a negative equals
122:40 - check
122:41 - for values
122:46 - great so now we have our application
122:48 - that basically
122:49 - allows inputs multiple times
122:53 - and can be terminated with exit
122:56 - input now what if i wanted to calculate
123:00 - number of hours for several days but i
123:03 - didn't want to
123:04 - basically just pass it on one after
123:07 - another because that's just
123:09 - too much effort for me so let's say i
123:10 - wanted to give it
123:12 - 10 different values but i don't want to
123:14 - type it in
123:15 - 10 times right i want that application
123:18 - to basically do the
123:19 - whole calculation for all those 10
123:21 - values but
123:22 - i just want to enter that list once
123:25 - instead of
123:26 - entering each value separately
123:30 - so in this part we're going to learn
123:32 - another data type
123:33 - in python called list
123:37 - so till now we have learned several data
123:39 - types
123:41 - like strings for example
123:46 - as well as integers and
123:49 - float numbers and
123:52 - boolean true or false
123:56 - and list is just another data type
123:59 - and the syntax for list is
124:03 - using square brackets and
124:06 - inside the square brackets we have a
124:08 - list of
124:10 - elements and those elements can again be
124:14 - either strings numbers or boolean values
124:18 - in our case we want to provide our
124:20 - application with a list of
124:22 - number of days right so we're going to
124:25 - have
124:25 - a list of integers
124:29 - like this
124:32 - and you can have as many values inside
124:35 - the list as you want
124:36 - and these are going to be comma
124:37 - separated and the syntax will look
124:40 - like this but again as i said you can
124:42 - have a list of strings
124:44 - list of booleans etc so as i mentioned
124:48 - we want to let user basically
124:51 - provide inputs as a list
124:55 - instead of those individual values one
124:58 - at a time
124:59 - so i'm going to copy this let's clean
125:03 - this up
125:04 - and let's actually see what happens if i
125:06 - just
125:07 - input that list as a value
125:10 - right here and enter you see program
125:14 - doesn't recognize that
125:15 - as a valid number obviously because we
125:18 - have the check
125:19 - and causes a value error that's why we
125:23 - get
125:23 - your input is not a valid number don't
125:26 - ruin my program
125:27 - message right here so we want to change
125:29 - that and
125:31 - make our program actually accept that as
125:34 - a valid
125:34 - input so how do we actually implement it
125:38 - and let's go through this logic
125:40 - theoretically first
125:41 - before we start implementing it what we
125:44 - need here is that
125:46 - we want to read this list and we want to
125:48 - do
125:49 - validation and execution for each
125:53 - value one at a time so that means that
125:56 - validate and execute function needs to
125:59 - be called
126:00 - for each value in that list right
126:04 - so basically this function for all this
126:07 - logic
126:08 - needs to be executed for each element
126:12 - now how do we get the individual
126:15 - elements
126:15 - of the list so you remember the
126:18 - definition
126:19 - of a loop loop is basically executing
126:23 - same function with the same logic
126:25 - multiple times
126:27 - and the number of times basically
126:30 - depends on the condition right
126:32 - here we have a condition for while loop
126:34 - and the condition
126:35 - for executing the same logic for each of
126:38 - those
126:39 - elements is going to be the number of
126:42 - elements in that list right so we want
126:45 - to execute the logic
126:46 - as many times as we have elements in the
126:49 - list
126:50 - and for that we have another type of
126:53 - loop
126:54 - called for loop and basically we want to
126:58 - execute validate and execute function
127:00 - using a for loop the syntax for
127:04 - for loop is a little bit different first
127:07 - of all we have four
127:08 - keyword just like for while then we have
127:12 - the
127:12 - element is a variable so we can call
127:15 - that
127:16 - number of days
127:19 - so this variable basically represents
127:22 - each
127:23 - of those elements in the list
127:26 - and then we have in which is again a
127:29 - keyword of python
127:31 - so for in basically puts together the
127:34 - for loop
127:35 - logic in python so python knows what we
127:38 - are trying to execute
127:40 - and finally we need the list
127:43 - that we are executing this loop on
127:47 - and our list is our user input
127:51 - and that's our for loop however
127:55 - again you remember the indentation the
127:57 - logic
127:58 - that for loop executes needs to be
128:01 - indented so it should belong to for loop
128:04 - so now we can read that for loop
128:07 - statement as follows
128:08 - for each element which we call we decide
128:12 - to call number of days
128:14 - in a list called user input
128:18 - we want to execute this logic
128:21 - exactly what i said before so for each
128:23 - element
128:24 - in this user input list we want to
128:26 - execute
128:29 - validate and execute function we don't
128:31 - have a condition
128:33 - written here like we did in while loop
128:35 - or
128:36 - if statement so the condition is
128:38 - basically implicit
128:40 - right the condition says however many
128:43 - elements there
128:44 - are in this list that many times that
128:47 - function or that block of code here will
128:50 - get executed
128:51 - so if i provide five elements you will
128:54 - be executed five times
128:55 - if i provide 10 elements it will be
128:58 - executed 10 times
129:00 - and that's exactly what we want however
129:02 - there are still
129:03 - a couple of things we need to do for
129:05 - this application to work
129:06 - properly first of all validate and
129:09 - execute
129:10 - function still uses user input
129:14 - right here so instead we want it to
129:17 - use the individual values of the user
129:20 - input because now it's going to be a
129:21 - list
129:22 - and not a number so this
129:26 - element we can actually call it num of
129:28 - days
129:29 - element this value should be used here
129:33 - instead
129:34 - right so we're going to use that element
129:37 - instead of the whole user input list
129:41 - and paste it here so that fixes the
129:43 - first problem
129:44 - and the second one is as you know user
129:48 - input is
129:48 - always a string so even if we provide
129:52 - a list of these it is still going to be
129:55 - considered
129:56 - as a string so we need something similar
129:59 - to
130:00 - this right here so the list of numbers
130:03 - that are provided as input needs to be
130:05 - converted
130:06 - in at least in python and we can
130:09 - actually do that
130:10 - in a convenient way using user input
130:15 - dot split and split is a function
130:19 - that will take user input as a parameter
130:23 - and will give us a list data type
130:26 - so split function basically will return
130:29 - a list
130:30 - of all those input values
130:33 - and again note the syntax of executing
130:37 - the split function
130:38 - we're not just calling a split function
130:41 - like this
130:43 - with user input as parameter instead we
130:45 - are basically
130:46 - calling it on user input and i'm going
130:48 - to explain
130:49 - more about this type of functions in
130:51 - python
130:52 - later but for now let's actually execute
130:55 - this application
130:56 - and see what happens so first of all
130:59 - how am i going to provide a list
131:03 - to this application so that
131:06 - userinput.split
131:07 - can actually convert it into a proper
131:10 - list in python and the way i should
131:13 - provide the values are
131:15 - list of values with spaces between them
131:20 - so basically like that so why spaces how
131:24 - come it's not
131:25 - a comma or something else the reason
131:28 - is because split function by default
131:32 - splits that provided list on
131:35 - spaces and then creates a list value
131:39 - out of them so that's the default
131:40 - behavior of split
131:42 - however we can override that behavior
131:44 - and we can decide you know what
131:46 - we want the input to be a list of
131:49 - numbers that are comma separated instead
131:52 - of
131:52 - space separated so what we can do is
131:55 - right here we can do split on a comma
131:59 - so that's what our split function here
132:01 - will do and now if i re-execute it
132:06 - and i can do commas now
132:11 - 40 55.
132:15 - so that's going to be user input and
132:17 - split
132:18 - with comma should convert it into
132:21 - a list value in python so let's execute
132:24 - it
132:26 - and as you see it worked fine we have
132:29 - a calculation for each of those values
132:33 - now let's actually play around with this
132:35 - and let's say we provide
132:37 - a list with some values
132:40 - and somewhere in between we decide to
132:43 - add a text
132:44 - and then maybe a float so let's see what
132:48 - happens now
132:49 - and you see that for those two valid
132:52 - numbers the calculation was done
132:54 - properly and for the other two basically
132:57 - the validation kicked in and it says
133:00 - that these are invalid numbers
133:02 - however again our application ran
133:05 - without any problems
133:06 - and we can even provide another input so
133:09 - now let's actually
133:10 - do 20 maybe a boolean even
133:15 - and a negative number execute
133:18 - and you see that for 20 the number of
133:21 - hours got calculated
133:23 - true is obviously not a valid number
133:26 - and minus 100 is a negative number
133:29 - so everything works perfect validations
133:33 - in place
133:33 - and we can provide a list here now and
133:36 - as a final optimization
133:38 - we can actually change this message here
133:40 - that says
133:41 - hey user enter
133:48 - number of days as a
133:51 - comma separated
133:55 - list and i will convert it
133:59 - to hours so now we can provide
134:02 - either just one value and it works fine
134:05 - or we can provide
134:06 - multiple values
134:10 - as a list
134:14 - and again if we want to see how that
134:16 - list
134:17 - actually looks like and check the type
134:20 - that it has in python let's actually
134:23 - print it
134:24 - so first i'm gonna print type
134:28 - of user input called split
134:34 - and then i'm just gonna print that list
134:38 - itself so let's execute
134:44 - and let's provide
134:51 - some values and here you see
134:54 - this is the class list so basically the
134:57 - data type
134:59 - list and that's how our list
135:03 - looks like so we have these square
135:04 - brackets here and each element inside
135:07 - as a string because we have the quotes
135:10 - here
135:10 - and later our application then
135:14 - transforms it or tries to
135:16 - transform it into an integer
135:19 - and you also see there are some
135:21 - additional spaces here because
135:23 - that's how we entered the values so
135:26 - basically
135:27 - the split splits the values on comma
135:30 - so this space also becomes part of that
135:34 - element
135:35 - so to fix that leading space in each
135:38 - value we can
135:39 - basically just add a space here so it
135:42 - will split on
135:43 - comma and space
135:47 - and let's test it out
135:56 - and there you go we have our values
136:00 - without the space before them
136:06 - so you saw an example of when we
136:09 - actually need
136:10 - to use list data types in this example
136:13 - we wanted to allow users to basically
136:16 - just input multiple values at once as a
136:20 - list
136:21 - but obviously this is just one of the
136:23 - use cases
136:24 - for a list and one of the specific
136:26 - examples because throughout the
136:28 - application you can create
136:29 - lists and you can use the elements of
136:32 - that list
136:33 - in another function so you can use it
136:35 - for multiple use cases
136:37 - and just to show you some basic syntax
136:40 - of
136:40 - how to create lists within your code
136:43 - inside your application so how to
136:46 - initiate it and then how to use that
136:49 - list
136:50 - i will show you the examples here so
136:52 - basically to create a
136:54 - list in your code you would use that
136:56 - syntax that i showed you earlier
136:57 - with square brackets and inside that you
137:00 - would have
137:01 - list of elements and this could be
137:03 - strings
137:04 - so it could be for example names of
137:07 - month
137:08 - let's say like this
137:14 - and then we would have to assign it to a
137:17 - variable right
137:18 - again just like we did for strings or
137:20 - integers or other data types
137:22 - so we can call it my list
137:26 - and this will give us a list with
137:30 - three string values inside
137:33 - and once you have created a list you can
137:36 - then
137:37 - use it to read the values from the list
137:40 - right
137:40 - so basically to get the individual
137:43 - values elements out of that list so for
137:46 - example if we wanted to print out
137:49 - the first element of my list
137:53 - then we would access that
137:56 - using my list and then following syntax
138:00 - with again square brackets and then
138:03 - index number of the element which is
138:06 - starting from zero so this is the first
138:09 - element with index zero this is
138:11 - the element with index one index
138:15 - two and so on right so it could be
138:17 - confusing because it starts with zero
138:19 - not with one but that's how the
138:22 - specific element of a list can be
138:25 - accessed right
138:26 - so if i wanted the march value here the
138:30 - third element then i would just
138:31 - type in index two and this is a syntax
138:34 - of
138:35 - getting elements from a list if i just
138:37 - want specific
138:39 - values and not each element one by one
138:42 - as we had in this example right so one
138:45 - way to use a list
138:46 - is to basically loop through it and get
138:49 - one element at a time
138:51 - and that's why we don't need to use
138:52 - index here because it gives us
138:54 - elements one after another or
138:57 - maybe we don't want all the elements or
138:59 - to do something for each element we just
139:01 - want specific
139:03 - values from the list for different use
139:05 - cases in this case we can
139:06 - access them individually like this and
139:10 - in addition to accessing the values from
139:13 - a list or basically reading the values
139:14 - from release
139:15 - we can also add values to a list
139:19 - and we can do that by typing my list
139:23 - and then on the my list we're going to
139:25 - do dot
139:26 - and use the append function
139:30 - right so append will basically take the
139:33 - next element
139:34 - or another value basically and add it to
139:38 - the list of elements already in the list
139:41 - right
139:41 - so let's say we want to add the next
139:43 - month
139:44 - and now if i print
139:47 - my list we should actually see
139:51 - this here with april as a fourth element
139:54 - right so let's execute and there you go
139:58 - so first we have march here printed out
140:01 - which is
140:02 - the third element right index two
140:05 - and then we have my list append that
140:09 - adds fourth month name into the list
140:12 - so after append this is how my list
140:15 - will look like and now again we can
140:18 - access
140:19 - the specific element for example if we
140:21 - wanted to access
140:22 - the newly edit element on index three
140:26 - so that's going to be the fourth element
140:29 - and there you go we have the new
140:31 - element printed out and also an
140:34 - interesting note is what happens
140:36 - if we use an index here which is
140:39 - too high so basically pointing an
140:41 - element that doesn't exist right so
140:43 - instead of three let's say we have
140:44 - four here so this will point to the
140:47 - fifth element and since we only have
140:50 - four elements let's actually see what's
140:52 - gonna happen so i'm gonna execute this
140:54 - and there you go you see an error index
140:57 - error that says a list index out of
141:00 - range
141:00 - so every time you access or you try to
141:04 - access an
141:04 - element at an index that doesn't exist
141:08 - you will get this list index out of
141:10 - range error
141:12 - and this is actually something that may
141:14 - happen pretty often
141:16 - when working with lists if you're
141:19 - accessing the values like this
141:22 - so this is how you work with lists how
141:24 - you create them and access
141:26 - values in them as well as add some
141:27 - values however
141:29 - note that most of the time if you are
141:31 - using lists
141:32 - you're going to be using them in a for
141:34 - loop because most of the time you would
141:36 - want to do
141:37 - something specific for each element in
141:40 - the list
141:41 - so this basically should give you an
141:42 - idea of syntax of
141:44 - lists and how to use them generally and
141:47 - also how to use them in combination with
141:49 - for loops here i want to take a few
141:52 - seconds to thank jetbrains
141:54 - the creators of the awesome pycharm and
141:57 - intellij editors
141:59 - for sponsoring this complete course
142:01 - besides all the great existing products
142:04 - they have
142:04 - they recently introduced space which is
142:07 - an
142:08 - all-in-one team collaboration platform
142:10 - covering software development
142:12 - project and team management and the
142:15 - great thing about space is that
142:17 - every single tool you would need in a
142:19 - company to collaborate and work together
142:22 - in a team
142:23 - is in one space so you have tools for
142:27 - chats blogs planning and creating tasks
142:30 - meetings but also software development
142:33 - tools like
142:34 - version control ci cd package
142:36 - repositories and much more
142:38 - so all these in one platform and in
142:41 - terms of
142:42 - productivity the great thing is you get
142:45 - all the notifications in one place
142:47 - like code review updates newly created
142:50 - issues
142:50 - new blog posts etc you get all of these
142:53 - in
142:54 - chats where you can react directly in
142:57 - place
142:57 - or add them to your to-do list
143:00 - automatically
143:01 - so i think the main value of space isn't
143:03 - that it has all these tools
143:05 - but rather the fact that it integrates
143:07 - them in such an intelligent way
143:10 - that it improves the team communication
143:12 - and productivity overall
143:14 - now let's go back to coding
143:19 - now at this point here i want to mention
143:21 - a pretty
143:23 - minor and simple detail but something
143:26 - that is also very
143:27 - important and useful in programming and
143:30 - that
143:30 - is comments so how do we write comments
143:33 - in python and why do we need or in which
143:36 - cases
143:37 - are comments actually useful one usage
143:40 - of comments is basically to give
143:41 - yourself
143:42 - some notes on your own code so
143:46 - basically if your code gets a little bit
143:48 - complicated
143:49 - and it's not really clear what the logic
143:51 - or the function body is doing
143:54 - it could be because of bad programming
143:55 - but also because
143:57 - the function logic is just a little too
143:59 - complicated
144:00 - so you want to add some textual notes to
144:03 - that code
144:04 - so that you understand what's going on
144:06 - there even when you look at that code
144:09 - days or maybe weeks after you wrote it
144:12 - so for example right here we may want to
144:15 - add
144:15 - some notes about what
144:19 - this part here is doing and comments in
144:22 - python
144:23 - are written with this character so for
144:26 - example
144:27 - i want to add a note here we want
144:30 - to do conversion only
144:34 - for positive integers
144:40 - and that's basically my note that
144:42 - summarizes
144:44 - all that logic right here and it is not
144:47 - only useful for myself
144:49 - in case i forget what this complex logic
144:52 - actually does but also for your team
144:55 - members so if you're working in a team
144:57 - and your code gets really complex and
145:01 - it's
145:01 - difficult to keep an overview of
145:03 - different functions and variables and
145:05 - what all these things do
145:07 - you can basically add these comments as
145:09 - notes
145:10 - to your team members so they can also
145:12 - understand what you thought
145:14 - or what kind of logic actually you were
145:17 - thinking about when writing this code
145:19 - so comments is a way of communicating
145:22 - your thoughts and your logic on your
145:25 - code so that's one use case for using
145:27 - comments
145:27 - and the second use case if you have a
145:29 - piece of code that you do not want to
145:31 - delete
145:32 - because it has some logic or it has some
145:35 - example that you want to
145:37 - keep as a reference but you don't want
145:39 - that code to be
145:40 - executed so basically you can comment
145:43 - out
145:44 - code so that it still stays there but
145:47 - doesn't get executed and the way to do
145:49 - that is just basically
145:52 - having this character before the line
145:55 - and also
145:56 - note the color of the comment in the
145:59 - editor
146:00 - is gray so it's immediately visible that
146:02 - these are the comments
146:03 - and now these two lines will not get
146:05 - executed by the program
146:06 - they will be ignored but they are for
146:09 - your own reference
146:10 - in case you want to keep it there for
146:12 - example this could happen
146:13 - if you are unsure about the change and
146:16 - you want to delete that whole code
146:18 - from your application because you might
146:20 - actually need that
146:21 - eventually so you're not sure about it
146:24 - so temporary
146:25 - comment the code before you permanently
146:28 - delete that
146:29 - so these are some of the use cases of
146:31 - comments
146:32 - now if you have multiple lines of code
146:34 - that you want to comment out
146:36 - or maybe hold text that you wrote as a
146:38 - note so for example you want to comment
146:40 - out all these four lines here
146:42 - obviously you don't want to do this in
146:44 - front of every line
146:46 - so for multi-line comments you can
146:48 - actually
146:49 - use the following syntax which is three
146:53 - quotes at the beginning and
146:56 - at the end and again you see the
146:59 - highlighting is
147:01 - different here which basically is
147:04 - highlighting of a string however it is
147:06 - ignored
147:07 - by the program and it will not be
147:09 - executed
147:10 - as a best practice you shouldn't have
147:13 - too many comments in your code because
147:14 - it will just add additional clutter
147:17 - and your code will look basically
147:19 - unclean so
147:20 - you should use them only when needed
147:26 - in this part i'm going to show you
147:28 - another data type in python
147:30 - called set so what is a set let's start
147:33 - our application again
147:35 - and let's say i provide here input
147:38 - values as a list let's say 20
147:41 - 40 and 20 again
147:44 - so basically i have duplicate values in
147:47 - my list
147:48 - and when i execute it i see that
147:51 - the program got executed for each
147:54 - element
147:55 - and i have duplicate results because i
147:58 - passed in the same value
148:00 - twice now again users
148:03 - they can input any value they want
148:05 - either
148:06 - intentionally or accidentally this could
148:08 - be bad values
148:10 - or things that don't make any sense so
148:12 - let's say
148:13 - we want our program to behave in a way
148:15 - that
148:16 - if user provides the same values twice
148:19 - or three times we only want to calculate
148:23 - the number of hours for that value just
148:26 - once
148:27 - so basically for this input we want just
148:30 - those
148:30 - two lines and basically ignore the
148:33 - execution again for the same value
148:35 - and you probably already guessed that's
148:37 - where set
148:38 - data type will help us so set is
148:41 - basically a list
148:43 - of elements but with unique values
148:46 - inside
148:47 - so list data type allows duplicate
148:50 - values
148:50 - the same value multiple times set does
148:54 - not allow duplicate values
148:56 - so how do we use set instead of a list
148:59 - and it's actually very easy to convert
149:01 - an existing
149:02 - list into a set and we can do that
149:05 - using a function called set
149:09 - and basically the parameter of our set
149:11 - function will be
149:12 - the list so if this list here contains
149:16 - any duplicated values that will be
149:18 - basically just filtered out
149:20 - when we convert it into a set so that's
149:22 - how it works
149:23 - and again for demonstration let's
149:27 - actually print out
149:28 - how set value looks like
149:32 - so i'm going to print the list first
149:36 - so that we can compare then we're gonna
149:40 - print out the set
149:45 - and let's also print out the types
149:49 - and i don't want to repeat this
149:51 - expression over and over again
149:53 - so what we can do even though this is
149:55 - just for demonstration
149:57 - we can actually
150:01 - extract it into a variable let's say
150:05 - list of days
150:11 - like this and
150:14 - we can use it everywhere we need and
150:16 - this is a little bit cleaner because
150:18 - we don't have to repeat the same
150:20 - expression
150:22 - over and over again and again let's
150:24 - print out the type
150:26 - of list of days and then print out
150:30 - the type of a set
150:34 - of lists of days and again you see that
150:38 - nested function calls three times
150:42 - and this should give us some interesting
150:43 - value that we can compare
150:45 - lists and sets and just a small note
150:48 - here that whenever we have this nested
150:50 - function calls
150:51 - think of the execution from inside
150:55 - out so the first function that will get
150:57 - executed in this chain
150:58 - is actually the set right so it starts
151:01 - from the last function
151:03 - in that chain so set function will get
151:05 - executed and convert that list into a
151:07 - set
151:08 - then type function will get executed on
151:10 - that resulting set value
151:12 - and then print will get executed and
151:14 - print basically the result
151:15 - of the type so the order goes from
151:18 - innermost function to the outer
151:20 - functions
151:22 - so let's save it and execute and now i'm
151:25 - going to
151:25 - again provide a list let's say 10
151:28 - and then 45 and 30 and 10 again
151:33 - and enter and first of all we see that
151:37 - 10 only got executed once and not twice
151:41 - and we can also see the first one
151:44 - is basically value of a list and you see
151:48 - at least here the second one is a set
151:51 - and you already notice the difference
151:54 - that list basically uses square brackets
151:58 - and set
151:59 - is represented using curly braces right
152:02 - and again it has value of 10 just once
152:05 - and again we have the data type of a
152:08 - list
152:08 - and a set so just to demonstrate that
152:11 - they are actually
152:12 - own separate data types
152:18 - and like we saw previously with lists we
152:22 - can also
152:22 - create sets as well as add an excess
152:25 - values from it
152:27 - so let's see an example here for example
152:29 - if you want to create a set
152:31 - the syntax for that will look like this
152:34 - as we already saw again set can have
152:37 - strings or numbers or booleans
152:40 - as its elements let's use the same
152:43 - example we use with lists so
152:45 - i'm gonna just basically type in names
152:48 - of the month here
152:50 - so let's say we have again january
152:55 - february
152:58 - march and we're going to
153:02 - assign that again to a variable
153:05 - so this will give us a set that we can
153:07 - create ourselves
153:08 - not just from the user input and now we
153:11 - can access
153:12 - the values the individual elements from
153:14 - the set
153:15 - and we can also add elements to the set
153:18 - however
153:19 - we cannot access the individual
153:23 - elements of the set like we did on lists
153:26 - right
153:27 - you remember on lists we use the syntax
153:31 - with square brackets and the index of
153:34 - the element
153:36 - in set we cannot actually do that
153:39 - instead we can only access the elements
153:42 - of a set
153:42 - in a loop so for example in a for loop
153:47 - we would write element
153:51 - in my set and then
153:55 - we can basically print that element so
153:58 - let's
154:00 - execute
154:02 - and right here you see all the elements
154:04 - printed out
154:06 - and again as i mentioned with lists also
154:08 - previously
154:09 - most of the time when you're working
154:11 - with lists or sets
154:13 - you're gonna want to look through the
154:15 - elements because you probably would want
154:17 - to do some operation
154:19 - on individual elements or some of the
154:21 - elements right instead of just grabbing
154:23 - individual
154:24 - one or two values from that now how do
154:27 - we
154:28 - add elements to a set
154:31 - let's see it as well we can add elements
154:34 - to my set
154:36 - using my set so the
154:39 - set itself the variable name and then if
154:42 - you do
154:42 - dot you see a bunch of built-in
154:45 - functions again
154:46 - set has its own built-in functions which
154:49 - are completely different from what
154:51 - list has and it has a function called
154:54 - ed and here we can basically add
154:58 - a new element again let's do april
155:01 - and now we can print my set
155:07 - and execute and there you go so we have
155:10 - here individual elements that are
155:12 - printed out
155:13 - and we have the new list after we edit
155:17 - april now one thing you probably already
155:20 - noticed
155:21 - when working with the set like printing
155:24 - its elements or
155:26 - adding a new element it doesn't work
155:29 - in the same sequence as with a list
155:32 - right
155:32 - so for list we basically had this
155:35 - january february march in this
155:37 - exact order and when we edit a new
155:39 - element
155:40 - basically it got added at the end right
155:42 - as a fourth element
155:44 - in set it's not ordered it's basically
155:48 - in a random order right
155:49 - so if i execute this again rerun
155:53 - you see the order changed here and here
155:56 - as well right
155:57 - and if i do it again there you go so
156:00 - this order and this order basically
156:03 - changes right
156:04 - so as you see working with sets
156:08 - is actually pretty different from
156:09 - working with lists
156:11 - so this means that set
156:14 - not having or not allowing duplicate
156:17 - values is
156:18 - basically just one of the differences
156:20 - between
156:21 - sets and lists and
156:24 - of course you're probably wondering i
156:26 - can add elements i can access elements
156:28 - what about removing elements right from
156:31 - lists or
156:32 - sets and you can do that actually
156:36 - the same way for both sets and
156:39 - lists so for example if we want to
156:41 - remove an element from a set
156:43 - we can execute a built-in function
156:45 - called remove
156:47 - and remove basically takes a parameter
156:49 - which is the value itself
156:51 - so let's say if we want to remove
156:53 - january from here
156:55 - then we're going to pass the value to
156:57 - remove function
156:59 - and now if i print my set again
157:03 - after the remove gets executed and let's
157:06 - run it
157:07 - and here you see the last print
157:09 - basically doesn't have january
157:11 - inside and as i said it works the same
157:14 - for lists so let me demonstrate
157:18 - this as well so on my list which has its
157:21 - own
157:22 - set of built-in functions one of them is
157:25 - remove
157:26 - which in this case is called the same
157:28 - for both set and list
157:30 - and this remove built-in function also
157:32 - accepts
157:33 - the value of the element you want to
157:36 - remove
157:36 - and let's print it again my list
157:42 - and execute there you go this is a set
157:46 - with the syntax with curly braces and
157:48 - this is a list
157:49 - which now doesn't have january inside
157:51 - because we removed it
157:53 - and as you know lists can have duplicate
157:56 - values
157:57 - so if we have january
158:00 - again here so two times and
158:03 - we do remove january it will actually
158:06 - remove
158:07 - the first occurrence of that value so if
158:10 - i execute this
158:12 - you see the first one got removed and
158:15 - the last one or the second january value
158:18 - is
158:18 - still there so that's how you work
158:22 - with sets basically and also how to
158:25 - remove
158:26 - elements from sets and lists
158:33 - so at this point i want to take time and
158:36 - review the functions that we have used
158:39 - from
158:40 - python itself so the functions that we
158:42 - ourselves didn't actually
158:44 - write and the functions that python
158:47 - basically makes
158:48 - available for us to use are called
158:51 - built-in functions
158:52 - so till now we have used function
158:55 - print which basically just takes
158:58 - some input this could be a string this
159:01 - could be a variable
159:02 - this could be a number doesn't really
159:04 - matter and
159:05 - basically just prints it in the output
159:08 - console right
159:09 - in the terminal we also saw input
159:13 - function that basically takes user input
159:16 - again we can provide a parameter which
159:19 - will be a message
159:20 - or leave it empty we also in the
159:23 - last example so an example of set
159:27 - function which basically takes a list
159:31 - and converts it into a set and another
159:34 - example
159:34 - is int again takes
159:38 - a string as a parameter and converts it
159:40 - into integer
159:41 - and all of these are built-in functions
159:44 - because python provides them to us
159:46 - so that we can use it in our code and in
159:49 - python
159:50 - there are a lot of very useful built-in
159:53 - functions for different purposes
159:55 - and as i mentioned most of these
159:57 - functions basically accept
159:59 - a parameter and then do something with
160:02 - that parameter
160:03 - that input that we provide that function
160:05 - and give us an
160:06 - output again print basically
160:10 - provides something here and gives us the
160:13 - output
160:14 - in the output window here
160:17 - in input we can provide some message
160:23 - that will again print an input here and
160:26 - the rest of them
160:27 - are giving value inside the code
160:30 - without displaying anything so in set we
160:33 - can
160:34 - provide a list
160:37 - and the same way a parameter here which
160:40 - is logical because the purpose of a
160:42 - function
160:43 - usually is to take some input like
160:46 - this as a parameter do something with
160:49 - that input
160:50 - and give us an output from that
160:52 - parameter and we have created our own
160:54 - functions
160:55 - that also take some input and
160:59 - give back some output like this and
161:02 - in addition to built-in functions that
161:05 - are called like this
161:07 - and our own functions we have also used
161:10 - third type of functions which is called
161:13 - directly on a value right and this is an
161:16 - example of that
161:17 - so basically directly on a value this
161:20 - could be a variable but
161:22 - also the string representation of that
161:24 - itself
161:25 - so if i had a string like that so
161:27 - basically directly on that value
161:31 - call a function like this and these are
161:34 - also built-in functions because
161:36 - python makes them available to us other
161:39 - than the syntax
161:40 - there is one major difference between
161:43 - these
161:44 - type of functions that are called
161:46 - directly like that
161:47 - and the functions that are called on the
161:49 - value itself
161:51 - and the main difference is that each
161:53 - data type
161:55 - has its own set of functions
161:58 - that can be executed like this so
162:02 - again let's take example of a string
162:06 - and if i do dot here you see
162:10 - the ide pycharm basically gives me
162:14 - a list of all the functions
162:17 - again built-in functions in python but
162:19 - functions that i can execute
162:21 - on a string value and
162:24 - again you see split is digit this is the
162:27 - one that we used
162:28 - in one of our previous examples that
162:30 - basically checks if that string
162:33 - is a representation of a digit or just a
162:35 - regular string
162:36 - and as you see lots of different
162:41 - functions so all of these are provided
162:44 - by python
162:45 - to do different stuff like turn the
162:48 - string literal to uppercase or
162:52 - replace a letter for example in that
162:55 - string
162:56 - and so on but the main point here is
162:58 - that those functions
163:00 - are only for string but as i said
163:03 - each data type has its own list of
163:06 - functions
163:07 - that can be called on that data type so
163:10 - for a demonstration let's take a list
163:15 - and if i do dot here
163:18 - again you see a list of functions that i
163:22 - can execute specifically
163:23 - on list values and there are lots of
163:26 - things that you can do with lists like
163:28 - add elements to it remove elements from
163:31 - it
163:32 - sort the list copy and so on
163:35 - so that's basically a major difference
163:37 - between
163:38 - these type of functions and functions
163:40 - that can be executed on
163:42 - specific data type values but the
163:45 - concept is the same here
163:47 - you also have a function that gets a
163:49 - parameter an input
163:51 - and gives you an output and the
163:53 - parameter for this type of functions
163:56 - is actually the value that we are
163:57 - calling that function
163:59 - on so this string here 2 3
164:02 - is going to be parameter of the split
164:05 - and in addition to that we can also
164:07 - provide
164:07 - additional parameters for example for
164:10 - split you saw here that we were able to
164:12 - add
164:13 - a comma space to basically tell
164:16 - the split function on which character to
164:19 - split that text
164:20 - so that was function comparisons in a
164:23 - nutshell
164:27 - in this part we're going to learn a new
164:30 - data type in python
164:31 - called a dictionary and we're going to
164:34 - do that by modifying our application
164:37 - and modifying how users can actually
164:39 - input
164:40 - the values now our program currently
164:44 - takes the number of days and turns it
164:46 - into a number of hours
164:47 - what if we wanted to make our program a
164:49 - little bit more advanced
164:51 - a little fancier and basically allow
164:54 - users to also decide
164:56 - what units it should be converted to so
164:58 - user gives us the number of days
165:01 - and tells us whether to convert it into
165:03 - hours
165:04 - or minutes so instead of the whole list
165:08 - now we're going to get just number of
165:10 - days and
165:11 - the conversion units and this change may
165:14 - be a little bit complex
165:16 - in terms of syntax so i will try to
165:18 - explain everything step by step
165:20 - so the first thing we need to do is
165:22 - adjust
165:23 - how we get input from the user so now we
165:26 - want the user to
165:27 - be able to give us the number of days
165:30 - and units in one input so
165:33 - first of all i'm going to adjust the
165:34 - text here
165:37 - enter a number of days
165:42 - and conversion unit
165:45 - now there are a lot of different ways we
165:47 - can allow a user to do that
165:49 - but what we want to do is something like
165:54 - this as an input so basically number of
165:57 - days
165:59 - colon and minutes or
166:03 - number of days and hours again this is
166:06 - our own decision
166:07 - we decide how the user input should look
166:09 - like
166:10 - but this should be a nice way of
166:13 - providing both of those values
166:15 - basically colon separated so instead of
166:18 - a list
166:19 - we're going to have a single input with
166:21 - two values that are
166:23 - separated by a colon so on the next line
166:26 - i'm going to change this split here
166:28 - into a column and this will give us
166:32 - user input this whole value split into
166:35 - two values as a list this is going to be
166:39 - day and days and
166:42 - unit so least with these two
166:46 - values and let's actually get rid of
166:48 - this for loop because we're not
166:50 - iterating through a list of numbers
166:53 - anymore
166:54 - and to begin with let's just print out
166:57 - the output or the result
167:01 - of days and unit variable
167:04 - so i'm gonna refresh and let's do
167:08 - two hours and enter
167:11 - and this is what we get so basically
167:13 - splitting this string
167:15 - on column will give us a list with
167:17 - elements
167:18 - 20 and hours and note that 20 is still
167:21 - a string right because that's how we get
167:23 - the input and now
167:25 - from those two values we're going to
167:27 - create
167:28 - a value of a data type called
167:31 - dictionary so in python we have another
167:34 - data type
167:35 - called the dictionary which basically
167:38 - looks
167:38 - like this so you have curly braces just
167:42 - like we had for
167:43 - a set and inside we have key
167:46 - value pairs so we don't have just single
167:48 - elements
167:49 - like this but rather we have key value
167:53 - pairs
167:53 - so key in our case is
167:57 - days and the value of that key
168:01 - in our case would be 20. and then comma
168:04 - separated another value would be
168:07 - unit and
168:11 - a string hours so basically this is
168:15 - the syntax of a dictionary and obviously
168:18 - the
168:19 - difference between a list and a
168:21 - dictionary is that we have
168:23 - descriptions for each of our values
168:26 - represented as key value pairs so we
168:29 - want to
168:30 - create this construct right here from
168:32 - those two values
168:34 - and since this is a data type we can
168:36 - create a value and
168:37 - assign it to a variable of that data
168:40 - type so let's call it
168:42 - days and unit
168:46 - dictionary
168:49 - equals and obviously we don't want those
168:52 - values to be
168:53 - hard coded here we want to get it from
168:55 - the list
168:56 - now how do we access an element
168:59 - of a list how do we grab the first value
169:02 - which is
169:03 - 20 out of that list
169:06 - and to do that there is a syntax to
169:09 - access the elements
169:10 - in the list the list name and then you
169:12 - have
169:13 - square brackets and index of the element
169:17 - which if you remember you already
169:19 - learned in the section
169:20 - of lists so again days of unit
169:24 - list is this one right here and with
169:28 - index 0 we are accessing the first
169:30 - element
169:31 - index 1 is the second element and so on
169:34 - and
169:35 - index is basically just location this is
169:36 - location 0 location
169:38 - 1 and so on so this will give us the
169:41 - first value
169:43 - and obviously the second value is going
169:45 - to be with the same syntax with index
169:48 - one and let's actually print
169:51 - that one out as well
169:55 - so that we see the results restart the
169:58 - application
170:00 - let's do 20 hours
170:04 - so again this is our list 20
170:07 - hours as two separate values and this is
170:10 - a dictionary that we
170:12 - created using those two values
170:16 - so we have key value pairs basically and
170:19 - the same way
170:21 - for minutes we would end up with a
170:23 - dictionary that looks like this
170:25 - so now we have these two pieces of
170:28 - information in one variable
170:30 - and now we can give that variable to our
170:32 - function so that it does the validation
170:35 - first of all of the number and
170:39 - calculation based on the units so
170:42 - on the next line we're going to call our
170:45 - validate and execute function
170:50 - and as you see we have this red line
170:52 - here because something
170:53 - is wrong first of all we don't have this
170:57 - variable called num of days element
170:59 - anymore
171:00 - because we deleted the for loop instead
171:04 - we have days and
171:07 - unit dictionary and here we are
171:10 - validating
171:11 - the integer value of the input number
171:14 - and the same way we need to validate
171:16 - this input number here
171:18 - as well so now the question is
171:21 - how do we access a specific value in
171:24 - this case
171:25 - the value of days here in a dictionary
171:28 - because we have to validate this value
171:30 - as well because i might as well
171:32 - have entered text instead of this number
171:36 - so the way to access values
171:39 - inside a dictionary is again
171:42 - using the square brackets just like we
171:45 - did for list
171:46 - but instead of an index index 0 or index
171:50 - 1 we don't need to use an index because
171:52 - we
171:53 - actually have a key so instead of index
171:56 - we're going to
171:56 - use the key like days or
172:00 - unit and this will give us
172:03 - value of 40 which will then be
172:06 - converted into an integer and then
172:08 - validated right here
172:10 - so again i'm gonna copy this
172:13 - for comparison so to access
172:17 - an element of a list let's say
172:21 - my list here and let's do
172:24 - 20 30 doesn't matter in order to access
172:29 - the elements
172:30 - of that list
172:36 - we can do that using an index so this
172:38 - will basically
172:42 - print number 30. again if we had
172:46 - other elements here we can do index
172:50 - 2 so that will print out 100 and let's
172:53 - actually
172:54 - check that and remember to comment out
172:57 - a multi-line code we can use
173:00 - three quotes at the beginning and at the
173:03 - end
173:04 - let's refresh and there you go 100
173:08 - was printed let's do the same with the
173:10 - dictionary
173:13 - so we have a dictionary
173:22 - days
173:24 - like this and
173:28 - to access an element inside
173:31 - that dictionary we use the square
173:34 - brackets
173:35 - and instead of the index like here on
173:38 - the list
173:39 - we use the key itself
173:42 - and again i'm going to print this
173:47 - and there you go you see
173:52 - value 20 and i can also access
173:57 - unit value and if i execute it i see
174:01 - hours and so on and i can
174:04 - add any number of key value pairs in my
174:07 - dictionary as i want
174:09 - so for example i can add a message here
174:13 - all good and
174:16 - i can access that message
174:20 - like this so this is how you create a
174:22 - dictionary and that's how you
174:24 - access the values in a list or in a
174:27 - dictionary
174:28 - so let's clean this up
174:32 - comment in our code again like this
174:36 - and get back to our code
174:39 - so basically again this is how we access
174:42 - the
174:43 - number of days in our dictionary and
174:46 - in our days to units function we need
174:50 - both of those values and we can
174:54 - pass in those values separately so we
174:56 - already have a user input number
174:59 - from the dictionary and the second value
175:01 - would be
175:07 - the unit from the dictionary
175:11 - however we have to add that second
175:13 - parameter to our function
175:15 - so let's do that unit
175:18 - let's call it conversion unit
175:22 - so now we are passing both of these
175:24 - values
175:25 - to our function so we have the user
175:28 - input number here
175:29 - which is already converted into an
175:31 - integer
175:32 - and the second one which is the
175:35 - conversion
175:35 - unit and now we can finish
175:39 - the logic in this function here
175:42 - right now we are using this hard-coded
175:45 - calculation to units which is
175:47 - 24 and number of units which is
175:50 - hard-coded hours
175:51 - so first of all i'm going to remove
175:52 - those two we don't need them anymore
175:54 - because we get those values from the
175:56 - user
175:57 - and now we have to substitute
176:00 - those two so here we're going to check
176:03 - if the conversion unit is
176:04 - hours
176:09 - equals hours
176:13 - then we're going to return calculation
176:16 - with
176:16 - hours it's going to be 24 and
176:20 - conversion unit here we can also hard
176:23 - code
176:23 - hours here because we know it's hours
176:28 - else if
176:31 - so if the conversion unit is
176:35 - minutes
176:39 - then we can return
176:43 - calculation for minutes and a text like
176:46 - this
176:47 - and it could also be that the conversion
176:50 - unit that was provided
176:51 - is none of those or maybe some invalid
176:54 - text
176:55 - and in this case we're gonna add final
176:57 - validation so
176:58 - if it's neither hours nor minutes
177:02 - then we're just gonna say you know what
177:06 - unsupported
177:10 - unit
177:13 - so basically we don't do conversions
177:16 - other than those two
177:17 - so we just tell the user that's an
177:20 - unsupported unit
177:21 - and now if we execute our
177:25 - program and enter
177:29 - value there you go we have
177:33 - our output and same way if we do
177:38 - 90 days to hours
177:41 - we have our calculation in hours so
177:44 - that's how dictionaries work we can do
177:46 - one final thing here and
177:49 - as usual print out the type
177:54 - of our dictionary
178:02 - and there you go you see class of type
178:04 - dictionary here
178:06 - which is another data type and at this
178:08 - point we can actually
178:09 - summarize all the data types that we
178:11 - have learned so far
178:13 - so let's give us some space here so
178:16 - first one was string so basically
178:19 - a message or some output
178:26 - like this
178:31 - that's our string then we have integers
178:34 - example of that we saw already days
178:37 - then we have float numbers which for
178:40 - example can be used for
178:42 - price or
178:45 - weight of a product etc we also have
178:49 - learned boolean data types when we check
178:52 - some kind of condition whether if it's
178:55 - true or not
178:56 - so for example is it a valid number
179:02 - or is the user input
179:05 - exit
179:09 - we also learned a data type of lists
179:13 - so for example usage list
179:16 - of days
179:23 - like this including duplicate values
179:27 - and list data type can be used for
179:30 - strings as well
179:31 - not only for numbers so for example we
179:35 - can have list of month
179:37 - like january
179:41 - doesn't really matter we also learned a
179:43 - data type
179:45 - called set and set basically
179:49 - is very similar to list but it doesn't
179:53 - allow
179:53 - duplicate values and its syntax is
179:57 - with curly braces so the same way we can
180:01 - have
180:02 - numbers or strings or booleans or any
180:06 - other data types
180:07 - inside a set and the last one that we
180:09 - learned
180:10 - was a dictionary
180:14 - and let's take our own example
180:17 - day in unit
180:21 - and dictionary is basically a collection
180:25 - of key value pairs and the syntax
180:29 - is written like
180:32 - this so why do we need all these
180:35 - different data types
180:37 - well depending on the use case or what
180:40 - exactly you are trying to achieve in the
180:42 - program
180:43 - you're gonna need a different data type
180:45 - to achieve exactly that
180:48 - so each data type has its own specific
180:51 - purpose
180:52 - and throughout these days to units
180:54 - calculator i try to
180:56 - demonstrate the purpose of each data
181:00 - type
181:00 - and when we need to use them so these
181:03 - are all the data types that we learned
181:05 - these are also
181:06 - most of the data types available in
181:08 - python and the main ones
181:10 - that you're going to be working with so
181:12 - this should give you a good foundational
181:14 - knowledge about data types
181:16 - in python and also note that most of
181:19 - these data
181:20 - types you will also encounter in any
181:23 - other programming languages
181:24 - because as i said these are the core
181:26 - data types and most of the programming
181:28 - languages actually support these data
181:30 - types as well
181:35 - till now we have been writing all our
181:37 - code
181:38 - in one single file so basically we have
181:42 - a project
181:42 - with just one python file and we're
181:45 - writing all the logic
181:46 - inside that file however you can imagine
181:49 - that
181:50 - if you're writing a little bit more
181:52 - complex applications
181:53 - that have much more complex logic so
181:56 - they end up having
181:57 - lots of functions obviously you're gonna
182:00 - end up with a python file that has
182:03 - hundreds of lines of code maybe
182:05 - thousands of lines of code
182:07 - and it's not very practical to manage
182:10 - all this logic and all this code in just
182:12 - one file so instead you need to
182:15 - structure your
182:16 - code and divide your logic between
182:19 - multiple different python files and you
182:22 - do that
182:22 - with modules to give an example
182:25 - imagine a web application that has
182:28 - basically many features like facebook
182:30 - for example
182:31 - obviously you can put all the facebook
182:33 - logic in
182:34 - one single python file right you will
182:36 - have a structure
182:38 - of facebook project with subfolders in
182:42 - your project
182:43 - which all contain multiple python files
182:46 - so you would have
182:47 - maybe packages for each feature
182:50 - and each such feature has a lot of
182:52 - functionalities
182:53 - so they will be all grouped then again
182:55 - in multiple
182:57 - python files right so you would end up
183:00 - with
183:00 - a project with a hierarchy of folders
183:03 - and lots of lots of python files inside
183:06 - now the question is if i
183:10 - have multiple python files in my project
183:13 - how do i connect them together so for
183:16 - example if i have
183:17 - another file here and let's call it
183:20 - helper
183:21 - dot py
183:25 - and if i have some logic here basically
183:28 - functions defined here how do i use them
183:31 - or how do i reference them
183:33 - in another file and the way it works in
183:37 - python is using the concept
183:40 - called modules so a module is basically
183:43 - a python file that contains
183:46 - functions or variables that
183:50 - you can use in another python file
183:53 - so basically any python file that you
183:55 - have in your project
183:57 - both of these in this case are modules
183:59 - and you can reference
184:01 - one module from another so basically
184:04 - the idea is that you can structure your
184:07 - application
184:08 - your program using modules so you can
184:11 - make your project
184:12 - modular so in this part we're going to
184:14 - create our own module
184:16 - in helper file and we're going to
184:18 - reference that in main dot
184:20 - python
184:23 - and let's say in main.python i only want
184:26 - the code
184:27 - that basically starts the program right
184:29 - all the functions
184:30 - all the logic i kind of want it hidden
184:33 - away
184:34 - and grouped together in a separate file
184:37 - so what we're going to do is copy this
184:40 - entire thing
184:41 - so both of these functions basically and
184:45 - paste it in here so now you already see
184:49 - a couple of
184:50 - red lines here because now the reference
184:53 - is obviously broken right
184:55 - so main.python obviously doesn't know
184:57 - anything about
184:58 - validate and execute function right it
185:00 - says unresolved
185:02 - reference and the same way face to unit
185:05 - dictionary is unresolved for helper
185:08 - because it doesn't know anything about
185:10 - main.python and the variables defined
185:13 - right here so the first thing we need to
185:15 - do is we need to tell
185:17 - main note python file where to find this
185:20 - validate and
185:21 - execute function right we have defined
185:24 - it in helper python so
185:25 - that's what we need to define how we
185:29 - do that is using something called an
185:31 - import
185:32 - statement so we basically import
185:35 - this whole helper.pi module
185:39 - inside main.python and we do that
185:43 - very simply using import
185:47 - helper right helper is the name of the
185:50 - file
185:50 - and therefore name of the module and
185:54 - right now it's grey because we're not
185:56 - using it
185:57 - and the way to use it is helper dot
186:00 - and the function name and you see the
186:02 - red line disappeared
186:04 - so again what we did is we told
186:06 - main.python
186:07 - there is a helper module in this project
186:11 - and please import this whole module
186:14 - and all the functions that this module
186:16 - has and make it available
186:19 - in main.pi and then once we have that
186:22 - helper module
186:23 - we can reference any functions if we had
186:27 - any variables
186:28 - using module name dot
186:31 - function so this has to be the name and
186:35 - if i hover over it you see that pycharm
186:38 - actually displays the whole path
186:42 - to that helper.pi file
186:45 - and now note that here we still have
186:48 - redline
186:49 - because this is a variable which is
186:52 - defined in main
186:53 - dot pi but a helper module doesn't know
186:57 - anything about it and that's an
186:58 - important distinction here
187:00 - because we imported helper module inside
187:02 - main
187:03 - so helper modules functions are
187:05 - available here but not the other way
187:08 - so in order to make this dictionary
187:10 - available
187:11 - invalidate and execute function we would
187:14 - need to
187:14 - pass it in as a variable like this
187:19 - and this will work now now
187:22 - note that in main.python
187:26 - we actually only need this validate and
187:29 - execute function
187:30 - we don't need the days to units function
187:32 - because
187:33 - this function is only used by validate
187:36 - and execute function
187:38 - so that means that we don't need to
187:41 - import the whole entire module inside
187:44 - main.pi
187:45 - we actually only need the validated
187:48 - execute function
187:49 - and this is a small example but if you
187:52 - had a module with
187:53 - 20 30 functions and you just needed one
187:56 - of them
187:57 - you wouldn't need to import the whole
187:59 - module just for that one function
188:02 - so what you could do is you can pick and
188:04 - choose which
188:06 - specific functions you want to
188:10 - make available inside another file
188:13 - or another module and you can do that
188:15 - very easily
188:16 - using the following syntax we say from
188:20 - helper that's the module again import
188:24 - and the name of the function
188:29 - like this and now because we are
188:31 - accessing
188:32 - and importing that specific function we
188:35 - don't need
188:35 - to use module name anymore we have that
188:38 - function
188:38 - available directly so we can delete the
188:41 - module
188:42 - reference here and we have that function
188:44 - available
188:45 - like this so again instead of having
188:48 - entire
188:48 - helper module with all of its functions
188:51 - and
188:51 - other stuff we only have one specific
188:55 - function
188:55 - available here so that means we wouldn't
188:58 - be able to use
188:59 - these two units for example now we saw
189:01 - an example
189:02 - of a module that has just functions
189:05 - right
189:05 - however module can have many other stuff
189:08 - for example
189:09 - variables and you can make those
189:11 - variables also available
189:13 - for another program and that's an
189:16 - example here
189:17 - i'm going to create a variable called
189:21 - user input
189:28 - message
189:30 - and this is our user input message and
189:33 - we can actually
189:34 - put it into a variable instead of having
189:37 - it defined like that
189:38 - so i'm going to copy it
189:41 - and paste it here so now we have
189:45 - the user input in a variable in another
189:48 - file
189:49 - again how do we access it in main dot pi
189:53 - in this statement at the top we can
189:55 - actually import
189:56 - several things from a module
189:59 - right now we are importing a function we
190:02 - can also
190:03 - import our variable and we can do that
190:06 - also very easily
190:09 - like this and we can use that
190:12 - user input message here so basically if
190:15 - you have
190:16 - again 20 functions and variables
190:19 - from a module and you just need maybe
190:22 - five of them
190:23 - you can import them individually
190:26 - like this just basically just list the
190:29 - names
190:29 - of functions and variables what you can
190:32 - also do
190:33 - is import all this is what this
190:37 - asterisk sign represents so we're
190:40 - basically importing
190:41 - everything from the helper module again
190:44 - this is kind of a waste if you just need
190:47 - a couple of
190:48 - functions and variables from that module
190:51 - and not the entire thing
190:53 - however with this syntax you can import
190:56 - everything
190:56 - and now you may be wondering what is a
190:58 - difference between
191:00 - importing everything from the module and
191:02 - importing the whole module
191:04 - because in both cases you have
191:06 - everything in the module available
191:08 - the difference is in the syntax because
191:10 - note that if we
191:12 - use this from import statement
191:15 - you don't need to use name of the module
191:18 - every time you're
191:19 - accessing something defined in that
191:21 - module right
191:22 - so we don't need to do helper dot
191:24 - function name or helper dot
191:26 - variable name whereas if we imported
191:30 - the module like this you see
191:33 - we have red lines because we would need
191:35 - to do
191:37 - helper dot or module name dot
191:40 - whenever we use something from the
191:42 - module now this could be
191:44 - a matter of taste so basically which one
191:47 - you want to use i personally think that
191:52 - this is the most efficient and also
191:54 - cleaner way of
191:56 - using specific functions variables etc
191:59 - defined in a module
192:01 - and as a side note the things that are
192:04 - defined in a module
192:05 - that you can use basically in another
192:08 - file are called
192:09 - definitions so all these those three
192:12 - elements here
192:13 - are definitions of a module and you can
192:16 - use
192:16 - any of those definitions in a file where
192:19 - you
192:20 - import that module what you can also do
192:23 - when importing a module
192:24 - is you can rename that module basically
192:27 - to
192:27 - whatever you want so if the name of the
192:30 - module
192:30 - is too long or you just want to use a
192:33 - different name
192:34 - you can do as and then basically write a
192:37 - name whatever you want
192:39 - like h for example and then obviously
192:42 - you need to use that
192:43 - new name everywhere you access
192:47 - functions or variables of that module
192:50 - so basically how you import a module and
192:53 - whether you rename it
192:54 - is a matter of taste basically how you
192:57 - want
192:57 - to do that in your code
193:01 - however i think that importing specific
193:05 - elements from a module like this is
193:08 - most efficient and also cleanest way to
193:11 - do that
193:12 - so we saw how to create our own module
193:16 - and use it in another file so basically
193:19 - if you had hundred python files here
193:21 - with each one of them having their own
193:23 - functions and variables you can cross
193:25 - reference them from each other using
193:28 - the import statement very easily
193:34 - now in addition to creating your own
193:36 - modules
193:37 - we can actually use modules that python
193:40 - itself already includes so just like we
193:43 - used some
193:44 - functions that python gives us out of
193:47 - the box
193:48 - like inputs or ins so basically all of
193:50 - those
193:51 - the same way python also gives us
193:54 - modules
193:55 - for different scenarios so that we don't
193:58 - have to write this logic
193:59 - ourselves and there are a lot of useful
194:03 - modules that python actually includes
194:06 - for example math module for mathematical
194:09 - operations
194:10 - its own module for working with dates or
194:13 - date times
194:15 - module for working with specific files
194:18 - and so on so basically
194:19 - for many different use cases python
194:21 - already gives you
194:23 - ready modules and these modules will
194:25 - then contain multiple functions
194:27 - and variables for that specific use case
194:30 - again if we take an example of a date
194:32 - so if you have an application that works
194:35 - with dates
194:36 - and times you have this module from a
194:38 - python
194:39 - that gives you a bunch of useful
194:42 - functions
194:43 - for working with dates and again this
194:44 - means you don't have to write this logic
194:47 - yourself but rather use the existing one
194:53 - so to give you some examples of modules
194:56 - that
194:56 - python provides us with for example if
194:59 - you want to
194:59 - work with operating system there is an
195:02 - os
195:02 - module so
195:06 - we can print out we can get the name
195:09 - of the os for example
195:14 - and i'm going to comment all this out
195:19 - and run and you see the name of the os
195:23 - another useful module python offers is
195:27 - logging so if you want to use logging in
195:29 - your application
195:31 - the logging module gives you different
195:33 - functions to log
195:34 - an error message or warning etc
195:38 - as well as basically just configure how
195:41 - the login will look like
195:42 - again to see an example
195:49 - again it may look a little bit complex
195:51 - here but essentially
195:52 - just using the name of the module and
195:55 - then functions that
195:56 - it gives you obviously you need to know
195:59 - the functions
196:00 - and you need to know how to use them and
196:02 - you can get that information from
196:04 - documentation
196:05 - or if you're using pycharm
196:08 - it actually gives you all the
196:10 - information about these functions and
196:11 - the module
196:12 - if you just hover on it so you don't
196:15 - even need to
196:16 - google or check out the documentation
196:18 - and basically we're
196:20 - creating a logger and we're logging an
196:22 - error message
196:23 - so if i execute this now and here you
196:25 - see
196:26 - the output of the logger error happened
196:29 - in the app and logging in application is
196:32 - actually
196:33 - a very important feature so that's why
196:35 - logging module is available
196:38 - by default in python any use case
196:41 - in our application would be right here
196:44 - if an
196:44 - error happened for example instead of
196:47 - using a print basically just
196:49 - log and error so these were just
196:52 - some basic examples but as i said python
196:55 - comes
196:56 - with lots of very useful modules that
196:58 - you can
196:59 - use in your applications for different
197:02 - use cases
197:03 - and that of course makes your work
197:05 - easier
197:06 - because you can just use the logic
197:07 - instead of having to write it
197:09 - yourself in the modules that are part of
197:13 - python so that you can import them like
197:16 - this
197:16 - directly are called built-in modules we
197:19 - learned about built-in functions
197:21 - so these are the functions that python
197:23 - makes available to us
197:25 - directly and there are built-in modules
197:28 - that we get from python
197:29 - and by the way if you're wondering where
197:32 - this module actually comes from so where
197:34 - is the physical location
197:36 - on our machine or where this module
197:39 - files actually
197:40 - leave if you're using pycharm you can
197:43 - actually hover
197:44 - over it and hold down a control key or
197:46 - if you're a mac
197:47 - command key and click inside
197:51 - you see the file opens up which is the
197:53 - module the logging module
197:55 - since i said module is basically just a
197:57 - python file that has
197:59 - multiple functions variables etc
198:01 - available and you see right here
198:03 - on this top line the whole path
198:06 - for that python file so that's the
198:08 - location
198:10 - of that module file locally on my
198:12 - computer
198:14 - and inside this python file basically
198:16 - you again have python code
198:18 - and if we look for get logger function
198:22 - here like this
198:26 - right here you will find the definition
198:30 - of that function right so somebody
198:32 - implemented this function
198:34 - and called it get logger
198:38 - and this is basically the logic all the
198:41 - things that get
198:42 - executed behind the scenes and
198:45 - you as a user of python basically can
198:48 - use the name of the function
198:50 - and write your own programs with it
198:54 - and let's also look for error
198:58 - and there you go we have error function
199:00 - as well right here
199:02 - and obviously this is a more complex
199:04 - code here
199:06 - than what we write but just
199:09 - to give you an idea that this is
199:11 - actually a file on your machine
199:13 - that comes with the python version that
199:16 - you
199:16 - install locally and all the functions
199:20 - are defined already there by python
199:22 - developers
199:23 - and you can just use them like this
199:26 - without worrying about
199:27 - how the logic is actually implemented
199:30 - and another interesting thing is if i
199:33 - click here
199:34 - in this python 3.9
199:38 - like this logging is basically one
199:41 - module
199:41 - that we used and here you will see
199:45 - the list of the complete list of all the
199:48 - built-in modules
199:49 - that you get from python so some of them
199:52 - are folders
199:53 - like logging for example email and bunch
199:56 - of other stuff
199:57 - and the operating system module for
200:00 - example that we used
200:01 - is a python file then you can find
200:04 - right here so these are the built-in
200:08 - modules
200:12 - so now that we know what built-in
200:14 - modules are and how to use them
200:16 - let's actually see a realistic example
200:19 - and
200:19 - also write a little more interesting
200:21 - application using
200:23 - built-in module
200:26 - so what i'm going to do is in my python
200:28 - project i'm going to create a new file
200:31 - and i'm going to call this time to
200:34 - deadline dot pi y
200:38 - and we're going to write an application
200:40 - that basically accepts a user input
200:42 - of a goal and a date like a deadline
200:46 - date
200:46 - and then we're going to print out back
200:48 - to the user
200:49 - how much time it is remaining till that
200:52 - deadline
200:52 - and that deadline will be a date right
200:56 - some date in the future so that means
200:58 - that we're going to be working with
201:00 - dates
201:04 - and in order to work with dates we are
201:07 - going to need
201:07 - python's built-in module that allows us
201:11 - to call functions and do some processing
201:14 - and stuff
201:15 - on date values and that module
201:18 - is called date time so
201:22 - import date time
201:25 - so let's have that import statement
201:27 - right there and we're going to use it
201:29 - in our program so the first thing we
201:31 - want to do is
201:32 - let the user give us an input about
201:35 - their goal
201:36 - and a date or deadline for that goal
201:41 - so let's do that first
201:44 - we already know how to ask for user
201:46 - input
201:47 - with a message so we're gonna say enter
201:51 - your goal with a deadline
201:56 - separated by colon and we also know this
202:00 - already
202:01 - basically what we want to do is user to
202:04 - be able to
202:05 - enter their goal like learn python
202:09 - column and a date and let's say
202:12 - again this is totally up to us to decide
202:15 - we're the ones basically setting the
202:17 - rules here so let's say we want the date
202:20 - to be entered in following format
202:24 - day month
202:28 - and a full year like this
202:31 - so that's the format that we're looking
202:33 - for and this is how user
202:36 - should input the value otherwise with a
202:39 - different format it's not going to work
202:42 - so we're going to save that input value
202:44 - into a variable
202:45 - let's call it user input
202:50 - so we have the user input let's do the
202:53 - split again
202:55 - on a colon remember we have this whole
202:58 - thing as a string as one
203:00 - string so we want to split it into two
203:02 - parts
203:04 - so we have the goal here and the
203:05 - deadline and this will give
203:07 - us a list with those two values
203:10 - and let's call it input list
203:15 - and now from that list we can actually
203:18 - extract
203:19 - or get those individual values using
203:22 - a list syntax so accessing the elements
203:25 - from a list
203:27 - which is what we learned already using
203:29 - an index
203:30 - right so we have input list index
203:34 - 0 which is going to give us learn python
203:38 - and let's save it as a goal variable
203:41 - and let's create another variable which
203:44 - is going to be
203:45 - date let's call it deadline
203:51 - and this will be the second
203:54 - value in our list now
203:57 - let's actually print this out
204:02 - print this whole list out and
204:08 - now note that we are actually in a
204:10 - different file we're not in the main.pi
204:12 - anymore and we don't want to execute
204:15 - main
204:16 - python file instead we want to execute
204:18 - this one right here we basically just
204:20 - want to ignore everything else in this
204:22 - project
204:22 - so how do i go from main to this file
204:26 - execution
204:27 - very easy in this editor just to right
204:30 - click
204:31 - and you see here run time till deadline
204:34 - and i'm going to execute this everything
204:36 - else is ignored in the project we are
204:37 - basically just working on this one right
204:39 - here
204:40 - so enter your goal with the deadline
204:42 - separated by colon
204:44 - let's do that i'm going to do pi learn
204:47 - python
204:48 - colon and then
204:52 - let's enter some date and
204:56 - enter and this is the output so we
205:00 - basically split that into
205:02 - two values and put it in a list right
205:04 - here
205:05 - and very important to note here that
205:09 - both of these elements in this list
205:12 - are strings because again user input is
205:14 - always
205:15 - interpreted as strings so this was a
205:18 - string and it was split into two strings
205:21 - which are learn python and this date
205:24 - here
205:25 - however we don't want date or deadline
205:28 - as a string we want deadline as a date
205:31 - and exactly for that functionality we
205:33 - need
205:34 - this date time module because we don't
205:37 - want to implement it ourselves
205:38 - we want python to give us a ready
205:41 - function
205:41 - from a module that will basically just
205:44 - let us convert this string
205:46 - into a date value and converting string
205:49 - to date is just one example usage of
205:53 - date time module but you can use this
205:55 - module to work with dates
205:57 - generally like creating new dates
206:01 - formatting the dates updating the value
206:04 - etc
206:05 - and we're gonna see some of those
206:07 - examples in this section
206:09 - now if you're learning this type of
206:10 - thing alone you don't have
206:12 - me basically teaching you and giving you
206:14 - an example the way you would do that
206:16 - is you would basically research and
206:18 - maybe google how this is done
206:20 - in python and you would basically see
206:22 - some examples
206:24 - of using this date time and what the
206:26 - name of this function is and how to use
206:28 - that
206:29 - as well as each module has its own
206:31 - documentation page
206:33 - where you can look up the syntax and
206:36 - usage examples
206:37 - because obviously you're not going to
206:39 - know how to do that
206:41 - by yourself so the way we convert a
206:44 - string
206:44 - into a date using this date
206:47 - time module is on this datetime module
206:52 - if i type in dot
206:55 - i will see a list of all the definitions
206:59 - that daytime module gives me right
207:02 - so i have date daytime time etc
207:05 - the one that we need is date time
207:08 - because the function
207:09 - that we need for conversion is inside
207:12 - that definition and don't be confused
207:15 - here because we have date time twice
207:16 - here
207:17 - the first one is a module and the second
207:20 - one is a definition in that module and
207:22 - we can actually check that as well
207:24 - so if i jump into this date time module
207:27 - and inside that if i look for
207:31 - date time again so right here you see
207:34 - this
207:35 - date time definition and on that daytime
207:38 - definition
207:39 - we have now functions that we can use
207:42 - and as you see this is not a function or
207:44 - variable
207:45 - it says class here which is another
207:47 - concept in programming
207:49 - we're gonna see later so just for now
207:52 - think about this as a container of
207:54 - functions
207:55 - and variables inside that module
207:58 - and that's why we have to access it like
208:01 - this
208:02 - and then on that daytime definition this
208:05 - class
208:06 - we now have functions that we can use to
208:08 - do the conversion
208:09 - so the function we need is called str
208:13 - so string p time and this function will
208:16 - take a string
208:18 - representation of a date and we'll
208:20 - convert it into a date format
208:22 - so our string
208:26 - representation is deadline and
208:29 - we need to pass in the second parameter
208:32 - because remember
208:33 - i said we basically decided that the
208:36 - date should be entered like this with
208:38 - points and a full year here
208:41 - and as you know there are lots of
208:43 - different formats and types for dates
208:45 - right
208:46 - depending on a country or a language or
208:49 - even within that language
208:50 - we basically have multiple different
208:52 - formats right we have formats
208:55 - like this or we could also have
209:02 - a shorter version of the ear etc so we
209:05 - need to define here the format
209:07 - that we want python or this method here
209:10 - to use when converting this string into
209:13 - a date
209:14 - again because there are so many
209:16 - different formats available
209:17 - so what we have here is a day then we
209:20 - have a
209:21 - dot then we have a month again a dot
209:24 - and then we have an ear so this is kind
209:27 - of a
209:28 - main structure of a format however
209:31 - formats for dates have their own
209:33 - specific syntax
209:34 - and this is actually for all programming
209:36 - languages so what we need to do
209:38 - is put this percentage sign in front of
209:42 - every
209:43 - letter so again we have day month year
209:46 - and
209:46 - there is one more thing about this
209:48 - format this format right here
209:50 - matches
209:55 - this date however we want the full date
209:58 - not just
209:59 - the last two and the format for that
210:02 - would be a capital y
210:03 - again this is something that you would
210:05 - look up in the documentation
210:07 - of the module instead of knowing it by
210:10 - heart but just know that this type of
210:13 - formats
210:13 - are used when working with dates and
210:16 - this is not specific to python
210:18 - you will actually see something very
210:20 - similar in all the other different
210:22 - programming languages and that will
210:25 - do exactly what we want it will take
210:27 - this date here
210:29 - and give us a proper date format from it
210:33 - let's actually test this so i'm going to
210:36 - print this first
210:40 - and i'm also going to print a type
210:43 - a data type of that value so let's
210:46 - execute
210:56 - i'm actually going to copy that so i
210:57 - don't have to retype it over and over
210:59 - again
211:00 - and enter
211:03 - and here you see we printed first of all
211:06 - the
211:07 - date not a string and now this looks
211:10 - like a
211:10 - proper date and not a string anymore
211:13 - note the
211:14 - change in the format plus we have these
211:16 - zeros here
211:17 - which represent hours minutes and
211:19 - seconds
211:20 - we didn't set any of those so these are
211:22 - all zero and we have the date
211:24 - time type again note date time
211:28 - for a module name and date time of the
211:30 - class name
211:32 - so this is the type of our converted
211:35 - date and the reason why we needed to
211:37 - convert that
211:38 - string into a date is because we want to
211:41 - calculate
211:42 - how many days or how many hours are
211:45 - remaining
211:46 - until the deadline from now starting
211:48 - from
211:49 - today and to do that calculation
211:52 - we need to have date type because we
211:56 - can't do that on a string
211:57 - great so now we have our deadline
212:00 - represented as
212:01 - a date so let's actually assign this to
212:04 - a variable
212:05 - it's a deadline date
212:08 - like this and remove this
212:13 - and now we need to do a calculation
212:18 - how many days from now
212:23 - till the deadline
212:27 - we already have the deadline we need now
212:30 - again now is or today is also a date
212:34 - and since we have this module date time
212:36 - we can
212:37 - also assume that this module will give
212:40 - us some function
212:41 - to tell us the date of today
212:45 - and if i do date time
212:48 - again daytime class
212:53 - and today you see that we have this
212:56 - function available
212:57 - and this will basically give us the date
213:00 - of today so depending obviously when you
213:03 - execute this program
213:04 - it will give you always the current date
213:09 - so let's print it today
213:12 - for me it's 7th of february so if i
213:15 - execute it now
213:18 - i'm going to enter this and today is
213:21 - 7th of february for me so if i execute
213:24 - this
213:24 - let's actually comment this out
213:30 - here i have the date for today which is
213:32 - 7th of february
213:34 - plus the exact time it is now but we
213:37 - don't care about the hours and minutes
213:39 - and seconds
213:40 - we just care about the day
213:45 - so that means we already have deadline
213:49 - and we have today let's also
213:53 - add it to a variable
214:01 - like this and now we can actually
214:04 - do the calculation calculation is
214:07 - super easy we just say deadline date
214:11 - minus today date and this will actually
214:14 - give us
214:16 - the difference between
214:22 - or time difference between today and
214:26 - the deadline date in the future
214:29 - again let's actually try this out
214:36 - and you see that so this is 12th of
214:40 - august for me today is 7th of february
214:43 - so the program calculated that there are
214:46 - 185 days
214:48 - until the time plus how many hours
214:51 - minutes
214:52 - seconds and milliseconds so that was a
214:55 - pretty easy calculation
214:57 - now what we want to do is
215:00 - tell the user some kind of message and
215:02 - we want the message to be
215:04 - dear user the time remaining until the
215:07 - deadline
215:08 - for your goal whatever the goal was is
215:11 - this so let's actually put that text and
215:14 - message together
215:15 - and bring it back to the user
215:19 - so first i'm going to save it into a
215:22 - variable
215:24 - let's call it time
215:28 - till
215:31 - and the message dear user
215:38 - time remaining
215:41 - for your goal and here we want to print
215:45 - what the goal actually is and you
215:47 - remember how we format
215:49 - a string when we want to use a variable
215:52 - we put an f here and in curly braces now
215:57 - we can use
215:57 - variables or numbers or some other
216:01 - expressions
216:02 - which are not string so first of all
216:05 - we're printing back
216:06 - the goal so time remaining for your goal
216:08 - whatever goal they entered
216:10 - is time till
216:16 - and let's execute our program
216:24 - and let's give it some other value
216:27 - like this and enter and here we have
216:30 - our message dear user time remaining for
216:34 - your goal
216:35 - learn python is 132 days
216:39 - and this many hours minutes etc
216:42 - now let's say we don't care about this
216:45 - whole thing here we just want to know
216:46 - how many
216:47 - days are remaining so how do we get rid
216:50 - of
216:50 - this part here again very easy
216:54 - and the time till if i do dot here
216:58 - i get a list of suggestions for
217:01 - functions or variables that i have
217:03 - available
217:04 - and one of them is days as you see here
217:07 - so if i click here
217:08 - and save and i'm going to reuse these
217:12 - inputs
217:13 - because i don't want to type and
217:16 - as you see we got rid of this whole
217:18 - thing here and we just have
217:20 - days and let's actually write days
217:28 - and there you go we have a cleaner
217:31 - output now for
217:32 - our user and finally what if the
217:34 - deadline was
217:36 - just a couple of days in the future and
217:39 - the user wanted to know how many
217:40 - hours are remaining till that deadline
217:43 - we can do that
217:44 - by getting rid of these days and again
217:48 - type in dot and we have something called
217:51 - total seconds here which gives us the
217:53 - time different
217:54 - in total seconds and now we can
217:58 - reverse engineer and calculate the
218:00 - number of hours
218:01 - from this total seconds which is pretty
218:03 - easy
218:05 - like this calculate minutes and then
218:08 - calculate hours
218:11 - and i'm gonna execute this again
218:16 - and here you see the number of hours
218:20 - with a decimal precision so we have 4450
218:25 - hours point
218:27 - some fraction number here again we want
218:29 - to get rid of this
218:30 - extra stuff and as you see from the
218:33 - syntax
218:34 - it is actually a float number with a dot
218:36 - here
218:37 - so what we could do is basically convert
218:40 - this whole thing
218:41 - this float number into an integer so
218:45 - convert this whole thing into an integer
218:47 - using
218:47 - int function and we need this whole
218:51 - calculation here inside the int function
218:54 - and let's execute it again learn
218:58 - python and let's choose a date which is
219:01 - near
219:03 - and there you go we have a whole number
219:05 - 57 again
219:06 - cleaner output and as a code
219:10 - optimization
219:11 - we could take this whole thing out
219:14 - into a variable and call it hours
219:18 - till to make our code a little bit
219:23 - cleaner
219:24 - so now we have the whole program that
219:26 - takes user input
219:28 - and basically prints back to them how
219:31 - many
219:31 - hours are remaining till the deadline
219:34 - for their goal
219:35 - and for this program we used a date time
219:39 - module
219:39 - a built-in date time module from python
219:42 - and we also learned a new data type
219:45 - which is date time and as we learned
219:48 - from the module section
219:49 - we can actually optimize the import of
219:52 - the module because
219:53 - obviously we're just using the date time
219:55 - definition
219:56 - and nothing else from that module
219:59 - so what we could do is from date time
220:03 - module
220:04 - import date time definition
220:07 - which is a class in this case so
220:11 - now you don't need to use the module
220:13 - name
220:14 - so let's get rid of those and this could
220:17 - make
220:18 - the code cleaner as well as make the
220:21 - import more efficient because we're not
220:23 - importing the whole module even though
220:24 - we just need one definition from there
220:29 - when you install python it comes with a
220:31 - set of
220:32 - modules that are built in into python
220:36 - however there are many more modules
220:39 - for other different use cases like web
220:42 - development or data science and machine
220:44 - learning etc
220:45 - that are not part of that installation
220:48 - and these are basically
220:49 - external modules not built-in modules
220:52 - that you have to
220:53 - install as you need and this makes sense
220:56 - because the built-in modules are the
220:58 - ones that
220:59 - most of python programs will probably
221:02 - need
221:02 - and depending on what specifically you
221:05 - are doing with your program
221:06 - whether you are developing a web
221:08 - application or creating some machine
221:10 - learning
221:11 - program you can then add and install
221:13 - them as you need
221:15 - and there are hundreds of such external
221:17 - modules
221:18 - for python out there and obviously it
221:21 - wouldn't be practical
221:22 - to have them all on your laptop when
221:25 - you're just gonna use maybe a handful of
221:27 - them right
221:28 - now if i need to install an additional
221:32 - module for example django for web
221:35 - development
221:36 - where do i find these modules and how do
221:38 - i install them
221:40 - python modules actually live in a module
221:42 - repository
221:43 - where you can find them and that module
221:45 - repository is called
221:47 - pipey so if i look for pipey
221:50 - right here you see the python package
221:53 - index
221:54 - if i click inside you can search for any
221:58 - module that you want to add or install
222:01 - additionally for your application and
222:04 - here you see this word
222:06 - package everywhere instead of a module
222:09 - so what is a package or what is the
222:11 - difference between
222:12 - package and a module
222:17 - to give you a simple comparison module
222:20 - is basically
222:21 - a python file like this one right here
222:23 - that has
222:24 - a name of that file right so we have an
222:27 - ssl
222:28 - module or the one that we used
222:31 - earlier we have this os module right
222:34 - so module is one python file that
222:38 - contains all these functions and
222:39 - variables that you can use
222:42 - package is a collection of modules
222:45 - so if we scroll up and logging
222:48 - is actually one our example
222:52 - so these are actually packages and
222:56 - again let's go to logging so package
222:58 - basically contains
223:00 - multiple python files and use it in the
223:03 - same way you basically
223:05 - import the functions and definitions
223:06 - from the module
223:08 - and as you see clearly the difference is
223:10 - that package
223:12 - is more structured so for example the
223:14 - code is not available in just one
223:16 - single python file but it's divided like
223:19 - this
223:20 - in our case we have two python files and
223:22 - package
223:23 - always has this init python file
223:26 - and this file basically differentiates a
223:29 - normal folder
223:31 - like we have right here with bunch of
223:33 - python files
223:34 - from an actual package with python files
223:37 - so that's the difference between modules
223:40 - and packages
223:41 - and many external modules basically that
223:44 - we want to use in our projects are
223:46 - actually packages so basically package
223:48 - is a
223:49 - good way to define some hierarchy and
223:51 - structure for your modules
223:53 - and kind of group them together so
223:55 - that's why you see
223:56 - package here as a name instead of module
224:00 - so now that we know the difference let's
224:02 - actually search
224:03 - for a package for our project so for
224:06 - example if i type here
224:09 - django you see django packages that we
224:13 - can
224:13 - use from here we also have numpy
224:18 - and so on however in programming when
224:21 - working with and using these external
224:24 - packages a typical example would be
224:26 - where
224:26 - you need to implement some logic for
224:30 - example you want
224:31 - to write a program that basically talks
224:33 - to aws maybe
224:35 - and you don't know exactly the name of
224:37 - that package
224:38 - but you know what you're looking for so
224:41 - in this case
224:42 - instead of the exact name you would
224:44 - actually type in here in the search
224:46 - projects box
224:47 - a description of what you're looking for
224:50 - so let's say we're looking for
224:51 - an aws api package right
224:56 - something that will allow us to connect
224:58 - to the aws api
225:00 - and as you see here we get a list of
225:03 - different packages for that to choose
225:05 - from
225:06 - so basically pipey is a repository
225:10 - or storage for all of those modules and
225:12 - packages
225:13 - and people can also publish their own
225:15 - libraries like individual developers for
225:17 - example
225:18 - they can publish their own packages and
225:20 - modules there
225:22 - and make it available for other
225:24 - programmers to use
225:25 - and that's one reason why large
225:27 - community is
225:28 - so great for a programming language
225:30 - because then you can make
225:31 - use of all these modules and packages
225:35 - that others in the community have
225:37 - developed so for any kind of
225:39 - functionality you need in your
225:40 - application
225:41 - you could imagine that there is a module
225:44 - or package that helps you do exactly
225:47 - that
225:51 - now let's say i need a django package
225:54 - for my
225:55 - web application so first i find the
225:57 - package
225:58 - and now i can actually check some of the
226:01 - documentation for that specific package
226:04 - so if i click inside i see some
226:07 - description
226:08 - for the project as well as documentation
226:10 - and some other links
226:12 - now the question is how do i actually
226:15 - install this package
226:16 - locally so that i can use it in my
226:19 - project
226:20 - in python we install packages
226:23 - using a package manager tool called peep
226:27 - and right here on top below the package
226:29 - name you actually see a command
226:32 - peep install django so this is actually
226:35 - a command
226:36 - that will install that package locally
226:38 - on my laptop
226:39 - so we install packages in python using
226:43 - this pip command so
226:46 - what is this command or where does it
226:48 - come from
226:49 - pip is a package manager for python
226:52 - and if you know any other programming
226:54 - language basically
226:55 - the concept is the same every
226:58 - programming language
226:59 - has its own package manager tool
227:02 - for javascript it's npm for java
227:05 - it's maven or gradle and for python it
227:08 - is
227:08 - pip and one of the main tasks or usages
227:12 - of a package manager tool
227:13 - is to install external packages or
227:17 - libraries
227:18 - or also called dependencies for your
227:21 - project
227:22 - so if python needs this django package
227:26 - basically it's the job of the package
227:28 - manager
227:29 - to install that package and make
227:30 - available for python
227:32 - now where did this command come from do
227:35 - we have pip command available
227:37 - well in python version 3 actually
227:40 - pip is packaged inside the python so
227:43 - when we install the python we actually
227:46 - installed pip as well so basically we're
227:49 - going to copy this command
227:51 - peep install django and we're going to
227:54 - execute it actually from the terminal
227:56 - of pycharm so in pycharm editor we have
228:00 - this
228:00 - integrated terminal so this is actually
228:03 - pretty much the same
228:04 - terminal as you have outside like this
228:08 - so we are going to execute this pip
228:10 - install command directly
228:12 - in this pycharm terminal so i'm going to
228:15 - copy it
228:15 - here and do peep install django
228:19 - and you see it is downloading and
228:21 - successfully
228:22 - installed django 3.1.6
228:25 - and we can actually see that package
228:28 - from our editor directly
228:30 - if i expand these external libraries
228:33 - and site packages
228:37 - and scroll a bit down here i have django
228:41 - 316 version installed so i see that the
228:45 - package is now
228:46 - available in my project and to also test
228:49 - it
228:50 - in the code i can do import and
228:55 - django and you see that pycharm actually
228:58 - recognize that i have django packaged
229:01 - locally
229:01 - so it gives me that package as a
229:04 - suggestion
229:04 - so that will basically import the whole
229:08 - django package
229:09 - so we can now use it in our application
229:11 - here you see pycharm
229:13 - actually noticed you are using or want
229:15 - to use
229:16 - django web framework as i mentioned in
229:18 - the beginning the pycharm professional
229:20 - edition
229:21 - has special support for different python
229:23 - web frameworks
229:25 - supporting you with syntax highlighting
229:28 - suggestions
229:29 - database integration and so on so again
229:32 - if you want to try it out for free for
229:33 - three months just use my code in the
229:35 - video description
229:37 - in the same way as we install the
229:39 - package
229:40 - we can also uninstall packages using pip
229:44 - and let's also actually demonstrate that
229:48 - pip uninstall
229:51 - django and
229:55 - let's confirm that
229:58 - successfully uninstalled django now if
230:02 - in the site packages i click inside
230:05 - you see that django packages are gone so
230:08 - this site packages folder got updated
230:11 - django was removed
230:12 - and you also see that in the code editor
230:14 - now i have this
230:16 - red line under django because pycharm
230:19 - cannot find
230:20 - a module called django and also if i do
230:24 - this
230:25 - obviously it won't give me any auto
230:27 - suggestion for that
230:28 - so that's how you can use peep to
230:30 - install packages and also to uninstall
230:33 - packages
230:34 - for your application
230:38 - now here i want to show you another cool
230:41 - alternative to installing and
230:43 - uninstalling packages directly in the
230:46 - pycharm ide
230:48 - and this is actually a feature in the
230:50 - latest pycharm release
230:52 - and for this i need to switch to an
230:55 - early access pycharm version so you see
230:58 - here
230:58 - it says pycharm eap early access
231:02 - to show you the feature however when you
231:04 - watch the tutorial it probably will
231:06 - already be included in the latest
231:08 - official pycharm version so you should
231:11 - have that already
231:12 - so instead of us basically finding this
231:15 - package in pipey
231:17 - and then executing peep install commands
231:21 - right here what you can do is
231:24 - down here you have another tab called
231:26 - python packages so if we click inside
231:29 - this is a place where you have
231:31 - everything that you need to know
231:32 - about the package the package search and
231:35 - all these
231:36 - features basically in one place so for
231:38 - example
231:39 - in order to install django we can just
231:42 - search
231:43 - for django right here and you see that
231:46 - when i type in the first couple of
231:47 - letters
231:48 - i already get suggestions so this is a
231:50 - list of all the packages
231:52 - that start with this name that are
231:54 - actually available in pipi
231:56 - so let's type in django and we see that
231:59 - right here
232:01 - and on the right you see the
232:03 - documentation
232:04 - of the package that you would actually
232:07 - see in
232:08 - pipey ui so you have that in place as
232:11 - well
232:12 - and in addition to that what they added
232:15 - is the documentation
232:16 - link so this is actually the package
232:18 - how-to guide
232:19 - and the full documentation with examples
232:22 - etc
232:24 - so very convenient way to basically get
232:26 - all the information about the package
232:28 - search the package and then to install
232:31 - the package
232:32 - we can choose the version here so either
232:35 - you can leave the latest
232:36 - or basically select the specific version
232:39 - and then once you have selected that you
232:42 - can just click
232:42 - install and here you see installing
232:45 - package
232:47 - and there you go so now in installed
232:51 - view here so we just had pip and setup
232:54 - tools
232:54 - these two things installed and right
232:56 - here we have now
232:58 - django in the installed packages list
233:01 - and again while you're now using the
233:04 - installed
233:04 - package or library in your code and
233:07 - basically you want to look
233:08 - up some examples or you want to check
233:10 - some documentation
233:11 - right you go back to the package click
233:15 - inside and you have link to
233:16 - documentation and
233:18 - the package information as well and also
233:22 - just by looking at this list you know
233:24 - which versions of which packages you
233:27 - have installed so i think it's really
233:29 - cool way to manage all your packages to
233:31 - install packages
233:32 - and for example if you want to uninstall
233:35 - packages
233:36 - from your project then again just
233:38 - clicking
233:39 - to that specific package right here
233:43 - you can just delete it and it will be
233:44 - removed from your application
233:49 - like this and no django anymore here
233:54 - so a very cool addition to pycharm
233:56 - because this will be very convenient to
233:58 - work with the packages
234:00 - so now i will switch back to my other
234:02 - editor again
234:03 - and continue from there
234:11 - so basically i have just cleaned up my
234:14 - python project we have this main.pi
234:17 - which is
234:17 - empty and we're gonna write an
234:19 - application that will read
234:21 - a spreadsheet file from our local file
234:24 - system
234:24 - it will read some information from that
234:26 - spreadsheet file and do
234:28 - something with that data and this could
234:30 - be a very useful
234:32 - use case if you're working with lots of
234:35 - files and you want to do some
234:37 - data processing in those files and you
234:39 - don't want to do that manually
234:41 - by automating or writing a program in
234:43 - python
234:44 - that basically can do anything in a file
234:47 - or across multiple files so let's see
234:50 - exactly
234:50 - what we are going to be doing with this
234:52 - program so first of all
234:54 - we're going to have an input file a
234:56 - spreadsheet file that we're going to be
234:58 - working with
234:59 - and that spreadsheet will look like this
235:02 - it's called inventory that's how it's
235:05 - going to look like
235:06 - so basically this file simulates
235:08 - something that many companies would have
235:11 - and employees of that company would be
235:13 - working with
235:14 - so we have this list of product numbers
235:18 - inventory for each product price for the
235:21 - product
235:22 - and a supplier so this could be an
235:24 - example file from a company that is
235:26 - basically dealing with
235:27 - selling or buying products so what we're
235:30 - going to do is
235:31 - we're going to read the information from
235:32 - this file and we're going to do
235:34 - something with that information
235:35 - first we're going to write logic that
235:38 - calculates
235:40 - how many products we have per supplier
235:43 - so we have three supplier companies here
235:45 - and per supplier we're gonna calculate
235:48 - number of
235:49 - products from that specific company and
235:51 - as a result we're gonna list
235:53 - the company so all three companies with
235:56 - their respective
235:57 - number of products then we're going to
236:00 - write another logic that
236:01 - lists inventory products that have
236:04 - inventory which is
236:05 - less than 10 so basically those ones
236:09 - the third exercise is going to be to
236:12 - list
236:13 - each company with their respective total
236:16 - inventory value
236:18 - and finally in the last exercise we will
236:21 - calculate the inventory value for
236:23 - each product so product count times
236:27 - price and we're going to write that
236:29 - value to
236:30 - an additional column in the spreadsheet
236:32 - and
236:33 - after that we're going to save that
236:35 - updated spreadsheet file
236:36 - programmatically using python so we're
236:39 - gonna see how to
236:40 - update a file and then save it
236:43 - programmatically
236:44 - in python if any of these sounds a
236:46 - little bit too complicated for you then
236:48 - just bear with me
236:50 - i'm gonna explain everything step by
236:52 - step and
236:53 - it's gonna become much clearer when we
236:55 - actually start writing the
236:57 - logic
237:01 - so the first thing what i'm gonna do is
237:03 - i'm gonna take this
237:04 - file that i have in the downloads folder
237:07 - and i'm actually gonna
237:08 - move that into my project so i'm gonna
237:10 - copy that and i'm gonna drop it in here
237:13 - so that we have the file right in our
237:16 - project and so we can basically just
237:19 - read it
237:20 - easily and okay and here is
237:23 - our inventory file so that's taken care
237:26 - of so obviously what we want to do now
237:28 - is read that file so basically let our
237:32 - python program
237:33 - read the contents of that file right
237:36 - here
237:36 - because we want to write some logic
237:38 - based on the values
237:40 - that are in this inventory file right we
237:42 - want to calculate stuff we want to
237:44 - list some stuff and so on so basically
237:46 - we want to work with these values and in
237:48 - order to do that we need to
237:50 - read all of these values into our
237:52 - program so that we have them available
237:55 - so how do we do that now there is
237:57 - actually a
237:58 - built-in module in python that allows
238:00 - you to work with files
238:02 - generally right it's not specific for a
238:05 - spreadsheet
238:05 - or for any other file type it's for
238:08 - different types of files
238:09 - generally however there is an external
238:13 - package
238:14 - that allows you to work with
238:16 - spreadsheets
238:17 - specifically and the obvious advantage
238:20 - is that
238:21 - that external module that allows you to
238:22 - work with spreadsheets or
238:24 - was created to work with spreadsheets
238:26 - specifically
238:27 - has much more functions and is much
238:30 - easier to use
238:31 - if you are working with spreadsheets
238:33 - compared to this built-in file module
238:36 - so that's one of the cases where you may
238:37 - have multiple ways of
238:40 - actually implementing some functionality
238:42 - for
238:43 - application and then you have to make
238:45 - this decision of maybe finding a better
238:47 - package or better module
238:49 - which is available externally that will
238:51 - make it easier for you
238:53 - to implement that functionality so
238:55 - that's what we're gonna do for our
238:57 - project
238:58 - we're going to choose the package that
238:59 - is actually made for working with
239:01 - spreadsheets
239:02 - we're going to use that one and it's
239:04 - called open
239:06 - pi xl and if i
239:09 - search for it this is the package that
239:11 - we're looking for
239:12 - and if i click inside basically we have
239:15 - some information
239:16 - about this package so here we see a
239:19 - description
239:20 - let's actually make this bigger
239:22 - description
239:24 - library to read write excel
239:27 - files with all these formats
239:30 - so this is the library that we're going
239:32 - to be using in the same way as we did
239:34 - before
239:35 - we're going to copy that command and
239:37 - execute it from pycharms
239:39 - integrated terminal so from here i'm
239:42 - gonna
239:43 - execute this pip command and install
239:46 - our module and as you see
239:50 - successfully installed open pi xl
239:53 - and this is the version of the module
239:55 - that we installed and
239:57 - in external libraries site packages you
240:00 - should be able to see
240:01 - our open pi excel package
240:05 - and now because the package is available
240:07 - locally i can do
240:08 - import and open
240:11 - pi excel again i get a suggestion from
240:14 - pycharm because the module is there
240:16 - and now we are able to use that package
240:19 - for our application and one small note
240:21 - here if you're wondering
240:23 - why there are some packages with
240:26 - basically a dot
240:27 - inside and some without these are the
240:30 - packages
240:31 - that we install python packages and we
240:33 - know that because there's this
240:35 - init python file inside and the ones
240:38 - without the dot they're just folders
240:42 - with bunch of files inside but they're
240:44 - not python packages so to say
240:46 - and inside some of those packages we see
240:50 - other packages as well with their own
240:52 - init file
240:53 - so basically hierarchy of multiple
240:56 - packages
240:57 - and at this point i'm going to say that
241:00 - the word
241:00 - library basically describes package
241:04 - that includes multiple other packages so
241:07 - basically which has a hierarchy of
241:09 - packages
241:10 - so we have module which is basically
241:12 - just one python file
241:14 - that we can use in our project then we
241:16 - have package which is
241:18 - a hierarchy of multiple modules with an
241:21 - init python file inside and then we have
241:24 - library which is basically
241:26 - multiple packages together in a
241:28 - hierarchy
241:29 - just like we see right here so note the
241:32 - difference
241:32 - so you don't get confused when you see
241:34 - library package and module
241:36 - especially if used interchangeably
241:42 - great so now we have our module in place
241:46 - so let's use it now to read our
241:48 - spreadsheet file
241:49 - and again you basically have to know the
241:51 - function names
241:52 - to do that if you don't you can do dot
241:55 - and get suggestions
241:57 - and load workbook is actually the
241:59 - function that we need
242:00 - in order to read our spreadsheet file so
242:02 - i'm going to choose this
242:04 - function and obviously we need to tell
242:07 - this function
242:08 - which file it should read so as a
242:10 - parameter
242:11 - we're going to say please
242:14 - load inventory file and we even get a
242:17 - suggestion because we have this
242:18 - inventory file here
242:20 - and there you go now this function will
242:22 - load the workbook and all its contents
242:25 - and later we obviously want to do
242:27 - something with that content
242:29 - so in order to be able to do that we
242:31 - need to save it first as a variable
242:33 - and let's actually call it inventory
242:36 - file like this and this will give us the
242:40 - file contents
242:41 - now let's actually open that file again
242:45 - and let's see exactly what we need so we
242:48 - can have multiple
242:49 - such sheets basically per file so we
242:52 - need to tell the program which one it
242:54 - should use
242:54 - exactly so for example if this was
242:57 - called a product list
243:01 - you would use that name but we're gonna
243:02 - go with sheet
243:04 - one so we're gonna use that name
243:06 - basically
243:08 - and we're gonna grab that using
243:12 - following syntax and you remember this
243:14 - syntax probably from using a dictionary
243:16 - so this will give us this one specific
243:19 - sheet and all the information inside
243:21 - and we can also save that into a
243:23 - variable so let's actually call that
243:26 - product list so now we have read the
243:29 - whole file then we have read this
243:32 - specific sheet of that file
243:33 - and now we have all this information in
243:36 - that variable
243:37 - so now we can read any of those values
243:39 - and
243:40 - do calculations etc using that variable
243:46 - so let's get to our first task and the
243:49 - first task is basically to calculate
243:52 - how many products we have per supplier
243:56 - and then list the names of the suppliers
243:59 - with that
243:59 - respective number of products so let's
244:02 - go back and do that
244:05 - so the results what we want to get is
244:07 - basically
244:08 - products or number of products
244:11 - per supplier right that's basically what
244:15 - we want to get as a result
244:16 - so we're going to create that variable
244:18 - and we're going to set it
244:20 - to an empty dictionary so
244:23 - by the end our program should give us
244:25 - something like this
244:27 - a dictionary where the name of the
244:29 - company is the key
244:30 - and the value is basically product count
244:34 - for that company and since we have
244:37 - three suppliers or three companies we're
244:39 - gonna end up with
244:40 - a dictionary with three key value pairs
244:43 - per
244:44 - company so we're starting with an empty
244:47 - dictionary for products per supplier and
244:50 - now let's see how we can
244:51 - programmatically calculate this
244:55 - first of all what we need is we need to
244:58 - go through each of these lines basically
245:01 - so we have these rows so we need to go
245:03 - through each and every
245:05 - row in order in sequence and we need to
245:09 - get
245:09 - or check a supplier name for that row
245:13 - and you remember whenever we execute a
245:16 - logic
245:16 - on multiple values over and over again
245:20 - so basically same logic or same function
245:22 - gets executed
245:24 - for multiple different values for a
245:26 - number of times
245:28 - that's basically a use case for a loop
245:30 - right so we're looping
245:32 - through those rows and we're doing the
245:35 - same thing
245:36 - per row which is getting the name of the
245:38 - supplier now
245:39 - as you also remember loops have
245:42 - conditions right
245:43 - we need to tell the loop how many times
245:45 - it should execute
245:47 - that specific logic and if we check our
245:49 - file here
245:50 - how many times we want to execute the
245:52 - logic the answer is
245:55 - as many times as the number of products
245:57 - so
245:58 - if we scroll down we have 74
246:02 - products so we need to do that 74 times
246:07 - for each product so basically as many
246:10 - times
246:10 - as the number of product and obviously
246:12 - we want this program to work for
246:14 - any spreadsheet file right with any
246:16 - number of products so we need to
246:18 - calculate or we need to read that value
246:21 - also from the file
246:22 - so basically we need to read how many
246:24 - products are on this list
246:26 - so let's see how we can do that first of
246:28 - all we're using
246:29 - for loop to execute the logic for
246:32 - specific
246:33 - number of times and if you remember from
246:36 - for loop syntax
246:37 - four then we have the specific item
246:40 - so what is an item in our case our item
246:44 - is a row right product row is going to
246:47 - be an
246:47 - item of iteration so looping basically
246:51 - so we can call our item
246:55 - products row and then comes in
246:59 - and now we need that condition how many
247:03 - times and again this should be generic
247:06 - so we need to calculate or we need to
247:08 - read
247:09 - the number of lines here number of rows
247:11 - here from the file
247:12 - and the way we can read that is remember
247:16 - we have all the information we need in
247:17 - that
247:18 - one specific variable which is product
247:20 - list
247:22 - and that variable has
247:25 - the value for number of rows which is
247:28 - called
247:29 - max row now how do i know that
247:32 - max row attribute is available for
247:35 - product
247:36 - list i basically just looked it up on
247:38 - the documentation of the module
247:40 - and as i previously also mentioned
247:42 - whenever you're using a
247:43 - module this module will have a
247:45 - documentation so
247:47 - if you need some functionality if you
247:49 - need some values
247:50 - you can basically just search inside the
247:53 - documentation
247:54 - which functions and variables are
247:56 - available to
247:57 - get the functionality or values that you
248:00 - need
248:01 - and we can actually test it we can print
248:04 - it out
248:05 - like this
248:08 - and as you see here 75 so basically max
248:12 - row will always give us the number of
248:15 - lines or number of rows
248:17 - in that specific sheet so we know how
248:20 - many times to
248:21 - iterate now whenever we're providing a
248:23 - specific
248:24 - number in a for loop like 75 for example
248:28 - in this case we need to
248:31 - put that number in a range like this
248:35 - so we can't just say 70 or in this case
248:38 - max row now why do we need a range here
248:41 - and why is number just not enough
248:45 - because the for loop is for iterating
248:48 - over a list and the range will create
248:51 - a list of numbers to iterate through
248:54 - in our case range of 75
248:58 - will create a list of numbers or
249:00 - sequence of numbers
249:01 - from 0 to 74. and with that we're going
249:04 - to have
249:05 - a valid for loop where for each
249:08 - item in this list of numbers
249:11 - some logic will be executed so that's
249:13 - why we need a range here
249:15 - and now there's one more thing that we
249:17 - need to fix we go back to our
249:19 - spreadsheet
249:20 - you see that the first row so this is
249:23 - going to be the first row basically
249:25 - does not actually include the product
249:27 - information
249:28 - it just includes the titles for each
249:31 - column
249:32 - right so we actually do not want to read
249:35 - this line we want to skip it and we want
249:38 - to start from the second row
249:41 - so instead of starting for loop from the
249:44 - first row
249:45 - we want to start it from the second row
249:48 - and in order to
249:49 - tell python to start at row 2
249:52 - in the range function we're going to
249:54 - pass first parameter
249:56 - 2. so basically this will give us a new
249:59 - range of numbers
250:00 - starting from 2 instead of starting from
250:02 - 0. and since we're using those
250:04 - numbers in the range as an index for the
250:07 - rows
250:08 - the first number is going to be 2 so
250:10 - we're going to start iterating from the
250:12 - second row
250:13 - so this will be the start point and this
250:15 - will be the end point
250:17 - so basically from here to the end
250:21 - now there are two things specific
250:24 - to a range that you should be aware of
250:28 - first of all when we do not
250:32 - provide the start index basically
250:36 - the start number in the range by default
250:39 - it's actually
250:40 - zero so it's not one but it's zero
250:43 - and obviously we don't have a line zero
250:46 - here
250:47 - so if we executed it with the default
250:49 - one
250:50 - we would get an error so that's one
250:53 - thing to consider that
250:54 - range actually by default starts at 0
250:57 - and not 1. but for us it doesn't matter
251:00 - because we're skipping the first one
251:02 - anyways and we're starting from line 2
251:04 - because our spreadsheet doesn't have
251:07 - line 0
251:08 - obviously another specific of the range
251:10 - is that
251:11 - the second value here basically the last
251:15 - number of execution in the loop in our
251:18 - case this is going to be 75
251:20 - because we have 75 lines and we printed
251:23 - that out here
251:24 - that number is actually exclusive
251:27 - it's not inclusive that means that
251:31 - the range will execute from line 2
251:34 - to 75 exclusive so basically
251:38 - till here this line will not be included
251:42 - in the loop
251:43 - again that's a specification of the
251:46 - range
251:47 - which we need to fix and
251:50 - basically want to tell you know what we
251:52 - want that iteration
251:53 - including the last number as well
251:56 - including that max row
251:58 - and a simple fix for that is going to be
252:00 - to
252:01 - do plus one here so basically whatever
252:05 - the max row is we want to include that
252:07 - one as well
252:08 - so we want to add one to it so now we
252:11 - have a range
252:12 - starting from two and ending in 76
252:16 - exclusive so obviously the 76th
252:19 - line will not be red and
252:22 - this will now give us a range that we
252:25 - need
252:28 - and now that we have condition for the
252:30 - loop and we have set
252:32 - how many times it should execute let's
252:34 - actually execute the logic
252:36 - itself so what is the first information
252:38 - we need from that
252:40 - product row for each row we basically
252:42 - need the supplier name
252:44 - so that we can increment or start
252:46 - counting how many
252:47 - products this supplier has so we need
252:50 - this
252:51 - one two three fourth column and the
252:53 - value in that fourth column
252:55 - for each and every row right
252:58 - let's go back to editor how do we get a
253:01 - value
253:02 - in the cell you have to imagine when we
253:04 - iterate we have
253:05 - one row per iteration
253:09 - so right here we actually have this
253:11 - product row which is just
253:12 - one row and we have four columns here
253:15 - and we want
253:16 - value in this specific cell and
253:19 - we can get it using first of all product
253:22 - list
253:22 - because again we have all the
253:23 - information here so in this list
253:27 - we need a cell right we need a value of
253:30 - a
253:30 - cell so that's the name of the function
253:33 - and the cell basically takes two
253:36 - parameters again product list
253:39 - contains the whole sheet here so the
253:42 - whole list
253:43 - with all the rows and columns and we can
253:46 - get a specific
253:48 - cell value so whatever we are doesn't
253:51 - really matter
253:52 - from that variable by providing two
253:55 - values
253:56 - the row number and the column number
253:59 - that's it
253:59 - so row nine column one basically will be
254:03 - this specific value row five column
254:07 - four will be this specific value so
254:10 - for each iteration we're gonna do
254:13 - exactly
254:14 - that so for our case the supplier is
254:16 - always column four
254:18 - and the row is dynamic because we are
254:21 - iterating
254:22 - and therefore we're going to use
254:25 - whatever row we're at at the current
254:28 - iteration
254:29 - so that's the first parameter and column
254:32 - 4 as i said and this will give us
254:36 - the supplier name for each and every
254:40 - row so we can grab that value like this
254:42 - and this is going to be supplier
254:46 - name so we can save it in a variable
254:50 - as a next step we're going to start
254:52 - building
254:53 - how many products each supplier has
254:56 - we're going to start building a
254:58 - dictionary
254:59 - with the name of the supplier and then
255:01 - how many products they have
255:03 - so we're going to be building this
255:05 - dictionary here
255:06 - so this is a reminder now for what i
255:09 - said previously
255:10 - that you don't need knowledge of math in
255:13 - programming
255:14 - rather you need logical thinking right
255:16 - so you're going to get tasks like this
255:18 - where you have to
255:19 - basically logically decide how you are
255:22 - going to do a certain task
255:24 - and think all this through right so
255:27 - programming is more about logic rather
255:29 - than pure calculation or math
255:32 - which is actually more interesting and
255:34 - cooler and that's exactly
255:36 - what we're going to need in this example
255:38 - we're going to need some
255:39 - logical thinking to basically build this
255:42 - application
255:43 - so bear with me on this one the first
255:45 - thing we need to check here
255:47 - so think about this iteration on the
255:49 - first time
255:50 - and second time the first time the list
255:53 - or the dictionary is actually
255:54 - empty so we want to add the first
255:58 - supplier to the list right away right
256:01 - so we're gonna grab that and the syntax
256:05 - for
256:05 - adding a new entry in a dictionary is
256:09 - like this where we have a key
256:14 - and a value here so basically what we
256:17 - want to end up with
256:18 - is supplier name like a
256:21 - company and
256:25 - number of products for that supplier
256:27 - that's the
256:28 - dictionary that we want to end up with
256:30 - then it's going to be
256:33 - bbb company and so on
256:38 - so the very first supplier goes directly
256:40 - into the list
256:42 - and we're going to need the name of that
256:44 - supplier we don't know what it's going
256:45 - to be
256:46 - so name as a key
256:50 - and value is going to be
256:53 - 1 at the beginning right this is the
256:55 - very first iteration
256:57 - so after the first it iteration we're
256:59 - gonna have
257:00 - the first company name supplier name and
257:03 - count one for that on the second loop
257:06 - second iteration basically if
257:10 - the next line is a different supplier
257:14 - like here for example then a new entry
257:17 - will be added
257:18 - because we have a new key now with
257:21 - count one right so now we're gonna have
257:24 - company a
257:25 - with one product company b with one
257:27 - product
257:28 - now what happens when on the next
257:30 - iteration
257:31 - we get company a again right
257:35 - what we want to happen is
257:38 - company a the product count to
257:42 - increase to two right because now we
257:44 - found another product that
257:46 - is supplied by the same company however
257:49 - with this land we are actually
257:50 - overriding and setting it
257:52 - back to one so how do we make sure that
257:56 - number of products gets incremented
257:58 - instead of always setting it to one
258:00 - what we're going to do is before we
258:03 - execute this line
258:04 - we're going to check is it a new
258:06 - supplier or
258:07 - an existing one because that makes a
258:09 - difference
258:10 - so how do we know if it's a new one or
258:13 - an existing one
258:14 - we can look that name up in the
258:17 - dictionary
258:18 - if we have already edited that name in
258:20 - the dictionary then it's going to be
258:21 - there
258:22 - and we can do that very easily again
258:25 - with the syntax
258:26 - if supplier name in
258:30 - the dictionary it's actually very
258:33 - readable syntax that says is the
258:36 - supplier
258:36 - already added to the list or is it a new
258:39 - one
258:40 - so if this is true again
258:43 - remember if conditional so if this
258:47 - is true statement if the supplier name
258:50 - is already there
258:51 - then it is an existing one so we need to
258:54 - increment
258:55 - the product number instead of setting it
258:57 - to one
258:58 - so instead of assigning a new value we
259:01 - want to
259:02 - grab that value the existing one and
259:05 - basically add
259:06 - one to it right just increment by one so
259:09 - getting a value from a dictionary you
259:12 - probably remember the syntax already
259:14 - using the key and we can save it into
259:17 - a variable let's call it current
259:22 - number of products
259:26 - like this remember we're using a key
259:29 - in order to get the value and the key is
259:31 - the supplier name
259:32 - value is the product count so this will
259:34 - give us
259:35 - the current number of products on the
259:38 - first iteration this will be one
259:39 - or after the first iteration we're going
259:41 - to have one product for that specific
259:43 - supplier
259:44 - and if we already have that supplier
259:49 - in the dictionary we want to increment
259:52 - the number of products for that specific
259:54 - supplier by one
259:56 - because we just found another product
259:58 - from that supplier
259:59 - so we want this value to now be
260:03 - plus one right so current number of
260:06 - products
260:07 - plus one so that's the new value that we
260:10 - want
260:11 - for the existing for this current
260:14 - supplier and how do we assign it back
260:17 - to the dictionary again we grab that
260:21 - and assign it so as you see
260:25 - taking the value from the dictionary has
260:27 - the same syntax as
260:29 - setting that value in the dictionary
260:32 - in fact we could actually use a shortcut
260:35 - here
260:36 - so instead of current numproducts we
260:38 - could just
260:39 - take that value and add plus to it and
260:41 - then
260:42 - set it back as a new value and
260:46 - this will basically just give us a
260:47 - one-liner for the logic
260:50 - depends on the taste whether this looks
260:52 - nice or not
260:53 - or whether it's better to have a new
260:55 - variable and
260:56 - increment the value like this let's
260:58 - actually leave it like this
261:00 - so this logic will take care of adding a
261:03 - product count
261:04 - every time we find another product for
261:05 - the same supplier
261:07 - however now we have to decide what
261:09 - happens
261:10 - when it's a new supplier so if this
261:13 - condition
261:14 - is false if the supplier name is not on
261:16 - the list
261:17 - and this is going to be the case on the
261:18 - very first iteration
261:20 - as well because the dictionary is
261:23 - basically
261:23 - empty so there are no supplier names and
261:26 - for that case
261:28 - else we're going to do what we had
261:32 - before
261:32 - which is just setting that number to one
261:35 - right this is going to be the first
261:37 - value so this will do
261:39 - two things basically it will create
261:42 - a new entry in this dictionary for this
261:44 - new supplier
261:46 - and it will set the product count number
261:49 - to one for that new supplier and that's
261:52 - it that's actually our logic
261:54 - and let's actually try this out and
261:56 - print it out
261:57 - so right here i'm gonna print
262:01 - adding a new supplier
262:04 - and this is going to happen three times
262:06 - because we have three suppliers
262:08 - so we can safely print it because just
262:10 - gonna happen three times
262:12 - there is one more thing we need to fix
262:14 - here and that is
262:16 - getting the value from the cell so if we
262:18 - actually
262:19 - execute this now let's comment this out
262:21 - and actually print out
262:23 - what the supplier name here is
262:27 - let's actually get rid of this line we
262:29 - don't need this
262:30 - and run the program you see here we have
262:34 - cell information so it's not actually
262:36 - the
262:37 - the value the name of the supplier but
262:40 - it's just
262:41 - the object cell and the reason for that
262:44 - is because we're accessing a cell but
262:47 - we're not actually extracting or getting
262:49 - the value out of it
262:51 - and we can do that using this value
262:54 - attribute on that complete object
262:58 - again something that you can look up in
263:00 - the documentation of
263:02 - this open pi xl module
263:05 - so now let's run it again and now we
263:08 - have
263:09 - the actual values of that cell
263:12 - and this will take care of that small
263:16 - problem and now we are ready to
263:19 - execute our
263:23 - program and after the for loop actually
263:26 - let's print out the
263:28 - dictionary because we want to see the
263:31 - results of the dictionary that we are
263:32 - building here
263:34 - and i'm going to execute it now
263:37 - and there you go first of all we have
263:39 - three times adding a new supplier
263:42 - because we have three suppliers and this
263:44 - is the
263:45 - resulting dictionary and it looks
263:48 - actually very good
263:49 - first we have company a because this was
263:53 - the first on the list
263:55 - and we have number of products that were
263:57 - counted
263:58 - for that company then we have the second
264:01 - one
264:02 - with number of products and the third
264:04 - one
264:05 - so it looks like our program did exactly
264:08 - what we wanted
264:12 - so that takes care of the first exercise
264:15 - now i want to note here
264:17 - one small thing which is an alternative
264:21 - syntax for
264:21 - getting values from a dictionary which
264:24 - is actually
264:25 - a more recommended way of doing it which
264:28 - is instead of
264:29 - having these brackets here
264:32 - to have a get method right
264:36 - to use a get function
264:40 - with the key name so now you see the
264:44 - difference between those two
264:46 - so this is setting the value of that key
264:49 - again remember key is this one here and
264:52 - this is the value
264:54 - so we are accessing the value of the
264:55 - dictionary using that key
264:57 - and get function is actually
265:01 - another way of grabbing this value out
265:05 - of a dictionary using the key name
265:07 - again if i execute this i should see
265:11 - the same result
265:14 - after the first exercise basically we
265:16 - see from which company
265:18 - from which supplier we have the most
265:20 - product or the highest number of
265:22 - products now in the second exercise
265:24 - we're going to calculate
265:26 - the total inventory value per supplier
265:29 - meaning in our list for each product we
265:32 - have
265:33 - number of units for the product and the
265:35 - price so basically for
265:36 - each supplier we want to calculate how
265:39 - much is the total
265:40 - value of inventory of their products
265:43 - of all their products and again as a
265:46 - result
265:47 - we want to create a dictionary that
265:48 - basically tells
265:50 - us that value per company let's go ahead
265:53 - and do that
265:55 - so this was calculation
266:00 - calculation for number
266:03 - of products per
266:07 - supplier
266:12 - and here we're going to give us some
266:14 - space
266:18 - and do calculation
266:21 - total value per
266:25 - supplier or total value of inventory
266:31 - per supplier that's what we want to
266:33 - calculate
266:34 - so just like we did before we're going
266:36 - to create a new dictionary now
266:38 - and we're going to call it appropriately
266:41 - total value
266:44 - per supplier
266:48 - and start with an empty dictionary
266:52 - again for starting in an easy way let's
266:55 - consider the first
266:56 - very first iteration for the first
266:58 - supplier
267:00 - how are we going to calculate for the
267:02 - first supplier
267:03 - for the first product so i'm going to
267:07 - take this new dictionary and
267:12 - with our familiar syntax i'm gonna do
267:16 - supplier name so that's gonna be our key
267:18 - and the value
267:20 - of the very first iteration for the
267:22 - first product
267:23 - is going to be inventory
267:27 - times price so for the first product
267:31 - we're going to calculate how much
267:33 - or how many of the product items we have
267:36 - and
267:36 - number of price right that will give us
267:39 - value of the total inventory for
267:41 - that one specific product and that means
267:44 - we need those two values
267:47 - right now we're just getting the value
267:49 - of the supplier
267:51 - so we need inventory
267:58 - i'm actually going to copy this so we
268:01 - need
268:02 - cell for product row and
268:05 - column inventory is on column two
268:09 - and value so whatever the product row is
268:13 - going to be so for each product
268:14 - basically for each row
268:16 - we need always the second column so all
268:18 - these values here
268:20 - and then we need price which
268:23 - going to be product list cell
268:27 - and we are looking for
268:32 - the third column for every row
268:36 - number three and value
268:40 - so now we have inventory and price per
268:43 - product and the way to calculate
268:46 - value is basically inventory that's the
268:49 - number of
268:50 - product items times price very easy
268:53 - that will give us the first value
268:57 - for the first supplier now again the
269:00 - same way
269:01 - if we are getting a new supplier so
269:04 - basically in the next iteration
269:05 - if it's a new supplier then this line
269:08 - will get executed and everything is fine
269:11 - however if it's an existing supplier
269:13 - that we already have in the dictionary
269:15 - then we have to add to that previous
269:18 - value right instead of setting a new one
269:23 - so we're going to do very similar logic
269:26 - as we did here
269:27 - so we have the supplier name we're
269:29 - checking
269:30 - is it a new supplier or an old one an
269:33 - existing one
269:35 - this time in our new dictionary
269:40 - and if it is we're gonna
269:43 - grab that old or existing value
269:47 - again using this get syntax here
269:51 - existing value now is hundred we want to
269:55 - add to that hundred right
269:57 - so we're gonna grab that value this is
269:59 - going to be current
270:01 - total value
270:05 - and then we're going to add to that
270:08 - current total value
270:12 - the inventory value for the current
270:15 - product and assign it back to
270:19 - our dictionary
270:23 - now our variable names a little bit
270:26 - long so the code kind of looks a bit
270:29 - cluttered
270:30 - but it's easy to read and descriptive so
270:34 - you can also go for shorter variable
270:36 - names to have a cleaner code
270:37 - again matter of taste i usually name the
270:40 - variables
270:41 - something descriptive something that
270:43 - basically really
270:44 - differentiates or says what the value is
270:46 - about
270:48 - and that basically takes care of
270:52 - existing suppliers or the suppliers that
270:55 - we already
270:56 - have in the dictionary else we do
270:59 - this and this is complaining about
271:03 - too many blank lines so let's fix that
271:06 - and
271:07 - that's basically our logic again to go
271:09 - through it once
271:10 - for new suppliers again this is going to
271:12 - happen three times because we have three
271:14 - suppliers
271:15 - we are basically setting the total
271:18 - inventory price or inventory value for
271:20 - that specific product
271:22 - because remember we are iterating
271:24 - through products
271:26 - and then every time a new product
271:30 - iteration happens for the same supplier
271:32 - we basically just
271:33 - add an inventory price or total value
271:36 - for that specific product
271:38 - for what we already have in the
271:41 - dictionary
271:42 - for that specific supplier so now
271:45 - let's again print out
271:49 - our dictionary
271:54 - let's actually print both values
271:59 - so the first dictionary is this one
272:02 - right here
272:03 - supplier and number of products second
272:06 - one
272:06 - is going to be supplier and total value
272:09 - of all the products they have in the
272:12 - inventory
272:13 - with us execute and there you go we have
272:16 - both dictionaries printed here and here
272:19 - you see
272:20 - for each company we have the value
272:23 - in price basically right here the value
272:27 - for the total inventory of all the
272:29 - products they have
272:31 - on this list and we see that value
272:35 - per supplier and the values are
272:38 - decimal numbers with cent precision so
272:41 - 95
272:42 - cents 47 cents because the prices
272:45 - are obviously like this as well and if
272:48 - you're wondering this
272:49 - comma here is actually a german format
272:52 - for number precision so this is going to
272:55 - be actually equivalent to
272:57 - english dot and we don't have to worry
273:00 - about this actually because
273:01 - python reads it and
273:05 - interprets it correctly so no problem
273:08 - with
273:08 - different language formats so that takes
273:11 - care of
273:12 - our second calculation
273:16 - now the third logic we're going to write
273:18 - is basically printing out
273:20 - all the products that have inventory
273:23 - less than 10
273:25 - like this ones here for example so
273:28 - the logic for that is actually going to
273:30 - be pretty easy
273:31 - what we need as a result is again a
273:34 - dictionary
273:35 - let's call it products which have
273:39 - inventory under 10
273:43 - like this and the value in the
273:45 - dictionary
273:47 - should be the product number
273:50 - which we have in the first column and
273:53 - the inventory count so let's get rid of
273:56 - these print statements
273:58 - and let's do calculation
274:01 - or we can do logic products
274:05 - with inventory less than
274:09 - 10. so basically as i said for each
274:12 - product
274:13 - which has inventory under 10 we want to
274:15 - print out
274:16 - or we want to save in a dictionary the
274:19 - product number
274:19 - and the inventory count so
274:23 - we have the inventory count already the
274:26 - value
274:27 - from the cell but we don't have the
274:30 - product number
274:30 - we're not accessing it so let's actually
274:33 - do that
274:35 - product number
274:40 - and we already know how this works
274:43 - this is going to be the first column
274:46 - right
274:47 - this one here and this gives us
274:50 - product number and now in our dictionary
274:55 - products under 10
274:59 - we want to add value like this product
275:02 - number
275:04 - and it's going to be set to value of the
275:07 - inventory
275:09 - like this however we don't want it for
275:11 - every
275:12 - product we wanted only for products with
275:14 - inventory less than 10
275:17 - and that's going to be an easy if
275:19 - conditional here
275:20 - if inventory again remember
275:23 - this logic all this logic happens for
275:27 - each product row right so all these get
275:30 - executed
275:30 - for each of these rows so basically we
275:33 - have inventory number
275:35 - on each iteration for each specific
275:37 - product
275:38 - and that's why we can just say if
275:41 - inventory is less than 10
275:44 - so if the value on that specific row is
275:47 - less than 10
275:48 - we want to add that product
275:52 - the current product that we are
275:54 - iterating on
275:55 - on the list and set the value of
275:58 - inventory as well
275:59 - again we have some complaining here
276:01 - because of the lines
276:03 - and this will be the logic basically
276:06 - and a use case for this type of
276:09 - calculation would be
276:10 - if we find products that have inventory
276:13 - which are less than 10
276:15 - means we need to reorder them right
276:17 - because they're going to get out of
276:18 - stock soon
276:19 - and now at the end
276:23 - let's print the list of all the products
276:25 - that have
276:26 - inventory less than 10. so i'm going to
276:29 - execute it
276:30 - and here we have the product number and
276:34 - inventory count so we have three
276:36 - products basically
276:38 - which have inventory less than 10 and
276:41 - let's actually
276:42 - check that product number 25 right here
276:46 - which has inventory of seven and product
276:50 - number
276:51 - 30 inventory of six
276:54 - and the third one as well now you're
276:56 - probably wondering why we have this dot
276:58 - zero here because by default those
277:00 - values are interpreted as
277:03 - float numbers and not integers if we
277:05 - wanted to we can actually fix that
277:08 - using the integer function
277:13 - in both cases like this
277:16 - let's execute it again and we have the
277:20 - integers and not floats
277:24 - and finally as a last exercise what
277:27 - we're going to do is we're going to
277:29 - actually
277:29 - add some value inside that spreadsheet
277:32 - till now we have been reading the values
277:34 - and doing some calculations and just
277:36 - printing the result
277:37 - on the terminal as the last exercise
277:40 - we're actually going to create a new
277:42 - column here for every row and we're
277:44 - going to
277:45 - calculate basically the total price of
277:48 - inventory
277:49 - right the number of units times the
277:51 - price and we're going to
277:53 - basically set the value for each product
277:56 - inventory multiplied by price so
278:00 - how do we add a column or how do we make
278:03 - changes
278:04 - to a file it's actually pretty easy
278:07 - the same way as we were grabbing the
278:09 - value from this
278:10 - file and basically reading the values we
278:12 - can
278:13 - add values to it and add columns and
278:15 - rows etc
278:17 - so to add a fifth column
278:20 - we're gonna do product list cell
278:25 - product row this is going to be the
278:27 - number of the row and
278:28 - a column number so the same way we
278:31 - accessed
278:32 - the cells for all other values we can
278:35 - basically
278:36 - access the cell on column five
278:39 - which has an empty value right so
278:43 - we're not actually creating a new column
278:45 - we're just grabbing
278:46 - a value of a column five which happens
278:50 - to be
278:50 - empty and we are overriding that value
278:52 - and we could
278:53 - do the same actually for any other
278:56 - columns here right we can overwrite all
278:57 - these values
278:58 - if we wanted to so that's basically what
279:00 - we're doing
279:01 - so we're grabbing that cell and we can
279:04 - now save it into a variable
279:06 - let's actually call it inventory
279:10 - price so now that cell
279:14 - is saved into that variable so we can
279:16 - reference it
279:17 - and note here that i didn't add dot
279:20 - value at the end
279:21 - because if we want to update the cell
279:24 - we need the whole cell object right so
279:27 - that we can
279:28 - actually set a value on that so how do
279:30 - we set a value
279:31 - for that specific cell so again note
279:34 - that this is
279:35 - iteration so for each product row
279:38 - the value will be set so how do we set
279:42 - the cell value i'm just going to grab
279:44 - this
279:45 - variable here inventory price which is
279:47 - representing the cell
279:49 - in column five for each iteration
279:52 - and right here at the end because this
279:54 - is our last exercise
279:55 - let's write this is a logic
279:59 - or basically add value for
280:02 - total inventory price
280:06 - and the way we set the value in a cell
280:10 - is dot value equals
280:13 - and the calculation for that is actually
280:16 - very easy we already did it here
280:18 - inventory times the price for that
280:21 - specific product
280:23 - and that's it so we're using that dot
280:25 - value here
280:26 - in order to set the value instead of
280:28 - grabbing the value
280:29 - and that will actually update and
280:33 - add this calculation a result of the
280:36 - calculation
280:37 - on each line on this column but note
280:40 - that this will only
280:41 - change the value in a temporary file but
280:44 - it's not going to save
280:45 - anything right so what we want to do at
280:48 - the end
280:49 - if we want this change to persist to
280:52 - actually be
280:53 - saved we want to explicitly save the
280:56 - file
280:56 - so for example if i manually did
280:59 - something here added some value
281:01 - i would need to save it here as well
281:03 - right so that's exactly what we need to
281:05 - do
281:05 - here but programmatically using python
281:09 - so how do we save a file using python
281:11 - again
281:12 - this package or this module that we use
281:15 - here
281:16 - also gives us a function that we can use
281:19 - to save the file
281:20 - and since we're doing an operation on a
281:22 - file and not a sheet here
281:24 - we're going to grab that variable in
281:26 - file
281:27 - and here at the end we're going to call
281:31 - a save function on it and this will save
281:34 - the file changes
281:35 - however we're not overriding the same
281:37 - file the existing inventory file
281:40 - we're creating a new one and because of
281:42 - that we need to provide
281:44 - a name of the new file that is going to
281:46 - be created
281:47 - with the save function and we're going
281:50 - to call that
281:52 - file let's say inventory
281:56 - with total value
282:00 - and extension
282:04 - the same extension as we have here so
282:07 - this line will now save the changes and
282:10 - create a new file
282:12 - from the original one which has these
282:15 - values generated basically
282:17 - so now that we are done with the fourth
282:20 - exercise let's actually print out
282:22 - everything
282:30 - that we've done so far i'm gonna take
282:33 - all those values
282:50 - so this is going to be execution of all
282:53 - our logic
282:54 - printing these three dictionaries here
282:56 - and then updating
282:58 - the spreadsheet file and saving it into
283:00 - a new file
283:02 - so with this let's actually execute our
283:05 - program and see what happened
283:08 - first of all we have all those three
283:10 - dictionaries listed here
283:12 - or printed here with the values
283:15 - and if we pull this aside
283:19 - here you see a new file got generated
283:21 - with the name
283:22 - inventory with total value and if we
283:25 - open this file
283:26 - we should see that for each row a new
283:30 - column was generated and filled with
283:32 - values
283:33 - which is calculated for each product's
283:35 - inventory and price
283:38 - so that's basically our project that's
283:41 - how you work with
283:42 - files in python specifically with
283:45 - spreadsheet
283:46 - files and as i said at the beginning
283:48 - this could be actually very useful
283:50 - automation logic when you're working at
283:53 - a company where there are lots of
283:54 - excel files or spreadsheet files that
283:57 - employees have to work with
283:59 - and manually update stuff inside
284:05 - in this part we're going to learn the
284:06 - concept of objects and
284:09 - classes in python and generally object
284:12 - oriented
284:13 - let's consider an example of an
284:16 - application with
284:17 - lots of users for example linkedin right
284:19 - we have
284:20 - users and each user will have some
284:23 - information for example
284:25 - email address
284:31 - name of the user
284:40 - password
284:42 - maybe a current job title
284:56 - work experience a set of skills and so
285:00 - on
285:00 - right so each user will have all this
285:03 - information but
285:04 - obviously the actual values the actual
285:06 - information will be different
285:09 - for each user in addition to that users
285:12 - are able to do something with their own
285:14 - information right
285:15 - so for example a user can change their
285:17 - password
285:22 - change their current job title add a new
285:25 - skill
285:34 - and again basically do stuff with their
285:37 - own
285:38 - personal information and our program
285:40 - will be
285:41 - able to handle this user information
285:44 - plus
285:44 - user changing their information right so
285:47 - this will be
285:48 - user data and in order to do something
285:52 - so to perform some action we would have
285:54 - functions for that right
285:56 - so all of these will actually be
285:59 - functions however as i mentioned
286:03 - every user will have their own data and
286:05 - whenever a new user basically registers
286:08 - for an application
286:09 - all these data should be gathered for
286:11 - that new user
286:13 - and saved in the application so
286:15 - basically that means that
286:17 - in our program we need some way to
286:20 - define
286:20 - kind of a blueprint for a user for all
286:23 - the data
286:24 - user information and user behavior right
286:28 - things that the user can do in the
286:30 - application
286:31 - because if we have thousand users in our
286:33 - application obviously we can't
286:35 - write the same logic and same variables
286:39 - thousand times right we want to have a
286:41 - blueprint once
286:43 - and then we can use the blueprint for
286:45 - all those thousand users
286:47 - and that blueprint for a user is called
286:50 - a class
286:51 - and the specific implementation of that
286:54 - blueprint
286:55 - is called an object so think of this
286:58 - like a blueprint of a building right you
287:01 - can have a blueprint
287:02 - once which is like a general description
287:05 - of
287:06 - building with doors and windows and
287:08 - everything that
287:09 - every single building has and then the
287:12 - specific implementation
287:13 - of that blueprint will be the actual
287:16 - built ready buildings right
287:18 - so that's the same concept we're going
287:20 - to create a class
287:21 - blueprint for a user and the user class
287:24 - blueprint will define
287:26 - what information a user has
287:29 - and what actions user can perform in the
287:32 - application
287:33 - and object then will contain the actual
287:35 - information
287:36 - like this information right here
287:40 - for each specific user so let's clean
287:43 - all these up
287:44 - and let's now actually create class
287:47 - user
287:50 - so let's create a new file in our
287:52 - project and let's actually call it
287:55 - user dot pi so this is going to be our
287:58 - user class
288:00 - and inside that i'm going to paste in
288:03 - this piece of code that basically will
288:06 - represent
288:07 - data for the user and some behavior
288:11 - these pieces of data are also called
288:13 - attributes
288:14 - for that class so now let's turn
288:17 - all of these into a class so first of
288:20 - all
288:21 - we create a class using class special
288:23 - work and you also see the syntax
288:25 - highlighting
288:26 - and we're going to call that user
288:29 - and you know the syntax already for
288:30 - functions um etc
288:33 - with indentation so this is going to be
288:35 - where our class definition goes
288:37 - now note here the capital letter for u
288:39 - for user
288:41 - and lowercase user in the
288:44 - python file name so a standard
288:47 - convention is that we call classes with
288:50 - a capital letter
288:51 - and the file names are written in
288:53 - lowercase letters
288:54 - and now all of these should actually go
288:57 - inside that
288:58 - indentation right like this now we said
289:01 - that
289:01 - class is a blueprint for specific
289:04 - objects
289:04 - and blueprint cannot actually have
289:07 - specific
289:08 - values right so all these needs to
289:11 - be removed so in the blueprint we don't
289:13 - have any specific values we just have
289:15 - the attributes
289:16 - so basically we say this user will have
289:19 - an email
289:20 - name password and current job title the
289:24 - actual values of those attributes
289:27 - will be then set when we create an
289:29 - object from the blueprint
289:31 - however we need a function that will
289:34 - actually
289:34 - take those specific values and assign
289:37 - them
289:38 - to an object which is created from the
289:40 - blueprint
289:41 - and we're gonna create that function
289:44 - right here in the class
289:45 - and that function actually is called
289:48 - init with
289:50 - underscore or two underscores at the
289:53 - beginning and
289:53 - at the end a couple of notes here first
289:55 - of all you see the syntax highlighting
289:57 - just changed
289:58 - to this different color second note is
290:01 - that these
290:02 - functions that start with underscore in
290:04 - python are special functions
290:06 - so python basically gives them some
290:09 - special meaning so it knows
290:11 - exactly what this init function is and
290:13 - we also have to call it init we can't
290:15 - just call it whatever we want and final
290:18 - note is that this init function in
290:20 - python is
290:21 - something called a constructor again we
290:24 - have a blueprint and we're constructing
290:27 - objects from the blueprint and this init
290:29 - function
290:30 - the constructive function will help us
290:32 - construct
290:33 - objects from that user class and now
290:37 - for a function syntax you know that we
290:39 - use
290:40 - these brackets right and when i
290:44 - start writing the bracket you see that
290:46 - self
290:47 - got automatically created as the
290:50 - parameter here
290:51 - and the reason is as i mentioned python
290:54 - knows what the init function is and that
290:56 - it's a
290:56 - constructor so it knows that it needs
290:59 - this
291:00 - self as a parameter again self is also a
291:04 - special
291:04 - word in python it has a special meaning
291:07 - and it actually
291:08 - refers to this class here
291:11 - right this entire class if i hover over
291:15 - it
291:15 - you see self points to the user class
291:19 - and it will basically just help us
291:22 - access
291:22 - and reference all the attributes and
291:24 - functions within that class
291:26 - so it's for special usage within that
291:29 - user class
291:31 - and we're going to see examples of how
291:32 - to use that in a second
291:34 - now you can think of those attributes as
291:37 - variables
291:38 - within the class because they belong to
291:40 - the class right they describe basically
291:42 - what attributes or what characteristics
291:45 - this
291:45 - class has and in order to define that
291:48 - these
291:48 - variables belong to the class we need to
291:51 - use
291:52 - self here so
291:58 - and you see again syntax highlighting
292:00 - changed
292:01 - and the red line disappeared so
292:03 - basically we are defining
292:05 - that email name password and current job
292:07 - title
292:08 - belong to this class using this self
292:12 - keyword and now the last thing remaining
292:14 - in this constructor again remember
292:16 - constructor
292:17 - is to construct new objects so whenever
292:19 - a new object is created
292:22 - the specific values will be assigned
292:25 - to all these four variables right and
292:28 - those
292:28 - values those specific values will be
292:31 - passed into the constructor as
292:33 - parameters so email name
292:36 - password and current
292:40 - job title those four values
292:43 - must be provided to the constructor
292:46 - whenever we're creating
292:47 - a new object note that these
292:51 - names here could be different from this
292:53 - these are not the same these are just
292:55 - parameters and using these parameter
292:57 - values we are going to
292:59 - basically set the variables or
293:03 - attributes
293:03 - of the class like this
293:07 - and the warning is gone as well again as
293:10 - i mentioned this could be something else
293:12 - we could call it user email so it
293:15 - doesn't actually have to be
293:16 - the same it's just for convenience so
293:20 - this function will construct an object
293:23 - with parameters that we provide when we
293:26 - actually create it
293:27 - and we're going to see how to create an
293:29 - object later this is just the definition
293:32 - as remember when you define a function
293:33 - nothing actually happens
293:35 - until you call or you use that function
293:38 - so
293:38 - right here we're just defining that
293:40 - function so that we can use it
293:42 - later so constructor logic is
293:45 - done now we have these two functions
293:49 - that any user in our application
293:52 - can do right any user can change their
293:54 - password or change their job title
293:57 - and logically when change password
293:59 - happens
294:00 - by user basically user provides a new
294:03 - password
294:04 - in order to override the old one so the
294:07 - flow will be following
294:08 - the object will be created for the
294:11 - specific user
294:12 - so the initial data for that object will
294:15 - be provided
294:16 - so we'll have the user email name
294:18 - password and current job title
294:20 - and later at some point user may decide
294:22 - to change their password
294:24 - and their current job title and that
294:26 - means the
294:27 - initial data will be changed and that
294:30 - means
294:32 - that we're actually changing the
294:34 - attributes
294:38 - self.password with a new password
294:41 - right so logic will be like this
294:44 - now we have red lines here why because
294:47 - we need
294:48 - this self as a parameter first of all we
294:50 - also have that
294:51 - as um note right here
294:56 - so just like here we need to actually
294:58 - pass that self as a parameter that's
295:00 - just how it is
295:01 - because we need to access attributes
295:04 - of that class in that function and
295:07 - new password will be
295:12 - new password variable will be the new
295:14 - password
295:15 - basically that user wants to set so this
295:18 - will change
295:19 - the initial password with the new one
295:22 - and the same way
295:23 - in change.title we have self as a first
295:26 - parameter
295:27 - we always need it in all the functions
295:29 - because
295:30 - otherwise we cannot access the
295:32 - attributes in the class
295:33 - and new job
295:38 - title
295:45 - so now let's review this class that we
295:47 - created
295:48 - first of all we have this class keyword
295:50 - here with a capital letter
295:52 - for user you already know the syntax
295:55 - with colon and then
295:56 - indentation so this all of these
295:59 - inside this indentation is class body
296:03 - so part of the class logic first we have
296:05 - this
296:06 - init constructor that sets the initial
296:09 - values
296:10 - of that class attributes whenever we
296:13 - create
296:13 - a specific object for that class right
296:17 - so this happens only when we construct a
296:18 - new object
296:20 - and then on that constructed object we
296:22 - can change password we can change
296:24 - job title and note that right now we
296:27 - have
296:28 - nothing basically hard coded we have no
296:30 - specific
296:31 - values here right everything is just
296:34 - parameterized
296:36 - and also this is just a definition for
296:39 - class and its functions nothing will
296:42 - actually happen when we execute this
296:44 - because we're not creating any user
296:47 - objects
296:48 - so if i right click here and execute
296:51 - this
296:51 - run user you see that
296:54 - nothing happened because the class
296:56 - definition was created
296:58 - but we're not doing anything with that
297:00 - class definition we're not creating
297:02 - new users so now let's actually go ahead
297:05 - and
297:05 - do that
297:09 - in the same file in user.py
297:13 - i would actually use that class
297:15 - blueprint to construct a new
297:17 - user object and creating an object from
297:20 - a class is actually very simple
297:22 - we just write name of the class and
297:25 - parentheses this is actually the same
297:28 - syntax as
297:29 - calling the function with parameters
297:32 - and the parameters that we need to give
297:34 - that
297:35 - class are these four values here
297:39 - and note that calling this user
297:42 - class function basically in the
297:44 - background we'll call
297:45 - init function right so the constructor
297:48 - will be called whenever we write this
297:50 - syntax with class name and parentheses
297:53 - and this init constructor as you see
297:56 - expects
297:57 - four parameters so we have to provide
297:59 - all those parameters
298:01 - right here in the parenthesis so let's
298:03 - actually provide them
298:05 - let's do user email
298:09 - like this
298:13 - my username and password
298:22 - and a current job title again very
298:25 - similar to calling a function
298:27 - and this will actually construct a new
298:30 - object from the user class which has
298:33 - these four attributes with
298:37 - values that we just provided here and
298:39 - has these
298:40 - two functions that we can use
298:44 - to either change a password or change
298:46 - job title
298:47 - one note here is that functions that
298:50 - belong to a class
298:52 - are actually called methods so there's a
298:54 - special name for functions
298:56 - which are part of a class so we can
298:58 - refer to them as
299:00 - methods so user object basically gives
299:03 - us
299:04 - two methods that we can use now again if
299:07 - we execute this program now
299:08 - we will not see anything even though
299:11 - user will be created because
299:12 - we're not printing anything to the
299:14 - console we're not doing anything so
299:17 - let's do that run user nothing happens
299:20 - because
299:21 - we need to print a message or some kind
299:23 - of information
299:24 - so what i'm going to do now is inside
299:26 - that class
299:27 - i'm going to create a function or a
299:30 - method as we learned now
299:32 - that basically prints back some user
299:34 - information right
299:35 - prints me the name email and current job
299:38 - title because we don't want to display
299:40 - password so let's give us some space
299:43 - here
299:43 - and let's create a function called get
299:47 - user info so that we can see something
299:51 - and again as soon as i typed in
299:54 - these first parentheses self got
299:57 - generated
299:59 - because we need self in every function
300:01 - within the class
300:02 - and in the function body we're gonna
300:06 - print user information
300:10 - so let's say user
300:14 - and name of the user which we can access
300:17 - using self
300:18 - remember all the attributes that the
300:20 - object has can be accessed with
300:23 - this special word here so self
300:26 - dot name
300:29 - so user whatever the user's name is
300:32 - currently works
300:35 - as a and now we need the job description
300:40 - or job title
300:44 - and you can contact
300:47 - them at and now we can
300:51 - use the email
300:54 - so this message will be printed for the
300:57 - user
300:58 - again because this will be used for
301:01 - any user of our application the message
301:05 - these parts will be the same but each
301:07 - user will have their own different name
301:09 - different job title and different email
301:11 - address
301:12 - so all of these are
301:15 - and written as variables because we
301:17 - don't know these values up front
301:19 - so now we can actually use this function
301:23 - or method to print out information of a
301:27 - specific
301:28 - user so how do we use or how do we call
301:31 - that function of the user
301:33 - we first save it into a variable
301:36 - app user one
301:40 - or nana doesn't really matter let's call
301:42 - it app user one so it's generic
301:45 - so how do we use that function
301:49 - to print out the information about the
301:50 - user if i do
301:52 - app user one and dot
301:56 - you see that i have the attributes here
301:58 - the four attributes that
302:00 - our user object has or user class
302:03 - and we have these three methods of the
302:06 - class get user infor
302:07 - change job title and change password so
302:10 - using get
302:11 - info we can call this function
302:17 - and if i execute this right here you see
302:20 - user
302:20 - nanogenasia currently works as a devops
302:23 - engineer
302:24 - you can contact them at this email
302:27 - and now let's say we want to change
302:30 - job title of that user we do that in the
302:34 - same way
302:35 - app user one dot
302:38 - change job title and
302:41 - we're gonna provide the job title
302:44 - parameter
302:45 - note that even though you see two
302:47 - parameters here on that function
302:48 - this first parameter is passed in
302:50 - automatically so we don't have to
302:53 - basically pass that self right it's
302:55 - already done automatically we just have
302:57 - to worry about these parameters
302:59 - so new job title is let's say
303:03 - devops trainer
303:07 - and now we can call that
303:10 - user info method again
303:13 - and execute and you see first
303:16 - message printed here before we change
303:19 - the job title
303:20 - now it's devops trainer
303:23 - so that's how we can create a new
303:26 - object from a class and we can
303:30 - use methods of that object by first
303:32 - saving that object into a variable and
303:34 - then calling that function
303:36 - on that variable and obviously now this
303:39 - is just
303:40 - one user but if we had another one
303:45 - user two that's actually
303:50 - clean this up we can create
303:54 - a new user with different values
303:58 - like this
304:04 - they have their own email
304:08 - own name
304:16 - own password and on
304:19 - job title and again
304:24 - we can create that user and basically
304:27 - just use the methods defined in the
304:30 - class
304:31 - and in two different cases or for two
304:34 - different users
304:35 - obviously the user info will be
304:38 - different
304:39 - so let's execute this and right here you
304:41 - see the user
304:43 - information for both users and obviously
304:46 - if you have an application like
304:48 - linkedin you don't have two users or a
304:50 - thousand users
304:51 - you probably have millions of users and
304:53 - having
304:54 - a user definition once and
304:57 - reusing it every time a new user gets
305:00 - created or
305:02 - basically existing users do something in
305:04 - application
305:06 - is only possible when using classes
305:09 - and objects instead of just having all
305:12 - these logic
305:13 - non-structured throughout the code and
305:16 - again in this type of applications
305:19 - you would not have four attributes and
305:22 - three methods you will have
305:23 - probably hundreds of attributes and
305:25 - hundreds of such
305:27 - methods now as you see here
305:30 - we have created this user.pi
305:34 - file for user class but we're also
305:37 - creating these
305:38 - objects in the same file which actually
305:40 - doesn't make sense because
305:42 - the file should be only for defining the
305:44 - class right
305:45 - so all of this logic actually needs to
305:47 - move out from here
305:49 - and this should be just only for class
305:53 - definition
305:54 - so in the application again using an
305:57 - example of linkedin
305:58 - we would have class user and then we
306:01 - would have
306:02 - a class post right whenever someone
306:05 - posts something
306:07 - each post will have their own attributes
306:09 - like the actual
306:11 - message or text in that post the author
306:14 - who wrote the post how many likes it has
306:16 - etc
306:17 - as well as specific functions right for
306:20 - example
306:21 - changing the post commenting on the post
306:23 - etc
306:24 - so you will have separate file for each
306:28 - such class right in the application and
306:30 - then you would have
306:32 - one file somewhere else this could be a
306:34 - main dot pi
306:35 - where you would actually use all those
306:37 - different classes and create
306:39 - objects from those classes and that
306:41 - means that logic that we wrote here
306:44 - constructing a user object and then
306:46 - calling some functions on that
306:48 - will actually happen in another file in
306:51 - our case let's use
306:52 - main.pi and now let's see how we're
306:54 - going to do that
306:55 - i'm going to paste in the code that i
306:58 - copied from there
306:59 - and as soon as i paste in you see those
307:02 - red lines
307:03 - so basically main.pi says that it cannot
307:07 - find
307:07 - a reference to user so this file doesn't
307:10 - know anything about the user class
307:12 - so how do we fix that or how do we make
307:15 - this user class available
307:17 - in another file and if you remember
307:20 - when we needed to use modules or
307:23 - basically functions
307:24 - variables whatever from other files in
307:26 - python
307:27 - we use import to basically import those
307:30 - functions
307:31 - and make them available here or import
307:34 - the whole module
307:35 - to make its functions and variables
307:37 - available here
307:38 - and the same way we can import classes
307:41 - from another file import
307:45 - user and note here that i'm using the
307:48 - name of the file
307:50 - user lowercase and not the class name
307:53 - with capital user right
307:54 - so we are importing that file so now we
307:58 - can use
307:59 - anything that is defined in that file
308:01 - and one of them
308:02 - is class called user and the way we can
308:06 - access that class now is using the name
308:10 - of module and not the class
308:13 - user itself and this is basically
308:16 - exactly the same concept as we saw
308:18 - before
308:19 - because we are importing a module called
308:22 - user
308:23 - remember every python file that has
308:26 - functions or variables or classes inside
308:30 - is a module so we are importing a module
308:33 - and once we have that module imported
308:36 - now we can use
308:37 - and access functions variables or
308:40 - classes
308:41 - of that module and we can do that by
308:43 - copying the name of the module
308:45 - dot and there you go in the same way
308:48 - here so exactly the same concept whether
308:51 - this is a function or a class doesn't
308:54 - matter
308:55 - we use it the same way remember when we
308:57 - use the date
308:58 - time module with the syntax
309:01 - datetime.daytime
309:02 - and that was an example of using a class
309:06 - from a module now user.user may
309:09 - look a little bit weird so we can use
309:12 - our
309:13 - familiar import statement where instead
309:16 - of
309:17 - importing the whole module we can pick
309:19 - and choose and import specific
309:21 - definitions or specific elements of that
309:24 - module
309:25 - in our case we just have one element
309:26 - which is the class
309:28 - so we're going to say from user module
309:30 - import
309:31 - user class and now we don't need the
309:35 - module name anymore because we imported
309:37 - the
309:38 - class itself and now if we
309:41 - execute main dot p y
309:45 - let's do it again here we have the same
309:48 - result
309:49 - for two of our users
309:54 - and again as i said in applications you
309:57 - will have multiple classes
309:59 - that are connected to each other so for
310:01 - example if we have a post here
310:03 - post blueprint basically whenever a new
310:06 - post gets created
310:08 - with some specific values like the
310:10 - actual message
310:11 - and creation date time etc
310:14 - it will also have an author and that
310:17 - author will
310:17 - actually be one of those user objects
310:20 - right
310:21 - so you will have some functions here
310:23 - that actually
310:24 - reference the post and we can also see
310:28 - that in action
310:29 - let's actually create a post class
310:36 - let's give it just two attributes to
310:38 - keep it simple
310:39 - so we need a constructor here
310:43 - in it
310:47 - and we're gonna pass in message
310:50 - and author right this is gonna be the
310:53 - user who wrote it
310:55 - and you know the drill already
311:09 - and let's create another function
311:12 - which displays a post with its
311:15 - respective author so let's do get
311:19 - post info
311:23 - again we have self here and let's print
311:30 - post
311:36 - written by
311:39 - and the author name so this is going to
311:43 - be our simple
311:44 - post class and user
311:47 - is able to create new posts so we have
311:50 - the blueprint for a post
311:52 - and the same way we can create that post
311:56 - inside the main dot pi so first let's
311:59 - import
312:02 - the post class
312:08 - and then here we're going to create a
312:10 - new post
312:11 - in pycharm you get this nice display of
312:14 - parameters
312:14 - that function or class basically
312:18 - expects so we have message and author
312:21 - let's do some
312:27 - message or post and as a second
312:29 - parameter
312:31 - we have the author and we can use
312:36 - the name of a user so let's do
312:41 - app user to dot name and this will
312:44 - create
312:44 - an object also called instance in
312:47 - programming
312:48 - special instance of that post class
312:52 - and then we can print the information
312:56 - of that post first assign it
312:59 - to a variable let's say it's a new post
313:02 - and on a new post we're gonna call get
313:06 - post info let's actually run this
313:08 - application now and see the result
313:10 - and here we have our post message that
313:13 - gets
313:14 - printed by this get post info method
313:18 - in the post class
313:22 - and at the beginning i mentioned object
313:24 - oriented programming
313:26 - which basically means that when you're
313:27 - writing your code with
313:29 - objects and classes like this to create
313:32 - blueprints and then
313:33 - use those blueprints for specific
313:35 - instances
313:37 - that's called object-oriented
313:38 - programming and also an
313:40 - interesting note here is that in python
313:43 - almost
313:43 - everything is actually an object for
313:46 - example the data types like string
313:49 - integer list set etc when we printed
313:52 - them out we saw
313:54 - class of string or class of
313:57 - list so these data types are also
314:00 - classes in python
314:01 - and this int or sdr for string functions
314:05 - we called
314:06 - where actually the constructor we called
314:09 - to create a string
314:10 - or integer object and the constructor of
314:14 - int for example took a string
314:16 - representation of a number
314:18 - and in its init function and constructed
314:21 - an integer out of it now for us in terms
314:24 - of
314:24 - using these data types and variables etc
314:28 - it doesn't actually matter but it's just
314:30 - an interesting thing to know
314:32 - about how this whole thing works in
314:34 - python
314:40 - in this part we're going to learn how to
314:43 - use
314:43 - python to talk to external applications
314:48 - in our case we're going to use gitlab
314:49 - and then application and just
314:51 - note here that communication between
314:54 - two applications in our case our python
314:57 - application
314:58 - and a gitlab application usually happens
315:02 - using a common protocol like http
315:05 - so basically our python application will
315:08 - send an http request
315:09 - to gitlab application and from the
315:12 - gitlab application it will get
315:14 - an http response for that request
315:17 - so just know that http is just a
315:19 - protocol
315:20 - that these two applications can
315:22 - communicate with
315:24 - over the internet i have a couple of
315:26 - projects on gitlab
315:27 - so we're gonna write a very simple
315:29 - python application
315:30 - that basically goes to gitlab and asks
315:33 - for the list
315:34 - of projects for my user and
315:37 - then just prints it here in our run
315:40 - window
315:41 - and the concept of one application
315:44 - talking to another is basically done
315:47 - using
315:48 - something called api requests so the
315:51 - remote
315:52 - application in this case gitlab has an
315:54 - api
315:55 - so these are functions basically that
315:58 - gitlab
315:59 - makes available for other applications
316:02 - to call
316:03 - and we're going to call those functions
316:04 - from our python application
316:06 - in order to get the list of projects for
316:08 - my user and that
316:10 - communication or python basically asking
316:13 - for this information
316:14 - is going to be an api request or api
316:18 - call and what we get in response from
316:20 - this gitlab
316:22 - api is going to be api response
316:25 - so let's go ahead and do that
316:30 - in python in order to make those
316:33 - external requests
316:34 - to remote applications we're going to
316:37 - need a module
316:38 - called requests this is a generic module
316:41 - that you can use for
316:42 - any external application and as i
316:45 - mentioned at the beginning the
316:46 - communication happens
316:48 - using http protocol between two
316:50 - applications
316:52 - and as you see here also in the module
316:54 - description it says
316:55 - an http library which allows you to send
316:58 - http requests and then receive http
317:02 - responses
317:03 - from another application and that's
317:05 - exactly what we're going to be doing
317:07 - and this request module is not part of
317:10 - python
317:11 - so we're going to install it using pip
317:13 - again remember that we're using pip
317:16 - that actually comes packaged with the
317:18 - pycharm
317:19 - so in the terminal window of my ide of
317:22 - pycharm
317:23 - i'm going to execute peep install
317:27 - requests
317:32 - successfully installed request this is
317:34 - the version of that module
317:38 - and if i expand this external library's
317:41 - site packages
317:42 - i'm going to see the requests package
317:46 - in the list great
317:50 - so once we have the module available
317:51 - locally we can
317:53 - import that module in our file
317:56 - and this requests module now has or
317:59 - package actually
318:00 - has functions variables and objects
318:04 - that we can use to talk to these remote
318:07 - applications like gitlab
318:09 - as i said gitlab is just one example you
318:11 - can talk to any
318:12 - remote application that has an api and
318:15 - we can not only do
318:16 - requests for getting the existing
318:18 - information but we can also make
318:20 - requests
318:21 - to change something in that remote
318:24 - application so for example
318:25 - i can write a python application that
318:27 - will actually create
318:29 - a new project on my gitlab account
318:32 - but to keep the demo simple we're just
318:34 - going to be
318:35 - fetching information from gitlab so
318:38 - how do we make requests to an api of an
318:42 - application
318:44 - with this requests module we get a
318:46 - function called
318:47 - get and get takes one main parameter
318:51 - which is url so basically we need to
318:54 - tell python where to find that remote
318:56 - application
318:57 - or again in our case where to find
319:00 - gitlab
319:01 - to talk to it so we need the url of
319:03 - gitlab
319:04 - and where do you find this url
319:07 - information of a remote application
319:09 - you can basically google that every
319:11 - application has their own documentation
319:13 - where you can see the urls
319:14 - so for example for gitlab i actually
319:17 - googled it
319:18 - so if i do gitlab api documentation
319:22 - like this
319:27 - let's make it bigger so you have
319:29 - basically description
319:30 - for the api and what type of information
319:34 - you can get from gitlab
319:35 - and also what kind of things you can
319:37 - create in gitlab
319:39 - and you see an example api here that
319:42 - basically
319:43 - just lists all the projects however we
319:45 - want to list
319:46 - projects of one specific user in this
319:49 - case i want to list my own projects
319:51 - and in this documentation i found this
319:54 - list user project
319:56 - section where i have an example
319:59 - of how to use projects for a specific
320:02 - user
320:02 - so we have slash users and the user id
320:05 - so that's going to be my gitlab user id
320:07 - and projects so basically the url will
320:11 - now look like this
320:12 - first we're gonna have this base url so
320:14 - that's basically
320:15 - https gitlab.com api v4
320:18 - and all the things that we want to do is
320:21 - going to be
320:22 - at this base api and
320:25 - after that we can basically depending on
320:28 - what exactly we want to do
320:29 - we can choose one specific action
320:32 - and again going back this is
320:36 - the action we want to execute
320:39 - on this base url so from gitlab we want
320:43 - projects that belong to user and right
320:46 - here i'm going to add
320:47 - my own gitlab user id
320:51 - so if you have a github account you
320:52 - should add your own user id here
320:55 - and that's going to be an api url for
320:58 - user projects and this will actually
321:01 - give us
321:02 - some kind of response so requests.get
321:05 - will make that request
321:06 - to gitlab and it will return some kind
321:08 - of response and we can save that
321:10 - response into a variable
321:12 - so let's call this variable response
321:15 - because that's what it is
321:17 - and on the next line let's actually
321:19 - print and see what's in that response
321:27 - let's run our application and
321:30 - right here you see we have an object
321:33 - response
321:34 - with a code here 200 is a code for a
321:37 - successful
321:38 - request but we're not seeing the actual
321:41 - contents right we want to see the
321:42 - projects with their
321:44 - details and in order to get that we're
321:47 - gonna
321:48 - do dot and text and let's actually
321:51 - execute this now
321:52 - and now you see these square brackets
321:56 - which means it is a list because we have
321:59 - a list of projects
322:01 - and this whole bunch of information
322:03 - about projects there
322:05 - and you also see curly braces so this is
322:08 - a list of
322:09 - dictionaries and each dictionary holds
322:12 - information
322:13 - of one specific project now
322:16 - if i actually print the type of that
322:20 - response text
322:27 - like this see that it is a
322:30 - string so even though we see the format
322:33 - is actually
322:35 - a list of dictionaries we're getting a
322:38 - string because we're accessing
322:40 - text attribute now there is actually
322:43 - another attribute which will give us
322:45 - the same thing but as an actual list of
322:49 - dictionaries instead of string and this
322:52 - will be actually a better way to get
322:54 - that information because then we can
322:55 - work on it so we can
322:57 - look through it and get the individual
323:00 - elements
323:00 - and access the values so what i'm gonna
323:03 - do now instead of
323:04 - dot text i'm gonna
323:08 - use json json is a standard format that
323:12 - all programming languages
323:14 - understand and usually when two
323:16 - applications
323:17 - communicate with each other which are
323:19 - written in different languages
323:20 - and with different technologies with
323:23 - json they have a common format
323:26 - for communication and this requests
323:28 - module basically gives us this
323:30 - json function to read the json format
323:33 - that
323:33 - gitlab sent us so json function will
323:36 - read the json response
323:38 - from gitlab and turn it into one of the
323:41 - python data types
323:43 - so i'm going to execute this now and now
323:46 - you see that response.json actually
323:50 - gave us list data type instead of string
323:54 - so again for demonstration
324:02 - since this is a list i'm going to
324:05 - access the first element of that list
324:09 - and print that out and right here you
324:12 - see
324:13 - that is actually the first element
324:17 - just the first one from the list and
324:19 - that element
324:20 - is a dictionary as you see so all these
324:23 - just to give you an idea
324:24 - of what we're getting back from that
324:27 - gitlab
324:28 - api and what we can do with that
324:30 - response or how we can actually work
324:32 - with that response
324:33 - so i'm gonna clean all this up and we
324:36 - saw that
324:37 - response.json gives us exactly what we
324:40 - want
324:40 - and that is a list of my projects so
324:44 - let's call this
324:47 - variable my projects and now what i want
324:50 - to do with this
324:51 - is i want to print out
324:55 - in our window for each project
324:58 - project name and project url so
325:01 - basically the repository url for that
325:04 - project
325:05 - so i don't want to have any other values
325:08 - like id
325:09 - or description or whatever
325:12 - other stuff i have in this dictionary i
325:14 - just want name
325:15 - and project url for every single
325:18 - project and i want that information
325:20 - printed out in this
325:22 - window so how do we do that
325:25 - we have a list so we're gonna loop
325:28 - through that list
325:29 - to access each element inside that list
325:33 - so you remember we have for loop to loop
325:37 - through
325:37 - or iterate through a list and give us
325:40 - access to each element
325:42 - one at a time so here i'm going to write
325:45 - for loop and if you remember the syntax
325:47 - of for loop we have
325:49 - four and then a variable which will
325:51 - represent the single element in that
325:53 - list
325:54 - and in this case it's going to be a
325:55 - project a single project
325:58 - and then we have in
326:02 - list so for project in my projects
326:06 - do something so for every project
326:09 - element
326:09 - in this my projects list we want to
326:12 - print out the name and the url
326:15 - so right here i will do print
326:18 - and let's do our formatted string here
326:21 - and let's start writing our message
326:24 - let's do
326:25 - project name
326:28 - and the project name will be this one
326:31 - right here
326:32 - now how do we actually access
326:35 - the name of the project in each project
326:39 - element as you see here these project
326:42 - elements are actually
326:43 - dictionaries and how do we access a
326:46 - value in a dictionary
326:48 - using the name of the dictionary in this
326:51 - case
326:51 - our variable project so this whole thing
326:54 - is going to be
326:55 - saved into a variable called project and
326:57 - then on that
326:59 - variable on the dictionary we're going
327:01 - to pass in
327:02 - the name of the key which is name
327:06 - now i've been using double quotes
327:08 - throughout our project
327:09 - and for a syntax for dictionaries as
327:12 - well
327:13 - like this
327:16 - right however here we have a small
327:19 - problem which is
327:20 - we have double quotes inside the double
327:23 - quotes but as you remember
327:25 - for string representation we can
327:27 - actually use
327:28 - single quotes as well as double quotes
327:31 - and this is one of the
327:32 - really important use cases for why we
327:35 - can actually use
327:36 - both single and double quotes for a
327:39 - string
327:40 - and that is if we have a string inside
327:42 - another string
327:43 - like right here we can actually use that
327:47 - interchangeably so that we don't have
327:49 - this problem here
327:51 - so now as you see back to normal
327:53 - everything works because
327:55 - now python knows okay this is another
327:58 - string
327:59 - which we're using inside this string
328:02 - so we can use these interchangeably as
328:04 - we want so this could be single quotes
328:06 - and this could be double quotes
328:08 - wouldn't really matter but that's a
328:10 - really good use case why we need
328:11 - both types of quotes so we have the
328:15 - project name
328:16 - now we need a project url
328:22 - and let's see where the project url is
328:25 - in our dictionary
328:26 - this is one element one dictionary right
328:29 - so
328:29 - i'm gonna scroll it to the left
328:33 - and we have web url this is what we
328:35 - could use
328:36 - or we could also use http url to repo
328:40 - let's go with the web url so again this
328:43 - is a
328:44 - key inside the dictionary so we can
328:47 - access
328:48 - the value so this is actually the value
328:50 - we need and we can access that using
328:53 - the dictionary name projects
328:57 - and the key name which is web url and
329:00 - this is actually project
329:02 - not projects and this code will now
329:05 - print
329:05 - name and url for each project so let's
329:08 - actually execute our program
329:11 - and as you see we have project name and
329:14 - project url
329:16 - for each project we can make the output
329:20 - a little bit cleaner
329:21 - let's do a new line here
329:25 - and a new line here so we can separate
329:27 - the projects from each other and
329:30 - run again and there you go this looks a
329:33 - little bit cleaner
329:34 - for each project we have a name and a
329:37 - url
329:38 - so if i click inside i'll go directly to
329:41 - this
329:42 - project so that's basically a very
329:46 - simple example of how to use
329:49 - requests module to talk to external
329:52 - applications
329:53 - or external urls and then do something
329:56 - with the response that we get
329:58 - from that external application by first
330:00 - converting that into an actual data type
330:03 - that we're getting using json function
330:05 - so in our case it was a list
330:07 - and that's why json function actually
330:09 - converted it into
330:11 - a list if the response was a dictionary
330:14 - instead of at least
330:15 - then json would convert it into a
330:18 - dictionary
330:19 - and then we can do something with that
330:20 - response value
330:25 - congratulations you made it till the end
330:27 - i hope you learned a lot
330:29 - and got some valuable knowledge from
330:31 - this course if you like the course
330:33 - please leave a thumbs up on this video
330:36 - on my channel i actually cover
330:38 - lots of different devops topics like
330:40 - docker ci cd
330:41 - terraform and more so be sure to check
330:45 - out
330:45 - my tutorials if you're learning python
330:48 - to become a devops engineer
330:49 - i actually have a complete devops
330:52 - bootcamp
330:53 - with all the technologies you need to
330:55 - learn as a devops engineer
330:57 - which also includes a module for
331:00 - automation with python
331:02 - with several cool demo projects to
331:05 - automate some
331:06 - common devops tasks like application and
331:10 - server monitoring
331:11 - cloud automation tasks with aws
331:14 - jenkins etc so if you're interested
331:17 - check out more info in the description
331:20 - also happy to connect with you on social
331:22 - media
331:23 - so i would love to see you there with
331:25 - that said
331:26 - thank you for watching and see you in
331:28 - the next video