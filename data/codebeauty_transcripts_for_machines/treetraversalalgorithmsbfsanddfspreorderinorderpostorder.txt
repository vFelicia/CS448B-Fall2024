hi guys and welcome to my channel in this video we will talk about different ways to traverse a binary tree and different algorithms so we will discuss depthfirst search and breadthfirst search algorithms and i will also show you how you can use recursion in order to traverse a tree and since we'll be using visual studio i want to show you a very useful plugin that many senior developers use it is called visual assist and it is used in order to boost your productivity and to help you to write better code faster and also to help you to avoid all those little sneaky errors that are very hard to find and fix you can use it with c c plus and c sharp programming languages and on the screen you can see some of my favorite features of visual assist and how i use it to boost my productivity some of the things that it can help you with is it enhances intellisense so that it behaves like intellisense on steroids and then it has different code suggestions spell checking it is used a lot for refactoring it helps you with navigating and searching through very large projects which is usually very hard it has different code inspection commands and so on so if you are interested to try it out you can use the link in the description and it is a musthave if you plan to make games or work with unreal engine and then if you want to see some of my favorite features of visual assist and how i use it you can check out the video that will be linked here and also in the description so let's start talking about three traversal algorithms here on the screen i have a tree and then in my visual studio i have a code that represents this stream so i wrote this code in the first part of this video which will be linked here and also in the description i'll just show you very quickly what we have written so far and then if you don't understand something make sure to watch part one and then you can come back to this video so here i have a code that represents node structure so here is how one node looks like it has data it has left child and right child and then here is a function used to create a new node and then this code here represents this tree that i have painted and before we start talking about traversing trees and different algorithms to do that i first want you to understand why we need to traverse a tree in the first place so we are using tree traversal because that is the only way to access the data that is stored inside these nodes and to do something with it to manipulate it or do something else that we want to do with that data so there are two types of algorithms that are used to traverse a tree bfs and dfs so breadth first search and depth first search and in this video we are going to focus on depth first search algorithm and then if you want me to make a video about breadth first search let me know in the comments the main difference is that breadth first search algorithm will first search the width of the tree and depth first search algorithm will first search the depth of the tree so here is an example of how breadth first search algorithm works so as you can see breadth first search algorithm prioritizes with search instead of depth search which means that it will first visit this note here and then it will go to the second level and only after all the notes on this second level are visited only then it goes deeper it goes to third level and then again it visits all the nodes on third level and then it goes to fourth level okay so this is how breadth first search algorithm works and then depth first search algorithm works like this so as you can see the order in which these nodes are visited is very different with depth first search because as i said dfs depth first search prioritizes depth over width which means that it will first visit this entire subtree so from the top to the leaf to the deepest leaf node and then it will visit this entire subtree and then this and this and then it will visit this one and then this and this will be the last one so uh you can clearly see the difference between depth first search and breadth first search algorithms so once again bfs prioritizes with search and dfs prioritizes depth search so in this video we will focus on depthfirst search algorithms there are three depthfirst search algorithms preorder in order and post order so let's now explain each one of these and i also want to explain what these data left right labels mean so with preorder algorithm we first manipulate the data and then we go to the left child and then we go to the right child so let's see how preorder algorithm works on this tree here so we will start from the root node and we will start this algorithm so it first says please manipulate the data so let's print the data that's number one and then the algorithm says go to the left child so i'm going to this left child here and i restart the algorithm and again the algorithm says please first manipulate the data so i print number two and then it says go to the left child so i'll put l here and i'll go to the left child and restart the algorithm once more so again i manipulate the data so i print number four and then it says go to the left child but there is no left child so i proceed with the algorithm which says now go to the right child so i'll put our symbol here and also notice that there is no right child so the only thing that is remaining to do is to go back to this node here and to continue from where we left so we manipulated the data we went to left child and the algorithm here says that the only thing remaining to do is to go to the right child so i put r here and we go to the right child which is this note here and we start the algorithm once more so data which means that i will print number five and then visit the left child which means this child here and the algorithm starts once more so data again i print number nine and then i try to visit the left child there is no left child i try to visit the right child there is no right child as well so i go back and here i try to visit the right child but there is no right child so again i go back to this note here and then i go back to this note here and here we said data left so we are remaining with r which means visit the right child so i go here and here again i start the algorithm so please manipulate the data so print number three and then go to the left child which is this node here and again print the data so i put number six and then i visit the left child there is no left child i visit the right child and there is no right child so i go back to this note here and here data left so now i do write which means that i visit this node here and here i also do data which means that i print number seven and then i do left which means that we visit this node here and again i need to print the data which means i need to print number 15 and then i need to visit the left child and the right child and since there is no left child or right child i go back and here data left right but there is also no right child so i go back and then back and we have successfully traversed a tree with preorder algorithm so this is visual representation of preorder algorithm and this is how you can print all the numbers of this tree with the help of preorder algorithm now let's see how this looks like in code so here is how print tree function looks like with preorder algorithm so here is the function to print a tree and i'm going to explain every single line but first i want you to focus on this part here so as this preorder algorithm says we first need to manipulate the data so we first print the data and then we visit the left child and then we visit the right child so that is the algorithm and then we also have this condition here which is called base condition and it will be used in order to stop the execution of this function another thing that i want you to notice is that this function here is a recursive function now a recursive function is a special type of function that invokes itself so inside the definition of that function there is an invocation of the same function so it continues to execute and invoke itself and then execute and invoke itself and so on until a certain condition is met and that condition is called base case and that condition will stop the further execution and invoking of that function now if you are not familiar with recursive functions i recommend you to watch this video it is beginner friendly and you can learn everything that you need to know about recursive functions in order to understand this code here and in that video you also asked me what is real purpose of recursive functions and when are they used in programming so this is one of the most common uses of recursive functions they are used in order to traverse trees so basically what is happening here is this same algorithm so let's go line by line and explain how this code is executed so we start from this root node here that node is passed as a parameter to this function and then the first line says please check is the root equal to null ptr the answer is no it is one so we proceed we don't return from this function and then the second line says now you need to manipulate the data so print the data so we do this part here okay and then we go to the next line and the next line says now you need to go to the left child so we do this part here and we go to the left child so we invoke the same function but but this time we are passing here number two so again we are entering in the same function and again we are asking is the root node equal to null ptr and the answer is no the root node this time is equal to two so we proceed from this base case and we go to this line here which says now you need to print the data so we do this part here and then we proceed with the next line which says now you need to visit the left child so you need to invoke the same function but for the left child so we do the left part of the algorithm and we visit this child here which means that we invoke this same function and this time we are passing number four as root so again we are asking is root equal to null ptr the answer is no root is four and then we manipulate the data so the d part and then we need to print the left child so we are invoking the same function and we are passing the left child so this part here but this time when we are passing parameter to this function since we don't have a left child this root node will be equal to null so when we enter to the function and when we check this condition is root equal to null ptr the answer will be yes because there is no left child so now we need to return from this function and go back so we are continuing from here which means that we are continuing from this node and we are still left with this part so now we need to visit the right child okay so once more i'm entering into this function and passing the right child of node four and again there is no right child so once more when we check this condition we will be returned from this function and we will come here and then we will come to the last line which means that we will go again one step back and that is to this node here and to this part here so here is where we left when we were at this node number two so we will continue from this r part which means print tree and this time you need to pass the right child of this node here and the right child is number five so here we are entering into the function and passing node five so when i check is node five equal to null ptr the answer is no so we proceed and we print number five which means that we have manipulated the data and then we need to visit the left child so l part okay and we are visiting this note here since that is the left child and again we are entering into this function and passing number nine we are checking is nine equal to null ptr the answer is no so we go to this part here we print the data and then we visit the left child the left child is null so when we pass null here this condition will return us from the function we will be taken back here and we will proceed with this part which says now you need to print the right child so again when we enter here with no because number nine does not have right child either we will be again returned by this condition here and then we will go back and then back and so on until every single element of this tree is printed so that is how this function here works and prints a tree by using recursion so now the only thing that is left to do is to check if we are going to get the same output with this function as we did here when we manually applied this preorder algorithm so i will invoke this function at the end of main i will say print tree and i will pass the root node and if i run the program let's see the output okay so it's 1 2 4 and here is 1 2 4 and then 5 9 3 5 9 3 6 7 15. so as you can see our function works as expected so that was an example of preorder algorithm and now let's see how in order algorithm works so in order algorithm says that we first visit the left child and then we manipulate the data and then we visit the right child so let's apply in order algorithm to this tree here so we start at the root node and the first thing that the algorithm says is visit the left child so we visit this child here and again we restart the algorithm so again the algorithm says visit the left child so we visit this child here and here again we visit the left child and then since there is no left child we proceed with the algorithm so the algorithm says now manipulate the data which means that now we need to print number four and then visit the right child but there is no right child so we go back to this note here and here we continue from where we left so we visited the left child now we need to manipulate the data so we print number two and then we visit the right child which means that we are going to this node here and here we are starting the algorithm again so we visit the left child so we go to this child here and again left data which means that we print number nine and then right but since there is no right child we go back and here we continue so we had left now we need to manipulate the data so we need to print number five okay and then we need to go to right child there is no right child so we go back and here we also finish the entire algorithm so we go back again and here we visited the left child now we need to manipulate the data so now i print number one and then i visit the right child and the right child is this here so here i do left okay which means that i'm visiting this node here and here as well i'm doing left and then data which means print number six and then write there is no write so i go back and here i need to print the data so i print number three and then i visit the right child so i'm going here and here i will say left so i'm visiting this note here and once more left there is no left child so i do data which means that i'm printing number 15 okay and then i try to visit the right child there is no right child so i go back here here i need to print the data okay so i print number seven and then i try to visit the right child there is no right child and with this we have successfully visited all the nodes of this tree with in order algorithm so now the question is how we can translate this in order algorithm to code and apply it to this function here well it's actually very easy this here is preorder algorithm and if you remember we said that preorder first prints the data and then visits the left child and then visits the right child and you can see that part here so data left right on the other hand in order algorithm first visits the left child and then data and then right so the only thing that we need to do is we need to move this line here like this so first visit the left child and then manipulate the data and then visit the right child so if i run the program let's see if we are going to get the same output okay so four two nine four two nine five one six five one six and then three fifteen seven three fifteen seven so our code works as expected so at this point i would like to encourage you to try and figure out on your own how post order algorithm works so it first visits the left child and then write child and then it prints the data so i would recommend that you paint and draw the same way that i did here and then create your own output predict the output and then you can adjust this print tree function so that it does left right and then data so that you can check the output that you get here for post order algorithm also i'm going to paste this code in the comment section so that you can use it if you want so thank you very much for watching and if you enjoyed this video please give it a thumbs up because here we are talking about algorithms and then you hitting that like button is very important for the youtube algorithm you can share it with your friends with someone who needs to learn about data structures and algorithms because i know that many students are struggling with these topics so you can be that person who sends them a video that might help them because i really try to explain these topics in a very simple and understandable way so um i hope that these videos are helping you guys so thank you very much for watching and i will see you in some other video bye