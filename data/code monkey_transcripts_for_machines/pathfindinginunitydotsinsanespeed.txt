in this video we're going to implement a star path finding in unity dots we're going to implement the algorithm in a pure data oriented way which will allow us to benefit from the extreme performance of unity dots let's begin okay so in this video we want to implement a star using a data oriented design we want to benefit from massive performance from unity dots by using the job system and the burst compiler now previously I covered how to do a star where we made it the normal way using objects if you haven't seen it yet then go watch that video in there I cover the algorithm in more detail step by step here I'm going to do an overview of the algorithm and then start implementing it in unity dots paying close attention to how we can convert from object oriented into data oriented so before we get to the code let's first check out the theory the goal of the astar path finding algorithm is to search to find a path from A to B so the algorithm already detects one coupon and unwalkable areas and correctly identifies the insurance path from A to B our map won't be grid based from each grid position we can move in all eight directions on each node essentially we have three values first we have the G cost that is the walking cost from the start node so for example to go from this node into this node it has a cost of 1 and we can also move diagonally so from this node into this node has a cost of 1.4 now in order for our code to work with ends instead of floats we're simply going to multiply our values by 10 so horizontally we have a cost of 10 and diagonally cost of 14 then we have the H cost this is the heuristic cost to reach our final goal so it's essentially an estimate to try to reach the goal our calculation is simply assuming there are no 1 so moving straight towards our goal so in here our hitch cost more commonly going from here to here to here again this is just a basic guess to figure out which notes you prioritize and finally we have the F which is simply G + H so this combines our actual cost from the start combined with an estimate to reach the goal and we have our final number using this we can prioritize nodes with lower F since those are more likely to be closer to the goal the algorithm finally stops when our current node is our goal node so if we start here for we check on the neighbors these are unwalkable so they are ignored so he checks this one then checks these two neighbors then this one has a lower F value so it checks this one checks the neighbors four down then it starts locating that one and it says that this one is a go so we have our path so here as you can see that G cast is constantly increasing and the F cast is constantly decreasing then our path is traced back from the final node into our original so each node also knows what the previous path node was then for the algorithm to work we also have two lists for our notes the open list and the close list the open list is where we have all the nodes that are queued up for searching and the cause lists are all the notes that have already been searched so we keep going until we find the current node on the open list or our open list is empty so we no longer have anywhere to search so there's no path okay so now that we've got that the algorithm let's implement it again in this video we're focused on the unity dot specific implementation which means that are oriented and no objects so make sure to watch that other video first which will make the data oriented version much easier to follow I've also made a video covering the differences between reference types and value types that is one of the main differences between the objectoriented way and the data oriented way objects are reference types whereas here we're going to use structs which are value types so watch that video to see how they behave differently this video is made possible thanks to these awesome supporters go to patreon.com/scishow to code monkey to get some perks and help keep the videos free for everyone let's begin by making our script so a new csharp script and just call it cat finding and just for testing let's make a empty game object and attach our script onto it okay now the core of our pathfinding is to source some data on each squared position so let's begin by defining our pet node now first of all this will be a struct and College Pat node now inside the first thing we're going to need is the position so let's have an end for the X and then in for the Y and now since we're working with structs and not objects that means we're going to work a lot with indexes so let's also store a public and for the index then we have the standard a star path finding values so we have the G cast H cos and F cast the G cast is the actual move cast from the start node onto this node the H cast is the estimated cost from this node onto the end node and the F cost is simply G Plus H then we're also going to have a simple boolean for is welcome and lastly in order to calculate our path back from the end node then we need to know where we came from now in the objectoriented way here we we just saw our previous path node but we cannot use objects so instead we're going to define it as our index so this is the index of node previous to this one when we're completing our path all right so here we have our path node defined purely using value types so that means we can use this struct inside a burst compile job now up here let's make a testing function so a simple called fine path we're going to find a path and we're going to receive an into for the starting position and then into for the end position now the into is inside the new unity dot mathematics library and there it is so in here let's start off by creating our grid let's start off with just basic four by four grid and in order to store our grid we're going to use a flat native all right okay so we define our flat native Ray and then since we're dealing with native race we must remember to dispose of them so at the end we call this post all right now to initialize it in here we construct a new path node and now to set the starting Val so we set the x to this X same thing for the Y okay now to initialize the remaining values we're going to need the index so let's make a function to calculate that here it is very simple we just convert a x and y position into a flat in X so in here we can set the path node index to be are constantly indexed and a path length DX and one then we need to initialize our costs so first of all for the path no dodgy cost this is the cost from the start node onto this node so let's start off with all of them at max value now for the edge cost which is the heuristic cost in order to reach the end node so we're going to make a function to calculate that now we need to define the weight for the diagonal and the straight move cost so let's go up here to the final alright so here's our function to calculate a distance cost from A to B and now up here we can set our Edge cost it won't be calculate our distance cost from position a which will be this one so when into with this X and this y then the B position will be the end position so there's the H cost and now for the path node F cost we can calculate this inside of our struct so in here let's make a function and the F cost is simply the G cost was the H cost and up here we simply hopefully alright so lastly we just need the is welcome all for that one let's make them welcome so plot node that is welcome on let's set it to true and lastly we have the came from node index which we're going to use minus 1 as our invalid Val alright so here we have our pet node correctly set up now after its set up then we need to assign it to the index position in our flat rate so in the pattern of the array on the index of the index then we set this pattern oh okay so here we have our grid completely set up now after doing that let's grab our start node to grab that we calculate the index and up here we use our start position so this is our start node and for starters we're going to update the G cost since its start we're going to set it off to zero and then we need to recalculate the F cost and again always remember that here we are working with value types so what we're doing in here is simply modifying the copy we're not modifying what is actually inside of this array so after we modify it let's place it back in the array all right there it is now following our algorithm we're going to need an open list and a closed list and again we're working with structs so let's define our a race as list of int indexes instead of references and again make sure we dispose to start we're going to start with the start node on the open list so open list and we have the start node index and now while we have nodes on the open list so while the open list up link is bigger than 0 we're going to grab our current path node and the current one won't be the one with the in lowest F cost so down here let's make that function so here this we take our open list and then receive our flat array of our path nodes then we do a simple cycle so we cycle through the open list which again contains indexes and not references so we go through down 1 then we access the path node arrayed on that index and if the F cost of this one is lower than this one then this one becomes in your most so there it is very simple this returns the lowest cost F node index so in here we simply use it we pass in the open list and if at no the right all right now here we have the index for the node that we want to test let's also grab the current node now we test if this current node is the final node then we have reached our destination so in order to do that we can calculate the index of our end position node so we calculate the end node in X using our end position X&Y okay and then down here if the current node index is the same as the end node in X then we have reached our destination and we simply break out of the cycle if we haven't reached our destination then the first thing we do is remove the current node from the open list so here we cycle through the open list which again is a list of integers for our indexes then we check if we have the current node in X and if so then we remove it from the list on that position all right so after we do that then we need to add this list into the close list so simply close lists and we add this in X and now here following our algorithm we need something else so we need to cycle through all the neighbors of this current node so for that let's go up here in order to define an array for all the neighbor offsets all right so here we have our array with all of our neighbor offsets so I left right up down left down left up right down and right up so we create this native right and again always remember to dispose of it now in here let's second through the offsets so we grabbed the neighbor offset then we create a neighbor position which is based on the current node was the neighbor offset and now we need to validate this position so we need to know if this neighbor position is inside of our grid let's make a function to do that okay so we have a simple function testing if it's above zero and under the actual width and height so here as we cycling through the neighbors if this position we test the neighbor position if it is not inside the grid then we simply continue so we continue on to the next neighbor offset and now if not then we have a valid neighbor position now here let's check if the close list contains this index so it's also completely the end for the neighbor index so if the cause list already contains this neighbor node index and we already searched this one so we continue if not then let's check if the node is one kaboom if note is not welcome all then we continue and finally if we go through all of these then we have a valid node so here and let's do our algorithm alright so first we calculate the attentive G cost so that is based on the current node G cost was he dissing cost from the current node onto this neighbor position if that new G cost is under the current G costs then we want to update this neighbor node so we update he came from index to be the current node index we update the G cost we calculate the F cost and again here we're working with structs so after we update our node we need to place it back in the array so we do that and then we add it onto our open list alright so just like this over here we have our pathfinding algorithm and now after doing this cycle one of two things happen whether we found a path or we didn't find a path so the way we know that is by looking at the end node so if we're having a pet node for the end node it shall be the pet node array of the end node index and we test if the end node that came from node index if it is minus one then we did not find a path and if not then we did find the time now let's make a function to build our path so if we have a wonder new we're going to return a empty native list so our into is going to be our path position and if we have found a path then we need to walk backwards to get our actual path alright so there it is we do a while we have a came from node index in our current node we grab the node in that index and we add that position into our path and finally we return the path all right so just like this we have our path being calculated now it's actually inverted but we won't worry about that when we make a unit to actually follow the path so up here if we find a path let's calculate it and right now we don't care about getting the path backs we just want to calculate it so after getting it which is disposable and here at the end again make sure you dispose on the native arrays that you create all right so here we have our East our algorithm implemented solely using valley types so that means that this is usable with bursts nd job system but now let's first make sure it actually works so for that and let's make a test all the way up here we are working with a simple model behavior so let's make our start function done start let's simply try to find a path our grid is of size 4 by 4 so let's try to find a path from zero zero on two and let's say three one and down here when we come away the path and let's make a debug log so we make sure that the path is correct all right that should do it let's test any of there you go over here in the console we can see that we have our path being correctly calculated again it's backwards but B path is correct so we go from 0 0 to 1 0 so to the right 2 to 1 so diagonal up and to 3 1 to the right all right so the algorithm appears to be working now let's add some walkable areas to test it so in our path finding in here we are creating our grid so after we do that let's make some walkable areas all right so here we have some code adding some walls I just implemented this set is one coupon function as you can see down here we simply set our boolean to either true or false and up here we first grab the node on that position so this one on one 0 we said is walkable to false and then we update the node back in our path note the right so we're setting a wall on 1 0 1 1 and 1 2 so essentially we got a vertical wall right next to the start alright let's test and yep there we have our path correctly going from start to finish without going through the walls awesome so now that our algorithm is fully working let's make a bigger grid and do a simple performance test okay so here I had a simple performance test so we have a grid size of 20 by 20 and we're completing the path from 0 0 to 19 19 and we're calculating that path five times then we're simply on looking into the logs in order to see the time in milliseconds but before we run this let's try it out on the path finding that we did previously using objects okay so here I am in that other project here we have our path finding working with our Platinum class so as you can see we're using a bunch of reference types in here and for a test we're doing the same thing so calculating the path from 0 0 to 19 19 on a grid of 20 by 20 and we're calculating that path five times all right so let's test ok so here we are and there we have the result about 700 milliseconds now obviously what I have implemented here has not been optimized at all this is the most straightforward implementation of the astar algorithm using objects you can implement path finding with object oriented code and get significantly faster results which is some a little bit of optimization but still let's take this as our baseline so here we're taking 700 milliseconds and now let's do the exact same test with our that oriented version any of their days over here you can already see quite a big improvement going from 700 milliseconds down to just 1 so here we have this code running on the main thread calculating five paths one after the other now let's put this code inside a job to make it multithreaded so we're going to implement all this in our job struct so we just implement a job and now here inside the execute method we're going to have essentially the contents of our find path function and with jobs our execute method does not have any parameters we need to receive the parameters out here as fields okay there it is no errors everything is working great all right so now up here let's instantiate the job all right so here we have the same thing to find it start at zero zero at the end at 19 19 we'd find the job and then we run it all right so let's test okay so here we are and yet we still have the exact same results that's because we were running the job on the main thread and it's not yet multithreading in order to make this multi thread instead of run we need to call schedule and we need to schedule all the jobs and then complete them all all right so here it is we define an array of job handles we set them through our 5 we schedule all five jobs and then we tell them all to complete all right so fun let's test and if there it is now it's indeed multithreaded and it's taking point 5 to point nine milliseconds instead of the usual point one point two to one point three and now there is still one massive improvement that we can do which is we can enable the birth compound so appear using unity dot burst and now down here on our jump now since we already wrote all of our code thinking about the limitations of burst all we really need to do is add the burst compile attribute and if there it is this is all it takes however here we did use one thing that is not supported on burst which is only in here on the neighbor offsets we cannot use an into array inside of bursts unlatches easily changes alright so there it is very simple and again everything else is already been made with burst in mind so our struct only uses valley types and everything should work perfectly all right so let's finally test our massive improvement any of their you we have our purse being finally compound and look at that we have 0.05 milliseconds so there is the insane improvement you get by combining all of the dot stack so with the normal unoptimized objectoriented pathfinding we had this action takes 700 seconds and using dots with the job system and burst we have it working in 0.08 nine seconds so even without doing any further special optimizations we already have some insane speed so here for an insane test I've made the grid 100 by 100 so again going from 0 to 9999 and we're doing 50 jobs so this means that we're running 50 pathfinding jobs on the exact same frame so let's see how long this takes and yep there's the answer 50 units all searching for the path on the exact same frame and it taking 2 to 5 milliseconds so here we have the profiler now let's look at a frame where we're calculating a path so let's look at one of these spikes and yep over here we have a frame where we're working on some of our jobs and you have look at that all these jobs being scheduled and executed using burst and down here and look at only jump threads and if there you go and look at all of them all completely very busy so we have tons of jobs all of them working in parallel so here you can see the insane performance gains you can get by using the unity dot sack ok so here we have implemented our superfast path finding algorithm using unity dots with the job system and the burst compound now this video is already very long so I'll leave it here for now but I won't cover using the path finding combined with the entity component system in the next video we're going to set up on the components and build a system that won't run our path finding job and store the resulting path in a component so that the entity can follow it I'll also optimize this code to see just how far we can push this so if you're watching this in the future check the links in the description and if not then hopefully that video won't be out by next week this video is made possible thanks to these awesome supporters go to patreon.com/scishow to code monkey to get some perks and help keep the videos free for everyone as always you can download the project files and utilities from Unity karma calm subscribe the channel for more unity tutorials plus any question have in the comments and I'll see you next time