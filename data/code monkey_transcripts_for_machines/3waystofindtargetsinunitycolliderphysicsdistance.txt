hello and welcome i'm your code monkey let's learn about three different methods that we can use to find targets all methods work pretty much the same for both 2d and 3d these are applicable to just about any scenario where you need to find targets so you can use this for example in an rts where units need to find targets or in a tower defense game for the tower to find something or even on the player itself to enable them to do some calm abilities with the enemies that are nearby we're going to first explore each method individually to see how they work and then in the end we will explore the pros and cons for each method so make sure you stay tuned to the end the video all three methods are valid depending on the scenario so it's up to you to choose the right one for your particular use case over here i have a very simple demo scene so just a normal sort of tower defense game this scene was initially built for my tower defense ai video so there's this tower and i can press a button to spawn some minions they spawn on the right and they move towards the left now the goal is for the tower to find the enemies as they get within range and start attacking them okay so let's begin with the first simplest method which is using a collector with a trigger let's make a new csharp script name this our targeting system for the collider and let's select the tower and attach our script okay now like i said this first method is using a collector so let's add a circle collider again if you're working in 3d then use a spherical layer instead here make sure you set is trigger to true since we do not want this collector to be a solid object and simply modify the radius to get a good attack range so maybe something like this so as the enemy gets within that area the tower is going to start attacking okay now let's open up this script and here this is going to be very simple let's just get rid of these and instead make a private void on trigger entry 2d again if you're working in 3d then you add the ontrigger enter instead now this function is triggered when another collider enters inside the shape of this collider so it gets triggered exactly once on the very first frame that the collision starts so let's first do a quick test just to make sure it's working so a debug.log just say something okay let's run this in c okay so here i am and let's spawn an enemy here he comes and let's look in the console as the enemy gets within range yep there you go we have our target okay so with this we are correctly identifying the collision now if you have issues with the collision check out the video link in the description where i go over the various causes for issues with collisions essentially you need at least two colliders and one rigid body for the collision to actually trigger so in this case my actual tower has a collider the circumference that we just added and on the enemy it has a box leather and then also a rigid body so with this we have our collision being detected now we also need to identify that this object is actually an enemy we don't want to attack friendly units that go inside this range or really any other objects so the simplest way to identify the object that went in is to simply ask if it has a certain component so the enemies are being made using this prefab and this prefab also has a very simple enemy script so we can simply use this to identify that what entered inside of our collider was indeed an enemy so when we have the ontrigger enter let's see if we go into the collision and we do try get component try to get the component of type enemy and if this is true then we know that we collide with an enemy so now here all we have to do is just attack and now in the demo that i have prepared i have my tower object which has a tower script and over here on this very simple tower script i've got a function to set the target so let's just call this one so over here on the targeting system let's first grab the tower so private tower for the tower and grab it on the awake so just get component of type tower so just grab the tower and after here after we verify that it's an enemy we call set target and pass in the enemy all right that's it let's test so here we are and let's spawn an enemy and he's coming in as soon as he gets around here if there you go now the tower is indeed attacking the enemy alright awesome so here we have the very first method for finding targets we use a con leather which can be of any shape here we use a circle collider but it works with a box leather or really any collateral shape so using this method we have a collider set to trigger we'll listen when other colliders enter inside the area of disconverter and if so then we have our actual target we set the target and we attack the object alright so this is the very first method now for the second method this one is going to be cycling through a list and testing for the distance so let's first make a separate script so in uc sharp script calling the targeting system for the list distance let's select our tower attach our new script and let's remove the previous one okay now for this one it is not based on a collider so we can also get rid of our targeting collider now here the one piece of data that we're going to need is the range so let's make a serialized field for a private float for the actual range this is our attack range and here in the editor now we can set the value so let's set it to 60 which is the same we were using and now here let's make a simple private void update and on update we want to essentially cycle through all the enemies in our world now for that i have the enemy script here and this enemy script already has a static list of enemies so there's this list and this function to get that list and on this list down here on the enemy awake the enemy gets added onto the list and when the enemy dies then the enemy gets removed from the list so this list contains all of the unlive enemies in the world so here we just cycle through the homeless so do a for each enemy enemy in and go into the enemy and get the enemy list so we cycle through the entire enemy list then we just do a vector 3 dot distance calculate the distance between this transform position and the enemy transform position and we simply do an if and if the distance is under the range then we have the enemy within range and if so then we simply attack the enemy so the same thing we get a private tower to get the tower reference so we grab the tower and here just tower set the target and pass in this enemy now in this case our enemy list is already prefiltered to contain only the enemies that are alive so here we don't need to verify that it is an enemy and we don't need to verify that it's alive so that's it it's this simple let's test here we are and if i spawn an enemy here he comes and as he gets around here within range and yep there we go we have our target so our targeting system is indeed working the enemy spawns it does a vector3 dot distance between this position and the enemy position if it is within a certain radius then we have our target all right awesome so this is our second method now for the third method and by the way if you find the video helpful consider subscribing and hitting the like button it really helps out the channel now the third method is using a physics call so let's begin like we did by making a new csharp script for the targeting system and let's name this the physics overlap here's the tower and let's attach this one and remove the previous one okay now here let's make a very simple private void update and on update the method we're going to use is the physics 2d dot overlapped circle again when working in 3d the logic is pretty much the same except you use the physics class instead of the physics 2d so what this function does is it asks the physics system for all the collaterals that are inside of this area so it requires a point and a radius for the point we just use this transform position and for the radius let's do it like the other script so let's expose a certain range and we use the range in here and here let's set the range to the exact same thing so 60 okay now here this function returns a collector 2d so for now let's just do a debug.log to see what this outputs so a debug.log on the result of our overlap circle and let's test and if right away we do see it working so it's an overlap circle in there and right now there is no collateral in there so it's returning no we can verify that it is indeed working if we add a collector onto the tower so let's add just a basic box letter 2d and if there you go it does identify that collider however there's one thing so it's correctly identifying the tower collider which is indeed within our radius however the function that we use here returns just a single result so it will only return the very first collision and no more so depending on the order in which the scripts are run that means that the enemy might be ignored so here comes an enemy and either the enemy or the tower won't be ignored so right now it's only finding the enemy and not the tower so for that two enemies it will only find one of them so instead of using overlap circle we can use the second one which is overlap circle all so this is the same overlapping logic except returns all of the colliders within this circle so we've got an array of our colliders and all we have to do is just cycle through it then in here we just need to identify which ones are the enemies so like we did previously we can simply do a get component so collider 2d try get component of type enemy and if it is then we do have an enemy this is an enemy so once again let's grab our tower reference so we grab the tower and here tower set target and pass in this enemy again you could then do all kinds of logic with this list that you have here for example finding the closest within the range or just like this which will essentially pick the last enemy within range so let's test this method here we are and let's spawn an enemy here he comes and as soon as he gets about here and yep there you go it does target the enemy and the enemy does get damaged and gets destroyed so here we have the third method only working this one is doing an overlap circle around this area and as soon as the enemy collider goes inside it then we have our collision and we have our enemy all right awesome so here we saw three separate methods for finding targets now let's think about their pros and cons now the first method on using a trigger collider the main pro is its simplicity so it's very easy just add a collider and a single function and it all works very easy to implement another pro is how it's very visual and designer friendly so you don't need to make any extra editor scripts you can see the range by default whereas for the other methods that use a float for the range it doesn't automatically have any visual yet another pro is how it's event based so rather than querying the physics system on every update it simply runs a code when a collision happens so that's much more efficient the main con is how it requires you to add a collider onto your object so if you use this method a lot you end up with tons of colliders which may cause a performance impact also if you already have a trigger collider then you can't use it just like this since you can't have multiple trigger colliders in the same object and listen to events on a specific one so you would need to make a separate child game object with a detection collider and handle the logic there another potential con is how it requires working with the physics system so if your target objects do not have collaterals then the collision event will not trigger those are the pros and cons for the trigger collider method now on the second method the unless distance the main pro is that it's very easy to implement you don't need to touch the editor at all everything works inside of your codebase so for me as a programmer this is the reason why i use this one a lot another pro is that it's very versatile you're doing a cycle going through every single enemy so that means you can easily validate more than just a position for example you can easily make it so one type of enemy has an attack range of 10 but another enemy of a different type has an attack range of 20. another pro is that it's not dependent on the physics system so you can use this method to identify objects that do not have any colliders at all then the main con is potential performance issues as you can see this method cycles through all of the objects so if you have a handful of them then it's unlikely to cause any issues but as the unlist grows bigger this starts to take more and more time to complete so if you have a hundred enemies then this method is definitely not good another con is like i said the visualization isn't automatic so this exposes a float for the range and by default you don't see that in the editor you need to guess how far it goes or make a custom editor to showcase that another con is also related to performance which is that you need to run the code constantly now this con has a simple fix which is to just test less often than on every frame so if you combine it with a simple timer and search through the list at most something like 10 times per second that helps a lot but again it's still more complex than the previous method which is event based and in last method which is the physics overlap the pros and cons are similar to the list distance method the main pro is that it's easy to implement just like the list method it all works through code so there is no need to touch the editor another pro is that it supports massive amounts of enemies whereas in the unlist method it becomes worse and worse the bigger the list is here it asks the physics system for the collaterals within an area so it doesn't need to query every single object that exists and the main con is just like the enlist method which is potential performance issues since this is not event based you need to call the function on update if you do a physics query on every single update then it can cause some slowdowns but just like the enlist method you can minimize this con by adding a simple timer and searching much less often than on every frame another con is again the visualization is not automatic so if you want to see it you need to make a custom editor and another potential con is how it is dependent on the physics system so the objects that you're trying to find need to have a collateral in order for the physics query to work if they do not have collaterals then they are not detected okay so those are the three methods as you can see they all have their pros and cons now for me i usually go with the second or third method the first method requires working in the editor and modifying the game object by adding an extra collider so after some time you might forget which script that collider is related to so it can become quite messy whereas the other two methods are done internally with code so all the logic is in the same place for me as mainly a programmer i like to keep my games through code as much as possible so that is why i prefer those too usually my approach is to use the enlist distance method since it's so easy to add and then if i come across any performance issues then i might change it to the third method so there you have it three nice methods for finding targets each with their pros and cons if you have other methods you don't like to use go ahead and post them in the comments i'm interested to see how other people handle targeting as always you can download the project files and utilities from mintycodemonkey.com this video is made possible thanks to these awesome supporters go to patreon.com unitycodemonkey to get some perks and help keep the videos free for everyone if you found this video helpful consider liking and subscribing post any questions have in common and i'll see you next time