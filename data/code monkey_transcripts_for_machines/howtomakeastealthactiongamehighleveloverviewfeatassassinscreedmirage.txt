hello and welcome I'm your codm so here let's see a highle overview of how to build a game just like Assassin's Creed Mirage I'm going to cover all these mechanics and how I would go about building them I made a page on the website with links to all the tutorials that I'm going to reference it's Link in the description basically this is a new format that I'm trying out going through a game or a specific genre and doing a high level overview of the various mechanics and referencing the various tutorials where I've covered them in detail hopefully if you're trying to build something similar to any of these mechanics then this can be quite useful I simply don't have the time to make super detailed stepbystep course on every single game every single genre imaginable but I think this quick format can be useful to help point you in the right direction as with everything that I do this is just an experiment so do let me know in the comments if you find this format useful like the video and subscribe if you do okay so here let's see a nice high level overview of how to build a game like Assassin Creed Mirage I play the game and I analyze it so here are the mechanics that I'm going to cover personally I always really enjoy these Assassin's Creed games I love historical medieval stuff and I love open worlds with lots of stuff to do traversing that open world is one of the crucial things so speaking of that the main thing you probably think of when you think of Assassin's Creed is the parkour system basically how you can just look at a wall then simply run towards it and the character jumps and grabs onto every hole point and everything looks great and climbs all the way up to the top now this is one of those mechanics where if you're a beginner this might seem impossibly complex but in reality building something like this is actually relatively simple or rather I should say the difficulty in building a mechanic like this is not necessarily in terms of logic complexity the difficulty is simply in the massive amount of work required to build all of the unique animations set up all the home points on every single wall in the entire game doing all of that for a large world is obviously a ton of work a ton of animations a ton of EDG cases a ton of stuff so it is very laborious but in terms of logic it's actually quite simple basically you need to Define what exactly is a home point and then as the player moves pretty much just need to figure out which one is the closest Home point that matches the player's input so for example over here in this scenario this one is marked as a hold point this little right here this is also a hold point this is a home point this one as well as is that one as is up there and so on so all of these are individual hold points that again were marked either manually or automatically through some algorithm in terms of the logic itself they can simply be just letters with a basic script on top maybe that script could then have a reference to a scriptable object that defines all the data on that specific hold Point like saying that this one over here this one is a wire whereas this one is just a little thing coming out then the logic in the player itself the player would simply do a physics query around the player position so right around here it would do some kind of Circle to identify all the hold points near the player position it also takes the player's inputs into account so if the player is going this direction then it's not going to check for physics collisions all all the way over here so it checks for nearby Home points through some kind of physics square like an overlap sphere then it simply finds a closest one although there can be multiple closest ones so over here all of these ones all of these are pretty much around the same position so as I'm going to move and jump he's going to grab pretty much any of these then the system decides to pick which specific animation matches this one so so which specific animation goes from the player being over here on the floor to picking up some bar in here or this one here so in the game itself if I just move forward and I jump and there you go he grabbed straight onto that one I can move down I can go onto this whole point I can go up to that one side to that one and so on and of course one climbing the controls become vertical so the control Vector instead of being down on the XZ plane instead of that now it is up here on the XY so move up or move to the side and for these animations they've got tons of animations but they also have quite a bit of dynamic to them so as you can see it always grabs on the exact same position now they don't have a million animations they've got a couple hundred maybe even a thousand but they definitely don't have millions of animations so to handle Dynamic animations basically how do you handle Dynamic Logic on top of static animations for that you use inverse kinematics Unity actually has a builtin tool to do inverse schematics it is called animation rigging I made a tutorial on it it is super useful super awesome for making your animations a lot more Dynamic another crucial mechanic in these games is Eagle Vision I think the original Assassin's Creed was actually one of the first games to pop poize this mechanic and afterwards the Batman Arkham games and Witcher 3 all of them Implement it's a really interesting thing basically you press a button and the world goes into this special Vision mode where it highlights individual enemies some helper Allied units and a bunch of items so to build something like this basally there are two ways to do it once again you can do a simple physics query around the player then you can locate all the various objects that Implement some kind of interface related to Eagle Vision and then you can basically T those objects in order to highlight themselves so that they would change the material to change the Shader to be more visible and so on or alternatively you can just have the player just the player fire off some event when they enable Eagle Vision and then all of the individual objects all of them have a certain script on them and then that script listens to that event so when the player enables this mode and checks the distance towards the player and if close enough then enables that visual so those are the two main ways you can do something like this in terms of visual for achieving this this is any kind of Shader you want for the postprocessing the black and white so this is just the basic volume system you can just desaturate the entire scene and you would probably add some postprocessing so on these individual objects once in this mode then render them in a different way for example something similar that I did in my own game dinky Gardians all of the objects have a specific Shader and when the player is close enough to them to be able to interact that it simply changes the outline from black to white in order to show this is the active object in terms of the visuals for the postprocessing changing from the desaturated into the regular world and so on for that you can simply have two volumes so you can use just the volume system to modify the post processing you can see how to do something like that like in the video where I remade the mechanics from Verdon including the gas system another mechanic related to that one is the Eagle Eye so this is where the player can pretty much just spawn an eagle and the eagle flies and then the eagle can just look around and identify other objects so I can move the cursor in order to tag a bunch of enemies so I can tag that one and that one and so on it can also find some special chests some special objects and so on so once again implementing something like this actually rather simple first you need to be able to tell where exactly the eagle is looking at so as I move the cursor where exactly is the cursor over in the 3D world that is pretty much exactly like I covered in the mouse position in 3D video basically just do a recast from the camera position down to the terrain and figure out where it hits on that position so one way would be to do just do a r cast in order to find the mouse position over there on the floor on top of the castle then in there simply do a sphere cast around that position to figure out if there's anything interactable within that area and over there then yep it would find this enemy and it would simply tag it now for identifying objects the best way is to use an interface that way you can can identify both enemies as well as chest and any other kind of object interfaces are insanely useful and I highly recommend you to learn about them if you don't know them they are so useful in so many scenarios for example I use interface in my own game tons of times all over the place I think pretty much every single object in my game things like the dinky the player all the various buildings machines and so on I think pretty much all of them implements at least one interface basically with an interface you can write code against that interface and then the interface won't allow you to identify any kind of object so it can be a chest it can be an enemy it it can be a special object or anything like that so related to that it's the mechanic about tagging so you can basically tag objects and then I can exit the eagle mode and the objects are still visible so I can still see all the enemies and importantly I can see them actually through the walls again for this one several ways you can do this in terms of the actual UI elements in the world if you want to do that place UI elements in the world then you can make a world space canvas with this you can place UI elements things like texting like images you can place them directly inside the world although they will be hidden by occlusion which over here is not what we want if we want to see them through the walls so to solve that one option would be simply to use that method and then render them with a special material with a special Shader that doesn't actually write the depth so it is always visible alternatively another method is to use a stackable camera so you can make one camera and that camera is standard then you can make another camera and Define that one as an overlay camera and make sure the settings are exactly perfect then you go on to the first camera and you set the second camera as a stackable camera then as long as you make the second camera only render these UI elements that means those UI elements will always live on top of the main World on top of the main camera or of course alternatively you can simply convert all these objects convert them between World position into UI position then simply move some regular UI objects another unique mechanic about these games is the unveiling of the map so basally you climb to the top of these various towers and as you do it unlocks more of the map now for implementing something like this you basically just have two versions of your map you've got one where everything is locked and one where everything is unlocked so you've got two separate textures and then with those two textures you can basically use a separate mask in order to mix both of them in order to figure out which one should show the loock part and which one should show the unlocked part I covered how to do a mask like that in the Rover mechanic simulator cleaning video so in order to build this mechanic you would do the exact same thing when the player gets to the top of the tower and synchronizes it then you basically update the mass texture for that one specific Tower so basically each Tower is going to have a related Mass texture probably through a scriptable object or something like that and in terms of visuals for animating it you could do it through a simple Shader effect could be EXA like I covered in the Hades transition effect video you basically just find a gray scale texture and then basically animate how that one shows the underlying texture and then of course it's the icons themselves so for this you would probably just have the icons plac in the map by default then these icons would simply have a simple script and in that script they would have a reference to a specific Tower then whenever the player unveils whenever it synchronized a brand new tower that action would fire off an event then the icons over here on the map they would listen to that event when that happens they would check the tower that they are linked to again prob with a scripal object check the tower and if that Tower was one that was synchronized then make the icon visible if not just hide it then for something simple like the assassination so this is just a basic interaction system so I approach and if I can interact and I'm closing enough then I can simply do a special animation special interaction there you go pretty simple it works for assassinating enemies and also for interacting with all kinds of objects in the world this is just a basic interaction system kind of like I covered in the how to talk with NPC's video all the various interactable objects they have some sort of collor just so they work with the physics query so this would have a collider this would have a collider and so on then again as usual the same thing so the player does a overlap sphere to find all the interactable objects around all of these objects would Implement some kind of interactable interface then checks which one is the closest in order to show which button to input and when the player Triggs the action then just triggers an interaction with that one object with a system like this you can easily create things like assassinations you can set the blend in interact with objects steal things loot things and so on next up is the stealth a ey so basically the enemies have States they can be idle where they are really just patrolling around then if they spot you doing something bad they will't go towards the player and investigate if they see the player doing something bad for long enough then they go into attack mode in that mode they simply chase the player and attack but then if the player runs and breaks line of sight if so then the guards will investigate the less known player position after some time if they don't find the player then they simply go back into the idle state so all this is really just a super basic state machine this is actually a topic that I've wanted to cover for quite some time it's it's yet another mechanic that looks quite complex but in reality it's actually quite simple I covered a super basic sa machine in a video a very long time ago basically the one this game is using the exact same concept just a bit more complex for seeing if the player is visible by the enemy you can just do a simple Ray cast from the enemy position towards the player or more accurately you can actually use a sphar cast because you never want the accuracy to be depended on pixel on perfect bases so you always want to allow for a little bit something more forgiving but at the same time doing a sphere cast that only tests for direct distance whereas you obviously don't want to detect the player if the player is behind the enemy so to solve that you can also incorporate a vector 3 dot to check the angle I did something like that in the backstab mechanic video where I made sure to make a special attack that only works on a backstab meaning it only works if the player is behind the enemy so if there's no obstruction and the player is in front of the enemy then you increase an alert timer if long enough then just go into the investigate mode and then for losing interact the player that is really pretty much the same thing you would do the same sphere cast to find out if the player is visible and if the player stops being visible then you basically just tracked that position so the last down position where the player was visible and then you simply tell the AI to move to that point and then from there really just move to random points between that area if enough time passes and it still doesn't find the player then simply go back into the at State one more related thing is simply enemies attracting other enemies so for example if this enemy finds something then it would do some kind of sphere cast around its position and simply find all of the other enemies and simply tell them to attack on the same position so you have the stealth enemy eye it's another one of those things that looks pretty complex but in real is actually quite simple like I said this is something that I would like to cover in a dedicated tutorial doing some stealth n Mii so hopefully sometime soon I will have a dedicated video on exactly doing that now for some rapid fire quick ones for viewing the enemies and the objects through the walls for doing that you can use the render objects feature I cover that in detail in one of the many lectures in my ultimate un overview course then for the talking system where the camera is placed dynamically behind the player looking at the Target this is pretty much exactly what I built in my turnbased strategy course the camera is placed dynamically on the shoulder of the shooting enemy whilst pointing towards the target enemy so this really just involves some simple Vector MTH to calulate the point right behind the player shoulder and to the side then for the virtual cursor the game is fully playable with the game pad and whilst on the menu the GamePad uses this really nice virtual cursor that identifies all the objects I actually covered this in detail in a very recent tutorial it is super easy to build when you use the input system and I use the exact same thing in my own steam game dinky Guardians personally I find this sort of thing much better much more intuitive for navigating regular menus as opposed to the old School navigation system which really just moves from button to button personally I really prefer the mouse cursor virtual cursor system but when you're using a mouse inside of a gamad the cursor goes into this custom Hardware cursor this is another thing that is pretty subtle but makes your game look quite a bit more nice so it's say nice little bit of Polish I made a tutorial on this and I even made a fullon asset on how to make this super easy including how to support animated cursors then on the menu for checking out all the skills each one of those skills has a nice accompanying video showing what it actually does and how it actually exists this is another great thing especially in terms of tutorials as the say go show don't tell for implementing this you can easily build it using Unity video player it's a simple component where you can play some kind of video and then render it onto a texture onto a material or so on then during loading there are some hints you can cycle through them and this is really just some text so for storing these hints you can sort them in a simple script B object and in the script B object itself instead of storing just a simple string you can store a localized string so you can use unity's localization system so you can use unity's localization package in order to make all these strings easily localized same thing for the codec and database so storing all of these things all this text all these images and so on all these topics this is something you can store pretty easily in a ton of script objects that is pretty much exact same thing I did in my own game for making the knowledge base okay so that's a high level overview on how to make a game just like Assassin's Creed Mirage like I said this is a new format that I'm trying out basically doing a high level overview of various games and genres I've already covered lots of separate tutorials on lots of things and if you put them all together you can build all kinds of games I really don't have time to make 20hour courses on every single game every single genre imaginable but I think hopefully this format can help at least point you in the right direction so do let me know in the comments if you find this format useful like the video and subscribe if you do all right so thanks for watching and I'll see you next time