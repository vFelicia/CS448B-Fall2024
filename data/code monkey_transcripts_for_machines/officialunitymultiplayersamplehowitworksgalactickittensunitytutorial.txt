hello and welcome I'm your code monkey and here let's do a deep dive on one of unity's official multiplayer samples the galactic kittens game this is a very simple 2D Coop multiplayer game that works great as a learning project for understanding how to make multiplayer games using unity's official multiplier solution called netcode for game objects of the source code is available so you can download it and pick it apart to understand exactly how it works if you've seen my net code for game objects video you shouldn't be able to easily understand how this project works this project is intended to be as simple as possible it is meant to be a Bare Bones multiplayer sample for something more complex afterwards definitely go take a look at the much more advanced simple Kong boss room that one builds upon this base and includes tons of optimizations that you definitely must learn to make a good multiplayer game the reason why I researched this official project is because I'm currently working on my upcoming free multiplayer course I'm hard to work on it and hopefully should be out within the next few weeks so if you're looking for a guide path stay tuned for that and go watch the free single player course to prepare for it also as the unity they officially sponsored this video so if you want to learn more about this Mo project then check the link in the description to download it and inspect it for yourself and if you want to make multiplayer games then Unity also has tons of useful tools in their Unity gaming Services brand so also check that out with the other Link in the description okay so first let's do a quick look and play through the game and then let's open up the project and inspect how everything works so we can learn how we can build multiplayer games now if you download the projects to try it out there is one very important thing with how the game is set up basically on all the scenes there is one scene called bootstrap this scene starts up all the necessary objects so when testing it out for yourself make sure you go onto this scene before ending play otherwise you might see some errors so here in the scene let's hit a play and try out the game alright so here's the game gonna like the kittens and right away we have a nice scene waiting for input to start so I'm going to click with the mouse there you go we've got a very basic main menu so we can host which is to create a host for the multiplier we can join which is we can join as a client to connect to a host or just quit the game okay so let's go ahead and join as a host and right away we go into a nice character select scene so here as you can see this game supports up to four players and each player can use a different type of spaceship so by pressing a or D as we can see the controls down here by pressing that I can swap out which spaceship which character I want to use so let's select one let's go with cat okay so here I've got another build so on the main one I made as a host on this one I can join and if there go it joins connects the brand new player and sets a new character so now again on this one I can also modify my character and yep it synchronizes perfectly over there with the host so I can change whatever character I want so I can wait for some more players to join or I can go ahead press on ready and there you go now this character is set is ready but the other one is still waiting so the game has some logic waiting for all players to be running so as soon as I press ready on this one there you go it starts the timer and both players load and they both load into the control scene and they both wait a bit so the players can see the controls and once again they both load they both synchronize and here it is the main game scene so I've got a bunch of controls and now I'm playing solo so I have to kind of control both at the same time so as you can see I can play with a client down here I can fire a bunch of bullets or up here I can also fire a bunch of balls okay so there you go as you can see a bunch of enemies are being spawned all of them are being synchronized so all of them are in the exact same position on both scenes I can move around the players anywhere and I can pick up some pickups and with another key I can enable a nice shield and again everything is nicely synchronized so I can play around okay I'm probably going to lose one but okay all right so there you go this player down there was hit so the spaceship has been destroying okay now on this one let me try to make it until the boss fight there you go the boss is coming okay so here is the boss and I just have to shoot it and the boss has various stages and again note how everything is still nice and synchronized so the boss is doing a lot of things and I just gotta take him out and I end up losing so we go into a nice fit menu where we've got a bunch of sets so let's try again so here I am on the second try and here comes the boss again so let's see if I can defeat it also knows how the characters the spaceships they have a different Sprite when moving up or moving down so those Sprites are changing and note how it is indeed being synchronized so everything is working perfectly okay so let's see if this time I can actually defeat the boss and okay just a bunch more shots and just a little bit more and there you go the boss exploding and again note how everything is nice and synchronized and up here we go into a nice Victory scene where we can see the scores enemies destroyed and so on all right great so as you can see it's a simple game but this showcase lots of things that are very useful and very need to learn in order to make multiplayer games okay so that's the game as you can see it's pretty simple which is excellent as in learning project it involves lots of multiplayer topics such as scene loading character selection spawning players firing bullets synchronizing the player enemies and boss handling the win and game oversights and so on so now that we've seen how the game actually works let's inspect to see how all of this is built so for starters over here I'm looking at the project window we can see all of the scenes involved in this game like I said the first one is the bootstrap so this one starts all of the necessary Global objects then after that one we go into the menu so this is the main menu with the main buttons then when we create either a host or join as a client we go into the character selection window over here the players can join and select their character then once all of them go into ready we go into the control scene so this is just a basic window just showing the controls for the players to play and after this one is on screen for a little bit then transitions into the gameplay scene and this is where the game actually happens then through the course of the game either the player wins or losses so either goes into the victory or the defeat scene okay so that's the main way as to how this game is structured so let's inspect the bootstrap scene this one like I said creates all of the global objects needed for the game to work we can see that it has primarily a network manager this one is the main script that you need in order to be able to use netcode for game objects again definitely go watch my net Code 4 game objects video If you haven't seen it yet in there I cover all the required components to make this work so this one has the main network manager and over here has all of the network prefabs also note one important thing which is over here there is no player prefab the reason for this is because the player prefab this one is spawned automatically when someone joins but since we're creating the network manager over here and then when connecting we are going to the character selection scene when we go in there we don't really want to spawn the spaceship right away so that is why in this case we are not using the player prefab in order to automatically spawn any kind of prefab for the player we're going to handle that manually As We join both the character selection scene and the gameplay scene so there's no point prefab then over here all of the various Network prefabs so this is basically the prefab list that needs to be added over here for anything you want to spawn dynamically in the game so if you want the bones to be able to spawn and synchronize and they need to be here on this list then down here for the rest all of it is mostly on default so it's using the entrance password okay great and one very very important thing is over here scene management is enabled so this is how you notice how when the host starts a new scene the client automatically unloads it that is because this one is toggled otherwise you need to handle that manually okay so this one is the network manager pretty basic most of it with defaults then we also have a loading manager visually this one really just has a black screen that's it this one is only used for visually fitting to Black and fitting away we can inspect the script to see what it does here it is and first of all it extends something called a Singleton persistent this is a class that they made for this demo basically just creates a new Singleton so a standard static instance and then just adds don't destroy and load to make sure this one is persistent so it never gets destroyed that way the unloading scene manager there will only ever be one and it won't persist so that is why you start from the bootstrap scene over there it starts the unloading scene manager and then just lives until you quit the game then the other object in this scene is the go to menu this one is a super simple script basically just Waits until the unloading scene manager has been created and when that happens it loads the main menu scene however note how over here it is not using the basic unity scene management instead it is going through this script and if we inspect this here we can see what it's doing so it's starting a CO routine in order to do the fade in effect and so on but then the very important thing is this one takes a parameter for is Network session active basically it's going to do two different types of loading depending on if a network connection has been established or not now we're here in the bootstrap over here we don't have a connection so this one is set to false so then over here when this one runs it's going to go with this one as false so it's going to load the scene locally and this one is going to load the scene as normal so just go and use the unity scene manager and just call load scene but afterwards when the connection is established then instead of using this function it's going to use this function and this one over here note how it does not use the regular scene manager instead it goes through the network manager accesses the scene manager on that network manager and then loads that scene this is important like I mentioned this is why the network manager has scene management enabled this way only the host load scenes and then of the clients all of them will load the target scene automatically because again the network manager has seen management enabled so basically for this bootstrap Scene It just sets up everything locally so there's no connection at all here just as the basic setup and then loads the main menu so let's open up the main menu scene here it is on this one again this scene also has nothing to do with any multiplier everything is still local here it just has this mini controller with this many manager script and over here on this script simply on update just as for a key and if so triggers the transition that transition then shows the regular buttons that we saw the host the join in the quit and down here we can see how that is implemented so we've got our click buttons here so for the host when that happens it goes into the network manager and starts the host right away so again example like are covered in the netcode for game objects video then it plays a sound effect and then constellutes in but again remember how the network scene this one is now going to default to true so when it starts the host when it loads the scene it's going to unload the scene through the network manager and also remember how this has the fade in by default so first it's going to fade in it's going to wait until the unloading fade effect is finished when that finishes then it actually loads and then it fades out so that's how the visuals and logic are connected that's how the host Behavior works and then when clicking join to join as a client for this one it's going to start this Co routine so let's see what this one does and this one is actually interesting it's going to run this function the fade on which we can see what this one is doing so it does another core routine and basically this one does the fade in then waits for one second and then Fades out so this go routine is pretty much just going to play that in Mission so fade in wait fade out and then back in the same join function over here it's going to wait until the load effect is on can load which means until it has been fully faded in and when that happens then it's going to go into the network manager to start the client again remember how because of that setting on the network manager to handle the scene management because of that when you change the scene on the server the clients will automatically unload that scene so that is why over here and locally it is first fading and only when the fade has finished then it starts the client which in turn won't load the scene right away okay so after that both of those will enter the character selection scene and this scene is very interesting basically I saw a bunch of people commenting on my netcode for game objects video on how to do a multiplayer character select scene so this sample is super useful here we see we have two very important scripts so the character selection manager and the client Connection Manager note how both of these have a network object component again this scene is now correctly connected so the previous two scenes they were only in single player no connection but when we get to this one we do have a connection active so in order to synchronize things we need to make sure we use the network object you must add this component whenever you want to synchronize anything across the network so let's begin by inspecting over here the client Connection Manager now the purpose of this class is to handle the number of clients for a game you probably want to limit the number of players you probably don't want an infinite number of them but right now if you just use our client it will always join the network so if you want to add some kind of limit to how many players can join you need to handle that logic and that one is handled over here on this script if we scroll down we can see there is a can connect function so here it is and the main thing it does is over here just gets the players connected so it goes into the network manager in order to grab the list of connected clients and checks if it is above maximum if so then it says we are full and if not this one isn't allowed to enter now as to how this one is used if you go over here onto the unloading scene manager script this script is listening to a comeback over here on the network manager when the scene loads so it goes into this function and here this one visibly gets triggered when a scene is finished loading and this one is triggered on a per client basis so that is why over here we've got the client ID so this one is triggered when this client has finished loading then as usual for handling the player connections or nonconnections we want to run the logic only on the server so if it is not the server we will return we don't do anything and then it's over here so when the client finishes loading that's when we're going to call this function can connect client and over here this function is going to run down that we just saw if the client can connect if so then it's going to return true so the client can connect but if not if for example the game is already full if so then it's going to run this remove client function and this function over here essentially kicksey client out and the way it does that is using a client RPC again make sure you watch my phone video if you have no idea what is a RPC client or server RPC basically this one takes a client RPC params and over here on the params you can Define what clients will receive this RPC so you can send a client RPC to all of the clients or just a specific one so in this one in order to remove the client it receives the client ID then creates a new client RPC Brands and make sure this message only goes to this client and basically tells this client to shut down and then down here on that function really just triggers the shutdown which means the client goes into net network manager and call shutdown and goes back into the main menu so this is both how you can click a player in any way so you can use a client or PC on their end in order to shut down network manager and this is also how you can simply prevent more players from joining a phone game although I should point out that there is actually another method for handling this kind of logic if you look over here on the network manager and we scroll down there is something called connection approval in the docs you can see how this works basically this lets you do pretty much the same thing the only difference is this way the player doesn't even fully connect like the game is doing right now you can accept them or reject them directly during the handshake process okay so that's the main Logic for limiting how many maximum amount of players you can have the other important Logic on this scene is handling the character selection so first let's see how does a player actually join like we saw that is over here on the unloading scene manager so it listens to this comeback from the network manager and then on this callback it has if the client can connect if now then it kicks it but if it can connect then it grows over here and just calls this scene initialization function this function then receives a client ID and then simply spawns a new network object and importantly it also changes the ownership so the server is going to spawn this prefab object but it's going to immediately give ownership of that object to the client now we're going to see what this player prefab contains in a little bit then afterwards down here the way the game handles all the players is basically on this array so we can inspect this type so here it is it is an array of type player connection state and this state is defined up here basically this is the type of data that you want to store for each player so it has a connection state which can be disconnected connected or ready then it has the player name the player client and they reference to the player object so back into the init function here basically just Cycles through all that array and then checks for the first slot that is pretty much empty so the first one that is disconnected and set it as connected it assigns this player name this length ID and this player object again remember how all this logic this is only running on the server not in any client so only the server is setting this data then for sending the data to the clients for that server uses a client RPC so after the server sets its own same then over here it's going to sync that state onto the clients and it's going to use this line RPC so it's going to tell all the clients which one is the brand new client ID which one is the state index the player State and the player object then the clients are going to receive this line there are PC and in doing so they are going to update their own site then over here we see one another very very important thing which is look at the type used over here on the last parameter this one is a network object reference basically up here when the server is calling it it is passing in a network object this is essentially how you can send some references over the connection like I mentioned in the net code for game objects video in a client RPC you can only use value types you cannot use reference types so you could not make a client RPC and pass in the player object directly but you can pass it in as a network object reference so you do that and then on the other side on the clients they receive that reference and they can use the function try get in order to try to get the network object that relates to that reference so it can get that player object and then simply gets the component that you want and assigns it like that so this is how you can pass in references through client rpcs okay so that's in Logic for spawning the player now let's look at the player prefab here on the script we can find the player selected character reference here is the prefab so let's open it and we can see this is a commonly empty prefab so there's no visual it just has obviously a network object so that it can be synchronized and then has this nice script so let's see okay so here this script basically handles the character selection and the way it does that is using a nice synchronized Network variable so as to how all of this logic flows we can see it has a start but remember that before the start we are going to run the on enable so basically as soon as the player respond when that happens it is going to add some listeners to these events so it is going to listen when the value changes on all of these Network variables so this one is going to run hook onto these listeners and then up here then the start is going to run and on the server the server is going to set the player ID so that each instance of this prefab knows which player it belongs to and in doing so in modifying display ID value this is once again going to trigger this on value changed event so it is going to run this function and this function is pretty much just going to update the UI and again remember how when the server modifies a network variable on the changes are propagated to all the clients so that's how this code is going to end up running on every single client so the server sets and then when it does it also sets the character selected so this is the other network variable and this one once again it is going to run the Compact and update the UI okay so that makes the default selection logic then as to how the player itself modifies their own character the inputs are handled over here on the update so you can see that it listens to the key a or D in order to select the character going left or right that is going to trigger this function so let's see and this one the first thing that it does is some basic validation just to make sure this value is within the valid ranges and then basically use the server RPC in order to tell the server the new selected character so the client runs this logic and then tells the server and the server then receives this and basically updates the network variable and in turn the network variable when that updates that is then synchronized to all the clients which then update on their UI so as you can see the selection logic is super simple locally the player changes something then use a server RPC in order to save what a change to and then the server updates a value which and gets the update to all the clients also there's one very important thing here which is over here right after sending the server RPC right after doing that note how this client this local client automatically updates a UI basically if you didn't do this there would be a delay the message would have to get to the server and then be propagated back in to all the clients see if he didn't do this right away if you didn't update the UI on locally if so then it would take a differently something like 15 milliseconds which is definitely noticeable and would make the game feel quite a bit unresponsive so when making multiplayer games this thing right here is one very very important thing usually you want to tell the server what to do but then locally you want to reflect those changes right away you want to update the game State instead of waiting for a reply from the server so this is a very very crucial thing you need to know with regards to multiplayer games in general in order to make them feel good you have to update the UI right away even if technically the server hasn't yet received that message okay so this is really all there is to it with regards to the character selection it really is that simple the clients change their value use a server IPC and then the heads broadcast it to all the clients one more thing in this update is we can see over here the Escape so this is basically a simple and quit option if so then checks if this one is the host so if there are no more players if so then starts a shutdown and for the shutdown once again the same thing that we already saw previously so it sends a client RPC to all the clients in order to shut down and for shutting down religious goes into network manager shuts down and then loads back the main menu so that's it super simple now the final important logic in this scene is the play Ready setting again here on the player character the selection on the update so we test for A and D in order to change the character and then we also test for the space bar and it is a server RPC in order to tell the server that this character is running so it's going to run this function only on the server and then on this function basically it tries to start the game timer so here we can see what it does basically goes through all the players and if at least one of them is not yet ready if so then Samsung doesn't actually start a timer but if all of them are ready then goes to enable a simple timer we can see here the Tamil logic again just a basic photo timer so just counts down by time.com time note how this timer is only running on the server and nothing else so it counts on a timer and when that is done it triggers this start game function and this function over here triggers a client RPC in order to tell all the clients to fade in because again remember how the unloading happens automatically so it tells all the coins to fade in and then the server automatically loads the next scene send the clients to the fade in as soon as the fade in complaints the scene they receive the message to load the next scene then load it and everything completes okay so with that we arrive at the main gameplay scene and over here we have another really interesting thing right away so first phone was the same pattern so it starts over here from the unloading scene manager so there's this comeback he checks if the client can connect the server and so on and over here it's going to run this initialization function and over here here is the very interesting thing that I mentioned which is that if you were to spawn the client prefab right away apparently you could get some desync issues in case some of the other clients took a bit too long to load so the solution over here in this function is actually quite simple basically when the client connects it adds the client to a connected list and then it checks if this client is the last client if not then return and doesn't do anything but if it is the con less client then that's when it actually spawns all the prefabs so if you use the automatic scene management make sure you pay attention to this one potential sneak issue so make sure everyone is connected already before you start spawning things then over here for spawning it's pretty much the same thing that we saw so it spawns a network object and again changes ownership to the client so the clients own their own spaceships for the prefab that one is stored inside a circle object we can see here under data the scriptable objects containing all the data for all of the various types inside each of them has a different prefab variant so let's inspect this prefab and this one very simple as usual it has a network object then for controlling this one is a coop game so the clients actually have authority which means they move the transform directly and that is synchronized using the client Network transform so it's just like I showed in the netcode for game objects video this client tells the server where it should be and then down here we can see that these objects are also based on a rigid body so it has a rigid body to the component and then down here a network rigid body 2D in order to make sure everything is synchronized although also note how the body type over here is set as kinematic so that means there are no synchronized physics so it has this and then down here the various player control scripts so let's see this movement script here it is this one is pretty basic if we go down here we can see how it actually works so it handles the keyboard input so just doing some basic key testing in order to calculate an input vector then with that input Vector it runs this function so it takes the input vector and simply moves the transform directly then in turn when the transfer moves that one is synchronized to the client Network transform component so very simple example like I covered in the other video but if you remember from the gameplay the ships also change visual when moving up or down so that part is actually synchronized over here on this function so it just checks if the player is moving up or down and slice the Sprite and then once again use a server RPC in order to sell the server what Sprite it shouldn't load so then the server receives that message and simply broadcasts it to all the clients then the clients receive that message and based on a simple enum because again you cannot transfer objects so you cannot send a Sprite through a client RPC so over here it just defines an enum for all of the possible Sprites and then over here simply set them on only clients and that's really it for the movement as you can see it's super simple then let's take a look at this ship control script this one handles various player logic like for example using the shield so you can see it has for the input and then use a server RPC to turn the server to activate the shield and in this case the server is actually the one that is going to validate the inputs so when the player presses it is always going to trigger This Server RPC and then the server checks if this player can use it so if it has enough specials if so then counts them down and this one as you can see is a network variable so it gets automatically synchronized and then use a calendar PC in order to tell all the clients to activate this Shield then next thing this script does is testing for collisions with the power ups so that one is handled over here using a simple regular ontrigger enter 2D so this one is only going to run on the server so if the server detects a hit if it detects a hit with a power up special if so then validates if the player can handle more and if so once again updates the network variable it does that and also importantly down here it actually destroys the object so it runs this simple function which calls dspawn on the network object and again this logic only runs on the server so that gets rid of the power up next for the health and damage if we scroll up we can see this script once again has a network variable for the health and down here it has a hit function this one once again is only going to run on the server and when this spaceship gets hit it is going to count down the value by the damage which in turn this network variable is going to synchronize you all the clients then it also use a client RPC in order to tell the clients to play some kind of hit effect and then down here on the server it checks if the health is below zero meaning if the spaceship is dined if so then once again just goes and spawns a VFX prefab and then despawns the actual employer spacer finally it calls this function to say that this line has died and then this function is going to run this client there PC again with the client ID as a parameter and this one is essentially going to make sure that only this client is going to enable the death UI animation so as you can see all the helpful logic is also pretty basic now the next grip over here is the one for the player shoot bullet so this one actually spawns bullets and the way this script does that is once again using a nice server RPC so when the player presses space it triggers this function it is going to get a new bullet which once again is going to spawn a network object prefab it does that although note one important thing which is over here this one is spawned as a server object meaning this one is not going to change ownership to the player that fire the bullet all of the bullets are always owned by the server so you can then inspect this prefile to see how the Bonnet works so over here we can find the bullet prefab reference so let's open this and on this one once again it has a network object although this time it has a regular Network transform as opposed to the client Network transform again that's because all of the bullets are going to be owned by the server then once again it has a rigid body a rig a kinematic rigid body it also has a simple collider and then a bunch of scripts for movement it has this basic generic movement script really just all it does is it's only going to run the logic on the server and just going to modify this transform that's it then the other logic is over here the bullet controller this one has an enum for the bullet owner so basically the bullets are always going to be the same object for both the player and the enemy bullets and on start use a client RPC in order to set the color for this moment again different colors for player or enemy Bots and then down here some basic collection detection it is going to test for hits with something that can be damaged if it's a player then it's going to increase some stats it's going to deal on damage to that object and once again going to despawn this network object so all of it very basic so back here on the gameplay scene let's inspect the enemy spawner script so here it is the enemy's funnel script and over here on update we've got the spawning logic and again this is only going to run on the server basically just has a handle enemy spawning function and over here pretty simple just handles a photo timer if it goes above a certain maximum then gets a next random enemy prefab it spawns a prefab and then the enemy handles itself automatically same thing for the meteor so for the meteor over here same thing pretty much as spawns one then the important one is down here on the boss so once again that starts off as a simple timer so when the timer ends it starts this coroutine and first like we saw it first plays a warning UI so that is handled over here through a client RPC so all the clients receive this message to enable the warning UI then just Waits a little bit tells the clients to stop showing the warning UI and finally spawns the boss again just wanting a regular Network object just spawns it and initialize the behavior the boss has this script this boss controller which is actually a really nice State machine but in terms of multiplayer logic everything is really all the same it goes through the various stages firing various bullets and so on and the final important thing is when the boss dies so you can look over here on these scripts for the various boss dates so let's look at the both Nest state so when the boss dies it is going to spawn some random explosions then it destroys the network object and goes into this pasta feed function and again as usual this function does the same thing for any kind of loading that we've already seen so it does a client RPC to tell the clients to load something and then loads in this case the victory scene and finally over here on the victory scene we just see a bunch of basic stats and that's it that's a game and that's how it works as you can see it's a pretty simple and simple project which works great for learning it has some of the basics for making a multiplayer game you have a character selecting multiple characters a maximum player count you have moving spaceships bullets enemy spawning collisions a boss fight and a bunch more here we saw how it all works under the hood by using lots of network objects a bunch of server and command rpcs some interesting scene loading and a bunch more and you probably also notice some things like for example slight delay on the collisions the bones firing movement and so on Unity themselves have said that this project is intended to be the most basic working demo possible so all of those extra things all those things like movement prediction and some more responsive visuals those would be added on top of this starting base for those more complex things definitely go take a look at the more that one builds upon this and includes tons of optimizations that you definitely must learn to make a good multiplayer game again remember you can inspect this entire project for yourself download it with the link in the description if you haven't yet seen my complete detailed tutorial on netcode for game objects and definitely go watch it now and check out the other link to learn all about Unity gaming Services Unity has tons of tools to really help you bring your multiplayer games to life things like Matchmaker and Lobby relay and more so definitely go ahead and read about those I've also covered Lobby and really in two other dedicated videos and of course like I mentioned the reason why I researched this game was to prepare for my upcoming free multiplayer course and in preparation for that make sure you go watch my full free single player course alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and I'll see you next time foreign