in this video we're going to learn about dynamic buffers in unity dots this is how we can hold a list of multiple values inside of our dots component we're going to learn about dynamic buffers and use it so our player can target multiple enemies at once let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with NF tutorials made by a professional indie game developer so if you find the video helpful consider subscribing okay so here we are working with unity dots and ECS so first of all if you're not familiar with dots and ECS check out the videos linked in the description now as you know we can only store certain types inside of our ECS components mainly we can only store value types and no reference types so for example that means we cannot home an array or a list however there is one way we can sort a list of values with variable size and that's with dynamic buffers this video is made possible thanks to these awesome supporters go to patreon.com/scishow to code monkey to get some perks and help keep the videos free for everyone now first we're going to learn what our dynamic buffers and how they work then at the end we're going to go through a nice demo with a player character that attacks a single enemy and we're going to use dynamic buffers to make them attack multiple enemies at once okay so let's try it out Here I am in my basic empty scene now the first thing we need is to define a buffer element so this is a type that we're going to store inside of our dynamic buffer so here let's just make a new csharp script and call this our int buffer counter okay now in here we're working with ECS and let's get rid of all this instead we have using BLET entities and now our in puffer element will implement a buffer element tag so this is the interface that handles buffer elements and now inside what you have a public in and call it Val and in here as always with ECS this is not a class but rather a struct so we have our struct implementing buffer element data and inside we just have a simple int for our Val now let's make an entity to test this out back in the editor let's just make a new csharp script just our testing and let's make a game object and drag our testing script okay now in here let's test out by making a very basic entity okay so here we're having the default normally in creating a basic empty entity and now in here we can start by adding our buffer element and now the way we do that is we use our entity manager and we call the function add buffer we pass in our buffer element type so in this case our in buffer atonement and plus in our entity okay so here we're adding our buffer of type int buffer element into our entity now this function as you can see returns a dynamic buffer and now with our dynamic buffer we can add a bunch of elements so in here we can work with it just pretty much as if it were a normal list so access the dynamic proper and count add an inside pass in a new buffer element and here we can set a value okay so there it is very simple we create our empty entity we call add buffer that returns a buffer and then on the buffer we add individual elements all right so let's test any up here we are with our entity debugger and there it is our created entity and as you can see it has the info for element and then we have three values inside one two and three so just like this we have a component with a variable size awesome all right now back into our code over here we are getting our dynamic buffer and calling the function add and creating a new buffer element but if our buffer only has one value like we did in here which is have a int value then we can simplify this by using our dynamic buffer and calling the function we interpret this reinterprets our buffer element into a specific type so in this case we can reinterpret it as an array of int so this returns a dynamic proper of the new type int and now here we can use this buffer directly with ends without having to create into buffer elements so for example let's access the buffer on index one and change it from two and put it into a 5 all right so let's test and yep there's our entity with a 5 on index one so this is a helpful way that we can easily work with the underlying value instead of always having to create a new buffer element all right now thing that we can do is simply cycle through all the values in a dynamic buffer okay so here we're doing in normal for as if we were working with a normal array so we simply start on zero go until the dynamic buffer going and then here we're just increasing the values so very simple as if it were a normal array and let's see any app over here we can see that all of the elements have increased by one right so here we saw a bunch of operations that we can deal with a dynamic buffer and in order to do them we need to access the actual dynamic buffer reference so right now we're getting it because we get it as soon as we add a buffer to our entity but let's say we're running this code elsewhere other than when we add our buffer and the way that we can get our dynamic buffer we can simply ask our entity manager in order to get the buffer pass in our buffer type which is our buffer element type and pass in the entity so just like this first we're adding our buffer into our entity but we're not storing the return value from this instead then we ask the empty measure to get the buffer we pass in our buffer element type and passing the entity which returns a dynamic buffer and then we can do everything we've done previously so for example if you're working inside of a system you do an entities for each you get a reference to the entity and with the empty manager you can get the buffer from that entity now another thing as he saw the buffers have expendable size so in here I can add as many elements as I want however that also comes at a cost as you increase the size past its capacity it has to allocate new memory and copy the previous events into the new memory location dots is all about performance and efficiency so obviously you want to avoid this as much as possible and to reduce the chances of that happening you can define a size for your buffer so for here in our in buffer element definition here we can add the attribute in turn on buffer capacity and this isn't takes an int for the capacity so this is how many buffer elements we want to store in our buffer and for the example let's say just five so in this case when an entity holds a buffer of this type it won't be created with enough space to hold five elements so you can still do whatever operations you want on the buffer and as long as the elements remain within you will not see massive performance tips on the other hand you can still go pass this amount if you absolutely need it but if you want your code to be as fast as possible then you should pick a number that won't do for your use case okay now let's look at how we access a buffer from inside of the system so let's create our script and call this our test buffer system okay now inside let's make this a component system all right now in our update let's do a very simple entities dot for each and in here we can simply use dynamic buffer and pass in our in buffer element type and just like this we use it as if we were using any other component so here for example let's cycle through the buffer elements and increase them alright so here we cycle through our normal buffers so we're not even reinterpreting and we're simply increasing the buffer value any of their days over here in our NT debugger we can indeed see all of our values constantly increasing so this is how you use a dynamic buffer inside a entities for each now so far we've been adding buffers directly by writing the code but we can also use the conversion work form in order to make it any editor so over here we have our in buffer element and now for most elements if you implement I component data you can also add a generate authoring component C you add this attribute and you can simply drag the script on to your game object however as of right now this does not work for I buffer element data so in this case we need to handle the conversion ourselves so let's make a new script and call this our int buffer element authoring this will be our authoring component and now in here we add using unity dot entities and we implement I convert game object to entity and we have a public int for our value now when we convert our entity we use our desk manager in order to add a buffer of type int buffer element into our entity alright so in our authoring component we have a value array of our intz then by implementing this interface the conversion system will call this function and in here we're adding the buffer just like we did previously and then we take our dynamic buffer we cycle through our value array and we add them as int buffer elements and also in order to be able to add it we also need to implement monobehaviour so now we can go back into the editor and in here we create a new game object and now we can drag our int buffer element authoring component and there you go we have our value ray so here let's say let's put a 5 and a 6 and in order to convert this automatically we needed convert to entity script all right so let's see if we have another entity being automatically accentuated within buffer element with two elements let's see and if there it is here's our game object as you can see it was automatically converted and we have our two elements in the system is still working on both of these now another thing we can do is access the buffer of another entity so for here we made our system modify the dynamic buffer of that specific entity but another thing you can do is access the buffer of another entity all right so now let's try it out and make two separate entities now we're going to identify them with empty tag components so here I created two scripts tag allison tag Bob now these are simple tags so just completely empty tag components in order to use them with the conversion workflow we automatically generate the authoring component all right we have both of our attack components so here this object let's name him Bob and we drag the Bob tag another one for the analyst and drag the tag Alice alright so now we have two different components we have Bob and Alice and for now let's remove our own testing component and let's go into our test buffer system and here let's make a new system call with our test buffer from entity system and now here let's icon just through Bob so we do entities that for each but before we do our for each we add the filter with all of type tag Bob so here we're only going to cycle through the entities that have the Bob tag which is only one and now here we want to get the buffer from Alice so to do that we use the function get buffer from entity and we pass in our end buffer element this is you can see returns a buffer from entity and now the way that we access the buffer from a specific entity is essentially using this like an array and as the array index we need to use an entity so in order to get the entity from Alice we could do it by several ways for example we could store a component inside of Bob containing a reference to Alice's entity or we can just do a very simple entities so here we're doing it for each on the entities that have the Alice tag and we assign onto this one the one that we find and now we can access this one on our buffer entity so with this we have our dynamic buffer now here we just increase it as previously so now let's test alright so here we are we have Bob and Alice and as you can see Bob has the buffer elements but they do not change but unless any of their yo the buffer elements stored in cervelas are constantly increasing so this is how we access a buffer from a different entity we just get buffer from entity passing our buffer element type and then we access it as if accessing an array using the entity as the index all right now let's look at dynamic buffers inside of jobs so let's make a new script called test buffer job system alright here we have our basic job component system and now let's create a job now here we implement a job for each with entity underscore EB that's the one that takes in the element buffer and we pass in our specific type so in this case our int buffer account and here on the execute as you can see it takes in a dynamic buffer so on definition of the job you pass in the buffer element but in here you receive the dynamic buffer that contains our buffer elements then here you can play around with it the same as previously and then here we make a new job alright here it is let's test any up here we have both of our entities with the dynamic buffer elements constantly increasing running on a job awesome ok so we covered a bunch of different uses and actions we can take with dynamic buffers now over here I have an interesting scene to demonstrate the use case of dynamic buffers so right now over here is my player and you can see a bunch of zombies being spawned and moving towards him after two hits they die and as you can see the player can only attack a single zombie at once so after a while he becomes completely overrun so he only has one active target and only when that target is dead does he try to find another so essentially we have a system looking for the closest target and storing that target entity in a component in the player so here you can see the component the player single target the type component data and simply contains a target entity then we have the targeting system it simply cycles through all these zombies and looks for the closest one and sets that target entity and then the attack system which has a simple attack timer it checks the player single target component if it has a target then it spawns a Qunari in order to attack that target so again here is the demo and the limitation is we're only attacking one enemy at a time now that we've learned about dynamic buffers let's use one so the player can target multiple enemies at once so first we create our dynamic buffer element so let's create a new script call this our player target element and inside we're going to implement our interface all right so here's our buffer element data that contains a target entity and let's define it as a buffer capacity of five so here in the scene I have the player game object as you can see it has the various components and using the conversion workflow so let's make a authoring component so let's make a new script code our player target element authoring now let's do the same thing that we did with our previous authoring component except in here all we want is a D buffer so we do not want any public fields and said we are simply going to go into our entity manager and we have our buffer of this case the player target helmet so all this authoring component does is add an empty buffer and in the editor we just select the player and drag our authoring component and there you go now this entity will have a player target element buffer and over here on the targeting system we were cycling through the player single target and let's modify this to work with our dynamic buffer element alright so here I modified the code in order to work with the dynamic buffer so the logic is still pretty much the same except instead of the closest we get five targets that are valid within the range so the first thing we do is clear our dynamic buffer then we cycle through all the zombies we don't the ones in range into this zombie entity and list and after cycling through all of them we add them once the length is under five so we're going to add up to five targets within range and now let's go into the attack system so here it is and we're working with the players in on target and let's replace this with our dynamic buffer and here we do pretty much the same thing we just cycle through our dynamic buffer okay so here I've changed everything from working with a simple component to working with the dynamic buffer that holds multiple components so now let's test and see if he attacks more than one enemy all right so here we are and yep you can indeed see the player attacking multiple enemies at once so as they get within range up to five enemies are gonna be attacked instantly so here you can see a practical application of how we took one system that supported a single target and updated it to support multiple targets so now you know how to use dynamic buffers so go ahead and build your awesome dots games this video is made possible thanks to these awesome supporters go to patreon.com/scishow to code monkey to get some perks and help keep the videos free for everyone as always you can download the project fastening tony's from unity karma comm subscribe to the channel for more unity tutorials post any questions in the comments and I'll see you next time you