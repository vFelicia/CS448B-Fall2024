in this video we're going to see how we can find a target for each of our units in a pure ECS game in unity we're going to tag our entities and create systems for finding a target and moving towards it let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with enough tutorials made by a professional indie game developer so if you find the video helpful consider subscribing so one of the main benefits of ECS is getting massive performance so that makes it perfect for games with lots of Units like for example an art yes that means it's essential to have your units be able to look for targets so let's do that in our pure ECS game we're going to start off with entities with a simple unit texture and others with a target texture then we're going to see how we can tag each entity to identify its type using a simple component then make a system that won't only run on entities with that unit tag and look for entities with a target tag after that we're going to create a component to keep track of when the unit has a target and finally another system to move the unit towards the target in order to destroy it alright so those are the various steps we need to be able to do our system so let's get to it here is the starting point I just have a simple unit texture and a bunch of targets being randomly spawned we want them to locate the closest target and move towards it so let's see how this is set up here in the scene I simply have this game having our object so let's see this script here is the script where we're setting up all of our ECS code now if you're not familiar with ECS check out my getting started video which covers how ECS works and what all of this does check the link in the description so the first thing we do is get a reference to the entity manager then we have a function to spawn a unit and another one to spawn a target as you can see the components for the unit and a target are very similar we just have a translation for the position welcome to world and render manner to be able to see it and a scale in which the unit is larger than the turret so up here we're simply spawning a single unit and various targets all right so this is our starting set now the first thing we need in order to be able to find the closest target is to be able to identify which entities are units and which are targets as you can see right here they both have the exact same components so right now it's impossible to realize which one is a unit and which is a target so in order to identify them we're going to create simple that won't work as tax so down here we just need to make a strut let's call it unit and it implements I component data and it is completely empty so this empty component works as our unit tag then let's make another one for our target and that's it alright so now we can go up here and on our spawn unit function we're going to edit with the title unit component and down here on the target we add the typo target component so just like that we now have two different archetypes one that contains the unit tag and one with the target time this way we can now identify which entity is which so we can now run the code and here everything still looks the same we have random targets and our random unit but if we check on our analysis entity debugger here you can see we have two chunks one chunk that contains a unit tag and one that contains a target time as you can see in here we just have one unit and here we have ten turrets so just like that we have two specific types of entities now let's see how we can make a system in order to cycle through them so here let's make a new script this will be our finds target system now in here we get rid of model behavior since we are working in ECS instead we're going to extend a component system now here we have our on update function and it's in here that we need to cycle through all of our units and only our units this code is not meant to run on the turrets so for that we use the entities and now here we have the filter let's have the filter with all meaning it'll only select the entities with all of these components so in here recently class in the unit tag component and then we do it for each so this for each action will only run on entities that contain the unit component now in here let's use the delegate that receives a parameter for the entity so here we have our code running on all entities with the unit tank now here's just make sure that it is working correctly let's just do a simple debug log and pass in the entity okay so let's see and we should be able to see only one entity being display any up here in the console you can see only one entity is running that code okay awesome now just for testing to make sure this is all working right let's spawn another entity so in here instead of just one let's want to let's see and if there you go our code is now running on entity 0 and entity 1 and if we go into the empty debugger you can see that the 0 and 1 are indeed our units so 0 and 1 are units and the 2 is a target okay awesome so we now have this system running only on specific entities and we're specifying those entities using the unit tag component so now in here let's see how we can cycle through all the targets and in order to do it it's actually quite simple we just go here inside our 4inch and we do another 4 inch so again we grab the entities and in this case we want with all of the target tag and we do for each on that so here we have code cycling through all the entities with a target time again or to verify this is working correctly and let's do another log on our target entity any of you can see our code is cycling through each unit and through each unit that goes through each target okay so we have pretty much all of our cycling logic working now all we need to do is to calculate which one is closed so let's go into our system and now in order to get the closest that means we need the position for both the target and the unit so up here let's have a reference the translation component and down here also and now we need is to find which one is our closest target so for sirs let's define an entity variable to hold our closest target entity now by default entity is a struct so we cannot simply add no instead we need to add entity dot know then here when we're cycling through our targets for the first one is very simple if the closest target entity equals entity known then we have no target so we said we call this target entity to this target entity and if not then we need to calculate which one is closest so here we do a if math and do a distance between the unit translation value so this is the current unit position and the target translation dot value now in order to get this distance we cannot use the reference inside another cycle so we need to go here and store a foe 3 for the unit position which will be the unit translation value okay now we want to make sure that this distance is closer than the one that is already closest however in here we only have an entity so we also need to store a or three or the closest target position and here when you set we also set the target translation that value okay then here we check that so if this current target is closer than the closest target and this one becomes a new closet and that's it this is our logic for finding the closest target using peer ECS so down here after the cycle we have our closest target now let's have a visual debug line in order to be able to see it so we do if the closest target if it is not known then let's wait the bug dot draw a line between the unit position towards equals this target position all right so let's see and see for unit is indeed pointing towards eco cistern and he appears our unit and five random targets in E as you can see it is correctly and find out as it closes let's reset the scene and try again any of there that one is the closest and that one is list okay awesome so we have successfully written a system that looks for targets closes to eighth unit now we need to think about how we're going to set the target on that unit now in normal objectoriented code you would have a unit class which would have a field to hold the current target so in ECS your first approach might be to store the active target in the unit component however in this case and we are using this as a simple tag that is probably not the best way to do it so let's go with a different approach which is we're going to have a component to home that target so when the unit finds a target it adds that component and when the target is destroyed it removes that component so let's see how we can do that in here we simply create a new struct let's call it as yet and we also have I component data in this case we're going to add a field and the field will be a public entity for our target entity okay so we now have a specific component that we're going to add to our units when they find a target it's now here when we have our code looking for a target and we find our target and here we have the hash target component so in order to do that we use the post update commands this is an entity command buffer in order to add a component into our entity we're it add a new component of our hands target and we're going to fasten the target entity as our causes target entity so when the update finishes this code will run which will have this component to this entity so that way our norm only unit component still works perfectly like a tag and our targeting data is held in a different component so now for example instead of doing our debug drawn line here we can do it on a separate system so let's make here a simple debug system so we just make let's comet has target debug and we implemented component system and here we just cycle through all entities that have the has target component in here we do our debug dot draw a line between the entity position and towards the target position now in here we need to get the position for the target so we need to go and grab the entity manager in order to get component data and here we can pass in our target entity so has target dot find the target entity in order to get the translation component so you grab the translation for the target then we use that to draw our what so this is how you get component data for a specific entity so you have our target entity stored in our component then we have our has target debug component system in order to simply draw a line between the entity and its target okay so let's test and here we have a quick error because we're adding the has target multiple times that same empty so let's see why that is here it is on our fine target system essentially we're running this on every unit and if we do find a call to start we add a new has surrogate component so the simple solution is to make sure that this fine target system only runs on units that do not have a target so we can use a different filter in here we can use the with none of time has target so this code will normally run on entities that contain the unit component the translation component and no has target component so as soon as we have a house target the next time the update comes it will not run this code so again we cycle through our targets grab the closest at the hands target component the hazard component contains a field for the target entity and then we have our debug component which won't simply do a debug drawn so now let's see and we should be able to see online pointing to the closest target and if there does the unit is correctly locating the closest target and if we go into the entity debugger here you can see our unit entity there you go there's the unit a component and it also has the highest rated component which has a target entity all right so everything is working we have our unit finding targets now let's go back into the code and make another system in order to move our unit towards the target and destroy it so for that let's create a new system this will be our unit move to target system and in here here we do a cycle entities for each and we're only going to cycle through entities that have the highest high rated component now here we're going to do very much the same thing that we were doing here on our debug we need to get the target component and then we move our entity towards the target so that means we also need to get a reference to the translation component we simply move our translation towards the target Direction multiplied by a move speed multiplied by time Delta time all right so we have our unit moving towards the target then let's check the distance if we are within a certain distance then we want to destroy our turret so for that again use the post update commands in order to destroy the entity we're going to destroy the has target our target entity and then we're also going to do another post update command in order to remove a component from this entity so here we need a reference remove the component from the unit entity of type of as target all right so that's pretty much it so when you cycle through every entity that contains a has target component since it has the house target that one has a target entity so we grab the translation from the target entity we calculate Direction define a move speed move the unit towards the target then we check the distance and if it's close enough we destroy the target entity and then destroy the he has target component all right so as you can see our logic is very nice and easy to follow so let see so here he is moving he finds that one gets close destroys gets close destroys finds the next closest keeps moving towards it as gets close destroys and moves to the next one right awesome so as you can see we have our unit finding their targets and moving towards that target the target gets destroyed when he gets near and everything is working great so here you see a simple example of how to organize your code using a pure ECS system so you have tags for the unit and our target we have a component to keep track of which units have a target then we have a system which runs through all those units without a target and finds a target and we have another system which only runs on units that already have a target and moves in towards that target it's now let's try this out with a bunch of units and also a target spawner so let's go up here and spawn a bunch of units let's also spawn some targets every once in a while so we have a simple timer running every 100 milliseconds spawning ten targets let's see and just like that with multiple units finding multiple targets we find an error right away and the error is the entity does not exist now the error in this case as you can see only happen when we spawn multiple units and the reason is because we have two or more units going towards the exact same target so we have this system running on multiple units and the thing is when the first unit reaches its target it destroys a target entity however the second unit is still going for that same target however that entity has now been destroyed so here we need to make sure that we check if the target still exists before we move towards it so that's quite simple we just go here and we go into the entity manager and we can simply test if a certain entity exists so in this case our has target target empty if it does exist then we do all this okay and if not then we want to remove the unit has target from this unit okay that should fix our error let's see and yep now we have a bunch of targets being spawned and our units constantly moving towards the closest target so they are all independently around looking for the target causes to them as soon as he found the target they moved towards it and they destroy that target so we have each entity working independently so here you have learned how to tag entities in order to identify them make a system to cycle through all the entities that you want create a specific component to handle target data and another system to handle units that do have a target now in here all we used was pure is yes and only is yes I did it that way just keep the video easy to follow and understand how to cycle through entities so that's why I'm here in order to find the target we're cycling through all the entities and then through all the targets as you see this works however in order to get the most benefits we should use the complete dot stack stack so that means that now that we have on this code working we should Java fire our systems in order to benefit from massive performance so that we can have multiple units looking for targets at the same time so stay tuned for the next video we're going to do just that as always you can download the project fountain attorneys from unity code monkey com if you liked the video subscribe to the channel for more unity tutorials post any questions you have in the comments and I'll do my best enzmann alright see you next time