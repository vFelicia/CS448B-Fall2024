in this video we're going to learn how C sharp delegates work and how they're used we're going to see how they help us write more modular code and use compacts to simplify our logic let's begin so the liggett's are a very interesting C sharp feature essentially they allow you to store a function inside of a field this is extremely powerful in many scenarios you've seen me use delegates whenever I use one of the function classes from my utilities for example on the function periodic which triggers an action every certain amount of time it is a delegate to receive the function that won't be triggered so when I create the object I pass the behavior that I want to trigger in a previous video I covered events which also use a type of delegate not only they use the standard event handler as the event type and even handler is a type of delegate with a return type of void and a parameter signature of object and event arcs so let's take a look at how delegates are defined how they are created and assigned and various building types that make our job easier then we're going to look at two examples that show how delegates help keep our code clean and how they help us write more modular code this video is made possible thanks to these awesome supporters go to patreon.com/scishow to code monkey to get some perks and help keep the videos free for everyone delegates are defined as a function signature and return type but without any implementation so for example here I am in a simple empty script and first we define a donut and the way we do that is very simple first we write the accessor so for example public then we write the keyword delegate and now we define the delegate return type and signature so for the return type let's keep it simple and just return void then we need a name so let's call it our test delegate and now we define the parameters that make up the double yet signature but again to keep it simple let's make it no parameters at all so there we go here we define a donut that returns void and takes no parameters in here on we're doing is defining the actual delegate type so now we can make a field of this type so just like any other field let's say we make it private of type test delegate and call it our tests they'll get function now this film can be assigned with a function that matches this delegate signature so here on start let's say we set our test don't get function to equal something so now we define our function and again make sure that it has the same signature as identity so let's make it first of all will return void then we give it a name and again no parameters so this function declaration matches the delegate so now here we can simply assign this function onto this stomach and once we have assigned the delegate we can call it as if it were a normal function so we do test don't get function this case no parameter so just friends just like that we are calling the function that is stored within this field which in this case is going to be this function so let's just add a debug mode here just T to us alright so let's test and see any of there's our work so our function was correctly triggered through our delegate now let's make another function examine like this one but with different behavior so in here on let's define another private going and inside we have different behavior so we're going to say a different message and now up here let's say we assign this function on to this delegate then we call it okay and then we reassign our W with this function and we call the exact same dumb yet now let's test any of there you go we are calling the same delegate but getting two different behaviors delegates can also be multicast meaning they can trigger multiple functions so this is mainly what is used in the events so here we set the delegate to the first function and then we do plus equals our second function and then we call the delegate let's see and yep there you go we just call the function once but we get our two inner function calls so this is how the event publishers can have multiple subscribers and all of them get notified whenever the event changes so we can add functions but then we can also remove them so let's add both of them we call them then let's remove the second one and call again and if there it is the first time we get triggered both functions and second one only triggered the first one all right so this is how you define a delegate and assign it to a specific function now like I said delegates can have any return type and parameters so here for example we can make a public delegate let's make it return a boolean and let's say that we take an int parameter now we define our field of this type and down here we make a function that matches the signature so we're going to return a boolean call it something and we're going to have an integer as our parameter and then we can assign it the same way as previously so my tests don't delegate function and then we can simply count all right so we sign our w2 with this function and then we commit and pass in our parameters so let's see and if there is we have our function call written correctly awesome just one note here when you define a double yet you need to give it a name for the parameter so if you just do int you'll get an error so you need to define a name for the parameter however when you define a delegate function you don't actually have to use the exact same name so here it could be something completely different and the code still compiled some runs and everything is don't great now when it comes to creating a delegate function and assigning it we have several ways to do it one of the ways is how we did it just like here so we just assign it to a function that we defined that matches the signature now what this is actually doing in the background is we are doing a new test delegate and in this case we pass in our function so by doing this you're explicitly creating the delegate but again you can just keep it simple and just set it to assigned a function directly which one we cast our medical now another way we can create a delegate function and assign it is using anonymous methods so here we can take our delegate we can do equals and then we use the keyword delegate and we create our parameters that match the delegate parameters so in this case we have nothing and then we have our function body so just like this we defined an anonymous method that so much is the double gate signature and we can call it the same as any other method there you go there's our while working so this is how we create a function inside of a code block this is easier than having to create a separate function in most cases now another way of creating an as method is with a young lambda expression when the expressions are great because they are extremely tiny and compact so to do it all you need to do is really just open the parentheses with the defined arguments so in this case we have none then we do a little equals arrow and then we add our function block and yep that's it it's that simple so by doing this we are defining our lambda expression which works as a function that matches our delegate signature and we can then count if we're in the code there it is everything is working so this is the easiest and most compact way of defining a function if you've seen some of my videos you've certainly seen me use lime dissolve they are extremely useful in order to keep your code simple and easy to follow and again both anonymous methods and lambda expressions you can still return values so let's use the align the expression to define this function in here so the signature for this delegate is it returns a boolean and contains an integer so here for my lambda expression we open the parentheses we define our integer then we do one little arrow we add the code block and here we do simply return so in this case return what say I under five there you go here we have a valid lambda expression that is going to return boolean and take an int as a parameter if you have just a single statement then you can actually compact this even more and just get rid of all the curly brackets and put it just like this there you go this is a valid claim that expression that is going to return I under five if we were in the code yep everything is working now one issue with anonymous methods and lambdas is if you don't quite have their references they're created you won't be able to remove them from the delegate manual so for example here I'm signing two separate lambda expressions onto this delegate function then let's say we call it and then we want to remove only the first one the way we're doing here we can't really do that since we have no unique reference for this first function so if you need to add and then later remove a function from delegate that's better to make it an actual proper function instead of using an anonymous method now for the builtin delegates there are two extremely useful ones they are both inside system so make sure you go up and add using the system now the first one that you have is action so you define it using the action type here is our action and as you can see it is say don't get that returns void and thinks no parameters so the action is pretty much a built in type exactly of this one that we did up here and then you also have generic versions of action that take parameters of any type so you can find an action then you make it a generic and here you can see we have tons of options so for example it's an action that takes an integer and a fault so then we can assign this and this one won't take an integer and a float and returns void there you go here we have an action with an int and a float so for most cases you can probably use just normal actions instead of having to directly define your donuts okay so that's the builtin action type it takes any number of defined parameters and returns void now if you want to have a return value you have the other very useful builtin type which is the func this one by the font has a generic and the generic won't be our result so essentially our return type so in this case and let's say we want to return just a boolean and we give it a name so we go here we have a donut that won't take no parameters and return a bone so in this case we do no parameters and we return false so here's our font double gate and again here we do have tons of options for any parameter types and amounts that you want so you can define a funk the last one is always the results so let's say we want to return bullion but then let's say we want to receive an integer so just in here we have pretty much the exact same definition that we did up here so it returns a boolean and it takes an integer as a parameter so here we take an int and we return a bully so just like that all right so here we look the ton at how delegates can work how we define them how they're signed and the various builtin methods that make our job easier now that we've seen the underlying structure for how delegates work let's look at two examples first let's look at an example that shows how delegates really help keep your code clean and easier to use and then we're going to see how delegates help us write more modular code okay so for example over here I have a simple timer class it is meant to count down the number of seconds so I can trigger some action after some time you can see it has a function in order to set the timer then on update it counts down the seconds then we have a function to test if the timer is complete then the scene the script is simply attached to an empty game object then we have the game object that has the testing script we've been using and now let's say that we want something to happen after one second so let's use our timer script first here in our testing let's add a film for our action on timeline and now back in the editor and we can just drag the reference okay and now here as soon as we start let's say we want something to happen after one second so first we access the action on timer in order to set our timer let's set it to one second so that won't set the timer and start counting down and then let's do our private voice update and on update we need to check if the timer is in laps so we use that function call case timer complete so if it is complete then when you do a simple lock okay so just like this it should be working however you can probably already see an issue if we do it just like this then once the timer is elapsed it's going to trigger this function on every single frame so it said boolean to test if our timer has elapsed so we only run this once so if the timer has not elapsed and thumber is complete then we set it to complete and we set a time lapse so this will only run once okay let's test here we are and after one second yep there you go we have our timer complete all right so our timer work correctly so here we have a fully functioning Tamra code but as you can see this is extremely dirty we're checking for the timer if it's elapsed on every single frame on this class and we have to keep a bouillon inert to know if it's been triggered or not so instead of the timer being handled solely by the actual timer class the implementation of the timer is split into various places then if we want to use this same time or somewhere else then we need to implement the same thing over again so both classes are tightly coupled in a very nasty way now we can easily solve this problem with a simple delegate so on the timer class we can go up here and a using system and then we can make use of our built in action delegate and call our film let's say timer combat and now here when we set the timer let's receive an action for our timer combat then we set the film to what we receive and then on update we do our timer complete logic all right so here our timer class is now much more compact and now actually is responsible for everything related to the time so on update if the timer is better than 0 so if the timer is active then we count it down and after counting it down if it is complete then we call our comeback and now we can go back into our testing to see how we're going to use this function and in here instead of all of this nasty code all we need is a reference to our timer we don't need an update or anything like this we just need to call set timer and then we pass in the timer come back so again we can use a simple lambda expression then we just do our log so now everything is much more compact and all the camera code is actually handled by the timer class itself let's see so here we are and after one second if there you go we have our timer complete so you can see how just by using a very simple donut we made our class very clean and very easy to use so on the testing all we do is we tell our time and the action that we want to execute after that amount of time so here is a very simple timer class this is similar to the function timer from the code mock utilities I cover that specific class in another dedicated video so check that out if you want to learn more okay now let's look at an example of how delegates help our code be more modular so over here I have a simple character just moving around normally and I can press the mouse button in order to attack so let's look at the code here is the code on our update we're handling our movement and our attack and on the attack on we're doing is a simple input testing for the mouse button down and if so we're calling the punch attack function now let's say we have an upgrade system and we want the player to graduate from punching to using a sword so we could do that with a simple boolean so let's say we story prep ball count is using sword and starts off as false by default then we could have a function concept use sword we set that our boolean to true and then here we test if we are using sword then we use a sword attack and if not then we use the punch pack so this would be one valid approach but we could also solve this problem using a delegate so instead of storing a boolean and all this let's say our infection and this will be our attack function and by default on our start let's set the attack function to be our punch attack so that's our default and then we have set a sword instead of working with a boolean we set our delegate to be our sword attack and then when we're handling our inputs we don't need to do any condition on logic in here all we do is just access and use our delegate so that's it you can see how this is another potential approach so here just for testing let's do a simple input so when I press the M key I'm going to call set use forward which is going to modify the attack function delegate which is then used by the attack so let's see so over here is my player character move them around and I'm attacking using punches and kicks all right sounds good now I press ducky and now I use the exact same attack and there you go now I'm using sword instead so when it comes to handling the input in the attack both behaviors are doing the exact same thing what we're doing is using our technology which can be pointing to whatever function we want so for example I've used this type of implementation in the hotkey bar video in that video I store a dominant for each key input and we can easily swap out what pressing the one key does what the two key does and so on all of our function behavior is stored in a field which is linked to an input all right so here we learn all about delegates how they're defined how they're signed and how they can be used as you can see having the ability to store a function in a field is extremely useful in a multitude of scenarios now you have one extra tool you can use to solve your problems and keep your code clean when making your games this video is made possible thanks to these awesome supporters go to patreon.com/scishow t code monkey to get some perks and help keep the videos free for everyone as always you can download the project files and utilities from in Tacoma com subscribe the channel for more unity tutorials post any question have any comments and I'll see you next time