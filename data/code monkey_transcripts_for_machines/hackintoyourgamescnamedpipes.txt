hello and welcome i'm your code monkey and what i'm covering in this video is some really exciting stuff that has tons of potential use cases essentially you can make your games like normal and then make a second unity window which hacks into the first one and interacts with your main window to do whatever you want to do in my case i use this in order to have a main unity application running in my primary monitor and a second one on the second monitor controlling the first one so let me tell you the story about why i needed to research this a couple of weeks ago i started live streaming progress on the mini games that i was working on it's been interesting to work alongside chat so i definitely would like to make them more regular and in order to make this a more regular thing i went researching live streams in general one of the awesome things that i found out was something called stream avatars it lets viewers have a visual character walking on screen i thought that looked fun and then i also remembered that i already did the research towards creating a transparent unt window i even made a phone tutorial about it a while ago essentially you can make unity as a transparent overlay on top of the desktop so one of the demos that i showcased was making an assistant that would tell me jokes kind of like those characters that were so popular in the 90s like bunty buddy so with that i very easily made my own version of stream avatars i just have my characters using my animation system and all the sprites that i've used in my various steam games then i connected them to youtube live chat which was something i also researched two years ago when i first attempted the live chat game put them all together and i had characters joining from chat and seeing things on top of my desktop window but then of course came a huge issue with this everything works but if this was meant to be used alongside chat then naturally i needed some way to control it with the internet being the internet it was guaranteed that someone would try to say something inappropriate and i didn't want that to show on the live stream automatically so i needed some way some method of controlling things to manage the main window but at the same time this is an overlay the live stream is showing on my main monitor meaning that i cannot have the control window also on the main monitor so that's what led me down this rabbit hole of making a second unt window that controlled the first one and that i could place that one on the second monitor that way i could live stream normally and add whatever data or control options that i want in that secondary window for example i have a list of characters that are live and i can manually remove any of them i can also make the chat bubbles be based on approval so essentially they only show up on the main monitor after i accept them then i also have some simple buttons for hiding the characters showing a background or disabling or enabling the on top so that's what i use this for but you can really do anything with this method it's a twoway communication between two instances what data you communicate is really up to you you can use it for example to have your game running on the main window and then a second unity instance displaying some extra data like maybe performance or stats so it's very useful for testing or you can even use this without the main window being a unity game this is just using some basic c sharp classes so if you have some sort of app made in c sharp then you can use unity to visualize whatever that you want to transfer so this really has tons of potential use cases now getting all of this to work was actually very difficult so that's really why i'm making this video honestly i'm not sure how many people are interested in this topic since it's such a niche specific thing so this video is kind of for my own personal use this way i have this method documented just in case i forget something and i want to revisit it sometime in the future so the main thing is communication between two separate instances and from my research i found two methods that you can use to make this you can use a tcp tunnel to communicate between both instances or you can use something that csharp has which are named pipes during my research i encountered someone mentioning how they use tcp but the connection was always being dropped due to sending too much data i'm not sure what is the amount of too much data but i didn't want to bother with having to compress data and i didn't need it for it to be over the internet so i went with the named pipes approach figuring it all out was quite tricky but in the end everything is working and it's quite simple and works perfectly alright so here i am on my empty project i have a simple game object with an empty script so on this one this is meant to be my server so let's begin by making a function to actually start listening now the reason why i'm naming this server thread is because we're going to need to run this code on a separate thread in order to make a thread first we need to add using system.threading and then we can do a basic private void start and on start we're going to start off the new thread so let's make a thread name it the server read thread and make a new thread and pass in the server thread okay so this creates a thread and then just server read thread dot start so this will start running this function on a separate thread and now the first thing that we're going to do in here is create the server pipe now the class that we need is inside using system.io.pipes the class name is the named pi server stream and this one first takes a name and then a certain pipe direction okay here it is now based on the name that i use here and on the pipe direction you can tell this is a read pipe actually on the pipe direction you can make it both read and write so in and out however when you set it up like that the communication has to be one type at a time meaning that either you're reading or writing if you use a single pipe you cannot be reading waiting for input and writing something else at the same time so that's why here i set it up with a pipe just for reading and then later i'm going to make another one just for writing that way we're always ready for both reading and writing now on the server the first thing we need to do is wait for a client to connect so just go into the name pipe and call wait for connection so this is why you need to run this on a separate thread essentially this line won't block the code execution until a client connects and just one note here which is the pipes themselves they also have async versions of the methods so you can use them if you prefer to work with async and await but here i will be using the synchronous method simply because i find it simpler now after this line runs then essentially here we've got the client has connected so once the client has connected then it's time to start listening now for sending and receiving data we need some sort of data stream and for that on the official csharp examples they have this nice stream reader class so you go ahead and copy that over here then we just need to add some using statements serious system system io and system text and all the errors are done okay so we have this nice stream string this is a pretty simple class essentially it's got two methods one for reading a string and one for writing a string so up here we just need to use this so we just use it and send in the pipe and now let's read a message so we go into the stream we call read string and once again this won't block the code execution until message is received and then just doing a debug log okay so just with this code we already have enough to do a test then after we read the message let's just do the pipe and close our pipe so name pipe and we're going to call close okay this is the simplest thing that we have okay so that's pretty much it for our server it's set up to open the pipe it listens to connections when a client connects it listens to a message then it prints out the message and closes the pipe so now it's time to handle the client so here i have another empty project this will be our client now the logic here is going to be very similar so first we make our function then we need to start the thread so we start the thread and then here we create our pipe and in this case the class name is the name pipe client stream now the first parameter is the server name so this can be a remote computer that you want to connect to or in this case we want to connect on the local computer so just put a dot then for the pipe name and finally for the pipe direction and again this one is just a right pipe then afterwards instead of waiting for a connection we just actually connect okay so the client is connected and the way we set up our demo the server then expects a message so let's send one we're going to reuse the same stream class okay i've got the same stream class now just created in this case we just go in there and we write onto our stream and afterwards close the pipe okay so that's it as you can see pretty simple so if we test like this everything should be working now the one thing that we need to make sure that this test does work is we need to run the server first if we run the client first then essentially this line will fail and it won't try to reconnect so i've got my both unt instances so let's start off the server okay the server is waiting now start off the client and yep there you go and you see that everything did indeed working so the client has connected so the client connected and then the server received a message from the client all right awesome so here we have the absolute basics working the server starts listening then the client connects the client says something the server receives it and they both quit so everything else is really just building upon this now there's actually still one massive issue remaining that won't break this when we try to make a proper build instead of running in the editor but before i cover that issue let's quickly look at the final code in my live chat characters project and by the way if you find the video helpful consider subscribing and hitting the like button it really helps out the channel so here is my final server now as i mentioned there is a separate thread one for reading and one for writing then i also got a bunch of external logic in order to make the code thread safe so i'm not going to go into too much detail on how multithreading works just know that in order to access unity specific things like game objects and transforms you need the code to be running on the main thread so that's why over here i am working with some cues so i've got a read cue and a write queue as well as a read lock and a right lock and then for those cues then i've got a simple function that i'm running on the main thread and this one simply goes into the req and dequeues and reads the command so over here on the read thread we do the same things that we just saw so create the pipe wait for the connection create the stream string then we read something when we do read something then we use our unlock in order to make things thread safe then we enqueue our message then just make it sleep so this doesn't run nonstop and this is always on a while through and then also just catching some exception just making sure that it doesn't crash when there's some issue and then the right method down here is working pretty much exactly the same way create a new pipe wait for the connection create the stream get the lock dequeue from the queue and actually send it so this as you saw is sending just pretty much normal text so for encoding the contents of the messages i'm essentially just using json so i've got this function which takes in just a string for the message it creates a pipe command which is really just a structure to hold some data so i've got that and then i simply convert that into json and when i read the messages convert it back into json if you're not familiar with json i covered that in a previous video it's just a very simple way to encode some data so that's pretty much all it is and then over here just a function to destroy itself so this one runs on a mono behavior on destroy and all it does is just aborts the threads now avoiding a threat like this is actually something that you should not do however i really could not find any other way to stop the pipes once they start reading they cannot stop reading until it receives something so this is not the ideal method but i really couldn't find any other solution and this does work all right so this is the server code so as you can see it's just expanding upon what we saw and then over here is the client which works pretty much exactly in the same way so separate for reading separate for writing the main difference from what he saw is over here essentially getting it to try to reconnect so if it is not connected then it tries to connect if the connection fails then wait one second and try again so that's pretty much it then here the same thing reading into a queue and then for writing same thing writing from the queue and sending the message using json and so on now as i said there's still one massive issue remaining that drove me crazy for many hours as we saw in the demo everything is working perfectly fine we have the server and client talking to each other however if instead of running this in the editor you make a build that's when everything breaks you won't see an error related to how named pipe server stream is not implemented this is a very weird bug however after a lot of searching i finally managed to make it work i even posted on the thread that i found while googling so the solution was mainly to compile it as a 32bit executable for some reason that one has server implemented while the 64bit does not so on the server just make sure that you go into the build settings and over here instead of x86 64 just x86 which is 32 bits then i'm also using mono and api.net 4.x on the client i didn't have any issues so i just ran on my standard parameters and with that everything is working both in the editor as well as in the standalone builds you can create a pipe to communicate between two instances and you can pass through any data that you want so in my case i use it to create my main window showing all the chat characters and a second window to moderate and control the first one if you have some sort of app made in c sharp then you can use unity to visualize whatever that you want maybe you have a normal console app like a website scraper and you want to visualize some graphs and charts or just really for game testing play a normal build with your game and connect to it to display some debug data or a bunch of sad to help you balance levels and weapons unity is a game engine which makes it perfect for making complex visualizations so this really has tons of potential use cases alright so this was a unique video on a pretty obscure topic but i hope it helps someone as always you can download the project files and utilities from unitycodemonk.com if you found this video helpful consider liking and subscribing this video is made possible thanks to these awesome supporters go to patreon.com unitycodemonkey to get some perks and help keep the videos free for everyone post any questions you have in the comments and i'll see you next time you