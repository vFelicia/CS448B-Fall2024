in this video we're going to do a deep dive into the unity logo effect created in the visual effect this is part of the official samples and it's a great showcase of millions of particles behaving in the pen tool we're going to inspect the graph and see how it actually works let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with enough tutorials made by a professional indie game developer so if you find the video helpful consider subscribing okay so here we're going to look at the unity on logo effect from the official unity visual effect grab symbols there's not like the descriptions where you can grab the symbols and try them out for yourself and if you're not familiar with the visual effect graph then check out my getting started video alright so here's the effect in action there's this fear of moving around spawning particles and in the background you can see that those point particles take on the shape of the unity logo each particle as you can see is individually simulated which shook is the power of the visual effect graph doing something like this with this many particles is simply not doable with the own particle system this video is made possible thanks to these awesome supporters go to patreon.com/scishow to code monkey to get some perks and help keep the videos free for everyone so it's a great looking effect let's see how it works okay so here in the project files we have our samples then we have the unity logo and let's open up the unity level effect all right here is the entire graph now while the effect is actually very impressive it's actually one of these simpler ones so the effect is essentially built in just two parts so there's a sphere moving around that acts as the spawn position for the protocols and there's a vector field in the shape of the entire logo which is where the particles are attracted to so everything else is just adding more randomization and color to those two actions so let's first look at how the logo is done now like I said it's using a vector field a vector field is a field containing vector isn't like you might see for example on a weather map showing wind direction so that would be a 2d vector field and the 3d vector field is essentially a cube made up of voxels where each voxel contains a vector pointing in a certain direction and in this case of those vectors are built pointing to the shape of the unity logo so those vectors are what the particles used to move in unity you can store effector film as a 3d texture or as a dot vf5 so here in this folder you have the Unity on logo and as you can see it's a texture of 64 by 64 by 64 with the RGB okay now in order to analyze the logo effect let's just quickly disable the sphere so in here I'm going to this can this feared connection and there you know this fear is just on the middle and also the save on the collision and let's disable the gradient so now the particle spawn as white and down here let's disable D blend color alright so now we can focus only on inspecting how the logo works now here in the update we can see that we have three update box now the first one is colliding with the spear so that one's already disabled now the second one we can also disable for now and the third one is the one that has the actual shape of the unti logo so here you can see that this block is of type vector field force so it's applying a force to each particle based on a vector field now the vector field is in here being selected with this exposed property so I'm looking in the blackboard we can see the vector field properly is a texture 3d and it's set to this one here with the unity logo and since this one is exposed we can also sound like the VFX game object and open up the inspector and in here we have our vector field so since this one is exposed you can also override this and select a different one now the other input here is for the field transform so these are essentially the transformations that are applied on top of the vector field so right now it's attached to a property but we can break this off and now we can play around and manual and modify these values so for example we can modify the scale to make it really tiny so make it just 1 1 1 and if there you go and look at that effect now it's extremely tiny so essentially we're modifying the size of the vector field and again the vector field is the thing that actually attracts the particles so we can modify anything of this like for is a modified the X and there you go it starts moving to the side modify the wine to move it up and down and we can also rotate it yep just like that so all these transformations are applied on top of the vector field so let's connect this property again so connect this one to this one and now let's see how this property is working because this one is actually extremely interesting so we have this property and in the whiteboard we can see that it's of type transform and then we can inspect on the inspector our game object and here we can see indeed we have a vector field transform and now for the really interesting part is down here attached to this game object is another script of time VFX properly by and this is how you can link a VFX properly with a normal game object so here we can select this property binding and we can bind this property to this target and this target takes a transform which is an object in our scene so instead of modifying these values individually we can have a probably binder will ink a field with a transform and that we can modify this transform so here in the scene view and we can just move it and yup there you go you can see that the effect is actually moving so by modifying this game object you can see that we are updating our effect in real time now what makes this super cool is how you can easily animate your effects by animating a basic game object so in fact that's exactly what's being used as we play the scene here with the scene plane you can see that there is a slight rotation left and right and none of that is done by actually modifying the effect but rather just by animating that linked object so here in the scene there's a timeline game object and we can inspect the timeline and see that yep indeed there it is we have our transform proxy and it's being animated on the rotation so it rotates left rotates right and by animating that object then our effect gets animated as well so binding transforms in your scene to transform properties in your effects is a really excellent and easy way of adding some awesome animations alright so that's pretty much how the unity and logo works it's just a vector film attracting particles now here on the update you can see that there is also another vector field so this one is essentially just applying some noise so for example let's is able to undo the unity logo and right now we don't see anything and now if we nave on this one yep there you go now you can see it's pretty much just random noise so it's a vector field sending all the particles in all different directions and now here you can also see that there are some nodes attached to it and all its really doing is it's taking the total time which is constantly increasing then it multiplies itself by a certain value and simply a point is a result of that transformation onto our film transform rotation so in there you can see that the vector film is actually rotating constantly so if I'm working the scene look from a different point of view yep there you go you can see the rotation happening so in here we can increase this any of there you go now it's rotating faster and if we were to disconnect this one yep there you go now you can see how the randomness is commonly static so with rotation it looks a lot more interesting alright so this one is pretty much is that just adds a bit of noise and then this one has a shape of the Indian logo so when you combine both of them if there it is it takes on the shape of the unity logo while also keeping some rotation making it feel very flowy so that's the unity logo part of the effect pretty much as a vector film and some randomness on top now for the vision let's note down here on the output most of it is pre standard so with just orienting particles along with their velocity then it set the scale based on their current velocity and then the one special thing down here is the color blend which is based on the particle a lifetime and it's also pointing with another color based on the sphere position so now it's time to look at the second main element which is how the sphere works now up here and let's just reset the sphere connections so connecting this fear output onto that input and if there you go now the sphere is moving around in our scene and now let's just focus on the sphere so in here let's disable the vector fields and enable the sphere collision and since the particle size is based on velocity right now we can't see anything so much it's not a very tiny force and a pyramids also set in a lifetime to a tiny amount and increase how many are spawned and here just increase the GR intensity and yep now we can visually very easily see all of our sphere moving all right now we can look into it now the really interesting thing is how all this movement is handled solely through these nodes down here so like you saw previously it's possible to create some movement by linking a moving game object and acting as the input for the sphere or transform and now here we are seeing another approach of animating our effects which is just using some basic map so let's first analyze the part here on the aleph time now this one is really just a simple branch node it uses a boolean to decide whether to use this value or this film now the difference here is that one is using the total time for the entire effect and the other one is using the total time for each individual particle so that's a logic to it however it doesn't really make much of a difference but anyway this whole group that's how it's doing oh it does is it krabsy total time then over here is the group with the actual sphere movement and now if you're familiar with math and trigonometry then this won't be very easy to understand but even if you don't you should sound be able to get it now there are two parts to the sphere there's the movement up here and this down here now the size part is actually extremely simple it's just these notes so you can see that we have a simple noise node now what it does is it generates some random values in this case it's generating those values in a single dimension so imagine a noise image that is one pixel tone and each pixel is randomly going from pipe to what all these films are on here essentially manipulate how that noise is generated then our coordinate in here is the value that we're actually grabbing so by using the time from down here as our coordinate time is almost increasing so the coordinate is almost increasing so we're always getting a different value and then the output from the noise here is going to be a value between 0 and 1 and then in here we have an alert node so this one interpolates a value between x and y based on the input in here on the s and for the inputs we are getting them through this property so we can expand it and see yep we have a property it has an x and y which you are using to set the minimum and maximum size so here in the blackboard we can inspect this one there is this fear min/max radius it is a simple invite you to and again it's exposed so we can modify this in the inspector so we selected down here we have the sphere min Max for example let's put this at point one and this one at one and now this fear goes from really big to real small so interpolate between the minimum and maximum based on the noise and then we simply input that onto the sphere radius so all of these nodes down here are essentially just creating a nice pulsating effect so as the sphere moves around it also randomly becomes smaller and bigger now we can just disable the size pulsating so we can focus only on movements and let's just disconnect the timing here any of there you go now our coordinate is the same so the size never changes alright so that's how is the size is set up now let's look appear into how the movement works now the movement is handled internally through all of these nodes and now essentially it's all based on the sine and cosine waves now I'm not a mathematician but if you're not familiar here is a very basic explanation the sine is a value calculated based on an angle design goes from minus 1 to plus 1 so if the angle is 0 then the sine will be zero and if the angle is 90 degrees or one half of pi the design will be was one and if it is at 270 degrees then the sign is minus one so if you picture a rotating angle you end up with a nice wave function going constantly from minus one to plus one and if you rotate the angle faster then you essentially increase the frequency of the wave and the cosine is pretty much the same thing except instead of getting the opposite side of the triangle it gets you adjacent so what matters is that it's a wave function that returns a value between minus 1 and 1 so here we are using the sine in order to grab what can become DX and we're using the cosine in order to grab water and become the Y and the Z now to simplify things let's disconnect the cosine here and you've just like that we can see our sphere moving simply and left and right so that's the sine wave at work now note here that we are applying a sign to a vector so one thing that really tripped me up quite a bit while I was researching this was how sine works with vectors I was thinking that it was essentially calculating the angle of the vector and then calculating the sine of that however that is not the case what it does is individually currently to sign for each of the x y&z and it films the output vector with the sine of those values so in this case we're only grabbing the output on the Y which is simply going to be the sine of the input on the 1 so the input isn't really being used as the vector 3 but rather as just three floats now in here we can disconnect the sign from the time and here you can see that if I modified Zed yep nothing happens since we're not using it modify the X and yep nothing happens either it's only found modified Y that yep you can see that it's going left and right now again another basic math thing just in case you're confused the number used in here to currently design is represented in radians so at 0 the output is 0 so the sphere is right down the middle then as we increase you can see that reaches the edge yep just about that so in order to get an output of +1 then essentially we have to have the input of pi divided by 2 so essentially 1.57 then as we increase and we reach pi which is 3.14 we go back into the middle so the result is 0 and as we keep increasing goes left side and at 2 pi it goes back to 0 so just be aware that this one is using radians and not oiler angles so it doesn't go from 0 to 360 brother from 0 to 2pi all right so that's the sine wave which is outputting on the yvalue but here it is combined into the x value with these other two so the append vector is essentially just creating a vector it takes this one as the X then this one as its Y and this one as its Z so this one just creates the actual vector now in this vector all of the fields are going to be between minus one and plus one and then in here we have a simple multiplier where we're multiplying our vector by the sphere motion amplitude then the resulting vector from that simply goes into the sphere Center which is the sphere position now this effect is using two properties in here the sphere motion speed and emotion amplitude so now let's connect these in back yep there it is now these two properties are pretty straightforward so from working to the inspector since those are exposed yep there you go we have the sphere motion speed and the amplitude so if you modify the spinned as we increase yet there you go the sphere constantly moves faster and faster and faster and by modifying the amplitude we simply change how much it goes in this case and left to right so put it really small and barely moves yep just like that so two basic properties that we can interact and modify the effect and now if we just connect the cosine and if as you can see it's mostly the same behavior except it's moving up and down and back and forth so that's pretty much how the whole movement of the sphere works the input is in here increasing over time then it applies some wave functions to that value it multiplies them by a certain speed and a certain amplitude and simply uses it all in order to go to the center so with this one and let's also connect the pulsating effect and yet there's this fear working me exactly as it was so you can see how you can animate things in your effect either by animating a link game object or just by using some really clever math so that's a sphere which is outputting in here and then it's used in various places so the main one is the sphere goes in here into where the particles are spawned then it also goes into this walk in here which caused the particles collide with the sphere so if we disable this one if there you can see that they no longer collide so as soon as they spawn they are left behind and finally it also goes into this part down here which creates some color pointing so let's see how this part works so for that let's enable our vector fields so enable this one in the shape of the unity logo and name on this one in the shape of the random vector field and appearing let's reset the particle on lifetime any of there's our effect with the sphere moving around as well as the unity logo so the particles get spawned on the position of the sphere as it moves and they get attracted towards the unity load now if you remember up here we disconnect this gradient so all the particles are being spawned as a simple white but down here if we enable the point color over life so enable this one and if there you go now you can see that the particles do take some color so the color is in here on the blend it uses this property which is exposed and you can see that it's using this gradient so each particle goes through all of these colors over its lifetime that's going into this color input and then it also has a very interesting complement so what this planning is doing in here is its planning the color of the particles when the sphere passes over them so in there you can finally see that even though the particles are changing color you can still see where these fear is moving now the input in here is from the sphere as it moves yep then we take that sphere input we get the position of the current particle and we do a simple distance compare it to the sphere center then we simply subtract the radius and then we use that Valley in order to sample a specific value on a curve so what this is doing is essentially if the particle is right on top of the sphere then this node will output zero and if the particle is too far away from the sphere then it'll output one so we can break off this connection and many will modify this to see what happens so if this one is at the other then is going to sample the curve right on the on left side there so the output in here will be zero which means it will not blend with this color so without pointing then the output color won't simply be the one that it was fun with and if we change it to one thence essentially using this color which is a gradient over the life of the Paragon so the output from this one into this one won't depend on the distance of the particle to the sphere then it grabs a position on this curve and then it outputs in here and depending on that you neither uses this color or the starting cone so if we connect this one back and if there you go now they get spawned with a different color and you can see how the effect of where the sphere goes over some particles they go back into their original cone all right so here is the four complete effect it looks pretty complex but hopefully now you understand how it's made up of a bunch of relatively simple systems all interacting with each other this is a really good looking effect that works as an excellent sample to showcase the power of the visual effect graph again remember how throughout all this time we've been playing around with hundreds of thousands of particles and it's not running any rocksolid framerate so here it is the effect looking real nice alright so this was a bit of a different new type of video this is the first time I've done a deep dive on an official sample provided by unity let me know in the comments if you found this type of video useful if so then I'm gonna look into doing more deep dives into more effects as well as other ent projects like the dot sample or the ELA script so let me know in the comments this video is made possible thanks to these awesome supporters go to patreon.com/scishow to code McKee to get some perks and help keep the videos free for everyone subscribe to the channel for more unity preserves postnuclear salmon comes and I'll see you next time