hello and welcome I'm your code monkey here let's look at how to take a square grid and convert it into a hex grid we want to change the shape of the grid and also be able to identify what grid position belongs to a certain world position so a while ago I launched my turnbased strategy course it's a really awesome course that will help you take your skills from beginner to Advanced the reviews have been extremely positive so I'm really happy with how it came out throughout the whole course I'm constantly talking about writing good clean code and focus on keeping a good code architecture because of that the final set of the course is very adaptable and easily expandable so in the last lecture I asked what would people like to see in future free updates and the most common request is hex grid so that's what I've been researching now if you just want a simple math answer to test if a certain point is inside a hex I already covered that in a separate video that one is focused solely on the math for doing that test it's really great and I definitely encourage you to watch that video especially if you're not a math expert just like I'm not learning how to do that is relatively simple and will help you boost your math skills the goal in this video is a hex grid which doesn't actually require that logic for testing a point it's mostly just say it doesn't check like I said I'm harder to work on the free expansion for the course making hex reads work with the entire rest of that project but since this is such a requested and useful topic I figured I'd also make a standalone video based on the grid system that I've built over many videos on this channel and for this topic it's actually surprisingly difficult to find some good info on it if you search for Unity hex you will only find two things tutorials making visual hexes either mesh based or with a town map and tutorials on making hex logic but based on using mesh objects and doing some expensive raycasts those tutorials are great if that's exactly what you're looking for but while that approach does work it's not scalable if you create an object with a mesh and a physics on leather you will very quickly reach the limits of that method so you won't be able to make a game with a massive grin so over here on let's do it properly with some basic math now before we get to the code let's do a quick overview of what we're trying to build here over here is a simple image of a basic Square grid so all the positions are placed neatly in a simple square shape each grid position has a certain cell size for both the width any height now over here is the hex grid that we want to build the main difference between them is this offset on the X for each odd row so row 0 starts off here which would be on Samsung like zero zero however for Row one we need to offset it by a little bit and the offset position is going to be half the cell size and the other very important thing is the Z or the Y position by the way all the logic here works exactly the same in 3D or 2D meaning it's exactly the same in X Y or an exact plane so the code can easily be converted into either xbase or Y based so like I said over here the only difference is the Y offset when a squared we're in each row is exactly one cell size above the previous one however over here on the X grind the Y offset for over here the first row is not exactly the cell size if we were to offset upwards by the sound size then instead of being positioned in here it would actually be positioned in here and if we used half cell size then we would end up here so it's neither of those in order for this to be offset perfectly the offset has to be 75 the size so that is half the cell size plus a quarter of cell size or 0.75 of the size now these numbers are extremely important to get right in order to make sure that our hex grid matches perfectly with that we're going to be able to position all of our hex grid positions then we need to incorporate that into our coordinate conversion logic meaning converting to and from grid positions to warm positions so in order to convert from a grid to a wrong position that one is pretty simple we take the X Y grid position like for example over here grid position one zero we take that one and we just multiply it by the cell size so in this case if we got a cell size of 10 then position 1 0 would be in one position 10 0. and then on top of that we also need to test if it's an odd or even row so if it is an odd row like for example we're testing four zero one then we do the same basic math so in this case this would be one position 0 10 but then we check if this is an odd row if so then we add an X offset and that X offset is going to be by half the cell size so converting grid positions to one position is actually only pretty simple the tricky part is on the warm position to grid position for that when we receive a warm position we need to test which position that it belongs to now with the square grid that is pretty simple we can just round the position and it works so position over here is going to round to here position down here runs to there so all of it works however on a hex grid just rounding does not work for example here if we are above this line and we test the point in here just rounding it will likely give us this point here which would obviously not be correct so for this to work we first round the point to get a rough close the squared position so let's say rounding would round into this one then we take that node and we grab all six of its neighbors so the one to the left left down this one this one this one and this one we grab all six neighbors of the rounded grid position then we cycle through all of them and we do a simple distance check to the origin so check distance this one this one this one this one and we would find out that this one is indeed the closest with that logic we can indeed convert a worm position into the closest accurate grid position okay so that's everything we need to build so let's do it if you use unity in any way definitely get my ultimate TNT overview course it won't teach you how to use the many tools and features that ENT has so you can be more effective and make better games faster there's no need to build something yourself from scratch if there is already a builtin tool that works great UNT has tons of them that you might not know about the course already has 15 lectures each covering a different twohour feature of the engine and is constantly getting free updates or if you prefer stepbystep courses on making a specific game check out my Builder defender course I also have a phone course only on using visual scripting there's a single line of code in any of those games and if you're past the beginner stage and you want a guided path to help you make the jump from beginner to Advanced and get my turnbased strategy course it will help you massively improve your programming and Game Dev skills on all courses I'm always available in the Q a section answering all of your questions every single day so check them out through the link in the description okay so let's implement the design for our hex grid system like I said it's going to be based on my grid system which I've built over several videos on channel over here I have my grid class working so I got a grid with a certain width and height and as you can see it has a simple square shape now the goal is to convert this shape into a hex shape so here is the code creating that we're in all I do is Define a certain width certain height and a certain cell size then just create a grid using my grid class give it the width height the cell size position on Vector 3.0 then just cycle through the entire thing and just instantiate a prefab on each grid position again if you you don't understand this code go watch the other videos on the grid system this system was built from scratch starting from the very first video now the first thing we're going to do is handle the conversion from grid position to warm position first we want to do that so we can generate the correct worm position so we can position all of our visuals but before we do that let's actually duplicate this class I don't want to destroy my Square query system that one is still useful so here on my grid system just going to duplicate this and call this the grid xxz then inside the script just need to change all of these references so grid hex said just in there over here on the Constructor on the funk and I think that's it okay great so this is script and on the testing script just change the class name so from that one into that one so just replace all these and let's also rename this variable to grid hex XZ what it says just make sure nothing breaks and yep we still have a square grid okay so far so good now here in the editor I'm going to swap out the visual so I'm using this one which has just a basic square and I'm going to swap it out for this one which has a hex Sprite I drew this perfect hex in Photoshop Photoshop actually has a great tone for making perfect hex shapes I mentioned that in the previous hex video or you can also download the project files for this video and the Sprite won't be included so over here just swapped out the prefab and let's run and yep it is indeed spawning the hex visual but obviously it does not look correct we can see that we have a gap in here because we are placing this hack still in here when it should be offset and slightly on Lower so let's first implement the offsetting of odd rows let's go over here into the grid hex XZ script and let's scroll down to find the function so here it is the one to get a warmer position so it takes in an X and a z and returns a world space Vector 3. again we can refer back here to our diagram so if it is on then we want to offset it by half the cell size so over here we're going to return this position so we get that multiplied by the cell size plus the origin position in the end and then plus Let's test if it is an odd position how it has a super simple we can do a modulo of two so if this one is one then we do know this is an odd row by the way if you don't know the marginal operator this is the modulo in math so it's basically the remainder of the division so that's how we can tell if this is an odd row or an even row so if it is an out row then we're going to add our offset and like we saw the offset is on the X so let's put one zero zero and the offset amount is going to be by half the cell size so cell size times 0.5 F and if it is not an out row then we don't want to add an offset so let's use Vector 3.0 okay so that's it and just with this let's see if the offset is already working correctly and yep it is indeed working so the even rows are still placed exactly where they were but the odd ones are now offset okay so that's good but of course there's still the issue that I mentioned before for the square grid we do offset it on the Z by the size same as the wind but on the hex we're in we need to offset on this end by half the size plus a quarter of the size so in total 0.75 the size so again here in our conversion we for the X we're going to move by the sound size that is correct but then for the Zen so new Vector 3 offset this time on the Zen for this one we're not going to offset just by the sound size but 0.75 F of the cell size and actually this number here 0.75 this will be used in several parts of our hex logic and as always we never want to use mysterious magic numbers like this if you were to return to this code after some time you would have no idea what this 0.75 represents so let's go up here and make a proper constant with a proper name let's call it hex vertical offset multiplier and we put in that 0.75 f okay so now we use this so let's go down here instead of this magic number let's use our constant okay great just with this let's test and if it's working okay great all right so with this the easy part is done we have successfully managed to convert grid positions into warm positions all right awesome now let's go into the more complex part converting a worm position back into a grid position for a nice visual just so we're able to see what the logic is doing over here on my hex prefab I've got the standard hex Sprite then I've got another one also a hex Sprite except this one is going green basically we want to show or hide this game object so we're able to see which grid position the conversion process is actually selecting so over here on the testing script let's just add some visuals to our grid object then just a basic show and height function okay it just finds the selected game object and sets it to active or not again we're doing this just so we have some nice debug visuals so over here then we need to assign it so instantiated we grab the reference then we go into the grid object on this position and we assign the original transform and tell it to hide itself then let's show the selected for the one underneath the mouse position so let's do a private void update and on update let's get the mouse run position now if you don't know how to do that check out my quick video tutorial on it and there I made this function so I can use it here so get the mouse run position then I go into the grid hex and I get the red object on this mouse run position right on this one to show and now I just need to hide the previous one so I just need to get that one so private for the grid object the last grid object okay with that then now over here if it is not known then we tell the Hind and then we tell it to show okay that's it so with this we should be able to have a nice visual which is going to be very helpful as we try to handle our world to Great positional logic let's see and yep it is working so as I move the mouse I am selecting the underlying hex grid position okay now obviously as you can see the logic is not working so the mouse is over here and it's liking down down there so it is not correct the logic is still based on rounding which works for a square grid but obviously does not work for a hex grid so going back to the implementation overview I covered in the beginning for this to work like I said we need to round the position and grab the rough X and rough Zen then we take that grid position and we grab all six of its neighbors with that we test the distance to each of them and when doing that we're going to be able to find which one is the actual horses neighbor which will be the closest hex position so when we do the first rounding that is just the rough X and rough Zed and not the final one so over here on the function to get the X Zen which by the way just in case you haven't seen the other grid system videos when we call grid grid object when we call this this one is then calling the get xn so in the end we end up going through this function okay so this one is just following the values now this is not going to be the final value this is just going to be the rough one unless actually round set of four so let's grab an end for the rough X and we're going to round this one and this is going to be an end for the rough Zen and again let's also round it so we have the two rough values now let's make a list for all the neighbors that we want to test so let's say a list of vector 3 int neighbor XZ list and now here an extremely important thing is you have to remember that the hex grid has an offset so back to our diagram here if we are testing something over here and we round out to this position 2 2. if we go into this one then we can see that the first ones we want to test here the left and right Neighbors so just minus 1 on the X and plus one on the X so let's do 1 on the X and we're going to do a vector 3 end of the rough x z then here we add the rough XZ to this offset Okay so we've got the left one then the right one is going to be pause one okay and now here comes the tricky part which is for the ones above and below for these ones if we go minus one on the X yep we do get this one but then if we try going plus one on the X then instead of getting this one we end up with this one that is not what we want we want the six neighbors so in this case would be 1 and plus zero however that also depends if we have an even row or an odd Row for the odd row as we can see we want minus one on the X and plus zero however when working with an odd Row for that one we want plus zero n plus one if we do minus one and plus zero then we end up getting these two and not these two so again this is the tricky part definitely make sure you get the offsets correct if you make a mistake you might see issues because you won't be testing the exact six closest neighbors so over here let's grab that neighbor science first put all of them so on a plus one we testing minus one and the plus zero and then the two neighbors below so it's minus one on the Zen ten differences on this one it won't be either minus one or plus one depending on if it's an odd or even row so let's define here a bow call it odd row and we grab the rough Zen and again the same thing module of two see if any equals one if so then this one is an odd row then over here if this one is an odd row if it is odd then we want pause one and if it is not then we want minus one and same thing on this one all right so this should be working again be very careful make sure you don't get the neighbors wrong let's do a quick test just make sure this is all working correctly let's print out all the neighbors okay so here just add a simple album let's see all right so I put the mouse over there on position two two so we can see down here so we are testing position two two all right and the neighbor is going to be 1 2 which is the one to the left 3 2 which is the one to the right all right then we have one three so three is going to be the row above and one is going to be to the left so it's going to be this one then two three is going to be this one and then down below we have one one and two one so it works on even rows now let's put the mouse position over here so with this one it is now position on one one so this is zero zero one zero and over here we have one one okay that is correct then we're testing left and right so zero and two so zero one two one yep correct then we test two two and one two so row two is going to be this one so this one is zero and we're going to test one and two so yep that is correct and then down here on row 0 we also test one and two yep also correct all right so we're correctly grabbing all of our neighbors now after this the code is going to be super simple so we just cycle through all the neighbors yep and then we're just going to do a basic decent share to find the closest foreign so here it is just some basic closest logic so we cycle through all the neighbors then we test distance from the worm position that we're trying to test we test from that one to the warm position of this neighbor so if that's distance is closer than the one that was previously closes then this one becomes the new closest so we cycle through all the neighbors and then we return it okay so that's really all the logic as you can see it's all super simple the only tricky part just over here the neighbors but as long as you make that correctly other than that it's just a simple lesson check also one thing that I forgot a while ago over here when calculating the rough values for the rough for the Z we also need to incorporate the hex vertical offset multiplier so over here we also need to divide by this one if we don't do that then with a bigger and bigger grid then the rough set would become more and more inaccurate so it wouldn't actually work so let's test any up here we can already verify that it is indeed working so if my mouse over there if I go anywhere inside the hexagon yep I'm inside and if I go outside yep I'm on this one so it works on an odd row and if I go here yep it works on an even row so wherever I place my mouse position I can go to the edge go to zero zero to there and all of them it's always perfect which one is selected underneath the mouse position so it works if we test on the horizontal sides so over there it swaps over there it swaps it works on diagonals that one that one that one and that one and it also works on a really massive grid so here I am regardless of what size it is I always know which grid position is under the mouse position always always perfect whether I go into the corners into the sides of the edges all of that works perfectly alright awesome now at this point I should point out that obviously you can massively improve the performance of this system over here we are generating a ton of garbage by generating the neighboring list every single time so you could probably catch these Neighbors in some way to avoid all of this then perhaps instead of checking the distance against every single neighbor you could add some basic checks to limit how many neighbors you test so there's plenty of ways to make this more performant and then of course for the visuals over here just to keep it simple I instantiate a new game object for each grid position however obviously that is not very scalable so instead a much better approach would be using the tile map that I covered in a previous video that one is based on dynamic only generating a mesh and attaching it to the underlying grid system just like this one so with that instead of having one game object per each grid position you would have just one game object for the entire grid that would be much much more performant so you can watch that video to learn how to do that or you can just watch my video on how to dynamically generate a mesh through code that is really only need to make this a lot more performant alright so now you know how to make a hex grid system if you want a fun challenge go watch my grid system videos and convert one of those systems to this hex grid system for example the grid building system that would be a fun one to convert and also I want to apply this to the ASR pathfinding that I covered previously since I won't use this same underlying grid system it should be pretty easy to convert and of course like I mentioned beginning the reason why I researched this topic is because people ask for it in my turnbased strategy course I'm harder to work on the free expansion of the course heading hexologic to that entire game if you haven't picked up the course definitely go ahead and give it a look I worked really hard on making it an excellent course specifically to help guide you and take your skills from beginner to Advanced so if you're interested in turnbased strategy games or really you just want to improve your programming and Game Dev skills while learning how to write good clean code then check it out and if you already have it then this hex grid update won't be a commonly free expansion to the course hopefully within the next few weeks alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and I'll see you next time thank you