in this video we're going to write superfast Java fight code for our units to find their closest target it won't be super fast which will enable us to have thousands of Units looking for targets all at the same time let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with nf2 torrents made by a professional indie game developer so if you find the video helpful consider subscribing this video is a continuation of the previous video where we built units and targets and created systems for those units to find and destroy those targets now in that video with it everything using only CS and in this video we're going to use ECS combined with the job system in order to achieve maximum performance so if you haven't already check out that video first to see how the basic setup is done and how we're looking for the closest target using normal ECS systems so let's see the scene in action here it is and as you can see we have targets and units and our units are actively looking for the closest target they move towards it and they destroy them okay so let's review the code to see how all of this works so here is our basic starting script and in here we have two functions one to spawn a unit entity and another one to spawn a target entity you can see here the entity archetype they are very similar the only difference is the tank opponent so this one has a unit tag and this one has a target tag those tags are defined down here as you can see they are just empty components then we have our fine target system first we cycle through all the entities that do not have the half surrogate component but do have the unit component so all the units without a target we cycle through all of them and then we cycle through all the target entities we calculate which one is the closest and if we do find a closest then we add the component has target using our closest target entity then finally we have this system which runs on entities that do have the have started component it simply moves them towards the target and once he gets within a certain distance we simply destroy our target entity and remove the historic component okay so this whole thing is working perfectly fine as you saw here we have our units all of them actively looking for the closest target move towards it and destroy okay however right now we're not taking advantage of all the benefits that the entire unity dot stack provides here in our final target system we're cycling through all the entities one by one just on the main thread so for each unit we and this system will get exponentially hard to run so in order to make our code multithreaded all we need to do is convert this from a component system into a job component system so let's go down here to make that let's call this a fine target job system and we're going to extend the job component system so in here we're going to do pretty much the same logic that we were doing previously except we're going to do it inside John so we're going to have a job cycling through each unit and in there we're going to search for the closest target so let's start off by making our job so we make here a struct for our find target job and we implement I job for each with entity and we also want to grab the translation components so in order to implement the I job we need to add the execute function so with our definition here it means that our execute method receives an entity the index for the entity and our translation component now for translation we don't want to modify it so in here we can add the readonly attribute now we want our job to run only on our units right now this job would be working on every single entity that contains a translation component so in order to limit where our job runs he can go here in order to add the attribute we're going to add the required component tag type of unit so now the job will only run on entities that contain the unit tag and then we also want to ignore the units that already have a target so we can use the attribute exclude component passing the type of has targets okay so now our job is clearly defined to works only on units without a target so here we essentially have the exact same filters that we have in here working on the units with none has target with all unit and doing it for each that's exactly the same thing we're doing in here now inside in order to look for the closest target we need to know a list of all of our targets so that means in here we need a negative array to hold all of our targets so an entity for our target array however in order to identify the closest target we don't just need the entity but we also need the position so we could either have two arrays in here one for the entity and one for the position or we can just go up here to define a simple struct to home both the entity and the position so here we make a simple struct let's call it entity wave position and in here we're going to have an entity field and a followed three for the position all right so now in our job we receive this instead so essentially we're receiving an array of entities with their position we also don't want to modify this array so we can have the readonly attribute and since this native array won't be running inside our job which is managed by our job system we want to make sure the array gets is posed correctly so we can add the attribute deallocate on job completion which means the job system will automatically deallocate this array when it goes through and completes the job so here we have all the information that the job needs we have our targets and their positions and now inside our job the logic we're going to do is pretty much exactly the same thing we were doing previously so let's copy this code and see what we need to change so for the unit position it's the translation dot Valon then instead of cycling through the entities we cycle through our array so we cycle through all of our target entities then here if the kosis is known then this is the first one you found so we set this one very simple and if not we check which one is closest so if this one that position is closer than the current causes and this one becomes the new causes so that's pretty much the exact same logic for looking for the closest within our target list and then if we do have the concern identity we want to add the has started component however inside a job we cannot use the static variable for our post update commands but instead we can pass in a field that won't contain an entity command buffer so in here a public entity command buffer let's call it empty command buffer a command buffer essentially holds the commands that won't be executed that on a later time and in order to write it concurrently on our job we need to use the command before dot concurrent okay so now we can go in here to call our add component function takes a job index so we can use the entity index then our entity and then our has started in front okay so here we have our job doing the exactly the same thing that we were doing previously on a normal component system except right now we have our job component system so with the job defined that we need to actually create it schedule it and completely so down here on the on update function first we need to create an instance of our job and now in here we need to pass in our target array so we need to create it before that now here we need to know the size of our array which means we need to know how many targets are on the scene so in order to second through all of our targets we need to create an entity query containing all the target entities so we create an entity query for the target query and we get the entity query and seen here that we pass in our parameters so in this case we want our targets so typo target then we also want with the translation component however we only want it read only so we can use the component type that read only of type translation so we have our target query which is essentially asking the entity manager to give us all the entities that contain a target and a readonly translation component then we can grab all the entities that match this query and put them into a native array of entities for the target entity array and it will simply be the target query dot entity array okay so we now have an array containing all of our target entities now we also need containing all of our target translations so for that we use two components that array with our translation components and using the same allocate and now in here on our target array we can spawn it using the length of our target entity array okay so we do a query to get all the entities with target and translation then we get an array containing all of those entities another array containing all translation of those entities and then we create a new entity with position array that we're now going to have to fill so all we need is this icon through it and we set the target array on that index to be a new entity with position and we're going to pass in the entity as our target empty array of the same index and our position as our target translation array of the same index dot Val maximally here we have nurse since this should be a 4 3 for the position so that it holds the x y&z okay so here we have correctly filled up on our target array containing entities with position which contains the entity and the position of all of our targets so now we can simply pass in into our job now in here since we are working with native arrays we have to make sure to dispose of them our target array gets this posed after the job execute so we don't have to worry about that one but we do need to dispose these two so in here that disposed and do the same thing for the other one for target translation okay so we have prepared all the data that the job needs now the last thing that John needs is the entity command buffer so here we need to pass in the command buffer that runs after the update so previously we were using up here the post update commands however this one only exists on the normal component system and not on the job component system so we need to use something different so let's override protected overwrite our on create function and in here we're going to go into the world to get or create a system and this case let's grab the end simulation entity command buffer system and let's store this so we have this command buffer system which runs after the main simulation so this is perfect to use as our entity command buffer so we simply go in here we pass it to the job and create a command buffer and since we want to write it concurrently on the job we need to pass in two concurrent so just like that our job will now be able to run our line or to add a component at the end of the frame and the last thing we need is to tell the entity command buffer system to run our commands after the job has happened so in order to do that first we schedule our job so find target job and we call schedule we schedule this job this returns our job handle and then we tell the command buffer system to add the job panel for producer and repassing the job Himmel essentially this tells it to execute the command buffer after the job has been completed and finally on the job component system we need to return the job Hammel from the on update so after this we just do a return on our job hammer alright so this might seem like a lot of code but it's actually very simple and you won't see what benefits we get from writing it this way so first up here we define our specific job this job won't run on our unit entities over here will receive an array containing the entity and position of all of our targets then for each unit entity we cycle through the targets and count like the closest if we do find the closest we add the component and down here all we need to do is prepare the data that the job won't work on so we grab all of our targets we grab the entity in the translation we create our specific struct we passed the job will let the job system schedule it to do its thing and afterwards we have the command buffer executing all right so let's test and we should be able to see everything so the same in order to disable let's appear and comment out our previous component system to make sure it doesn't run okay so let's see any up here we have our units they are still being spawned they are still finding it causes target moving towards it and distraint okay so our logic is still working the same now let's see exactly how much faster this method is compared to the previous one so in here in order to test out how much time this is taking let's stop adding the component so this way they won't continually search for targets every single frame and let's also test out the previous code some let's instead use the component system and comment out the junk component system let's see how long the normal component system takes and in here instead of just five targets let's spawn a thousand units and a thousand of turrets and we stopped funny okay so we have a nice test with a thousand units looking for a thousand targets and it's currently running on a normal component system okay so here we have a thousand units looking through a thousand targets and as you can see the performance is pretty bad we have the CPU taking 260 milliseconds and the game is running at four frames per second none of them are moving since we're not actually adding the hosteria components so when we're testing is really how long it takes to find a target so again remember this is a normal component system so essentially for every single one of those thousand units it's doing a cycle on a single thread and for every single one of those thousand its cycling through another thousand times for every single target so you can already see this is a lot of single threaded sequential work so we can for example inspect with the profiler and here's our profile and as you can see about 250 milliseconds okay so this is the normal own now let's see the improvement with our job system so here we count out the normal component system and now we try out the job component system okay let's test and here we are and as you can see already a massive improvement we went from 250 milliseconds per frame down to 70 milliseconds per frame and from 4 frames per second to 14 frames per second and here in the profiler you can see it taking 70 milliseconds and our jobs are being quite busy now if you've seen my other video on ECS and the job system you know burst can provide an insane boost so let's try adding it to this job in order to add first thing we need is to add burst compile in here which is using unity dot first okay that's all it takes to add burst so let's go back okay so here we are and again using normal component system we were taking 250 milliseconds using the java component system we are taking 70 milliseconds and now lets enable burst and there you go from 70 down to 2 milliseconds we can open up the profiler and take a look and there you go the home simulation taking point 6 milliseconds and the fine target job system taking just point 3 milliseconds so as you can see that's pre insane performance so let's rename our ad has target component so here we just go and put this back so we should now have our units fine target and destroy them and as soon as we try we come up with a bunch of Arabs so all these errors are essentially saying that we cannot use burst and use the entity command buffer at the same time the reason why burst is so fast is because it works on an extremely unlimited subset of C sharp and in that we have a bunch of limitation so in this case we cannot use the empty command buffer in order to add a new historic component so that's pretty bad but we can work around that so here on our fine target job essentially the only thing we cannot use burst for is this one right here at the end so that means that we can essentially split this job into two and have one job to complete the closest entity and another job to actually add the historic component so we will have one using burst and one not ok so let's do that let's copy this job let's call it the fine target burst job and again in here we cannot use the empty command so we get rid of this so all we're doing these cycling through our targets and finding the closest however then we need to know which one is closest so on another job we can actually add it so in order to store the closest let's also go up here to add a public native array of type entity and this will be the closest target entity correct so we do all of our calculations and then we put our closest on the same index so if what we call is the starting empty in there so we have this native ray that we are using in this job essentially using as our output so down here when we make our final target first job for the target array we use the same one and then instead of passing in the entity command buffer we need to pass in an anti array the size of our units so we need a native array of entities and just like up here and let's call it the closest target entity array now in here we need to know the length so for the length let's do the same thing we did in here we grabbed a entity query except this is the unit query and we get it with type of unit and here instead of using the component type readonly let's use the exclude of type has target since we only want the units that do not have a target then here we know our link in order to go here completely linked and that's the size of our array all right so we have our closest target entity array and we pass this one into the job so this job has burst enabled and it locates the closest target and puts a result on this array and then we make another job let's make here a private struct let's call it the add component job and to be very similar we also use the I job for each with entity and let's receive a translation and in here we get a entity command buffer dot concurrent for our entity command buffer and we're also going to receive a native array of type entity for our closest target entity array we can have the same attributes that we add in here so this one won't be readonly and it won't deallocate on the job completion and here all we do is we test if the closest target in the array of this index is not entity no so if this entity has a closest target then we simply go into the entity command buffer in order to add the component using this index into this entity a new has target component with a target entity as our causes target entity and this index and that's it this is our second job which is only responsible for adding the component to the entities that do have turned and we have our first job which uses burst and just completely closed so this way we get the best of both work so you use burst for maximum performance and we still have our behavior work now we need to actually schedule this job so down here let's make an add component job for the closest target in the array we use the one that came out of that job for the empty command buffer we pass in the same we were using previously and now we schedule this job so the add component job dot schedule and now in here we schedule it with the dependency of our first job since first we want to find it closest and then we have the component so we run this job and when this job completes we run the second job and that's it this way we can benefit from burst in order to do all the find closest math and then we have a separate job to do the part that burst cannot do so let's test and see if everything is working and run and yep here we are and the hall automatically found the closest move to it and completely destroyed all of the targets so again let's check out the performance difference for all of our different methods so here in let's just disable adding the component so we can test so first let's try out just the component system so here we have just a component system looking for targets we have a thousand units and a thousand targets taking 270 milliseconds ok now here we are using the job component system and we went from 270 down to 70 milliseconds so a massive improvement and now finally we enable burst and there we go down from 70 all the way down to 2 point 5 milliseconds again we have a thousand units looking through a thousand targets of that happening every single frame and yet we have 2.5 milliseconds so you can see the massive benefit you get when you use the entire data stack as always you can download the project files and utilities from in tucumán comm if you liked the video subscribe the channel for more unity to turrets post any questions you have in the comments and I'll do my best answer alright see you next time