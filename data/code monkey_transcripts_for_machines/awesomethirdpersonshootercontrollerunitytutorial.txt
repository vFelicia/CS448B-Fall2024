hello and welcome i'm your code monkey and here let's build a third person shooter controller so we have our normal third person controller and we can move our character in any direction then by pressing a button we can go into a mode where we can then shoot so we need to handle the two states and on the camera and the animations handle how the bolts work and put it all together in a nice clean way so we can expand upon it in the future and for me personally this demo project was a great new learning experience i'll talk about it in a bit this is a pretty long video since it involves quite a lot of individual elements so if you want to skip ahead to a particular topic or watch the final polish controller there's timestamps in the video if you prefer a more guided path with stepbystep lectures then check out my complete courses learn how to make a bundler defender game using csharp just like i make my own steam games or learn how to make games internally using visual scripting or learn all about unity with the ultimate overview course which contains over 13 lectures each covering a different tool or feature of the engine to help you make better games faster i'm always available in the courses q a section answering your questions every single day so check out all the courses with the link in the description okay so let's build a third person shooter controller now this video is kind of split into two parts the first part is a stepbystep tutorial on how you can recreate all the logic and then in the end i will take that as a base and polish it into a really nice thirdperson shooter and talk about my research process for building this but first of all let's actually make it so here is my starting scene now i already have a third person controller this is the super useful controller made officially by unity it's part of the star assets which includes this controller as well as a first person one i covered both of them in another video and you can grab them for free from dnt asset store so what i have here is exactly that third person controller so with that i can already look around i can move around i can walk run i can jump and so on so all this by default just by importing that package now on top of this we're going to build our third person shoot on logic so the first thing that we need is just like i mentioned in that other video we need to make a second virtual camera set up as a shooting camera so over here is my scene and the only change that i did is over here on the player phone camera i put the shoulder offset on these values so a bit to the right and a bit upwards so there you go so it's like this and i put the camera side all the way to one so this is to make it so that it's a bit more like a third person shooter so you got the crosshairs down the middle and the character slightly to the side so let's first duplicate the player follow camera let's call this the player aim camera and over here just modify some settings so in order to see difference let's just increase the priority so let's put it at 20. so this is the one that is now active okay so for these settings first of all we want to zoom in so a slightly lower fov so let's put it maybe on 30. so slight zoom in then let's also push the camera a bit forward so over here on the camera distance push it a bit forward so maybe something like 2.5 okay so with this if i enable and disable we can now see the difference so this is the normal camera and this is the zoom in camera and over here again the difference that i made from the default third person is we've got the camera side all the way up to one meaning that you can easily toggle between the left and right shoulder so you go from zero it's on the left shoulder go to one on the right shoulder so that's a prestandard option in any third person shooter okay so with that that's pretty much it everything else is pretty much the same so we want third person follow so everything else is correct so with this we now have two virtual cameras so the first thing we want is just some basic logic to switch between them so let's begin by making our script so in uc sharp script called the third person shooter controller and here on the player armature let's just drag this script okay now here let's first begin by adding a reference to our aim virtual camera and for that let's make it of type cinemachine virtual camera just in case we want to change something on the camera itself later on so we need using syn machine and then we're going to make a thin machine virtual camera for the aim virtual camera make it a serialized field so we can set it in the editor so back in here just drag the reference all right now here since we already set the aim to have a higher priority all we really need to do is just enable or disable this game object so to do that let's make a private update and now here we need to test for input and for that the star assets package is using the new input system so for the aim let's use that one as well if you don't know how to work with new input system package go watch my video on it it's a very capable system that makes input handling super simple and it's what you definitely should be using in your final projects so it's eastern action so let's just open this one and here it is all the actions involved in this third person controller so let's add another one let's call this aim and now normally for type itself i would use it as button but here i'm trying to stick as close to the standard set by the starter assets so let's set it up exactly the same way as the sprint here so both these are meant to be hold actions so let's set up the example the same way and this one is set using passthrough so over here let's do the same thing pass through okay and then for the bindings let's add one let's listen listen to the right mouse button and let's also add another one and this one is going to be for a gamepad and for aiming let's go to a left trigger there it is then just make sure to assign this one to the gamepad control scheme and this one is on the keyboard mouse control scheme okay our action is defined let's just hit on save ascent now we need to listen to when that action happens so on the star asset itself we can see that it's using the player input method and for the behavior itself it's using send messages now personally when using this class i would prefer to use unity events but again i don't want to change this i want to stick with the standard made by the start asset so let's use the same method and if we stick with the same pattern then we listen to that event over here in this start assets input so for the behavior we want it really to be exactly like the sprint so we can examine just copy all that logic so instead of a sprint let's make an aim and then down here we've got the on events and so let's copy let's make this on aim then we're going to make an aim input function and then down here let's copy the spring input and just make it the aim input okay so there it is we made it work exam like the previous one and now in our third person shooter controller first we need a reference to the start inputs so a private star assets inputs so this one is inside a namespace all right we have the inputs and then on our update we're simply going to test go into that one and test for the aim volume so if this one is true we want to enable the aim virtual camera so let's go into this one.gameobject and we're going to call setactive and if it's true we're going to set it to true and if not we're going to set it back into false okay so just with this it should already be working so let's test okay here i am and everything looks normal now i right click and there you go it zooms in and i'll let go and yep it zooms out okay now it's obviously way too slow so let's fix that let's go into the send machine brain so on the main camera we've got this in machine brain and over here we've got the default transitions so it's taking two seconds let's make it quite a bit snappier so maybe point one let's see so here it is and i hold yep there you go now it's nice and snappy okay great so the next thing that we need is aim sensitivity right now the sensitivity is the same in both modes which works on right over here in normal mode but if i zoom in then it's way too intense it's very difficult to aim correctly so let's set up the logic to have two different sensitivities now in the video where i made an overview of the starter assets in there i already covered how you can add sensitivity to the third person controller which doesn't have that field by default so let's modify the third person controller script over here let's just add another one so let's make a public load called sensitivity and define it to 1f and then down here we just find the camera rotation function and on this one we're applying the input so we just multiply by the sensitivity and just that it's already working now we just need to build upon this and we're going to make a function to expose the sensitivity so let's go down here make a public void let's call it set sensitivity okay so we got a function to change it and now let's go into the shooter controller and over here on let's add fields for both of them so make it a serialized field make it private it's going to be a float for the normal sensitivity another one for the aim sensitivity and then we set them to the same way that we set the zoom so we need to get a component of that one all right so we get the component from the same object and then we simply go into that script we call set sensitivity and on this one we set it to the aim and on this one with normal all right so let's set these films in the editor so let's say for normal keep it at one and for aim let's put it at half okay so here i am with this sensitivity and as i zoom in yep now it's much smaller allowing me to be quite a bit more accurate all right great now the one thing missing here is a simple crosshair so we know where we're actually aiming so let's add one now this is very simple we just need first of all a canvas so let's go into ui make a new canvas then for the canvas set it up like i normally do so leave it on screen space overlay over here scale with screen size go with 1280x720 and match with the height so that's just the center that i like to follow and now inside let's make an image so a new ui image just called the crosshair and over here i've got a simple sprite of a crosshair so it's just something very basic that i do in 30 seconds so just sign the image and let's make it quite a bit smaller maybe 50 maybe 30 something like that and that's pretty much it nothing else we need to change just make sure it's pivoted on the center and it's on zero zero and yeah there it is now we have our character controller and we can see exactly where we're aiming alright great so with that done now it's time to handle the shooting now for this there's actually two ways you can do it one approach is you can make the weapon shoot actual projectiles or you can make it a hitscan weapon so for that one there's really no right or wrong answer it really depends on the type of game that you're going for now i actually made a video quite a while ago on the various ways to handle projectiles in that video i covered the methods in 2d but the logic we're going to use here is quite similar so do go watch that video after this one to see how it works in 2d now the most complex thing to do has to do with where you want the ball to go now the reason is because this is a third person shooter so that means the camera is slightly off to the side and not right on top of the player so that means that if you have the player itself just shoot forward it's going to shoot forward and not actually shoot where the crosshair is so even if you go with the projectile approach it still helps to do a quick raycast just to see exactly where the projectile should go okay so let's do that now here in our script the way we're going to do that is with an actual raycast now a while ago i covered how to get the mouse warm position in 3d and 2d now that method is making a raycast on the mouse position and see where it lands and that's exactly what we're going to do here so let's actually copy the code from that video it's on the mouse 3d class that i've got on this project so here it is that's the code that we made in that video and here we've got the update making array and yep okay so like this it would work however here we're using the old legacy input manager so we could change this to use the new input system we could do it using unity engine.input system and then over here we could do for example mouse.current grab the position and read the value now we could do this however with this the game would break if there was no mouse connected so it would break for example if you were playing on a console now since we want this to work with the mouse but also just a gamepad let's go with another approach all we really need is the position on the center of the screen since it never actually changes so for that we can do some very basic math to get that point so yep it's that simple we just make a screen center point we grab the screen width divided by two the height divided by two all right so here we have right the center and then we do a screen point array so the same thing as usual then we've got the collider mask so first of all let's rename this to the aim to leather mask and let's define it up here so as usual serialize feel make it a type layer mask i cover layers and bit mask in another video if you're curious to how it actually works so this is an aim collider mask okay so our logic should be working except over here we do not want to modify the transform position but let's verify that it is correct so let's make a debug transform so up here add another field just a private transform call just the debug transform then down here we set that one on the position just make sure that this point is actually correct okay so back in the editor here we've got our script first of all we need the aim collider and layer mask now over here all the walls on the environment all this is on the default layer so let's collide with the foam layer okay then for debug transform let's create just a 3d sphere put it pretty small and just add a nice material just for fun okay so this sphere is going to be our debug transform so just over here let's move it okay so it says and we should be able to see the sphere exactly always on the crosshair position let's see and yep it works so wherever i unlock i can see the sphere is exactly on there so with this we now know the worm position of where we're actually aiming alright so far so good however here we actually have the same issue that we saw with the house building system in the third person video and the other issue is the sphere is approaching so that has to do with the call either so just over here let's just remove the call either and okay no longer has that issue now as i was saying we do have the same issue that we had with the house building system in third person so in that video if you remember there was an issue when we looked at the sky because the sky does not have a call either so that's the exact same thing here if i'm looking at the ground floor and so on everything works there's this here okay but if i look towards there's no collateral so if i look up at the sky and nope the whole thing breaks so there's no sphere anywhere because over there there's no collateral so the simple solution is just like it did on the house building system which is to make sure there's always a collider let's add some basic invisible walls all around the world so there's always something to collide with that's very basic let's just create a new cube let's just move it to the side all right so i've added colliders all around but obviously the player is not meant to be outside in here so very simple let's just remove the mesh render there you go now we've got the colliders but they have no visual and now if we test and we aim around yep everything works perfect alright great so far so good now one more small thing here usually in third person shooters the character rotates as you aim so as you look around right now the character is still facing forward but it should be aiming towards where i'm pointing so let's add that over here we're testing for the aim changing sensitivity and so on so in here let's just calculate the vector from the player to the target position okay so here first of all i have the mouse compilation up on the top so we can use it down here so just to find the vector3 for the mouse one position then we do the raycast the usual thing reposition the debug transform even though we can remove this later and then we just have the muzzle position all right so then we just grab that one and first of all we make it the y match the exact same one as he transformed position y because right now we just want about left to right rotation we don't care about up down so with that then we have the aim direction towards the world name target so with this now we can rotate the player and we can do that with transform.forward so this is the player's forward vector which you can read but you can also write in order to rotate so if you're like me and we prefer dealing with vector threes instead of quaternions then this is a great way to rotate things and to make it smooth let's do it using a vector3.org all right so like this we should be able to see the player rotate to face the world aim target and it should rotate nice and smooth okay let's test so here i am the character is looking forward and i can look around and see the character all right but if i zoom in now i'm aiming and yep there you go now the character does aim towards where i'm actually aiming and the aim itself is also nice and smooth so instead of being instant there's a nice smoothness to it all right great so everything seems to be working however we actually do have an issue if we start to move so if we're moving like this yep so normal i can move and look around but now if i move and aim at the same time and yep now look at that now the character is not looking there now the whole thing is messed up so the issue here is that the base character controller is trying to rotate based on the move direction but then we're also trying to rotate as we're actually on the aim mode so we need to make sure to do just one or the other for that let's make a function to disable the rotation on the base script so over here on the third person controller let's add a simple boolean so private bone let's call this rotate on move and let's default it to true and then we can go down here into the actual move function so it's over here that we're moving the things and so on all right and we're handling the target rotation so over here this is how it's facing the input direction so we're only going to run this if that volume is set to true okay so now we just need to expose this bone so down here do the same thing okay so we've got this function exposed and now on the character controller now we can do that so in here we go into that one so while aiming we set it to false so that one does not rotate and when we stop aiming we set it back to true okay let's see all right so here i am i can walk around the character rotates as it should all right and now if i zoom and if there you go now the character no longer rotates so now it actually always faces the nice same direction all right great so let's continue now the sphere is always on top of the crosshair which means that we know the world position of where we're actually aiming so with this like i said you have two options one is to make the bullet an actual projectile so you spawn the bone on top of the weapon position and you rotate it to face the crosshair worm position and then just move it forward and test for physics conditions as it moves that's one approach and the other approach the head scan weapon is to do the raycast and then we check the object that we hit we test if we hit something we can damage and we just deal damage directly so let's quickly try out both methods so over here i've got a bonus prefab that i prepared previously so there's a parent game object with a rigid body and a collider set to trigger then over here on interpolate set to interpolate so it actually moves smoothly and collision detection is set as dynamic since this one will be moving quite fast then inside we really just have a visual nothing else okay so let's make a script to handle the bone projectile so let's make a new uc sharp script for the bullet projectile and over here first thing is let's get that rigid body so private rigid body okay so on the weight we get it and then let's make it on start one start we're going to set the bonelet rigid body we're going to modify the velocity and it's going to be based on this transform dot forward vector so we do that and then maybe a certain speed all right so just like this it will move forward as soon as it spawns now testing for collisions since we made the collided trigger we test for ontrigger enter and then over here let's just destroy this game object okay now we need to define a shoot input so on the input actions let's define another action call it shoot and for this one this is meant to work like a button so let's copy exactly the same way as the jump action so make it a button then for the bindings let's add one first of all for the left button on the mouse okay and add another binding and this one will be for the controller so let's go with gamepad in this case for shooting let's go with the right trigger okay then set this one as a gamepad this one is the keyboard mouse all right so we have our action let's hit on save and now to listen to the action we need to add over here to the start assets inputs so again let's copy the exact same pattern as over here on the jump so this won't be the shoot so let's copy the on jump so you've got the onshoot then the shoot input so again let's copy all right so we've got our shoot bowling that we can test so back in the shooter script over here on our update what it says for that one so if we're going to go into the star assets input that's for shoot if it is true then we want to shoot our bullet so in order to spawn the prefab let's add another one up here so for the boneless projectile prefab so we're going to have that reference and then down here we're going to call instantiate so now we need to know where we're going to instantiate it so in order to define that position in the editor let's add another transform as well what's called the spawn bullet position so let's set both of these in the editor just comment out this line so it can compile now here on the player script let's first add the prefab so drag down okay and then let's make a game object so let's make it inside the player armature so just an empty game object so this is the position where we're actually going to fire our boat from so for now let's put it roughly there roughly around chest height okay the only thing is just make sure that it's not actually inside the player collider so make sure that it's a bit off so the ball doesn't spawn this right immediately so let's call this the spawn bullet position and on the script attach that one okay so then here we can now use that we are going to instantiate the prefab instantiate on the spawn ball position and then we need the rotation so for this one again we're going to make it face towards the mouseworm position so let's get it here okay so we call in the m direction we grab the mouse run position and we come with direction based on the spawn bond position all right so we've got that direction then we need to convert it into a quaternion so we use a local rotation and convert okay and then since this is meant to be a pistol we're going to set the issue to fall so it doesn't shoot constantly so as you click it shoots okay let's test and we should be able to instantiate the prefab and it should move forward then it should be destroyed when it hits a wall let's see all right here we are and as i aim and i shoot and if there you go it doesn't need spawn the prefab and it goes in there and then it vanishes so if i shoot into the ground yep there you go so yeah it is spawning correctly and it is going exactly towards where i aim so again remember the problem that we're trying to avoid which is to make sure that the player doesn't shoot just forward but rather it actually hits where it's actually aiming and yep it is working so aim at the corner and yep it hits the corner alright so far so good now let's identify the collisions over here i've got a simple visual for a target this is from the polygon battle braille asset pack there's a link if you want to get it so we're going to identify it using a tag component so for that let's go down here and just create a new c sharp script let's call it the bullet target and then let's leave it as a completely empty component so don't change anything this one is only used for identifying a target so on the target game object i'm just going to add this script so just add the bone target onto it okay that's it now back into the bone script when we've got the ontrigger enter let's says if we hit a target or not okay so that's it we just test for a get component if it is not now then we hit a target if not we hit something else now i just add some particles just to identify it okay so just adding two references some particle effects so one green one red if we hit the target we get green if we hit something else we get red then here i've got some particles that i've prepared previously so just go into the bullet projectile on the prefab and just assign the references and that's it okay let's test all right so here i am and as i zoom and i shoot and there goes the bolt and yep it hits the floor so you've got the red particles okay so far so good now if i aim towards the actual target aim and shoot and yep there you go now i've got that one alright so we are correctly identifying what target we're actually hitting so we can hit the wall or we can hit a target let's just speed up those bullets so hide the visual for debug since we can verify that one is correct and on the bonus make it move a bit faster so maybe 40. so we're here as i am and i shoot and yep there you go now i've got hit the target hit everything else and so on and yep everything works great alright awesome so we have the projectile goes towards the crosshair it hits something and it identifies what object it hit so that's the projectile method now let's see the hitscan method so for the hitscan method it's actually much simpler which is down here when we do the raycast okay we're grabbing the point which is the actual head position all right but then over here we also have the actual object so over here we can simply test if it is a valid target or not so we can just define a transform for the hit transform and default it to null and then over here we set it equals the raycast hit dot transform okay so we know the transform that we hit then down here when we shoot instead of having to instantiate something we don't do this for the hitscan weapon we just test if we hit something so if it is not null then over here we can add the same logic that we had on both so just this so if it is not known that means that we hit something and if so then we identified just like previously and that's pretty much it so here i am and as i am and i shoot and yep there you go it shoots instantly so i'm shooting here and i've got the red particles shoot down and have gotten nice and green alright so this is the raycast method as you can see there is no projectile as soon as you click the bullet is instantly fired and it instantly reaches the target so as you can see you've got both methods both of them are valid now there is one difference about both of them so here i'm using the bonnet projectile method and if i go towards the corner and i am just out there you would assume that i would hit that wall back there but if i aim and i shoot and yep i'm hitting the wall near me so not the one far away so i'm not actually hitting where i'm trying to hit so the issue is that of course the projectile is not being spawned right from the center of the screen so slightly offset whereas over here when using the hitscan method with this one even if i'm right on the corner yep it still hits the actual target now again this is really a design question some people see this as a feature others sees it as a bug so really it's up to you to decide what method works best for your game one more design question that you need to ask yourself is if you want to enable hipfire or not so you want to enable shooting like this and also while zoomed in or only while zoomed in again this is a design question and it really depends on what game you're going for and what you're trying to build okay so with all this we have the whole logic working we can move the character around in third person we can gauge a mode and we can shoot some bullets either as projectiles or as hit scan weapons now one final thing we need is just a basic animation so we're not actually shooting from the unknown position so for that over here the player is using an animator so here it is so this is the animator that it comes with so item won't run it's got the jump the in air and so on now the way we can handle aim is by using the super useful animated layers so you go up here you create a new layer let's call it aiming and creates a new layer and then down here i've got a pistol idle animation so i just grab this one from mixamo which is a free website with a bunch of free animations so i'm just going to set this animation and that's it now if you don't know about animation layers they are super useful here we have the layers and if we click on the gear icon we can see it has a weight so by setting this on zero it's playing just the base layer so it's currently on idle and as i move up if there you go now it starts playing the pistol idle animation so this is how we're going to do it we're going to dynamically swap between the normal walking and the aim animations we're going to dynamically do that as the player starts to aim now i cover n middle layers and tons of other things related to animation in my ultimate unity overview course so go ahead and get it if you want to learn more about animations and many other unity tools and features okay so here in the third person shooter controller we just need a reference to the animator okay and then down here when we're aiming we're going to modify something so let's go into the animator we're going to call set layer weight now this one takes a layer index we added it as the second layer so it's on index one and then the float for the weight so we could set this just on one f and when we stop aiming we set it back into zero f so we could do that and it would be instant but again like we did previously on the rotation let's use lerp to make it nice and smooth okay so we're just using meth.lerp in order to alert the layer weight from whatever it is up to one and then over here down to zero okay let's test all right so here i am it's looking normal with normal aim animation and as i right click if there you go we go into the aim animation so normal aim and so on all right so it looks pretty great alright so the character is working great we've got our normal character we can look around we can move around sprint jump and so on everything works then we can go into a mode and point anywhere and then we can shoot some bullets then those bones are projectiles and they identify exactly where they hit so i can walk around go here aim and shoot and there you go everything works great alright awesome by the way if you find the video helpful please hit the like button it's a tiny thing but it really does help thanks now over here is the final polished character that i made while researching this video so i've got the same third person controller i can move around i can run i can sprint i can stop then as you can see i'm using a custom character along with a really nice weapon and i'm playing around on this scene which is from the polygon battleground pack there's a link in the description if you want to get it and the animations are also from another pack that i picked up a while ago i can aim which causes the character to lift up the weapon and zoom in the camera so just like we did and of course i can then shoot so as you can see lots of tiny effects lots of polish to make the shooting feel really great so i can walk around i can run sprint and aim and start shooting at everything just like that so like i said in the beginning of this video one interesting thing was the research that i did in making this project now most of my unity expertise lies in making 2d games essentially all of my steam games are in 2d dealing with 3d characters and especially 3d animations is definitely not something that i'm used to so this specific demo has been a great learning experience for me i'm saying that just to once again remind you that your home life is a neverending learning journey for me i've been making games for 20 years and working with unity for almost 10 and yet this is the first time that i really dug into 3d animation so whenever you come across something that you know absolutely nothing about don't be discouraged it's unlikely you won't ever get to a point where you know everything so the goal is to always be learning new things and using that knowledge to make better games so to make online logic here is pretty much exactly what i covered in the rest of the video so it uses two virtual cameras and so on then for the animations themselves as you can see they also look pretty good so i made it pretty much exactly like the demo and just expand upon it so there's the animator i've got the base layer with i don't want run animations then on the second layer this one is only being affected to the upper body this one handles the aim and shoot animations this one only gets up to half weight so if i get into the game and i zoom in you can see yep that one goes up to one and that one only up to 0.5 so this one is just because the walking animation had a lot of up and down motion so when i zoom in in order to stabilize it a bit i put down at 0.5 so just stabilize the weapon quite a bit more then on top of that the other thing that i had to learn was how to work with the animation rigging package so it's super useful i'm definitely going to do a dedicated video on that sometime soon note how because of that the player is aiming perfectly wherever i am the mouse so the weapon perfectly matches exactly where i'm aiming so if i am right in there same thing there if i go in there it's pointing in there so this perfect aim perfect rotation perfect aiming that is handled by the animation rigging package so the base animation on the animator that one is just static it's just pointing forwards and then the animation breaking package that's the one that is making it so that it points exactly where the mouse is pointing then the next thing that i added was a muslim flash effect on the light so those are just some very basic effects essentially they get enabled for literally one frame and then disabled so just click enable disable just like that very simple and looks pretty great and then for the projectile itself a while ago i mentioned that you have two options you can go the raycast or the projectile route however in reality there is a third type you can make a hybrid between both of those which is exactly what i'm using here so first i'm doing the raycast to get the mouse position and then i've got this simple script which runs on the bot this one has a setup function where it receives the target position and then it simply moves this transform towards that target position so there's no physics on this object it just moves the transform towards the target position and when it gets there then destroys its own i went with this approach because i wanted the bullet to move really fast and the physics system gets a bit weird if you try to make some really fast projectiles so like this looks really good and it works perfectly and then as you can see i also added a trail for the visual so over here you can see the bolt is in there this is all the trail and for the trail it's just a very basic trail render and finally just for fun i added these boxes these props they've all got rigid body so they follow with gravity and then i also added some simple shooting logic so i get whatever collider i hit i try to get the component rigid body and if it does have a rigid body then simply add explosion force so with that i can name and if i shoot towards something with a rigid body there you go boom and i can shoot everything as you can see very simple and makes the scene feel much more alive with much more physics objects alright so with all that here is a really nice really capable third person shooter controller you can download the project files and use this as a base on your own projects and now that i have this really nice thirdperson shooter controller i will definitely be using it in many more videos so make sure you hit the bell icon to stay tuned for that again if you're looking for a more guided path with stepbystep lectures then check out my complete courses alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and i'll see you next time