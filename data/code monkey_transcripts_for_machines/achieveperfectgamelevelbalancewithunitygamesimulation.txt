in this video we're going to look at a practical use case for making perfect match 3 levels by using game simulation we're going to run hundreds of simulations on each level so this will let us ensure that our levels are perfectly balanced with the correct level of difficulty let's begin this video is sponsored by unity alright so in a previous video i already covered the basics for unity game simulation essentially this is a new unity feature that lets you automatically run your game in the cloud using certain parameters and one big benefit is that you can run multiple builds all at once so you can playtest your game hundreds of times in the cloud using tons of parameter combinations in a very very short amount of time go check out that video linked in the description to learn more and see a basic getting started tutorial here we're going to look at a practical use case for unity game simulation we're going to use game simulation in order to ensure that our levels have the perfect level of difficulty also quick note here unity is having a machine learning ai summit on december 10th it's a free one day event with presentations panel discussions and handson workshops all about spatial simulation play testing robotics ml agents and more all of it presented by experts and industry leaders so if you're interested in machine learning or ai check out the link in the description so over here i have a simple match 3 game i made it's the basic match 3 design so i can click and drag some gems in order to make matches and when three or more get matched they get cleared others fall down and more are spawned match 3 games are very popular since you can take this underlying logic and apply to just about anything so for example you can make some casual games where you match some candy or a more hardcore theme where you do matches to spawn more units in a strategy game or do matches to handle magic spells in a fantasy game or pretty much anything so this is a very versatile genre and what we're going to test here is applicable to all those scenarios the underlying base logic is pretty much all the same so over here we have the base game we do matches in order to clear the board now there are two types of goals one is to reach a certain amount of score in a certain number of moves and the other one is to destroy all the glass blocks again all in a certain number of moves both of those goal types have a limited number of moves which is where the difficulty comes in now like i said we're going to use game simulation in order to perfectly balance our levels so our game has a nice smooth difficulty curve and if you've seen the previous video introducing game simulation then you know one requirement is to have the game play itself so over here i have made a simple bot script that can automatically play the game so i just hit play and it starts automatically playing the game now naturally the quality or skill of your bot will have an impact on the results that you received but as long as the bot works you will get a good baseline value to bounce around so you just do this and if there you go the bot won automatically this bot is relatively simple so i'll just go through a quick overview of how it works here is the bot script which is relatively simple all it does is it listens to some events so for example on state changed so when the state is waiting for the user input then the bot tries to do a move then over here it goes into our main class in order to get all the possible moves so here this is the main class that handles the underlying game grid and here on this function we simply cycle through the home grid and we test swapping around each word position with one of its neighbors then simply go through all of those testing positions we try doing them we swap them we try to see if there's any match three links if so we add them to the possible moves list and in the end we return that list so this function essentially goes through the home grid and identifies all the possible moves and all the matches that doing those moves would result in then over here the bot simply grabs that list of possible moves and then simply passes that list onto a function to identify the best possible move so then depending on the score it does one of two things so if the goal type is score then it simply looks for the one with the most match amounts and if the goal type is glass and symbol looks for the one that destroys the most amount of glass so as you can see it's a pretty simple pretty straightforward bot you could definitely improve upon this to make it smarter but like i said as long as it works then we have a nice baseline value in order to bounce around then the levels are all manually designed and stored in a scriptable object so i can play which one i want so for example this level will always start off exactly with the state so if i stop playing and i try to hit play again and yep there you go with load the exact same level i also made a simple level editor where i can just easily manually modify each of these great positions so here with all of these levels what we want is to test the difficulty of them now using the traditional approach what i would do would be start playing the game so here i am i have a certain total number of moves i have a certain score that i want to hit so i would simply start playing so make this move there you go it does that does that now i make another move another match and so on and i get some score so i do it until i win or lose the game and then i analyze on the 11 parameters and decide if i should make this level more difficult or easier so as you can see that would be a very minimal process that would take ages especially since match 3 games usually have tons of levels so that's where game simulation comes in we want to use game simulation to very quickly test the difficulty of all of our levels alright so let's implement it so here i already have the game simulation package installed and i can simply go into window game simulation all right now the first thing i need to make these services so let's make that all right so here's the window funny working let's just talk it down here and see now i already covered a very detailed getting started guide in the previous video so in there i covered in detail step by step how everything works so how to install the package use the api and the dashboard and so on so go watch that one if you haven't seen it yet here i will assume that you know the absolute basics alright so with this let's go into the code now the code for this game is set up in a really nice and really organized way so the main match three script has all these nice events which makes it very easy to interact with so we're going to make a script to hook onto these events in order to handle game simulation so let's start off by creating a new csharp script name this is the match 3 game simulation now let's make a game object give it the same name and attach the script onto it okay now open and now in here first off let's add our using statement so using unity.simulation.games then the first thing we need to do is fetch our parameters so let's make a private void awake and then awake go into the game sim manager access the static instance and call fetchconfig alright we are fetching our configuration again go watch the other video if you don't know what this is doing but essentially it's downloading all the parameters so let's go back into the editor and here on the game simulation window let's simply add a parameter let's name this our level and for this one let's make it of type string and for default value let's use level underscore a so i'm using this default value which matches up over here on the project there you go here you can see the various levels stored as scriptable objects so this is the name that we're going to use and it has to match exactly this perfectly so by default we're going to play on level a all right so that's the parameters again don't forget to click on save in order to save the changes okay everything is good now back here on our script let's go into the game sim config response in order to get a string with the key in level and this will return the string for our level name then we just need to grab the scriptable object that refers to this level name so let's add them up here all right so just a list of the level scriptable objects make it serializable so let's see it in the editor and here i've got the 11 list so let's just lock the inspector and drag all the levels on there all right these are all the levels and now here just cycle through it all right so we cycle through the list we find the one that matches the name of our parameter and then we simply have that level then let's also add a simple test to select the default level in case we cannot find it so just keep things safe in case we accidentally give it a bad value all right so far so good now let's add a reference to our match 3 script okay we have this and then in there there's a function in order to load and level so just call it and pass in this load level all right so just like this we should be unloading the correct level for testing so right now we should be loading the default level so yep right away we are unloading level a so here in the console we can see yep config fetch level level all right it worked and just make sure that it is working let's change this to level b hit save and yep now it loaded in level b all right so the logic for unloading the level based on parameter is on fully working now back in our game sim script let's listen to the events from the main class so we know when the bot either wins or loses so here just go into match 3 and subscribe to the on win event and on out of moves which is when the bot loses all right here we have both of our events so here we have our win and now in order to save the simulation result we set the counter so we go into the game sim manager access the static instance and we're going to use set counter in order to set a certain counter now over here essentially we have three ways of testing how difficult a level is so one approach we can give the bot a target score and unlimited moves and we test how many moves it takes to reach that score or we can give it a limited number of moves and see how much score it gets or we can set both a target score and unlimited number of moves and see how many times the bot wins and how many times it loses so essentially all of those approaches are valid now in this case since we're running the simulation for the very first time i think it makes sense to set a goal and give it unlimited moves to test how many it takes to win the level then after we do that simulation we can then do a second one with unlimited number of moves and see how many bots win and how many lose so here let's simply save how many moves it won and let's also save the level name so let's store here a reference to the level scriptable object and then here when we set on level let's set this one to this load level okay so here we have the level that we're running so just do this use the name then a underscore let's say when moves used and then for the value that we want to store so let's go into the match 3 and in there i have a function to get the used move count so this way when the bot wins we're going to save how many moves the bot took in order to win that level so this one will work for both of our goal types now here in the level just make sure that all of the levels have enough moves in order for the bot to win so all of them are set to 100 so that's good that should be more than enough and then on the lose event let's also save and we're going to save the level name then lose and then here we don't really need to store any value but unless you store one so we can easily count how many times the bot lost all right so with this we have everything all set up now that's left is making sure that the bot stops playing after it either wins or loses so let's go down here in order to make a function let's call it end game simulation and in here we simply call application.quit but again we don't want to quit if we're working in the editors let's add a if unity editor if we're in the editor then go into the editor application and simply set is playing into false all right this is our function to end the simulation and up here we simply set the counter and end the simulation set the counter and end all right so everything is set up so we start off by fetching the config once that happens in here we get the parameters so in this case we just have the level so we get it then we unload the level that matches that parameter then the bot does its thing it plays through the level and it either wins or loses and depending on that then we save the result of our simulation all right so all logic is working now it's test again just look at the console so here it is the level load zbot is playing automatically and here is the console you can see we fetch the config then let's see if the bot wins or loses and there you go the bot one we have our game over we wrote our counters and we quit the application all right so everything went perfectly now go into the game simulation window and in here go into build upload let's include our one scene and then give it a name and simply click on build and upload all right here in the console we can see that it was built and uploaded so now we just click on create simulation okay here we are create a simulation first of all give it a name so like first test with unlimited moves then we select our build okay and over here we have our level parameter so we've got our default value level a then let's try with all of them so just put all of them all right all the levels then down here for the number of runs per combination so in this case let's go with something like 100 times on each level now again the whole point behind the indie game simulation is to run the cloud in parallel so in a more proper game we could go increases tenfold to a thousand runs per combination and it would not take 10 times longer so eventually when your game would be close to complete you could put a massive number in here in order to ensure that everything works perfectly fine but in our case for a first test let's go a little bit lower just 100 runs then for the max runtime per run now each level probably takes under a minute but just in case let's put two alright everything is set up we are going to test all of our levels we're going to test 100 times on each level and everything's going to run alright so just hit on run okay now the simulation has been queued so all we need to do is wait for it to complete all right so here i am a bit later and as you can see the simulation has completed and right away you can see just how awesome game simulation is so it has only been about 30 minutes but in reality it ran through 1700 minutes of simulation so you can see just how insanely efficient this is now right away we have our reports so we can download them so the main one we want right now is the aggregate data all right here it is and right away we can see all of our results so we can see we ran a hundred instances of each simulation type over here we can see the settings so this one level a b c d and e and we use counters in order to track how many moves were used in order to complete the level so over here we can see the average maximum minimum the standard deviation the sum and the number of instances so for example right away we can see that on level a it only took one move to win so right away we can see that level a is way too easy then on level b we took six move to win then level c 7 then 19 and then 24. so now with this data we can analyze this and figure out what we do in regards to our level so for example level a is way too easy and here we can see on level a that only takes is the bot doing just one move and right away it triggers a ton of things so it automatically hits the target so in our case let's modify the target on level and let's put it at let's say 10 000 and then for the number of moves let's say 10 moves so here playing manually let's do that move and yep with just one move already got tons of scores to just do another move and so on and everything works all right so here we have level a which is very easy exactly as it's supposed to be and by the way if you find the video helpful consider subscribing and hitting the like button it really helps out the channel then on our level b took on average six moves so the level b is a glass level and six moves sounds about right so again this one is meant to be relatively easy so if the bot can do it in six moves then let's make the move amount about 10. then on level c it took seven moves so here this one is meant to be a bit harder so for the movement let's set it to about 12. then on level d it took 20 moves so that's possibly a bit too much of a difficulty increase again the goal is to reach a nice balanced smooth difficulty curve so i can modify the number of moves or i can edit the level in order to modify just how many nodes are in case in class in order to make it easier or harder or i can also modify the various gem types that are used on each place so as you can see game simulation gives you all the data and then it's up to you to decide what to do about it and then finally on level e which is the toughest one so it makes sense that it took an average of 24 moves with a maximum of 30 moves and a minimum of 11 moves all right so we used all the data in order to balance our levels and if we want we can manually go through them in order to ensure that it looks very nice all right so with this many moves stone level is indeed perfectly balanced with the exactly the level of difficulty that i was going for okay so with this we have perfectly balanced some of our levels now the difficulty curve for our game is looking quite great however now let's say we continue working on our game and we want to add a new feature so let's say we want to add a power up that destroys various blocks instantly so i have in point that when there's a four link match one of the gems will explode and take down all the gems around it so as i move this one if there you go all of those were destroyed so as you can see adding that feature does cause a significant change in our level so adding the feature is relatively simple but then comes the question of exactly what does that new feature does to all of our perfectly balanced levels so this is where we see the real power of game simulation we already added that feature and now we don't even need to touch the simulation code at all we just need to go back into our game simulation window and make a new build to upload with our changes all right the new build has been uploaded and back in the game simulation dashboard over here we have a button where we can easily clone a previous simulation so here we have of our level parameters all of them running a hundred times once more so just over here pick a new build so it's that one give it a different name and just run the simulation all right there it is running now once again we wait and now the second simulation has completed so let's analyze our results here is the new aggregate results compared with the previous ones and we can see that by adding the new exploiting gem we did indeed modify how the levels play so we can see in level a after our changes and after adding new feature now it takes four moves to actually win then level b takes around six moves level c around five level d around ten and level e around fifteen and at the same time we also added the unlimited number of moves to the level so the bot actually lost a few times so over here on level b the bot actually lost eight out of the 100 times and then on level d i lost 14 out of 100. so once again now we have all this data and we can use it to rebalance our game and just like that we add the new feature and easily balance the game in just a few minutes now just imagine this apply to a real game with hundreds of levels and dozens of special moves and you can see just how insanely useful game simulation is at the push of a button you can run hundreds or even thousands of simulations and ensure your game is always perfectly balanced alright so i hope you like this practical use case of the benefits of unity game simulation the package is in active development so unity is looking for all the feedback they can get try it out for yourself and if you have any issues go into the forums or email the team directly this is a really fascinating feature that can be a huge help to both small indie developers as well as large studios alright so thanks for watching if you found this video helpful consider liking and subscribing and i'll see you next time