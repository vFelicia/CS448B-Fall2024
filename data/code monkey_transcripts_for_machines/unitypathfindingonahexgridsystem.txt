hello and welcome I'm your code monkey and here let's take the grid pathfinding that I made previously and apply it to a hex grid honestly I was wondering whether I should make this video or not because it literally is a super simple change but I decided to make the video anyway so that it shows up in search results and helps anyone who is looking for specifically hex based pathfinding if you want the 10 second answer here it is you just change the pathfinding grind to use the new hex grid then you change which neighbors are tested and that's it that's all it takes now in preparation for this topic I already made two related videos one covering how to test if a point is inside a hex now that one isn't really necessary when it comes to hex words but still very useful to know how to do that and a second video on making a hex written in there I take the regular square grid system that I've used in so many videos on the channel I take that grid system and convert it to support hexes to be able to tell which one position equals a certain hex word position then of course I also covered pathfinding in data on another video again that one is also based on the same square chord system so here let's see how easy it is to swap pathfinding from a square grid to a hex grid over here I have my demo scene I have exactly the same Pathfinder that I made in that other video the only difference is I change the grid to work in the XZ axis instead of X Y I did that just to be able to have a bit more fun in a 3D scene but everything else is exactly the same as it was built in that video so I have my simple unit and I have my Square grid and I can click anywhere to tell the end to move and the unit calculates the pathfinding to get it to that position so I click there it goes there it goes there and so on now with a right click I can also make a certain position walkable so let's make all these unlockable now if I click here and if there go simple pathfinding avoiding the unwalkable areas okay so that's the basic demo with only working pathfinding on a square grid now let's swap it out for a hex grid so here is the pathfinding script that we made in that previous video again the only change I did was just swap the grid to work with XZ instead of X Y so let's duplicate this script we don't want to destroy this on their pathfinding square roots are still insanely useful so we're here on let's just duplicate this and call this the pathfinding hex XZ over here let's change the name so hex XZ and then all of these references change them so just this one and this one now swapping out the grid so let's use the grid hex XZ that we created in the previous video so just replace all these references so just find them all this one this one this one and that's it no more references now doing this requires changing over here the path node as well so let's also deploy it down so over here on the path node let's duplicate it and again just call it hex and here change all of these so the hex XZ so replace all of these references okay and for the grin this one is great hex Zen so just replace this one and this one all right that's it so now back into the pathfinding hex xn and over here instead of using this path node let's use the path node hex XZ so we just need to make sure to change all of these references so change all of them one by one just find this one find this one over here change change this one this one this one and these and a bunch more down here so change all of them and finally these ones all right great so we have no more errors here and we have swapped it to use pathfinding hex xn using the grid hex and the path node hex and here in the editor yep the scripts are compiling so everything is working correctly now let's do some quick testing over here we have a game object with a testing script and here just have a prefab reference for the square the hex and the unwalkable then on away simply instantiate the grid hex end second through it to spawn all of the original transforms and create the pathfinding and then on update and listen to a mouse click then tell the unit where to go and on right click make the position unlockable so let's swap this out for a hex grid so let's go up here instead of using the grid xn the green hex and the pathfinding swap route for the pathfinding hex let's also rename this so hex by the way the shortcut over here is control RR that's the rename shortcut which remains all of the references so rename all of those and down here the grid hex xn which is also used here and the pathfinding hex XZ okay that's it no more errors and just over here we're instantiating instead of instantiating the square let's instantiate the hex okay so we should be able to see our hex grid let's see and up here we do see our hexary okay so far so good now let's do a quick test to visualize the pathfinding so let's go to where we are getting a mouse click over here let's go into pathfinding hex X end and let's go on the function to find the PATH this takes a start form position so let's use Vector 3.0 and for the end let's use the mouse worm position okay so we do this and this returns a list of vector three so this is our path list and then let's just cycle through it and let's just do a debug.rawline on these positions so let's go into the path list on this index and let's go until the path list on the next index and just up here and let's make sure we only cycle until the path count minus one and finally color dot green and let's show this for just three seconds it's not a log but actually a draw line okay all right so we should be able to click somewhere and see a bunch of lines going from zero zero onto the mouse position let's see so here we are in Game View and now since we use debug.tronline that means we need to enable gizmos to see it so we're here on game view let's go up to the top right corner and click on gizmos to enable them and now if I click somewhere let's say I click in here and if there go it does show the path so going to path in there going to pattern there and so on okay great so we can currently see the path being calculated except of course it's not really working so the path is going through weird places so this one going in there is going through there and that is not a valent position so going in there should either go through there or through there okay so the reason why the path isn't working is because the last thing we need to change is the algorithm itself and again the only change needed is really just getting the neighbors again make sure you watch the pathfinding video if you want a quick refresh here on how the ASR pathfinding algorithm Works basically over here on the find path function we have a open list and a closed list then we second through all the nodes on the open list we check if it's a final one if not then we continue we remove that one from the open list we test all of its neighbors and so on so all we need to do is modify over here this function which Returns the neighbors of a certain node and here for the Neighbors we have the neighbors on a regular square we're in so we've got left left down left up right right down right up and so on so for example here's a diagram of a square grid so let's say we are testing this position and we're going to look for Neighbors so we're going to look on the right we're going to look on the left we're going to look up and also going to look down and then obviously on the corners so the upper left the upper right down right and down left so any Square grid we have one two three four five six seven eight neighbors whereas over here on a hex grid if we're testing out this node then the neighbors are going to be the one right the one on the left and then we're going to have one that is straight above so this one is position two two so two three is going to be straight above and T1 is going to be straight below and in this case we're also going to need to test this one and this one so in a hex grid we only have these two these two and these two so only six and not eight neighbors however the other thing which I also mentioned in the hex grade video is that the neighbors depend on whether you are working on an even row or an odd row so here on this on row you can see the ones above you see the ones with X plus zero so on the exact same X just above and you test for the ones with x minus one so that's what you do on an even row however on an odd row like for example this one if we were to test the x minus 1 we would end up testing this one above that is not the one we want we want to test this one which is X plus zero and this one which is the X plus one so we need to be extremely careful here just like we were very careful with the hex grid video so here on the get neighbor analyst function let's first test if we are in an odd row so bull for the odd row and we just grab the current node and grab the Y which is actually the Z since we're working on the X Z case but sure so we take that one then we do a module of Two And if it is one then we have an odd row if not we have an even row and then instead of all these neighbors we just asked for different ones so we've got the ones that are the same regardless of being on an odd row or an even row so you've got the x minus one so the one the left one on the right the one down and the one up and then the only difference over here if we are odd or an even row if we are in an odd row then we want to get the ones with an X plus one and if we are on an even row then we want the x minus one okay so with this all of the neighbors should be correct again make sure you don't make any mistakes here if you test the wrong neighbors then the algorithm won't work and finally there's just one more minor change which is down here when we are calculating the distance cost for a square grid we've got the difference between diagonal costs and strict costs that is because mathematically moving over here going straight to the right that is a shorter distance and going from here to here on diagonal however on a hex read we don't have that issue all of those those are all straight movements so over here we can simplify this or really just make straight costs all the way so it's never a diagonal cost however there is still one last sneaky issue here like this it's not exactly 100 correct because of the offset between the odd and even rows so over here the way we were getting our diagonal moves is the minimum between the X and the Y distance and then the straight moves are simply the remaining ones so going from 0 0 to 1 1 the minimum between those two that would be indeed one so this would be one diagonal move and then the remaining one minus one is zero so there would be Zero moves so that makes sense in a square grid going from here from zero zero to one one that is indeed just one diagonal move but if we go back here onto the hex diagram on this one if we are going from zero zero to one one then with that logic we have just one move whereas in reality over here we have two we cannot go straight like this in order to go there we need to go here and here so using the exact same cost logic that would not be correct now this is actually something that took me tons of time to figure it out and I'm still not entirely sure how to correctly calculate a Manhattan distance on a hex grid so for example getting the distance from zero zero over here to three three how do I get one two two three four and five I tried tons of approaches but there was only something wrong it needs to take into account the direction so going left and right the number of odd or even rows in between the start and the end and so on so I tried lots of things and it didn't quite work but then I realized that it's also not really necessary I don't need to know that from here to here is a certain number of moves the distance is really only used for a heuristic which is really just a guess so in order to get that guess the simple way to do is just test the actual warm distance since we already have a super easy way of converting a grid position onto a warm position so we're here when calculating the distance cost instead of this we can just use something super simple so we do effector 3 dot distance let's go into the grid system then on the grid we get the worm position get the wrong position from this starting point so a DOT X and a DOT y then call it the distance towards the B position with this we have distance so let's just multiply it by the move straight cost and since this expectation and let's just do a math F dot round to end so on all of this all right so that's it this will indeed give us a very rough distance which is all we need for the algorithm to work so let's rename this to give it a proper name so it's not the direct distance cause instead it's just a rough guess so let's rename this and let's call it the complete heuristic distance cost then I'll let you see where we're using this function and if we go up here onto the algorithm we do see that we're using it to set the H cost of going from this node onto the end node so that is correct the H cost is the heuristic cost in the algorithm but we're also using it over here for the G cost but the G cost is not meant to be heuristic it's meant to be the actual cost so this one that we use over here this one must be correct and this one is always going to be a straight move it's always a street move from the current node to the neighbor node so over here we can just put the move straight cost and just use this directly all right so that's it again the heuristic in the algorithm this is just a rough guess so that is why we don't necessarily need an extremely accurate heuristic like we did for the Manhattan distance on the Square grid system with this very rough very simple heuristic our algorithm should still be working perfectly so let's finally test so here we are and if I click over here and yup it does take the exact correct hex path I can click anywhere I want and yep it always goes straight through the hexes and never in between all dashes alright awesome now let's verify that it is indeed working by making some nodes unlockable again here in my testing script I already have that logic so I'm testing for the right Mouse button if so then I get the grid object on the mouse run position and I set it as unlockable then I also get the one position where I clicked and I instantiate the unwalkable prefab so over here I can right click let's make these positions unlockable so we're going to start from there and let's say go in there and if there go it does go over there so I can now make whatever path I want and yep there you go it always finds a path so finally here it is applied to a character so I can right click to make any notes unlockable then I can click and yep there you go the character does find the PATH and goes straight through the target position so I can go anywhere do anything and yep the character always finds a path throughout my hex grid alright great here is how the character is set up this is based on the modular character system that I covered in another video it just has this component move position hex pathfinding then this function over here receives a Target move position and an action when it reaches that position then just goes into the pathfinding columns find the PATH and gets the path Factor on list and then on update simply goes from position to position so here it is on a bigger more complex math and yep everything works I can click anywhere and the character finds a path and goes straight towards there alright awesome okay so that's it as you can see it's pretty simple to convert from grid based pathfinding into hex based pathfinding really just a few tiny changes and everything already works perfectly the algorithm is really all the same the only difference is just the neighbors now like you mentioned in the hexade video the reason why I've been researching hexes is because it's the most requests topic on my turnbased strategy course so now that I've done my research I'm currently working on writing all the lectures making a free update covering the complete conversion process if you haven't picked up the course yet then definitely give it a look I worked really hard on making it an excellent course specifically to help guide you and take your skills from beginner to Advanced so if you are interested in turnbased strategy games or really you just want to improve your programming and Game Dev skills while learning how to write good clean code then check it out and if you already have it then this hex grid update will be a completely free expansion to the course hopefully within the next few weeks alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and I'll see you next time foreign