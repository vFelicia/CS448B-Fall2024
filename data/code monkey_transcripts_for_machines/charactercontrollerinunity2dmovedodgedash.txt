this video is sponsored by hosting er in this video we're going to make a nice character controller in unity 2d it will be using physics so we automatically collided with walls and can push around objects we're also going to implement an instant and a smiling row let's begin hello and welcome I'm your code monkey and this channel is all about helping you will learn how to make your own games with indepth tutorials made by a professional indie game developer so if you find the video helpful consider subscribing okay so I've already done some videos covering simple character movement however in those videos I covered it in the simplest way possible so that means no physics at all the character just moves by directly moving the transform in order to find objects and collide with it it does a raycast so that's a great and simple way to move character but it has some limitations for example you cannot easily push objects around and interact naturally with other physics objects so here we're going to make our character controller using physics all right over here is our goal there's our player character right here and as you can see there's a bunch of debris on four and if I go towards it and there you go I can push it around down here we also have an object simulating a door with a hinge and if I go and there you go I can push and open it so as you can see we have some nice physics interactions since we're using a rigidbody to move our player we also have ones easily working so over here there's this wall and if there you go I cannot go through it because the solid object now here we're also going to implement two nice movement features so for example we have an instant so just like this we can dash into any direction and yep there you go the dash does not go through walls and for another different movement type we have a Dodge Ram which instead of being instant it simply slides on a certain direction so I can go and slide it around and once again it's all working with physics so I cannot go to the walls but I can interact with other objects all right so here is our character controller working nicely which we can easily use as the base for any 2d game you can expand upon the space to make some really cool abilities unique to your game sure what you make with your friends by hosting the builds on your website which you can get through hosting ur hosting ur provides bestinclass hosting services that are extremely fast and very affordable with excellent customer support to help you succeed choose from a variety of plans and pick the one that best suits your needs making your website from scratch can be hard but hosting er makes this much easier by supporting WordPress which is a few clicks you can use the auto installer to get WordPress installed on your website then you can pick from a giant selection of weights too quickly at start and then customize a website to exactly as you want it here for example I have easily built a simple website by customizing a template when excellent WordPress feature is how you have these buttons to swap between desktop table and phone these points so you can rest assure that your website will look great on any device also if you're making some really cool online integration for your game then check out their super fast and affordable cloud hosting solutions all the plans come with a 30day moneyback guarantee so you can try out the services without any risk go to hostgator.com slash code monkey and use the coupon code monkey to get up to 91 percent off yearly web hosting plans click the link in the description and succeed faster using the link help support the channel so thank you to hosting ur and also thank you to these awesome supporters for making this video possible go to patreon.com/scishow to code monkey to get some perks and help keep the videos free for everyone alright so this is our goal let's get to it okay so here we are in our starting scene all I have is my character sitting around I don't doing nothing so I'm pressing keys and I cannot move them or do anything okay so let's begin by making our character control so we make a new csharp script call it our character controller 2d and now over here I have the player game object as you can see inside it as you say basic to the enlight a sprite for the shadow and a object for the body the body is composed of a mesh filter and a mesh renderer so the animation system that I'm using is based on dynamically modifying meshes in runtime so check the video in the description to see how it works so this is the composition of the character and then here I simply have the character B script which handles all the animations so in here let's drag our new only created script okay there it is and let's open it up okay now in here and let's start off by making our update function and in here we're going to listen to key inputs we're going to control our character using W a s and D so if we have an input gate key and here we want it key and not get key down since we want this to be true for as long as the key is held down so we use get key and then we choose let's say W so if you press the W key we want to move them up and now just for starters let's do it with the easiest way possible without any physics so we just move the transform that position was equals a vector up so zero one just like that alright so as we were holding down the W key we're going to move the transform up let's see so here we are now press W and there you go he's moving it alright so far so good now let's handle on the other directions alright so I've copy/paste the same code for own directions and if we test here we are and moved up yep there you go move down move right and move up all right awesome so here we have movement in all directions awesome now so far we're still working with moving the transform directly meaning we are not working with physics so back in the editor if we try to make a wall down here I have a simple wall sprite so just drag it in there so here is a basic one sprite and now in order to have physics let's add a box Collider 2d and there you go we have the collider and now if we test and here we are and there's the character moving and it can go through walls alright so now let's implement physics on our character now the first thing we need is to have a Collider so here on the character we select and we add a Collider and now in here we have a whole bunch of options whatever type you choose depends on your game so for example if you want to have smooth corners you can go with either the circle Collider or the capsule Collider but personally I prefer to work with rectangles so let's add a simple box Collider 2d so there it is you can see the collider and now we can edit in order to modify the size and pretty much just like that now my animation system only runs when the game is running so here all we can see is a shadow but I can still guess the size the character and if we test and there it is with the game running you can see that the box just pretty much fits deep sprite the sprite is built in a front topdown perspective so rather than occupying the whole character I'm only occupying the bottom part alright so here we have our character working with a Collider but if we move yep there you go we can still go through the wall in order to get collisions to work we need to add a rigidbody if you want to know more about collisions check out the video linked in the description okay now here on the character let's add a rigidbody 2d and here in these settings and let's freeze the rotation since we don't want our sprite to rotate and since we're working on top down let's also disable gravity by setting the scale to zero alright so this is our setup now back in our code and here the first thing that we need is a reference to our rigidbody so let's grab it on our way all right we have our rigidbody reference you know here we have our update function which gets called on every frame and we're testing for when the keys are down so now you could assume that we would simply change the rigidbody for it transform however when working with physics the physics system is running at a different rate than our actual update so instead of the update we should work with our physics inside of our fixed update so it's in here that we should modify our rigidbody however we still want our inputs to be nice and snappy so we want to grab them in the normal update every frame so the solution is to capture our inputs here sort them in a vector and then use the vector down here so all the way up here let's make a private vector3 for the move direction and now here on update let's set our move vector so first let's define a float for the move X start off at zero then you float for the move Y start off at zero then we set them in here all right so we define a move X and a move Y and then we handle the keys so for example if we're holding down dummy we said to move Y to one and then down here we construct our vector based on the move X and move Y and now here we need to remember to normalize our vector so we make sure that we don't go too fast whilst going in the diagonals all right so we have our move direction and then down here on our fixed update this is where we can modify our rigidbody now there are two ways we can modify the region one we can use move positions this function will move our rigidbody from the current position onto the target position however this can lead to some jittery movement if we try to move to an invalid position like say inside of a wall so the other approach that I prefer to take which is setting the velocity directly so we just set the velocity to be the direction so this way we don't tell the rigid body specifically where to move to branches in what direction it should move and then the physics system decides if it can move in their direction all right here's our rigid body setup know what's test alright so here we are and let's try to move and yep there you go it's moving insanely slow but yep it is moving the rigid body and if we move up and see what happens when we collide with the wall and keep going up keep going keep going any of there you go as you can see it reached the wall I'm some pressing W but it's no longer going through the wall so just like this we have collisions working automatically awesome now as you might have noticed the character is moving painfully slow so let's fix up here in our script let's define a nice constant for our movement speed all right we have our move speed constant and then down here when we set the velocity we set it to the move Direction multiplied by our move speed okay let's test here we are in try to move and you've there you go now we have a much more accurate speed so if I go yep there you go I cannot go through the wall no matter what I do all right awesome now one thing that you might also notice is that the movement is actually quite jittery so look at that it's very very bad so let's fix that here in the editor we can see our rigidbody and then here we have the interpolate so it's in here that we can set from none into interpolate and if we run again and here we move and there we go now the movement is actually perfectly smooth so everything is being interpolated between each physics friend alright awesome now that we have the movement working let's add some animations again this step won't depend heavily on whatever animation system you're using but as always remember to write clean code so make sure your classes are as a couple as they can be here in my case the animations are on hand on inside of this character based class and I don't care how the animations are implemented all i care is that this class exposes some functions that I can use to play the various animations so first I grab that component that handles the animation so it's a character base I get that component here on awake and now when we set the move direction I can call the function play move animation which takes the movement directly all right that's it let's test so here we are in his idle and I move any of there you go now we have our nice animations working again this is going to depend on what animation system you're using but the main point is remember to keep your code nice and clean so in here I don't care how the animation is implemented as long as I have a nice function that I can pass in a move direction so whatever this function does I'm not interested whilst working on the character control and this animation system is based upon dynamically modifying meshes in runtime so here in the scene you can see that the animation system is made up of dynamically modifying the meshes I covered the bases for this system in another video so check the link in the description if you want to know more and with this we now have a nice character moving around alright so we have our basic character control working now again since we're working with physics let's play around at some debris so over here I have some prefabs with a bunch of rocks as you can see they just have a different sprite and a box Collider and a rigidbody so here they are a whole bunch of rocks and now if I test so here we are and I can move the character and I can go and yep there you go I can push around all of the rocks again this is because we are using the physics system directly to move our character so we don't need to do anything else in order to make it interact with other physics objects over here I also have a simple door object so really just has a hinge and then another object and again if we test here we are and if we go and try to move yep there you go I can push that object without doing anything else right awesome so here you can see our character and everything working correctly with physics now that we have the simple movement working let's add some more features to our character control first let's add a simple R is going to be essentially an instant teleport but without going through walls so back in our code in our update lets s for pressing the spacebar and here we are using gate key down since we only want this to be true on the exact frame that we press the spacebar and again on the update we are only handling recording our inputs and then on fixedupdate we actually move our rigidbody so let's go all the way up here to store a simple boolean what's called is that button down and now down here if we have the gate key down on the space let me simply step tower is button down true and then on the fixedupdate if the button is down then here we want to move our rigidbody so in this case instead of modifying the velocity we're going to use the move position function so this will move the rigidbody towards the target position so our target position won't be based on the transformed graph position which is our current position plus the move direction and then multiply it by a certain amount so in here a food for amount and then we use it in here all right so just like this we are teleporting our object instantly towards this new position and after we we set is but down back into the false all right so just like this we are instantly moving our rigidbody on to this new position let's test ok here we are and let's move in press space and if there you go we have our instant teleport working perfectly so we press space and instantly teleport quite a bit ahead all right so here's our however we have an issue since we're setting the move position directly there you go we can now go through walls without actually colliding with them so let's fix that so let's do a simple ray cast to validate our target position so here we have our recast we do recast from our transform position towards the move direction by this mount if it collides with something we modify point to be the exact point where the collision happened however if we just run like this and now here we aren't trying to move and yet there we go he's not actually dashing because he's colliding with the actual player hitbox so we need to use a layer mask to define what we're going to hit for example here on the wound let's modify the in layer and put it on the wrong layer and let's also make a objects layer so for the wall we set it on the walls layer and down here on the hinge object let's put this on the objects layer all right so we have everything on different layers and now here we can pass in a layer mask into our recast and the layer mask is a bit mask if you're not familiar with bit masks then check the on links in the description one way we can easily set this is to go up here and we're going to add a civilised field for a and layer mask and this layer mask actually shows in the editor so if we go back and you up here in the editor we can see a very nice drop down menu for our layer masks and in this case we want to collide with drones and with objects so it's not like both of them and now down here we can use our layer mask alright so let's see now so here we are in to the right and yet there you go we have our and we can through our rocks however if we try to through a wall and there you go it doesn't work alright awesome so now our actually works correctly and it does not go through sound like objects alright awesome now over here I also prepared a very simple effect so it just has a sprite animator you going through a bunch of sprites and then it destroys itself and I can spawn it using this basic static function so just to add a nice visual let's use this so in here when we do then let's call that function alright there it is just like this and test ok here we are on and there you go we have our nice effect and everything is working correctly all right awesome ok now for another move type let's add a nice dodge roll so instead of being an instant teleport this is going to be a constant movement in one direction and now here in order to add that feature we need to make a decision regarding how we were going to structure our code so should the Dodger won't be implemented inside of this character controlling class or she didn't make it as something separate so that's going to depend on what type of game you're making and how you're stretching your code here in this case I'm going to duplicate this class so back in the editor we just duplicate this script and let's call it the simple version and now let's add the Dodge wrong implement inside this so I'm going to call it both of these in the project files so you can use whatever best fits your game okay no in order to do our dodge roll it's actually quite simple we're going to use the velocity film very much like we do when normal movement okay so in here let's put the dash on a different key and let's put it on that and then let's do a get me down on our tiptoes piece all right so when we press space we want to start our dad row now the first thing we need is the store where we actually want to run towards so let's go up here to make another vector3 for our wrong direction and now down here when we press space we set the wrong direction to be our same move direction okay there it is and now the question is how do we actually move towards our wrong direction as you might guess we cannot simultaneously have normal movement working on so I do it the wrong direction so for that let's make a simple state machine so here we define a private inneun call it our state and state will either be normal or wrong so then we store it in here and on awake we start off as normal and then on our update we do a switch on our state and we only run this normal tone case we are State not normal and when we are rolling we simply ignore the inputs okay so far so good and on the fix update we do this on switch on our state if we are normal then we do the same thing that we were doing previously and if not if we are rolling then it's in here that we want to modify our rigidbody policy all right so here it is very simple just using a basic state machine now so far everything is following pretty much the same logic as the normal movement now the difference is that the raw speed is automatic and it should slow down so let's also store that so all the way appear let's also store a float for the wrong speed and on our fixed update we're going to move by the wrong direction multiply it by the current row speed and on the update once we are rolling let's reduce the iran speed all right so here we have it on the effects update when we move the rigidbody we move it using the wrong direction and Iran speed and then in here once we are on the rolling state we're simply reducing the row speed based on a certain multiplier and always lowering it by time.deltatime and if we go under a certain minimum we simply reset the state back to normal so the last thing that we need is to set our starting wrong speed so in here when we set the move direction we set the wrong speed to the starting speed so I'd say this then we also set the state into state wrong all right so here is our wrong speed code know it's test okay here we are and we can still move we can still push everything's great and if I press space and there you go we have a nice run speed so as you can see it goes fast then slows down and after a while there you go it goes back into the normal state alright so here we have our dodge roll working great awesome now let's just add the animation so here when we start rolling let's once again go into the character base in order to play the role animation again how this is implemented does not matter for the character control all i care is that I have this function so I press in the wrong direction and then we test okay so here we are in our press space and there you go we have our nice roll animation and now it looks like an actual proper role and if you press F we still have the instant on board so instant teleport and a nice rolling movement alright awesome now finally let's just fix one issue so right now if I'm not moving at all and I press the wrong button and there you go nothing happens if there's an actually moved anywhere and the same thing if I press and there you go nothing happens he is rolling but he's not rolling anywhere because he's taking the wrong direction as a vector zero so here when we have our update and we calculate our move Direction vector if both these are zero then we're going to have a wrong direction as a vector 3 0 so how we solve this is to make sure that when we roll or we do it towards the end last move direction so let's define that up here so we have the last move direction and then here when we set the move direction if we move X is not 0 or we move Y is not Z then we are not I don't so here we can set the move direction to the book direction okay so we have the last move direction and then down here when we set the wrong direction instead of using the move Direction let's use the last move direction same thing down here on the space when we have our instead of using the move direction let's use this last move direction all right well let's test ok here we are and I can still move I can still wrong normally normally and now if I go and I stop and now I press here on button and there you go now he rolls down to the other last move direction and same thing for the space and E right awesome so just like this we have a complete Foley working character control so you can see that we can move in any direction everything is nicely animated we cannot go through wall so if we try to roll or we try to nope doesn't work and we can push around other physics objects don't like this piece of debris and as well as this hinge joint so here it is a very very nice character controller that you can use on just about any game so thank you to hosting er and also thank you to these awesome supporters for making this video possible go to patreon.com/scishow t code monkey to get some perks and help keep the videos free for everyone as long as you can download the project files in a tony's from unity karma calm subscribe the channel for more unity girls post any Kirsten haven't comes and I'll see you next time