this video is made possible by my game bomber play seven awesome games and help support the channel get the steam game bundle at unity code monkey comm slash game bomb in this video we're going to take our dots pathfinding code and apply it to the entity component system so we have our entities they add a component to request a path and it's calculated using the super fast dots path finding and finally return to the entity let's begin okay so here is our goal over here I have a simple character and my map now I can rightclick anywhere in order to make areas walkable or unwalkable and with the leftclick there you go the unit receives the order commonly it's a path and moves towards it so if I try to go through wall there you go it avoids the walls and now here I've made the units roam around randomly and by pressing a button I can spawn some more units every time I press there is 500 new units being spawned and again all of them moving randomly and calculating their path so here in the stats we can see the number of units so right now with a thousand units everything is running in about 4 to 5 milliseconds so I can spawn a whole bunch more okay so here we are at 10,000 units on running pathfinding and roaming around randomly inside of this grid and we're still managing to get it within 15 to 20 milliseconds so that's an insane number of units and just like that you can see how insanely fast this works and actually most of the time that we're spending in here is working on the renderer and not actually on the pathfinding illogic so here in the profiler I'm looking at a single frame you can see that the actual pathfinding is all the way in here we have to zoom in there you go taking just one millisecond and you can see over here a whole bunch of jobs all of them running in parallel all of them with bursts enable so as you can see most of the time that we're spending on a single frame is actually on rendering and not on the path finding which is insanely fast so if you had a better render like for example the one I made where I managed to get a hundred thousand animated sprites at once then you could push this a lot further these dots videos take quite a lot of time to research and put together so if you find a video home phone consider supporting me on patreon or picking up the game bundle so thank you to these awesome supporters for making this video possible go to patreon.com/scishow to code monkey to get some perks and help keep the videos free for everyone ok so in the previous video we implemented pathfinding using the other elements of the dot stack we made it work with the job system and Ebers compound now here we want to make it work with the entity component system now if you haven't seen it yet go watch that video and then come back to this one check the link in the description so here when I have my unit waiting around he's just a simple sprite converted into an entity so if we pause and look if they're yo the unit is not on the scene as a game object but rather as an empty so if we one look into the entity debugger there it is over here we have the unit and here in the inspector of the components so you can see for example the various pathfinding components that we're going to use in order to request a path and follow it so here we have the path final component as well as the path position which is the dynamic buffer so over here as I click it adds a component to the unit here you can see that added the path finding params component so this component contains the path finding information so the start and end positions and then the path finding system is looking for entities that have this component when it finds one it runs path finding with those parameters and places the resulting path back in the path position dynamic buffer so over here you can see all the positions in order to reach our target position so there it is dynamic buffers are great and if you want to learn more about them check the video and link to the description so as I click you can see the unit correctly following the path now another very interesting thing that I have implemented here is the base for the path finding map and II visual so here I'm using the grid that we made in a previous video which is the same grid class that we used to create our objectoriented path finding so the word is composed of instances of this grid node class and the visual is handled by this game object so the very interesting thing here is how we're mixing game objects in the dots world into one single thing I've seen a bunch of comments from people concerned that either you have to make your game composer with dots or completely with game objects but the answer is you can mix and match so you can use dots for whenever you need absolute performance like for example path finding and sick with game objects where performance is not an issue so over here we have a practical example of that being used ok so now that we've seen our goal and how we're going to reach it let's actually implement alright here we are in our starting everything is working like in the previous video so if you haven't seen that one yet then go watch it and then come back here that video covers implementing the a star path finding algorithm using only value types so it works with the job system and the burst compiler ok so how we're going to make it work with the entity component system is by adding a component with the path parameters so let's begin by creating a new csharp script call this our path crams so here it is and now this won't be a very simple struct implemented by component data and inside we're going to have two fields so we're going to have an into for the start position and then into for the end position all right so here we have a simple component that holds the parameters that we need to calculate our path okay now let's see how we're going to add this to an entity so let's make a system to listen to input so we can tell the unit where to move to so here let's create a new C sharp script call this B unit move order system and now in here let's use unity empties we're going to make this a component system now here let's just for a simple input mouse button down so when we press the left mouse button let's pass in a pathfinding order and first i reason let you send them from a fixed position into another so we do a entities dot for each so we second through entities that have the translation component and now in here let's add our params component all right so there it is when we press the in left mouse button we're going to add the component into our entity and that component will contain a start position of 0 0 going into for 0 alright now let's go into the editor in order to make our entity so here we are and we're going to create a new 3d object and let's make it a quant and now in here I have a basic texture so just try it yep there you go there's our unit and to make it into an entity only need this to entity convert to entity script and that's it if you want to know more about converting and spawning entities check out the video linked in the description all right so let's test and yep there you go over here in the corner on 0 0 we have our entity ok so we have our entity and now let's click and if we pause over here we can see that we do not have the unit game object but if we only look into the empty debugger yep there it is over here is our unit and over here in the inspector we can look and see that indeed we do have the pathfinding params component with a start on zero zero and an end on four zero alright so we have our entity receiving a component on click awesome now that we have this let's run pathfinding based on these parameters so over here is the pathfinding script that we made in the previous video so we already have our fine path job that has burst compiled enabled so now let's use this job with those pathfinding parameters so first let's go up here and convert this into a component system all right now on our update and let's do the usual entities for each so we grab the entity and also the path finding params so here we're cycling through every entity that contains a path finding params component and now in here now let's create a job using these parameters alright so we in Senshi 8 a new instance of our job passing the parameters and then we run the job now to see this working let's just add a debug log and after running our job in order to make sure that the path finding only runs once for each entity we can go into the post update commands and tell it to remove a component of time path finding params on this entity so every time an entity receives a path finding params it's gonna run this code it's gonna count alike the path and then remove these pathfinding params so that's how we make sure that we find a path for a specific entity only once alright let's test ok here we are with our entity idle and we click and you're over here we can see that we are running our fine path code and correctly calculating the exact path so we have one right next to it so we're going from 0 0 to 1 0 to 1 3 1 and finally for 0 all right so our system is running I'm looking for a path as soon as the entity receives its parameters so now that we have our parameters in path being calculated let's see how we can make our unit phone with firstly in order to store the path we're going to use a dynamic buffer holding a list of into positions if you're not familiar with dynamic buffers check the video linked in the description so let's make our buffer element to create a new C sharp script called s the path position alright here we have our buffer element that defined what we have is really meant to for the position of each path position so now that we have our buffer element let's make a offering component so we can easily add it on to our entity so back in the Edit term let's create a new script call it the path position authoring alright here's our authoring component again if you're not familiar with the convert game object to entity check out the videos on the dynamic buffer and on incent shading prefabs so essentially this runs when we convert a game object onto an entity so it calls this function with the created entity and the entity manager and so in here we can simply add our buffer of path position so now we can go back into the editor and over here select our entity and all we need to do is drag the path position authoring component so now if we test and yep the game is running and over here on the entity debugger we can select the unit and there you indeed it does have a path position buffer alright so far so good now let's go into our path finding script and in here we are cycling through our entity with the path finding params and now let's also receive our dynamic buffer so you grab it in here and now let's also pass it down to the job all right so now the job receives a dynamic buffer and now we can go all the way down here after we complete our current path here we go this is where we're actually generating the path so previously just for testing we were creating a native list of into a race and now instead of doing that we're going to add it directly on to the dynamic buffer so here and let's do another version of this function and instead we're going to return void and we receive the dynamic buffer and yet there it is so we're doing pretty much the same logic as previously except previously we were incent sheeting a new native list and in here we're receiving the buffer and we're directly adding the path positions onto our buffer okay so now appear and let's use this function instead all right so just like that and now again since we're adding positions to the buffer before we do this let's make sure that we actually clear okay right so all this should be working let's test okay here we are there's the entity now we click and now let's look into the entity debugger and over here we have our entity and if there you go we have our path position buffer being correctly filled there we go you can see going from 0 0 to 1 0 to 1 3 1 and finally 4 0 so we have our dynamic buffer being correctly filmed with the positions that were calculated awesome now that we have a path being calculated let's make a system to actually fold so let's make a new script from this key path following system all right we have our simple component system now here and let's cycle through the entities with dynamic buffer and the translation all right we are secondly through all the entities with the buffer and the translation so now here we have a question and the question is how do we know which path position in the buffer should we actually follow so should we go into index 0 in the x1 or whatever so to solve that we need another component in order to keep track of the current path index that we're following so for that let's make a very simple script call this our path follow alright so here it is we have a very basic component all we have is an integer for the path in X and we're automatically generating the authoring component so we can go into the editor and here we select our unit and let's drag the path followed component there it is and for default let's set the path in the x2 minus 1 to indicate that for stars we don't have a valid path all right so now let's go into the follow system and our here we need the buffer the transmission and all so let's grab our follow and now if the path follow dot index if the path index is actually bounded so more than zero then let's grab the current path position so we access the buffer on this MX and we gravity position and now we just do some simple code in order to move towards it all right so here there is just some basic follow code so you grab the path position convert that into a float three for our target position we can't let the move direction based on the turret position and the current translation value define a certain move speed and simply move towards emu direction but move speed x down time and finally we check distance if it's close enough then we set to go into the next Waypoint and now if you remember in the last video when we come later the path we had the path actually reversed so that's why here when we reach the path position we go into the next index which is actually the one before so we do index okay so just like this our system should be working now all we need to do is set up the path for no component so let's go back into our path finding script and let's go down to the part where we are calculating the path so here we come like the path which means that we are actually filling up the buffer so we need to set the path for component for that and let's go up here in order to add another field we're going to add a field of type component data from entity of type at fall now here if you're not familiar with this type it essentially lets you access component data from a specific entity so we're going to access this using the entity as the index so for that well it's also grabbed the current entity and now we can go down where we calculate our path so here we are we calculate the path if we do not find something then we ask the component data from entity of this entity and we set it to a new path from when you set the path index in this case to minus 1 because it's invalid and down here when the path is violent we asked the position buffer in our key gravity only all right so there it is now we just need to this to the job so let's go up here when we're in San Shi a ting the job we need to pass this and now the way that we get this is by using the function get component data from entity and passing our type and we also need to pass in the empty alright that should do it let's test ok here we are with the entity on the corner there now as I click and there you go the entity starts moving and follows the path correctly awesome and right now since the e parameters are fixed when I click it goes back into zero zero and then follows a path in order to reach for zero okay so over here we already have quite a lot working when we click we add the path finding parameters then the path finding system listens to entities with path finding parameters and runs the path finding job to come late the path when the path is calculated it gets added into a dynamic buffer and Wesley the path for most system follows each path position in our buffer until it reaches the destination alright so over here we have our unit correctly following the calculated path now you might have noticed that we still have one crucial thing missing here right now our press find grid is being completely created and in Senshi ated over here as we begin our job so we don't have a separate grid map working with our path finding now here as you might have noticed I set up this scene to use a grid so I can right click in order to make a certain position either walkable or not so this is using the grid system that we created previously as well as the visual and over here this is the script that is setting it up so we create a path finding grid which is a grid with instances of grid node here it is a grid node as you can see extremely simple we just have an X a Y and a boolean for is walkable very basic so here we create the grid and on rightclick I can set it to walkable or not so here by rightclicking there your divisional updates and says that something is workable or not but again right now the job is creating its own grid so for example I can make this one visually blocked but the path finding isn't connect to the grid at all so as I click there you go he does not know there's one there and just goes through it alright so let's make the path finding grid be created and accentuated outside of the job and here this is also an excellent example of how you can mix unity dots with regular game objects so the grid in here is made using a class displayed using a game object so if I pause you can see that this is working me on the path finding visual so there it is I can move around so what we're going to do is take this and convert it into a stroke that we can then use with the path fighting system again the great setup in this class where we have a static instance that we can use to access our public path fine and grid all right so let's go into the path fighting system and in here and let's make a function that won't take the grid and convert it into a native array of these types of path nodes so we're going to instantiate this right here all right here it is as you can see we are building the native array pretty much the same thing as we were doing previously down here so we access the grid that we are using and we simply cycle through the width and height and create a bunch of Pat nodes and place them in a flat native all right so you can see we're grabbing the is one cable from the other grid that we created previously and that we're using as our base and as our visual now this returns a native array of Pat nodes which is going to be our path finding grid map so down here now let's modify the job to receive the native array of our path nodes and since this is a flat native array we also need to receive a into for our grid size and down here in the job instead of creating the grid all we need to do is set it up for stars alright so there it is pretty much we're just completing the h cost based on the end position that we receive in DeJong ok so here we are creating our path node wind and now let's go up here in order to pass it on to our job so we do is passing the path know the rain and we get deep at another right we also need the grid size all right so here this now we have set up everything now here just one more thing since we are creating the pattern of the Ray outside of it and then passing it into the job down here previously we were calling Pat another ride out this post now instead of doing it in here we can simply add Dion locate on job completion so that won't take care of the allocating the array all right let's test okay so here we are now the start and end positions are still fixed but we know he's going to go from this position over this position so by default it won't go around this wall so as I click yep there we go goes around that wrong and ends on the end position now let's place a bunch of moral wrongs so here I'm going to right click in order to modify the grid and now click again he goes back to the start and now let's see any up there yo now he correctly saw that these two are walls and he did not go through them so the path fighting grid that the job received is now correctly matching what we see in here awesome ok now let's make it actually go to where we click so here we are in the system where we're grabbing the mouse click now let's grab the mouse position and convert it into a grid position all right so here this we're grabbing the mouse position we're using the code mock utilities which is always you can grab for free from Unity code monkey calm here is the function in case you want to implement it yourself all it does is wrong just say warm camera and screen to run point all right so we get the Mouser on position we get the cell size for the pathfinding grid we get the x and y position that matches the mouse warm position then we just validated to make sure that it's inside of the grid so bigger than 0 smaller than width and height so we do that to calculate the end position and then we cycle through the entities and we do the same thing to validate the starting position and we add the path fighting params component all right so there it is very simple let's test ok so here we have our unit in core now let's put it in here and click and there you go the unit come way to the path and went exactly to the mouse position so click again and there you go no went from there there click and there you are awesome so here we have the start and end position correctly working and again we already made work with one so let's rightclick make a bunch of ones in here and I'm gonna click for him to go in there and yep there you go he goes around there there there and there right awesome so we have our unit following the available path going from start to finish okay so just like this we have our path finding system working we can add this path finding params component in order to set the path finding parameters then our path finding system looks for entities that contain the path finding parameters when it finds those entities it creates a path finding job and finally we have the path for system which looks for entities that have a valid path and similarly makes them follow it alright so here we have a working system however there's still one thing missing and it's actually one of the most important things so right now over here we've been testing this with just a single unit obviously we want our path finding code to be working nicely in parallel with multiple units so here let's just duplicate this object and there you go now we have two units so here we are and I click and there you go it does seem like it's still working however if we look in the profiler and over here we can see the issue so it is working but you can see one path in here and one in here so it's working but it's working sequentially so we have both jobs working on the main thread and over here and look at all of our job workers on compiling idle what we really want is to have them running the jobs in parallel so back in the path finding script now the way that we make them work in parallel is first we schedule all the jobs and then we tell them to complete them all so in here let's create a native list of job handle so we create a list then we add to the list our job instead of running it we call schedule and then down here we use job handle and we call complete own and we pass in our job handle list alright so that's it firstly schedule all the jobs in the new random all in parallel let's test so here we are and click and there yo we have found our error it's essentially telling you is that we cannot schedule two jobs that access the exact same data so in this case see component R from entity now this is the job system protecting us from causing race conditions over here we have multiple jobs on accessing this component data from entity which is actually a native array however here we know what we're doing we know that even though multiple jobs receive the same component data from entity we know that each job will access this array with a different entity so there's no actual race condition so the solution here is to tell me compiler that we know exactly what we're doing and we want to disable safety so for that we go all the way up here north to add another reusing using unity that collections dot lowlevel dot and say and inside of that namespace now we can add the attribute disabled container safety restriction so by adding this attribute we're telling the compiler do not worry about safety when accessing this field so now this won't correctly work but again be very careful when you using these types of attributes if you do end up with the race condition your game will crash so make sure your code is working perfectly before you start messing around with safety all right so let's test so here we are and click and now here we have an error although we did fix the other error so we fix the issue with concurrently accessing the component data from entity field but now we have the same issue when accessing the dynamic buffer so to verify that we fix the issue and let's stop using the buffer so here let's comment out everything related to the buffer ok there it is we are no longer using the buffer so let's test here we are and click any app theory oh the game is running and everything is correct so we do not have any race conditions and there's no crash awesome so now here when dealing with the dynamic buffer it's something that I actually found quite strange so you would assume that we could just have the exact same attribute in order to disable safety and be able to access the buffers in parallel we can use something similar to the component data from entity by instead of using the dynamic buffer we use buffer from entity so we would assume that this would work again we know we're never going to access the same buffer of the same entity in two jobs so we know we're safe however just adding this attribute does not appear to disable safety over here there we go we still have our error so I'm not sure if this is an issue specific with dynamic buffers that won't be fixed or if dynamic buffers are special and somehow cannot be accessed in parallel at all it seems like it should work just like this other one but apparently it doesn't I spent quite a long time looking into this and I could not find the solution to disable the safety completely however I did find another alternate solution that works well enough so the solution is quite simple which is just don't do it in parallel so we can still calculate the path and get everything working correctly in parallel and then we make a second type of job that won't run just on the main thread and it's solely responsible for filling up the buffers with the calculated path ok so let's go all the way up here to make that secondary job ok here it is the set buffer path job so here we just have the pattern of the Ring which after going through this job the pattern of the Ray has already been set up so essentially all the path nodes already have the came from node index correctly set up so we just use that in order to generate our path and by doing that we end up with the path position buffer correctly filmed so down here let's get rid of all mentions of the buffer so all of this will be done on the other job and also here make sure that we only the allocate the pattern of the Ray after we set the buffer so in this one let's get rid of this attribute okay and now appear when we incent she ate our jobs so first we schedule all the jobs that do not use the buffer we do all of those we complete all of those and after completing then let's run the buffers while sequentially all right so here it is over here when you create our normal find path jobs we're adding them into this space list so we instantiate them and put them inside of this list and then in here we just cycle through the list after the previous job has been completed and we simply grab data that we used on that same job in order to make this new job and fill up the correct buffers from entity so again I wish it were possible to make all of this inside of the other job and I'm not sure if this is intended or a bug but still unity dots is so fast that even with this part running on the main thread it still ends up being insanely fast all right so let's see it in action okay so here we are in click and there you go both units calculate the paths in parallel and they both go to the target position and if we look into the profile over here in the profiler you can now see indeed we have two worker threads correctly working working on the fine path job both in parallel so now let's play some more units so we're here and let's just duplicate this one place a bunch more all right we have a whole bunch of units and click any of there you go they all come later the path and now went straight to the target position awesome ok so here we have our complete system working we have multiple units working as entities and we can click to set the parameters which will then get calculated by the path fighting system so right now we can look into the profiler in order to test our speed so just here in the code in order to make sure that we test the path finding speed we can simply comment out the post update command in order to remove the path finding params so this way this component will not be removed so it will be trying to look for paths on every single frame so here we are in the profiler with seven units waiting for a path and right now it's seeking one millisecond which is still quite a bit and the reason is because we are missing our magic bullet so that is the burst component so just go over to jobs burst and enable a burst compilation and let's test and there you go now here we have burst enabled and look at that the entire path finding is taking point three seven and we have to zoom in real far in order to actually see our jobs working in parallel so you can see all of them here in parallel and then afterwards we haven't here the various jobs in order to set the buffer so this is in parallel and this is not but it so ends up being insanely fast now let's try out with a hundred units alright so here we have 100 units we can look into the stats in here to see the batch is 100 yep we got a hundred and we click to enable pathfinding and here in the profiler you can indeed see a whole ton of fine path jobs all working in parallel only using bursts and then afterwards of the ones setting the buffer elements so I'm looking at the path finding we have 100 units searching for path all in the exact same single frame and it's taking just four milliseconds so this is insanely fast alright so over here I have set up the units to look for a random position and when they get there and look for another random position so as you can see they are all roaming around very random and over here on these stats you can see just how quickly this code is running so we have 1,000 units randomly doing path finding in just 4 milliseconds and again I can modify the path finding grid by rightclicking so let's put a wall in there and yet there you go you can see them avoiding the positions with walls and every time I press the button I can spawn 500 units so there yeah now we got 1500 and they all spawn over there on the corner now we got 2000 and again everything's still running at about 5 to 6 milliseconds alright so let's see how far we can push this ok here we have 5000 running at about 1012 milliseconds and around 8,000 we finally go under 60 fps and at 20,000 we are around 30 fps and this is all once I'm still recording the screen so without that it will go much further so here we have 20,000 units randomly running around our level and it's running at 30 frames per second and really half of that time is just spent on rendering so we can look into the profiler so here we have the profiler and as you can see for 20,000 units all of our pathfinding is over here running in just 2.9 milliseconds then we have the path phone system in point 7 milliseconds and then a lot of the time is actually spent on rendering so if we were using the rendering system that I made in a previous video which supported over a hundred thousand animated sprites by using that system we could push this even for all right so here we have implemented a star pathfinding in unity dots we're using the entirety of the dot stack so we have the job system calculating paths in parallel we have the worst compiler converting all of that code into superfast machine code and we have our data oriented entities running the logic and being displayed so here it is insanely fast supporting tons of Units alright so this video and the previous one were quite tough to make but I'm really happy with the results now with this working I can start to work on making a simple art yes or maybe combine this with the dots physics in order to watch entities looking for paths and pushing each other around let me know what type of videos you'd like to see this system apply to and also this took quite a long time to research in put together so if you find a video home phone consider supporting on patreon or picking up the game bundle so thank you to these awesome supporters for making this video possible go to patreon.com/scishow code monkey to get some perks and help keep the videos free for everyone as always you can download the project files in Usagi's from unity calm calm subscribe to the channel for more unity tutorials posting first in heaven comments and I'll see you next time