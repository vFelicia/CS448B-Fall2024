hello and welcome I'm your code monkey I recently announced that I'm working on my next team game it's called turtleworm Liberation go ahead and add it to your wishlist in the announcement video I talked about how this idea came about how I've been wanting to get back to making a complete game for quite some time and how earlier this year I spent several months working on my turnbased strategy course then when I had the idea of continuing from what I built there to make a phone game I thought that was a great plan it's great for me because well first of all it's an idea in the genre that I enjoy and I would love to explore some more and it's also great as content for you the viewer to see a practical use case of how you can take whatever knowledge you gain from following whatever cars you have completed take that final project and continue building upon it to make something unique and interesting you won't see how the funnel game will be very different from what you see in the course it will look like a completely different game despite being built upon the same base I officially announced the game after I was certain that this was the idea that I want to pursue and after building quite a lot of things so here let's see everything that I've done in that time this devlog is actually quite a bit longer than I would like because I end up building so many mechanics and systems so quickly and stick around to the end where I'm going to mention something that I tried which might help you if you're in the habit of stopping projects in the middle of finishing just like me pausing development of this game to get back to doing regular videos also since one of my main goals with this devlog series is phone transparency throughout the entire Dev process in the announcement video I asked you to wish list the game wish lists are extremely important nowadays if you want to be successful you really need to launch with a good amount of wishlists otherwise your game won't be buried between the dozens of games that come out every single day on scene that is why I waited to have the steam page up and running with a phone trailer before I announce a game in the announcement video I asked you to wishlist game and as of right now the game already has over 3000 wishlist which is a huge amount so thank you all so much in the video where I did the math you can't let the gongs the smaller gong was 10K wishlist and the absolute bare minimum was 5K so already in just about a month it hit over half of the absolute bare minimum so that really is an excellent start so once again thank you all so much for wishlist in the game speaking to you as an instructor my advice is announce your game as soon as you have something to show and start Gathering wishlists right away and speaking to you as a developer myself as a two wishlist game if you haven't already the goal release date is on Q3 of next year so with 3 000 wishlists already by now then I filmed that hitting 10K by release should definitely be doable alright so here let's see how I took the final course game and built upon it adding tons more mechanism systems to make my own unique game I already had tons of notes on design that I want to implement basically I first worked on design on paper before I wrote any code so when it came down to writing the actual code I already had a list of systems and mechanics that I wanted to build and basically I prioritized them based on their importance and their ease of development for example the open world logic being able to seamlessly move around in a large open world with Dunes all over the place that system is very much crucial to the entire game design but I also know that system won't take a long time to implement so in making a first quick prototype I did not choose to prioritize that system instead I built other systems that were easier to implement but still very important to the final design and before I got to implementing any system the first thing that I did was just make a nice empty scene for development in the course the final lecture is on building a nice complete MiniGame with all the mechanics built in the course so the final game has a nice level scripting a bunch of enemies some carefully placed items and so on but while developing this game I did not want such a complex level for developing and testing you really want it as simple as possible so I duplicated that scene and got rid of everything that wasn't absolutely necessary so no level layout only two friendlies and two enemies I made sure to remove all of the 11 scripting so I could run the game and everything worked in this simple possible with a nice empty testing scene setup I started implementing the first system and for that I chose the building system the game has billing mechanics where you can place down buildings construct them with resources and so on in the final game you won't be able to go out into the middle of nowhere and completely build a nice Outpost from scratch making this mechanic was actually pretty simple because in the course I already implemented a nice generic interact action you can make any object interactable then the units have an interact action which can take an action on that object and importantly that system is built using an interface so that action can be whatever you want so in the course that same system is used for making a door you can open and close or some crates you can blow up so over here I just made a construction object I set it as interactable and for the logic just added some construction progress when the progress completes it simply destroys the construction object and spawns the final object really simple system this mechanic was super easy to implement and once again is a great very practical example of the power of writing good clean code because I focus on making the course code as clean and extensible as possible adding this mechanic took literally just about 30 minutes if I had not taken care to write Googling code if my interaction system was all very hacky and built without any thought behind it if so then mechanical like this would probably have taken hours or days instead of 30 minutes so this is really the reason why it might seem like I'm a broken clock constantly telling you about the same thing talking about how important it is to write Googling code but the reason why I say that so much is because this is because it really does matter also a very important fun thing related to this mechanic I went to Google to figure out if it was spelled constructable or constructable fun fact my steam game gamecorp DX actually has a typo in the game you have various categories for the funnel game quality and skills your developers can learn one of them being writing and in the game I totally thought that writing had two T's so funnily now if that game has a typo in the most ironic Place possible anyway so I got the beginning of the construction system working and then I jumped to another very crucial system which is in laser system basically the game is meant to be kind of like XCOM but in a large open world with tons of units the big problem with that design is that if you have something like 30 units over a huge world that's a huge amount of work to get them all to do something on the same turn you'd need to take three actions on every single turn that would really slow the game down so part of my solution for that problem is the only their system there are some special units that act like leaders and other nonleather units can only be directly controlled when within range of a leader so in the final game this will make it so that each leader kind of has its own team and then with that it's easier to manage one team's thing behind defending the main base while not only that goes out another team to capture and build a secondary Outpost for building that system it's also pretty easy it's really just a decent check so each unit has a simple Boolean either it's a leader or it's not then the leaders can always be selected and the nonleaders when the round begins it does a distant check to all the leaders if it's within a certain distance then the unit can be selected if not then it cannot be that's it pretty simple and now you yourself might be thinking another problem with this design which is well does it mean that the units outside of Direct Control just stay there do they just say static and do absolutely nothing that is indeed a problem with this design and solution for that is something that I call automated actions which I'll cover in a bit the next task now that I had a building and leaders working was making a controllable turret this was also pretty easy in the building system when spawning the funnel object that object can be whatever I want so I just made a turret and added the unit script just with that it's already controllable and again the whole design of the game is very modular the actions that a unit can take just depend on what action components it has so by default I add the same components as units which also means that the turret could walk around which was a bit funny obviously I don't want that for the turret so to make it act like an actual turret I just removed the move action and that's it with that tour can shoot just like any any other unit really simple to implement this thanks to once again good clean code so with those systems working the next crucial system was items the game is meant to have building crafting automation elements all of those require items to function for implement the items I thought of a bunch of different ideas the main question when making a game like this which is grid base is do you want just one item per grid position or not I felt that was a bit too limiting so I didn't want that design I want plenty of items all over the place to represent the atoms I just built some cubes with some icons those icons are obviously just placeholders but like I mentioned in the video where I cover the assets that I'm using to build this game a bunch of those icons were taken from previous videos or previous games that I made obviously the icons have nothing to do with the actual items they're just random icons just while I'm developing the system so I have some items as cubes and for picking them up like I said I did not want to be limited to just one item per grid position and I also did not want the limitation of having to use an action point to use an item so for picking up the player literally just clicks on the item if it's close enough it gets picked up that's it super simple also added a rigid body and collided to the items just for fun and for representing the actual item data for that obviously I use script more objects which are excellent for exactly this purpose just to find a prefab icon name and that's really it built a bunch of times just assess it out and everything worked perfectly with the items working I also worked on a fun mechanic making enemies drop items on death it's pretty simple to add just a script that listens to the health system on that event when that happens just spawn some items and then using physics apply and explosion Force just to throw the atoms in the air really fun and at this point actually something extremely rare happened Unity actually crashed sometimes I hear people talk about how their Unity crashes all the time and it always confused me because for me I use Unity a ton and it never crashes on me I literally get maybe one or two crashes per year while using it for hours every single day I guess the reason is because I normally stick with the very stable LTS release for this game I'm using the tech version since the release date is only in late next year by then I'll be launching the game with version 22 LTS which should be commonly stable anyway since I saved constantly I hit Ctrl s subconsciously pretty much every few seconds because that I didn't really lose any progress to this crash so just reloaded unity and kept on working alongside the items one obvious system is an inventory system building this was pretty fun it's something that I've done many times before so I just wrote code nonstop for about an hour before doing any testing now you probably shouldn't do that you should test often after writing just a headphone lens of code definitely don't write 100 lines of code and then test if you do you might have tons of issues and then have lots of trouble finding those issues but anyways for me I've built dozens of inventory systems so that's why I just wrote tons of code nonstop making a simple inventory system is pretty easy I have a video tutorial that I made quite a long time ago I've actually been meaning to remake that tutorial with a better one for example something that uses scriptable objects just like I'm using here so I made that and worked but it also brought forward a potential issue with this design I knew that I did not want to have a limitless inventory I wanted to limit I wanted a physical representation of space but if every item occupies one slot then it gets really difficult to then Implement building or crafting mechanics or anything that requires tons of resource also ammo I want ammo to be a consumable resource so that the player needs to craft some ammo and bring enough when they go out to explore the world with this system where each item takes one slot with this the player really couldn't take much with them so later on I spend upon the inventory to make a stackable item system so this was quite a bit more complex but still doable I can define an item type as stackable or not and Define the max stack amount then of course all the logic for consuming a single item merging and splitting stacks and so on some of that was pretty tricky to handle but it came out looking quite great with the inventory done I made a visual since the game has lots of units and objects in the world I cannot just use a regular UI to show data for all of them so each unit and each object has a worm space canvas attached to it this is a really awesome way to attach UI elements to objects in your world I made a simple button to show and hide the inventory UI as well as some simple Logic for displaying the item icons of course all of it written with some nice clean code so there is no direct connection between the inventory and logic and the inventory UI DUI just listens to events and updates itself so everything is nicely decoupled I could completely remove the UI class and the code would still compile with atoms working it was time to actually use them so I modified the building system to require items for construction the unit doing the constructing must have the required items in their inventory if they do they cannot progress pretty simple next is since I have items in individual inventories I want to be able to transfer items between them to do this I just made something super simple pretty much just duplicated the interact action except instead of interacting it begins an item transfer action for making it work once again I made heavy use of interfaces so this item transfer action can work with anything that has an inventory it works for changing items to be doing two units I can drop items on a crafting station or a storage I can pick up items from a Loot Crate and so on so another excellent example of the power of csharp interfaces with all those mechanics working it was time to create a crafting system I just made a crafting station just a regular building I made it with the I interactable interface so I can interact with it it checks if the unit has required items in their inventory if so then it grabs the funnel item and stores it in the crafting station inventory for the crafting recipes as usual I use scriptable objects just to find some inputs and outputs all of it pretty easy then for a really fun system the power system this is crucial for implementing the automation mechanics I want some buildings to require power and I want that power to have to be gen generated and transporting this is on part of the original design that I wrote down so implementing it wasn't too difficult I wanted three types of buildings generators that produced power Transporters that transport that power and consumers that use up power for the generated it's pretty simple it's just a building for the consumers once again made heavy use of csharp interfaces so any building of any type can be made into a consumer just needs to implement the interface which is those three things the system is already working it's a simple system but I think it will do very well in the final game since it's connected to so many other systems you build something like for example a crafting machine and it needs some power so you build a generator and doing that requires resources that you need together then perhaps you also need a transporter if the machine is far away from the generator and of course you need to defend the transports on the way if the zombies destroy them then your secondary Outpost won't lose power so I really like how this system is interconnected with all the other systems and I think it won't be pretty crucial in the final gameplay then actually did a bunch of work for a few days but forgot to hit record I'm still getting used to this concept of making some devlogs so I gotta remember to record anytime that I work on the game then I worked on the atom transport system so this is another really crucial assistant to the home game one of the main goals is having a large persistent open world with multiple bases and units all over the place since building requires items in order to build things in many places I created the item transport system which essentially acts kind of like a conveyor system you build some item Transporters then Define an atom transport route Define what Atom types will go through that route from where it starts and from where it goes then the atoms move a certain distance automatically every turn this works in conjunction with all of the other automation mechanics so you can have something like a money Outpost Gathering some resources and then transporting those resources back into the main base it is also obviously connected to the power system so each transport must be powered up for it to work and of course it also works with all of the Survival Systems like the zombies if a anime transport gets destroyed on the way then the atom route stops working speaking of automation I also build a Automated machine that can grab and drop meaning you can build a machine just like any other building and then tell it to grab a specific items from a specific nearby position and drop it on another one again this whole system uses interfaces so it can grab items from anything that has an inventory and drop it on anything else that has an inventory for example this machine can grab items from a search container and drop it on a crafting station or maybe it can grab items from an item transporter and drop it in longterm storage it works really well and the Automated machine does not need to know what object type it's interacting with all it cares is that it has an inventory that's it again my focus on this is really making the code AS generic as possible with everything working through interfaces so that that way these systems that I'm building here all of them can work with one another then I made another Automated machine this one is an interactive machine so it triggers an interaction on a Target word position like for example it can automatically make some crafting then for another simple action I also made some resource nodes so you can interact with it and it spawns some resources which again the player can pick up putting all of those systems together it already enables some really complex immersion gameplay you can build up your main base with a bunch of crafting machines then you can go out with a leader and build a secondary outpost on that Outpost you can gather some resources then build some power lines along the way and some item Transporters to transport those resources back to the main base and use the automated machines to grab items from the Transporters place them in the crafters and another automated machine to automatically start crafting so already quite a lot of complexity is possible just with these handful of systems and buildings one of the missing automated things in that example gameplay is how do you make the Gathering automated for that and to solve the problem that I mentioned in the beginning of this video I implemented something called automated actions basically there's three turn types there's the player turn the enemy turn and the automated turn during the Army return all of the automated actions take place this helps keep the game moving without forcing the player to do all kinds of manual actions for example the player units they can already gather resources the player can manually move them to a resource node and interact with it so all that already works but doing it manually is a bit annoying so the automated action helps that I can set up an automated Gathering action on a certain unit I can give it a certain area from which to gather resources and also an area to drop resources in storage then the unit is controlled by the AI to do all that logic importantly is this automated turn only happens after the player normal turn so the unit isn't locked to the AI or anything the player can manually take any action then after ending the turn if there are more action points available the unit will do the automated action with this the unit can handle resource Gathering automatically it can drop resources on storage then an automated machine can take those resources from storage and drop them off in an item transporter which then completes the scenario that I mentioned this was the final system that I worked on before pausing development to make the trailer and as you can see I already built quite a lot of interesting interlock systems that work well with one another I really think the design of the final game will be very compelling to play now like I mentioned in the announcement video one big challenge with the making of this game will be building it once also making regular videos on this channel I don't want to stop making tutorials or any other type of videos so how can I work on the game then pause for a few weeks to make videos and then get back to the game usually when you come back to a project after some time it can be quite a bit tricky to remember how everything worked it can take a few days to get reappointed with the code base so to help try to solve that I made a nice diagram of all of these systems what is their purpose and how they are connected I just got back to development on this game after being away for almost two months and this diagram really helped I was able to quickly get back and start writing some more code so if you're the kind of person who stops projects in the middle then perhaps consider doing a diagram kind of like this one before you stop building something like this while you're still very familiar with the code base is pretty easy and in my experience it really helped me when getting back to it so perhaps do give this technique a try alright so that's everything that I built in the about two weeks that I was working on the game full time thanks to already having a really nice base in the final course code I was able to do a ton of progress really quickly and once again let me remind you that part of the reason why I built all of this so fast is because the course code is really nice and clean so I don't want to sound like a broken record but hopefully this video and this whole journey will act like an excellent practical use case of the power of writing good clean code and why it is so important if you haven't wished list the game yet go ahead and edit your wish list there's a link in the description and stay tuned for future devlogs as I continue on this journey alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and I'll see you next time foreign