hello and welcome I'm your code monkey and it's finally here unity's official multiplayer solution is finally fully released I've had tons of requests to cover some multiplayer and my answer was always the same I'm waiting for the official tune to be released and that time has finally come so here let's look at unity's official multiplayer called netcode for game objects this is a precomprehensive detailed tutorial one of the longest I've ever done I tried to cover as much as possible related to multiplier we're going to first start with an extremely simple example just to see how the absolute Basics work so first how to install the package and set up the network manager then how to spawn a player and synchronize it across multiple clients learn about Network objects and network transforms how to synchronize custom data with network variables how to run Logic on the server or the client depending on remote procedure calls learn how to spawn and despawn networked objects how to synchronize animations learn how to use the multiplayer tools for help with debugging and learn about peertopeer and net there's timestamps in the video if you want to skip ahead or rewatch your particular section by watching the song video you will have enough knowledge to build all kinds of multiplayer games and with this video as a base I want to build upon it and make some nice multiplayer mini games so do let me know in the comments what types of games you'd like to see maybe in a future video I'll build a quick mini game of things like overcooked the mangas or maybe something like valheim this is one of the longest most detailed tutorials that I've ever done so if you like it please hit the like button it really helps and maybe consider getting one of my courses I'm basically sponsoring this video myself if you use unity in any way definitely get my ultimatinity overview course it won't teach you how to use the many tools and features that ENT has so you can be more effective and make better games faster there's no need to build something yourself from scratch if there is already a button tool that works great UNT has tons of them that you might not know about the course already has 15 lectures each covering a different twohour feature of the engine and is constantly getting free updates or if you prefer stepbystep courses on making a specific game check out my Builder defender course I also have a phone course only on using visual scripting there's a single line of code in any of those games and if you're past the beginner stage and you want a guided path to help you make the jump from beginner to Advanced and get my turnbased strategy course it will help you massively improve your programming and Game Dev skills on all courses I'm always available in the Q a section answering all of your questions every single day so check them out to the link in the description okay so let's learn all about netcode for game objects let's begin by installing the package so for that let's go into window and open up the package manager and over here let's go go into the NT registry and then scroll down until you find the netcode for game objects although I should note one very important thing which is make sure you're using Unity version 2021.3.10 or later if you're using an earlier version it won't show up over here on the package manager for example while researching this topic I was testing with a project on 21.3.0 and in that version it does not show up so do make sure you have 21.3.10 or later or alternatively you can also install it by selecting the path if you go into the official multiplayer docs over here you see the pass so com.unity.netcode.game object so you could copy that and then paste it over here on ADD package by name but like I said make sure you're using 21.3.10 and it won't show up on the package manager so let's just install it all right the package is installed now the first thing we need for multiplayer is a network manager so let's create an empty new game object let's count as the network manager let's reset transform just keep things clean then let's go up here into add component let's find netcode and then inside netcode let's create a network manager this is the main component that handles pretty much everything related to multiplayer also I should point out that you should have only one of these components so make sure you don't have multiple then on this component we see this info warning it's telling us we probably want to install the multiplayer tools package as well we're going to see about that package later on the video but still let's quickly install it just make sure that this warning disappears so over here on the package manager right above the netcode for game objects is the multiplayer tool so let's just install this okay the package doesn't sound so back into the network manager the next thing that we need is to pick over here the network transport layer this is what actually handles sending and receiving the underlying packets one great thing is that this part is modular which means that you can use netcode for game objects with different transports so for example when making a steam game you could swap this out for the scene transport layer and everything else would work but over here on let's check with the basics and let's use included transport layer so let's look over here and select transport and let's select the unity transport alright so it's unladen down here we see a bunch of ENT transport things let's leave all of the parameters with default so with this the basic setup is done now let's create a simple player character so let's create an empty game object name this the player let's reset the transform and now for a visual let's go inside and let's create a simple capsule let's just offset it on the Y by one so there you go there's my simple player visual okay so now to make this an object that is going to exist on the network let's add the component so let's go into that component let's go inside netcode and this time we want to make this a network object all right that's it no need to touch any of these next the way that the system works is by spawning a prefab for each player so let's first make this into a prefab so just drag it over here into the project window this is now prefab so now let's go back into the network manager and over here we've got a film for the player prefab and let's just drag our player prefab so now when the player connects it will automatically spawn this prefab for each player although here and let me also quickly point out that this is not mandatory for example on some strategy games like Civilization or command conquer you might not want to have a player prefab since in those games you don't really have a single player character so for making those types of games you might want to leave this empty or you might still want to assign it just so it spawns a player prefab without any visual just some game object to run the logic of the player without needing to have any visual also an important thing is let's remove the player prefab over here from the scene player prefab should really be spawned dynamically when a player connects so make sure it's not on the scene the next important thing is over here enlist for Network prefabs basically anything that we want to be spawned on a network must be in this list any object that is not on this list pretty much does not exist on the network so here let's click on the pause icon and let's drag our player prefab okay so with this basic setup we are ready to make a quick test so let's just go ahead hit on play and when you do you might also see this warning Pretty much telling you that this scene has not been added to the building list you can add magic only or just click on yes until edit automatically so let's click on yes basically what that does is over here if we're going to file and build settings over here we now see that this scene that we're working on this one has been added over here to the Boneless okay so let's hit on Play There It Is the game is running and right now there is no player spawned so right now there is no connection nothing and on the network manager we have some nice buttons and by the way if you don't see network manager you might notice that it's not over here on the scene anymore that is because like I said the network manager there's only one component that exists and when that component starts it pretty much adds itself over here on the don't destroy on load so over here is the object let's select it and then here we have these buttons so start host server or client now these three types are extremely important to fully understand a lot of the logic that we're going to build depends on understanding which is which first of all the server is just a server so it has no player then for the client that is just a simple player connecting to a server and the host acts as both a server and a client so if you wanted to make your game use a dedicated server architecture for that one you would create just a server and then all of your players would be clients but if you don't want to use dedicated servers then you make just one player be the host and all of the other players will be regular clients so we're here for our test we want to create the server but I also want to play as a player so let's use it as a host so let's click on it and if there it is as you can see it spawned the player prefab and we can see here that we are currently running as a host supposedly what happened is we created the server and then automatically created the player We join that server on the same window okay great so far so good now using these inspector buttons isn't very useful if we make a build we won't be able to see the inspector so let's make some proper UI button just for testing so over here on the hierarchy I already have my basic canvas so inside my basic canvas let's create an empty game object call this the network manager UI let's put the camera in 2D and zoom out to find the UI now this empty game object let's expand the size so let's click over here on the anchor and expand on all edges and put them all on zero just so that this game object occupies the entire canvas window then inside let's create a new UI button so over here the button text mesh Pro let's call this the server button then let's go inside for the text let's call the server and let's anchor this button over there on the top right corner and just move it in there again make sure you anchor it correctly and make sure you set the parent size correctly because later on when we make a build for the build we're going to be using a smaller window so make sure the buttons are always over there on the top right corner regardless of whatever aspect ratio you're using okay so that's the server button let's duplicate it push it down one for the host button and one for the client button so the host button and the client button all right so we have three simple UI buttons now let's make a script to run this so let's right click let's create a new csharp script the network manager UI over here let's attach the script and open okay so now here let's add references for all of our buttons so let's make it a serialized field so we can drag them in the editor so this is a button let's say the server button and over here let's use the visual studio Humper to add our using in the engine.ui okay so the server then you've got the host button and the client button also by the way if you're ENT beginner and you don't know why I'm using serialized film private as opposed to public then go watch my video on why you should not make everything public okay so we have these three references let's go back into the editor and over here on let's drag on references so the server then we've got the host and then the client and over here let's add some Behavior so let's go make a private way to wake and on awake let's go into the button so the server button let's add a click listener so let's go into the on click addin listener and let's add the unlimited expression and again if you're a beginner and you're not familiar with this Lambda syntax if so then go watch my quick video on delegates so when we click for this one we want to start a server and the way that we do that is we access the network manager and for this one you need to add using unity.netcode so on the network manager inside we can access the static Singleton like I said there's only one of these objects at one time so through the Singleton then we can access some functions so we can start a server a host or a client so for this one let's start a server and for the others let's quickly make them all right so those are all the buttons super simple so start a server a host or a client okay with the button set up let's see one more thing back in the editor let's go into the network manager and over here one of the very important settings is over here the unlock level and by default this one is only on normal we can change this to only do logs on errors or developer which is much more verbose so since we're learning how it all works let's choose the most robust option so let's go with the bumper and also before we make a phone build for testing let's see one more optional step like this if we want to make a build and we want to read over here the console logs doing that for the editor is going to work just fine but again since we're working on multiplier we're going to be working with builds for testing and reading the console logs from build isn't really very simple we have to find the build log file which is pretty annoying so it would be nice to be able to see the logs on screen so for that there's an excellent asset that I reviewed a while ago that does exactly that it's a Quantum console again this step is optional you do not need this to use netcode it's just helpful to be able to easily see the logs in a build I think the asset was included in a bundle a while ago so maybe you already have it and again don't worry if you don't have it you don't need it I won't also show you how to read logs the normal way but for me since I already have it I'm going to be using it so I need is just take the prefab and drop it in my scene and there's my console so that's it just a nice window to be able to read the console logs so now let's test with a proper build let's go into file and into our build settings here make sure that our scene is encoded in the build list and one more thing let's go down here into the player settings and then here you've got these two very important Fields the company name and the product name these are going to be important for later on finding the unlock file so write something in here and also importantly over here on the resolution under phone screen mode make sure you select windowed and not phone screen we want to be able to do some testing and have the windows side by side so make sure you set that and default sure yeah 1024 works well okay so with that let's go ahead and build and run alright it's currently building let's wait a bit all right so here's the build and we can see over here are nice Humper buttons If you don't see them go back and check how you anchor the buttons and what size you use for the parent so here it is and now let's run the other client over here in the editor so let's put them side by side all right so here I have two builds running the editor and a separate one so now over here on the editor let's create a host again a host not a server because I want the editor to also have a player so let's make it a host and yep we can see that our hosts start initialize all right so now over here on this one let's create a client and if there you go it does connect and over here we do see client connected and the client connect to the host all right great so here I've got two players connected in a shared world all right awesome so we can see over here on the logs that the connections did work correctly but like I said if you're not using this asset you can manually go read logs you can find the unlock phone location over here on the documentation we want to find the logs related to the build so let's scroll down and over here the employer running logs and in this case I'm working on windows so I need to go into user profile then app data look on low then it's the company name and the product name that we placed and then inside we should find the player log so in my case here it is under a local monkey netcode for game objects because those are the names that I used and inside I do see the player logs so if we open this yep we do see log circle line internationalize connected which is indeed exactly what we see over here on the log so like I said using an asset like the quantum console is super useful but you can also work without it alright so with this we already have our connection working so we've got a host and the client both joined in the same section however we didn't add anything else so right now if I press any keys nope nothing happens there is no movement no nothing so let's add that let's begin by making a script for our player so let's right click let's create an easy sharp script call this the player Network let's select the player prefab and drag our script okay so now here let me just make some super basic movement code so making an update and on an update I'm just going to test for some basic input alright so here it is some basic inputs creating a movement vector and then using it to move this transform some of it's super simple obviously there are million ways to move the player and over here I'm using the Legacy input manager just for Simplicity but of course you could be using the new input system so again just some super basic movement code so with this we should already be able to move our player so let's make a build just like this to test it out all right so I have both builds let's make this one the host there it is and this one is the client okay now let's select this one and let's try moving and if there we go it does indeed move the player okay so my basic movement logic is indeed working however we can already see the first issue which is that moving one player is actually moving both players now that is because I did not add any check to see if a player owns that object so it's currently moving both the script on both objects is running at the same time so back in the code here one very important thing is over here instead of extending mono behavior let's swap this out and let's extend the network Behavior and this one is as well inside unity.netcode so this class Network Behavior this one is an extension of monobehavior with some extra things that are related to multiplayer so you've got a bunch of virtual functions that you can override a bunch of interesting things and over here A bunch of very useful properties we've got these three right here so is server is client and is Host this is very useful to check which type owns this object and an even more important one is over here this one is owner this one won't be true only for the player object that this player owns so you can use this make sure our script only runs on the owner and does not run on the other prefabs so back in our script over here on our update before we do anything let's just do a simple if and we check is owner and if this one is not true so if we are not the owner of this object then let's just return so we're not going to run any code if this script is not attached to this owner so the only one that is going to run this module down here is just the owner all the other connect players that also have this script will not be listening to any input and they will not be moving this okay so just with this let's test again and see if we can only move our own player alright so here I have this host and this client so now let's select the host and now let's try moving and yep it does work I can only move the object that I actually own alright so that's great that some of the first problem that we saw however we can also see another issue and like this we can see that the movement is not being synchronized so over here I'm moving the player over here on the host but over here on the client it is not receiving any position so the movement is not being synchronized we're moving the player object but only locally we're not actually sending the new position anywhere else so for that let's go inside our player prefab and over here on the prefab let's add a component let's once again go inside netcode and this time we want to add the component Network transform this is going to help us synchronize all the values from the transform however in multiplayer bandwidth is an extremely important thing you really don't want to be sending any unnecessary data so over here you've got a bunch of really useful checkboxes to Define what data you actually want to synchronize we do not want to send any data that will never change so in this case for this demo we are only moving so there is no need to send any scale data and again on this super simple demo we also do not have any rotation we're just moving a Sim on capsule so let's also not send the rotation and finally we also do not have any jumping on this demo so let's not send the Y so that's it the only thing we're going to send is the position x and z that's it so let's save this prefab go back let's make a bill to test so here I have both of them connected so if I move this one and yep there you go it does work so it moves over here locally and over here on the client it is also receiving the new transform position okay great so everything is indeed working the client is receiving the synchronized transform position however with this we also see another extremely important detail it works over here if I move this one which is the host however if I jump over here onto the client if I now try moving this one and nope nothing happens it does not even move locally I'm pressing the buttons but this object this local object is not moving nothing is happening so basically what is going on is like I mentioned by default netcode for game objects is server authoritative meaning that the server is the only one with power to change the current state so the reason why the client is not moving is because when I press the button it actually does try to move but the client does not have ownership so that that the client has here when I move it it does not change it does not send anything back to the server so instead the client is constantly receiving the position from the server and the server it never moves so over here as I try move it tries moving it locally then receives the packet from the server and resets it back into zero zero so this is the part we're going to have to make some decisions regarding netcode architecture and what you want to use if you're making a hyper competitive game then the basic rule is you should never trust the client however if you're doing something casual and Coop then perhaps it can be okay to trust a client depending on which approach you take you have several options here if you do not want to trust a client then you need basically to have the client on the server hey I would like to move in a certain direction and then the server moves the client and sends the new position back we're going to see how to talk to the server with an RPC in a little bit but if you're making a casual Coop game and you're okay with trusting the client then there's a much simpler approach over here on the docs if we go into the network transform page and we scroll all the way down here we see something called a client Network transform this is basically the same as a regular Network transform except instead of just having ownership on the server you have ownership on the client itself meaning that the client can move itself and then tell the server where that transform should be this class is not included in the default core package so we need to add it here and as we can see we need to add from git URL and copy paste this URL so let's copy this copy this URL then over here in the editor let's open up the package manager click on the plus icon let's add from git URL and let's face URL and add and yep there you go it is downloading and installing and if there it is it installed the multiplayer samples utilities so on this one let's go back into our player prefab and here we are inside and let's get rid of the network transform and instead let's add a component and let's search for client Network transform yep here it is let's add it and this one as you can see has the exact same properties so let's do the same thing so do not want to send any of these okay just like this and by the way if you want to see the difference that makes this one have ownership as opposed to the other one you can just right click on this one and go into edit script this one opens up the script that we download from samples and as you can see this one just extends in network transform and all it does is wrong just overrides this so is server authoritative and makes it false so if you want you can just copy paste this code you don't need to install the entire samples okay so this is really all we need to do just make sure we swap out the network transform for a client Network transform so let's exit the prefab make sure we save the changes okay let's make another build okay here we are let's make this one a host make this one a client let's move the host and yep it sound works the same as previously now if I get into the client and I move this one and yep there you go this one does work so this one moves and the host is over there receiving new position so both of them work both of them are now networked all right awesome again there are many ways to move and synchronize objects which one you choose is really up to you it all depends if you are okay with trusting client or not which is going to depend on the type of game that you're trying to make so we already have a super simple way of synchronizing transforms that is really awesome now let's look at another way of syncing some data we're going to be using something called Network variables which like name implies lets you have a variable that is synced over the network so let's go back here into our player Network script and over here let's add a field so a private we're going to use FType Network variable and this one as you can see uses generics for the type if you don't know about csharp generics check out my quick video on them so for the time let's start off simple and just synchronize a simple integer that's it now one important thing about Network variable is it must be used inside a network Behavior class if I swap this out for a regular mono Behavior then this will not work so let's try running our code just like this so here we are and as soon as I try to make host and up there you go I've got an error as it says here all Network variables must be initialized so over here when we Define our Network variable let's also initialize it so let's say we knew and then over here we've got a bunch of default parameters if you want to use the defaults and you can use it just like this or you can start off with the default value so let's say start off with one also very important is you need to initialize the network variable either here on definition or as soon as the object is created you can now create it on a later update for example so we have this variable and now let's modify it and modifying it is super simple so we just need to access it and over here and let's do a simple input test so let's go input get key down let's say for the D key so when we press it let's modify it so inside we go inside we modify the value and we set this to whatever value we want so let's get a random number just testing okay so when I press the button it is going to modify the value inside the network variable and now let's see we debut.log just to be able to see all the values so let's go up here let's go before the is owner because we want to see the value stored on every single client so let's go here and let's see we debug down log let's do the random number dot value let's print this and let's also print the client ID just so we know who is printing this message we can use the owner client ID that exists inside Network Behavior so let's print this so the owner client and then the random number all right so let's test this so here are both balance let's make this one a host and this one a client and over there we can already see the random numbers so as you can see both of them client 0 which is going to be this one the host and client one which is this client both of them are receiving the same random number one which is our starting number now let's see what happens when I press the T King and if there go that one didn't update the random number is now 50 and as you can see over here the client the client also received the update this one also received A50 so Network variable is how you can easily synchronize variable across multiple clients you just set the value and automatically gets propagated throughout all of the clients so change to all of them and yep all of them receive the same value however again here we also see another interesting thing related to the same problem which is If instead of generating over here so I'm pressing T I'm generating over here on the host and yep it does work it does again synchronize however if I go into the client and on the client if I press the T key and if there you go we do see our error let me just reverse the order so we can see the error over here on the ENT editor so make this one down here the host this one up here make it the client and now if I press the T key on the client and if there go there's the error client is not allowed to write to this network variable again we go back into the same thing about Network for game objects where by default it is only server authoritative and like I said this is up to you whether you want to keep it this way you could make the client always ask the server to modify the variable or you can also enable the client to be able to modify themselves directly how you do that is over here when we construct our Network variable as you saw we have a bunch of parameters so the first one is the default value and then we have the read permissions and the write permissions you can see defaults are that everyone can read but only the server can break to it and you can modify them so first of all the read permissions we can set it to everyone which is default or only the owner and also the server although I'm not sure I can really see any scenario where you would want a limit reading so for this one you probably really want to leave it on everyone and the important one is over here on the right permissions for this one you can make it so that the only the server can write or you can make it so the server and the owner can write so other clients cannot write to the network variables of other clients only their own and of course the server can write to anything so let's go with this one let's go with owner so on this network variable everyone can read but only the owner and the server can write to it and since I'm here on our code we're only getting down here if we are the owner then now we should be able to modify this so let's test so here we are I have a host appear and a client down here so if I go into the host which again hosts to access both a player and a server so on the host if I press the button if I can indeed modify the variable and get synchronized over here on the client and now if also go into client and if I press the button any of now I am indeed having control and being able to write over that Network variable which then gets synchronized over here on the player so the client can generate something the server receives it the server can generate it and the client also receives it so with this you can make the client be able to write on the definitive variable however again like like I said if the client are to write onto the network variable of this other client then it would not work the client can only write on the network variables that this client owns another thing related to Natural variables is you can listen when the value is actually change so instead of reading the value on every update like we're doing here instead of that we can do something different so over here we can go inside the network variable so let's right click and go into definition and over here yep we do see that we have a nice event on value change so we can hook onto this one although I should point out this does not have the event keyword so this is technically just a callback but it still works the same so we can subscribe to this and usually you would do that on an awake but like I said a while ago when working with networked objects you should not be using the wake or start for anything related to networking instead you should always overwrite over here the on network spawn for anything related to networking make sure you do it over here and not on start or awake so let's copy this and overwrite this one so back in our player script let's make this one and set a virtual let's override it and over here you can subscribe just like you would for any event so on the random number let's go into the on Valley change and subscribe to this we can go check out the delegate to see the signature that we must match which is a previous value and the new value so you can make it a function or just make it over here in Lambda so in this case the type is in so the previous value and then for the new value so instead of doing the debug.log on every update let's do it just on this one okay so let's test so here we are and by default you can see that nothing was synchronized because it's synchronized by default value so that on value change does not trigger on start but now if I select over here the host and I press the button and if there you go it generates a random number modifies Network variable and client does receive it and now move it over here on the client and yep that one is receiving every time I press it receives a new one so everything gets synchronized Everything Changes only when I want to change okay so that's great everything is working exactly as intended now so far over here we've just been using a simple int but you can use any of the basic types here so you can use an end a flow table and so on the only limitation is that the type must be a value type if you don't know the difference between value types and reference types go watch my quick video on that topic basically you can use things like int and Float but you cannot use things that are references which can be known so for example over here you cannot use a game object or a transform you cannot use that here because those can be known however one thing you can do is create your own custom type to organize some data you just need to make sure that entire type is also a value type so over here and let's make it so let's make it public make it a struct again it has to be struck cannot be a class it goes back to the same thing so structs are value types whereas classes are reference types so let's make it a struct come with my custom data and let's open it and now inside we can store whatever fields we want so let's say an INT for a simple end let's say we also have a bow for example ball and so on so this is our custom data and now up here instead of using this let's use of this type and then for defense let's create a new default so my custom dyno let's default with an INT of let's say 56 and with a boom let's save true then let's leave it readable for everyone and we'd own a right permission okay so that is working and just down here just swap it out so the end previous value and the end new value and let's print out the new value so here we have the new value and then inside let's access the end and let's also print out the bone all right so that's logging down here for modifying is the same as you would modify anything so you modify the value and in this case we construct our custom data and let's set whatever values you want so let's put a different number and a different volume okay so just like this let's test so here I have both builds let's make this one a host and this one down here makes the client and yep as soon as I do yep here we do see an error they are selling those that our custom data type is not supported by a network variable that is because this is a custom data type that we made and the network manager does not know how to serialize our custom type so for that when working with custom data types we also need to implement the interface I Network serializable so over here let's use the visual studio quick actions to implement the interface and there you go we must implement this function and now we can just easily serialize these fields by accessing the serializer over here on the parameter and just go and call serialize Value and let's zero let's just put ref and for our int and let's also serialize our bone okay so that's it that's all you need to do you've got the custom types here and you are serializing them here so if we test like this so now here let's make this one the host and this one join the client and yep it does work no bugs no errors and I'll press the T key here and if there go with it synchronize did send that one press the D key here and yep the client id1 also synchronized perfectly so our custom data was indeed correctly serialized and sent over the network okay great everything works perfectly now one data type you might want to use would be a string so a public string for a message however over here we do see a warning all the films inside of here must be not nullable so they must all be value types and the issue here is that string is a reference type it's actually a bit more confusing than that because string is a reference type but also sometimes works like a valley type but over here it is used as a reference so we cannot use it just like this however what you can do is use a different type and that type is called fixed string and to find this type let's use the using so using unity.collections and the fixed ring is just the main class so we cannot use this one directly but if we search for fixed string yep here we do see a whole bunch of them basically a bunch of fixed Rings each of them with different sizes so these basically preallocate some memory which you can then use to set with some certain data but since it's preallocated it means that the screen cannot grow or Shrink so you must make sure to pick the right size and in terms of size one character equals one byte so if you want to send a message that is let's say 50 characters long then you cannot be using this one with 32 bytes that is not enough space so for sending 50 characters you would use for example this one with 128 bytes also the reason why there are two for each of these just because this one is deprecated so you must be using this one that is named bytes so let's use this fix type and if we use this and yep it does work we no longer have any errors then since we add another field we must over here serialize the value as well so let's see realize the message and then for reading and writing this ring it's pretty much the same as all of the others so let's add another log for our strings so the new value in this case is our message and then down here when creating let's add our new message all right so that's it let's test so here let's make a host let's make this one a client they are connected and over here I press CT key and if there go it did send the string message so this one receives it this one sent everything serialized all of it worked everything worked perfectly all right great so these are network variables which is one way you can synchronize some data like I mentioned previously there are many ways synchronize data for example instead of using the builtin Network Transformer that we saw previously you could just use a network variable to synchronize just a vector 3 for the position and then use that to move the transform another way of synchronizing data is using rpcs which are remote procedure calls you have two types you have server rpcs and you have client rpcs these are super easy to make but it can also be a tiny bit confusing how you make them is super simple so you just make a function and one very important thing is the name must end with server RPC so let's call it test server RPC then to make this a server RPC we just need to add the attribute server RPC by the way this attribute also has some optional parameters related to ownership but for now let's just use the basic default attribute now like I said the name must end with server RPC if we just add the attribute and we do not add that over here in Visual Studio nothing happens so there's no error however here in unity we do see an error so the server RPC method must end with server RPC so you absolutely must follow this naming Rule and the reason for why this wrong exists is so your code can be as clear as possible rpcs can be tricky in terms of where they execute so by forcing you to write the name correctly that really helps with that confusion and the confusion that I'm talking about has to do with where this code is run for example let's call this function so over here in our testing key instead of modifying our Network variable let's just comment this out and let's call our test RPC so that's it we just call this function and then over here let's do a simple log so debug download let's log test server RPC and let's also unlock this client owner ID okay that's it let's do a quick test so as usual I've got the host appear in the client down here if I go into the host and I press the button and yep it does work it does examine what you expect so it runs that function over here on the host okay right however now if I go into the client and on the client I press that button and look at that it did not run the function over here on the client but it is running over here on the host so as I press the button it runs that on the host as you can see the owner ID is on one whereas if I click here and I go this one is on zero this one is on one so this is the tricky thing I'm running the code calling this function over here on the client but the code is running on a completely different place in a normal scenario if the client were to run this function then very simply this would go inside this would run the log that's how it works in the normal case but that is not the case with rpcs basically when the client calls this function which is marked as a server RPC when that happens in the background the system interrupts the function call so this function does not run on the client at all instead it queues up a message for the server that says hey when you have the chance run this function so in using server rpcs remember that the code does not run on the client at all all of it only runs on the server and also the reason why it ran here as I'm clicking on the host is because again the host works as both a client and the server if I were using a dedicated server architecture with just one server and everything else would be clients and only the server would actually run the test server IPC now one more requirement that I didn't mention a while ago regarding the server RPC over here the name must end with server RPC it must have the attribute yep but then this must also be defined inside a network behavior and it must be attached to a game object with a network object now another optional thing is you can also use some parameters here so it doesn't have to be parameterless however just like with the network variables that we saw those parameters must be value types they cannot be reference types and again yet another weird exception which is over here you can deduce rings so I can can make a several RPC and over here receive a string let's say this is the message and then I can print out the message then up here when calling it I can pass in whatever message you want so if we test this so here in the host if I press a button and yep it does work it did receive the message and on the client if I press a button yep it's also sending a custom message to the host so if you want to do some kind of communication with strings then chances are you want to use a server RPC instead of using a network variable one more thing related over here with server rpcs is you can use the included parameter type which is the server RPC params we can inspect this time so let's frequently go to definition this one contains just two Fields so a send and you receive and we can inspect these so can inspect the send and this one is commonly empty so this one is pretty much just a placeholder that they might use for something in the future and then for the received params and here this one can receive the parameters for the center client ID so you can just make it like this so let's do the server RPC params and then let's print out the owner client ID of this network object and then let's also go into that one go into the receive parameters and let's grab the sender client ID and then up here let's create just an empty object so just new server RPC Brands so let's test so from the host I press the button and if there you go it doesn't receive with the sender ID of 0 and if I go into the client and I press and yep there you go it does receive that one so that's another way that you can figure out which clients and what message okay so that server rpcs it's a way for you to send some messages from the client to the server if you did not want your game to have client ownership in any way then this is the example which you would use basically the client would use server rpcs to ask the server to move or take some action and then the server itself would update the game State and send it back then we have the other type of RPC which is a client RPC and again we have the same naming rules so here let's make a private void call it test client RPC and we add the attribute the client RPC which again also has some parameters but let's leave it then here on let's just do a debug down log now let's do the same test so let's call this from up here get rid of this okay so it says just like this so here we are and on the host I'm going to press a button and yep look at that the client RPC ran on the host which again works as both a server and a client and the client RPC also ran over here on the client client rpcs are meant to be called from the server which are then run on the clients so the server calls the function and all of the clients all of them run that function but like I said client rpcs are meant to be called from the server which then run on the clients so if I go over here onto my client and in here I try to press and nope it does not work nothing happens the client cannot call a client RPC so I can press here as many times as I want and nope it does not run anything here and does not run anything on the host using this using client rpcs is just how you send a message from the server to the clients just like with several rpcs over here you can also use any parameters you want and also just like server rpcs there's also a default struct so in this case it's a client RPC params and again we can inspect this we can see that we have the same structure so we send and they receive and if we inspect the send over here we see something really interesting we see a list of the target client IDs basically with this we can Define which clients get what message as you saw by default the client RPC ran the code on all of the clients by using this we can Define only some to run on and the other thing to receive over here once again no parameters so just a place on there for possibly adding things in the future so let's try sending something just to one specific client so appear on the screen so let's create a new calendar PC prems and then inside we just want to modify the send so let's create a client RPC send prems and then in here let's create a Target clients ID so let's do a new list of uint and let's send to just client with an ID of one okay so let's see if this does run the client RPC but only on the client with an ID of one so here we are and the host appear is on client ID of 0 and the client down here is on client ID of one so if I go into the host and I send the client RPC and if there you go look how it does now run here and it only runs down here so we can Define and only send the client RPC to a specific line that we want so for sending messages from the server to one or more clients you use client rpcs for the next topic let's look into spawning objects so over here let's make a simple prefab just to spawn some object so let's create a new empty game object called the spawn object and then inside let's add a nice visual so let's add just a sphere and lift it up a bit a little bit put this one on y of zero okay so this the object let's just make a nice material and just make it visible so up here let's just make a simple material and drag the material onto this one and just put it in a different color all right so that's it just say nice glowing sphere now let's turn this into a prefab so just drag it over here into our founder okay there's our prefab and we want to spawn this so let's delete it from the scene we don't want it to be there by default now before we can actually spawn this we need to make sure that this object can exist on the network and like I said before there are two things that we need to make that happen so let's go into the prefab and first thing we need is the network object component so let's go into that component let's find the network object let's add this one and secondly every object on the network must be added to the network prefabs list so let's go into our network manager and here we've got the network prefabs let's click on the plus icon and drag the spawn object okay great everything is set up now for spawning it let's go into the player script and up here let's say the field to spawn it so let's set up here a centralized field make it of type transform and let's call the spawned object prefab by the way if you're wondering over here why I'm using transform instead of game object it's because those two types are pretty much interchangeable if you want to see differences go watch my quick video on it okay so I've got the spawn object prefab so let's go down here and when we have our input then let's spawn it just like we would do normally so let's call instantiate let's instantiate this transform just like this okay so let's see what this does so here I am with the hosts up here and if I press this button if there you go it does spawn the object however looking down here on the client we can see the client did not see that spawn object so the object will spawned but only locally on the host it did not spawn across the network so back in the code here in order to spawn it on the network we need to grab the network object component so let's first grab a reference to this one so the spawn object transform so we grab the reference of the spawn object then you go into this one and let's call get component and let's grab the network object so we grab that one and then from that one we can call the function spawn this one takes a parameter for destroy with scene let's set this one to true so that this works pretty much like any other object so if we were to change things this object would be automatically destroyed okay so just like this it should work it should now be spawned on the network so it should show up on the client let's see so here on the host if I press a button if there go it does spawn the host and also spawns on the client alright great however one more thing if down here on the client if I press a button to try to spawn it and nope there you go we've got an error we can only spawn Network objects directly on the server in this case there is no way to allow the client to spawn any network objects so if you wanted to spawn a bullet or something like that then what you would do is you would use a server IPC to tell the server to spawn that object and the server would spawn that object and send it over to the client now since we can't spawn objects let's also despond them and for that it's actually very simple we just destroy them like normal so let's store this reference so let's go up here and let's make a film for this so private and spawn are transformed so we save that reference so then down here let's make sure we don't save on to unlock on variable but we save onto that one okay so we have this one let's do another input so input so I'm going to press the y key and let's just destroy so just like usual just called destroy on this game object okay that's it simple Let's test so here we are and let's spawn it on the host and yep spawns on the host and on the client now press the other button any of their go gets destroyed both on the host as well as on the client okay great so as you can see the spawning is super simple although there are some more options when it comes to the spawning objects just like here on the network object you can correspond you can also call on despawn so we can grab this and instead of Spawn we can call despawn we can use it to despawn then optionally destroy or not destroy the object so this can be use only for some reason you want to remove the object from the network but keep the game object itself alive another thing are the options on the network component so if I go into the spawn object over here we've got the network object and there's this film for don't destroy with owner basically by default if the owner is gone for example if the client is the owner of some Bond prefab and the client disconnects then on the objects on by that point player won't be destroyed and if you don't want that to happen you can just stick this and this way those bullets those objects spawned by that client will still remain existent in the world in the server even after the client has disconnected so this could be useful for some more persistent online games with players jumping in and out Okay so we've already learned quite a lot of things about multiplayer so I've got my basic player I've got the hose and over here I've got a client I can move them all and yep everything does work however so far we've been playing just with a simple capsule for the player now thankfully adding a proper player with some proper animations is actually super easy so here I've got another simple demo except instead of just captions I've got a different prefab and this one does have a proper player character this one of these components these are just based on the official free Unity star assets which I covered in another video which is a simple and third person controller the only change I need to make was on the controller maker of type Network Behavior instead of mono Behavior then down here on the update again make sure to only run that logic if it is the owner then on the prefab I also added the network object component for this object to exist on the network and just like we saw previously I also added the client Network transform and since this one the object rotates I also include the Y rotation and finally on the network object itself over here on the network manager on the network prefabs list I swap that one out for the player prefab so let's do a quick test but before that let's make sure to go into file build settings and let's add this scene and drag it up top so that it's the first one on the bill so there you go I want to test out this scene so let's test okay so up here let's create a host and here there you go there's my player and on here let's connect as a client and if there you go both have been connected and up here on this host if I move the player and if there go it does work it does move and down here on the client if I move it yep it does indeed work however as you can see there are no animations being synchronized so as I move the hose down here it does move the position but nope it is not synchronized now like I said thankfully this is super easy to add let's go inside the player third person control prefab then on this one let's add a component let's go down into netcode and now let's add a network animator now over here the only film it has is just an animated film so let's just drag this animator onto this field and that's it nothing else so now this component will automatically sync up all of the parameters on this animator so if we test like this let's just make sure to save this prefab okay let's make a building test so if I'm here on the host and I start moving any up there you go it does work but you can see that the host is indeed moving and all the animations are being synchronized I can even jump and yep all of them work perfectly okay great however if down here I select the client and now I move the client and nope there's our issue so the client is not being synchronized basically the client is indeed receiving the animations from the host but it is not sending its own animations back into the host again this is the usual issue because by default most things on netcode for game objects are based on server authoritative so the animator will only sync if the server tells it to if I were to play an animation on this character on the server then it would work it would indeed synchronize the animations and just like with the network transform we can also modify this to give the client some Authority the docs here contain the code snippet that we need to use so if you go here onto the network animator and we scroll down and down here we see owner authoritative mode and all we do is we only just need to make a component just like this so something that overrides this Boolean and returns false so here I have exactly that so this owner Network animator and here on the prefilm let's just swap it out so instead of the basic Network animator let's use this one instead let's use the same reference for the same animator let's save the prefab and let's test all right so here we are and if I move the host and if there go it does play exactly perfectly so it works on both and if I go here and I move the client and yep it also works perfectly so I can move I can run I can jump and all the animations they are all being synced perfectly all right awesome so as you can see syncing animations is indeed super simple you really just add one component and all the animator parameters regardless of how many you have all of them get synced correctly now the next topic is the multiplayer tools package this is the one that we already installed in the beginning of this video there are two ways we can view Network stats one is with the profiler so if you go up here into window let's go into analysis and let's open up the profiler here is the profiler and the way this setup is by multiple modules so you've got CPU usage rendering memory and so on and if you scroll all the way down then down here you find the network for game object messages and the objects one really important thing is you want to be looking at these two so these ones that say NGO however there are actually two other profiler modules so if you click over here in order to select them you've got over here these two for Network messages and network operations these are not the ones that you want these two are related to the Legacy unit multiplayer so these are not the ones you want to use you want these ones on here the NGO so just with this we can try playing the game and see so here I've got my builds let's make this one the host and this one connect as declined and now we can view over here and we can click on each individual frame so we can click and see over here we are sending something to client one sending a server RPC message Network variable and so on so we can see how many bytes so sending 60 bytes and so on and if I move around yep you can see all the messages and you can inspect them and see everything that is being sent so this one is sending some parameters from the owner Network animator you can see the messages on the client the server and so on so lots of things over here you can play around with so this is one way you can view some data related to networking so both on the client and on the server so receive and send and so on so you can see a bunch of stuff here and there's another useful tool encoded in this multiplayer tools that one is not on the profiler but rather than let's create an empty game object so a new empty game object call this the runtime stats monitor and then let's add a component and let's search for runtime it's this one runtime net stats monitor so let's add this and over here you see a whole bunch of settings however if you look at the object then nothing seems to be happening basically this window gets created dynamically only when the game runs so if I now try running the game and yep over here we do see this window here with both builds we can now see the stats so let's make this one the host and this one the client and up over there we do see some stats so we see the round trip time to server this is how much time a packet takes to get to the server and get back now since we are making this in localhost I want to sing zero if we were playing the game through the internet maybe connect to the UNT really we would see something here then we also see the total number of bytes sent and received so this is super useful for analyzing just how much bandwidth you're using so over here for all of the network parameters all of the objects all the things that we're transforming here some of that data is around 400 bytes per second and now if I start moving we do see quite a bit more data being transformed so all of that being sent and we can see all the ones being sent and if I move this one we can see all the ones being sent and received like I said this is super useful for analyzing just how much bandwidth your game is using then we also see the number of packets both sent and received and then down here the number of rpcs both sent and received so these signals are very useful for analyzing how your game is performing so if you're sending way too much data you're going to be able to easily sit in here and if you're sending just custom data you can verify that it is only sending the exactly the things that you want now let's learn more specifically about Connections so if we go into our network manager object down here you can see that we're using DNT transfer that we set up in the beginning of this video so this is what actually handles sending and receiving all the packets so it's on this component down here on the connection data this is where you set to connect directly to an IP on a certain Port you can use whatever port number you want as long as nothing else is using that port and by default as you can see the IP is connecting to 127.0.0.1 this is the default localhost address this IP always refers to the unlockable machine that the game is running on so if I were to make a build just like this and I tried connecting the client from another PC it would not work work because that other PC would be trying to connect to itself and not to this PC so in order to make an online connection it is very simple you just need to find your local IP and set it here so in my case on my PC my local IP is 192.168.1.8 so if I put this that's all I need to change so now if I make a bill just like this so here I've got my bill now I'm just going to copy this onto my laptop which is also connected to the same local layering Network so here I've got my build and on this one let's make it a host and now on my laptop I'm going to click the button to make a client and click and if there go the client at connect so over here on this PC yep I've got my host and on my laptop yep I've got the other client so I can move both of them and Yep they're both fully working so with this I have a connection between two PCS both on the same local area network as you can see making online connection really is that simple however when it comes to connecting online it is a much tougher problem you can attempt to do the same thing so go into the network manager and down here instead of using the internal IP you can use the external IP however in doing that there are many things that can go wrong and the reason for that basically has to do with net or network address translation basically routers have firewalls and they usually are prestricked about blocking any seemingly unwanted traffic so if I just put my external IP here that is really all I need to do on DNT signed however if then someone tried to connect through the build it would likely fail that is because by default my router would receive a connection on this port and my router would not know what to do with that connection so it would probably just block it I have both this PC and my laptop on the same local network so my router would not know which of those PCS should receive this incoming connection Nat or network address translation that is connecting from an external IP onto an internal IP so in order for an external connection like this one to work then basically you need to ask the player to go to their router and set up port forwarding they basically need to tell the router that when they get a connection on a certain port that connection on that Port should go to one specific machine on the local area network that is what you need to know in order to make sure that an outside connection doesn't need to go through the router and go into the right PC now as you might imagine asking players to manually hand on port forwarding is not a very good thing players do not want the hassle of dealing with all of that so you have a bunch of alternatives to handle this problem there's a real nice page on docs here if you go into Concepts and FAQs and then over here into a listing server and host architecture down here you see all of the various options that you have so the first option is port forwarding so just like I mentioned the users need to manually open ports on their router in order to forward the packets to the right PC that can be a problem since users might not have the technical knowledge needed to do that or they might simply just not have access to the router another option is using Nat punch through so this is basically a technique to try to handle on port forwarding automatically it basically tries to open a connection between two IPS on a certain port and if the connection does get open then the router essentially automatically handles support for recording if you can force a connection to go through one way then it won't automatically open the other way but as to whether this approach works or not really depends on the technique used over here you can see a whole bunch of links for a bunch of techniques and it's also going to depend on the router in question so maybe it won't work or maybe it won't work these techniques here are pretty complex so I might cover them in a separate video first I need to do a bunch of research and then we've got the third option over here the relay server this is how you can basically have a third party which is a server somewhere on the internet that all of the clients can access to since the server is on the open internet then everyone can automatically connect to it so that means that this one always works however of course by adding that third party into the connection you end up with quite a bit more latency since the packet needs to go let's say from the host to the relay and then back to the client and then we have the final option of all which is pretty simple first you try to do some Nat punch through if that works in great if not then you fall back into the brainly so this is the best option of all if Nat puncher works then you have a direct connection so everything works perfectly but if that fails then you can fall back into the relay which always works this way you always get a connection and you also avoid using the relay whenever possible so with all that said the entity has an official relay tool as part of their Unity gaming Services if you don't know about TNT gaming services this is their brand with tons of game related Services there's about 20 tools I made a video doing a quick overview on all of those so really is the efficient way to handle that and here I wanted to include a guide on how to use enti relay but that requires quite a bit of explanation and the video is already super long so I'm going to include that in a future video alongside two other things which is Lobby and authentication so I'm going to make a separate video on how to get all of that working basically it requires using Unity authentication then you need to ask the relay in order to reserve a server with a certain amount of player slots then when the service is reserved you get a string ID which you can then use on the client to connect to the relay or join a Lobby you can check out documentation over here for the relay in order to learn how it all works so if you want to edit yourself before I make that video or if you're watching this in the future then check the link in the description alright so that's quite a lot of info about netcode for game objects with all that you'll learn here you can already get started making multiplayer games but at the same time this is a massive topic and there's much more to learn so before I end this video let me quickly mention a bunch more features and resources for you to dive further into one interesting thing is connection approval so by default as you saw whenever a client connects then the host simply accepted but let's say you want to limit the number of players well you can use the connection approval in order to get a connection and decide whether you want to approve or disapprove that connection another interesting concept is object visibility this is how you can Define if an object is visible so if it should be receiving some data or not if you use this correctly and you've got a massive game with a huge world that you can really cut down on unnecessary bandwidth then you also have Network object parenting so if you want to change the parent and runtime then you need to do this in a very specific way there is session management so this is how you can handle when a player drops out of the game and then reconnects and you give it the exact same point ID in order to continue from the same data if you're spawning tons of options and definitely make sure you look into object pulling one potentially very useful tool is called parallel sync this is a unofficial tool so it's not made directly by unity what it does is pretty much duplicates your Unity editor instance so you don't need to constantly make a build just like I was doing for all this video you can get it on GitHub so it's all open source another testing thing is on the transport layer you can simulate packet loss over here on the NT transport down here on the debug simulator you can add a DNA in microseconds Jitter and a certain drop rate this is definitely necessary to make sure that your game doesn't break if the player is lagging so you don't have any race conditions or anything now like I said many times you have the option to go with server authoritative or if you want to also give the client some ownership depending on your game that is a possible thing but also make sure that you know about the potential issues so here I made a post in the forms and Chris gave a great reply with a ton of potential issues whether these are a problem or not really depends on the game you're making also now that you've seen this video and you know the basics then you can go ahead and dive deep into Unity samples the most complex one is boss room it's a really awesome sample and by now you should be able to understand everything in that code base and related to multiplayer are the various antigaming Services tools again I'm going to cover a bunch of these in a future video so basically we've got the lobby to create various lobbies for your players to join then you've got the relay which is how you handle the connections you've got Matchmaker in order to use some logic to match players with one another and you've got multiplayer which is how you can handle dedicated game servers and of course all of it integrates very well with netcode for game objects alright so that's the video now you know how to use netcode for game objects a lot of people request this topic so I'm happy I was finally able to cover it now that it reached 1.0 this video Took a ton of work to make so I really hope it helped you if you liked it please hit the like button it really helps and maybe consider getting one of my courses My ultimate TNT overview course is found with excellent info that is useful for pretty much anyone using ENT alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and I'll see you next time