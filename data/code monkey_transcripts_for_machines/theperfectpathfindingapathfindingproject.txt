hello and welcome i'm your code monkey and here's the first video in a really interesting new format the asset store is full of awesome assets so i figured i could review and highlight some of the best which can greatly help you when you're making your own games now for this first video in this asset review series i chose to highlight a really special asset for me the astar pathfinding project this is the one asset that i've used the most and it has already helped me ship several steam games so here's the story back when i was first getting started with unity my very first game survivor squad was a strategy game where i really wanted to have hundreds of units and thankfully i found this asset pretty quickly which really helped me develop that game in a decent time frame if i had tried to make my own custom pathfinding with support for that many units it would have taken me ages whereas this was already set up with multithreading which made pathfinding insanely quick even for hundreds of units now you might not think that performance is all that important if you just have a handful of characters in your game but it really is the less time your pathfinding takes to complete the more time you have for other things like more objects more effects to really make your game stand out so i can definitely tell from personal experience that this is an excellent asset that will help you greatly to solve all of your pathfinding needs and this asset is now eight years old with nonstop constant updates the change log is massive so you know this has been thoroughly battle tested in just about every scenario as always there's a link to the asset in the description and that's an affiliate link so if you pick it up through there you'll also be helping out the channel and as a bonus you can use that link and then use the coupon code monkey10 to get 10 off your order so the a star pathfinding project it's a super fast path finding solution it supports dynamic scenes that are constantly changing procedurally generating worlds works on moving objects easily supports elevation works in both 2d and 3d it's really versatile and just like the name implies the underlying algorithm is a star if you're curious about how the algorithm works i made a nice video going through it step by step you can go watch that to get a better understanding and just by looking at the very simple implementation that i do in that video and comparing it to this one you can see how the performance difference is night and day now i've imported the package here and as usual it contains a bunch of documentation you've got an html file or a pdf and you can also find all of the updated documentation on the website the documentation is extremely detailed so you can really get it to work exactly as you want it and it also comes with a total of 16 examples so you can see it in action in pretty much every scenario imaginable you've got simple movement pathfinding on the terrain one with links for jumping or a door that opens and closes another one showing pathfinding in a procedural world another one on a moving object and so on so this video is split in two parts first we're going to look at the demos to see what the asset can do and how they work and then after that i will do a quick stepbystep guide on how to start using it and add it to your own games let's first look at the simplest example possible so over here on example 3 so we have this mod character and it's following the mouse position so i can move the mouse around and it recalculates the path pretty much instantly down here on the console we can actually see what the code is doing so you can see how it's searching for all these paths searching for all of these nodes there you go the path length and you also see how long it's taking so even if i put it really far you can see just how quickly it works so it pretty much always runs down to zero milliseconds so it's path finding so obviously it goes around these objects then it also supports elevations over here we've got a ramp and yep it automatically knows how to get up there and the graph can also update in real time so i can press as it says here press p to place an obstacle and i press and there you go drops a bunch of obstacles and if i put it yep it recalculates and knows exactly where those are all these examples also have these useful messages teaching you how the asset works so for example here it's saying the a star game object has all the settings if we put the game in the scene view side by side we can see what is happening so over there you see a gizmo for the path as it's being calculated and you can see how fast it calculates and just in case you don't see this graph you can select the a star object and in here make sure you have show graph sticked so this a star object contains the pathfinder script this is the main script with all of the parameters the main ones are for the pathfinding area so you can see here the width and depth in terms of voxels and then down here you can see the size so we can just modify this make it smaller hit on scan and there you go to make sure that this area is walkable you can also decrease the cell size so doing that it splits the area into more and more nodes so this allows for more detailed paths obviously the more detailed you go the more time it takes to calculate so you can manually scan by clicking here or it will automatically scan as soon as you enter play mode we can see how it updates in real time so if i spawn a bunch of obstacles if there you go that's what it does so as soon as the obstacle touches the floor you can see yep it updates perfectly so it creates a brand new nav mesh taking these positions into account so you can play around with all these values then you hit on scan and make sure you've got enough of the area covered so next up if you scroll down here you see the settings tab and right away you see one of the most important ones so the thread count you can set it to multithreading which will run pathfinding pretty much without any performance cost so if you were to use this in a final game you'd probably choose one of these you automatically load or hallowed then you also see a whole bunch of debug settings first up the path logging so you can make it really verbose or only show errors or don't show at all then you've got some graph coloring so you can essentially visualize various different things from the path so for example you can set it to show the gene which is one of the parameters used in the calculation and then up here take it to show the search tree and if we play you look at that now we get a nice visual representation of the path as it's being calculated so there you go really nice really fun to see this in action then you also have a whole bunch of colors that you can customize you can give a bunch of names to the various tags then down here you also have saving and loading so instead of generating the graph and runtime you can generate it right now and then save it onto a file and then you also have a whole bunch of optimizations so these are for more advanced use cases and finally you have the about tab which showcases a whole bunch of information the asset automatically searches for updates and lets you know if there's a new version alright so that's the main pathfinding script the pathfinder now for the other important scripts they are on the player themselves so in this case we have our bot character and right away the first one that we see is the seeker component this is what handles the pathfinding calls and does a bunch of postprocessing on the path over here you can define what graphs are traversable by this unit and then you can also specify a bunch of tags see if they are traversable and if they have any panel then you have the ai path component so this is the script that actually follows the path calculated by the seeker for the parameters right away you can see the repath rate so this is how often the ai won't recalculate the path to the target so the default is at 0.2 so 200 milliseconds so 5 times per second if you have a game that changes the pathfinding map a ton you might want to lower this on the other hand if you have a very static pathfinding map you can push this higher to make it even more performant then you have the various movement parameters how it actually moves will depend on what other components you have attached to this object for example in this case it has a character controller so it's going to use that to move if it just had a rigid body it would use that and if it didn't have any of those and it would simply move the transform position directly so all of these parameters are pretty selfexplanatory so you've got how fast it moves a bunch of acceleration whether it's in 2d or 3d rotation then how far from the final distance does it start slowing down and how far from the final distance does it stop should it use gravity or not and so on by the way every single one of these components has a detailed explanation in the documentation you can go into edit script so here is the script for the ad path as you can see it's got tons and tons of comments then you can also go into the actual documentation to see even more information so definitely look into that if you want to learn more about a particular component so the ai path is the base movement script but you don't absolutely have to use this one you can write your own script to follow the path generated by the seeker but this is a great starting point and then the postprocessing that the seeker does is depend on the modifiers that you add onto this object so in this case it just has the funnel modifier if we disable this and hit play we can see what the original path looks like there you go over there we can see the path as it's being collided and as i move it yep you can see it's very jagging so it's essentially only going down to the center positions of each polygon so that's how the original path is calculated and then if we enable funnel yep now you see the difference now it actually funnels the path and makes it into a proper path so as i put it in there yep there you go a very nice mood path this is just one of the included modifiers you can go into add component and then here go down into pathfinding and go inside the modifiers and up in here you've got all the various modifier algorithms that you can apply and the final thing on this demo is the ai destination setter this one is an extremely simple script all it does is it grabs a reference to the ai path script and then it goes to that one and simply sets the destination directly to this target and the target itself is based on the mouse position and like i said in the second half of this video i will go through a quick getting start guide on how to implement this from scratch all right so that's the simplest example to see this asset in action then over here on example four we have an example using links so this character has the ability to climb up drop down and so on you can double click in order to set it to a certain position so if i put it right in there he's gonna go he's gonna drop down from there then he's gonna make a jump and so on so there are links between these various pathfinding areas and by the way if you find the video helpful consider subscribing and hitting the like button it really helps out the channel and over here on the scene view if we select the a star path we take show graphs and we hit on scan now we can visually see the links so we can see in blue all the walkable areas and over here we can see the various links so this area is linked into that one down into that one and so on as for how the links are set up they are set up in certain objects so in here if you click you go inside the ground inside the link and over here you've got the various cubes so here we got this one so that's that for area and then inside it there's a link game object and this game object contains this animation link component now this is a custom component made specifically for this scenario to play the jump animation but if you go on to add component go down here into pathfinding here you see link link two and link three so these are the three link types that you can add which is always you can go check out the documentation to see how they are different but in order to make your own link types to set up how your units handle various links you just extend one of those types in this case it has this link and then it has a child game object which is the final position on the link so it connects that position onto that one again the documentation is extremely useful if you want to implement your own links then for the bot on this example this one is using the rich ai so this one essentially builds on top of the simpler ai path and that supports for the links that we see here and then for playing the animation it also has a script so this example showcases how you can link various areas together now let's check out over here the example 5 for the point graph this one showcases a different type of graph so instead of a nav mesh we've got a point graph so this is perfect if you have a game where you want the player to only move through some specific areas so if i put the mouse right down there he simply goes to the closest position and never actually goes down into the void so it always stays within the path again we can inspect the path and scan it to see it in action so this one is using a graph of tai point graph and for the root it takes in a transform so for the transformer if we expand this we can see this one and it's in here that it has all the various nodes so all of those nodes are child with this transform then on the settings for the point graph over here we've got a max distance so it will automatically connect all the nodes within that distance and beyond that you can also add some manual links like we saw in the previous example so for example over here this one and this one are too far away so the algorithm will not automatically connect them but if you select on this one as you can see there's a link component and then it has a reference to this one so it's manually linking both of them so this is how you start with the automatic generation and then you can smoothly add the things that you want so this one is an extremely useful graph type for something like an adventure game where the player should only move through a certain path next up over here on example 7 we have a door example this one is showcasing the pathfinding updating a tag which in this case is set for the character to not go through closed doors so if the door is closed and i tell it to go there nope it doesn't go but if i talk on the door as soon as the door opens yep now he goes now i close it again now i don't go back nope and as soon as i open it does over here we can see the graph updating in action the part under the door has a different color so that's the visual representation of the tags on the astar object if you go down here onto settings onto the debug you can see graph coloring is set to tags so that one is a set as blue so right now it has the open door color and if i tug on the door yup you can see it turns into green so it's showcasing the different tags then on the bot itself it has a seeker component and over here if we expand the tags we can see how it's set up so it's set up for the basic round open door and all the other tanks all those are traversable except for the closed door on this one it is not reversible and then on the door itself it has this door control script it has an open tag enclosed tag id and for the script itself down here that has a simple setstate component and what it does is it creates a graph update object this is how you update the graph you create this with the bounds for this object so that's how it knows what area it should update in this case it's just said to modify the tag set the tag and it's going to set the tag to this tag so either the open or the close tag so you create the graph update object and then you call the astar path and you call to update graphs and pass in the update object so here it is an action opening and closing and you can see how the tag changes and for the bot right now i tell them to move and can move in here but if i doubleclick in there nope doesn't go open the door and now it does go so that's how simple it is to update the graph then there's a second door example and this one functionally it works exactly the same way so i try to go there can't go open the door and all of a sudden he goes there if we play the scene we can see the actual difference so in there we visualize the graph mesh and right now you see that it's actually cut so these two areas are separate and as i open it yep there you go you can see how the nav mesh constantly updates so it's closed and now it opens so instead of modifying tags this one is actually modifying the underlying nub mesh so this is a different method and this one is using the nav mesh cut component so here it is constantly cutting the mesh then here is example 8 path types this one showcases all the various path types that you can use so first of all just a simple a to b then you've got a multitarget path so this one finds the point from one position into many then you've got a random path which like the name implies gets a random path within a certain distance then you've got a fleet path which essentially takes in a position and then flees away from that position so very useful for tons of game logic then another one is for identifying all of the nodes within a certain range and then on the flood path you can search for the whole entire graph for every single node searching from a single point if you look in the console you can see that this takes quite a bit of time so it takes 10 milliseconds however if you cache those results then you have pretty much free pathfinding so if you go back into the av path and here as i click if i go towards the edges you can see that it takes between one and two milliseconds however if i use the flat path tracer this one all the paths were already calculated so no matter how far i push it now it's always zero milliseconds so that's the benefit of caching and here you can see you have tons of ways of accommodating different paths then on example nine we see penalties we have two bots one of them absolutely cannot go through the restricted areas and the other one tries to avoid the first area so if i got both my bots in here and i try to move in there there you go one of them goes all the way around and the other one goes through there and tries to avoid touching the restrict there you want as much as possible however if i go in here and i go down there then it does go through the restricted area so there's a penalty but you can still go through it now these areas are set up as tags and they are defined in these two graph update objects so these have the graph update scene and over here you've got a list of all of the points and in this case it's set to modify a tag and set this tag then on this other one it has this different shape and replies different tag and finally on the bots themselves we can see that it's using the same thing so on the seeker this one restricted area has a penalty of 300 whereas the other one is simply set to not reversible then on example 10 we see a layered grid graph so this is a grid graph that also supports elevation so a normal grid graph which for example is the one being used here on example 9. on this one if we set it to shutter graphs and head on scan here we can see it's using a grid graph and there's this slight overpass here and you can see what happens so it only identifies the overpass above and it does not identify the area underneath but if we go into example 10 over here we have the same map but if we go in there we enable we scan and yep now this one does identify both areas so that's the layered grid graph then on example 12 we see a procedural generation so here's the bot in a randomly generated path and i can double click to set it to move and as he moves it generates more so here i go and if i move towards the edge of the square as soon as it gets to a certain point then he's going to generate a brand new area and start populating it and so on and if we select the pathfinding we can see enable show graphs and yep we can see how it's constantly updating so there's an area around the bot it's constantly updating so regardless of how the world is generated it's always finding a path you can even set the bar towards an area that does not exist so the bot is going all the way up to a corner there and as soon as he goes and he accommodates the path he sees this one is different different and then it merges with that one and so on so it's constantly updating next up on example 15 we see a 2d example so this one is using the xy plane instead of xz the obstacles themselves they simply have a box converter 2d so as i click he knows exactly how to get there and for the path this one is using a grid graph with 2d physics and collision testing so as i click anywhere he knows exactly how to get there for the ai scripts it uses the exact same seeker and then it can use the exact same movement script here it's using the alert for moving perfectly but you can apply smoothing to the path or use the ai pathfinding from previously alright so we've seen a whole bunch of examples there's quite a lot more this asset is extremely versatile and detailed if i were to go through all of them this video would be one hour long there's tons of stuff there but by now we've seen enough of what the asset can do so we should be able to use it so let's see how you could add it to your own games here is my demo scene with some very simple rts controls i made this from scratch in another video so go check the link in the description i can just select a whole bunch of units and tell them where to move so very simple stuff and on the cursor i just have an animated cursor as just a little bit of fun now as i mentioned in that video this does not contain any pathfinding they just blindly move towards the target position so if i try to grow and grab that item nope they just ram straight towards as well and then there's an enemy down there so as i click on it instead of going all the way around nope they just ran towards the wall so let's use our awesome new asset to solve our problem so the first thing that we need is to make our a star game object so let's make a new game object name it our astar and let's reset the transform to keep things nice and organized then here let's add component and search for the pathfinder component and here we expand the graphs and now we choose what graph type we want so in this case this is a 2d demo so i'm going to go with a grid graph then go ahead and take on 2d and right away we can see our graph shape now for node size this is the size and units of each specific node naturally this will depend on the unit size that you define for your sprites so in my case i'm going to put it at five then you just need to extend the width and height to occupy the whole area so as i zoom out let's make sure it occupies the whole area okay that's a good size then over here for the connections we can leave it with eight connections for each cell so essentially it's got diagonals as well then make sure you take to the physics then for the collision testing you know let's go with a circle with diameter of two and then for the layer let's select the one layer so all of these wall objects they've got box and letters and they're set to the one layer all right so that's pretty much it and now if i hit scan if there you go now i've got the map and it's fully working so it identifies the walls and it identifies the wonka bone areas alright so it's already working now let's make the units complete and follow a path for that over here is my unit game object now this one is set up using the modular character controller that i made in another video and for the movement it's using this move position direct script so what that does is it calculates the direction straight towards the target and sets the velocity to move towards it so like i said direct movement there is no pathfinding now to use pathfinding we first need to add the seeker component so this is what actually calculates the path everything with defaults should be fine right now i don't want to play around any penalties or any tags so the default is fine then we add the ai path script again for more complex use case you could extend this but in this case this one is more than enough for the read path right here let's put it at 0.1 so it updates quickly then just set these values depending on the size of your sprites so in my case putting max mean and then i do want them to move really quickly so let me put with my acceleration of 500 for the orientation this is a 2d game so go with that one for rotation i don't want this game object to be rotated for the next waypoint distance yeah sure a bit more than that should be fine for the slowdown maybe on 10 maybe on 5. now again the values that i'm using here are obviously related to the size of my sprites my 2d characters are about three units tall so if you use different sprite size then naturally you need to play around these values okay so that's pretty much it we've got the seeker to accommodate the path and the ipad to phone with all we need to do is just grab this ai path and then set the destination so for that let's remove the scripts that i'm using to move directly so i'm going to remove this one that completes the direction and this one that sets the rigid body for listening instead i'm going to add this move position a star pathfinding script now this script is pretty much empty all that it matters is that it implements this move position interface so this is just how my basic unit is set to give orders towards the target move position this unit rts script is what listens to the player input and then just goes into whatever script implements that interface and sets the move position so here in order to use pathfinding it's very simple we just need to grab the ai path so let's make a private ai path and now we need the namespace so up here using pathfinding we get that and let's say on awake grab the path and then on the set move position we're simply going to set the destination destination towards the target move position all right and that's it just like this it should already be working let's test so here i am and if i select it and tell it to move here yep there you go it does move towards the target position and now if i go straight towards trying to grab that item and if there you go he does go around the wall alright so we have pathfinding and it is indeed working now if we look in the scene view we can see what's actually happening so we select that one tell it to move there and there you go that's the calculated path so as you can see it's quite jaggy so just like we saw we can apply a modifier so simply go down here and let's add the funnel modifier and now if i click yes there you go now i've got a nice smooth path so as i go there yep nice and smooth so here it is let's take this guy go grab that item you go grab that item and yep it does work and you go down there yep he does go around it he goes towards the enemy and shoots the enemy alright so yep we have all of our logic and all of our pathfinding working all right awesome so there you have it that's how easy it is to add you just had the pathfinding object you set up the grin then on the unit you add the seeker to calculate the path and the script to follow it like the builtin ai path the logic in 3d is exactly the same you just use a different type of graph and change some parameters now you can build upon this and implement all the features that we already saw like the restricted areas updating the path elevation and so on so that's the astar pathfinding project it's very easy to add extremely fast and works on any scenario if you need a pathfinding solution then this is all you need as i said i've already used this asset to ship successful steam game so i can vouch for its usefulness go get it through the link in the description and as a bonus use the coupon code monkey10 to get 10 off your order using the affiliate link helps support the channel and you get an awesome asset to help you in making your games i hope you found this review useful for your own projects let me know in the comments any suggestions for other assets that i should review next thanks to these awesome patreon supporters for making these videos possible thank you for watching and i'll see you next time