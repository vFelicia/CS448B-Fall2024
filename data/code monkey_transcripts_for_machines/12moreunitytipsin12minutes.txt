in this video we're going to look at another 12 unity tips in about 10 minutes this is the second video on unity tips so check the playlist link in the description alright let's begin alright so tip number 21 avoid update performance traps there are certain things that have a pretty significant performance cost that you should never use on update for example over here i've got three examples so we have git component we have find and we have the camera main so here's the code that i'm using for testing just calling these functions which then do the various things a handful of times so if we run and look in the profile we can see the time that each one takes so in terms of time we have test component taking 40 milliseconds test fine taking 40 and the test can remain taking 16. now previously actually camera main used to be one of the worst what this one would do is it would look for every single object in the world and compare the tag to see if the camera is tagged with the main camera tag so here in the scene view i have my main camera as you can see it does have the tag main camera so previously this used to be extremely expensive however in recent unity versions that process is now much faster but still you should cache the value when possible then the other two over here you can also see that they have issues calling get component takes a bit of time and doing a transform find a child also takes a bit of time so the approach for these should always be to cache the values that you need so you would define some member fields to hold all of these values and you would grab it simply on a wake or on start so you grab it just once and then down here instead of calling these potentially expensive functions you would simply use the values that you stored previously on the fields so for the most part you should never use any of these on every update next step block ui clicks with invisible images now when working in the ui naturally you have buttons and images that listen and capture the mouse event so for example over here is a button here it is in the game running and i can click on the button now let's say that you're making a tutorial and you want to disable this button you can make some complex code to disable the click functionality or another approach is to simply make a new ui image and then in here on the caller simply set the alpha community to zero so you do that and then make sure you leave as raycast target enabled and now if we try and here it is and if i try clicking on the left side nope can do it the image is actually blocking the mouse and on the right side there's no image so now it works so this is extremely useful for making tutorials when you want to block certain parts of your ui next the sorting order in the ui is defined based on the hierarchy position so the order you see here on these transform children renders from top to bottom so first the blue button is rendered and then the green button is rendered on top of that one so if you want something to show up on top you set it to the bottom of the hierarchy so if i want to move to show up on top just click and drag to the bottom of the hierarchy and the children also works exactly the same way so if i add an image to this parent container there you go you can see the image is that red circle and then we've got the children so first the background and then first this sprite image so the parent renders then this channel in this chart then as you're making your game you should constantly be following clean code principles in order to keep your code base nice and easy to work with and a really important part of writing clean code is minimizing access just as much as possible now when you want to expose a film in the editor you can simply just make it public and up over here we can see our exposed films and we can set them however doing it this way means that these fields are now accessible to every other part of our code so every other class in our code base can both read and modify this field so if this field is meant to be used solely inside this class and nothing else then we should really just make it as private so we should do this however doing it this way if there you go it hides it in the editor so the solution is to add the attribute serialized field so you add this attribute and now this private field is still private however as you can see it does show up in the editor so now it can only be accessed and modified by the cloud inside that class and also in the editor meaning that no other classes in the code base can modify it next up when you have a certain concept that requires multiple pieces of data you should group that entire concept into a single class for example here is a simple script to handle some sort of construction timer so we have this script which extends monobehavior okay and then the construction data is stored inside this class down here which holds a float in a simple sprite then over here on our script we have a simple field exposed of this type however over here in the editor we cannot see it because that is a custom class so we can solve that and make it show up in the editor by adding the attribute system.serializable so just by adding this if we go back in the editor yeah there you go now it shows up in here and now over here we can set our data related to this last tip is that this same attribute also lets your class be converted into json so for example if i remove it and over here i do a project start and i use the json utility and convert it to json and do a debug dialog to see what this does and if we run it on this object it does work however if we put this object inside another object like for example a save object if we try converting this save object into json let's see you can see that the second parameter of our custom class is not converted into json but again if we add the attribute system dot serializable and if there you go now that inner object does indeed get converted into json so if you have issues with empty objects when converting to json make sure you have the attribute serializable next up when making timers you should increase the amount rather than resetting it back to zero so for example over here i have a simple timer script it increases a timer by time.time and once it goes past the maximum it gets reset down to zero and then we simply do a log on the timer count so how many times this code runs as well as the total time so we're running this every 0.1 seconds so the first log should be 10 times the second log and let's test and if there's a console and it's looking mostly fine so this one is at 12 and this one is at 1.4 so they're pretty similar however now a bit later you can see that they are totally out of sync so this one is at 18.2 so this one should be at 182. now this has to do with the fact that when you pass the timer max you are going past it by a certain amount and when you reset it back down to zero you are essentially losing that amount so instead of resetting it directly back to zero what you should do in order to have a perfect hammer is to simply subtract it by the timer max so by doing this you are no longer losing the amount that you go past by the timer max so doing this even after a long time you can see that the timers are completely in sync next up avoid magic numbers so this is one of those that is so easy to do and it greatly increases code readability so for example over here is a script that does something the script uses a whole bunch of numbers over here now if you spend some time studying this code eventually you'll figure it out since it's a very simple script however it still requires you to do a bunch of unnecessary effort in order to decipher what all of these numbers mean and if we just do some very slight refactoring and use some local variables with proper names and emp can now see that the code is much easier to understand so we test if the gold amount is bigger than the gold cost and then we're using physics in order to identify the max building radius and then we call a function and pass in a construction timer so now i know what all these values are supposed to mean rather than having magic numbers where you have to figure it out this next one is slightly related to the magic number step so over here i have a simple tooltip class and then down here it has a simple function to show the tone tip it takes the text for the tone tip and then it takes a float for the taunted timer so as you can see this one gets defaulted to 1f and now in this particular case you have to guess that 1 is a special value that really means no timer so up here on our update we are testing if the timer is not minus one f so if it isn't then there's a timer if it is minus one f then it stays visible forever so this works but it's very confusing essentially y minus 1 f instead of 0 or why not minus 10 and also being a float means that it's very brittle so if you do some math and just pass in minus 1.1 then all of a sudden your tone tip will show and hide instantly and leaving you very confused so in order to avoid confusion you should define a proper class to hold this parameter so it can be something literally as simple as this just a class only tone tip timer and a simple font for the timer and then over here on the show we receive an object of this type and then up here we store that object and we simply test if that object exists now it makes more sense that if this object is known then that means there is no timer and if it isn't known then there is a timer and with this we also have no more issues with floats so keep your code readable with proper classes where it makes sense next i have a simple demo here so the circle will simply move towards the target there's a circle and yep gets towards the target it gets there and it prints a message on the console so very simple sort of like a pathfinding script and as you can see it works well the object moves reaches the target and fires off the event so the code is very simple just calculate the move direction and move the transform towards that direction along with the move speed and time. time and if you go within a small distance then you have arrived at the target so this looks good then let's say you launch the game with this code and afterwards you start getting complaints from players saying that their objects aren't reaching their target and after a lot of head scratching you come to the conclusion that it is probably related to the frame rate so when making the game for testing you have the super useful application dot target frame rate so with this you can limit the frame rate in order to tell the game to run at a very specific frame rate so for example let's put this running at just 10 frames per second and there goes the circle and yep with this we can see the issue the object is moving and the movement is based on time.time so since the frame rate is so low it essentially makes huge jumps on every frame and never actually lands on top of the target so if you use this code then the game would be broken on people who had slightly weaker machines so now that you have identified this issue you can add some code for example to test the distance before and after moving so make sure you always use target frame rate during testing in order to ensure that your game works at all frame rates then here's a simple one now events are very useful and you should definitely be using them so for example here is an event and then as you know in order to fire the event you simply just call it as if it's a function so on something happen in this case using the standard so this and event r is not empty however if you run like this you're going to have a nonreference exception in case this event does not have any subscribers so before you fire off an event you need to make sure that it exists so one approach is to do this so it has if not no any far off the event so this works but it wouldn't look better if it was a bit more compact so the way that you can do that is you have the event and then you add a question mark and then afterwards you can assume that the object is not known so in this case we can call invoke so this question mark is the nonconditional operator which was introduced in c sharp six and essentially what this does is it tests if it's no so if this object is known then the code stops executing in here and goes on to the next line and if it is not known then it continues forward and runs this code so in this case it won't invoke the event if not now and it will skip it if it is not next here i have a simple health system so just starting the current health and the health amount max starting off with a maximum of 100 hit points and currently with 40 health and then down here a function to get the health amount normalized so it returns a value between 0 and 1. so in this case with this amount it should return 0.4 let's see and nope instead we get a zero the issue is that in here both the health amount and the health amount max are both defined as ins so down here when you divide an int by another int then the result will be an int so the result of this division automatically cuts off any decimal points and that's how you end up with zero the solution is convert at least one of these into a float so you can do a simple cast cast that one down to a float and divide by an end so then you got a float divided by an end which will result in a float which works perfectly and if there it is now it doesn't need return 0.4 so always be aware of exactly how data types work or you might find yourself very confused in certain scenarios alright so that's 12 more tips go watch the first video if you haven't seen it yet that's where i cover the first 20 tips i hope you found this video helpful learn something new subscribe to the channel for more unt tutorials this video is made possible thanks to these awesome supporters go to patreon.com unitycodemonkey to get some perks and help keep the videos free for everyone post any questions in comments and i'll see you next time