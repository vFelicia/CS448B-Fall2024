in this video we're going to look at the current state of unity dots and ECS and what is changed in these past few months there's been lots of great improvements that makes it much easier to use and sell has epic performance as usual let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with nf2 torrents made by a professional indie game developer so if you find the video how fun consider subscribing so back in May I first got into unity dots and ECS and spent a long time learning and playing around with it in total I made 12 videos on a whole bunch of topics related to dots and ECS which you can find in the playlist in the description and now while dots and ECS has improved significantly since then I'm happy to say there haven't been many breaking changes so if you're completely new to unity dots you can go through all those videos in the playlist and pretty much all of it is still accurate the improvements have been more related to quality of life making it easier to write superfast dots code as well as making it work with game objects and automatically converting them into entities so here I won't go over some of the enlarged changes since that time if you want to learn more about dots and ECS then go check out that playlist and then come back here to see what changed for example I served one of the biggest changes this is announced back in the United Kingdom polenta teas for each inside a job component system so if you go through those videos you'll see that to make a job for security job struct then create the job instance set the data and schedule it now all that still works but using entities for each you can really cut down on the amount of code needed another awesome thing is automatically generating a monobehaviour component to be used in the editor I'm going to go over all of these changes and we'll test them out as we go on so for here I have my project setup with dots as you can see I'm using entities version 0.4 I also have bursts along with jobs and the hybrid render package okay so first of all back then I was under the impression that as that's went along it would eventually come with a dots editor so you wouldn't use game objects at all however in reality rather than selling everything from scratch over the past few months the focus has been to improve the conversion workflow that way you can still use the editor like you've always done and everything gets automatically converted into entities as soon as you run your game so here for example let's make a simple object like always so we make an empty game object let's call this our player and inside we add a mesh filter and for a mesh let's select a simple then let's add a mesh renderer and for the vision let's drag this material with a sprite and yep just like this here we have a very simple sprite as we've always done now in order to convert this from a game object into an entity all we need to add is the component convert to entity just by adding this component as soon as M runs this game object will be converted into an entity representation and then don't be destroyed if you're using custom components and naturally you need to handle the conversion yourself but for all normal human T components like the mesh filter mesh render and so on it's on automatic so if I run the game right now and if there you go the sprite is still there just as normal however if we pause and look at the hierarchy yep there you go our game object is now gone and now we can go into window analysis check the entity debugger and there you go over here we can see our player entity so they convert 20d script automatically construct this entity based on the components we have in our game object so in those videos I made pretty much all of it straight through code which again still works in this valid approach but right now thanks to the conversion entity workflow you can do what you've always done in the editor using game objects and simply add the convert to entity script another very important and very useful change is automatically making authoring components for example let's try making a simple component so in here we just make a new csharp script let's call this the move direction and now inside let's get rid of monobehaviour and all this and instead let's make a simple component so first we add using unity dot entities and then we had a public struct let's call this our move direction and we implement by component data then inside of our component let's add just a simple field so a public float called Val okay so here we have a very basic component with a single value however just like this if I go back into the editor here's my script here's my player and if I try to drag it if there you go we have an error we cannot add components if they do not derive from on a behavior however I can go back into the code and now we can add the new attribute called generate authoring component this will automatically generate a mono behavior see for this component so now I can go back and now I can select my player and drag the script and yep there you go it is example like that our move Direction authoring component now I can modify the value to put whatever I want so all I need is this simple attribute and you can play around with the components as if they were normal monobehaviour scripts so again this goes back to making a conversion workflow very easy to use now that we have our component and our player automatically converted into an entity let's look at the entities for each so for that let's make our system so we make a new script call this our player movement system now here we have our script and again this is not a mono behavior instead this is a job component system which again is inside unity entities so here we have our job component system with our on update and now previously back when I made those videos we had to make a job stroke to them of our job logic so we have to make something like a struct my job and implement I job I job for each or anything like that so essentially we had to build a struct and then initialize the struct inside of our job update so that still works however right now it's much similar to make a simple job here in the update we can use entities dot for each so here we take in a lambda function and if you've worked in normal component systems then you already know how this for each is so simple previously I would normally do a single threaded component system first to get on the logic working then I will convert it into a job now we can just straight do all that here on the job so here inside of our lambda let's do a for each and cycle through all the entities with a translation and move the Russian components okay so we sound through all the translation and move direction and now here we can also define which components are read and which are read/write so if you wanted to be read only like four is only move direction then we add the in keyword and if you wanted to read and write then we add the ref keyword so in this case we want to read and write on to the trend question but only really move direction so now inside of our four inch let's simply move the translation based on the move direction so we're going to move the translation dot value X and increase it by the move direction dot valid in order to make it frame rate independent let's also multiply it by adult time so we need to grab that time outside of the job so outside of the job for each so in here we make a float for our double time and inside we can use it alright so here we have our very simple job moving the translation based on the move direction now just like this we are setting up the job then we need to actually schedule it so after doing our for each week all scheduled and we pass our input dependencies and after scheduling this returns our job handle so we simply store our job handle and we can return our job handle so let's test any of there you go there's our sprite constantly moving to the right and in the entity debugger we can see our player movement system working on the player so again here's our job component system working with the simplified for each syntax if you compare it to the older videos you'll see that this helps in cutting down the amount of code needed by quite a massive amount now in here you can schedule it which won't be run by the job system however you can also make it run on just a single thread so instead of schedule we just call run and if we run this is now return a job handle so instead in here we can return just default and then up here we can add the attribute always synchronized system this forces all dependencies to run and synchronize before running this one so if we run this and if there you go there's our sprite constantly moving to right so everything still works now previously when you define a job struct you had to add the worst compiled attribute in order for it to use burst however now it's the opposite by default everything will use burst and if you need to do something that is not allowed with burst then over here on the entities you can add the filter without burst so by default your code run super fast with burst and if you find the inverse error in the console then you just need to add this filter next we have two things which have completely different names so if you run the code exactly as it is in those videos you need to change them in order to run so inside using unity dot collections you have the various dots collections for example you have a native cue and in order to write to it you would make a native cue concurrent in order to get it you would go into the native cue and you would call two concurrent now the behavior still works the same however now it has been renamed into the parallel writer and then as parallel writer so it works exactly the same just to name that change now another breaking change is regarding the active world so whenever you need to access the world to get something like the entity manager you would do world are active and find the entity manager however right now the correct way to do this is instead we use world dot default game object injection world so this is the world where all of your game objects that I have automatic conversion won't go into this was changed because that may or may not be the currently active world so in those videos when you see one that active you can replace it with world dot default game object injection world now one more thing that is not something that actually changed but rather is something I haven't covered yet and has been doing great progress and that starts physics again this is all being done so that the normal conversion workflow makes it super easy to use so here in my project I also installed the Unity physics package and in order to use it we just go into an add component and we have a regular normal rigidbody component and just like this if we now run the game and if there you go there's my sprite following along with gravity so as you can see the normal rigidbody component gets automatically converted into it dots physics rigidbody so I can also add a sphere Collider and then for example add this bouncy material and underneath put another object so here I have a nother object just a basic wall and again just by running it and there you go we have physics working and again these are using dots physics so we have nothing on our hierarchy so look forward to a video decade that's physics coming very soon also one thing I want to point out if you're some very new to dots then one excellent learning tool you can use is visual scripting I've done a video on it and even if you have no interest in visual scripting itself it can so be very useful because it's all dots based and most importantly contains a code viewer so you can make a simple visual script get used to the logic between entities components and systems and then look at the code viewer to see how the underlying code works for example you'll be able to see the code viewer making queries and running entities for each so even if you have no interest in visual scripting you can still use it to learn how dots and ECS works all right so if you're completely new to unity dots and ECS then go check out that playlist other than these minor changes all of the code and structures shown in those videos is still valid now I plan to get back to making dots videos especially since it's meant to come out of preview in just a couple of months so the future looks very exciting let me know in the comments what type of dots content would you like to see maybe a complete simple game maybe a showcase like the Marines vs. zombies videos maybe some specific system let me know in the comments as always you can download the project found in a tony's from unity code muqaam subscribe to the channel for more EMT tutorials posting question have in the comments and I'll see you next time