in this video we're going to learn how to display a simple sprite with pure ECS in unity 2019 we're going to display it and transform it and finally create a custom mesh through code let's begin hello and welcome I'm your code monkey and this channel is all about helping you will learn how to make your own games with enough tutorials made by a professional indie game developer so if you find the video helpful consider subscribing so when I was doing my ECS research it took me quite a while to understand how to draw a simple spread the documentation is still changing so it required a lot of trial and error to identify the necessary components so this is going to be a really simple video just to show you the basics you need in order to draw a simple sprite first if you know nothing about easiest then start by watching my video on getting started it clearly explains how ECS works how to make entity systems and so on so in here let's just make a testing script to run our code so just a simple and you see sharp script conduct testing let's make a game object to run our code so testing and drag the script just like that okay now first we obviously need an entity so let's make that so just like this we have a simple entity we can run our code and on the entity debugger yep we got our entity okay now in order to have a visual we need to add some components so the main one we need is type of render mesh which is inside the using unity dot rendering this is the one that actually renders our mesh and then we also need the type of local to world this is inside using unity dot transforms this component centrally calculates the matrix for how the mesh should be this point and as of the current DCs implementation it is required to have this component if you just have the render mesh it won't actually be visible so on the render mesh here you can see what we need we need a mesh and a material so let's do that let's add some serialize jion's in here now let's go to the editor to select our mesh and material so here for the mesh we can use unities default quad mesh and for the material let's make one in here a new material for our sprint material let's use unlit transparent and drag our zombie sprite and we dragged our material onto there okay so in here we have our two things now let's set our entity component data so we go into the entity manager to set the shared component data since the render mesh is of type shared component on this entity we pass in a new render mesh and here we pass in the mesh as our mesh and the material as our material now in order to display we just need to make sure that the local to our own contantly it's the correct values so in theory these are the only two that we need but in order to come lay down welcome to our own value we can simply add the type of translation which won't automatically fill it up so this one is not strictly essential if you set the unwelcome to our own values yourself but this way it's extremely simple so mighty and if there's our sprite being visible in a pure ECS way here in the entity debugger you can see that our sprite has all these components the ones that we manually added were the render mesh and then welcome to world and then you need translation art for these values to be calculated and here on the render mesh system you can see that it is running on one instance ok so these are the complete basics to draw a very simple sprite you just need a random mesh component and the own local to world component now let's see the other related components now on a normal game object you here have the transform with a certain position and in purus yes we have the equivalent which is the translation component you can see here the definition as you can see it is simply component data and contains a for 340 volt and if all three here is the definition as you can see just has an x y&z so this is our position component let's make a simple system in order to move it just on here make a poly class for the moon system which implements a component system again if you don't know how ECS works check out the link in the description where I slowly go through what is a system and how they work so in here I'm just going to quickly implement the abstract class which has the on update method and here simply cycle through the entities for each entity that contains a translation component on each entity that has a translation component let's just move them up so translation that Valley dot wine was equals by a certain amount x time down time okay so here we have a simple system that won't act on a translation component and simply move them up let's test any of there's our sprite constantly moving up okay great now again back in our game object on the transform we also have a rotation and the equivalent in ECS is also called just rotation here is the definition of the rotation component and as you can see we simply have a quaternion so let's make a rotator system also this valley is of type unity dot mathematics and not the normal unity engine so we have to go here using unity dot mathematics which is a specific math library for our entity system so here we have our rotator system which is running on every entity that contains a rotation component and we are similarly rotating it over time let's see and if there is there's our sprite moving up and also rotating and here on the entity debugger you can see the entity and inspect the entity balance as you can see the in local two world and the world render bounces are calculated automatically and we have our rotation component rounding and the translation moving up so with the Sudan the last one on our normal game object transform we have the scale and in ECS we have two ways of setting our scale we have the type of scale this one as you can see just takes a float for a value so this is if you want just a single scale on on with our x y&z so let's make a system for that so again we have this system running on every entity that contains a scale and we are simply increasing it over time so let's see if the sprite doesn't need increase in size and if there's our sprite scaling up moving up and also rotating now as I said we have two ways of rotating we have this one which is a uniform rotation you just have one float value for the entire rotation and then you have another one which is type of nonuniform scale and this one as you can see it takes a float three so you can set a different scale for the X the Y or the Z so here instead of a system let's just set it on our start let's make him stretched up so one f3f and one out okay so let's see if we have a rectangle stretched vertically any of there is the sprite is indeed stretched so one of the main things between using the entity system or the default game object is that you no longer have the automatic scale as you do when using a sprite runner so here for example I have two sprites this is a square sprite and this is a rectangular sprite and here if I were to create a simple sprite renderer I drag this one and I can see it perfectly matches and drag this one and it perfectly matches however when using ECS we have to give our actual mesh size so it doesn't get automatically translated from these sprites and whatever you're using in here so again in a normal game object you have your basic transform which has a position rotation and scale and in pure ecs you have an object which has a translation for the position rotation for the rotation and either scale or nonuniform scale for the actual scale now let's spawn a bunch of entities instead of just one okay so here we are spawning ten entities if this code seems weird then make sure you check out the getting started video so let's see our ten entities okay so here we have our ten sprites and now in here if we go and see our stats you can see that they are not currently being patched in order to solve that we need to enable GPU instancing so we go into our material and now in here as of the current version using the sprites shader if I go in here select sprites and default if I click on enable GPU instancing for some reason the sprites disappear I'm not sure if this is a shader bug or what it is but it doesn't work so one shader that I found out that it does work with sprites it's going here into a legacy shaders select our transparent diffuse shader and now we can enable GPU instancing now in here another problem we have is the sprites become dark and that's because of lighting so we need to go here on to your rendering lighting settings and set the ambient lighting to white and just like that there are our sprites and as you can see they are all being batched okay so we have learned how to create and display a simple sprite using pure ECS now one thing that is extremely useful to know is how to create the mesh through code since each sprite no longer gets automatically size as you saw we need to either use the scaling component or have a different mesh per sprite so let's make a mesh completely through code instead of using our serialized field so let's go here and make your function to create a mesh so a private mesh create mesh and in order to make a simple quad it's actually quite simple all we need are two polygons so that means we have four points so we define an array for our vertices and we create it with four points then we also need to apply UV to those same vertices so we also have four and finally in order to make a polygon we need three points so for two polygons we need six triangles alright now let's set these values up so to keep things simple let's define them in a clockwise fashion so our first vertex will be on 0 0 so at the lower left corner the second one on 0 1 so the upper left corner then on 1 1 so the upper right corner and then on 1 0 so on the right bottom corner let's make those vertices so we have 1 on then on plus so up there plus 1 so up there and plus so in there now for the UV we're going to use the home sprite so it's very simple ok the UV essentially matches how we define our vertices and finally for the triangles this is where we need to be careful each triangle needs to be defined in clockwise otherwise we're going to be looking at the back of our polygon so here each triangle is an index of the vertex so these are all the families we need in order to create a simple quad and now we just create the actual mesh and it's a symbol we create the mesh assign the vertices the UVs and the triangles and now we can go all the way up here and instead of using our serialized field mesh let's get rid of this one and here we do a create mesh and let's also stop moving it on the scale so we have our default mesh okay let's see if our sprite is indeed being displayed in a square any of those are sprites and all of them being displayed using a nice simple mesh that we created through code so now we need this to be able to create a mesh of different size so for example we would create a square mesh for this texture and for this one we would create another one since as you can see that is stretched let's see okay so here the only thing we need is to go into our create mesh function and let's receive a float 40 with an default for the height then here let's calculate a float for the half width which is our width divided by 2 F is followed for the half height which is our height divided by 2 F and here we just use this so we're doing exactly the same logic except we have a width and a height so then let's go in here and for these ones and let's use the same one F 1 F so we still have a square room let's see and yet we are still displaying squares ok now let's go here add another material so first one rename this one for the zombie material and this one won't be the kenai material now here let's create 20 and then we do a cycle and we're going to put essentially the first hand using the zombie material and the next n using the crime material so in here we just do if di is under 10 then we use the zombie material if not we use the Konami material okay that's the total material now we can go here and create our two different meshes so on the first thing we're going to use these animations on material and on the next enduse econ I mention the Konami material so we are no longer using nonuniform scale but whether we are creating two different meshes for our two different sprites let's see any of here we have both meshes and they are all correctly scaled this sprite is using a square mesh in this one a rectangular mesh so you can see how creating a mesh through code is extremely useful when dealing with the entity component system so that's pretty much it for spawning and displaying a simple sprite using pure ECS the main thing is really just the render mesh and in welcome to world components then you have these components which are the equivalent for our game object transforms and you can dynamically create meshes in order to display any size we want as long as you can download the project from the utilities from unity code monkey comm if you liked the video subscribe to the channel for more into tutorials post any questions you have in the comments and I'll do my best instrument alright see you next time you