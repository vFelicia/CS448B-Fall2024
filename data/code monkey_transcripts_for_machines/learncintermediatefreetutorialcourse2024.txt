hello and welcome I'm your KMI welcome to the free intermediate section for my complete C Mastery course by going through this course you will learn how to be able to make games websites apps Robotics and literally anything C is an extremely versatile language the core starts from the absolute Basics like how code executes line by line and what is a variable then covering intermediate topics like what are interfaces generics and events and how you can use them to build some really awesome things you will also learn the theory behind how to choose good naming rules clean code guidelines and learn about design patterns and finally the advance section which I'm currently working on and covers quite a lot of advanced topics right now there's a handful of lectures already out and I'm constantly uploading more now this free YouTube over here this one contains all the video lectures for the intermediate section like I said in the previous video my goal is to publish the video lectures over here for free on YouTube if the premium version sells a certain number of copies and I'm very happy to report that has indeed passed that threshold which is why this video is over here for you on YouTube I've already posted a video with all of the free video lectures for the beginner section and in about 2 to2 months I will publish the free video with the advance section so if you're watching this in the future check the link in the description to see links for both of those the premium version of the course has all the video lectures for all the sections and also has a bunch of really nice bonuses So speaking of that here are the bonuses for the premium version I came up with some that I think are really awesome and definitely worth it if you can't afford it well at the same time not putting any knowledge behind the pay wall so even people who can't afford it they can still learn from the free lectures they really just need to do a little bit of extra work themselves the premium version is really just selling convenience making it really easy for you to truly gain the knowledge the premium version comes with a companion project this is a Unity project that contains a bunch of extra content basically the video lectures won't being preas themselves there's still really only half the course the other half of it is inside of this project it has a bunch of custom editor Windows to guide you through each lecture and each lecture has a section on frequently asked questions these are common questions that have some really detailed answers that provide even more details on what is covered in the lecture then there are some quizzes these are multiple choice questions again all with very detailed anwers it's really not just correct or incorrect if you pay close attention to each lecture you should be able to get most of these right but whether you do or don't by reading the extra explanation that will help you truly learn that topic then the interactive exercises I'm really happy with this feature I think this will really help you learn learning by doing is always much better and these exercises encourage you to put what you learned into practice instead of just blindly watching the video lectures I designed a ton of hcraft exercise for all the lectures to help you put into practice and truly learn the contents of each lecture there are all kinds of exercises some are about spotting and fixing errors others are about asking you to Define some function or class or Implement some kind of logic there are some where you just write code and somewhere you write code and then play the code in unity in order to complete the exercise then each exercise also contains a hint just in case you get stuck or a solution in case you get really stuck as well as a video walkthrough of me going through that exercise and completing it while explaining everything in detail so you heard the kind of person who gets stuck in tutorial hell then I truly believe that this will really help you escape it in order to learn need to actually do things and and this exercise encourage you to do that they encourage you to do it as opposed to just blindly watching the video lectures then the companion project also has a companion window basically this window is also listening to a bunch of errors and if it finds one it will help guide you in the right direction I manually wrote a ton of text for when text lots of errors all of them based on common errors that I see people ask about in comments in my own videos so this should help prevent you from getting stuck in your Learning Journey and allow you to get help instantly then the course also has an AI to help you answer questions this one was trained on the contents of the course and my own knowledge so it should be very accurate and helpful but more than that it's simply the fact that it is extremely fast you post a question in the course comments and within a few minutes the a will respond with probably a very good answer although of course I myself will also still be answering all the questions manually the goal with this AI is really speed so you get a response almost instantly and then within the next few hours I will manually answer myself then a simple bonus is how the premium version has the course split into lectures as opposed to Here on YouTube where it will be one giant video it has to be that way the how the YouTube algorithm works this is a small thing but it can be helpful especially if you take your time to slowly go through the course just like you should do remember that the only goal is really that you are actually learning yourself it does not matter how quickly you go through it so separate lectures help with that so that you can pause and actually try out your knowledge before going further and you don't have to memorize specific time stamps and over here on YouTube the videos have the normal YouTube ads as usual whereas the premium version has no ads so there's nothing to interrupt you while you're learning another two great bonuses is the private Discord and and thean live study group you get access to a private Discord with a really nice community of people all on their own Learning Journey I'm there myself as much as I can to answer questions or really just chat and every week I also do a private life QA you can join me on the live stream and ask anything you want and I'll do my best to help so these are the nice bonuses that I came up with that I think are really nice and really awesome while not taking away anything or putting any knowledge behind the pay wall if you can afford then I highly recommend the premium version these bonuses will help you truly learn and learn much much faster than the 10 years that it took me but if you can important that's okay like I said there's no hidden knowledge hidden behind the paywall you really just need to put more effort in yourself in order to actually apply knowledge that you gain so whether you get the premium version or watch your free lectures I really hope you'll learn a lot also just in case you're new to my channel so a bit about me and my credentials or why you should listen to what I have to teach for me I've been programming for over 25 years and specifically using C for over 10 years I'm a professional indie game developer with several successful games PO on seam covering a wide range of genres my games are usually focused on complex systems since I am merely a programmer it's what I really love to do and what I love to teach also a couple of years ago I started over here this YouTube channel making free video tutorials to basically share my knowledge to help you learn how to make your own games there's already over 800 free videos over here on this channel if you want to continue learning Beyond this course also one very important note for both beginners but also for intermediate users which is simply take your time take it slow remember this is your Learning Journey no one else's the only thing that matters is that you're learning it does not matter how long it takes you so it does not matter if someone learns all of this much faster than than you you are really not in competition with anyone but yourself also you are not expected to go through this course in one day one week or even one month basally all the content out of this course this contains knowledge that took me 10 years to learn so really just take it slow take your time and really just focus on learning and one final request if you find this video helpful if so go ahead and hit the like button and subscribe to the channel it's a tiny thing but it really does help all right so let's get to the first lecture hello and welcome I'm your KMI welcome to the intermediate section we're going to take things up a notch and learn some more intermediate Concepts but before we do let me just quickly say if you are still very much a beginner If the previous section was your very first exposure to any kind of programming if so then just be aware that it's perfectly normal that it takes you some time in order to understand the context of this intermediate section that's perfectly normal learning and trally understanding all that we're going to see all of that takes quite some time remember that the only thing that really matters is that you're learning how long it takes you isn't really relevant so really just focus on actually understanding actually learning for me it took me literally decades to learn and all of this so if it takes you 6 months to go through this intermediate section if so then you're still going to be doing much much better than me so all that to say take your time and just focus on learning now if you took a break between the beginner section and this one then I encourage you to go back and at least rewatch The naming lecture and the clean code principles I put those two lectures in the beginner section just because I want the beginners to be aware of it but as you grow as a programmer as you become an intermediate those two concepts naming rules and clean code principles those become even more important to fully understand and fully apply so if it's been a while since you saw the beginner section go ahead and rewatch those just quickly and with that that's the intro out of the way so let's go into the next lecture where we're going to see a nice overview of everything that we're going to learn in this intermediate section hello and welcome I'm your Cod monkey in this intermediate section we're going to go one level up relative to the beginner section and learn some more complex stuff so let's see an overview of all the lectures beginning with something very important that I debated whether I should put in the beginner section it's going to be Visual Studio shortcuts I end up putting it here because for beginners technically it's more important to learn how to write WR the code and it's not as important to be extremely efficient with how fast you use your ID but for intermediates this is a must have so we're going to learn about a ton of shortcuts to help you write code and navigate your environment much better then comes one of the most important lectures in this whole intermediate section it's all about refactoring this is the process of rewriting your code to make sure it is as readable and understandable as possible as an intermediate you absolutely need to know that this is a natural part of the code writing process and something you should not skip next is a lecture on s pretty simple and very useful it's how you can define a specific list of values that you can use in many ways after that we'll learn about properties which are kind of like a mix between variables and functions then we're going to learn about multidimensional arrays meaning arrays that can hold multiple dimensions of data after that we're going to learn about Ness Loops which is especially important in order to cycle through multidimensional arrays next we're going to learn another method for doing some looping logic we're going to learn about recursion this is something that for people with a math background it might actually be similar to understand than R Loops then we're going to learn about an extremely useful data type the dictionary this is a key value pair that has tons of really awesome use cases after that we're going to learn about some more collections like q and stack then we're going to learn about the prams keyword and what exactly does it do in a function next we'll learn about optional parameters how to define them and how to call them from a function then another crucial lecture for intermediates this one is on learning the differences between value and reference types this is extremely important if you don't know this difference then you will go crazy at some point in the future wondering why something isn't changing and it's usually going to be because you don't know you're working with a copy and not a reference related to that is the lecture on structs these are similar to classes but importantly they are a value type next we're going to learn some more intermediate use case for classes we're going to learn about inheritance polymorphism and a bunch more then learn about interfaces this is one of my favorite features of csharp it allows you to write some really nice modular code related to that we're going to see various ways of testing for types and converting to and from various types also related is the lecture on switch pattern matching this is a really simple way to do a switch not just on value but also on type then we're going to learn all about delegates lambdas and Anonymous functions this is how we can store a function itself inside a field next we're going to learn the differences between lambdas and local functions after that we learn about events which is how we can have one class we notified when something happens then the next lecture that one is going to be all about generics this is another super power powerful C feature that makes your code work with multiple types next is a simple lecture on constant and read only what they are and what are the differences between those two after that is a lecture on exceptions and how to handle them with a try catch then a lecture on implementing I numerable so we can add support for something like a 4 in for some custom types next we're going to learn about namespaces what they are and how to make your own then a really important lecture on one of the most important design patterns the single T pattern and after that is a general over review of a bunch more design patterns and finally after doing all of that we're going to check out the intermediate project that uses all of this to make something really interesting hello and welcome I'm your codm in this lecture we're going to learn about a bunch of really useful Visual Studio shortcuts okay so as we get to the intermediate Sage it is really important to be good at using your tools and as a programmer your main tool is going to be your ID so you should be very comfortable with shortcuts and moving around your codeb base but also this is something that you pick up with experience so this lecture this one is really not meant to be a stepbystep lecture but rather I just want to show you a bunch of shortcuts that I use myself just so you are aware they exist and over time you won't pick them up and they won't become more and more natural okay so the most basic but honestly most useful one is simply moving the cursor normally beginners they use the mouse to move around so they scroll down and click wherever they want to write and then sometimes beginners use the arrow keys and they press it like a million times in order to get wherever they want to go technically this works but it's obviously not very efficient there are many ways to speed this up and importantly many ways to navigate your code base without your fingers ever leaving the keyboard for example when moving left to right technically you can indeed just press the right arrow key and eventually you won't get there but as you can see going left to right like this takes quite a while I got to press like some like 50 times in order to get to the beginning or the end so one of the best super simple shortcuts is simply to hold down the control key and now as you move left and right yep instead of going letter by letter it goes word by word so that way now I can get to the beginning or the end of this line in just about four five presses instead of being like literally 50 so it is literally 10 times faster then of course you also have the home and end key I use these all the time especially when combined with shift for quickly selecting something so for example if I want to move this line above the Southern Line if so then us what I do is press end to go to the end of this line then hold shift and press up to select and now press end again in order to select just that one then I press CR X to cut I move up press contrl V and yep like that so if you do it pretty quickly it goes quite fast very easy to do all this and again I did all of that without ever my fingers leaving the keyboard if I were to use the mouse I would have to select like this crl x go like this like this so in this case not much of a speed difference but just the fact that your fingers never have to leave the keyboard that alone is a huge bonus and again on all these shortcuts we're going to see how differen is usually pretty small like saving like a second 5 seconds or fractions of a second so that does sound like a super tiny amount but considering how you're probably going to be programming for many years and you're going to write millions of lines of code throughout your entire life when you look at it like that those tiny amounts of time they really add up so that's the main thing just moving left and right holding control to go between each word or using and then home in order to go back to the beginning and the end and combining all of that with shift in order to really move around super quickly so that's the first tiep and then for something that is sadly not default is moving the cursor up and down so by default if you do that it obviously only moves one line at a time so again the same thing in order to move down 20 or 30 lines that actually takes quite a lot of pressing in order to move and by default the alternative is using page up or page down although personally I'm not a big fan of this I find that these move the cursor way too much so every time I press page down it takes me quite a while to realize where the cursor is and how much actually moved so I don't like how this moves way too much so in my code I added something so that I can move the cursor up and down vertically by just five lines that way I can very easily go down and continue scrolling down and I'm never lost because the screen never changes a massive amount I'm always moving down moving up select this line of code do something move down write something so on now sadly this behavior isn't available by default in Visual Studio at least not that I know of so for this I installed this extension called visual Commander this one lets you basically apply some hotkeys to l anything you can do in visual studio and then with that install just go up here into extensions and here is the V command and on this one here are some commands that I made so here is the window so I've got move up and move down so I can edit in order to see what this is doing and yep it is executing the command line up so literally just moves the line up and the other one this one does the same thing but line down so I've got these two commands here if I have the cursor somewhere and I go into that extension and I use the move up command yep it does move up by six lines so then as you can see I just assigned some keyboard shortcuts to those so control up and control down then I just went into tools options and over here go down into the keyboard shortcuts and then find vs command and up here command one command two those are two ones that I made and as you can see I've have assigned them to control up arrow and control down arrow so all that if I press control up or control down as you can see the cursor moves quite a lot faster so I find this to be much better than just pressing one just moves one line or pressing page up which always causes me to lose and get lost so with just these steps you can see how I can move in the code really fast without ever touching the mouse like let's say want to go down I want to find for example the awake I want to select the awake I want to cut it and paste it down here and there you go just like this and remove these lines form met and so on so as you can see just using these control in order to move between the words using this shortcut in order to move vertically really fast and combined with home and end and with shift and all that put all those together and yep you can move through the cursor you can move in your code base really quickly without ever leaving the keyboard then of course if you're working on some kind of Big File like for example this is the player class from my steam game dinky Gardians so this a pre massive class for this one if I want to get to the bottom and if I go even with this short this is going to take quite a while so for that one if you want to move a massive amount you can use control home or control end in order to go to the beginning or the end the file so this is yet another way to very quickly move around and another very useful one for moving around is simply put the cursor on top of some kind of symbol like for example let's say this one this event on player picked up the experience and then if you press control shift and either up or down this will move the cursor to the next or previous reference of that symbol so for example over here you can see how it's really useful how in this huge line of code this script has almost a thousand lines of code but I can very easily see exactly where this one is being referenced I just move up and down yep here is the definition and here is where I'm using it so whenever you want to see all the various places in which you are using some kind of symbol that can be a function can be an event can be a variable can be literally anything just hold down control shift and then up and down and you can see all the places in which that symbol is being used then another extremely useful shortcut that I use all the time is control and comma this one pops out this window and now here you can search for any class you just typee a name and find it like for example I want to open up the dinky class so I'm going to type in dinky and now just one thing is this shows actually every symbol so in this case in this game since it's all about dinkies I've got tons of references to dinkies so you can see all of these in lower case I usually write my variables in lowercase so I know that's not the one I know the one that I want in order to open the file is the actual file itself so I can type in dinky docs and yep that does show the file press enter and yep here I am the dinky file and again press control home to get the beginning yep here's the dinky definition and I can see all this code just like this so if I want to move to like the tutorial manager so I just write tutorial manager just right a little bit yep I can already see this one so this the class we can also see the icon over there so that one means a f that one means a class this one means an event and so on so I can see this one press enter and yep here I am in this one and again move up move down everything works again note how throughout all of this my fingers never leave the keyboard I never touch a mouse so personally whenever I'm making my games and I want to open another class I never go into unity and manual double click on that file I always do it over here press control comma search for anything press enter and it opens or alternatively for example that one that I mentioned when you got tons of references something like over here tons of references to a dinky so I can just go into this one and then I can put the cursor on top of the type itself and I press on F12 and Yep this one takes me to the class definition F12 is a shortcut but if you want to use the mouse you can also just right click on it and over here we can see yep F12 is indeed a shortcut to go to definition now since we're here with the mouse one really useful one is over here the fine all references when you click on this this is going to show all of the references to that type so this can work with whatever is under the cursor so in this case I select the dinky class so this is going to show me all of the places in my entire code base where the dinky class is being used or alternatively you can put it just on a field and yep now this one is going to show all the places and you can click in order to automatically go to that line and of course it also works with functions so for example over here this function I'm pressing control shift up and down in order to see all the references within this file but this function is not called from within this F so in order to find where on Earth am I calling this again right click go to references and if I can see okay so it's being called from this script right here inside dinking manager it's calling this function another really useful use case for that particular one is when working with interface so let's say I want to see all the class that implement this interface again right click find all references and if I can see all of these look at these these are all implementing the UN interactable interface then something that I use all the time is control RR that is the shortcut for renaming the current symbol so I just plac the cursor for example over here on top of the is moving field press control RR and now let's say I want this to be a little bit more descriptive so is player moving so I change that and note how again the other shortcut control shift and up and down note how this one did rename every single reference of this symbol so all of those I don't need to change them just modify them once use the rename feature and automatically renames all of them and if I find out that the previous one works better again just edit go ahead remove this press enter and Y there you go all of those have now been renamed remember that refact ing is an extremely important and importantly it's a perfectly normal part of the process in fact the next lecture is entirely dedicated to the topic of refactoring if there is something that you wrote some name but then later on you think it should have a better name just take some time in order to rename it simp place the cursor over it press contr RR write the new name and it will automatically rename every instance of that symbol this works on everything everything from simple variables to even entire classes and it even renames every single reference in your entire code base so for example here I am on the dinky class which is used throughout the entirety of this code base I can press control RR and I can modify this whole thing and say something and Y like it says here rename will update 297 references in 58 files so this rename feature is really awesome really useful it automatically handles modifying everything and everything is handled automatically for you then when you have multiple windows open for moving between them you can use control tab if you just use one it goes back and forth between the last open tab so this is something that I use all the time whenever I'm working between two files and I want to quickly move between them but instead of doing just that and letting go you can hold down control and tab and as long as you hold down control you can see this window and over here you can move up or down in order to move between all the various windows that you have open so for example let's say I want to go into dinky off world yep there you go now I'm looking at this class and if I quickly control tab I go back into the previous class and this tab over here this one only works for the windows that are open so again the same thing if you want to open up a new window just press contrl comma open the window let's say for example I want to find the carry vehicle so I just type in the carry vehicle yep it's right here control enter and this one opens up the carry vehicle class now control Tab and off want want I go back to the link key and move between them like that then here's a really simple one you can raise an entire line by just having the cursor anywhere on that line pressing contr X that one cuts the entire line that one acts as a cut meaning if you press contrl + V you get the line back alternatively for duplicating you can press contrl D although honestly I rarely ever use this one because I can never remember whether it's going to duplicate on the line above or below it so usually if I want to duplicate something I just do the shortcuts that I mentioned a while ago so end above and cut move cut and so on now speaking of copy paste if you press control shift and V if you do that you get a list of your clipboard history so for example a while ago I showed cutting the awake class and yep it is still saved in here so if I press on enter yep it paste that one exactly like that so remember that your clipboard has history it is not just the last thing that you copied you can access the entire history another useful tiny time saer is actually when using the mouse when using that if you want want to select some kind of word some kind of symbol obviously you can do the basic thing which is just click and hold and drag throughout to select it so obviously that works but it's a little bit fiddly if you move up or down can be quite tricky so the similar shortcut for that whenever you want to select some kind of word you can just double click and it select it or alternatively hold down control and click in order to select the entire thing this can be quite useful for example when you have some copy pasted code and you want to change some kind of name but for some reason the rename function doesn't work like for example let's say I want to duplicate this code over here so right now I cannot use rename because this one is going to conflict with that one so instead let's say the active dinky list so I press I select this one control click and there you go like that and if I want like that so control click in order to do control V and so on this one can be quite useful sometimes then something that I only very rarely use is shift and ALT hold those and then move upward down and this one basically lets you select multiple lines of code and edit them at the same time like I said I rarely use this but sometimes can be useful for example for quickly appending or removing some kind of like for example on this enome I've got these values I want to write all of them and say tier one tier two and so on so I can select all lines and write here and writes on all of them or alternatively if this one did have it and I want to remove them just select them all and I can remove them so basically you can write code on multiple lines at the same time and if you want to quit this just press escape and yep back into a single cursor another Super useful one is when working with events like for example the on any dinky started starving so I can just write the event name then plus equals and then here Visual Studio automatically has a shortcut so you can press tab to insert start then if you want you can rename it but usually I keep the exact same name that it suggests so just press enter and Y there you go I've got a new event now I can come here and again use the shortcut contr X to get rid of that go above go to the end press enter go to new line then write some new code so really useful and if afterwards you decide that you want a better name for this event again remember just say quick control RR in order to rename then if you want to find something of course you have contrl f for example finding when I'm invoking some kind of event so just write invoke and if it finds it obviously nor then the shortcut for going to the next element that one is pressing on F3 and it goes to the next one so it finds that one that one that one and so on in order to go to the previous one you use shift F3 and goes backwards also by the way this works whether the control F window is open over there but if I press ones in order to close down that window and with this if I press an F3 yep it still remembers the last thing that I searched then for quickly commenting or uncommenting something you can do contrl KC and yep it automatically comments that entire line and if you have multiple lines selected control KC yep automatically comments the opposite to uncomment is control KU and yep automatically uncommons that although personally I never really use this one myself again it goes back to how I'm so proficient at just moving the cursor so if I just want to comment all of these I just do the common star go down there common star there you go just like this another useful shortcut is extract method so you can select a whole bunch of code then press contrl R and M and this one creates a new method with that code so let's say setup and if there you go pretty much took that code and plac it in its own method so this can sometimes be useful although again this is another one that I don't really use myself because again I'm prettyy fast at just moving the cursor so if I want to do this kind of thing I really just go into the code that I want I just go I use I move the cursor move up move down then do private void my setup do some kind of function then write it just like this and everything works if you want to go to a certain line you can press control and G this one lets you input some kind of line num so let's say let's see what is that line 500 so just type in 500 and yep there you go here we are on line 500 now for this one normally I don't really use it when writing code code but I do use this one quite a lot when writing the text script for my courses since normally I write my course in a simple text file sometimes it has tens of thousands of lines so for that usually I like to move around by using the line number although in the code I never really have such massive files so I don't normally tend to use it but it's only a nice thing to know then of course the one that you already know if you make some kind of mistake control Z in order to undo and one you might not know is control shift Zed in order to redo then for moving between visual stud and unity just a simple alt tab so just once and moves or if you have multiple files just keep pressing Tab and perhaps the simplest and most useful one is simply autocomplete I really advise you to get comfortable with how autocomplete Works learn how to just type a few lectures and then either press enter or dot or semicolon in order to quickly autocomplete honestly I don't remember the last time that I were something like for example try get component I just try a little bit and write like that for example dinky just like this then out Dinky Dinky just like this super simple so just get used with how little you have to write in order to press enter in order to automatically write everything everything else this works with Fields but obviously it also works with things like functions it works with classes it works with literally anything okay so that was a lot of shortcuts personally I use a lot of these all the time but again I've been writing code for over 25 years if you're not used to using shortcuts then I really don't expect you to suddenly use all of these right away all at once like I said this lecture this one is really not meant to be a stepbystep lecture for the most part right now I just want you to memorize the first ones that I mentioned about how to move through the cursor quickly just memorize those and simply remember that the other ones exist then periodically come back to this lecture every once in a while and watch it again if you do that several times over the next few months then soon enough all of these shortcuts that I mentioned all of these will be natural to you just like they are to me hello and welcome I'm your KMI in this lecture we're going to learn all about refactoring okay so before we learn some more programming syntax let's cover some very important Theory one of the types of comments that I get most often is basically beginners asking me how do I memorize all the code and write everything perfectly the first time and the simple answer is I don't what you see in a video like this course what you see is really after I've done tons of research and written and most importantly Rewritten a ton of code this is one of the crucial things that separates beginners from intermediates beginners think that when the code is written that's it it's written forever and will never change so you have to get it right on the first time whereas intermediate programmers they know that code is a semi living thing that is constantly changing as your game or your program changes and progresses refactoring which is a term for rewriting code or simply reorganizing it that one is a Perfectly Natural part of the process if a very simple process is simply when you first try to build some kind of system like for example making a health system at first your primary goal should be simply to get it working you should obviously try to write some good clean code but it's nearly impossible to get it perfectly on the first try so the first goal is just get it working and now here's the really important step that separates beginners from intermediates after you get the system working then look at it analyze the code and see if it could be written in a better way perhaps there's some variables that could have a better name perhaps there are some functions that are clearly doing too many things and should be split into multiple smaller functions perhaps you have a whole bunch of data separated that should make more sense being placed in its own custom class so the first step is indeed just get it working but then don't forget the Second Step that one is how to get it working properly remember that your code is a living thing you won't continue living and working with that code especially as you start to make bigger and more complex projects so since you're going to use and reuse that code in the future make sure you write it properly it is perfectly okay to write semi there code on the first time what is not okay is to leave it there so when it is working take some time to do some refactoring if needed so if you are a beginner about to transition into the intermediate stage I want you to truly learn and fully internalize this it is perfectly fine in fact it's essential to rewrite code you are not expected to write everything perfect on the first try but you are expected to constantly be thinking about how the code could be improved and if you do find some possible Improvement take some time and refactor that code always keep that in mind especially as we go through this intermediate section which naturally will increase in complexity compared to beginner section so keep that in mind and let's go to the next lecture and learn about enums hello and welcome I'm your Cod monkey in this lecture we're going to learn one super useful feature of C which are enums these allow you to Define enumeration with a set of named constants it's really useful in so many scenarios okay so enums are really great like for example look at this code this function over here get next player action this is supposed to be something like a turnbas strategy game so the player has this function and uses this in order to calculate what is the next player action then does a whole bunch of tests to find out what is the next valid action and doing so it returns an INT which is going to be some kind of code for whatever action the player should be taking so for example the player checks if it has no enemy if so then it returns zero so zero means no enemy gen checks if there's no path to the enemy if so returns one so one means no path to enemy then checks within attack distance so two means moving towards enemy or three means attacking the enemy now the big problem that is immediately apparent in this code is that returning an INT value that one is really not very intuitive int is really supposed to be a number so matching into some kind of behavior that seems quite strange just like this you have to memorize that zero means no enemy one means no path and so on so numbers really are not the best type to use here and I said this is one of the many scenarios where enums are really excellent so first we Define an enum and the way we do that is we just type in enum then the name of the enum so for example let's say player action and then open and close the currently braces and now here we just Define a set of names for our various enim States so for example in this case we want one to represent no enemy we want one to say no path to enemy and we separate them with a comma and one moving toward enemy and finally attacking enemy all right yep just like this so now we have to find an inum which inside can have four of these possible values by the way the inum just like classes just like types just like anything also can have an access modifier so again the same rule if you don't need it to access from anywhere make it private if you do need to access it from somewhere make it public okay so like this we have thein our n now we can refactor this code in order to make it much more understandable so for example instead of returning an INT let's return of type player action then over here instead of returning a number we just return player action dot in this case no enemy so instead of having this we just have this and Y right away this makes a lot more sense so let's apply the same thing to all these so this one is the no path to enemy and this one is going to be the moving toward enemy and finally we have the attacking enemy and yep just like this so now we don't need those comments to explain what the number is supposed to mean just looking at the actual value itself just like this we can understand what exactly this is meant to be doing so enums really are this simple we just Define the values for our enum and then use it in any way we want by the way here we are returning an enom but an enum is really just a type so we can do anything we want with it like for example we can make it a return type for a function or we can just make a variable of type layer action and we can set it to one of the values in our enum we can use it as a parameter we can use it on pretty much anything we want anything we can also use any other type in then another very common use case for enums is doing something like like a state machine so for example let's define a private enum for the state and on this state let's say we have the state looking for enemy then we have moving to enemy and finally attacking enemy so these are our various possible States and then we have some kind of function to handle the state so this is going to handle our state machine and over here we just do a switch and do a switch on our state so we would have some kind of state variable holding the current state for this unit and then we do a switch on that state and you case case something so case for example moving to enemy then we have the moving to enemy logic afterwards we do a break then we do all the other cases so looking for the enemy and so on so yeah this is a really simple State machine and you can see how by using an actual enum for the state that makes it much easier to understand as opposed to if we had the state being some kind of int and over here instead of these we would have just zero one and two and we would have to memorize what these numbers mean so just looking at this it is very clear just how good enums are with numbers it becomes really messy but if we apply some enums everything looks really understandable now enums also have an interesting property which is on the back end these values are actually stored as ins so to run some testing code over here I'm writing some code in the unity project so let's just do a private void start which is going to run this function automatically so now over here for example let's define a player action just a field of player action and let's set it to something for example let's say no enemy which is the first one that we defined so we Define this and now let's do we debug. log on displayer action and if we do this and here in the console we can see it pretty much print out a string of the state so no enemy however like I said on the back end these values are actually stored as ins so if we cast this down into an INT let's see what this one says and yep the int is going to be zero however instead of printing out the in for no enemy let's say the one for no path to enemy so this is the second state that we defined and you have this one now prints one so theorder is based on how you define them so the first one is going to be on essentially index zero then one two three and so on and you can also do the opposite so we can for example let's cast onto a player action and let's cast for example the number two any you casting the number two onto our enome does return moving toward enemy so due to this property due to how enom really are stored as ins in the back end because this there are some interesting things you can do with it for example another common use case for enom is when making some kind of game tutorial with various stages so You' have an enum for the tutorial stage then have like stage one which is like player teaching the movement controls in stage two stage three and so on so you'd have this kind of thing and then you will Define some kind of variable to store the current tutorial stage so let's say we're starting off on stage one and then we can just do tutorial stage Plus+ and let's do a log on this one so we're defining it as stage one then we're doing Plus+ let's see what this one says and yep it says stage two so it went on to the next inum value then we could simply compare against the last value in the tutorial stage in order to know if we've reached the end alternatively you can also handle the conversion back and forth using strings so for example string for the tutorial stage string and here let's grab the tutorial stage and call the usual two string function so this going to convert onto a string and now if we take this and we try to cast it to a tutorial stage if we do it that nope this does not work this is an error we cannot automatically convert the string into our enum so if you want to do this the correct way to do it is go inside the enum class this one exists inside system so we go inside of this one and then there's a parse or a tri parse so the only difference is this one returns a bone whether the par succeeded or not whereas this one assumes it always succeeds and you can see these also have versions with these angled brackets these are generics which I'm going to cover in more detail later on in this intermediate section so for example and since we know that the code perfectly matches the Eternal stage let's just do a parse we're going to parse onto the type of tutorial stage and we're going to parse this string okay so if we see this we should be able to see the usual stage two because we got stage one we increase it convert it into a string and then from a string back into our enum and if there it is correct then yet another thing you can do with inom is simply cycle through all the possible values and for that we can do for example for each for each inside the tutorial stage let's cycle through all the tutorial stages then in and now here you can't do for example tutorial stage. count. something no that doesn't happen that doesn't work so instead in order to get all the values you go again inside the inom class and for this one you can pass in get values and this one takes in a type so here to get a type we want to type tutorial stage but just like this nope this does not work in order to get the actual type object for that that we use the keyword type of and pass in our tutorial stage so yep like this it works so debug.log on this one and this should print out all of our possible elements inside our enum so let's just print some just separate from the other logs let's see and if there it is stage one two three and four all right so those are enums really useful in so many scenarios they are really easy to use and help you make your code a lot more readable and understandable hello and welcome I'm your Cod monkey in this lecture we're going to learn all About Properties in C these are kind of a mix between a variable and a function so you can sore some data and run some logic okay so properties these are actually pretty simple to Define so we Define them pretty much like a normal variable so we've got the access modifiers let's make it private then we have the type let's say of type string then we give it some name and the usual naming rule is for properties to use Pascal case meaning upper case on the first letter so for example player name and then if we just put a semicolon if we just do this then this is a normal variable it's not a property in order to make it a property instead of this we open and close a code block and now here we add two pieces of logic one is called get so let's do get and then a semicolon and then the other one is called set so let's set and then a semicolon and if that's it this is a super simple property and in order to use it over here in our static main function let's just Define this one as static so then down here in our main we can use it just like if as if it were a regular variable so we can go inside the player name and we can set it to something like Code Monkey so let's do this and then do a console the right line and let's print out the player name okay let's see and if there it is and does print out the name so pretty much the same as a regular variable however in reality this is not a variable in reality the C compiler is doing a little bit of magic in the background properties are really not variables they don't actually store any data directly so what we have defined here is what is called an auto implemented property in the background the C compiler is generating a hidden variable that does sore data for this property so we can also just manually do exactly that so let's do a private static string for the player name and again since this one is a variable we're going to use chemel case and then let's use it over here on the property so inside this code block for this get in this set we can actually expand upon it so for the get let's add a code block inside it and over here let's return our backup field so let's just return the player name the underlying one okay then for the set again same thing let's add a code block and for this one we want to set the player name so player name equals and then we use the keyword value so this basically going to be whatever value we assign to the player name so when we run this line of code it is going to run this sort of mini function and it's going to assign the value to whatever we assign here which in turn is going to assign it onto the underlying value okay so if we test like this and everything still works the same it still prints out Code Monkey so what we have over here is literally exactly the same as we had previously the C compiler simply builds all of this automatically in the background whenever we do a property where we have just a get in just a set and we do not Define any of these code blocks now here the get in the set these are pretty much functions which means you can write pretty much any code here for example we can do some validation so over here on the get function for example let's test if the underlying player name equals n so if it hasn't been set if so then we can return some kind of default so unknown if we do it like this and we erase the setting so we just have the player name uninitialized and if there it is now it does print out unknown so we basically added some extal logic onto our get function and when setting same thing we can also validate the value for example let's say this player cannot be named Code Monkey so we can test if the value if the value equals for example Code Monkey if so then either we can set the value to some default value or for example we can throw a new exception cannot name player Code Monkey by the way I'm going to cover exceptions in detail in a future lecture this is pretty much just an error message so if down here we can try to set the player name equals Code Monkey if we try doing this and if there it is right away we see an exception because again it is running our validation code and our validation code does not let usame this so usually this is the goal of properties which is how you can do something validation for processing either the get or the set function and one extremely useful thing you can do with properties is simply make different access modifiers for each of these now right now we made the player name we made this one private which means that both of these are going to be set to private and if instead we make this public if so then now both these are public meaning any class in our codebase can access either the get or the set however you can also add different accessories here for example we can leave the get like this in order for anyone to access it and we can make the set as private that means that this class can now access and set the value over here on the player name but other classes can only use the get so yep here we do see an error so I create the completely separate class named player and inside I'm trying to access the player name and modifyed nope I cannot use it because the set accessor is an accessible however if I do a console right line on this one if I do it then Yep this is perfectly valid code so this property can now be accessed we can access the get from any class anywhere in our code base but only this class can access the set so right now you might be wondering Okay so is this really all the same as just making a field with some get and set functions and yeah pretty much it is if we were to make a private static void set player name and receive a string for the player name if we do this and set the player name and then we have a private static string for the get player name and over here we return our player name so if we have this code and then up here and let's say we don't want any of this validation so we just have the basic Auto Implement property so just get any a set so you have just like this the property that we defined up here it is doing pretty much exactly the same thing as what we have down here we have a field with set and get functions and that's pretty much the same thing that we have here so these two pieces of code these are pretty much identical now I have to say that personally I'm not a big fan of properties simply because I do not like how they look like variables but act like functions personally I find that needlessly confusing if I want to store some data I want to use a variable and if I want to use some logic I want to use a function combining both in a strange way to me just seems really odd mod it seems needlessly confusing but that's really just me that's just personal preference a lot of people really like using properties in fact the official C documentation is full of properties so while personally I don't like them and don't normally use them it's not because they're bad it's really just personal preference so if you do like them feel free to use them in your projects for me the only place where I use properties is when I use the Singleton pattern I'm going to cover that in detail later on in the course but over here let me just quickly show you how the property helps Implement that pattern usually in that pattern you want some feel to store the Singleton reference but importantly you want only the Singleton class to be able to set that field while anyone else can get it so the property accessors are really useful for that so usually for that you make a public make it static for the Singleton pattern make it of the type that you are making the singlet ton so for example the program type then usually call it instance and then we have a get and a private set so y this way the access is exactly as intended by that pattern we have a public property with a public yet and a private set meaning this one can only be set inside of this class but any other class can get it like said I cover single tens in detail in a future lecture but I just want to show that this is pretty much the only scenario where I use properties for anything else I normally just make a regular field and if I need to I may get or set variables if I need to modify but again it's all personal preference so if you don't like properties then go ahead and use them okay so that's properties they are a really interesting mix between a variable and a function allowing you to handle store data and process it in some way when getting and setting hello and welcome I'm your kodm in this lecture we're going to learn about multidimensional arrays Okay so so in the basic section we already learned about arrays this is how we can store multiple pieces of data in just one variable we've got essentially multiple containers at each different index so now we can just go one step further and essentially make multiple dimensions of these arrays for example we can make it have two Dimensions so it has two axes and then each position instead of having just one coordinate it actually has two so for example on this array we can go on to position 0 0 and place some kind of number or we can go into position 2 three and place some kind of number go into 41 and draw something and so on so each of these positions works exactly the same as the elements in a regular array they can be set or you can get their value and this is an example of a 2d array so you've got a certain axis and another axis but you can have as many dimensions as you want you can have a 3D array 4D array 5D 6D or literally anything you want however this is also just one type of multidimensional array there are multiple types and multiple ways to build them so this is the syntax for building a regular onedimensional array so in then the square brackets in Array then create an array with some kind of size and one way to make a multidimensional array is to make an array with multiple Dimensions so to do that here when we Define array we include a comma for the dimensions so in this case we have two Dimensions so one on the left side one on the right side technically there's no limit so you can add as many dimensions as you want so here let's do a simple 2D array so we do that and then afterwards we just include the size for both dimensions and Y like this we have a two dimensional array on the First Dimension it has a size of five and on the second one it has a size of six this creates the array and then in order to modify a certain index we can just access it with the coord coordinates so go inside the interray and now on a flat array you would just put an index but this one is multidimensional has two Dimensions so we need to put the index for both dimensions so for example 02 and have this will access the element inside the array on position 02 you can use this to read the value or assign it to something else then when it comes to arrays you will eventually want to cycle through them and normally you would do some kind of four so four and I equals z i unless in the interray do length do this Plus+ so normally this is how you would cycle through an array how however now with a two dimensional array if we do this then this one this interray do length this one is going to return the total length so in this case it is going to return essentially 5 * 6 so we can do a console. right line to see so the interray length and if there it is the result is indeed 30 which is 5 * 6 so that's the total size the array when we have a multidimensional array in order to get the length of a single dimension for that we can access the function get length this one as you can see takes a parameter for the dimension so let's first cycle through all the elements in the First Dimension and then inside we can do another for Loop by the way I'm going to cover nested Loops in detail in the next lecture but yep just like this this is going to cycle through every element in the entire array will cycle through the First Dimension then the second dimension in order to go through every single element we can do a console d right line and print out the interray on position I and J this won't print out the value stored in that coordinate let's also just print out the I then Comm then DJ then something so we can see what we're seeing okay let's see and if there is we can see it all working so first checks position 0 0 then 0 1 02 and so on until it gets to one Zer so on and so on and all the vales are just zero because we just initialized all with zero but as you can see this is indeed cycling through the entire array through both dimensions of our multidimensional array alternatively for initializing the array contents we can do this note the difference between this syntax and the syntax we just want to mention so here we have some currently braces and then inside we have multiple pieces of curly braces one for each of the second dimension of the actual array and up here you can see the array being initialized so 0 0 has one two three then on one Zer it has like that one crucial important thing about these kinds of arrays and initializing it like this the shape needs to match so on the first one if we initialize this with four elements then the second one also needs to have four elements in order to have multidimensional arrays with differently sized elements for that we can use Jagged arrays which I'm going to cover in a little bit but before we get to that like I said there are multiple ways of doing multidimensional arrays this is just one way where you have a single array with multiple dimensions and the other common alternative is simply to have an array of arrays so instead of int and square brackets and having a common we have int and then square brackets open close and then open and close again this is basically creating a new array of arrays then we can do the usual cycle through it so for in IAL Z less than array. length here we can use length because again this is not a multidimensional array it is an array of arrays meaning it's an array and inside each position each element itself is going to be an array of multiple elements so we can do this i++ and we can go in Array on this index and inside it we create a new in Array of whatever length we want like for example six so basically what we have here is what we had previously when we had a multidimensional array with five and then six on the other dimension and then for accessing this one we access it by interray then access the First Dimension like say on position zero and then the second dimension let's say on position two so y this is how you set or read some elements from an array of arrays so this is also a valid way of starting multiple Dimensions instead of having just one array with multiple Dimensions you have multiple arrays of arrays and of course the same thing that I said a while ago about having no limit to how many dimensions you can have that still applies here so you can have as many arrays of arrays as you want so this code looks pretty insane but Yep this is perfectly valid code one crucial difference about these two types is basically defaults that they will use for example down here when we create an interray with multiple Dimensions when we do this by default all the elements inside of this array won't be on zero so like we see all the elements defa to zero whereas on this one since this is an array of arrays if we just cycle through the main array if you try to access this one so let's do a console do right line on this one so let's print out the array on this index let's do that and see what this prints out to see basically what each element of this array defaults you and if there it is the answer is essentially null we can compare this equals null and if there it is true so all of these elements are set to null so there is one big difference between array of arrays and multidimensional arrays these get initialized with every value at Z zero on whatever type you're using for the array whereas this one since each element inside of the main array since each of those is actually an object It's actually an array of something else because that by default the default value for some kind of array is going to be null because arrays are reference types as opposed to Value types which by the way I cover value and reference types what those are I cover those in detail in a future video and then another difference between these two types one thing that you can have with array of arrays but you cannot have with a multidimensional array one of those things is what is called a GI array meaning each subarray can have a different size down here when we Define the small dimensional array by default the shape of this array of multiple Dimensions the shape will pretty much be a rectangular size so over here five in one dimension and six on another one it will always have some kind of rectangular shape however in Array of arrays that does not have to be the case for example when initializing this we can set the one on index zero to be a new interray and let's say this one has a size of three then on the next one on ele index one we can say this one has a size of six then on index two we can say this one has 10 and so on so using an array of arrays technically each array inside the main array each of those can have whatever size you want as for what use case this would have for example imagine some kind of grid for a theater when you go to movies and select a seat usually different rows have different number of seats so that's an example where this kind of data structure could be useful you would have maybe three seats on the first row then six on the second one and so on so that could work it does have some use case although personally I pretty much never use them since in games usually things have some kind of rectangular shape things like an inventory or World usually those have some kind of rectangular shape as opposed to some weird Jagged shape now when working with multidimensional Rays we need to cycle through them just like we saw so let's learn about nested Loops in detail in the next lecture hello and welcome I'm your kmy in this lecture we're going to learn about nested Loops okay so let's see what they are they are really simply just a loop within another loop so for example let do a for Loop for in I equal Z let's say less than three I ++ so a regular for Loop and then inside it we can write another for Loop let's say in J equals z J less than 2 j++ and by the way usually the convention for these iterator variables usually use the variable I then you use J then if you need more you need k l MN and so on that's usually the standard convention but it's not a requirement it's really just a convention so these can be named whatever you want but in general I and J are very commonly used so over here let's do this let's do a loop inside another loop and now let's print out the I and J to see exactly how this code is running so let's print out I then a little comma and then J okay let's see and if there it is so we start off with an i of zero and a j of zero and then we have an i of still zero but then a j of one meaning that for each time this Loop is running this one is going to run as many times as this Loop is meant to run so it goes inside this inside this runs this line then when this one ends goes back into this for Loop and runs this line again then this one reaches the end so that is why this one ends and again goes back into this one which again runs this Loop starting from the beginning and runs more and more and so on so here it is running 0 0 0 1 1 0 1 1 two 0 and 2 1 the important thing to remember here is the code execution order meaning for every time the outer loop runs the inner loop is going to run multiple times two times in this case also remember what we covered in the basic section about variable scope if you define some kind of variable inside this in Loop like a int H equals 5 if we do this and down here you try to access the age nope that does not work if you define something inside the scope of this inner loop it does not exist outside of it and here we have one Loop but technically we can have as many as we want again the same logic for every time that this Loop runs any Loop inside of it will run as many times as those run as you can imagine if you do a ton of Loops within other Loops if you do that it becomes really hard to understand the logic the deeper you go so usually just having one less Loop in most cases that is the most you should do then we already saw these briefly being used in the last lecture covering multi dimensional arrays that's a very common use case so here it is that same code so we've got the outer loop going through the First Dimension and then we got the second inner loop that one is going through the second dimension and by doing this this is going to cycle through every element inside of this multidimensional array then on Loops there are two important keywords one is called break and this one breaks out of the innermost Loop so for example if we don't include the break let's see how many times this prints with the value on J and if there you go the value on J goes from 0 to 1 0 1 and so on but if we add a break over over here and if there it is now the J only goes to zero and immediately breaks out of that inner loop now the important thing to note here about break is how it only applies to the innermost Loop so this one does not break out of the outer loop as you can see the outer loop still run 0 1 two and so on so break only affects the innermost Loop if you do want to break out of the uttermost loop if so you can Define some kind of ball break from Loop you set it to something like false then inside this one you do some kind of logic that would eventually set this one to true and then down here you would test that and if so then call break and let's see and yep now this one does go inside as soon as it goes inside sets a break to true and breaks from that one so breaks from the inner loop and once this one is through it also breaks from the outer loop now the other important keyword is continue this one continues or pretty much skips to the next iteration of the loop so if we write some kind of code after this continue so let's do a light right line and write something like this even Visual Studio is telling you so this line is slightly faded because it will never run so unreachable code detected that is because as soon as the code gets to this continue it is going to ignore everything afterwards inside this Loop and go to the next iteration of this Loop so if we run this and if there it is it runs through every single element so the J is only 0 1 01 and so on but note how our second message this one did not ever show up if we were to put this inside some kind of if let's say if I equals z then continue so basically on the first I when the I is zero then it should not print this message but on the other ones it should and if there it is so once on zero it is going to continue and ignore this line but on the others it is going to run this line and again again same thing as previously note how this one only applies to the innermost Loop even when we're running our continuous over here on I of zero note that the I still runs all of them so 0 1 2 so again always remember that break and continue those only affect the innermost Loop now I should also say that break and continue are not specific to just Nest Loops you can use these keywords with any Loop including just a single regular for Loop or some kind of for each for example if we have some kind of player class so for example here's some simpar code so we've got a basic player class then we create a list of type player then we create a new special player we add that special player onto the list and then three random players then we do a four each inside of that player list cycling through every single one of them and then we check if that one is a special player if so let's continue if not let's write the name so if you do this we should be able to see the print of only three players and not the special player because that one will be skipped over here on the continue and if there you go exactly that three players and no special player now also on the topic of nest and Loops here we have a four inside another four but you can list any Loop of any type so for for example over here we can have a four inside another four and then inside both these fours we've got our 4 in so this perfectly works or we could replace this with a while or do while so literally anything works so as you can see neston Loops can be really useful especially when cycling through multidimensional arrays but if you go too deep if you Nest too much it can negatively affect code readability if that's the case consider whether you really need to make that Nest Loop and if so perhaps consider making a function that in itself has a loop then within some kind of other loop you just call that function so just be aware that Ness Loops can become messy very quickly so do be careful to use them properly and only when needed okay now that we've learned some more advanced us case for Loops we are ready to learn something that some people find quite complex which is recursion so let's learn that in the next lecture hello and welcome I'm your Cod monkey in this lecture we're going to learn about recursion which is a different way of doing Loops or just running logic multiple times okay so recursion this sounds like a really fancy word but in terms of logic it's really super simple it really just means a function that calls itself so for example over here let's make a function so private static void let's call it test recursion so we have this function which does some kind of thing and then inside this function we call itself and up here we call the first function so y That's it this is recursion it's pretty much just a function which inside calls itself now right away you might be able to tell a big issue here you can probably already tell that this is going to be an infinite Loop since this function will call itself for infinity and actually if we try to run this code we actually get a fun piece of trivia yep here we have an infinite Loop that eventually ended and it end with this error a stack Overflow exception and Yep this is where the famous website got its name basically as you call functions your CPU stores references to those functions in something called a call stack that's a stack of all the functions that have been called in the current process the CPU needs to know that so that it knows that when a function ends where should it jump back to but of course memory has the limit so if you call a function within a function way too many times eventually you reach that maximum which then caus the stack to loop back which in turn is called a stack Overflow so with this code we have an infinite Loop not very useful but like we already saw in the last lecture and in the beginner section Loops can be extremely useful and recursion is really just one type of loop so with recursion we can do literally anything we can do with normal Loops for example let's write a while loop let's increase some kind of number one by one until five so here we have a simple while loop so we Define number of zero and while the number is under five we just incremented so that's it pretty simple now let's do the exact same thing using recursion so on this we have a function and really since recursion is all about a function calling itself all we really need to do is pass in our variable as our parameter so we can just receive an inert number and inside do number Plus+ however just like this it won't work since like we saw on the electr on scope and functions function parameters are actually local variables so when we call this function with this we're working with a copy and not the original data so to get some kind of result back from our function let's simply set it as our return type so let's return of type in and then here we can do our logic and basically then do return number in order to return the final number so now when do we want to return the final number so now let's do the same condition that we had up there so if number is under five so we do if the number if number is under five if so then we're going to call test recursion again and we're going to return it with number + one and in order to get the data back let's call it return on this and if not if the number is above or equal to five if so let's just return the regular number so just like this let's just give this a proper name so let's rename this to recursion increment then up here let's call the same thing and we're going to start off by calling it with number zero and let's do a console. right line on this to see the result so let's see the result on this one and also a console. right line on the other number made with the regular W Loop okay so let's see if both these do return five and if there it is they both return five so we both have this logic that this one is going to run this logic multiple times and this one is also going to run the same logic multiple times so here as we call this the first time number is going to be zero and if number is under five if so then this one is going to return the result of this function and this function call will pass in the number so 0 + one pass in number one so once again that is going to go inside this function now with the number one which again still under so it's going to return another call of this function which again with the number 1 + 1 equals 2 and so on and as soon as it gets a five just Returns the final number so basically here we are stacking multiple function calls on top of one another and when the final one returns they all basically return and the call stack collapses and we end up with the finnal final result then if we wanted instead of having a hardcode maximum over here we could have another one as a parameter so an end for the number Max so we have that and we receive it here and we just pass it along the same way onto the next function call and then we could also have a parameter for the incrementer so increment amount so we have this one instead of increasing by one we increase by the increment amount so then over here let's put it five and then one and over here let's also pass in the incremented amount and have same result 55 and what we have built here is essentially the exact same logic as some kind of for Loop if you remember the for Loop has some kind of initializer iterator variable then it has some kind of condition usually some kind of maximum number and it increments by a certain amount so what we have here is literally the exact same thing as a for Loop except it's being handled with recursion so all the logic you can do with any kind of loop you can do with recursion this is really just an interesting way to handle running logic multiple times by simply being very clever about how a function can call itself multiple times now I should also say that personally I'm not really much of a fan of recursion in general I find it needlessly confusing I much prefer to have a simple for Loop where I can very easily see the iterator and the end condition as opposed having to look at the parameters for a function and trying to guess when it will stop calling itself so personally for me I pretty much never use recursion I always use just regular Loops I find those much more straightforward but recursion is a valid option so I definitely wanted to cover it especially if you're into advanced mathematics if so then you might actually like it since mathematics has a lot of this kind of stuff if you like that then perhaps for you recursion might be much more natural much more intuitive than working with regular for Loops just always be careful the same issue with for Loops which is always be careful not to end up with infinite Loops hello and welcome I'm your kod Maki in this lecture we're going to learn about one of the most useful collections the dictionary okay so dictionaries are a super useful data type for storing multiple pieces of data and doing so in a very organized way dictionaries are all about key value pairs meaning that the dictionary itself is a whole container and inside that container you store various keys so like some key for stone some wood and some gold and then for each key each key has a corresponding value and then that value can have whatever that you want importantly is both the key and the value both these can be of whatever type you want so for example in some kind of game starting the resource amount the resource type itself can be the key and the amount that you're currently holding that one can be the value if you were to build something like that using an array or some kind of list if so then you would have to memorize that for example index zero that one refers to Wood index one refers to Stone index two to gold and so on so you'd have to memorize what type each index belongs to whereas with dictionary the key itself can be very descriptive about what value it stores you can use a proper name or a proper object reference that makes a lot more sense than keeping in mind what index belongs to what now to build a dictionary this is actually super easy we just type in dictionary and then we open up the angle brackets now this syntax these are generics kind of like we use on the list I'm going to cover generics in detail in a future lecture in this intermediate section so we open the angle brackets and then we have two types the first one is going to be whatever type we want for our key so for example let's define enum for that so private enum for the resource type so we have this and then inside for the values let's go with stone then wood then gold okay those are the values for our resource type and over here we can use that resource type itself as our key and then for the value type let's say we just want to store the amount so let's use a simple int so let's let's name this resource type amount dictionary and then we can simply construct it so just new dictionary of this type okay just like this so this is going to create our dictionary but so far it's going to be just empty to add a key value pair we go inside the resource app amount dictionary inside our dictionary and we call the add function over here we need to pass in the key and the value so let's pass in resource type let's say Stone then for Value let's say 56 see if this is going to add the Key Stone onto our dictionary and it's going to link the value 56 with that stone this is how we can add a value and then for reading a value we do it pretty much as if it were an array so we use the square brackets and inside here we put the type for our key so in this case our resource type do stone so if we do a console downright line on this one let's see any y it does print 56 okay great now one key point about dictionaries is that the key itself this one must be unique so if we try adding a value on the same stod key if we try adding some kind of value nope right away we have an error an item with the same key already has been added so remember that each key must be unique if you want to update the value we can just access it so as if it were an array and then set it to something and Yep this will work now when getting a value if we try getting a value that does not exist so if we try going to this on the resource type. wood if we try doing a console. right line on this one yep here we have another error key not found exception the given key was not present in the dictionary so if you don't know whether a certain value exists you have two options first you can just check to see if it's contains that key so access the dictionary and call contains key then pass in the key so this will return true or false if this key exists inside the dictionary or not that's one approach and the other one is to access the dictionary and call try get value this one like the name implies tries to get some kind of value for some key so the first parameter is going to be the key so let's say resource type. wood and then the second parameter this is the first time that we're seeing this this one is not just an INT value parameter it is an out in this means that it's an output parameter this is a more advanced topic that I cover in detail in the advance section for now just know that this is an output parameter so this function is basically going to return both so it is going to return true or false true if the dictionary has this key and false if it does not and if it does have then it's going to Output whatever it is in here so let's Define a variable for the wood amount so if it does have wood then it's going to store the amount on that one so then we can see if this one does have this value if so then let's print out the W amount except we didn't add so this should not run and if there it is that doesn't run but if over here instead of assigning Stone let's assign to Wood and if there it is now it does run again if you're not familiar with this output syntax don't worry about it I'm going to cover it in more detail in a later lecture if you do use it just know that it has this syntax also like we saw we can modify values so we can go inside this resource type. wood and set it to something to modify it so this works but this also works for simply adding values so instead of calling that add you can just do it like this and if it does work and does add that value and of course since we can add values we can also remove them so we can call remove and then pass in some type of key so let's say resource. wood so this should remove the key so then this code should not run and if there is doesn't run so here we are creating a dictionary and then afterwards on a separate line we are assigning values but like we have with arrays and class and so on we can also initialize the object directly when we create it the way we do that is we open and close the Cur braces so the same as we do to initialize some kind of array or list and then inside it we put whatever element we want to initialize inside this dictionary but remember dictionary is a key value pair so we need to somehow Define a key and a value pair over here if we just do resource type. Stone and then 10 if we just do this nope this is an error the correct way to define a key value pair is with another pair of curly braces so put this one inside open and close just like this and then if we want to initialize more we can just start with wood and something and so on now importantly here pay close attention to the syntax so we've got currently braces on the whole dictionary and then again for each individual key value pair now one common thing you're going to do with dictionaries is simply cycling through them for that we can just do a four each directly on our resource type dictionary and for this one the iterator variable will be a type key value pair simp like this and then inside this one we can access the key or the value so let's do a console. right line this one. key and let's do a colon and key value. value let's get rid of this code and let's test and if there is second through the entire dictionary and prints out Stone and then the amount alternatively instead of sing through the dictionary itself inside of here we've got a keys collection this just basically going to scroll through every single one of the keys so over here you would have just resource type just resource type this would be the key and then you could simply access and print out the resource type and then go inside the dictionary on this type to see the amount and if there is same result so this is the other type for each and also finally you can also cycle through just the values and on all of this always remember that these are really just key value pairs meaning it's up to you to Define what value you want to use for the key and the value it does not have to be just simple types like ins and enums for example the key can be some kind of player class and the value can be some kind of weapon class that would be perfectly fine so just remember that it doesn't have to be just simple types you can use whatever type you want for the key and the value now here's a bonus tip specific to Unity let's say you want to build some kind of resource manager something like this so you have a resource manager class and inside You' got a dictionary of resource type and an INT but then you want it to be preset with some amount that you want to set in the editor but the issue with dictionaries is that Unity does not serialize them so even if we add serialized field private even if we do this here in the editor nope we do not see it the resource manager has no Fields nothing shows up in the editor so instead here's a neat trick you can do you can create a custom class and on that class you basically use the key value pair so here I've got a resource type and an INT amount now importantly we need to mark this type as serializable in order to show show up in the editor and if we do and then we just make a list of this type if so then Yep this one does now show up over here in the editor so we can set it to something and then we have all of our elements of our custom type so we can set all of them to whatever we want so there it is all the various values all the various keys and then on this same script over here on the awake we just create the dictionary we cycle through the list that we exposed in the editor and we just go inside the dictionary on that type and set it to that amount then we can just print out the concept dictionary and here in the console we can inde yep we did create the dictionary and we did initialize it with our data all right so that's the dictionary it's a super useful data type really helpful when you have two pieces of data that can be connected like a key value pair so this is absolutely essential in things like resource management or linking any kind of data together with one another hello and welcome I'm your Cod mon in this lecture we're going to learn about some other collection types like cues TXS and a bunch more okay so in the beginner section we already learned about arrays and lists then in the last lecture we learned about dictionaries honestly those are really the only collections that I normally use myself but there's still a bunch more that can be useful in certain scenarios so here let's see them one simple one is called the stack think of it like a stack of papers you can place papers on top so you can push them and for grabbing a paper you can only grab the one that is on the top in this case on the stack grabbing simply means pop so you can push and pop elements this is what is called a first in last out collection or also known as f here in the code the way we do it is super simple we just create a new stack this one takes a generic type so similar to the list so let's say a stack of strings let's call name stack and we construct it then on this one we can call the function push in order to push values onto the stack so let's push the string Code Monkey then let's push the string for Iron Man and let's push the one for SpiderMan okay so with that we push them and now if we go into the stack and we call Pop this one is going to remove and return the object on top of the stack so like I said this is a fellow collection meaning first in last out so ask yourself what do you think this will return this is the first element that is added so technically this is going to be the last one out so let's do a console down right line on this okay let's see what this returns and you correct this does return SpiderMan like I said first in last out so we first put Code Monkey so this means this is going to be the last element that we're going to grab and when we pop we are going to grab the one that we last put on there which is going to be this one and eventually if we don't put up anything so if we comment out all of this and we try doing a pop yep here we have an error the sack is empty so to avoid that we can use triy pop which will try to get an element if it exists and if you want to just look at the last element without removing it we can call Peak okay so that's a stack another related collection is a q this one the easiest way to visualize is some kind of queue of people so the first person that gets added onto the queue is going to be the first one that gets out so this one is a fivefold collection first in first out the way we build it is pretty much the same as a stack except this one is a que so then let's make a queue of string so for the string q and let's construct it so a new one and build it then on the string Q in order to add elements we call in Q so again same thing let's ass in Code Monkey then Iron Man and finally SpiderMan okay so we queue all of those and now on string Q we call DQ in order to grab the element this one again like the pop that we saw previously this one removes and Returns the object so if we do a console. right line on this one again Q is fifo first in first out so let's see what this one returns and if this one returns Code Monkey which was the first element that we add so some practical examples a q can be useful in something like a tycoon game where you have literally a queue of people like for example in my own game battle round Tycoon when there's a queue to join each Arena and for the sck a great practical example is how this can be very useful for making some kind of undo system so maybe something like a city Builder you can push onto the stack the action to place a building somewhere and then to make an undo you simply revert that action which would eventually demolish that building now importantly you always want to do it based on the last building that was built and not the first one so these two collections definitely have their own use cases although like I said normally I just use lists I've built both these systems like a q for a tyen game and an undo kind system I've built both of these using just list remember how on a list you can access the list on index zero and call remove that to remove it from a certain index so similar to a que or you can also just access it the last element on the index the last element on the list similar to a tack so personally I normally do all this custom logic using list but if you like these two collections can be quite useful so just remember they do exist next collection is what is called a hash set this one allows you to store a set of elements so let's make a hash set of string so for the string hash set let's construct it then go in the string hash set and this one we call add to add elements so for example add the element code monkey and Yep this one does work however one important thing about this type the hash set the important thing is that all elements have to be unique so like this it works but if I duplicate it and now I do a console. right line and let's print out the string hash set. count in order to count all the elements so we're adding two elements and then counting it so let's see what this returns any if this one returns a one because again we added a duplicate element so it actually didn't actually added so you can add elements you can remove elements and you can also do a union to combine multiple hat sets so the hashset can be useful for some kind of elements where you always want it to be unique so maybe a player ID so for those kinds of use case it can be a useful collection the next one we have the sorted list this one pretty simple like name implies this is the same as regular list but it gets sorted automatically so you can make a sord list of int another collection is a sorted set so this one pretty simple same thing it records a set of elements and it is constantly maintained in a sword order alternatively you also have a sword list this one has a key value pair then you have the sord dictionary and so on so there's a bunch of collections that serve various purposes like I said personally I really just sick with arrays lists and dictionaries I normally don't use any of these but it is good to know that the language can do all these things by default maybe you have some use case for which the queue is perfect so definitely make sure you know these collections exist hello and welcome I'm your codm in this lecture we're going to learn about the prams keyword that we can use in a function which then allows us to call it with any number of parameters okay so let's make a function to see it so let's make a private static void let's call it print player name and receive a string for the player name then over here just a console. right line on the player name so that's it super simple just a regular function like any other and up here we can call it and call it with code monkey and hope it does work it does print great but now let's say that I want to support two player names I want both of them I want support for both one player name and two player names so in order to do that I need to copy paste this and make another one with player name and then player name two see if this works but now I have two functions one with one parameter and one with two parameters and now let's say I want to support three parameters so again I need to make another function duplicate a ton of code and so on so right away you can see the issue this is basically the problem that pram solves so for that let's make just one function and up here let's call it to two parameters and right now yep we have an error because this one can only take one parameter so now here for the parameter let's write the keyword params we write params and then we write write the type for the parameter and in order to use with params this type needs to be an array so let's make a s array and for the player name array and up here let's just do a console. right line on this one. link just to see how many we call and right away we can see we have no errors up here so calling this function with two parameters does work let's run it and Y it prints out two and now let's call this function with just one parameter and again no errors and yep now it prints out with one also if we pass in with no parameters and yep we do have an empty array so that's it super simple you can just add the prams keyword and that way now we support any number of parameters this only has two requirements the first one is that the type over here needs to be an array for example if you make string it does not work if we make it just ring then no it does not work if we make an array of multiple Dimensions this one also does not work so it needs to be an array of some type it can be string it can be int it can be pretty much anything and the second requirement is that this one needs to come at the end so afterwards if we Define an INT H nope does not work here we have an error and the a says here a params parameter must be the last parameter in a parameter list so if we want to combine a params along with regular parameters we need to make sure the regular ones come before and the params comes after this way now yep up here we can type in an INT and then any number of strings and yep all of this does work that's it really simple and sometimes quite useful so anytime you have some function where you would like to receive any number of parameters whenever that happens always remember to use the param keyword hello and welcome I'm your kodm in this lecture we're going to learn about how we can use optional parameters in a function meaning parameters that we are not required to use okay so here is a normal regular function it supposedly spawn some kind of unit so it takes a spawn position the type of the unit the spawn rotation and some kind of Health amount and then to call this function we call it as usual so we call it and pass in all of our parameters if we run this it would work spawning unit of type melee with health 56 on this position this rotation but now let's say we want to spawn a ton of units and we don't want to be forced to pass in all of these parameters especially for example if some of them are going to be default to some amount there is going to be copy pasted all the time let's say for example the only thing we want to care about is the spawn position and then it will default to all the other ones so one option would be to Simply make another version of this function so let's make another one and let's make another version that only takes a spawn position and then in turn that one calls the other version passes in the spawn position and then passes in defaults for all the other ones so let's say melee turn. identity in order to have the regular rotation and let's say 100 Health amount so we can do this and now do this and spawn on new Vector three of 1050 something like this and if there it is we have no error and running the code yep it did work it did use those defaults and the 1050 position so this works this is one valid option but we have another option where we don't need to Define multiple functions we can simply use optional parameters to use them it's really simple so we just have our function with our parameters and then after the parameter we simply write an equals and then assign some kind of default value so for example for the health amount let's default it to 100 and now up here when calling this function we need to include all the other parameters so for this one let's include the unit type and let's include a quaran rotation but now we don't have to include a health amount so like that this one has no Health amount and if we run yep the health amount defaults to that 100 default so it's really this simple you just set equals and then some kind of default value we just have a few simple rules for how we can use this first is how the optional parameters these have to appear after the mandatory parameters so for example if here on the UN type before the Quan if on this one I Define an optional parameter like this no here we have an error it is saying optional parameters must appear after all the required parameters then another rule simply has to do with default values also by the way like I mentioned in the beginner section the compiler doesn't really care about new lines so if you have something with tons of parameters you can just place them all in a new line that way it becomes a little bit easier to read so like this okay so like I said the second rule simply has has to do with default values and the rule is how default values need to exist at compile time so here we cannot construct an object we cannot do new quion and then construct a new quion with something nope this does not work like it says here default parameter for Value spawn rotation must be a compile time constant so we cannot do this but we can use for example the qu. identity this is a constant and yep so we cannot use that but we can use the default keyword this will basically use the default value for that type so in the case of a quan which is a struct it is simply going to initialize that struct with everything at zero so for this struct we can use this and for the vector 3 same thing we can use that and for the unit type this one is an inome so we can just sign a default value and like this and everything works alternatively we can also use constants which is something that we're going to cover in a few lectures so you can define a constant and then you can definitely use that constant as a default value so optional parameters need to have certain defaults in order to work and then over here for passing in the parameters since we marked all those as defaults we can call it just like this and yep the code runs it works and works with all the defaults then alternatively we can pass them in one by one so for example if we want a spawn position let's put some kind of Spawn position and then for the unit type let's say we want like this so yep we just assigned two parameters and yep it did work but now let's say the only parameter that I want to assign is just the health amount so for that I go up here and I just write some kind of in so just 56 and no this one obviously has an error because argument one it expects a vector three not an INT so just like this you need to pass in all the parameters in order however you can actually pass them without being in order and for that we really just need to write the name of the parameter so in this case the parameter is the health amount so we write that and then a colon and yep just like this it does work this is basally calling the function and assign the health amount parameter to this value and on the other ones since we didn't assign them these Remain the defaults and if you're running the code we do see with health of 56 also by using the same method we can pass in parameters in any word you want so for example the health amount then let's pass in the unit type so unit type and unit type. something and Yep this is definitely valid code as long as I write the name of the parameters and then callon then give it a value everything does work all right so that's optional parameters it's quite a useful feature to help you avoid having tons of function versions for all kinds of parameter combinations hello and welcome I'm your Cod monkey in this lecture we're going to learn something very important the difference between value types and reference types if you don't know the difference then at some point in the future you won't go crazy because you think something is behaving as a reference when it's behaving as a copy so in C you have several types and mainly they are either value types or reference types reference types they store references to their underlying data whereas Val types they contain that data directly some examples of Val types are the symbol types like int float Bull and so on these are all value types and for reference types these are things like class object arrays and strings however importantly struct is a valid type we're going to cover strs in detail in the next lecture they look similar to classes but this is the one big difference between them strs are value types and classes are reference types and over here as you can see arrays are reference types even if the underlying data if you're making an array of int ins by themselves are value types but if you make an array of int the array is going to be a reference type and then strings are a bit of a special use case in that they are technically reference types but in some cases they behave like valid types so the big difference is shown down here with reference types you can have multiple variables and you can have all those variables all of them pointing to the same underlying object whereas with value types any variable you make with some kind of value if you then assign that variable to another variable you are making a copy instead of a reference to the original value another difference is how reference types can be null whereas value types cannot so for example if you have some kind of enome for your weapon types if the player does not have any weapon you cannot set it to null enums cannot be null neither can inss floats balls and so on so here let's see some code first let's define an INT which is a simple value type okay very basic just the variable named a and contains the value seven but now let's make some kind of class which is going to work as a reference type so here let's make a class call it my class and inside let's just expose an INT a okay and now up here let's create a new my class so my class equals a new my class and then let's go inside that one and set the a to some kind of value let's say seven and then let's make another my class call it my second class and now let's assign this one to the my class and over here we go inside the my second class and modify a to a different so here now we have two different variables we're initializing the first one like this then we're assigning it to the second variable and then we're modifying the value inside of the second variable so if we print out over here the my class. a what do you think this will say so let's do a console. right line and print this out let's see if it says seven or five and if there it is it does say five again that is because classes are reference types so over here even though we have two separate variables they are both pointing to the same underlying class so they're both pointing to the same underlying memory position they're both pointing the same actual object both them are referencing just a single instance of our my class so by going through either of these we're actually modifying the same underlying object we do not have two objects we have just one and two references to that same object so when we modify this one we're not modifying it just on this second object but since this one has the same reference as this one both of them are modifying the actual underlying object so by modifying either of them we are modifying the same underlying object now let's look at this exact same example but using our ends which are value types so you've got an INT a of seven then let's define an INT B and let's assign it to the value of a and then let's go inside B and set B to something else let's put it on five and now let's do a console. right line on a and let's see what this one prints so we print seven or five and if there it is the result is seven again this is because int int is a value type and not a reference type so over here we're defining a variable a and assigning the value seven and then we're assigning B and then we're defining B and assigning it to the value of a but again since a is a value type this is going to essentially copy the data that is currently stored inside a so after this point we have two variables and each of them holds a copy of their data and then over here when we modify B that is only modifying the copy that was created in here and not modifying the original data that we have in here this is the one big difference between valid types and reference types is how up here we are working with a reference and we have two references that both of them point to the same underlying object whereas down here we have copies so we have one copy here one copy there and by by modifying the second copy this has no relation to the original data now the scenario that is most important to know this difference is when working with structs which we're going to cover in detail in the next lecture for now don't worry too much about what they are I just want you to see the difference so a struct is made pretty much the same way as a class we just change the keyword into struct and let's name this my struct so like this and up here we can write literally the exact same code but write it with a struct instead of our class so up here use my struct then over here here this one is my struct and my second struct and then we modify this one here and we print out the my struct a okay so here's our test literally we have the same code down here as we have up here the only difference is one code is working with the class another one is working with the struct so let's see the difference between these two ending up with the exact same code we have two different results that is exactly because of the difference between value types and reference types the class has a value of five and the struct has a value of seven that is because the class up here again both of these are referencing the same underlying object so when we modify the second one we're both modifying the same unlying object so when we print out the data stored in the first one again same object so this one prints out five and yep we do have five and then down here when we're structs structs are value types so over here we create a brand new struct but then on the second one when we assign it we're actually creating a copy of the data so now this one this one has a completely separate copy that has no relation no reference to the original data to the original myru so when we modify this one we're only modifying this copy and not touching this one at all so that is why on the Str the result is seven which is the original value that we set over here because when we modify this we're only modifying this copy and have no relation to this original data now this difference between Valu reference types is also very important in functions for example private static void my function let's do some kind of test function and here let's receive of type my class another one of type my struct then let's just go inside and put it on something so my class and my struct let's modif if I so do the exact same test as previously let's just comment out this testing code and then over here let's create a my class my class let's create a brand new one then let's put my class set the a to 7 and create a new struct we also set it at seven so both them have the same value in their a field and then we call my function pass in our my class and our my struct and then let's do a console. right line on the my class. a then some space and my struck. a okay so again let's see what happens and yep there it is my class has a value of five and my struct has a value of seven again that's the same difference between valid types and reference types it's how when we call this function and we pass in our values the class is going to be passed in as a reference so as we modify this one we're actually modifying the reference so we're modifying the underlying object that was sent into this function whereas for the struct the function receives a copy of the data so the copy that we receive over here inside the function this has no relation to the actual data defined up here so so whil inside this function modifying this class modifies the actual data outside of it but modifying this struck only modifies the local copy also what I mentioned while go about how AR raise our reference types so for example let's do another test so let's make our function take in some kind of int and then an interray then over here let's modify the value of a and let's go inside the interray on index zero and let's modified value okay so now up here let's define some kind of int and let's define an INT array let's construct an interray and just put a value on there okay so now we call my function pass in a and the interray and now let's do a Conant out right line let's print out the A and then print out the interray on index zero okay so again let's see what this does and if there it is same thing the int was not modified inside the function but the array was that is because inss are value types so this one is passed in as a copy but in arrays these are reference types so when we pass in an interray onto our function we're passing in a reference to the original data so when we modify this inside the function we're modifying the actual original data and also since we're on the topic of value types and reference types I mentioned a while ago how value types cannot be null so you cannot Define an INT b equals null so this is not possible we have an error cannot convert null into n because it is a nonnullable value type however if you really want to do this you can do it instead you just have to use a custom type called nullable and with this you can make any value type like ins BS floats and so you can make any of those into nulls and this is something that can sometimes be useful I cover nullable in detail in a lecture in the advance section okay so that's the differences between Val types and reference types be very very careful with this difference it might sound like I repeated myself way too much during this lecture but that's because this is really so important always keep in mind whether you are working with a copy or a reference one of the most important ways to see this difference in action is in the difference between classes and structs so let's learn about strs in the next lecture hello and welcome I'm your codemy in this lecture we're going to learn all about structs these are structures of data that are similar to classes but also a little bit different okay so structs like I said are pretty similar to classes in how you define them you literally just swap class for struct so for here for example let's make a class named player right now this is a class and just by swapping this into struct yep now this one is a struct so that's it super simple however just doing this has some really important implications the main one is how classes are reference types and strs are value types which is what we covered in the last lecture this means that when you use something as a class like a class parameter it gets passed in as a reference whereas with a struct it gets passed it as a copy so here we can do a simple quick test make a player struct and a player class then just run this code just making the usual start function because over here I'm working in unity let's make a private void test function test function struct and another one test function class okay so here is some code we create a new struct and new class and we assign a field in set of them to the value one then we have have two functions and these functions these do the same thing so they just set that field into two and then we do a log so let's see whether this one keeps the number one or whether it keeps number two any like the log says here the struct keeps in number one whereas the class keeps in number two again that is because struct is a value type meaning these are passed in as a copy so over here we are modifying the copy and not the original data but classes are reference type so when we modify a class inside a function it modifies the actual position memory the actual original object so the reference type gets changed but the value type does not get changed this difference is really extremely important so I truly hope you fully understood everything in the previous lecture if not go back to it and rewatch it it is really important so you don't get to confused like I did many times before I memorize this this is one of the main differences between structs and classes how classes are reference types and structs are value types in general structs are mainly used as just data containers meant to organize your data the simplest example is really just the vector three type inside of unity so we can inspect this one so let's right click and go to the definition and up over here we do see this is a struct and it's a struct that pretty much just hold three components so x y and Zed so rather than having three separate Fields whenever we want some kind of position we just make a struct that in itself has these three Fields whenever we have several pieces of data that all of them make up one logical unit then perhaps consider making that a struct however again remember how it's a value type for example in unity you cannot even directly modify one of those components so if I set the position do 5 equals something if I do this nope it does not work now technically this is more related to the fact this position is actually a property and not a variable but still the reason why it's a property is because it actually copies the data and sends it over to the back end of the engine itself so in unity when you need to modify something you need to assign it to a new Vector 3 so basically you need to give it another copy of another piece of data in order to actually modify it so usually structs are used in an immutable manner meaning they never change once you create a struct with a certain value usually you keep it at that value however that is not an absolute requirement it's really just a good convention to follow for example the Vector three struct so let's do a position Define it as something 10 21 something and like this this struct inside actually contains the normalized function and if we do this and then do a debug down log on this position let's see Yep this function does indeed modify the underlying data so in theory strs can indeed be mutable they can change but in order to avoid confusion you should probably avoid this as much as possible you should probably always treat your structs as immutable just following that one simple rule will make things much simpler to understand now strs like classes they can have Fields they can also have functions like we saw here the normaliz and they can even have properties one big difference is how they cannot inherit I talk about inheritance in more detail in the next lecture but basically with a class you can make it inherit another class so po class base class and then poly class for some kind of unit class and this one can extend Base Class so this works this is valid code but over here on this player struct if we try extending Base Class nope and error struct s cannot extend classes the one thing they can do is actually what this error message is telling us they can indeed Implement interfaces I will also cover interface in detail in a few lectures then strs can also have Constructors just like classes however in most C versions you cannot have a parameterless Constructor so over here public player just like this with no parameters and nope we have an error so as you can see parameterless Constructor is not available in C 9 but if you're using a letter version this is possible instead of defining it yourself it always has one by default so up here we can do new player and Yep this works so for the constructors if we Define any of them it has to have some kind of parameter so usually on the Constructor you add some kind of thing to initialize the acttion struct itself and then one common error with Constructors is this one right here which is all of the elements all the fields must be fully assigned before controls returned to the color so if we Define a Constructor like this we must initialize all the fields so over here this. a equals a and yep now it does work so every Constructor you make has to initialize every single field within that struct again this has to do with difference between value types and reference types as soon as you define something of struct type like for example some kind of variable like a kind of player variable like this as soon as you define it like this if you define it like this it's an error because it is uninitialized but we can initialize it we can just use default this is a keyword that pretty much Returns the default of whatever type we have so if we do it like this let's see what this says and yep the default of a struct is indeed a struct and then we can even go inside of it so let's print out the A and yep so it creates a struct and initialize the variables all of them at zero so that's what default does initialize everything with a zero value however if we now make this into a class and if there it is default value for a class is null and since it's null that means it has no object so we cannot access anything inside of it again goes back difference between value types and reference types reference types by default are null whereas value types they always have some kind of value so when you make a struct you can create a new struct like we saw by using the default parameter on list Constructor or we can use any custom Constructors or we can just make the struct and over here Define any kind of thing so a equals 2 and Yep this is valid code for initializing a struct one more important thing about structs is once again how they are related to Value types and not reference types so one big difference is how they are sored in the stack instead of the Heap these are two different positions in memory one is much more efficient than another I actually have a nice story about this in my first steam game Survivor squad for the implementation of the fog of war the world basically has a ton of tiny quads on top then as the player sees some area those quads are Mark as invisible and they are not rendered so each of those tiny quads needs a little bit of data in order to know the position and know whether it's visible or not in the first version of this system I started that as a class and it was terribly slow and then I literally just swapped class for struct and suddenly got a massive speed boost all because of how struges are very efficiently stored in memory so in general you use struges to hold different pieces of data together and in general you should use them as immutable pieces of data meaning they should not change and consider using them when you have some kind of memory performance issues hello and welcome I'm your Kodi in this lecture we're going to learn some intermediate topics related to classes things like inheritance polymorphism protected override and a bunch more okay so in the basic section we already learned the absolute basic of classes how we can define a class which has Fields properties and functions and then you can create instances of that class so that's the basics but of course classes can do so much more one of the main things they can do is simply the concept of inheritance that is how you can have one class that inherits something from some other Base Class for example let's say we have this General unit class meaning this represents any kind of unit in our game and all the units are going to have some kind of speed and some kind of move function and then we can have the player and the player is a type of unit and to Define that relationship we can make the player class extend the unit based class that means that player is going to inherit everything from this unit class so on the player class itself we are not defining any speed field or any move function instead just by making it extend the base class it is going to inherit all of these elements essentially the player class this one contains everything inside player and everything inside unit then we can have another enemy class which again is also meant to be some kind of unit so we also extend the same unit based class and again this one is going to inherit everything so the enemy class itself is also going to have a speed move function and so on so anytime we have some common logic that belongs to any kind of unit we just need to add it onto the unit class itself and anything that inherits from that unit class any of those class are going to automatically receive the new code that we add to our unit and then each of the classes that inherit from base class each of those can also have code themselves that is unrelated to the base class so for example the player can have some kind of move player function and the enemy can have some kind of enemy health field these only belong to these classes and do not belong to the base class so for example the enemy has no relation to the player move player and the player has no relation to the enemy health so always keep in mind that the inheritance does not go both ways meaning the above unit this one over here has no knowledge that there is a player extending it and the player has this kind of function so the player inherits everything from unit but unit does not know anything about player or enemy okay so let's see the synx here is the basic unit class we've got a speed field and a move function and now let's make a clear so let's make a player class and now in order to make this one extend our unit class for that after the player class name after that we write a con and then the name of the class that we want to extend so in this case unit and if that's it just like this the player is going to be extending the unit class if we write any code inside of here we can already access the unit Fields so for example let's make a Constructor so a public player Constructor and over here we can access yep we can access the field we can set it to something and we can call move function yep that does work so even though speed and move are not defined over here in the player itself since the player extends unit it also inherits all of this but then like I said inheritance does not go both ways so up here on this one let's make one for the move player let's make some kind of move player function and now down here on the unit script if we try calling that nope that does not work the unit does not know anything named move player this function only exists on the player class itself now another thing we can do is override some base function so for testing let's actually go up here let's create a new unit so let's build a new unit and a new player okay so we have these and if we call uh the move function and on the player let's call the same move function so if we run this it should print this line twice and if that's correct it only print three times cuz I included over here in the Constructor but yep it did work so now like I said we can overwrite some base function so for that over here on the Move function let's add the keyword virtual and now we can go onto the player and on the player let's define a function Exel like this one so let's define one just like this inside let's say move player and if we do it just like this we actually see this green squiggling line and we can check and Y this is basically telling us that this one is hiding the inherited member and if we want to override an implementation we can add the override keyword or add new keyword if we want new function but nope we do want to override that one so on the base L we add the virtual keyword and on this one we add the override keyword and yep so now like this using this code so the unit has this one it's a virtual function and this one is overriding that function with a different message so we have two different messages and up here we are creating a unit creating a player and then calling the same move function on both them so now let's see what this prints and there it is so when we call move on a unit it is running move unit but when calling the same move function on a player it is actually running the overridden logic so this is how you can extend some Bas class so make it inherit from something else and then override certain functions to have different behavior from the base class now this is also a great time for me to mention how you can override the two string function basically every single class in C is always going to extend the base object class and that base object class always has a two string function so for example up here we did not Define any kind of two string in here but we can call two string Yep this does work as you can see this exists in the object Base Class this is the main way of how any single object any single type can be converted onto a string we can do a console. right line and we can print out for example player and Yep this does work because this one is going to automatically call two string in order to convert the player onto a string so anyways yep all objects have this function implemented automatically however if we run this yep the player just says essentially just prints out the actual name for the type so we're inside the names space c course we're inside the program class so that's the program class up here and then inside the player type so sometimes printing this is not very useful but the two string function this one is also marked as virtual which means we can also override it so let's do the same thing let's you public override and automatically this one already shows us some code hints so let's override the two string function and it like this so it returns a string and it's call two string and over here we just return the string that we want to name our player so for example let's give the player some kind of name so let's give it a string for the player name and let's receive this string over here so we've got a string for the player name and set this. player name equals this and then down here let's print out player and then the player name okay so we do this and up here let's print the name as code mon key and then we do the same thing so let's do a console the right line and let's just put player so not even any two strings so just like this let's see what this does and if there we go now we have overridden that behavior so we can now say whatever message we want from our custom type okay great so with this we can inherit from Basel and we can overwrite some functions and of course what I'm saying here applies to any class you want to extend you can have as many classes extending a base class as you want so for example we can make a class for an enemy and also make the enemy also extend our unit and for on this one we can also again we can also override the exact same move function so we can do this this one is move enemy and now here let's do the same testing code Enemy enemy let's construct a brand new enemy and then we call enemy. move and let's see what this runs and if they're going like that so move unit move Player move enemy even though over here we are always calling the exact same function so basically we have three implementations of this and each of them is slightly different because they're overriding the base implementation basically the Only Rule with inheritance is how you can inherit once you can only extend a single Base Class so if over here we were to define a unit 2 okay here's a complely separate class and over here let's try to extend that one as well and NOP we have an error it is telling us that eny cannot have multiple based classes so we can only ever inhered from a single Base Class if you want to achieve something similar to that kind of result for that we have interfaces which we're going to cover later on in a future lecture but you can definitely go the other way as deep as you want so over here for example we have enemy which turn extends the unit class then we can go one step further so let's have another class for example the enemy melee and let's have this one extend enemy and Yep this does work then we could have another one for the anime melee boss something like this so for some kind of boss that also extends melee this one extends enemy melee just like this and yep all of this is valid code however just like this you can probably already tell how this can become quite confusing quite quickly so over here let me point out that inheritance is a tool that can be very powerful but also can be very easily abused to the point where it's much worse than not using it there's a common programming joke that goes basically you want the banana so you construct a banana but end up with an entire jungle that's because the Banana class would extend the fruit class which in turn would extend the tree class which requires the jungle class and so on so if you have complex really deep inheritance structures if you have that you can end up with some really messy code one common saying to counteract this is prefer composition over inheritance this is how you can instead of having a complex web of inheritance instead of that you can compose your comp objects based on separate components that make up the final object now this is a more advanced topic so don't worry too much if you're not fully understanding everything that I'm saying here I'm only saying this just in case you were curious and want to research further on this topic if you want you can Google composition versus inheritance and you will get a ton of really interesting results the only thing I want you to take away right now is just remember to be very careful when you're using inheritance always ask yourself if you absolutely need it sometimes you do but many times chances are there's a better way to achieve the same result in a much easier way that does not become insan complex but inheritance does have its place so let's learn a little bit more about it one extremely crucial thing that is not related specifically to just inheritance is the concept of polymorphism this is how you can treat an object as a different type of the object as long as those types are related so for example up here if we Define a field of type player so we have this field and we can assign this to the player that we created Yep this does work however we cannot assign our enemy object over here that is because you cannot implicitly convert our enemy into a player because again going back to the diagram even though they share the same Base Class they by themselves are two complet separate types however now let's make a field of type unit so we have a unit and obviously for this one we can assign our unit type Yep this does work and on this one we can also assign the player type Yep this also does work because again player extents unit so it can be used in place of a unit and same thing for the enemy object Yep this one also does work and now if we go into this unit 2 and call the move function let's see what this runs and if there it is this one runs the move enemy that is because even though we assigned this to a unit variable even though we did the object itself is still an enemy object so the object itself the type itself that one is still overriding our base move function and for example if we assign this to player Yep this does work but like we saw on the player itself let's define a public void move player so let's define this function that only exists on the player type so we did this and if we go over here onto player and call move player Yep this does work this is valid code however if we go through the unit and call move player and nope that does not work it does not exist that is because again this field this one is now of type unit even though the object itself is of type player since we're accessing it of type unit we can only access the things that unit itself has so for example one fun thing you can do with this kind of property is for example having list of units for some kind of unit list you can do this and now inside of here we can place a unit we can place a player and we can place an enemy and Yep this works it works because our player class and our enemy class those extend our unit base class so they can all be cast down into a unit type now like I said the concept of polymorphism which is basically using one type as a different type that concept is not specific to inheritance for example it also works with interface which we're going to see in the next lecture if we have some kind of function that requires the player specific type if so then we need to receive some kind of parameter specifically as type player but we can do a bunch of logic that works on just units and that logic won't work on units it won't work on players enemies and anything else that extends our unit based class and now that we are only looking at inheritance we can also look at a different access modifier so far we've pretty much just been using public and private private means that only this class can access it and public means that anything else can access but when it comes to inheritance we have another Super useful one and that is protected for example let's go down into our unit and for example over here for the speed instead of public let's make this protected so by making it protected we can use it over here inside the unit class so yep this works this is valid code and importantly over here on the player Yep this one is still valid code we have no errors here by making it protected that means that only this class only the class that defines it and any classes that extend this Base Class any of those can access this protected field so up here the player can indeed access the speed but for example up here in our static in our main program over here if we try going into a unit and try accessing the speed field I hope it does not work unit. speed is inaccessible due to its protection level so if you make something protected it is only accessible from within that class and any other class that extend that class so if you have some kind of behavior in your base class that the extend classes should be able to modify and only those classes if so then make it protected or for example in a field make it protected virtual and yep like this all the other class can access so this one just needs to modify into protected override and then same thing on this one protected override and by doing that the class that extend That Base Class those canate access it but over here this one can no longer access then one really interesting thing is the concept of abstract classes the these are classes that have a definition but cannot be constructed directly for example let's say our unit class here this one should never be created this should simply be a base class that should be inherited by the player or the enemy or any other kind of unit type but we're never meant to have just a base unit class so for that we can add the abstract keyword and Yep this one marks this class as abstract and now if we go up here yep we do see this error since a class is marked as abstract we cannot create an instance of this type this can be really useful to provide a base definition for something but also make sure that base definition itself can never be used directly only the class that extended can be created along with marking a class as abstract you can also Mark functions so for example let's make a public abstract and make some kind of void attack function so we do this and then we just do a semicolon meaning we do not provide an implementation for this function and instead just by defining this we can see we have some errors over here in the enemy class and the player class and here yep it says that we must implement the attack function so if the B class has some kind of abstract function we have to absolutely Implement that and over here by the way quick tip Visual Studio actually has these quick tips so if you click on this little thing it tells you to implement the abstract class and it's going to automatically write it and if there does so we need to write that one and yep no longer have an error so this can be useful if you have something where you are not meant to provide any kind of default implementation you just mark it as abstract and any class that extends this class W be forced to provide their own implementation to this function but if you do want to provide default implementation then just do it like this just make a regular virtual function and then any other class can either override or not override then another keyword is sealed what this one does is it prevents classes from extending this one so as you can see up here we have an error since we marked that one as sealed it is telling us enemy cannot derive from seal type unit now personally I've never really used seal but in complex projects with tons of classes sometimes it can be wise to make something sealed if it is never supposed to be extended again remember the main clean code principle the main goal is really to to minimize complexity so if you have some class that is never meant to be extended no matter what if so you can make it seal in order to help you make sure that the compiler enforces that rule so it can be useful in that way but personally I rarely ever so it can be useful that way but personally I never really use it then yet another more advanced thing related to classes are destructors so we write those kind of like a Constructor so kind of like up here we have a player Constructor for a Destructor we write it pretty much the same way so we write just the player as if it were a Constructor so there's no return to type it's just in type and then before it we add the T key which by the way like it says here this one cannot be marked as public so it just runs just like this so this a Destructor and now any code that we write here this is all going to run when this object is destroyed which if you remember from what I mentioned in the beginning c is a program language with managed memory you don't need to directly handle the memory yourself so the destruction of an object happens when there are no more references to that object so for example here let's do a console d right line for the play this structor to see when this runs so for example over here for some testing code we're calling some kind of my function and inside we're just calling a player so pretty much just constructing a brand new player then over here I'm calling gc. collect so GC stands for the garbage collection so this is the system that automatically handles all the memory and calling collect simply forces it in order to do it if I didn't force then this would happen randomly as the program grows and then just calling another function just keep it running so let's see this and if there it is just like that so the player was created then we call the function this one created a local variable meaning that this variable ends as soon as this function ends so as soon as this function ended this variable was marked for Destruction then when we force fently called the garbage collection when we did that it automatically destruct the object then continue running the program but remember how destruction of an object happens when there are no more references to that object so that is why over here this one is a local variable meaning it only exists inside of this function so as soon as we exit this function naturally this object has no more references to it however if instead of describing it in here let's make a PL ler over here Player test and then down here instead of defining some kind of function like that let's set that field to that okay so just like this and now if we test and yep the distruct does not run because Player test this one is a static reference and this one continues holding a reference to that object even though this function has ended so this is yet another place where it's really important to understand the scope of exactly what code you're writing one practical example of when to define the structor is when you have some kind of class that requires some cleanup like for example if on the Constructor itself you open up some kind of file for reading if you do that then make sure you close that file on the destructor so these can be really useful for disposing of any unwanted memory all right so those are some more intermediate topics related to classes as you can see there's lots of stuff you can do with them but also specifically on the topic of inheritance remember what I said about how it can become really messy really easily so always use it with care and something that I mentioned quite a lot in this lecture are interfaces so let's learn what those are in the next lecture hello and welcome I'm your Cod monkey in this lecture we're going to learn about interfaces this is one of my favorites and just straight up best features of C you define an interface that represents some kind of behavior or type and then you implement that interface in any class you want okay so interfaces these are simultaneously really simple and also really powerful an interface is essentially just a contract so you define an interface then you define whatever functions that interface has then any classes that Implement that interface any of those they must Implement those same functions so you have a guarantee that anything that implements that interface will implement the functions defined in the interface by doing this you can then write code directly against the interface type and that code won't work on any object that implements that interface this logic is somewhat similar to the class inheritance that we just covered in the previous lecture except you cannot create an object of the interface type another difference is how a class can only inherit from a single based class but a class can Implement multiple interface so for example with this structure right here an i attackable interface that is implemented by both the player and the enemy with this we could have some kind of bond object then the bullet could receive an object of type I attackable for some kind of Target then the bullet itself would call the damage function on that I attackable meaning the bullet itself would not know if it's attacking an enemy or player but because those work with the interface the bullet would be able to deal damage to both players and enemies so here's a different demo for some kind of interaction system I've got three objects and I want to interact with all of them and over here on the building I can click and yep I can indeed interact with however clicking on these two does nothing here is the code running that demo now don't worry if you don't understand everything this is doing it's not really important this is just a demo just so we can see the interface in action over here all we're doing is testing for a mouse click then we get the mouse position and test if there's any collider under that position and then try to get the type of that collider so in this case we're trying to test are we clicking on something that is a building object so it has a building component attached to it if so then we call the interact function and that in turn spawns that chat bubble so this works perfectly fine with the building type but now let's say I want to interact also with the zombie and also with a push button right now it doesn't work I am clicking on the zombie and the push button nope nothing happens the only one that works is the building itself that's because over here this logic this was made specifically just for the building type so it does not work with any other type in order to make this work with those other objects I pretty much just need to copy paste all this code then make this one to make it work with a zombie and make this one down here to make it work with a push button okay let's see like this so interact with the building it works the push button works and the zombie also works okay so now I can de interact with all the objects but obviously the code over here does not look very good we've got tons of duplicated logic this is really messy code if we want to add yet another interactable object we have to come here and copy paste a ton more code so you can imagine how this becomes really tricky if we have dozens or hundreds of interactable objects so this is definitely not a good approach and this is exactly where interface come in instead of making this code work with each individual type instead of that we can make it work against an interface here's a super simple interface that I defined again I'm going to cover this syntax in a little bit then all the other objects they are implementing this interface and over here now for the If instead of testing for each individual type I'm just testing for the interactable interface type and if we test this click on the building and it works the button works and the zombie also works okay great because we made this code work with the interface itself that means that this now works with any class that implements that interface so if I want to make more interactable objects I really just need to make a new class and implement this interface and everything won't work there's no need to touch this code anymore so this is the Practical example now let's see the Syntax for how we build interfaces now the way we Define it is really simple for example let's define an interface for an object that can be attacked so we start the access modifier and for an interface you probably wanted public then instead of writing class instead of that we write the keyword interface and then we write whatever name we want for the interface and the general naming rule is to start interfaces with a capital I this not required it's just a good convention to follow so in this case to represent something that can be attacked let's call it I attackable okay yep so this is our interface now let's think of what functions we need so that something is attackable and the answer is we probably just need a damage function so over here let's type in public which by the way everything defined in an interface needs to be public you cannot Define private things inside an interface that's because interfaces like I said they are pretty much defining a contract that other classes must Implement if we were to define something as private then other classes could not interact with anything inside of this interface so it wouldn't really make any sense to have any private elements inside an interface so everything inside of here is public and by the way way this is actually another reason why I personally really like being as explicit as possible if you omit the access modifier if you do that over here on an interface and make some kind of my function if you do it then this one W default to public but if you write this exact same code over here inside a class if you do it then now this one will default to private so this is yet another reason why I like being very explicit that way there are no questions as to what access modifier we are using for what element so over here I like to be very explicit and write public void and let's call it damage and Y we just Define the function and then put a semicolon meaning we do not write an implementation in this interface here we are just defining the function signature so that's just the name the return type and any parameters if there are any and that's really it we don't provide any implementation in our classes like for example let's make a random player class and on this one we can Implement our interface and we do that pretty much exactly how we saw for extending a base class in the previous lecture so we add a con and then our interface so I attackable and if there it is just like this and we have an error and if we see yep the error because the player does not implement the interface member I attackable do damage again like I said if you implement an interface you have to implement everything within that interface so over here you absolutely must implement this damage function and since the interface itself since this one has no function body because that we can have whatever implementation we want meaning the player can have some kind of implementation then the enemy can have a different one and so on so pretty much similar to what we saw in the previous lecture on extending base classes how we could override and provide different implementation for the same function over here it's kind of a similar thing so let's do a public void damage and here we can let's just do a console the right line and just print out player damage okay so yep that's it and now for example up here in our main let's make a field of type ey attackable and now we can simply construct a player and we can sign it over here yep just like this this works again similar to what we covered in the previous lecture this is polymorphism in action since a player implements the ey attackable interface we can use a player object and assign it to a variable of type I attackable and then through this interface field through this one we can access whatever functions we have in our interface like for ex damage and Yep this does work so now we have similar benefits to what we saw in the previous lecture on inheritance for example let's make another class let's make an enemy class that also implements ey attackable and Y just like this it works and now up here if we have some kind of code that works against the I attackable interface like for example let's make a private static void attack object and we receive an object of type I attackable so we can do this and then on attackable we can call damage and now up here we can call this attack object and we can pass in an object of type player and pass in one of type enemy and yep both these work just fine so this function over here that was written directly to work with this interface type it does not care what object we pass in as long as that type also implements our interface now one limitation of interfac is they cannot have Fields so for example down here in the interface let's make a public in health and no this does not work interfaces cannot contain instance Fields again this goes back to the difference between an interface and a base Class A Base Class can contain actual data since a base class can be constructed but an interface this one is just a contract so this one holds no data so that is why over here we cannot have any Fields but we can have properties so y this does work so we can define a public health property and again same thing all these need to implement that one then we can also have functions of course then we can also have events which we're going to cover later so the main limitation is really how you cannot have Fields because again interface cannot store any actual data another thing is actually here we Define this function with no body and then the classes must Implement that function and this actually used to be the only way but in recent C versions you can now add an optional default implementation so you can write a function here and just write the code AS nmal so you can do this and now classes that implement this interface they are not absolutely required to implement this damage function if they don't then it's simply going to use the default one so as you can see over here we have no error and up here we can still pass in an enemy and through this function we can call damage function and the only thing is one is going to run the player damage and this one is going to run default so let's test and it Pickel like that so the player did Implement their own custom implementation but the enemy didn't so it used the default one this feature for default implementations this is especially great when working with some complex projects things that are already using a bunch of interface and you want to add a bunch more Behavior if over here you just add a brand new function so test function if you just do this then all of a sudden we broke all of this code this is obviously not very good so if you do this if you add after the fact and you don't want to break your current code just provide default implementation and yep now everything does work so like I said interfaces look slightly similar to class inheritance however one huge huge difference between them is how you can only ever inherit from a single base class but you can Implement as many interfaces as you want so for example here we can make an interface and let's call it movable so this would represent something that can move then an interface call it I has inventory so this represents something that has an in then up here let's say the enemy can move but has no inventory and the player can move and has an inventory and yep we can Implement all of these interface in the previous lecture I talked about how you should prefer composition over inheritance and this is exactly one way you can do that you can have interface that each Define some kind of behavior like for example whether the object can be attacked whether it moves whether it has an inventory you can do that and then your classes you can Implement only the interface that are related to that object so for example the player can attack and move and has an inventory but the enemy does not have an inventory so it does not Implement that interface this is a much better pattern as opposed to making all of these requirements on some kind of unit based class and then the enemy would also have some kind of inventory even though they would never use it so this is an example of composition over inheritance and for example in my game Thinking Guardians I use interfaces all over the place I use them to Define all kinds of behavior and then have tons of code that works directly with those interface and really does not care what the underlying type is implementing that interface so it can be a dinky it can be a machine it can be the player it really does not matter as long as that type implements that interface it does work when extremely common interface in games is simply making some kind of interaction system so just like we covered in the demo and if you want to learn more about specifically that type so you can see a practical use case if you want you can check out my dedicated tutorial on how to make an interaction system do something that can talk to NPCs push buttons or open doors and like we saw in the demo if you don't use an interface then you have to copy paste a bunch of code but if you do use an interface then it makes it super simple for your system to work with any object you want so interfaces are really truly awesome they are definitely one of my favorite C features they are extremely useful so definitely make sure you fully understand them they will help you a ton in pretty much any game any code you want to make now that we've covered interface and inheritance these are two things that deal with a lot of types that work as different types now that we done that we're ready to handle the various ways of doing type conversion so let's do that in the next lecture hello and welcome I'm your codm in this lecture we're going to learn some things about comparing various types we're going to see whether they're an interface or Bas class and we're going to see how we can convert between them okay so previously we already covered inheritance and interfaces those are two ways we have of handling an object of a certain type that also works as a different type for example if we have our eye attackable interface and both the enemy and the player implement that interface if we have a field of type I attackable over here we can construct a new player any of it works and we can construct new enemy and if this also does work but then let's say we have some special logic that we only want to run if the object is a player and not an enemy for example over here on the player let's define a public void player say hello something like this so if we have this function that only exists on the player so it does not exist on the enemy on the unit on the interface nope only exists on the player and over here if we have a field of ey attackable even though we placed a player object inside that field if we go through it and try to call player say hello nope this does not work like it says here eye attackable does not contain a definition for that so it does not really matter what is the specific object that we have stored inside this variable this variable is of this type so we can only interact with things that exist inside of this type if you have a film like this and you want to see if the underlying object stored in there is of a certain type or a different one if so you can do if attackable and then use the keyword is and then the type is player so we can say this and let's do a console d right line just to see if this one is a player let's just get rid of this code for now okay let's see if this one prints and if it does print that object is indeed of type player and if we replace it for an enemy and run and if that one does not print because this one is no longer of type player so this is the simplest way for how you can tell if a certain variable if the object SED within that variable is a a certain specific type alternatively on Prem much every other object we can see we have a bunch of functions that are available to every single object like we already saw the two string so this one exists on every object but the other one that is all super useful is this one the get type this one Returns the specific type of that object so for example let's do a right line on this one to see what this one says Okay so let's print this and see what this one says any if that one says the type so this one is of type enemy so here we can get an object of type type which actually only tells us the type of the object that this is so over here we can check the attack of do get type in order to get the type contained within that variable and instead of using is we simply compare with the type of player example like this we have an error because player this is the name of the class in order to get the type we use the keyword type of and this Returns the type of whatever is within the parentheses so in this case the player type and Yep this now works the same thing as we saw previously with the is so this one this is an enemy so this is not going to run and if there go it's an enemy but if we solop this for type player and if there it is now it does run now when difference between this get type method and the other one using the is keyword one difference is this one does not check for inheritance or interfaces so if we see is of type I attackable which again the player class this one is indeed implementing I attackable so let's see if this one runs or not and Noe this one does not run so if you use this method of getting the type and using a type of to do an equality check if so when it comes to interface instead of that you can access the function inside of this specifically the function is interface this will tell you if this type is an interface and then you have a bunch more you have a function for checking if it's an instance of a type you can check if it's a subass of something or you can check if it's a sign a b two and from something or alternatively for this case for testing against interface you can use the previous method which personally is the one that I prefer so just see if the attackable is attackable which in this case doesn't make much sense but let's test any yep it does work but if we were to make a new player over here let's see and if it does work alternatively we could test if the player is a unit and if this also works so there are various ways to test if a certain variable if a certain object is of a specific object type so for example let's go back to our original demo so testing if the attackable is a player and if so we want to run this specific function on the player class right now even though we have identified that this object is of type player we still cannot go here and call player say hello nope this still does not work even though we have verified that it is of this type we still need to convert it onto that type and for this we also have two options One is using the as keyword so let's define a player field and for this let's use the attackable as of type player so if we do this and now do this and over here let's just print out something okay let's see any yep it does work it did run that so here we convert our attackable into a specific player type and then we can call any functions that are specific to this player type the other conversion method similar to this one is simply casting which we already saw when we cast some floats down into ins so instead of using attackable as player we just put player in parenthesis and then attackable and like this and yep it does work so these are two ways for converting types and the difference is usually related to whether the conversion succeeds or not so for example let's go outside of the if testing the player let's just comment this out so up here let's create a new player and then let's create a new enemy and now let's do a player test player and we're going to take the enemy and cast it down into a player which obviously this will not work it does not work because enemy has no relation to the player itself the enemy implements the attackable extends a unit but has no relation directly to the player itself and in this case the compiler doesn't even let us run this code however we can try forcing something that won't work so let's put it an i attackable and up here on this attackable let's make it a new enemy so this one is an enemy meaning this one will not work but now we don't have a compile error because technically I attackable might be convertible into a player it might or might not be and if we test this and yep if we try to C something that does not work we're going to have this error unable to cast of type enemy into player and using the other method so let's see what that one does so attackable as player and in this conversion method we have no error and let's just do a console. right line to see what is stored on that one let's see any y it's empty meaning that one contains null so this difference between the two methods if you use a cast and the cast fails it is going to throw an exception whereas the as if the as fail it is simply going to store null over here on this field so remember this difference if you use this me method in order to figure out whether this cast worked if so then compare this one against null or if you use this method then before you do make sure to test if the player is actually castable which up here this code is normally what I do so I just check if something is a specific type and only if so that's when I cast down and then do some complicated logic also related to type conversion when working with value types like for example an INT on this one if you do some kind of thing like this so a as float if you do it nope it does not work the as operator must be used with a reference type that is because like we saw if this one fails this one is going to return null but a value type can never be null so that is why the as so that is why the as keyword can only be used with reference types so when you ever have this kind of thing you only have to use the cast option and something related that I mentioned briefly in the beginning of this course is how every type in C is convertible down into the object type this is the base type for pry much anything in C you can convert any type into an object so for example something you can do is to find some kind of int then you define some kind of object and you can place an INT inside of that object and then you can Define another int go inside the object and cast it down back into an end and Yep this does work this is technically something that is called boxing which I'm going to cover in more detail in a lecture in the advanced section this is basically how you can convert anything onto an object and then convert it back this topic of type conversion is also something that won be very important in a few lectures when we cover events the default type for any kind of event is the event handler and this one if we we inspect how it is yep this one has a parameter of type object so when working with this we're going to need to do some conversion and usually for events you know what type is fireing this event so you can just use a cast in order to convert this object onto whatever type you want but like I said I'm going to cover events in a few lectures so with that here we'll learn the various ways of handling type conversion these can be very useful when combined with interface or inheritance anytime you need to do some kind of type checking or convert back and forth between one or two types now you know the various methods for doing it hello and welcome I'm your Codi in this lecture we're going to learn about switch pattern matching this is how you can do a switch on a type instead of just a value this is a super quick lecture since it's actually really simple but I want to make sure you definitely know about this okay so we already learned how to handle multiple types with inheritance and interfaces now let's see a more advanced use case for the switch that is perfect for this scenario so in the last lecture we already covered how to check if an object is of a certain type so for example if I have an eye attackable field and I set this to a new player then we can check if attack is of type player and if so do some kind of logic then we could also test if attackable is of type enemy we could check if it's of type of the red Barrel so this works perfectly fine but just like we saw on the lecture on the regular ifs if you have to do a ton of them together then at that point a switch is better and actually on a switch we can also do this kind of logic testing if a certain field is of a certain type so instead of this let's do a switch and switch on attackable and then on the cas we can add the type definition so for example case player and then assign it to some kind of variable name player and if there it is this is valid code what this going to do is if the attackable is of type player then it's going to cast attackable onto a player type and it's going to assign that reference over here on the player so for example over here we can access the player and call a function that only exists on the player like this one player say hello so this one and Y this should work so let's run and if exactly it does work so here this is both testing a specific type it is also casting that type and assigning a variable reference so with this instead of having all those ifs we can do here case Enemy enemy and case red Barrel red barrel and in P these now work so now inside of this we can put any kind of enemy specific logic and of course we always have the default case just in case it does not match anything then it's going to run this code also this actually lets you do one more thing that I actually didn't know until I did the research for this course which is on this case you can add extra conditions so for example up here on the player let's find a end for the player Health something like this and now here on the player we can use the keyword when and then Define some kind of condition so for example when player. health is above 50 if so then we're going to run this and put one without it and it's going to run this so over here for test let's do a consant out right line on this so this one Health 50 and the other one is a default now up here on the player let's construct it and let's put the health on 100 so that should go inside of this one so let's see and it ex goes inside that one whereas if over here if the health is 20 and if if there it is it only runs the other one so this whole thing is called switch pattern matching so as you can see we can do a switch and then Define all kinds of patterns and depending on which pattern it matches going to run different kinds of code with this the switch can be used in tons of way so not just testing for a specific value you can cast into a type and then couple it with some kind of condition and doing that you can do all kinds of logic on different switches but again always remember the number one rule code is meant to be readable and understandable so if you end up with a mountain of switches with tons of complex when case conditions at that point it's probably best to refactor your code in some way but for simple use case this is really useful especially for this kind of use case where we have some kind of Base glass or some kind of interface and we want to do some specific logic depending on what type it is hello and welcome I'm your KMI in this lecture we're going to learn about delegates lambdas and Anonymous functions okay so delegates they are really powerful C feature they basically let you store a function inside a variable or use it as some kind of parameter here is a working demo so I can click and it spawns a chat bubble then I can press a button to change the action and now if I click yep now it spawns a regular Sprite and now press another button now I click and yep now it's spawning some particles so the same action clicking is doing different Behavior based on what action I select here is the code for the click actions and delate is this one over here it's something of type action this is a delegate and then I've got a bunch of functions toine here so spawn chat bubble a Sprite or a particle effect and I can see over here on start that I'm assigning The Click action to this function so importantly it is not calling the the function nope it is passing in the function itself and storing it over here inside of this field and then on Mouse click I simply run whatever is stored inside that variable so the variable stores a function and then by calling this I can run whatever function is stored within that variable then these buttons simply do that they simply assign a different function onto that variable and with that I can click do one Behavior press to select something else do another behavior and another one just like that so this a practical example now let's see the syntax to define a delegate first let's write the access modifier let's go ahead with private and then let's use the keyword delegate and then you write essentially a function signature so let's make something super simple for the return type let's use void then for the name for this delegate let's call it attack delegate then we add any parameters we want or basically none of them okay so yep so just like this we have defined our delegate type now we can use this type just like we can use any other type so for example here let's make a field of this type so let's make it of type attack delegate and let's give it some name like attack action okay so just like this and then like I said the goal is you can sort functions inside a delegate variable so over here let's make a regular function let's call it melee attack and let's just do a cons on the right line and let's print out melee attack yep just like this now importantly we need to make sure that this function signature has to match our delegate signature so it needs to match a return time so both need to return void and needs to match a number of parameters so in this case zero so this yep now we can go inside our attack action and we can assign it to our melee attack and again importantly we assign it just like this so so we assign the function itself we do not call the function no this is very different we assign the function itself just like this so you can do this and then basically we can run whatever function is stored within this delate and we do that by calling it like we call any other function so just like this okay let's test and if exactly it ran our melee attack function so for example you could have multiple enemy types each with different attacks and in order to trigger those different attacks you would simply assign a different function onto the delate variable then like I said the delate can have whatever return type and whatever parameters you want so for example let's make another delegate let's make one that returns in call it my delegate and let's receive a string parameter save just like this this is the delegate reference and like I said when assigning something of this type so for example down here let's make a field of this type my delegate and now when assigning it like I said it needs to match the function signature so if I try assigning melee attack and nope we have an error it is telling does that there is no version of the Mele attack function that matches the delegate my delegate so there's no version of this fun function that returns an INT and takes an A String so in order for this to work let's go make a private static void my test function and actually not void so actually in here let's return an INT and let's receive a string parameter so we have this one and now up here we assign this to this field of type my delegate and if now it does work let's just return zero just fix that error and yep like this this does work it works because the function signature now matches so they both return an in type and they both have a string parameter also by the way over here you need to Define some some kind of name for the parameter so like this it's an error so you need to Define it with some kind of name but down here when you assign the proper function this one does not have to have the exact same name needs to be the exact same type but not the exact same name okay great so this is the basis of delegates so up here we Define delegate and then we assign it so that's great and delegates are really super useful I use them all the time but always having to Define them before you use them that is a little bit of a pain so for that c has some really awesome default delegates that are super useful one of them is simply called action so so let's make a field and let's make it of type action which by the way exists inside the system namespace so action let's call my action and we can inspect the action in order to see the function signature for this delate and Yep this is a delate that returns void and takes in no parameters so pretty much exactly the same that we defined up here so down here if we grab my action and we assign it to melee attack and Yep this does work because again the function signature matches this one returns void and has no parameters so rather than having to constantly Define your own custom delegate with void no parameters if you want that you can just use action and then there are actually various action definitions you can add the angle brackets this means a generic we're going to cover what are generics in detail in a future lecture so this you can see there are 16 inversions of this type and these are basically just different amounts of parameters so you can see there's all the way up to 16 parameters basically on these you can include whatever type you want for the parameters so let's say an action that takes in an INT what this means is a function that will return voids and it's going to have an in for the parameter so the equivalent for example up here would be some kind of in like this so this would equal pretty much this and down here of course since we changed the delegate that we're using this one is no longer valid so in this case we would need to make something that returns void and then takes in an in parameter yep just like this and if we assign this one to that one and yep it does match so action is really awesome it's a builtin type so rather than having to Define your delegates you can just use this directly the only thing is that action always returns void so all the various versions that we saw all the 16 versions every single one of these is just the fact number of parameters but they always always return void meaning they cannot return any value if you do want to delegate that return something for that you have the funk and this one works pretty much the same as the action so this one also has tons of things so let's put in the generic in order see all the types and this one as you can see has a generic named T result so this is basically going to be the return type and then has all kinds of those for all kinds of parameters so this basically going to return some type and then have any kind of any number of parameters so for example in this case this my funk this one is of type int meaning it's going to return an INT so let's actually Define it so let's take this one go down here and we're going to need to assign it to something so let's make another function that matches that delegate so again this one has no parameters and it's going to return an INT so let's make it return int and with zero parameters and if we take this and let's just return zero and if we take this and assign it any yep it does work so the builtin action and Funk delegates these are super useful if you have some common use case you can really just use theu there's no need to Define your own delegates but defining your own delegate is also still something proper the one big benefit is of course this one has a custom name so even though this one perfectly matches an action delegate with the name attack delegate that makes it a bit more clear as to what the intent is as opposed to this one Funk this one has no clear intent on what exactly what it's doing so they both have their use case but in many ways for Simplicity when you just need something based that works using Funk and action those are excellent then for assigning a delegate so over here we are creating of something of some type that we are creating a separate function and then assigning it so this works but we can also do what is called an anonymous function or sometimes called a Lambda expression so for example let's define a field of type action and now when assigning it we can just put in the parentheses for the parameters which in this case action has no parameters and then we do a little arrow symbol and then let's open and close a code block so yep just like this this is valid code what we have here is a Lambda expression for defining some kind of function that takes in no parameters and returns nothing so what we have here is pretty much the same short hand as what we have here we can place the console right line there and Yep this is exactly the same as this except when doing this we didn't have to define a complete separate function so these lambas this is another really super useful thing I use them all the time especially when writing any code for buttons in unity buttons have a click action and normally I just use a Lambda in order to Define what Behavior I want when I click on a button as opposed to having to write a separate function and then assigning it to the delegate so there are really great time Savers and you can use them on any delate type so over here an action with no parameters but if we make an action that takes an INT parameter if so then we just need to define the in parameter over there and if this does work and alternatively if we make a funk let's make a fun that takes an INT and returns a bow so this one takes an INT parameter and then over here just needs to return some kind of volume yep that works and then alternatively if you want you can even simplify this even further so let's erase all this let's put just false just like this and Yep this is perfectly valid code this is doing the exact same that we saw previously the compiler is smart enough to know that if this delegate expects a return value it is smart enough in order to add the return into whatever statement we write so this is perfectly valid code although normally like I said I prefer being explicit so personally I prefer to always write everything perfect now an interesting property about delegates is multicast meaning how you can sore multiple functions inside a delegate so for example let's see here our attack action so we're assigning it to just the melee attack let's make another one let's make a range attack and over here if we do this and then assign it to range attack if we do this and let's just get rid of the other code so if we run this code and if there you go it only runs the range attack however instead of assigning we can do plus equals and now if we run this and if there we go now run both even though over here on the delegate we only ran the delegate once since the delegate itself is storing the reference to two separate functions it is going to run both those functions whenever we run our delegate so this means that the delegate itself it can store multiple objects it kind of has a list in the background of all the functions that are stored within it and since you can do plus equals to add it you can also do minus equals so let's run that one which should run both then do a minus equals and then print and let's see this and if there you go so the first time that we ran the D the first time it ran melee attack and range attack but the second time since we raise the range attack we did minus equals because that the second time it only ran the melee attack now when really common use case for delegates is doing a synchronous programming and handling callbacks if you're familiar with JavaScript you're certainly very familiar with this and in game development for example one very common use cases for pathf finding you tell a unit to move somewhere and you can pass in a delegate for what to do when the unit gets there so for example here's a basic unit class and it has some kind of pathfinding so it has some kind of move to function it takes in a Target position then an action for the unreach Target action so we would create a unit we would tell it to move somewhere and we would pass in a delegate so in this case could be a simple Lambda so a simple Anonymous function we could pass that in then the unit would do all kind of movement and eventually it would reach the Target and when it reaches the target then it would call that function and doing the so then it would run whatever logic we set when we call the move to function so if we test this yep there it is now the unit is moving and after a while it gets there and yep it reaches the target another common use case is when doing something that contacts a web server so some kind of web request I made a tutorial on that and for that I made the class receive a delegate for the Callback that is called whenever the server responds so delegates are super useful extremely versatile it can be sometimes a little bit tricky to understand at first since they look like variables but they're actually storing functions if there's something you didn't understand definitely go ahead and rewatch this lecture once again and go through the interactive exercises this is an extremely powerful feature that you absolutely must understand now here I mentioned lambdas for making Anonymous functions but there's actually another way of doing something similar we can create normal local functions so let's learn differences between them in the next lecture hello and welcome I'm your Cod Maki in this lecture we're going to learn about local functions and how they differ from lambdas okay so in the previous lecture we covered delegates and lambdas lambdas are one way to make an anonymous function so we have some kind of action my action we do a Lambda by writing the parentheses with the parameters then we do a little arrow and a code block just like this this is a Lambda expression however there is another method for making Anonymous functions it's called local functions and they're EXA like the name implies just like you can have local variables so in something so this is a local variable just like this you can also Define a function within another function and you define them pretty much exactly the same as another function so for example void print let's receive a string message and then we put a codee block and inside let's go console and right line and let's print out the message and that said here we have a valid local function we have this function inside this main function now naturally we cannot call this from anywhere else so if there's another one so another private static void so if we have another function here from this one if we try accessing print nope this does not exist so this is a local function which just like a local variable is only accessible within this function and we saw the delegates in the previous lecture so we can use these exactly the same way so action my action two and I can assign it to print and actually this one takes a message so let's do action of type string and yep there you go this is perfectly valid code so here this and here this just put a string here just to make it exactly the same so a string message like this and Y both this and this are exactly the same thing now let's see the differences and first is really just a syntax you can see how the Lambda over here this one does not have Name by default the only way to reference this Lambda expression the only way is by going through the actual delegate that stores it whereas the local function over here this one has a proper name you don't need to assign this to any kind of delegate field in order to be able to actually use it the another thing is how the local function can be defined anywhere so for example I can Define the print in there and up here I can call print and Yep this is valid code there's no errors again only inside the actual function code block because it's a local function but I can Define it down here and use that up here this is valid whereas with the Lambda you cannot do this if I accessing the my action nope obviously there's an error I cannot use the local variable before it is declared whereas for the local function that one works just fine the difference for this is because local functions these one are defined in compile time whereas lambdas these are defined at runtime so because that the compiler knows that this function is coming so it can use it but this one can only be used after it is declared also importantly is how the delegate over here the Lambda this Anonymous expression lambdas are actual objects that are declared and assigned at runtime they are exal objects that exist in memory so every time we run this my action every time we do that it is going to create a brand new object every time we run the main function every time we do it it is going to create a brand new instance of this object it's going to create a brand new Lambda whereas local functions these are defined as compile time so in memory they only exist once so we could call the main function 100 times and it would create 100 instances of this Lambda but only one instance of this print function so in terms of memory if your memory limited then local functions would be a better option than using lambdas so in general both local functions and Lambda serve a somewhat similar purpose they allow you to Define functions whilst inside another function local functions can be great for organizing logic within a function assuming whatever you're doing in that function is only ever done within that other function and lambdas are great for super quick things like assigning logic to a button click for the most part personally I really only use lambdas but local functions also have their use case hello and welcome I'm your Kodi in this lecture we're going to learn all about events this is extremely powerful feature of C it helps us write much better code with much fewer dependencies okay so events this is basically how you can have one class and that class fires off events when something happens and the subscribers that listen to that event those will be notified whenever that event happens for example here's a working demo so there's a tower and I can click to damage it and by using events we can have some kind of health bar and that health bar is listening to when the tower takes damage and when it does the health bar listens that event and updates its own state so the UI element over here this one is listening to the build damage event itself and then updates the health bar events have Publishers and subscribers or sometimes subscribers are call listeners those two terms are really used interchangeably the event is defined within some kind of class and then you can listen or subscribe to that event from anywhere else now what that means is that when the event is invoked all of these subscribers those all get notified that the event happened and note how this relationship only goes one way so the subscribers attach to the event in order to be notified but the event publisher this one has no idea that are any subscribers this is really excellent for keeping your Cod decoupled the event publisher does not know and does not need to know if there are any subscribers at all maybe there are some maybe there are none it does not matter the event publisher itself is completely decoupled from any subscribers as far as the event publisher knows it just knows that it fired off an event that's it it does not know and does not care if anyone is listening and the other benefit of using events is that our code can be based on when things happen as opposed to constantly pulling for something for example over here on this demo the health bar does not have to constantly pull the tower to check its Health State on every single update so it does not have to ask that question 60 times a second the health bar is perfectly idle it only listens when the event is published so only when something actually happens does the health bar take action here in the code the tower script this one has an undamaged event then this demo is really super simple I'm just testing for the mouse click and if so calling the damage function and damage function simply Alters the health amount and fires off the event again note how this Tower does not know anything about any kind of health bar it is completely decoupled and then on the the health bar itself this one does know that Tower exists it attaches itself to the on Tower on damaged event and when that event happens it simply updates the health bar so in order to show how the code is decoupled I can just go ahead and get rid of the health bar so I can just disable this game object and yep everything does work because the tower does not depend on the health bar okay so that's a quick overview of events now let's see the syntax and the way that we make events is actually super simple this lecture will be really easy to understand because we already learned about delegates which are quite closely related to Events first we our access modifier and usually for events you do want them to be public you want it public so that any other classes can listen to that event it doesn't make much sense to have one event that is only listenable from that class so usually events are public and then we have the keyword event on lowercase this is a special keyword then we add the delegate and like we covered in the delegates lecture we can Define our custom delegate or we can use the builtin action for example so let's use this one just because it's so easy and then we give it some kind of name usually the convention is to start your event names with on and then whatever happened so for example on player damaged see up like this and in terms of naming rules events are usually Pascal Cas just like properties okay so great so just like this we have defined our event now let's ready quick demo just see how it works and for that let me actually just put this inside a basic player class just so that makes a little bit more sense so put it inside there and now let's make some kind of damage function so let's call damage and now here the first thing we can do with our event is simply fire it and for that we do it pretty much as if this was a a normal delegate and we were just calling it so let's go on player damage and simply call it like this so that's it super simple however this code will actually throw an error but let's test it like this up here let's just create a new player just construct a brand new player then on player let's call damage and let's test any right away we have an error we have a no reference exception so this has to do with the fact that this event currently does not have any listeners if it has no listeners then this field is essentially set to n so before invoking an event we need to check if it has some listeners and we can do that just by checking against null so if the event is not null if so then that means it has some listeners so we can safely call that event so like this if we run and Y no errors although also nothing happened so now that we are correctly firing off the event let's add in listener let's make another class let's make it a class and call it player health bar something like this and now in order to listen an event we need some kind of reference so let's actually make a Constructor for our player health bar and the Constructor let's receive an object of type player so we received that and now here we can go through the player and now we can indeed access the onplay damage event also here in Visual Studio it shows this little lightning bolt this means an event so we can access that event and then we can do plus equals in order to subscribe to that event and here by the way Visual Studio has this really nice shortcut it is going to autorite the player on player damage event so just press tab to insert usually I do this then if you want you can rename it or just press enter and yep there's our event function now if you don't see this shortcut or if you're using different ID you can just manually write this function it's a pretty basic function the only important thing is just like we covered in the delegates lecture the function signature needs to match event signature so in this case for the event we made it of type action which means it must return void and must have no parameters okay so here we are listening to the event let's just do a log so console. right line let's just print out the on player damage event just like this and now up here let's construct our player health bar so let's construct a brand new one let's make it and this one requires a reference to our players so let's pass it in so first we create the health bar and then we call damage on the player so now basically what will happen is when we call damage the player damage this one is going to fire the on player damage event it is going to check against null and since we have a listener this one is not going to be null so it is going to run our event and by running that event it is essentially going to run this code and print this slide so let's see any if there it is the event was fired and listener did listen to that event all right Awesome Again note one of the big benefits of about events the player class this one has absolutely no relation to the player health bar so the player class is completely decoupled from the player health bar as opposed to for example if we were to make this public and then up here we would have some kind of private field of player health bar then we would need to keep this reference and in doing those on the damage we would call the player on damage function if we did this then the player class would be tially comp to this one so for example if I remove this one obviously there are errors because this type no longer exists whereas if we go back to what we had previously here is just the event here is just the player class and if I completely remove this one yep there are no errors inside the player class this is what it means to be completely decoupled is that the player class does not know and does not care if anything listens that listens to that event if it does then great if not then also great then one important thing about events is how multiple classes can listen to one event for example if over here I make another one let's make this a Mana bar so do it like this do it pretty much the same and over here let's say Mana bar something and then up here if we construct a new of type this if we do it then now we have two listeners to this event so when this fires it is actually going to run both of these listeners and if there is both them did run so events can be listened to by multiple listeners and then over here we are subscribing but if you want at some point to stop listening to that event you can simply swap the plus equals to minus equals and yep with that we can unsubscribe and at this point I should point out that unsubscribing to events is actually very important if you don't then you might end up with memory leaks depending on the left time of the object if the listener gets destroyed but the poish lives on if so then it will actually keep firing events onto a listener that no longer exists so that could cause all kinds of issues so always keep that in mind either pay attention to the lifetime of the objects because if the player has the same lifetime as this one then technically you don't need to unsubscribe but if they do have different lifetimes if so then when this object is destroyed make sure you unsubscribe to that event so yep we can either do plus equals or minus equals to subscribe or unsubscribe and on the class that defines the event we can also call the event and now right away you might be thinking that this looks exactly like delegates especially the delegates multicast function and if that's right this is indeed very similar to delegates in fact if over here I just remove the event keyword if I do no nothing changed there are no errors and if we run this yep everything still ran exactly the same so technically it works like this however adding the event keyword had some really useful limitations first of all is who can trigger that event if we do not add the event keyword then anyone would access to this event can invoke it so for example down here on the player health bar I can go on there call it and Yep this will work so this player health bar will be invoking this event usually you do not want this you want the class that defines the event to be the only one that can actually invoke the event and if you add the event keyword then the compiler actually enforces that rule so yep down here nope it cannot call it the event can only appear on the left hand side of a plus equals or minus equals so subscribing or unsubscribing except of course when used from within the player class within where the event was defined so the event keyword is really nice for essentially protecting you for yourself remember how the main clean Cod principle is simply minim in complexity so the more you minimize access to a particular field the better it is another limitation that this keyword adds is simply the ability to clear the event so again if we remove it then for example down here the player manavar this one can go into the event and set it to null and if we test the code like this yep look that issue basically the menar completely raised the original event listener so the player health bar this one no longer listens to everything anything because this one pretty much broke the code again this is something you don't want to happen with events and again this is something that just by adding the event keyword the compiler will help you by enforcing some rules and yep like it says here once again same thing Bing the event keyword the only thing you can do outside of that main class the only thing you can do is subscribe and unsubscribe and nothing else so in many ways events are indeed pretty much delegates since they in fact actually they use delegates like we saw here we are using the action delegate but even keyword that would add some really nice limitations to basically protect the code from yourself and of course since he use delegates we can use anything more than just a simple action if we want to pass in some data for the event we can really just use a delicate with parameters so for example let's use an action of type int and then over here when we call the event we can pass in any kind of int value and then down here on these in order to listen again The Listener function needs to perfectly match that one so if this one expects an end then over here we also need to put an INT and yep like this it will also work and the parameter over here will be whatever you do when you call the event now another thing is over here we've been using the action delegate you can use whatever delegate you want you can build your own delegates or you can use action the builtin type but in general the C standard is to use the event handler this one right here that exists inside of system this one has a signature where it takes in an object for the sender and an event arcs so usually when invoking the event for the object sender you pass in this so you can pass in a reference to whatever object was firing that event and for the event ARS if there aren't any you can just use the constant event ARS empty so yep just like this but again this is not a requirement like we saw you can use pretty much any delegate you want you can use action and everything works just fine but generally this is the C standard if you see a bunch of C code chance are they're going to be using the event handler and then this one actually has a second parameter that defines what are the event arcs again that parameter is also used with generics so let's open up that one and yep it has a type of event arcs so while following the standard if you still want to pass extra data you can for that usually you make some kind of class that extends event args so here let's make a class and usually the standard name is to give it the same name as events so on player damaged and then you simply append event arcs at the end and we make this a class that extends event arcs simply like this and then over here we add whatever parameters we want so like for example in this case maybe we would have like previous Health in order to know the previous Health before the player was damaged and then over here on the event hangler we use generics and we pass in our custom type just like this and then over here when we invoke the events instead of event arsmt we just construct a new object of our type and add whatever that we want so just like this and again on all these other ones of course we need to remake the function signature in order to perfectly match and again this something that Visual Studio does by default so just do plus equals and it's automatically going to write with the perfect event signature and over here on this one in order to access that data that is going to be over here on the second parameter so we can access e and then inside we've got the previous El and we can do whatever we want also one of the first things we saw is over here if we do not add this null check if we don't then this is actually going to throw a null reference exception so you always need to check for null however there's a special way to make this code a little bit more compact so you've got event and again just like this going to fire off null if we have null listeners so what we can do is we can use what is called a null conditional operator I'm going to cover these in more detail in the advance section but basically we can just set a question mark and basically this will mean that the code to the right side this code will only run if the code on the left side is not equal to null so we can do the question mark and then call invoke which is basically going to invoke the event and just like this so again the question mark basically means that is only going to continue executing code to the right if the code on the left does not equal null so if this one is not null if we do have listeners to our event then we are going to invoke the event so instead of having a normal test for null usually with events you have this kind of syntax so you just do a nonconditional operator and call invoke and invoke that event now one of the best things about events is what I mentioned already about code decoupling that truly is one of the magical powers of events it's how the event publisher does not know and does not care how many listeners that are to that event it simply fires off the event and does not care what else happens then all the listeners if there are any they will listen to that event and do whatever logic they want based on that event this is really a crucial thing about events decoupling your code as much as possible is one of the best rules you can follow in order to write better clean code and like we saw this is especially great when games when working with the UI usually you want your UI to display your game logic like for example the health of some kind of tower you want some kind of visual for it but you also do not want the tower itself to be the pendent on some kind of visual in theory your game should work entirely without any UI and by using vents this is really simple you can just make it so for example over here the tower class just fires off some kind of event and then maybe we do and maybe we don't have some kind of external display on top that displays some data based on that event if DUI exists then great but if it doesn't then the tower works just exactly the same so events as you can see are extremely useful in helping you write better more performant and more the cou on code definitely make sure you fully understand them which if you fully understood everything in the delegates lecture hopefully you manag to quite easily understand this lecture hello and welcome I'm your codm in this lecture we're going to learn all about generics this is yet another really powerful C feature this one lets you write code that can be used with a multitude of types okay so let's learn about generics and you've actually already seen them in action in a bunch of places for example quite a long time ago we learned about list and in list this type requires putting another type within those angle brackets this right here for example list of inth this is what is called the generic the list type works with generics which means it can work with any type so we can make a list of ins we can make a list of strings we can make a list of program types and so on if it did not have generics in we would need to create a separate list class for every single type we wanted to use it with that would definitely not be very fun not very easy to use whereas with generics we just Define the list class just once just one time and then that class can work with any type we want also same thing when we saw the delegate so we saw for example the action and we saw this one has all kinds of parameters so we can have an action that takes in a parameter of type int we can have a type string we can have a type B and so on same thing for the funk so again there's no need to create a specific action class that works specifically with an INT another one specifically with a float and so on the action class itself that one is made to work with generics it takes a generic T type and that type can be whatever you want now one of the best practical examples of how useful generics are is actually my grid system playlist I've built a ton of interesting systems and games on top of that base system and the reason why I could do that is because the grid system itself that one is made to work with generics here is that class the grid class with generics here it works with a generic type that I Nam T grid object so I can define a specific grid that works with a specific type again could be something simple like an INT a float bow and so on or it can be a specific custom grid object class that I Define and with that with that grid object I can place whatever custom dat I want and the grid system will work perfectly with it so I don't need to make a brand new grid system for every kind of thing that I want to do with a grid I just use the exact same grid system for any type and byting this class using generics by doing that I managed to reuse this Base Class and build all those complex systems that I made in all those videos so how we make a generic class is actually really simple we just write the class name as usual for example let's make our own custom list so let's make a class let's call it my list and then we put our angle brackets and inside here we give our generic type of name and technically you can give it whatever name you want there's no rules here however usually the convention is to name this t for type and alternatively if you have multiple types the convention is to use T and then perhaps a number so T1 T2 T3 so this is what the action uses or alternatively if you want any more descriptive name usually once again you would still start to type with t and then pass in something like for example T unit another example of generics that we've also already seen is the dictionary and if we look inside the dictionary Yep this one named the generics T key and T value so yep you can write whatever you want but over here let's just write a t so just like this so here we have our class with a generic type and now inside of this code we can use the type T so for example let's make a public field of type T so yep just like this now importantly is how T doesn't really exist we don't have any class named specifically t t is really just the name that we defined this can be whatever class we're going to use with so when we use our my list with a type int then this field will be an in field so this our BAS glass and now up here we can make a new let's create a new M list and then for type let's go with int just like this so this is a m list of type int and over here we can go inside access the field and yep note how this field is indeed of type in and yep so this does work then for example let's say we want this class to work with blls again since we are using generics we don't need to make another class definition we can just go up here make another M list in this case of type B let's name it b m list and then do a new in of bow and now we can go inside we can access the field and Yep this one is now a field of type B so over here we have two instances of our class and each of them is working with a different underlying type then our generic we Define our type te where we're using it over here in the field but we can also Define some kind of functions for example let's make a private void my function and we can receive a parameter of type t or alternatively we can make a return of type T and take in no parameters also by the way one quick Tip since over here we do not know what type T is going to be since we don't know that then for example we cannot return null this does not work and the reason why it does not work is because T technically could be a nonnullable value type like for example up here when we are creating our list of ins or bones these are are not nullable values these are value types not reference types so because that over here we cannot return null so if you do have some kind of logic that is meant to return a default value instead of returning null instead of that you can use the keyword default and this will return either null on a reference type or the zero equivalent on some kind of value type so for example let's do this let's make it public and then up here let's call it so let's call my function let's put a right line on this let's see what default value is for both these so let's see and if there it is default value for an INT is zero default value for a ball is false then on the generic definition over here like we saw we can already Define more than one type so we can Define T1 T2 T3 and so on we can do this and then we can use different types in our code this works so here we have our generic class but we can also use generics without making an entire class generic we can have just a single function so over here let's make a test function and on the function itself let's make that function work with generics the way we do it is really the same thing so after the function name we put the angle brackets then some kind of generic name and now we can use this type in any way like for example use it over here for a parameter or we can use it for the return type and yep everything works isly the same over here let's do a console d right line let's print out p and for example up here let's call out this one and we can call in with an INT and if this works we can call in with a string and Y it also works call in with a sh Yep this works call in with a bullion and Y this also works so here we have a function the function was defined with generics which means that we can run this function with whatever type we want then it can also make stru that use generics so instead of a class this can be a struct and yep structs can also use generics another one is also on interfaces so up here we can Define interface my interface and on this one we can also use a custom type and then we can use this type like for example some kind of function that returns of type T Yep this is also valid so lots of use cases for how you can Define generics and how you can use them and another extremely useful thing we can do is simply apply some type constraints to T right now we have no constraints meaning this T this can be used with any type for the generic it can be ins bowls some kind of custom player class it can be literally anything now let's say for example we want this one to only work with classes for that we can go over here into the class definition and afterwards we write the keyword where and then our generic type so in this case T and then put a con and then let's say for example class meaning that this one this type M list can only be used with a the T type as long as that type is of type class so like for example here we see some errors because ins and Bs these are not classes so we cannot use with those we need to make some kind of class for some kind of player and now of here we can make this of type player and if now this does work and again the issue that we saw a while ago on how we cannot return null from this one but if we do enforce that t has to be of type class classes can always be null so now we can indeed use null here then another interesting constraint is let's say for example we want to construct whatever type we use here and right now over here on this function if I try to do new T if I do this nope there's an error again same thing we cannot do it because we have no guarantee that whatever type we use here whatever type we use has some kind of Constructor in order to make that work again we can apply another constraint in this case this one is named new just like this so now we can use this class with any generic type as long as that generic type is a class and has a parameter lless Constructor which over here the player by default has some kind of parameter list Constructor so yep this one is perfectly valid code and over here yep we can do new T in order to construct a brand new player for example we can put this on that one and this one is going to construct a new object of type T which in this case is going to be the player so when we run this it should say something of type player and if there it is it's done like that there's a bunch of really useful constraints we can apply to our generic type there's a great list on the C docs we can see how we can force T in order to be of type struct of type class we can ensure that it is a nonnal type we can ensure that it has a parameter Constructor or one of the most useful ones are simple L these ones basically requiring T to extend some kind of Base Class or Implement some kind of interface and all of these work on a class definition but also over here on just a single function so again where T is a class and now it ensures that we can only call this function with the type that is actually a class and when using the one that enforces that it extends some kind of interface for example let's make a function get attack winner and let's receive two types T1 and T2 Ral let's give it proper names so T attackable and T defendable then we receive those so we can enforce that t attackable does have to implement the I attackable interface and we can enforce that t defendable has to implement the I defendable interface and now since we've applied these constraints because that now we can assume some things about these types for example we can go inside our attackable object and we can call get attack points then we can go into the defendable and call the get defense points just like this now with this if we had a player type that implements both these interfaces and a unit en type that also implements both of them if so we could call this function and pass in either two players or a player and an enemy or two enemies and all of this logic would work because all of them match the perfect generic constraints that we have so that means that this function this single function is really adaptable and can be used with a ton of different types whereas if we were to remove these then nope we cannot access these functions because we have no guarantee that whatever types we use here will actually have these interfaces in generally one of the best benefits of generics is how they make your code Type safe meaning they help you avoid errors when using incompatible types for example let's say we have some kind of resource so we have a type for gold a type for wood and then we have an inventory class that takes in a generic type so then up here we created different inventories one for gold one for wood if we go inside the gold inventory and we try to add and let's try to add some wood if we do this and nope obviously this one throws an error this is how generic samp is by making our code Type safe if we make an object of a type and we Define that this one only works with gold types if so then we cannot add some wood on there the type itself is going to be forced as soon as we create the object and we cannot break that rule all right so those are generics it's another extremely useful sear feature I use them all the time they are super useful for making your code really adaptable so definitely make sure you fully understand this and make sure you use it whenever you need to this is really powerful but also for beginners might be a little bit confusing so if you feel a little bit lost maybe go rewatch The ler one more time maybe go inspect the demo and definitely make sure you do all of the interactive exercises this is a really powerful feature you definitely must know about hello and welcome I'm your Cod monkey in this lecture we're going to learn about constants and the readon keyword okay so normally we have regular variables like for example int Ag and a variable just like name implies the value inside of it can change they're intentionally supposed to be modifiable so over here I can set it to one value and then set it to another value Yep this works but sometimes you really don't want something to modify some things are meant to have some kind of fixed value like for example Pi it has a fixed value and in C you can actually see it with math. pi y there it is 3.1415 926 and so on and note over here how this one is a constant meaning it always has this value you cannot change to something else so if here I put it to just three nope this does not work I cannot assign this to anything else it's a constant meaning the value is always going to be fixed so I need to Define some kind of field for something where the value should never change like for example some kind of float for some kind of player speed if we set it like this then this is a perfectly regular field so we can read it then we can modify it in order to make it a constant we just go here and we add the keyword const and if there it is now we can use this field whatever we want and this is always going to have this constant value we cannot modify this by the way for the name like I mentioned in the naming rules lecture usually constants are uppercase snake case so everything is uppercase and split all the words with an underscore and of course since constants cannot change then we have to assign some kind of value so if we Define something as constant we have to Define it with some kind of value okay so Yep this is our constant and constants are also basically static by nature meaning they do not belong to any instance of any class they belong to the class itself so for example over here we're working inside the static main function and usually we can only access static members so if this one is just a regular field if it is like this then over here we cannot access the player speed we cannot access it because this one is not static but by marking something as cons that makes it essentially static by default so over here we can do Con on the right line we can print this out and up here we can indeed access player speed also importantly is how Conant they are set at compile time time meaning the value has to be evaluated and defined during compilation not during runtime so that means constants are also somewhat Limited in what types you can use with them for example we cannot make some kind of class let's make a class player so we have this and now up here we cannot make a private cons of type player for the player we cannot do this because we need to assign a value and if we construct a brand new player nope this does not work because this line would only run during runtime and not during compilation so for the most part cons can only be used with the builtin type so things like float bll we can use string and so on however classes custom classes or even default ones like for example object these cannot be constant so constants have a bunch of limitations but for example if we inspect the vector 3 struct so let's go inside of this one so let's right click and over here let's go to definition so here is the vector 3 struct and if we scroll down we can see it as some things that look kind of like constants like VOR 3.0 or. one but again a strug cannot be constant so note how these are not Conant instead these are Statics and this is actually property and only has a get and always returns the same value so this is one of the workarounds you can do if you're trying to make a Conant of a type that cannot be constant alternatively there's another really interesting workaround you can build something similar to a Conant by using the keyword read only so let's define a field instead of making this a constant let's make it a read only and if this one now does work we don't have any more errors what read only means is that these fields cannot be changed after they are set so if we try down here assigning it to a brand new thing nope does not work this throws an error so if you mark something as read only it can have some kind of object type but it must be set either over here directly in the Declaration or it must be set in some kind of Constructor this one works with any type so it can be custom classes or it can also be the builtin types like int and so on it can still be useful to use read only instead of cons even for these basic types like for example on the player class over here let's say each player would have a different kind of maximum health so they would have a private read only for the health max and then on the player Constructor we could receive a certain health max then assign the health max onto this one just like this meaning that this would sort of act like a constant meaning we cannot change it afterwards but this way by using the read only tag basically we can set it to a different value and does not have to be set directly at compound time so that's really the main difference between these two for any data that you never want to change and any data that can be defined at compound time for those you can use const and if not you can make it read only once again remember the the main goal behind writing good clean code the main goal is minimizing complexity and the best way to do that is minimize how many things can change so if something is never meant to change then either just make it a constant or read only doing that will help you make your code much easier to understand hello and welcome I'm your Kodi in this lecture we're going to learn about exceptions as well as how to handle them and Fire custom exceptions okay so exceptions these are really errors we've already see them a bunch for example here's some code that is going to throw an error so I def find an in a variable with value zero and then I just do oneide by a so 1 divide by 0 you can never divide by zero so this is going to throw an error let's try running and if there it is right away divide by zero exception so when you hear the word exception than error now if I were to write some logic after this like for example let's say conso the right line let's print out something so let's try running and nope that message does not run as soon as the code gets the exception it stops executing that's where exceptions are meant to do but sometimes you don't want to happen usually if something goes wrong you want to know that something went wrong but then you also want to handle it so usually you don't want to have unhandled exceptions so the way that we can handle exceptions is with a trap block meaning we write the keyword try and then put a code block and inside that code block we put whatever code might fire some kind of exception then to make this valid we need a second piece of code which is called the catch but first let's run it just like this so this is still going to throw an exception this is still going to throw an error dividing by zero but now let's see if this line does run and if there go it did run and we do not have our exception now technically the exception still happen it really just happen silently for example if we were to put a log over here inside after our exception just say something and we're going to see how this log does not run and if that one does not run only this one down here that's because this line is still throwing an error so it stops executing anything afterwards but since we put it inside a try catch because that as soon as the error happens basally it's going to drop into after the try but like I said usually you want to handle exceptions now we only just ignore them so for that over here on the catch block we can add some parentheses and we can put some kind of exception type for a general catchall you can just use the exception type then give it some kind of name like exception and now inside of this object over here we have a ton of data related to that exception we can see the message the stack tray the source and so on so for example over here let's do a console. right line let's print out the exception. message and then let's also print out the exception let's say these stack TR okay let's see and if there it is that one did find an exception so attempted to divide by zero and found in our program on line 19 which Yip it is exactly that one so yep with this we are catching our exception and you can also add multiple catches you can have different ones to test for specific types like for example let's set another catch and for this one Let's test for the specific divide by zero exception except one important thing about having multiple catches is how it's going to go from top to bottom and since every exception always extends from exception this one is always going to run first so this one is never going to run so let's put the specific one before the generic one and another thing if we don't need any data inside of our exception itself if we just want to test out what type happened if so then we don't need to give it any kind of value so just like this it's going to work it's going to catch an exception of this specific type so let's do a consant do right line let's print out our divide by zero exception okay let's see and it picks on like that so we have our divide by zero exception and then the code continues running downwards okay great also another thing you can add is after the exception you can add the when keyword and over here we can test for for some kind of condition so for example when exception is of type divide by zero exception so if we do this then yep same thing this code is going to run pretty much the same thing as this one so it gets an exception stores it in here and tests out if it is this type and if so it's going to run this one so here we have a try and then a catch but there's yet another block that we can add and that one is the finally you add this one after the catch and basically over here the code inside this this code will always run so let's do a console. right line and let's say final and for example up here let's make sure it doesn't go inside of this catch so let's put when exception let's make it of a type that isn't going to happen so let's say for example the argument out of range exception okay like this so this one is not going to run but we're going to see how the finally is still going to run so the finally always runs no matter what so like this if we run yep we do cash our exception then the finally runs and then the hello there so now you might be think that the finally works is only the same thing as down here so we could just put this in here and it would work but one difference is on the finally over here when we can exception let's say for example we want to end this function so we call return and let's see what this does any we call return meaning this function is going to terminate so it is not going to continue running afterwards however even though we are returning even though we still get the final message so this finally block runs after the catch every single time so usually the finally code block this one can be really useful if you need to do some kind of cleanup code for example if over here on the try you were opening up some file for reading you want to make sure that if you do open up the file even if there is any kind of VAR you want to make sure you do clean it up also by the way you don't need to add the catch so you can just do a try finally and Yep this also works okay so this is how we can catch exceptions now to throw them ourselves we can also do that for example let's say we have our custom class for our player and then over here in the player Constructor and then let's make a test function and on this function we want to spawn some kind of exception so the way we throw an exception is with a keyword throw and then whatever exception we want like for example let's just throw a regular exception so just like this and for this one you can open it up just like this so just make a regular empty exception or it can give some kind of message so for example player exception okay so yep just like this so now up here let's remove our previous testing code and now let's create a new player and go inside the player and call test function okay let's see and if there it is that one did fire off a player exception so if you want to throw your own exceptions in your own code this how you do it just use the throw keyword and then you can even make your own exception type for example let's make a class let's call it in valid player name exception the Only Rule is that we need to extend from exception so just like this and now over here instead of spawning a general exception we can do our regular one so just like this let's run our code and if there is exactly like that so exception of type and of our type invalid player name exception also one more thing is for example over here if we do a try catch sometimes you might be running this inside some kind of function and that function might be calling some other function that might throw an exception so essentially you've got functions within functions and sometimes you want to basically just keep throwing the exception all the way up the call chain so if you want to do that you can just call throw just like this and this basally going to rethrow the exact same exception and if there is in this case since we are throwing once again on the main then we end up with a regular exception so by using the try catch to handle exceptions you can make your code a lot more robust for example when making a game you really never want the game to crash if something goes wrong like for example the player somehow has zero items and CA a divide by zero exception if that happens you really don't want the code to break you don't want the game to crash so if that happens you probably want to have that in some kind of TR catch Block in order to catch the exception and handle it in some kind of graceful way and especially when working with some external code like for example contacting some API on some web server for those you really want to add try and catch in order to make sure that your program continues running correctly regardless of what the server applies hello and welcome I'm your KMI in this lecture we're going to learn about enumerators how to implement I enumerable and I enumerator okay so something we've already seen several times is doing a simple for each on a list so we can do a list of in some kind of int list then we just construct a list and we can do a for each in I in the int list and Yep this works perfectly so we can do a four each and cycle through every element in our list but then if we try doing a four each on some kind of custom type so for example here let's make a player new player and then let's try doing a for each on this player and hope this does not work we have an error like it says here the for each statement cannot operate on variables of this type because player does not contain an extension definition for get enumerator in order to make the four each work with custom types for that we need to make our custom types enumerable so let's learn how to do that for example let's define a class for holding a single stat so some kind of name and value so just name it stat and inside just have a string name and just an in for value and then let's make a class to hold a bunch of player stats so class called player stats and over here for example let's have some fields of type stat let's say for Dex for strength wisdom and so on so yep just like this let's just construct these objects okay so yep just like this and now let's say that we want to do a for each and we want the for each to work on our player stats so basically we want to be able to cycle through each one of these stats individually so to do that the first thing we need to do is over here let's Implement an interface let's implement the I inumerable this one takes in a generic so let's say our generic type is going to be of type stat yep just like this so now we can implement this interface so it require us to implement those two functions this requires us to do something that constructs an object of type I in numerator so inumerable and numerator those sound similar but they are different so let's make a class that is going to be our enumerator usually for that we build it as a nested class so here let's make that so the player stat enumerator and we're going to implement I enumerator and again also of type stat then let's see what we need to implement on this one so over here let's select and then over here on this little light bulb let's implement this inter interface save there you go now we need to implement all of these and over here we just need to handle some kind of index and based on the index we're going to return either of these ones so that means we also need a reference to our player stats object so let's make a Constructor here and on the Constructor let's receive our player stats so you have this let's store it inside so just like this we have our player stats and then we also need some kind of index in order to know the move next the current and so on so let's do an in for the index and for the index let's default it to minus one the reason for that is because the four each is going to call the move next before it grabs the current so let's start off at minus one and then on the move next that's pretty simple so let's just do index Plus+ then since we have just three stats so this one is going to be index zero one and two because that over here if the index is bigger than two if so let's just look back to minus one then this one needs to return true if the enumerator was successfully Advanced and false if it has passed the end the collection so we can just return if the index is not minus one okay that's our move next function to dispose we don't really need to implement that one and the reset we can just set the index to minus one so what's important is over here the current this one is a property so let's go ahead and implement this property this one is going to have a get and on the get we're simply going to test out our index so let's do a switch on our index let's add a default and let's add a k Zer so k0 let's return go inside the player stats and on index zero let's return for example let's go go up here let's see so the first one is Dex then case one and two for this one let's return strength and this one let's return wisdom okay so yep so that's a current and over here for this other current we can just do a pass through onto that one just like this so Yep this is our enumerator class so we receive our player set so we have the original object we have some kind of index then on move next we just increase the index and on current we just grab the value based on that index so now here on the get numerator we only just need to return a new player stats enumerator object and on that one we need to pass in this so just like this and on this one again same thing we can do a pass through function so return get En numerator okay so now finally up here we can construct let's construct an object of this type of our player stats let's construct a brand new object and now yep now we can do a for each on that one this one is going to return a type stat stat in our player stat let's just see conso the right line on our stat and just to be able to see that let's inside our stat so inside this one and let's just override our two string and let's return the name and then the value okay so just like this let's test and see if our 4 each is working and if it's going to go through all of our various stats and if there is Exel like that so it did a 4 each through our custom type it found dexterity strength and wisdom all right awesome so this is how you make your custom types work with a 4 each you just need to implement both of these interfaces just do that do some basic logic in order to grab the current value and with that you can then use your custom types inside a for each by the way alternatively for this specific use case where we have a fixed number of elements that we want to cycle through for this a simpler approach is just on the enumerator we can just do a yield return so over here on the function to get the enumerator instead of creating a brand new enumerator instead of defining this entire class and creating all that if we just have a fixed number of elements we can type in the keyword yield yield return and then whatever we're going to return so let's say return that X then do another yield return for strength and another one for wisdom basically what this is going to do is this function is actually going to be called multiple times so by making something a numerator and using yield return by doing that this function is essentially going to store its state so the first time that we call this it is going to return Dex the second time we call it is going to return strength and the third time we call this it is going to return wisdom let's test this and if it works exactly the same we have our three stats so basically whenever you have a dynamic number of elements so if inside your custom type you have some kind of list some kind of collection for that you can define an entire enumerator and write all of this code but when you have just a fixed number just a bunch of simple stats a bunch of simple elements for that just using a simple yeld return this one is much easier also since we're on the topic of I numerator and I numerable let me mention one Unity specific thing which are Cod routines if you're just using C without Unity then don't worry about this part but Unity basically has co routines which is a way to run logic across multiple frames and specifically it works with I in numerator in order to make a co routine we make a function that returns I in numerator and then over here you can do whatever logic you want then when you want to split the logic you can do yield return and then Unity actually has some nice builtin functions like for example we can do yield return wait for end of frame this basically going to wait for the end of frame before running the code down here or for example we have wait for seconds this is going to wait for a bunch of seconds before continuing to execute the code for let's wait for 3 seconds then let's do a debug. log and say something so let's do debug. log before and after okay so this is going to basically run some code after some time so this is a great way to handle timing based logic in your games with this we have a code routine and now to start we just need to be working inside a monob behavior class and of course this script needs to be attached to a game object so then we do this and let's make a start and over here on start we just need to call the function start Co routine and this one takes our I enumerator so let's just call my code routine just like this yep so this is going to start running this code routine so we should be able to see this log immediately then wait 3 seconds and then see this log okay it's running there's the first message and after 3 seconds we should be able to see yep there it is the second message all right awesome so these are Co routines which is a Unity specific thing that works with I numerator now personally I must say I'm not a big fan of Co routines simply because I don't like this pattern that they force you to use it feels needless ly convoluted to me you need to be working on a mon Behavior you need to call start Cod routine you need to make a special function that returns aerator use yield return and so on so personally I'm not a big fan of this huge pattern personally I prefer using super simple FL timers but Coe routines work great so you you like this then definitely go ahead and use them okay so those are enumerators it's how you can make your custom types work inside a 4 in and various other settling Logic for example things like link which we're going to cover later on in the advance section hello and welcome I'm your Cod mon in this lecture we're going to learn about namespaces in C okay so namespaces this is one of the main ways you have of organizing your code think of it kind of like folders for your code for example you would have some kind of folder for your game logic another one for some a logic another for the UI and so on basically it helps you keep things organized and actually we've already been using a bunch of namespaces up here all of these using statements these are all namespaces for example the console class that we've been using this one exists inside of the system namespace we can access it by writing using system up here and then we can access the console class although actually when making a console app the system names space is included automatically so technically you don't need to explicitly Define it but in most case you do need it so you do need to add using some kind of namespace and also over here on this template when we create the brand new project it automatically created our program class with our main function and it put it all inside a namespace now I should say technically you don't need to have a namespace so if I get rid of this and this Yep this still works this is perfectly valid code basically when it compiles it will simply place this class in the root namespace to create a namespace you really just follow this symbol syntax so you write the keyword namespace and then whatever you want to name your namespace also namespaces they can have nested namespaces for example inside the system namespace there's a whole bunch of stuff like for example the IO namespace this is the one that contains a bunch of classes related to input and output and so on then here is a script inside of unity so Unity normally has most their things inside the unity engine namespace for example mono Behavior this one exists inside of unity engine then if you want to do things inside the UI then you would use using unityengine.ui so basically all the classes are nicely organized in namespace that makes sense for them you can also make nesson namespace yourself you can just write some kind of name then add dot then add another name and so on then one big benefit of name spaces is avoiding name conflicts for example let's say I want to define a player class and now let's say I want to define a completely separate class but I really do want it to have also the same name so also another player class since classes have to be unique this does not work here we have an error that it says that this Nam space already contains the definition for our class named player and right way this is also giving us a hint as to what the solution to this problem is the solution is simply put it in another namespace so namespace I can give it whatever name I want then I can place this class inside of that namespace and up here I can use either of them so I can use player and this one is referencing this one down here this one inside of this namespace or I can go inside the code monke namespace access player and up with this now I'm referencing the other one in the other name space the another common issue is sometimes you have a conflict that the compiler cannot resolve for example over here I added using system and using Unity engine and now I want to use the random class but the problem is that there is a random class in both Unity engine and inside of system so the two name space that I'm using up here they both have a class with the exact same name so basically the compiler over here does not know which class I'm referring to so to solve this problem either we get rid of one of the using statements and Yep this works so now there's no more errors however that won't probably break any other place where you're using classes from that namespace so in this case for example if I add the serializable attribute which exists inside of system by solving this problem I now cause this problem so to solve these kinds of naming collisions usually the simplest thing is to just write the full name so for example up here on this one I can write system and even now this one works and this one has no problem or alternatively I can just add the using system up here so this one no longer has an error but this one does have the error and over here I can just write the full name Unity engine not random and yep like this compiler doesn't have any questions it knows that I'm trying to use the random class that exists inside Unity engine another thing you can do with Nam spaces is simply using an alias so over here we can say using then give it some kind of name like Unity random and then say equals Unity engine. random so basically this one is now an alias to this so down here instead of using all this we can use this and if there you go it does work this can be quite useful when you have a really complex project with some super long names when that happens using the Alias can really help simplify your code okay so that's namespaces it's a simple yet very useful C feature as your project grows more and more they become more and more useful hello and welcome I'm your Cod monkey in this lecture we're going to learn about the Singleton pattern in terms of game development this is probably the most useful pattern and also one with a lot of pros and some cons so let's learn about it okay so the Singleton like name implies we have just a single instance of something in this case we have a single instance of some kind of class so for example we have some kind of game manager class and over here the way that we have just a single instance is usually with some kind of static field again static means that the field belongs to the class itself and not any instance of that class so usually we make it private static let's call it of game manager and for the name we call it instance instance is usually a common name used for Singleton although sometimes it's literally named Singleton so either one so here we have our private field and we made this private specifically for one very good reason the reason is because this class should be the only one that is responsible for creating the Singleton instance other classes should only be able to get it so the way that we're going to expose this is by using a public property so let's make one also going to return typ game manager and property usually starts by pass case so you've got our property instance and over here on the get on the get we just return our instance and then for the set for this one again like I said the instance should only be set by this one so for that one let's make a private set and on private set just set instance equals value okay okay yep so just like this basically here we have a field that anyone can access but only this class can set now for actually creating this Singleton let's first cover the barebone C method and then I'll cover the unity specific method so Singleton usually have what is called Las intiation this means that the instance is created only when it's needed for the first time and in order to do that we just put that logic over here on the get we just check if our current instance it is null if so that means we have no instance and if so then we just create a brand new one so we create and then we return it so basically this means that as our program starts there will be no single T instance and then the very first time that we use it it will actually create that Singleton also as a general rule Singleton usually have private Constructors so if you define some kind of Constructor it's going to be private that way any code up here cannot do new game manager nope this does not work because the Constructor is private again that's because the singl ton is meant to be the one that is responsible for creating the Singleton instance so the way that we use this is actually very simple alternatively another way of implementing the Singleton pattern is without Las intiation so an alternative would be to expose the Constructor and then just check if the instance if it is null if so set the instance to this so this is another way that the single pattern could be implemented but again usually you have some kind of private Constructor that only this one calls and over here we don't even need any kind of set because only that one is going to be set so this is the basic C Singleton pattern and now in order to use it it's actually real simple we just access the static property so we just go inside the game manager access the instance just like this so let's do a console the right line and now we didn't create any kind of game manager object up here this code is not creating anything does not know anything about any of that it just knows that it's accessing the game manager accessing the static instance that's it so if we test this and if there it is then we do have an objective type game manager so just by accessing the static instance it automatically created that object and return that instance then over here we can do whatever we want so for example some kind of public test function so we have some kind of function that does something and then up here in our code we can go inside the game manager we can access the static instance we can call test function and Yep this will indeed work also by the way note how just one instance is created so up here we are accessing one instance in here and then going through this one to calling the test function so we're accessing this property twice but when this code runs obviously since instance is only going to be null just once it is only going to create one game manager so no matter how many times we call this we end up with just one single instance and since we made the Constructor private because that nothing else can construct this object so we know for a fact that this class will only have a single instance making this the Singleton pattern as for the benefit of it the benefit is that it's really super simple to use just by accessing the class itself and accessing some static instance just through this we have a reference to whatever object we have of type game manager so we can call functions on this class we can do any kind of thing we don't need to keep track of any kind of game manager reference so for example if we had some kind of class of type player and then the player does something it like adds some kind of score so the player would end up killing some enemy or something over here the player does not need to store a direct reference to the game manager we can just go inside game manager access static incense and then we would call some kind of AD score function by using the single we have our instance of the game manager really easily accessible from pretty much anywhere in our code base and now that we've seen the single over here the barebone C Singleton let's see how to make it in unity in unity it's a little bit different since Unity components have to extend mon behavior and one of the biggest limitations of that is you cannot access the Constructor directly so in unity you simply make a regular script extend mod Behavior as usual then that script is attached to some kind of game object so all pre standard and over here in the code here personally this is the only scenario where I use properties and here I don't even use the backing field directly I use the auto implemented property so I make it public because I want to have a public yet let's make it static of type game manager let's call it instance and then this one has a public yet and a private set so yep just like this so this field has the perfect accessibility that I want for the Singleton so any class can get it but only this class can set it and then on the unity's standard awake function over here on this one just set instance equals this and yep that's really it the awake is going to run when this game object runs and when that happens it is going to assign the instance into this now this one technically isn't enforcing the Singleton rule if over here in unity I duplicate this object multiple times then I'm going to end up with multiple game managers and the one that is going to be set on that static instance is going to be whatever is the last one that runs so for this problem normally the only thing I do is I'm really just careful enough to only make one object object that has the static script that I want but if you want you can also add some proper safety checks one way to do it is over here before assigning the instance we check if instance is not known if so that means that this script already exists and the instance has already been assigned if so this should not happen so over here we can probably just fire off a log error so if over here I duplicate this object and I try running if there it is we have a log error and tells us what the issue is we can see it's on the game manager class then you can either manually fix this so go into the hierar key and delete the second one or over here on the script itself we can destroy this game object to make sure only one is kept alive so for example instead of that let's just destroy this game object and then call return so the rest of the code does not work so if we run this and if there it is we have our error because we do still have two game managers however if we only in the hierarchy yep the second one was inde the destroyed now this Singleton pattern is extremely useful when you have some kind of class of which there is only meant to ever exist just one single instance of that class for example in games it is very common to have some kind of General game manager and again you have just one usually you also have some some kind of audio manager some kind of input manager and so on then for single play games you might just have one player or even just one world so if you have just one of something then the single pattern is actually really great it makes a lot of sense and makes it really easy to access that static instance for example if your UI code wants to show the player's Health it doesn't need to have a direct reference to the player it can just grab the Singleton reference or if your player needs some kind of input it doesn't need a reference to the input manager it just access the static instance and that's it so the single T is great especially in game development where you normally have tons of systems that have a single instance however the Singleton pattern also has some potential problems if you Google you will find a lot of people arguing that this is a terrible pattern although I should say usually those anti Singleton comments are always a little bit too extreme the Singleton is a tool and just like any tool it can be used or abused and in general Singleton seems to be worse for regular game development not game development for game development like I said it does have a ton of benefits that do outweigh many of the possible cons and in general if you write some good code you can actually minimize a lot of those cons like the main con is simply the fact that Singleton are by definition global data the whole purpose of Singleton is to have a single instance of something that you can easily access from anywhere so because that it means that it can have many of the negatives that any kind of global data can have your code can easily become really messy way tons and tons of connections between various classes since Singletons are so easy to use you might be inclined to use them all the time and make it so that every class pretty much depends on a ton of singl ton classes doing so ends up with a massive dependencies ideally your code in your classes should be as decoupled as possible you shouldn't have a ton of connections this advice is applicable really all the time not just in relation to singl tense but single tense May violating this guideline very easy so that is why you need to be extra careful and because those issues of classes becoming coupled with tons more classes because that testing can become insanely hard simp because in order to test something if the class you're testing accesses some kind of single T then that single T needs to be created in order to test and in turn maybe that single T then uses yet another Singleton and on and on so you might end up requiring a ton of setup to do even just a basic barebones test another more serious problem is with regards to multithread code you need to be very careful to make your Singleton thread safe or simply make sure you only access singl ton from the main thread for example if you use Unity dots to write some super performant multithread code the simple way to avoid this problem is to do all your logic in tons of threads then at the end after all those jobs are completed then you do anything that requires a main thread like for example accessing The Sound Manager single T to play some s a sound effect so Singleton can indeed do have some negatives but they're also extremely powerful and extremely useful it is a pattern that can be very good in used but also very easy to abuse personally I use a ton of Singleton in all my games I just also make sure not to abuse that pattern I make sure to control how often I use them and limit class coupling as much as possible so my advice is don't be afraid of Singletons they definitely have their place but use them properly so they actually help you as opposed to hurt you now the Singleton pattern is just one of many programming patterns it is the one that I use most often and I find most useful so I made this static in lecture now next one let's go through a bunch of other patterns that also have their use case hello and welcome I'm your Cod Maki in this lecture we're going to talk about a bunch of design patterns okay so first of all what are design patterns in the last lecture we already covered one specific design pattern the Singleton these are basically some general reusable solutions to some common programming problems the Wikipedia page has a great reference with tons and tons of detail for example the Singleton pattern that we just saw this one one is a nice solution for the problem of how do you ensure a class is only one instance and how do you ensure that it has a global point that is easily accessible that's the entire purpose behind that pattern and by writing the code like we saw in the previous lecture that is how we can achieve those rules so that is a very good solution to that common problem and within that pattern we also saw another mini pattern the lazy initialization so this is how we made sure that the single T only gets created the first time that it's actually needed another pattern we've actually already seen is the Observer pattern this is a pattern where an observer interacts with a subject to be notified whenever something happens so Yep this is literally what we already covered in the events lecture a class subscribes to an event and again gets notified when that event is fired so using events is essentially The Observer pattern another common one is the command pattern with this one you can basically create commands that can be executed later on so one common use case for this kind of pattern is making some kind of undo system so when you do some kind of action you create a command for the undo action with all the data that is needed to perform that undo and then when you want to undo it simply runs that command so this is the kind of thing that can easily be built by combining a stack with delegates another interesting one is the factory pattern with this one you basically put the creation of an object in some kind of factory class and then instead of having every class with a Constructor that anyone can call instead only that factory class is responsible for creating those objects again we also saw a part of that pattern in the Singleton pattern where the Singleton itself is responsible for creating the object so the factory pattern is pretty much just a more dedicated part of this pattern it can be really useful to limit the number of placees from which a a certain type of object can be created then the object pool pattern this is a really useful one this is how you can create a pool of a bunch of objects and in doing so it really reduces the impact for creating and destroying objects Unity actually recently introduced an object pool type that does exactly that if you have performance issues with spawning and destroying objects you should definitely be using some kind of pulling then dependency injection this is an excellent pattern for testing your programs this one uses interfaces quite heavily it's one of the main reasons why interfaces are really EXC you can inject different types of objects as long as they Implement a common interface then the adapter pattern or simply a wrapper this is especially great when working with some kind of third party code you build a wrapper that only contains the info you care about and then you don't have to worry about any more of the underlying implementation so as you can see over here there are tons and tons of patterns and pretty much all of these have dedicated pages so if you want to dig deeper I definitely encourage you to do so these patterns were created by some very smart people in order to solve some very common problem so rather than Reinventing the wheel just being familiar with some of these is really great but you really don't need to memorize all of these I highly encourage you to research them just so you know they exist but don't try to memorize everything in one go like with the visual studio shortcuts lecture this is something that you pick up more and more over time but definitely do take the time to research these in a little bit more like the say goes there's no point in Reinventing the wheel sometimes you have problem for which a pattern would be the perfect solution and if you know that pattern then you can simply apply it rather than having to reinvent a brand new solution now for me personally I don't normally just use the Singleton and the Observer pattern specifically I use those pretty much EXA like they are designed and then I use various other ones when I need them even if I don't necessarily follow these strict patterns so sometimes for example I have some kind of factory pattern I have that where some objects are created only in a specific place but I don't necessarily create a brand new specific Factory class then like I said sometimes I use something similar to the command pattern especially in management games to queue up all kinds of actions and in unity Unity is all made about composition of various scripts so technically it is the composite pattern and I do normally try to compose my complex objects usually by composing them based on interfaces rather than just making one huge object with all kinds of logic so I highly encourage you to research some design patterns in order to be familiar with them but again don't worry too much about memorizing them especially not all of them I certainly do not have memorized all of these patterns only a handful of them then as you go through in your Game Dev or programming career you'll learn which ones you will commonly use as you encounter similar problems hello and welcome I'm your Cod mon in this lecture we're going to see a nice project that incorporates everything we've learned so far in this intermediate section although actually we've already covered a ton of stuff and some of it wasn't necessary to get this zmo build which this is actually a great practical example of everything you're learning in this course this course is all about C and C has a ton of tools and features but that does not mean you need to absolutely use everything all at once every time the goal of all this is to use the things that help you achieve whatever goal you're trying to achieve so let's see the demo it's inside the UN project inside the lectures and down here at the bottom we've got the intermediate project so we have our game scene let's open it and here is the miname running so I've got a player object I can move around by pressing the arrow keys or was then down here I've got an inventory with three slots and there are some weapons and some items that I can pick up there's also some enemies that are spawning coming to me so I can approach the weapon order to pick it up and I can click in order to start shooting and start taking down some enemies so as I shoot they take some damage they get a health bar that goes down and updates and eventually they die and they spawn want a bunch of money then for the money it's also something that I can pick up so I can touch it and pick up all this money I can see the UI is updating as I pick up some more money and there's a bunch more items and objects so for example there's some bombs those bombs are also attackable so I can attack them and I can destroy them and then I've got the other weapons so I'm using a pistol and then I can pick up a shotgun and down here on the inventory yep I picked it up so now I can swap the shotgun and I can start shooting and this one has a different shoot so this one can now shoot multiple bones at once and again I can pick up all this money and then over there is also a nice little potion I can pick it up and again that's also another item it's a usable item so I can use it click to use it and if there you go this goes into some kind of super mode where the player is now moving much faster so I can move around really fast and eventually it ends up and I can select another different one so let's go back to the pistol let's go into that one speed it up back to the pistol shoot that one shoot that one and so on so Yep this is the demo with lots of stuff happening that involves a lot of the things that we've already learned about there's player movement there are all kinds of interactions there's shooting there's enemy there's Health there's damage there's an inventory a whole bunch of items abilities and so on so as you can see in lots of stuff now let's inspect this to see how it all works and how all the elements of C how all of them are being used although also before we look at the code let me make one quick note basically how I built this project is not the absolute only way to do this you could build this exact same project in a million different ways so as we're going through it if you think to yourself that you would build some element in a different way than I did that does not mean that you're wrong there's always many many ways to achieve the same result and the way that I buil this demo is simply just one way out of the millions of possible ways to build it so if you come up with different way to implement the exact same elements you can definitely be right as well okay so here in the project files we can see that this demo is quite a bit larger than the beginner demo there's quite a few more files that's due to the fact that it is larger than the beginner project but also due to the fact that the code is much more well organized there's plenty of small class that do one thing and one thing only as opposed to the beginner project where try to make it as compact as possible which meant putting too much Logic on the player class whereas over here you can see how each file is actually pretty compact you can see most of it pretty much just over here on the quick code preview most of these files are actually pretty small so let's begin inspecting this and let's actually begin with the most complex script of all the player script let's do just a quick overview of this one before we see everything one by one and right away as soon as we open this we can actually already see a bunch of things that we learned in this intermediate section so right away we can see a namespace so all of the code for this project all of it is inside this specific namespace and one of the benefits that I talked about namespace is simply the fact of name collisions and actually on this companion project note how all the code for all of the various lectures and all the demos all it is inside this one project and I do have a bunch of other demos that also have some kind of player class but because over here I'm using a nam space that makes it sure that this player class does not have a naming conflict with any of the other player class so that's the first thing using namespaces then by the way the mono Behavior over here here we have are seeing an instance of inheritance and mon behavior is really just a base Unity class basically if you want to attach any script as a component in unity so for example over here if I select the player object and I look in it yep it has the player script attached to it so in order to attach a script onto a game object needs to inherit from that class then we can also see over here we have the Singleton pattern so we've got a public static player instance with a public yet and a private set and this one the instance is being set over here on a wake this is a Unity specific function that is called whenever this script is initialized so on awake we are instantiating the instance onto this since this little demo is meant to be a single player game it makes perfect sense that the player is a singl t since there is only ever meant to be just one player next we can also see usage of a bunch of constants again constants are values that are never meant to be changed so in this little demo it makes perfect sense to use a Conant for the base movement speed for the damage amount and for the super timer Max then we can see a whole bunch of events we're going to see these in detail a little bit then we've got a bunch of fields and by the way the serial field here this syntax is actually an attribute this is something that I cover in detail in a lecture in the advanced section over here this specific attribute this is another Unity specific thing it is just so I can expose these fields over here on the unity inspector without having to make these fields public if I were to just make them private without this attribute then it would not show up in the editor so in order to do that and keep the code clean keep the fields private in order to do that they need to Mark the serialized field private okay then we have a bunch more Fields then we got some inventory logic we're to see this in a little bit then we've got the update this is another Unity specific function basically the code in here is going to run whenever the frame updates so if the game is running at 60 frames per second these functions are going to run 60 times per second we've got a function here to handle the object rotation so that's the logic for how over here the pistol is rotating to face wherever I'm aiming with the mouse then there's some code to handle the items I'm going to cover the inventory in a little bit then some code to shoot then we've got some standard movement code so just some basic IFS calculating a certain move vector and then just moving the transform alongside this move Direction the transform is basically the game object in unity then we've got the super and let's begin by inspecting in detail over here the collisions again this is another Unity specific function this one has to do with the unity physics system basically over here for all the objects that can be picked up like for example over here the money the money object over here has a little collider so this little box is a physics collider and basically as a player goes inside of this collider is going to trigger that function and and over here this function will be called with whatever object it collided with so the first thing we do is try to get a component again this another Unity specific function this one tries to get any component of a certain type that is attached to the same game object so basically as the player collides with this money object it is going to try to get some of these components and specifically it is looking for a component that implements interface I grab object so here we see an example of an interface and in this case this is an interface that represents any kind of object that can be grabbed so in this game that's a money that's the weapons that's a potion and so on and the interface defines a bunch of functions which all objects that implement this interface must Implement so one of those is of course the money class so this one as you can see it extends the mono Behavior class this is the base Unity class so this can be used as a component and then it implements the igrab object interface then for the logic over here it's pretty simple this is really just a movement logic so over here with a weapon if I shoot a zombie y there you go the money gets spawned and moves a little bit just to have a nice little bit of visual polish so as the enemy dies it spawns some money and moves a little bit and then stops moving so that's really this code in action it moves the transform then lowers the magnitude which is how big is the movement Direction vector and if it is in a certain magnitude then just disables the script which means this update function will no longer be called then down here it implements the functions for that interface so we've got one to destroy this object and then some related to inventory objects now in this case money is not an inventory item it cannot be placed in inventory so over here for these functions just returns false and null before we see the inventory let's actually see how the money is actually connect to the UI so over here in the UI we've got a little indicator to show how much money the player is holding so going back on the player script here on the on trigger enter over here we try to get a component of that interface type and basically if the player hits the money object then this is going to be true it is going to be able to get this grab object component and when it does it is going to fire off this event it is going to fire off with some custom event TS and basically pass along the grab object that was grabbed so this event is defined up here so just a basic event handler that has a custom event Ts for our grab object and over here actually something also pretty interesting which is how in the events you can subscribe to the events from anywhere meaning you can actually subscribe from the class that actually fires off that event so that's exactly what I'm doing here so I subscribe to the on player grab object event and then over here accessing the event ARS in order to get the grab object and doing some type checking in order to see if that grab object is of type money so this identifies what object I picked up and if so then it's going to increase the money amount this is just a basic integer and as it does it also fires off another event on money amount change and the one that listens that event is this little UI element so over here in the hierarchy if I go inside the canvas I've got this player UI script and yeah this one is pretty simple so on start which is a Unity function that gets called whenever this object is initialized so right after the awake so when that happens it accesses the player static instance again the singl ton which is super easy to use which in this case makes perfect sense because this is a single player game there's only one player so use that to easily access the player and then simply subscribes to the event on money amount changed and when that happens it simply calls the function in order to update the text so it just goes inside the player static instance again accessing the Singleton calling a function to get the money amount that the player is currently holding and just passing that on into string in order to update the text this right here is a great example of one of the main purposes of events it allows you to keep your code decoupled and specifically in games it allows you to decouple your logic from your UI elements note how over here on the player class this one has no Direct connection to any UI class it does not know and does not care if there is any UI listening to any kind of money amount or anything meaning this player class is completely decoupled from this UI class which does display the money so if I'm playing the game and I pick up some money yep the UI up there is indeed updating it works great however if I go there and I disable the player UI game object so this script is no longer running but despite that there are no errors because again the player UI that one depends on the logic class but the logic class does not depend on the UI class meaning that the player can exist without or with any y it does not matter it works either way that is really one of the main powers of events it is how it helps you make your code much more decoupled so things can exist without other things now let's look at how the inventory over here works so this one also has a nice content for our capacity then it has a bunch of events that get fired whenever some things happen to this inventory in order to store the inventory items it is stored simply on a list and then just keeps an integer for the selected index so basically which item is currently being being selected then we've got some basic functions so one testing if we can add an item so really just testing the inventory list against the capacity then we got a function to add an object and over here we have an example of a custom exception so basically if we try to add an object without first checking if we can add it so if we try to add it but we can't if so then this is going to throw a custom exception of this type inventory for exception so the exception is defined down here pretty simple doesn't even have any extra data it's really just a type just to be identified exactly what exception it is but assuming things go well it simply adds the item onto the inventory and fires off an event to know that the item list is changed and then just has some more functions in order to set the selected index to get it in order to get the entire inventory item list and get the selected item so here we have a pretty basic inventory it sores a list of things and exposes a bunch of functions that can do certain things so you can work with the inventory also again note how in this inventory class there is no mention of any y anywhere once again that is because of the same thing so this inventory class is this one handles the actual inventory logic and then we have a separate UI class that listens to these events and then updates UI so over here we can see that so inside the canvas we've got the inventory UI so that is this element down here and on this script we have a reference to the inventory this is the one that is currently being held by the player and then we have a list of all the inventory slots these are all of these individual slots these are individual objects and as such they have a custom class in order to handle each individual one so rather than putting the logic for each each specific one inside of the main inventory UI class rather than doing that it is nicely separated so there's one class that handles the entire inventory another one that handles each individual slot then in this slot this one is a pretty simple script we just have a reference to an image and the select game object so the image is the icon Sprite and the select game object is this little green arrow in order to show which item is actually being selected then over here the behavior for each slot is actually pretty simple so we've got one to set the selected state so this really just either enables or disabl that select the G object with the visual then we got one to set the item Sprite again just setting the Sprite for whatever object is placed in that item location and then we have another one in order to set the click action so over here we can see delegates in action so we've got a simple action Delegate for the click action and simply just going inside the button and adding a click action so so an action that is triggered whenever we click on the button and all of these functions these are all handled by the other inventory UI class so over here this one again this one has a list of all the inventory slots and on start first we access the inventory and we subscribe to the two events that we need to so one then the item list changes and one when the select index changes then here we can see the click actions we can see a use of Lambda Expressions so instead of defining proper functions we're really just using the inline Lambda expression this works great when it comes to button actions so we're telling it giving it a click action for the inventory slot on index zero so the first slot telling you to select this index when we click on it then doing the same thing for all the other slots and then we have the functions listening to the various events so when the atom list changes when that happens we want to update the atom list and update which one is selected and on this one same thing just update selected and then for these for updating the item list first thing we do is cycle through the internal list we set the select the state to false in order to deselect all of them and we set the items right to null in order to disable the items then we cycle through the inventory item list that is inside the inventory we go through each of those elements in order to set the slot to the corresponding item Sprite basically this populates all the buttons and then for the update selected this one is also pretty simple so first we deselect all the buttons then we ask the inventory to get the select index and set that one to select it as just that one so yep here the inventory is empty and as I pick up a pistol yep it sets a weapon and sets that and if I click on one of these I can swap which item is selected then if I shoot I can use the pistol I can pick up the shotgun click the selected and use it or pick up this one click it and use it see y That's the inventory with various slots let's also see this over here the inventory this one has an item list and it's of this type I inventory item this another interface here we can see the usage of an enum in order to define the item type so it can be a pistol shotgun or potion and then various functions so one to get the atom type to get the Sprite and to use the item so with this let's look at the weapons and first of all in terms of structure I decided to separate the logical items that go inside the inventory and the actual items that exist in the world so for example over here in the world there's a pistol that the player can pick up this one has script of type pistol object so there's that one and then there's an actual pistol that contains logic so there's onlyu there's the potion object and potion shotgun object and the shotgun here for the pistol object this is the one that implements Agra object so this is how the player can actually pick up the weapon and this one unlike the money this one does return true because does have an inventory item and when calling the function to get it it simply creates a new pistol so this is the class that is meant to handle the logic for the actual pistol as to when that runs it's over here on the player when the player triggers an enter so when it goes into inside another collider it checks if it has a grabbed object which again the pistel object does implement this interface then the pistel object can indeed have an inventory item so then it checks if the inventory can add that item if so it adds it onto the inventory and goes into the grab object nor to grab the inventory item so that is what is going to construct a brand new pistol and over here is the pistol script this one has a function to return the atom type so that it knows okay this is a pistol it has one to return the atom Sprite and over here we see another instance of the single class we've got the game assets this is a class that I use in pretty much all of my games it's just a super simple way to access any kind of assets so here in the game in the scene I've got a game assets object and inside it as this script and then this script I can drag any references that I want to reference anywhere in the code base so this is another really useful use case for the Singleton pattern so anyway so the pistol gets the Sprite for the pistol and then it has a function to use the item which in turn is going to tell the player in order to shoot then the player shoot function this one is pretty simple it really just fires a rast this kind of like a laser in the physics World in order to find other colliders this is basically how it finds other things that it can shoot and over here again note how I'm not looking specifically for an enemy or a bomb but rather an eye attackable interface so this is how the player can actually shoot any kind of object not just enemies not just bombs it can shoot anything that implements this interface but before we get to that let's actually go back into the player class and over here note the override on all of these that is because the pistol this one is actually extending a weapon Base Class and this one here it is this one is an inventory item so that is how it can be placed on the actual inventory and this one is marked as abstract because we are never meant to construct just a base weapon but rather the weapons that extend from this class and everything is abstract so this is all up to the extending classes to implement these functions so the pistol over here implements these functions like this and the other weapon is over here the shotgun again this one also extends the weapon and this one does override with different things so it returns a different item type a different Sprite and over here we got a bit of different logic so the pistol just shoots once whereas the shotgun shoots multiple times so now we can go back here into the shooting code so again this one fires a rast in order to find all the physics objects that it hit if it did manage to hit something if so then it's going to try to see if that something is an ey attackable object and if so it is going to cause damage to that object here is the eye attackable interface really super simple just as a damage function so basically in order to make something damageable by the player all we need to do is implement this interface so for example here we have the bomb class this one does implement the ey attackable interface and this one is another super simple class it has the damage function down here for the interface and simply passes that damage function along down to the health system so the health system this is a great example of composition over inheritance basically the Bob is meant to have some kind of health so it has a health system but specifically it has a health system in a field as opposed to having of the health system code directly inside the bomb class this way it makes this health system reusable which it is indeed reusable since the enemy also uses a health system so let's inspect it and over here this is another preim class just has a basic functions for handling some kind of health so just as a health and a health about Max then as usual it has events for whenever all kinds of things happen so on health change or on dead then we've got the damage functions counts down the health amount and if under zero fires off the on dead and either way fires off the on health change so that is why over here the bomb this one we can note on start this one is listening to the health system on that event and when that happens happens it is going to run this code which is going to destroy the bomb and fire off this event the class that listens to that event is over here the game manager which again this is another one of there exists only one so this one is a Singleton and over here we can see that it is listening to the bomb on any dead event and when that happens basically just spawns a VFX prefab just as that and Shakes the camera so over here if I pick up a weapon and I shoot a bomb and I destroy it yep there you go it fires off some VFX and Shakes the camera yep there it is that's the bomb also note how the bomb also has a health bar that Updates this is another UI element that again is being driven by events so here in the scene we can see the bomb we can see the bomb has a canvas inside the health bar UI and this one note how this class is health bar this has nothing to do with any bomb or any enemy this one simply works with a health system it does not matter where the health system is attached it could be the player it could be a bomb could be an enemy could be building does not matter this health bar works on any kind of health system and the way it works is super simple just listening to a bunch of events and when it does then just goes into the health system to get the health normalize and use that in order to make the bar image fill them out so another super simple super short script it does one thing and just one thing and then our enemy class again this one also implements I attackable so it can be damaged it also has a health system so again it can be damaged it also fires off and on any dead event and note how just on this one and the same thing is over here on the bomb note how these are static events meaning that they belong to the class itself and not any instance of that class so that is why over here on the game manager when listening to that event it does not need a reference to every single Bob and every single enemy it just listens to the static event which is going to be fired from any instance of that class so for example when any enemy dies when it does it's going to run this code which really this one just spawns the money so spawns and sets it to go into a random position then back over here on the enemy class so we've got the event we've got the health system then on update we have some super basic AI literally just moving towards the player and again the player has a single T so it makes it super easy to access and then just listens when the health system dies and when that does it just destroys this game object so Yep this is another super simple class and the last two scripts that we need to look into are the holding object Visual and the weapon animator so the holding object visual this one is inside of the player game object here we have a holding object so basically inside of this object we place either the pistol game object or place the other game objects over here inside the prefabs we've got one for a pistol for a potion for a shot that is how over here the weapon that I'm rotating I can select different weapons and rotate some so this game object has that script attached and this one really just has the reference to the inventory in order to know when the selected weapon changes and when that happens it really just updates its visual that involves getting the select inventory item then doing a quick n check just to make sure there is an item selected and checking for the item type this one is going to be an inum so over here doing a switch on that enum and depending on that spawning a different prefab and finally for each weapon like for example over here the pistol it has a weapon animated script here is that script and right away we can see a Conant for a string like I said you should avoid using strings as identifiers at all cost but sadly actually the unity animator system this one requires using strings so rather than using a string down here for the set trigger on the animator instead of doing that I Define a constant up here and then for the rest of the code I only use this constant that really helps limit the amount of strings meaning the amount of potential problems that we have so it has a constant a bunch of fields then we've got the animator once again and this one also works based on events so it subscribes to the on shoot event on the player and when that happens simply just set the animator North to shoot it spawn the VFX prefab the little dirt that gets thrown out whenever shooting and then just spawn the bullet Ray prefab finally on this one since this element is being swapped out meaning it's spawned and destroyed we need to make sure to unsubscribe to the event so we don't have for example a dead weapon animator still listening to the same event so over here on the on Destroy which is a Unity function that gets called whenever the S game object is destroyed whenever this happens we are just unsubscribing to the event so we don't get comebacks for an object that is destroyed put all that together and here is the object I've got the inventory I can pick up a pistol and I can shoot a bunch of zombies when I shoot them they drop some money I can pick up that money then I can pick up different weapons so for example I can select now the shotgun and now this one shoots many more bullets I can shoot enemies and I can also shoot some bombs and boom there you go they all blow up it's all really satisfying then I can also pick up a different potion I can use it and all of a sudden I'm moving much faster and there you go just like this all right awesome so this is our intermediate project in this really nice project we have Incorporated almost everything we have learned so far you can go ahead and inspect this project for yourself in your own time in order to see how all the concepts we have learned have been used in this project feel free to play around the code and modify some parts to see how it all works if you make a mistake and you break something you can always just redownload the companion project so don't be afraid to experiment as always you'll learn by doing so take some time to do just that maybe build upon this in some way maybe see how you could add another weapon or another grabbable object or another enemy type hopefully with this video you understood how it's all structured so with this plus the knowledge you've gained through this entire course so far with all that it should mean you should be able to fully understand how all this is working how all these systems are interconnected if not then go rewatch some lectures on some topics that you find tricking or simply feel free to post a question in the comments and I'll do my best to clarify any doubts hello and welcome I'm your km all right so congrats on watching this entire free video course I hope you learn a ton I really hope that you took your time and really focused on learning all the topics in this intermediate section and if you're watching this video then I also hope that you also learned everything from the previous video on the beginner section if so then you are hopefully much more skilled now than you were when you started this course if you're watching this in the future then check the links in the description or the pin comment to see whether the Advan section video is over here on YouTube like I said in the previous video my goal is really to make all the video lectures free over here on YouTube if the premium version sells over a certain number of copies and I'm very happy to report that it has indeed gone past that threshold which is why this intermediate video is over here free on YouTube and the video lectures for the invent section those will also be coming out for free in about 1 to two months or if you want you can just go ahead and pick up the premium version right now and continue on to the advanced section right away you can watch all those lectures along with all of the awesome bonuses that the premium version has all right so thanks for watching I hope you learned a ton and I'll see you next time