hello and welcome i'm your code monkey and here let's learn how to use the new input system this video is pretty big but it's the only video you need in order to learn how to use the new input system this is an excellent package that makes managing multiple inputs of different types very easy it looks a bit daunting at first but once you understand how it works it becomes actually quite easy to work with and of course the benefits of this system are immense once you have everything set up in your game working with the actions that you defined after that's done then your game is instantly playable with the mousing keyboard or touch input or maybe an xbox or playstation controller all of that works seamlessly also this video is in lecture taken from my ultimate unity overview course unity is massive so in the course i explain over 40 features and tools of the engine that you might not know about there's individual lectures explaining tons of things like shadowgraph assembly definitions pro builder the video player and so on also the course will be continuously updated with free updates as i add more lectures explaining more tools and features this specific lecture was added as a part of the first free update along with 10 other new lectures so go ahead get the phone course and learn how to master all the unity tools to help you make better games faster in this lecture we're going to learn all about the new input system package this is a lot more capable than the legacy input manager and it easily allows you to handle input from multiple sources without any issues so you can make your games work with a mouse and keyboard or an xbox gamepad or a playstation controller and all of it works seamlessly but naturally all of those awesome features come at the cost of slightly more complexity however once you understand how it's all set up what is an action what is an input and so on once you understand the basics of the system it's actually quite simple to use okay so let's learn how it works first up we need to install it by going into the package manager make sure you're on the unity registry then scroll down and find the input system package then just go ahead and install it and also over here you've got a whole bunch of samples that you can download to inspect if you want to see how they all work so these are some very specific scenarios so maybe they can be helpful now when you install you might see a message talking about enabling the new input system or the old input manager you've got two options you can click on yes which won't disable the old input manager and enable the new input system or you can click on no so nothing changes instead of using that window you can instead go into edit and go down here into project settings then go on to the player tab and then down here scroll expand the other settings scroll down here until you see the active input handling and over here you can select the old one the new one or you can select both of them now i cover the differences between both of them in another lecture so go watch that if you haven't seen it yet but essentially i find that they both have their use cases so here i just pick both and when you change this it restarts the ent editor okay now to start actually using the new input system the first thing you need is to create an input actions asset this is an actual asset in your project files so you just right click on some folder go into create and then scroll down here until you find the input actions so create it give it a name like player input actions and then double click on it so when you do out pops out the input actions window now this is where you're going to define all the actions and inputs that you can then use in your game so you see this separated in three groups you've got action maps actions and properties now let's add an action map by clicking over here on the plus icon so an action map is how you organize various actions for example if you had a game where you have a player that can walk around the world but also enter vehicles you would make one action map for the player walking another one for the vehicle inputs maybe yet another one for the ui for while the game is paused and so on so using multiple action maps really helps keep things nice and organized by having distinct action maps instead of just a huge list of actions so let's call this one just the normal player next up are the individual actions so this is what actions your game can take like for example move or shoot so for example let's name this simple action just jump then over here on the properties you can see the action type so it's a drop down menu you can select from value button and pass through now value is for continuous inputs so something like movement being controlled by a joystick would be a value type button is like the name implies for things that work like buttons so something where you press and release then passthrough is similar to value but it bypasses something called disambiguation which is the process through which the input system decides which input is active but for now don't worry about that let's just focus on value and button now this is a jump action so let's make it a button then we have interactions this is the various ways that we can interact with an action of this type so for a button you've got the whole multitab press and so on if you just want a basic button pressed and you don't need to add anything that's the default and finally processors so this is how you can apply some processing to this specific action itself this is more useful for when dealing with joystick inputs for adding a dead zone and so on but we'll see that in a bit okay so when you create a new action it also created a new binding if it didn't you can just right click and add a binding so the binding this is the actual physical input that we want to tie into this action then for selecting the physical input you can click on this drop down menu and manually select it so go into the gamepad and over here you see all the various buttons that you can map alternatively for more advanced use case you can turn this into a text box and over here type in the actual button this is a special syntax used by the input system so again for now don't worry about that let's keep things simple and the simplest of all is just to click on this button that's named listen so when you click now you can press any key you want so in my case for jump let's press the space bar and there you go that one listens to the spacebar on the keyboard and just select it all right so with that we have the most basic input asset done we made the player action map inside we defined a jump action we made it so that it works like a button and we bound that action to the physical spacebar input now let's see how to actually use this to jump an object and also one very important thing that you cannot forget is to actually save this asset so up here you've got a button for save asset and up here on the title for this window you can see a little asterisk this means that there are unsaved changes so when you see that make sure you save it and also up here on the right side you have a toggle where you can enable to auto save so the reason why this is a toggle not simply enabled all the time is because of the c sharp question generation which we're going to see in a bit but until we do and turn this on and make things simpler okay so now that we have over here our actions working in order to use them the simplest way is with a prebuilt component so i've got my testing scene here i essentially just got a floor and then i've got a basic sphere object so i want to jump the sphere and now over here let's add a component and let's search for player input so this is a builtin component that is really useful for working with the new input system over here you can see it takes an input action asset so just drag the one that we created there it is then we've got default map right now we just have one so let's default to that one then we've got some more advanced use cases for dealing with the ui camera and so on so just leave these at none and then you've got the behavior so this is how the actual notifications of each action are sent and over here you've got various methods you can use so first of all you've got send messages which uses the unity send message system so it triggers functions with these names on any script attached to this game object then the next one is broadcast messages this one is similar to send message except that it also triggers functions on any child objects but most of the time you should use one of the other two so either yinty events which you may already be familiar with or basic c sharp events so let's see the unity events now here we get an events tab that we can expand to see all the various events that this object will fire so by default we've got these three so when it's triggered when the device is lost for example a gamepad gets disconnected regained so the gamepad gets connected again or controls change so for example you swap from the keyboard to the gamepad so these are normally in the event so you can click on the plus icon select an object in a function to trigger them and then up here you've got the player so that's the specific action map that we created and up here we've got the jump so this is the event that we made the actual action so this is where we can trigger something so let's make a script that we can then feed into here in order to have our event so up here i'm just going to make a basic c sharp script call it testing input system and here let's attach it to this game object okay now in here let's just make a very simple function so let's make a public void jump and on gem let's just do a debug.log jump okay just very basic and for the object let's drag this game object as the object and for the function let's go down to the testing input system and the jump function okay so like this let's test so here i am as i press the spacebar if there you go i've got unlock all right it does work now let's just make the rigid body jump upwards so just for fun okay so just like this just add four support just to make this weird jump so here and as i press the spacebar if there you go the sphere jumps all right so far so good now however there's one interesting thing that you might notice which is even though i press the spacebar just once over here we actually see three unlocks now the reason for that has to do with the various phases that the input system goes through so it's essentially one log for when the button was pressed another one for the button is currently pressed and finally for the button release if we expand the event we can see this event can be called with a parameter of type callback context this is the type that contains more data on specifically how the button was pressed so let's modify our function to also include this parameter so back in our script let's add using unity engine.input system and then we can modify this one and we're going to receive of type input action dot callback context then of course if you want you can just directly go to definition and inspect all the source codes all the various things that this one does but over here let's just see the actual phase so let's set him to the log the context dot phase and back in the editor since we modified the function let's assign it again so once again the jump function there we go so let's test okay so here and as i press the space bar and if there you go you can see the various stages it goes through so the starting so that's as soon as i press perform so that's i'm currently pressing it and cancelling which is when i release so these are the three separate stages that the input system goes through so for example for a button chances are you really only want it to be triggered once when the button is pressed so you can use the performed event you can either test if the phase equals phase not performed or you can just go if context not performed so this is a simple boolean that simply returns true if it is in the performed phase so if on the performed then you do this okay so like this so here i am and i jump and there you go it jumps much less because only being implies the force once and you can see that we just have one log all right awesome so that's one way to make it work by using our input unity events but then like we saw the other method is using c sharp events so let's see how this one works so when you click these are c sharp events so they are not visible in here in the editor so the way you subscribe is like any other c sharp event so it's through code so first of all let's get our component so private it's of type player input okay so we have that one and then through there we can see all the various events that it has so it's got the default ones that we saw a while ago so on device lost regained and on controls changed and then for the various actions you've got this one on action triggered so regardless of how many action maps you've got you've just got this event so as you might imagine the one big difference is that this one is triggered for all actions on all action maps now right now we just defined one action but if we had more then any action input would fire this one event so let's simply subscribe to this one and as you can see this one takes a parameter of type combat context so when we get the context let's just do a debug download on the contacts just to see what this is doing okay so let's test okay so here i am as i press the spacebar and if there you go now i can see the various contacts so i can see the action is in the action map player it's the jump action it was triggered by the keyboard space then for the phase this one is disturbing it happened on the time of 5.9 seconds and once again the key keyboard space with the value of one and no interaction so you've got the starting phase the performance phase and the canceled phase so in order to use this method then you do some identification over here on the action field and depending on what action it fire then you do different things but if we're going with this method of using this builtin player input class then i think it makes more sense to use unity events for this one so again you can use both but here i'm going to switch back so just like this and make sure that on jump event it triggers the jump action okay so now it's a good time to look into action interactions so back in our input manager we've got the jump action over there it's an action type button okay and we've got the interaction so let's add one let's for example look at the whole interaction then if you want you can set how long so how much time do you have to hold the button before it's actually triggered as a hold event so you can use the default so just take this box or untick and set anything that you want and like this message says you can click over here to open the input settings so this opens up the project settings and goes over here to the input system package and you can then create a settings asset and modify all the defaults so let's test just with the default so just a hold once again don't forget to save just in case you have autosave disabled and back here we are not using c sharp event so let's just clean up the code just get rid of this so it's easier to understand and over here on the jump let's actually do a debug.log on the entire context okay so we have the whole interaction now let's see just how often this function will be called so here i am and if i just quickly press yep we can see we've got the start and the cancelled phase but we did not get the performed phase that is because we did not hold on for long enough and the sphere itself did not jump because it only jumps on the performed face so if i click and i hold after half a second then it does do the performed and now as i let go now it does the cancel so as you can see the interactions are super useful for making some more complex actions and again remember that everything that we're doing here we're making it work with the keyboard but if we add another binding it would also work with the gamepad or touch or anything else and also this is a list so you can have multiple interactions so you could have a home then a slow tab and so on although ideally chances are you would make them into separate actions okay so that's interactions and then you've got the processors like i said these are really very useful for buttons but you can for example add an invert processor and right now before we hit play and clear the console we can see that as we were pressing we were getting over here the value of one so on the started and performed we've got a value of one and then on cancel we got a value of zero now if we add the invert processor so now as i click and if there you go now instead of pause one we get minus one so these processors apply some sort of processing on top of the actual event this is going to be more useful as we get into the movement joysticks but we'll see that in a bit okay so with this we have covered the absolute basics and we also saw how the builtin player input component works but like i said previously you also have the ability to generate a csharp class and have a lot more control over it so let's go into the project window and over here so like the actual input actions asset then you got a button to edit the asset which opens up this window and then you've got a toggle for the generate csharp plus so you can take this one and then you see all these inputs so if you want you can modify what file they're going to be generated in what class name what namespace and so on but here just leave them as defaults and hit on apply so as you do you can see over here that generated the c files over here the player input actions now if you want you can open and inspect this it just generates all kinds of functions fields and events based on the input action so for example we defined a player action map and over here we can see the player action map right in here and then for the player we define some actions so we define the jump action so over here we can see an interface that implements the jump action over here the player actions so all of this code is all dynamically generated so we've got our jump action and the various events started performed and cancel so you really don't need to worry about how this script works but if you want to feel free to inspect it so back in our testing input system here in order to use that we just need to create an instance of our generated c sharp class so it's called player input action so new player input actions so just construct this object and then on this one we need to access the player action map and then we're going to access the jump action and finally we're going to subscribe to the performed event so just pause equals and subscribe to this one and there you go the signature is exactly the same so on gem performed you've got a comeback context and then over here you can do anything so let's use this exact same function instead of creating a new one so just like this let's see if this works and just up here right now we're no longer using the player input so let's actually remove this component so we're just going directly through the c sharp class so let's try here i am and as i hit space and nope nothing happens now that is because we need to make sure to enable this input action so by default when you construct is actually disabled so it's not actually listening to input so in order to enable it we actually have various ways we can do that we can go directly into the player input actions and call enable however if you do it like this it will actually enable all of the various action maps so if you had one for the player one for a vehicle one for the ui all of them would be active at once which is probably not what you want to do so instead of enabling the entire input actions asset you can just go into the player so just go into this action map and just enable just this one and now here if i hit space if there you go everything works so i've got the performed action and it triggered the jump and it jumped the rigid body upwards and again note how here we only have one log that is because since we're going through this one we are only subscribing to the performed event so if we wanted of course we could also subscribe to the started or the cancelled event but chances are we just want to perform so this is actually much better okay with this working now let's add some more actions so on the input action asset let's add another action so we click on the plus button here let's name this one movement and now here is the reason why there's a toggle for the autosave which is because of the c sharp class generation if you have the generation enabled and you change this one tiny thing so for example over here change from button into value as soon as i change then you can see down there that unit is compiling so everything is frozen i gotta wait a bit and so on so if you do have c sharp generation enable then it makes sense to disable it do all your changes then save and when you save then it does generate the csharp plus okay so this is our movement action then over here for the action type this is not a button so we're going to use value and then you can see a field for the control type so this is if you want to limit it to a specific type like for example only allow the dpad or analog inputs or anything or you can also go with any if you're not entirely sure but in this case we do know that we want movement which means that we want an x and y axis so let's go with a simple vector 2. and then let's also delete the default binding that was created automatically so just right click over here click on delete and instead let's click on this plus icon instead of adding a normal binding let's add a 2d vector composite so with this we get four directions so up down left right so this makes it perfect for binding to something like the arrow keys or w a s and d so i'm going to do that to just select this binding then over here on the path click on this one click on listen this one is up so press on the double key there you go w then down go over here press on s then left let's go into a and finally the right let's go into d all right wsed so again don't forget click on the save asn so now it's going to regenerate the c sharp plus and now once again you can either go through the player input component or access the c sharp class directly so let's use that method since we're already using it here so for that one let's go into the player input actions then we're going to go into the player action map and now the action is named movement and let's subscribe to the performed event okay so when that happens let's just do a debug.log on the context so let's test like this and see what the context contains so here and i'm going to press the double key and here as soon as i do you can see that happened so you can see the context triggered on the player action map on the movement action which has all these mining so w a s and d this was a perform phase on this time and if you look a bit further you can see over here the value we've got a value of 0.0 and then 1.0 so i press on w so that means i've got a 1 on the y then if i press on the s i've got zero minus one if i press on a i've got minus one zero press on d and i've got plus one zero so we've got the perfect vector two in order to actually move our sphere so let's use that to move our rigid body so up here on the context in order to read the actual value let's go into context and then you call the function read value and this one takes a generic for the actual type here we have a twodimensional array so let's read it as a vector two and now in this case this is the movement direction that we want to apply to the rigid body okay so here we're doing context out read value reading a vector 2 so this is going to be our input vector then i'm just doing a sphere rigid body in order to add a force then for the force i'm constructing a vector 3 because the sphere is in 3d and the input vector is in 2d so just making that using the input vector x then 0 on the y since i don't want to move this here upwards but rather back and forward so just put that one multiplied by a certain speed and so on okay so let's just like this so here i am and as i press on w and if there you go it did move the sphere however you can see that it moved by a tiny amount so now i press on s and goes backwards and now i press on d and goes to the right press on a and so on so the one thing that you do notice is that this input gets only triggered once so it's essentially on a button press so if i want to actually move the sphere i've got to spam the buttons that's not supposed to be like that ideally for a movement input it makes more sense to constantly check the current state and constantly apply it so for that we can go with another method instead of over here subscribing to the performed on the movement action we can make a very simple private void update and over here we can actually read the value on every frame so you can go into player input actions so that means that we need to make this as a member field so you go into that one access the player action map access the movement action and then over here we can call read value read as a vector 2 and so on so the same thing that we're doing here let's do it up there okay so the exact same thing except on the update we're going through the player input actions player movement and so on and then applying the force and everything should work so now let's see so now as i press and hold any there you go now movement is indeed being applied on every frame let me just lower the speed and since this is a rigid body we should probably do this on fixed update and yep now in here i can read use wasd in order to actually move my sphere so move it to the right move it upwards then start moving downwards and so on all right so now it's working and i'm reading the value on every single update so chances are for movement you want to go with this method instead of the event method okay so now it's probably time to look into how multiple inputs like keyboards and gamepads work over here on the input action assets if you go on the top left corner over here you've got a button where you can add a bunch of control schemes so let's add one let's call this the keyboard and over here on the list you select the type so let's select of type keyboard and hit on save then here for each individual binding you can go ahead and over here tick and make sure that this one is used in the keyboard control scheme so just select that one in there then over here for all these select them one by one okay so now all of these bindings are set as keyboard bindings and now we can go up here create a new control scheme name this one gamepad and on the list let's select a gamepad select a generic gamepad and just hit on save and when you do you can see that the bindings disappear now if you want of course that are not lost so you can go back into the keyboard and you can see the keyboard bindings then go into the gamepad and over here we're going to add gamepad bindings so right now i just connected my xbox controller and you can also see over here on the logs that the input system automatically detected that that one was connected so with this let's do just like we did so on the jump let's click on this we're going to add a binding then for this binding go into the path and listen and i'm going to press a button on my xbox controller so i'm going to press the a button however if you try this it might not be working that is because i connected the gamepad right while the game was running so to solve that just make sure you save the asset and just play the scene and then if you quit again now it should be identified so now i can go up here click on listen press on the a button and there you go it does connect in order to validate that everything was connected there's actually one that is super useful that i'm going to talk about in a bit but just here briefly you can go over here into window analysis input debugger and over here you should be able to see your controller connected okay so anyways click on listen click on the a button and over here you see an interesting thing about the input system if you want you can select the a button on the xbox controller so if you do that then this action will only be triggered by the xbox a button meaning that pressing x on a playstation controller will not trigger this action so the better approach you can take is just use this one just button south gamepad this is a generic control that won't work on any gamepad so you've got buttons south north east and west and with that if you sound like this one so button south gamepad so the generic one if it's unlike this one then don't trigger on an xbox a button or on a playstation x button or on a switch a button and anything else that has the standard inputs okay so that's the simple button input okay and then over here for the movement let's click on this button and now for the keyboard we made a 2d vector composite that's because it was based on four buttons but for the gamepad we really just want to use a joystick so let's use a normal binding and then over here for the path just click on listen now i'm going to move around the lipstick and it automatically identifies so once again you can go with the xbox controller or the more generic gamepad alright so that's it and now just with this we can see the true power of the input system which is we do not need to touch our code at all the code is already set up to work with the jump action and the movement action regardless of whatever physical input they come from so just with this if i click on save asset and i play the game now i can for example press space on the keyboard in order to jump and now without doing anything special i'm just going to press the a button on my xbox controller and if there you go it does trigger the jump now using the gamepad so here this is the example of the awesome power of the new input system so it allows you to completely separate actions from the physical inputs you write your code to work simply with actions and then you set up the input action asset with how those actions are triggered and then without doing anything else your game now works perfectly with any input so the player can seamlessly switch between keyboard or gamepad and anything else and everything works perfect alright awesome okay so with that you already know the basics but let's see a few more things for example like i said the processors they are super useful when it comes to game pads and by the way here since we actually have two control schemes we can add processors on the action itself so click on the action and add a processor this will apply to the action regardless of whatever control scheme you're using or you can just add the processor directly on the actual binding so this is useful if you want to apply a processor to the gamepad but not on the keyboard so then over here one of the more useful ones is over here the stick dead zone this helps when gamepads have slight issues and they aren't perfectly on zero zero so for example you've heard of the nintendo joycon drift that is where the actual physical joystick gets slightly moved to the side never actually goes down to zero zero so that is why you have the stick that zone so with this processor what it does is if you move the stick bound less than this amount then it won't be considered zero so it won't do anything and if you move it by more than this amount then it won't be considered one and also the value between these two is normalized so for example if i take away this one and i put the minimum at 0.5 so now it should only read a value of more than zero after i move the stick more than half words towards any direction so over here i am physically moving the stick and as you can see nothing on the console so it's not listening and once i get past the halfway point so just a bit more and there you go it does start to actually move let's add a log so we can see the actual values so up here let's do a debug.log on the input vector to see what this says so over there it's all at zero and as i move a bit and it's still at zero and only once i go past 0.5 then it actually reads the value 0.1 so like i said this is normalized so as soon as i move past the half now it starts reading the value and if i go way past to the side so if i go past the 0.975 then it reads as an actual one so that's what the processors do as you can see adding the stick dead zones to gamepad 6 is something you should always do so your players can play the game even if their gamepad isn't in perfect condition and just as another quick example for example you've got the normalized vector 2 so as you saw if i move the stick by a tiny bit then it only shows like 0.1 but if i add the normalize and now as i move just one tiny bit you can see the values are normalized so even if i move just a tiny bit the magnitude of the actual input vector always goes up to magnitude of one okay so now it's time to talk about the thing that i mentioned a while ago which is for the input action you've got value button and then pass through now pass through is similar to value but it bypasses something called the disambiguation which is the process through which the input system decides which input is active now like i said the input system handles all the complex logic when you have multiple inputs connected like for example multiple gamepads and when using value it will only trigger the action for the active gamepad whereas on passthrough it will trigger the action for every single gamepad so now i also have a playstation controller connected and if i move one you can see on the log that it does change but then it goes back into zero and so on that is because right now it is receiving input from multiple controllers so i'm just moving one controller and not the other one and the input as you can see it's very erratic so the issue is because receiving inputs from all of the various controllers so for example one of them is telling them to go right the other one left and so on so the whole thing gets all messed up whereas if i set this back into value and over here if i'm moving using the xbox controller yep now the log is actually correct so it's only listening to input from the xbox controller and now if i instead start moving the playstation controller now it's listening to input from download so now it only listens to once at a time so only the one that is active gets listened all the other ones get essentially ignored so passthrough is useful for if for some reason you want to read input from every device at once but for the most part you really want to use value now so far we've been playing with an input action that we created from scratch however if you want to quickly get it up and running you can also use the default so if you go onto a game object and then add the player input component if you do not assign anything here and instead you click on this button then it asks you for a path so you can save it and it automatically creates the default input actions asset so this one is prefilmed with a bunch of action maps and a whole bunch of actions so if you want you can use this as a starting point instead of building your own from scratch or you can just look at this one to inspect and see how they implement things so this one has got all kinds of control schemes e2 action maps all kinds of actions and so on now on the lecture where i cover the differences between the input manager and the input system i said that the input manager is just more simple and more compact in general while that is true the input system can also be very compact if you want it so for example just testing for a simple mouse click you can do a private void update and on update you can do go inside the mouse access the current active mouse go into the left button and then check was presses frame if so then with this you've got a simple test testing if the mouse is pressed then you can also test for specific gamepad so you access the gamepad class you access the current one then you can access all the various buttons so a b button north south and so on you can also go into the keyboard and access the current the nexus for example bt key and so on but do remember that this super compact method is something you should really only use for a very quick test or prototyping something new when building something more permanent you should absolutely be using the actions and not be working directly with specific buttons at all one more thing here in the code is with regards to multiple action maps so as an example let's create one to see how it works so first of all go up here create a new action map let's say this is the ui so we want a bunch of inputs for navigating through our ui and up here let's just add a single action so just submit so just clicking a button and then for the binding let's just bind it directly into the spacebar so since it's bound to the spacebar which also on the player it's also bound to the spacebar so the player has got to jump to the spacebar and the ui has the spacebar doing a submit now how do you tell which action map should be active if you're using the player input action first of all let's make a function for the actual ui submit so over here you've got the various action maps so you expand upon this and set it so here let's just copy this one do the same thing except this one call it submit okay and now here let's just hook onto that event okay so we got both events both of them triggered by the same physical button but they are on different action maps so over here on the player input itself you can see the default map so this is the starting one so that you start on the player or the ui or so on and now how you change them is over here through code you've got the player input so you get the component and so on and then you trigger the function switch current action map you do that and then you pass in the map name or the id so let's use this super compact testing that i mentioned previously instead of the mouse let's go to the keyboard so if i press the t key we're going to swap the player input to the action map ui and if i press the y key we're going to swap it back into the player action map and then by pressing space we should see either this function or this function so let's see okay so here i am as i press space and yep it's firing the jump action on the player action map now i press t to swap out the actual default map and i press space again and you have now it's instead firing the submit action now press y to go back into the player and so on and down so yep this is the function that you trigger in order to swap between each action map so for example if you had a ui that was only meant for the pause button then when the player hit on pause then you would call this and when the player had on the resume you would go with this one so this is when working with the player input builtin component and when working with c sharp one is very simple like we saw it only works if we actually enable it so on that one we would enable the player by default then when we want to switch we would disable the player so just go into the player call disable and then go into player input actions access the ui and call enable so if you went with the c sharp method then this is what you would do now something that i showed a while ago that is super useful is the input debugger you go up here into window then down here into analysis and open up the input debugger and over here it shows you all the various connected devices so for example in my case i've got a mouse keyboard i've got a dual shock and an xbox controller then you can also see for example some unsupported devices so for example i recognize my microphone but of course it's not a actual gamepad then it also recognizes a bunch more and my specific mouse isn't being recognized but it is on the generic mouse and then you can also double click on each of these to go in further so for example double click over here on the xbox controller now for example if i press the a button if you can see over there on logs it does recognize and i'll let go and it goes back to zero so you can see up here on the valley the actual valley that it's reading directly from there so as i click there it goes here and so on and if i move the dpad then you can see all the various directions and if i touch on the left trigger you can see yep the value going up and down and so on so this is very useful to verify and make sure that your controller is indeed connected and unity is indeed receiving the input correctly so with this we have the new input system working one thing that is required in pretty much every game is rebinding keys so let's see how that's done over here on the testing script let's try rebinding the player jump action so to do that we access the same jump action and then we call the function perform interactive rebinding so this will essentially do what we saw of pressing the listen button so you call this this creates a specific object and then you call start to actually start listening so when you do then listen to the next input and assigns that to this action however just like this we're going to get an error but let's see it and if there's the error we cannot rebind something once something is currently enabled so over here we are enabling the player action map so when we go to rewind we need to make sure to disable so first we disable and then we start actually rebinding so like i mentioned a while ago we create the various action maps so for example one would be for the player ingame actions and then another one for the ui inputs and then while the ui input actions was enabled then you could easily rebind the player input actions now this function this one the perform interactive rebinding this actually returns an object of type rebinding operation this object is what actually contains all of the data regarding the rebind then you can also add all kinds of modifiers in order to do various things before you actually call start specifically it has an uncomplete event so we can hook into this one in order to listen when the actual rebind completes so for that we perform the interactive rebinding then instead of calling start right away let's first call on complete and on complete this takes an action so this one takes a call back as a parameter so we can do it like this so just a simple lambda expression and in here let's just do a debug.log on the comeback okay now let's play the game and that function was triggered on the wake so right now it isn't listening for a button so as i press for example the t key there you go it actually worked it rebound the key but we also see an interesting error related to a native collection that was not disposed of that is because you must manually dispose of this object in order to avoid any memory leaks so the object is the actual rebinding operation so that's the same one that we get over here on the comeback so on complete we do this and then we can call this pose so we dispose that and after the rebind completes let's reenable the action map so we try it out so we reenable this one and then let's see okay so now it's listening to input so as i press the t key yep now it should have rebound the jump action onto the t action so if i press the space bar nope it no longer jumps and if i press t yep now it does indeed jump alright great now like i said there's tons of filters you can apply in here you can inspect the rebinding operation to see all these various filters and things so for example you can add a canceling button or you can limit the expected control type or for example you can limit some controls so for example you do with controls excluding and then let's say exploiting the mouse so with this i won't be able to rebind this action onto the mouse so if i'm here and i click with the mouse and nope it's not rebinding because the mouse is not accepted but if i press a different key on the keyboard if there you go now it doesn't rebind so with that we can now rebind our actions so i rebound this to the t key so as i press t it actually jumps okay great however now if i stop playing the game and i start playing again and now press the t key and nope it's not jumping it's once again back to the default back to the space so naturally we need to actually save the rebins and for that there's actually two ways depending on what version you're using now if you're using version 1.0 then you need to manually save them but if you're using version 1.1 then there's a much easier process so when you actually rebind so after the on complete it actually changes one thing in the asset so for example over here on the comeback you can access the action and then for each action you've got various bindings so you can cycle through this one or in this case we just have one so just zero for testing and then for each binding you've got a field for the override path so let's look at what this log and as i press the t key to rebind there you go it did rebind in order to the keyboard t so if you're using version 1.0 then this is what you need to do you need to go through your input actions go through all the action maps cycle through all the bindings for each action and save up the override path however if you're using version 1.1 then there is now a function to return some json for all of the overrides so you just call this function and it returns a json string which you can then easily save in a file or the player prefs or anything and then another function for actual loading so depending on your version you've got two different methods okay so the last thing we need to cover are the touch controls you can define the bindings like any other so for example if you look on the input actions that are created by default on this one for the control schemes you can see it does have a touch control scheme and that one you can see that it does have the very specific touch controls so you can do this to set up the individual bindings but beyond that there's also a super useful builtin component so here let me make a canvas and then inside the canvas let me make an empty game object and now inside i'm going to add a ui image and for the image i'm going to select a basic circle and now just take the stick and let's put it over here on the corner and now the image itself we can add a component and search for onscreen stick this one then it's got two fields so the movement range that's how much this image is going to move relative to the parent and then the control path which is what this stick will simulate so in this case we can click on this let's go into the gamepad and we're going to simulate the left stick so if we play now as i click and drag the virtual joystick and yep there you go it is indeed moving the sphere so it's moving in any direction and if i push to the edge and it's the 50 units that we saw there so just like this it is automatically working and then the other builtin component let's make another image put it on the other side and this one is the onscreen button so this one same thing is just acts like a button so let's pretend that this one is the gamepad south button so as i click on this one yep it's simulating a jump so for mobile you can build your own ui from scratch and attach the touch specific bindings or you can use these super awesome super useful builtin components in order to simulate a gamepad using touch and everything else in your game won't work seamlessly alright so that's a new input system package this was a prebaking lecture since it's a pretty complex system but hopefully you can see how the complexity does pay off this system forces you to separate your logic and abstract actions away from physical inputs which in turn leads to writing better cleaner code and a game that can be played on any input device go watch the input manager versus input system lecture if you haven't seen it yet in order to understand the differences but if you're working on a proper game then this system is awesome and it's definitely what you should be using alright so this was a lecture from my ultimate unity overview course there's lots more explaining tons of things like shadowgraph similar definitions pro builder the video player and so on go ahead and get the phone course and learn how to master all the unity tools and features to help you make better games faster alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and i'll see you next time