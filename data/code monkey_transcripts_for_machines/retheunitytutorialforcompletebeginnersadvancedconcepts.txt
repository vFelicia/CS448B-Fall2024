hello and welcome I'm your code monkey a while ago Mark Brown from the channel game makers toolkit did an excellent beginner's guide for Unity it's a great video if you're a beginner or you want to get a quick refresher on the basics go ahead and give it a watch it covers the absolute Basics on making a game kind of like Flappy Bird with some really nice editing that makes it really easy to follow I definitely wish I had one tenth of his editing skills I started writing a comment pointing out some more things to help beginner go one level past the complete beginner stage and that comment ended up huge in super detailed so I figured I'd make a quick visual version covering all the points that are exactly one level above absolute beginners by the way if you want to learn blender 3D modeling there's an excellent homo bundle with a bunch of horses and the usual extremely deep 98 off discount I followed the complete blender created course myself last year and I managed to go from complete beginner to being able to build some nice models or if you just want to pick up some readymade assets then there's also a sale on the city store lots of packs for everything you can think of all in their signature gorgeous low poly Style so check out both sales with the links in the description so let's take a look at the slightly more advanced concepts and some clarifications starting off with naming rules as I've mentioned many times before you can use whatever naming neurons you want you can use a prefix in your variables use a postfix use capitals for consonants chemical case for properties snake case for Fields any of those can work by the way here are the definitions of what those mean in case you don't know them Pascal K starts with a capital and every word is capitalized camel K starts with lowercase and then uppercase for the first letter of every other word kind of like a camo hump in the middle and snake case is where you add an underscore in between the words like I said every rule can be valid the important thing is that you are consistent in always following through with your rules as you might know Unity mono behaviors have some default functions you can Implement so things like start and update which are written using Pascal case since you cannot really change unity's on rules that means that at least on function names I would say you should probably base your rules off of theirs so for functions you should probably use pass on case for the other rules like I said choose whatever makes sense to you here are some of my own personal rules that I've developed over the last 10 years for functions I use Pascal case just like unity and just like the csharp standard for function parameters I use camel case for Fields also camel case properties are in Pascal case constants are in uppercase snake case for a room that's a bit more controversial personally unlike the opening currently brackets on the same line I do hope this statement doesn't Center more in the comments it's just the visual sound that I personally prefer visually I think it looks better on the same line but if you like new line then go ahead and use that and a final rule which is simply spend some time deciding on a proper name and don't be afraid to rename things never use a variable with a single letter like X or k the exception of course would be iterators on something like a for Loop also do not use acronyms or abbreviation those might seem clear to you right now but in a few weeks you might not remember what they mean remember you don't get bonus points for writing extremely compact code so make sure you make your code readable and understandable even if it requires variables and functions with very long names so these are my general rules for the code style that I personally follow figure out what works for you and always make sure to follow your own rules next topic magic numbers these are numbers that you use directly in your code which have some sort of magical meaning that is not immediately apparent for example in the video he uses a 10 here now what does that mean if you watch the video where he is wearing the code then it's clear what it does when writing the code you always know exactly what you're writing but you will quickly forget the meaning of that value after some time so instead of using magic numbers always make sure to use a variable either a member variable or just a simple local variable and give it a proper descriptive name that clearly indicates what that variable represents you can see the huge difference to the code readability when Mark changes it to a proper variable with that simple change the code is much much easier to understand if you were to get back to that code sometime in the future you would have no problem understanding what it was doing because there are no magic numbers involved I covered more about magic numbers indeed on another video if you want to learn more next topic why you should not make everything public this is an extremely important topic and one where I already made a dedicated video on basically when you make something public you are enabling both read and write access from anywhere in your entire code base meaning that if you have a thousand classes then you have a thousand places where you could be modifying that field for example in the video the rigid body feel on this set is public but you don't really want another random class to randomly modify that field if you had another script that set that field to know while the game was running then everything would break with the film set as public there is nothing to stop that from happening so the better approach is to make it private that way only that one class can read or write to that field no other class can modify it in any way good programming is all about minimizing complexity the more you limit how accessible something is the easier it is to understand you don't need to keep in mind the entire code base since only the code in that class can read or write to that field so in that case you have two better options you can make it private but then of course you have the issue where you can't direct references in the inspector now since a rigid body happens to be on the same game object you can grab the reference with get component that's one approach another approach is make it private but add the attribute serialized field this one lets you make you feel on private so it's not accessible from any class but because it's serializable it is accessible from the UNT editor so with that you can drag the reference in the editor directly again go watch my dedicated video on why you should not make everything public if you haven't seen that one yet this is one of the easiest things you can do to drastically increase the quality of your code just following this one simple rule will make you a 10 times better program next topic and this one is really simple but a very important one which is tags this is something that a lot of beginner tutorials use if you want to identify an object use a tag if you want to find an object use a tag so it's a simple system that sounds good but as you grow your programming skills you will quickly recognize that it has one massive flow and that is that it's all based on strings strings are horrible horrible way of identifying things the issue is that they are extremely error prone it is very easy to break something when using string names and on top of that it is extremely difficult to debug if you have some kind of main logic game object and you tag it with the word logic if you write logic in lowercase it won't break if you write logic with a capital I it looks the same but it won't break if you add a 0 instead of an O it won't break if you had an invisible string in the beginning or end and again everything breaks and like I said on top of being easy to make mistakes it also makes it very difficult to find those mistakes because of this code this is all perfectly valid code there are no compiler errors as far as the compiler knows this is all valid workable in C sharp code the problem happens in runtime when this exact string does not match the exact tag in game development and programming it's usually unwise to use absolutes like you should never use something or you should always use something but in this case this would be the exception where I would say you should definitely never use tags or strings to identify anything I don't think I've ever seen a good use case for tags so instead of tags the better option is to drag the object reference directly probably by making it a serialized film private alternatively if it's something that exists only one like a main logic manager then perhaps use the Singleton pattern another way for identifying objects is use Tag components meaning you make a standard monobehavior component that is commonly empty and you just attach that component to something with that you can use get component or has component to see if the object has that tag component the important thing about these methods is none of them are based on strings if you write the wrong class name on a tag component you will get a compiler error so the compiler won't even let you run the game so again do not use tags and strings for identifying things and if you are now thinking to yourself well I'm way too smart or experienced to fall into that trap of mistyping something just know that this exact problem happened to me a few months ago while on Livestream back then the only place where I use strings was in a fine to get child game objects and even though I was very careful with my names I still had an error that made no sense the code did not have any typos the fine string was exactly the same as the object name except of course it wasn't after going crazy for a few minutes live on stream I finally figured it out turns out the game object name had an extra invisible space at the end so yep my advice to you is never use tags or strings for identifying things next topic updating UI state code decoupling and defense so as I mentioned a while ago the main goal with good programming is minimizing complexity you want to limit how many things you have to keep in your head at the same time and the best way to do that is with code decoupling meaning to have systems and scripts as separated from everything else as possible that way when you work on a single system you only have to think about that one system it doesn't matter how big the rest of the code base is if that system is nicely decoupled from everything else then nothing else matters one example of this where beginners usually do it wrong is when it comes to logic and UI for example in the video when updating the UI he has the pathology class on the UI class what to do doing it this way means that these scripts are tightly coupled if you remove the UI script from the project then everything won't break because in logic class expects the UI to exist the easy way to achieve decoupling in a scenario like this with logic and UI is use the excellent csharp feature called events which I've also covered in detail another video with events you can define an event name kind of like on past pipe you can Define that on something like a bird class and then you fire that event whenever something happens then some other class like for example a UI class can listen to that event and do whatever logic it wants like for example updating this cortex that way the bird class does not know and does not want to know that there is a UI element at all maybe there is maybe there isn't all the bird class cares about is that it fires the event into the void perhaps someone listens to it perhaps not in this case the UI class would listen to it but the birth class has no direct connection to it so if you can only remove the UI class the code would still compile and everything would work just the same another example is on the game over logic instead of the bird telling the game over screen to pop up it shouldn't set for an event some like onboard died then the game over screen can listen to it and show itself so as a general rule try to keep logic and UI as separated as possible if you want your UI to display some kind of state then don't make the logical list on the UI what to do just fire an event and have the UI figure out what to do with that info definitely watch my video on events if you haven't seen it events are insanely useful then just a quick mention on something used in video using Legacy text component Unity has two text systems the lazy text and text mesh Pro nowadays you should be using text mesh Pro it's much better in every single way the difference in the code is instead of using unity engine.ui and the class text you would instead use using TM Pro and text mesh Pro ugui or text mesh Pro depending if you're referencing a UI text or World text object another quick mention is on inputs Unity also has two systems there's the Legacy input manager in the new input system in this case the difference is less pronounced you can still use the in Legacy input manager personally I use it all the time in my own videos because it is so much similar to setup than the new input system so I always use the Legacy input manager for quick demos and prototypes but in terms of proper features the new input system is so much better so go ahead and use the latest input manager for quick demos and quick prototypes but as soon as you have a proper project you want to release you should probably refactor your code to use the new input system I also covered it in detail in another video also something tricky for beginners are the render Pipelines in the video Mark quickly selected the regular 2D template now this template uses what is called the builtin render pipeline this is the render pipeline that Unity has had for many years it works great but nowadays you have two other options you have agrp or the high definition Runner pipeline which is a render pipeline you want to use if your game is pushing visuals to their absolute limit or you have urp the universal render pipeline this one is the option that you should probably be using nowadays you have many more features like 2D light Shadow graph and a bunch more there's a bunch of templates you can download which come with the render Pipeline on setup but in most cases I would say urp is what you should use and if you're making PC or console games then yep use urp or agrp in my case I always use urp for example it's what I'm using to build my next steam game total warm liberation another topic that is also a bit tricky for beginners are the versions although this one is really only tricky if you try to make it tricky in the video Mark show downloading and installing unity and by default it installed version 2021.3 which is also known as the 2021 LTS version LTS means longterm support it's the most stable ENT version that's the version you should be using in 99 of cases so if you just follow whatever ENT gives you by default you're fine but if you tried it again you might be surprised to see that there are quote unquote newer versions right now you have version 22.2 so for a beginner you might think well surely I want the absolute latest version that one would be the best right and technically it is technically it is the most advanced recent version but that might also come at the cost of some stability when publishing your games you really want the engine to be as stable as possible so that is why they recommend you use the LTS version which is always one year behind the tech version so for 99 of cases you should use the version it automatically selects which is the LTS or long term support version so right now you should be using 2021 LTS in about six months you can use the 2022 LTS all right so those are my more advanced notes on the contents of that video it's really great it's an excellent quick overview of the absolute Basics I'm sure that video will help lots of people get started on their own gamedev journey and with this video I hope you found it useful to hear me talk about these more advanced topics and hopefully you'll learn something new alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and I'll see you next time