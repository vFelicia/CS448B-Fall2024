hello and welcome i'm your code monkey and here let's build a really nice feature complete camera system we want the ability to move rotate zoom in and out enable edge scrolling and touch drag to pan the camera this is a great and very capable system for just about any game where you want the player to have direct control over the camera you can follow this tutorial and download the final project files we're going to build it in a 3d scene but in the end i'll also quickly show a conversion to make it work in 2d now this video ended up pretty long but it's the only video you need to make a fully complete camera system so if this is something that you need make sure you watch the full video to the end if you prefer a more guided path with step by step lectures then check out my complete courses learn how to make a builder defender game using csharp or learn how to make games internally using visual scripting perhaps if you're past the beginner stage and want to make the jump to advanced then check out my turn based strategy course to learn how to manage a more complex project and write some good clean code or learn all about unity with the ultimate unity overview course which contains over 15 lectures each covering a different tool feature of the engine i'm always available in the q and a section answering your questions every single day so check them all out with the link in the description all right so let's build our camera system now of course to do it we are going to be using syn machine if you have never used it i covered it in detail in another video basically syn machine is an excellent unity builtin tool that makes everything related to cameras so much easier we're going to see how we can build a basic camera in just a few seconds as opposed to minutes or hours if we built it all ourselves and for the demo scene that i'm using here this one is from the recently released cynthia ancient empire's pack it's a gorgeous pack with a really awesome roman or greek theme there's a link in the description if you want to get it for yourself all right so let's do it first of all let's create a brand new virtual camera so let's go up into game object then down here find cinemachine and then let's create a standard virtual camera let's rename this the scene machine virtual camera and that's it okay so with this here we already have a nice virtual camera and the way that this system is going to work is we are not going to directly move this object so the virtual camera we're not going to directly move this instead we're going to move another object and then set this virtual camera to follow and look at that object so let's do that let's right click on the hierarchy let's create an empty game object quality camera system let's reset transform to zero zero let's go into the virtual camera and just drag the reference as the follow so if we see on the camera it is currently positioned exactly on top of that object which is on zero zero then let's also add the same object reference as the lookout and now with this actually the camera is already working to test that out let's hit on play so here the game is running and the camera is already working let's just play around with the fields here the goal is for this object the camera system so the target object for that one to be right on the floor and the camera is above it looking down so for that on the virtual camera let's expand the body and over here we've got the phone offset by default it's at 0 0 10 so we can actually look in the scene view to see what the default looks like so yep there's the object right there the target object and virtual camera is 10 units in the z behind it like i said we want an overhead camera so on the virtual camera let's increase the fall offset by quite a bit let's lift it up on the y so put it something like this then on the z also push it quite a bit more back so a bit lower bit higher something like this okay so just with these basic settings you can already see it working here with the game viewing scene view side by side we can already see the object and if i manually move it yep there you go you can see the camera perfectly follows so this is how we're going to do we're going to move this object and the camera will automatically look at it so let's make a script to do that but before we do before we exit play mode let's make sure to go into the virtual camera and over here make sure we take save during play so we don't lose all the changes that we did so far and also let's push this a bit back so a bit more of a front view okay like this all right so those are the settings that i want make sure save the ring play stick now if we exit play mode if there you go all the changes were saved let's just move the camera system game object moved by default something like this also rotate it we're going to see rotation a bit but just right now it already works all right okay so with this like i said let's make that script so let's right click on the project files create a new c sharp script called the camera system let's select the camera system game object and attach the script alright so here let's just do some basic input logic so let's do it by going into private void update now here let's just add some basic input logic all right so here it is so just testing for wasd now naturally you could easily replace this with new input system which i covered in detail in another video so with this we have a move direction also note how since we're working on a 3d game look at how i define a vector3 and when pressing the w or the s key i'm modifying the z not the y that's because we're in 3d so when moving forward we want to go four not up so we have this move direction however here you need to be careful with how you actually move this object you might think that you could just add this move vector straight onto the transform position so just go transform.position plus equals the move direction multiply it by a certain move speed and by time dot all the time to make it frame rate independent so here you could define the move speed and put it at some value so you might think to do this but if we do and let's see what happens so here i am and if i press on w yep it does move forward press on s let's go back press on the go right press on a goes left okay so it does seem like it actually works however if i unmaximize this window now with the scene view side by side let's select the camera system game object and over here let's apply a rotation so let's put it maybe 90 degrees so the camera is now rotated and right now if i do the same thing so let's see what happens when i press on w and there you go it moves to the left and now if i press on d yep now it moves forward now s a and so on so this is the issue with this code when i press w i want it to move forward but when i do now it's moving to the left that is because moving into the global forward which in this case with the camera rotation the global forward is still pointing in this direction so when i press on w it still goes there now obviously this is not correct this is not what we want we want to take the rotation of this object into account in order to decide how we should move so back in the code here how we solve this actually pretty simple instead of moving directly by the moved ear what we want to do is to use the super useful transform vectors so let's calculate the final move there so let's actually rename this one so for this one instead of moving let's rename it so the visual studio shortcut this ctrl r let's rename this to the input deer then we calculate the final move there and for this one like i said we're going to use the super useful transform vectors we're going to use transform dot forward so this is the forward vector for this transform so this takes rotation into account so we multiply this one by the input dear.zed and then we add the transform.right again this one is also affected by the rotation of this game object we take this one and we multiply it by the input there dot x so with that now we have the correct move direction based on the object's rotation so we now use this in our movement and if we test it like this here it is with the camera rotated on zero so if i press w s a and d yep sound works perfect now if i rotate the camera so again let's apply a 90 degree rotation now press on w and if there you go does move forward s d and a all right awesome all right so here everything is working correctly we can move in any way we want now at this point we should probably tweak some settings here notice how the camera is indeed moving as we want so move up down right left and so on but since we're also looking at the invisible target in front of here due to the smoothing that we have it creates a bit of an odd result so as i press on w you can see the camera kind of shifts a bit upwards and if i go to the right it kind of has a slight delay now perhaps this is what you want if so then don't bother with the tweaks that i'm going to mention but in most cases you want the camera to pin right away instead of going slightly behind the target thankfully like i said since we're using city machine this is super easy to do so much just like the same machine virtual camera let's expand over here the body and then we've got the x y and z damping if we set all of these back down to zero yep there you go now the camera does move much more snappy again like i said this is personal preference and it kind of depends on what type of game you're trying to make but generally i prefer like this i perform my camera to be much snappier okay so with this the movement is working next up let's in on rotation for this one is also going to be super simple we already saw how we're going to do this since we defined the camera over here with the phone offset with a negative on the z that means the camera is always behind the target object so there's the camera and the target object is down there since the camera is already behind all we need to do is rotate this object so over here on the y rotation all we need to do is play around this and we can easily rotate the camera so here in the code it's super simple again let's do some input so again just using some basic input on q and e in order to rotate so we get the rotate direction then in order to rotate the object we can just modify this transform dot euler angles and let's add it based on new vector3 for our 3d camera we only want to rotate around the y axis you can verify what rotation you want if you look over here in scene view so if i rotate around the y yep you can notice that it rotates exactly as we want whereas on the x it does this kind of rotation that's not what we want and the z does this kind of rotation also now what we want so what we want is rotate on the y so over here create new vector 3 0 on the x 0 on the z and let's just put over here on the y and for the y let's use rotate direction multiplied by a certain rotate speed and finally just multiply by time dot delta time all right so that's it some extremely simple logic let's test all right so here we are now for press on e yep there you go rotates press on q and yep it does rotate all right so yep it does work now it's going a bit way too fast so let's actually reduce that and also if you want the opposite so if you want to press e and rotate in the other direction then over here just swap these make this one minus in this one pause but in our case it's working exactly as i wanted let's just lower the rotate speed a bit slower so here press on e any of those rotate press on q and does rotate okay great but we do see the same issue that we saw previously so as i rotate the camera is slightly lagging behind so that does not look very good so once again the solution is the same let's go into the virtual camera now let's expand the aim part and over here we've got the horizontal and vertical damping let's just put both these at zero and now the camera yep perfectly nice and snappy so by moving rotating off it works perfectly okay great now remember make sure you toggle save during play before you exit play mode and here it is the camera working really nice really perfect so we can now move anywhere we can rotate anywhere and everything works right all right so that's it next up let's handle edge scrolling this one is also pretty simple over here in our movement code we are testing for player input but we can also create an input direction based on the mouse position for that we have the input.mouseposition this gives us the mouse coordinates in pixel units so if we do a quick debug download and test this if there it is here in the log i can see and if we look in the stats we can see the size of this window so you can see that i've got this window set up as 1080p so that's because over here i've got full hd selecton and to check out what input.most position returns we can see that if i put the mouse over here on the lower left corner yep it returns pretty much zero zero and if i put over there on the top right corner it returns 1920 by 1080. so input.mouseposition gives me the screen pixel coordinates with this we can just do some basic math all we need is to get the total width of the screen get the total height then check if the mouse is within a certain distance from the left side so for example if it's under 10 pixels of the left side then we move to the left if it's within 10 pixels at the right then we move to the right and so on okay so here in the code and let's do that let's first define just an edge strong size so an end edge scroll size maybe 20 units maybe 20 pixels maybe that's enough then we just use some simple logic so if the input.mouseposition.x if this one is under this amount under the edge scroll size then that means the mouse is on the left side if so then let's set the input here dot x to minus one f then we test for the mouse position dot y if it's under that one then we want to move down so that's e z minus one next up we want to test if what's on the right side so for that we're going to test the mouseposition.x and we're going to test if it's past the screen dot width this is how we get the screen width so then when we subtract the edge scroll size so if the mouse is to the right of this point then we want to move on the x by plus 0.1 and finally the opposite so this one is on the y let's use the screen dot height and this one we move on the z on plus one all right so that's it really super simple let's test so here we are with the mouse in the middle of the screen now five approaching miles on the left side if there go pens left pins right pans forward and backwards all right awesome everything works now when it comes to edge scrolling some people like it and some people don't so usually you want to add it as an option rather than making it always enabled so for that we can just go up here make a private ball use edge scrolling you can default it to either true or false and if you want you can even make this a serialized film in order to make the default shown in the editor and then over here we just use this logic if this one is true so if use edge scrolling then we do all this and if not then we don't do any of this alright so that's it some super simple logic and obviously you would control this boolean based on the player's options all right now for the final movement method let's add a click and drag so i want to be able to for example place the mouse here use the right mouse button keep it hold down then i move the mouse in this direction and the camera moves in that direction so that's what we want to do okay so here in the code so let's begin by testing out our input like i said i want to use the right mouse button so input dot get mouse button test for the get mouse button down so we want to know when we press it so on the right mouse button so that's on one again of course you could swap this out for touch or any other input i'm just using the mouse just because it's nice and simple so when we do press the mouse let's set a certain volume to true so let's go up here and let's define a private ball call it drag pan move active okay and then down here when we press the mouse button let's set this to true and let's add another one for this one let's use get mouse button up so when we release then we set this back into false okay so we have this nice bully knowing when we should pan or not now with this we're only going to run the drag panel logic while this one is true so after this we do if if this logic is true then we're going to apply the drag pen move okay so in order to pan we need to know the less mouse position so we know how much it moved in the last frame so for that let's store it let's define a private vector 2 since the mouse only has a vector 2 for the last mouse position and then with this one let's go down here as soon as we press let's set it so this one equals input dot mouse position and then down here while it's active so while we still have the last mouse position with the last mouse position with this one we can calculate a vector 2 for the mouse movement delta so this is how much the mouse moves in the last frame so we just take the input dot mouse position exceptionally up here is the mouse position not the mouse on delta so we take this one and we subtract the last mouse position and here for some reason the mouse position actually is a vector 3 not a vector 2 so we can easily just cast this down into a vector 2 before doing the math all right so with this we have the mouse movement delta so we handle all of that and then in the end after all the logic then we update it with new value now we can do a debug dialog to see what this shows so we understand how this logic is working so here's the log now if i right click and if i hold still it's zero zero now if i move the mouse right and up so move it yep there you go we've got plus and plus over there and if i right click and i go down and left there you go we've got negative values so this is the amount of pixels that the mouse moved since in last update so with this we can now use this delta in order to directly move the transform for that let's actually put all this logic above before we move the transform we're going to refactor all this code in a bit so we've got this now let's just convert the mouse movement delta into the same as the input direction so here we set the input there dot x equals the mouse movement delta dot x but then we modify the input dear dot z based on the mouse movement delta dot y because over here we're working with a vector 2 but with the input we're using the z okay so that's it except with this it's going to move way too slow so let's define a float for the drag pan speed then we just multiply it by the drag band speed okay so let's test so here we are the camera is static now if i right click and i move the mouse and if there you go it is painting there penning there there and there all right awesome so with this we are directly using the mouse in order to pan the camera anywhere we want we've got that filmed if we feel that this is way too sensitive but yep the logic is working perfectly all right awesome so we already have quite a lot of things working now before we move on to the zoom let's actually refactor our code like i said i want this video to serve as the ultimate camera controller so let's refactor all of this to make the code really nice and easy to read and also really easy to define which features you want to use like perhaps you don't want the drag pan or perhaps you don't want edge scrolling so let's do that so first of all let's make two functions one to handle the movement and want to handle the rotation so for the rotation that's just this code so just copy this and we call this on the update all right and for the movement let's first of all copy all of this so all this in there and on update we call handle camera movement okay so right now everything is done working exam the same as previously but like i said we want to refactor this in order to be able to use or not use edge scrolling same thing for the drag pan so let's actually make separate functions for each of these movement types so let's go down here make another function private void handle camera movement edge scrolling and let's make another one so another private void handle camera movement for this one called drag pan and all we do is just copy all this logic so the use edge scrolling let's copy on to this one and then for the other the drag pen let's copy all of this one and of course we this we need to use the input here since we're reusing it so let's define another input here here and also same thing for this one okay so that works now on these two functions we just need to apply the final movement so that's this logic right here so just copy it apply it to the end here and apply to the end here all right so everything's working no more errors now we can just add all the functions depending on all the features that we want for this and now we can easily either enable or disable these based on boeing so we've got to use edge rolling now for another one use drag pan then let's put the ifs on this one so test for the if in here instead of testing inside this function it's over here let's get rid of this one so that one always runs and then same thing another if on this one all right so that's it now it's super simple all we need to do is modify either these variables and the logic won't work exactly as you want it here is the camera system with all the features enabled so i've got edge scrolling if i go to the sides yep i've got the regular movement i've got the regular rotation and the regular pan movement all right awesome okay so with that the code is working all the logic works now the last thing that we need to handle is the zoom and for that there's actually two ways to zoom a camera one way is to bring the camera in closer so on the virtual camera one way to zoom is to get it closer on the z and also closer on the y so this applies certain zoom another alternative is to simply change the fov so as you lower the fov yep it looks like a zoom so both these approaches work as kind of a zoom they're different so it depends on which one you want let's see how both those work okay so over here let's keep writing some good clean code and call handle camera zoom so let's make this function so down here make a broad void and all the camera zoom all right now here the first thing that we need is some input and for zooming what makes most sense is the mouse chrome wheel so let's handle that we can easily access that with the input dot mouse scroll down now this one as you can see it's a vector 2 because apparently there are some mice that scroll on the x but chances are for a zoom you want to scroll on the y so you've got this one.y if we just do a debug.log on this to see what it does here if i scroll forward yep we do see the value change we do see a plus one and if i scroll the wheel backwards so back to me we do see some negative values okay so these are the values that we can use to run our zoom logic so over here let's try handling the field of view method first now this is actually the more complex part due to how sin machine actually works you might think that you can just access the virtual camera and search for a field of view field so first we need a reference to the virtual camera so let's make one let's make it a serialized field so we can set it in the editor for the syn machine virtual camera and for this we need to add using syn machine so we have this for the same machine virtual camera then here in the editor we can drag the virtual camera reference okay so now here like i said you might think to just go inside this object so let's go inside this one and search for some kind of field of view but nope there's no such thing search for fov nope does not exist looking at the inspector here we need to figure out how to modify this field and thankfully cinemachine has all the source code available so you can just right click on the component and click on edit script and when you do you should be able to see the entire source code for send machine and just in case that doesn't work automatically you can just find it manually so you can go into your project window and over here expand the packages now if this one doesn't work then on the project window on the top right corner there's this little icon with an i if this one is toggled then the packages don't show up but if you untoggle it then all of them show up and here you can find cinemachine then inside you can find runtime and then under behaviors over here you can find the same machine virtual camera so just go ahead and open this here like i said contains all the source code however over here if you search for field of view nope nothing shows up search for fov nope nothing shows up so to get another hint we can again look in the inspector and over here we see that the fov exists inside something called lens so then over here on the script if we search for a lens we do find exactly this an object of type 1 settings called m underscore lens then we just need to go inside this lens settings so on the project window we can search for lens settings let's make sure to search in all and here we find the online settings so inside the send machine runtime core line settings and inside this script now if we scroll down yep here we do see the field of view so this method that we just did this is how you can figure out how to find any field in order to modify it through code there's an even more advanced version of this method where you can load all of the packages source code directly into visual studio doing that makes it super easy to find exactly where the field is that you want to change in my ultimate tnt overview course one of the lectures is exactly on this topic how to find any class or any field to modify any of the many tools and features that unity has another example of this is the postprocessing effect so how do you modify these various films inside these various effects through code that's one of the things that you can do with this method or the other one that i covered in that lecture also that course teaches you how to use many of the tools and features that unt has so check it out to the link in the description okay so back to our demo here we already know how to get the field of view so now let's do that let's go into the camera system so we've got the send machine virtual camera inside we can access the lens and inside the lens access the field of view now with this we can change it whatever we want so first let's just test it out so let's set it to something like 10 and let's do it when we scroll so if the input dot mouse call delta if the y is bigger than zero so if we scroll upwards then we should be able to see the field of view change let's see so here we are regular zoom nice scroll in and there you go it does zoom in alright awesome okay so all we need now is some logic to use some proper values since the zoom is instant we also need to handle some smoothing logic so here in the code first we need to store a field for the target field of view so a private float call it target field of view we can defound it to sunlight 50. then when we handle the camera zoom when we scroll in the positive for this one let's increase so target field of view increase by a certain amount let's say by maybe five and if we have the opposite so if we scroll the wheel backwards so let's reduce it by five now here you don't need to use delta time because this value the muscle delta this one is based on how often you physically scroll the wheel it is not something that happens on every single frame so you don't need time to download time okay so with this we have our target field of view now with that let's add a clamp to keep it within valid values so target field of view let's do in mathf.clamp let's clamp between a certain minimum and maximum so clamp this value for the minimum and maximum we can define them up here perhaps as a serialized field let's make a float for the field of view max another one for the field of view min let's default the maximum to about 50 and the minimum let's say 10. so then with these two down here we just use them so the first one is the min so the field of view min and the field of view max okay so we have the target field of view now just apply it so into the syn machine virtual camera access the lens and let's modify the film the view to the target field of view again right now it sound doesn't have any smoothing but let's just make sure this logic works so here we are and if i scroll backwards yep it zooms in and if i scroll forward yup it zooms out alright great except it actually has the opposite behavior that i want obviously this is personal preference but i find better that if i move the wheel forward i want to zoom in and if i push it back i want to zoom out so very simple just up here just swap these so that's a minus and that's a plus okay so final thing that we need is like you saw it's way too snappy so let's add a nice smoothing and we can do this with a simple lerp i actually cover this in a quick short video it's a super simple way to add smoothing to pretty much anything can be a flow to vector 3 or anything you want so in this case target fill in the view is a float so let's use math f doubler this one takes a current value so the current value won't be the current field of view then the b this is going to be the final one so let's use the target as the target field of view and finally t so time dot dot the time and this is probably way too slow so you float for the zoom speed define it as something and we just multiply so that works that applies the smoothing and we just want it to the final field of view okay so let's test and see if it's nice and smooth so here if i scroll yep there you go nice and smooth going back and back all right great so i can zoom in and out in any way i want all right so here the field of view zoom is working now like i said this is just one of the methods the other one would be to leave the field of view exactly as it is and just move the camera closer so let's handle that second method but let's also keep this one let's rename this function to handle camera zoom this is the field of view method now let's make another one so private void handle camera zoom and for this one let's call it the move forward method okay so now let's go up into our update and over here instead of calling that one let's try out this second method so here we're going to leave the field of view on loan we're not going to touch that one instead what we're going to modify is the follow offset and again we're going to need to use that method because if we try accessing this again and we access the phone nope we just see the follow target we don't see default offset so again we need to look into the package source code to figure out what to change and if you look here into the syn machine virtual camera component on this grip if we look around we can see that the waste and machine works is apparently by some kind of cine machine component base so this system is set up in a way to allow for multiple components we can see we have a function to get all of these machine components and we got another one to get a specifics in machine component and then if we look in the project window under the packages under syn machine under runtime and then components if you look here we can see various interesting class names and if we open one of them we can actually see that the extends in machine component base so these are all of the various components that can be attached to the scene machine virtual camera and if you compare these names with the ones on the virtual camera so over here for example on the body if you scroll you can see we've got do nothing which means no component then we've got third person follow framing transposer regular transposon and so on and if in the scripts yep the same thing third person follow a composer framing transposer and so on so we can see that the body field here is essentially an instance of one of these components so in this case we're using the transposer type so let's open up the syn machine transposer script and over on this one if now we search for follow offset here it is we do find this only field m follow offset and you can see it even defaults to vector3.back times 10 meaning it's going to be pulled back minus in the zen so that's exactly what we saw happen so we know this is the one that we want to use so this is what we need to modify let's go back into our regular script and up here let's first get the same machine version on camera then we need to get a syn machine component of that type so let's use that function to get a syn machine component then for the type let's use the syn machine transposer and then from this one now we can modify the m follow offset here it is this one again let's do a quick test so let's set this to some random value so maybe this 10 minus 10 and once again let's do this on a scroll okay so let's just test and see if the offset changes so here we are and if i scroll any of there go it does indeed change all right great so this is working we just need to add some external logic so we're going to need to change it based on the scroll wheel and then at the end we actually apply the changes and we're going to want it to be smooth as well so let's go up here and do the same thing that we did so private this is a vector 3 for the fall offset okay then with this one down here let's do the same thing so on one of these we're going to move forward on the other one move it back now the question is how do we move it forward for this one we wanted to zoom straight in so we're going to need to calculate a vector 3 for the zoom here and now the way that we calculate this one of the simple ways that we can do is we can just say the current offset so let's set this to the following offset now we just want the direction so we normalize this so with this we have the same direction which will go either forward or backwards so then we can just increase the default offset let's increase it by zoom there and on the other one let's decrease it so minus equals this is on under zero then we need to do a quick test for the minimum and maximum so for that let's go up here let's define another private float for the follow offset min another one for default offset max then we can default this to some values maybe five f and maybe 50 f okay now we can compare those by checking the formula offset check the magnitude so we just do if the magnitude is under the fall offset min if so then we want to set it to some minimum so let's set the font offset equals the zoom direction which again is a normalized value multiplied by the fall offset min okay so this gives us a minimum and then the opposite for the maximum so if it goes past the fall offset max then we set this one so we have this now we just need to make sure that we start off fall offset with something so we can actually start off to the one that it has by default so up here let's make a private void let's make an awake then wait just set the final offset and grab the current one okay so then down here we just need to apply this small offset now the issue of course that this is instant we need to apply some smoothing so let's do the same thing that we did except this time we're working with a vector three so let's use vector three downward and all logic is exactly the same so let's grab the current offset then the target fall offset which is our final offset and finally time time dot delta time and of course you need to multiply it so you float for the zoom speed so we have our alert and then we just assign it so like this okay so let's test so here we are and if i move the scroll wheel if there you go and i zoom in and if i go to the maximum yup can't go further and i zoom out any of them out all right great so it's zooming a bit way too little but logic does work except it's also reverse so let's fix that so here just swap these out so this one is a minus and this one is a plus then for the amount float for the zoom amount let's put it at maybe three f and then the zoom direction we just multiply by this zoom amount okay let's test so here we are and if i zoom in if there you go zoom in and zoom out all right awesome so everything is looking really nice so i can move the camera i can rotate around and here we've got the second zoom method okay so with that done let's actually quickly check out the third zoom method now instead of zooming directly onto the position so this is a direct zoom instead of doing that let's just lower the camera closer to the ground so let's make another zoom method so let's make another function so hand on the camera zoom let's call this the lower y we're going to lower the phono offset on the y and logic here is actually going to be pretty similar to this one so let's copy this except for this one instead of moving according to the zoom direction instead of that what we're going to want to move is the fall offset but only on the y so only on the y that's the only one we want to modify so this one just lower it or increase it by the zoom amount then instead of checking for the magnitude we can just check for the fall offset y so the y equals math.clamp let's clamp the y between a certain minimum and maximum so let's define those up here so let's define the min y let's put it at maybe 10 and then the max y let's put it maybe 50. okay so we've got these two and now down here based on the min y and the max y okay so we clamp that value and then we do the exact same thing so we still use default offset and we did that all right so now let's use this method instead of the other one so over here on our update let's use this method instead of this one okay that's it super simple let's test okay so here we are and if i try zooming in yep there you go now it does this so instead of pushing forward it pretty much just gets the camera closer to the ground so personally i really like this method since it lets you look at objects from a different angle so the other one you always have this view and just getting in closer or further away whereas with this one we can zoom in get a different view of all of our map so personally i really like this method since it gives you a different view but either way here you have three zoom methods so choose whichever one you prefer and with that here is our complete camera system we can move with the keys in the keyboard alternatively we can also move the camera by moving to the edges so we've got edge scrolling enabled yet another method is by clicking and dragging the mouse so we can place the camera anywhere we want and again especially for this method you can easily change this to make it work with the new input system so making this work with touch input would be super simple and then we can also rotate the camera so i can look at anything from any angle and finally i can zoom in using any of three unique methods and over here is the 2d version with all the same features the logic is mostly the same the virtual camera is set up in 2d as is the camera the funnel target is the same and for the zoom there's only one method just changing the camera's orthographic size so that's it and here it is this same system working great in 2d alright so here is a fully featured fully working camera system this is perfect for any game where you want to give the player control over the camera there's a link description to download the project phone so go ahead and use this in your next project there's also a link there for this really awesome asset pack if you want to get it and if you found this video helpful check out my complete courses alright hope that's useful check out these videos to learn some more thanks to these awesome patreon supporters for making these videos possible thank you for watching and i'll see you next time you