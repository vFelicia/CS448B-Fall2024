in this video we're going to look at how to use the new unity dots physics we're going to check out the various samples and then experiment with all the physics components do some ray casts and play with events let's begin hello and welcome I'm your code monkey and this channel is all about helping you learn how to make your own games with NF tutorials made by a professional indie game developer so if you find the video helpful consider subscribing so unity dots if you're not familiar with it stands for the data oriented technology stack it's composed of the entity component system the job system and the burst compiler essentially it promises epic performance several orders of magnitude better than working with game objects for more detailed explanation of dots and ECS check the links in the description here we're going to look at the implementation of physics in dots so in this scene here I have the unity physics package installed as well as the entities package now let's first look at these samples and then we'll play around with the physics ourselves these samples are located in this github repo there's a link in the description so check it out here I have downloaded and open the project so over here you have a whole bunch of demos covering all sorts of physics interactions for example here the most basic demo is just hello world made with physics objects so as we were in the game there you go the in letters fall down and then we can pick them up and drag them around there you go we have a bunch of physics interactions and if we pause the game and look at the hierarchy there you go we have no objects in here however if we go into our window analysis and into our entity debugger here we can see all the various letters and here in the inspector you can see all of the dots physics components so in this case we have the collider we have some mass velocity and damping so as you can see you can inspect all of these demos to see how they work and for example over here on the last one we have one of the most complex ones here it is we have some cars and a bunch of objects so we're here you can see a bunch of physics interactions so we have a car none of them working with physics on the wheels then you can see the antennas which look very springy over here on this car you can see the joints and hinges on the doors and you can also see the box thing inside so as I move and I stop and there you go and again all of this is using the dots physics package so go ahead and get samples and then inspect all the various demos and all of the code is here for you to learn for this video is made possible thanks to these awesome supporters go to patreon.com/scishow to code monkey to get and perks and help keep the videos free for everyone okay so now that we've looked at samples let's play around with it here we are in an empty scene now we want to make a very simple test let's make your ball bounce up and down now there are two ways we can do this we can do it using normal rigid bodies and colliders with the conversion workflow or we can use the dots physics components directly let's first use normal rigid bodies so we do exam like we've always done so over here we create a new cube so let's stretch it out to make it our floor okay so over here we have our four and as you can see we're using a regular box from other component now all we need to add is the convert to entity script and that's pretty much it now this object won't live as a Collider in the dot physics world now let's make the ball so over here we create a new 3d object let's make it a sphere and again it already contains a sphere Collider now in order to make it fall down what we need to do is that a regular rigidbody component make sure that gravity is enabled so it falls down and again all we need to do is have D convert to entity script all right so that's pretty much it we set it up exactly the same way as we did with normal and game objects the only difference is we have the convert 20 script let's test any of their yo our sphere film down so here we don't everything exactly the same as we've always done with the usual components and just by adding the convert to entity script all the things get converted into dots physics entities so we can pause and look and yep we don't have anything on our game scene and we have our entities over here in the entity debugger okay so now let's use the dots physics components directly so let's duplicate this and put it on the side now over here on this one let's remove the box Collider component and inside let's add a component over here we sound like dots go into dots physics and in this case and let's select a physics shape now this component essentially merges some of the various colliders so you have a single shaped component type and over here you select the actual shape so in this case we want to be a box okay and again make sure you have the convert to entity component and that's it now for the bomb let's duplicate our sphere put it on the side and again get rid of the sphere come either as well as the rigidbody and now let's add a new component go into dots physics and first we add the physics shape in this case we want a sphere there you can see the gizmo okay and then let's also add a dots physics in this case let's add a physics body so this is the equivalent for the rigidbody and as you can see it looks pretty much the same and again make sure that it has he converted to entity script okay so that's it for our set up over here we have normal components and over here using the dots physics components directly let's test and yep both objects film down with gravity we have one working with normal components and the conversion workflow and we're working directly with the dots physics components awesome now let's make them bounce over here on the dots physics object in the physics shape you can see a field for the restitution so if we set it to one and keep the maximum then this object will not lose any energy so let's try two one and test and yep there's our ball and bouncing up and down now over here on the normal object on the sphere Collider we also have a space for a physics material so let's create a new physics material let's call it bouncy and over here we just set the bounciness to one and combine with the maximum and then we simply drag our bouncy in there all right let's see any of their here we have both spheres jumping up and down so one is using normal components and when using dots physics components awesome now since we were working with dots physics that means we're working with the entity component system world so again you can see that we're not using game objects and over here on the entity debugger we can see all of our various entities and you can see that both the one that we created with the dots physics components and the one that we created within normal physics components both of them have the exact same ECS components so this is the conversion workflow in action now you can find all the physics components in the package manual as it says in there we have all these components that are added depending on if they are needed or not so if a body does not move like the floor it does not have the physics velocity component so we're here if I sum like the cube there you go you can look in here and you can see that it has a physical editor and nothing else but if we still like the sphere and there you go you can see that it has a physical either mass velocity and damping this is another way that we can keep our code nice and performance since it will only have exactly the components that it needs and no more all right now let's write some code to interact with it over here let's make a new csharp script call this our ball jump system now in here let's get rid of the normal amount of behavior things instead we're going to be using unity dot entities now we're going to make this a component system alright now here let's do a simple entities dot for each cycle and let's second through all the entities with a physics velocity component alright so here we can modify the physics velocity so for example let's do a simple input when we press on the spacebar let's try to move it up so for that we're going to modify the physics velocity modify the linear and set in linear Y to a certain amount all right so that's it let's test ok so here we have our bouncing ball and by pressing space and there you go it does jump up so every time we press space we are interacting with dots physics so all we need to do is modify a specific that's physics component and everything works great so again check out the manual to see all of the other physics components and you can interact with them the same way you do with any other component type alright so now let's check out a simple ray cast over here let's make a new csharp script call this our test ray cast okay here's our script now first let's add the namespaces that we're going to need so first of all we need unity dot entities then we also need to be using unity that mathematics and finally using unity dot physics okay now right now we have to make our own ray cast function but I'm guessing in the future there won't be some sort of utilities class so we're hearing let's make it so we okay simple private void our recast now a recast will have a full 3/4 hour from position and another four three four the tube position so we're going to do a recast from and to now inside first we need to get our current physics world system so let's go into our world into our default world and we get an existing system we get it of type unity physics systems and get our build physics world now inside the build physics world we can access the actual physical world and then the collision world ok and now we can use our collision world and use the function cast break now for here as you can see we will require a ray cast input and it outputs a ray cast hit so first ray casts it is very simple so we make a new rake asset and again here pay attention we are using the array cast head inside unity dot physics and not the one inside unity engine so this will be our second parameter and now for the first one we need a ray cast input so let's create our ray cast input and now it's in here that we have the from in two positions so the start will be our from position the end won't be our two position and then finally we can add a filter now a filter is essentially the layers so here in the filter we have three fields first of all it belongs to and we're going to say that this rate belongs to own layers so in here we're essentially going to negate a zero if you're not familiar with the tilde character this is a bit operation not so we're doing not zero which means we end up with all the bits at the one I've made a video covering collisions layer masks and bitwise operators so check that out to learn more so here we're saying that this rake has belongs to all the layers and we wanted to collide with all the layers and finally group index which is just another way of filtering collisions by overriding the bit masks so for now let's leave it at zero alright so here we have all the information inside of our recaps input essentially we just have the from into so we use this in our function so we've passing the array cast input and then out for our ray cast hit and this one as you can see it returns a boolean so it returns true if we hit something and false if not so if so here we know that we hit something and now we can actually get the entity that we hit so we can access the array Cassatt and inside we have the rigidbody index field so here as you can see this field is an int so this is the index of our rigidbody and now we can access the entity that refers to this rigid body by using our built physics world to access our physics world then we access the bodies which as you can see is the native slice of rigidbody and we use this as our index so with this we have a rigidbody and then we can access the entity alright so this is the entity that we hit without raycast and now let's simply modify this one to return an entity and then we return this and if you do not hit anything then return entities got no okay so here we have our ray cast function we wherever from in the two we do a cast ray and we get our head entity all right so now let's test this out let's use a simple normal update all right so here we have some very basic code we do an if input get mouse button down on the in left mouse button so when we click we use the camera to create a normal screen point array and then we use our recast function pass in the array origin and then Direction times a certain amount so let's check to log and see if we can click to grab an entity okay so here we are there's our bouncing ball in our console now if I click on nowhere and there you go we have entity no now if I click on top of the four and there you go we had our entity click on top of the ball and there you go we have the other entity so over here we have a rick has correctly grabbing what we click on now over here the function that we made is only grabbing the closest hit but as you can see we have another one which takes a native list and returns all hits so if you want more than the closest that's what you would use and again here it is click on nowhere click on the ball and click on the floor alright awesome so here our simple ray cast function is working correctly however we're interacting with our ray cast directly very much from csharp now in order to get the maximum performance we should do our ray cast from a burst compile job so check the manual to see one implementation of a ray cast Q alright next let's check out triggers and events now to make a trigger let's first make a simple box so we're here for example let's duplicate this one put it a bit higher okay so over here we have the normal floor and then this second box let's call this our trigger and now in here on the physics shape just like we have a normal compiler over here we have is trigger so we simply click this and set it to true alright so that's pretty much it now we want to make it so that when the ball touches the trigger we're going to make it automatically jump up all right so let's make our script let's make it something and call it test triggers now the way that we handle our triggers is with a job so first let's make this a job component system okay now here we make our simple job in order to work with triggers we need to implement I trigger events job so this is the interface that we need to implement so we have our execute function which takes a trigger event object and we can inspect this and over here you can see that we have our entity pair Collider and body index and inside the entity pair we just have an entity a and B so this is a trigger between two objects interacting okay so now here when we get a trigger event let's push the entity up like we did when pressing space now the way we modify components from the entities involved in this trigger is we need to have a component data from entity of type physics velocity and then here first we check if has a component using our trigger event that entities dot entity a so if the entity a has a physics velocity component then we want to modify it and jump it up okay so if that one has a physics velocity we jump it up and let's do the same thing in case its entity B all right so just like this when we have a trigger interaction we're going to move up the entity that contains a velocity component so in our demo since we only have bound and only the ball will be moving up and then here we can also use first compile into our job alright so now to schedule it down here let's first make our trigger job and we need to set the physics velocity entities so we do is get component data from entity applied physics policy so then we're going to return our trigger job we're going to schedule it and now in order to schedule it we need the simulation and the physics world so for that let's also implement we also implement the uncreated function and here we can go into the world and we get or create our system up typed built physics world which as is how previously this is inside using unity about physics dot systems so with our built physics world we can use the second parameter which is our physics world then the third one is normal input dependencies and now for the first one it's a simulation and the simulation we get the step physics world and we use the step physics for on that simulation alright so here we have everything necessary we instantiate our new jump we pass in the components that we're going to need so we access those and if the entity has a component of type physics velocity then we're going to move it up and then we simply schedule and run our job all right so let's test any of there you go there's the ball as soon as it touches the trigger it starts going up so there you it's not touching down here at all so we can pause and over here use our camera and there you go yep the ball as soon as it touches the trigger it goes up it no longer to touch to the four so just like this we have implemented our simple triggers so only takes essentially making a job which implements I trigger your venn jobs then in here you can use the trigger event to access the entities involved in that interaction and do whatever you want to them now over here on the physics sample project you can go into setup and over here you have events and then for example let's open the portals there you go it's this scene so let's play it out any up over here you can see a different scenario so the bones come in they hit and they get teleported and moved around none of it is working using triggers another demo is here which essentially it has two triggers that are inverting the gravity and here in the code you can see a more robust implementation of the triggers so you have a job still implementing I trigger events job then you grab the entity a and B you try to see if they have the component that you're trying to modify so we're here it's ignoring triggers overlapping other triggers then also ignoring overlapping static bodies and then now I'm here doing all the modifications so just like this we have our triggers working now one more thing you may have heard about is the collaboration with havoc so essentially you have two possible physics engines you have unity physics and have up physics now in terms making your game there is no difference they both use the exact same components so in order to change them you literally just have a dropdown menu so here on the same there's already game object that contains a physics step component and using it over here you have the simulation type so it's currently set to unity physics and it's in here that you can set to have up physics so you just set that make sure you have the package and so on and everything works exactly the same so from a content creation standpoint there's nothing actually you need to do both physics engines are great and they have different design philosophy is related speed accuracy and state or staples the main difference is unity physics is free whereas havoc is paid for however right now there's a free trailer so you can play around with it here in the physics app you can also see for example you can modify the gravity so instead of having it pull down at 9.8 1 units let's pull it up and there you go just like that all of a sudden everything is floating now there's still a lot more to physics like joints hinges Collider casts and a lot more I want to keep this video as a simple beginner introduction so I don't leave it here for now but I won't be covering unity that's physics more in the future so let me know specifically what you don't like to see regarding dots physics if you want to explore it for yourself then check out the physics package manual along with these samples included this video is made possible thanks to these awesome supporters go to patreon.com/scishow natee code monkey to get some perks and help keep the videos free for everyone as always expand with the project fountain utilities from unity code monkey comm subscribe to the channel for more unity tutorials post any question having comes and i'll see you next time