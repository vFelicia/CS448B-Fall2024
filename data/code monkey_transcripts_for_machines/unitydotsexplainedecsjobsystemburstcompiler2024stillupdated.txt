in this video we're going to cover unities new data oriented technology stack we're going to go over what it is how it works and what are the benefits let's begin so first of all dot stands for data oriented technology stack this is sort of a different way of writing code and thinking of how to set up object logic and that the main goal of this new paradigm is to have performance by the phone meaning if you learn how to set up your game this way you will write cleaner code and experience excellent multithreaded performance which enables you to make more complex games with more units more effects better visuals and so on the technology stack is composed of three main components the csharp job system the entity component system and the versed compound first the csharp job system enables you to take advantage of multicore processors in order to run several jobs at the same time one of the main issues with Unity performance has always been due to how the main update thread is single threaded so for example if you have path winding for your units in single thread code first you calculate the path for the first unit then when that's done you count only de path for the second unit and so on whereas with multithreaded code you can calculate many paths at the same time depending on the number of course so if you have a lot of small independent tasks running in your game you can massively increase your performance writing in csharp multithreaded code is always very tricky since there are many things that can go wrong in seemingly random ways that can be a nightmare to test and debug writing multithreaded code also means you need to manage how many threads you have how many you should have and what each of them is doing so the csharp Java system manages all that and helps you write simpler code by having you create jobs instead of threats then those jobs are run on the threads and the whole thing is managed by the csharp job system this is designed to make it easier to write multithreaded code while reducing complexity and providing several protections from the biggest issues caused by multithreading like conditions so if you learned to write code that can be Java fide you can benefit from massively improved performance then the entity component system this is the part that requires a different mindset when writing code it's all about separating your code between logic and that instead of game objects with monobehaviour scripts you have entities components and systems so you have an entity that entity contains components which hold the data and these systems apply logic to that data for example you have an entity named unit that entity has a component composition which holds a x and y value then you have a system called move position which runs on every entity that has a position component and moves its x and y values under the hood what makes it so much more performant has to do with how memory is set up for a CPU it's quite expensive to be constantly jumping around in memory in the normal way working with game objects those objects are very heavy and they are located somewhere random in memory then each component can be in another place and so on so as the update thread is running the CPU is jumping all over the place looking for the memory it needs whereas with the entity component system the memory gets much more packed together in specific groups of components which boosts performance significantly since the CPU no longer has to jump around in memory in order to find the next object it needs so again with regards to code the main thing you need to understand is how it should be organized you have entities components and systems components home data systems process that data and entities refer to individual instances of component data so you can think about it how it relates the normal game object system an entity is like a specific game object so if you have two game objects in your scene each of them would be an entity components are held by entities and have the data so just like in the normal way you have components attached to each game object in this case you have components attached to each entity and finally the main difference is these systems which act upon the component data in the normal way your model behavior scripts hold in variables and also have functions to modify that data in ECS they are cleanly separated an entity refers to a specific instance of components the components home data and these systems modify that data following the easiest pattern also makes it easier to write code that can be Java fide by the job system which again excellent performance and finally the last dot component is the burst compiler which is a piece of really amazing almost magical technology it takes all that nice csharp code you write and converts it into highly optimized machine code it's especially good at making optimized code from the code generated by the csharp job system the compiler is also smart enough to take advantage of specific optimizations for the specific platform you're compiling for so for you all it takes is ticking a box to use it and benefit from massive performance the better you write your code according to e CS and each app system the better the performance boost these are the three components that make up the dots data oriented technology stack so to summarize you write your code according to the entity component system then that code can be Java fide to run in multiple threads managed by the csharp job system and then the burst compiler converts to csharp jobs into highly optimized machine code all of that makes up the data oriented tech stack or dots so I hope this video helped you understand what that is and how it works it requires a slight change in thinking but the potential benefits are immense I'm currently working on an e CS tutorial so stay tuned for more practical videos on this exciting new technology if you liked the video subscribe to the channel for more unity content alright see you next time