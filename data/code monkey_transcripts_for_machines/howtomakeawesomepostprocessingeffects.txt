in this video we're going to look at how we can make some custom postprocessing effects in unity we're going to make a shader using shader graph and create a customer in their path to use it let's begin hello and welcome I'm your code monkey and this channel is all about helping you will learn how to make your own games with enough tutorials made by a professional indie game developer so if you find the video helpful consider to subscribe check out the code monkey app on Steam interactive tutorials complete games and more click knowing the description and add it to your wishlist ok so here we're going to add some custom postprocessing effects this is usable in a GRP or a u RP or really any custom srp since it is based upon extending custom render passes and all the effects are made in cheetah graph so it's really easy to make your own custom effects alright so here is my normal scene just a player in a random level and I can walk around alright and now let's see and yep I've enabled a simple black and white filter so the carrot and bush I don't know component black and white so I made a custom shader and where I often appointed as a postprocessing effect and now here it is a simple basic tent now with a foam blur a pixelated effect and finally here is a really awesome 2 song shader effect so this would be a really good really easy effect to add to make some really cool transitions alright so this is what we want to make now I've covered a bunch of these shader facts previously so check the link in the description to see the playlist of those effects can easily be applied as postprocessing effects this video is made possible thanks to these awesome supporters go to patreon.com/scishow to code monkey to get some perks and help keep the videos free for everyone alright so this our goal let's get to it ok so here we are in our scene I just have my character and I can move around just like that now to make our custom postprocessing effects it's actually a pretty simple process although finding the answer that takes some digging so if you're looking for the answer like I was then hopefully this video won't help what we need is a way to run some shader code on our image during the postprocessing stage now if you're watching this video many months in the future then it's possible that you RP was updated with an efficient way to do custom postprocessing using the volume system right now that is not possible so here we're going to use a custom render pass if you want to learn more about how to work with the universal render pipeline then check the link in the description for the official examples there's a lot of really cool demos including one which does exactly what we're going to do in here okay so let's do it now as I said we're going to create a custom render pass so to do that we're going to select our universal render pipeline asset and here you can see the various renders that are assigned to it and right now we're using the default forward render so here it is we can select it and see yep there's nothing different it's the default and then in here we can click on the pulse in order to add a render pass and by default we just have this one so it's in here that we're going to add our custom render pass so in the project files and let's create go into rendering Universal render and in here let's create a render feature let's call this our lit render pass feature and now just like this if we select our for render data again and click on the pause yep there we have our customer in their pass feature alright so there it is now let's open up the script and in here we have the default file which already has some very helpful comments here we have a class that extends the script upon render pass so by default it has a configure method which sets up the render pass then the execute which runs whatever render logic we want and finally the cleanup at yet so this is the render pass and then we have this other class which extends the scriptable regular feature and this one is what sets up and in queues our render pass now this system is extremely extensible you can do pretty much anything in here and go as crazy as you want but for our purposes we just want really the simplest method possible so here by default we have the render pass event this is where in the rendering process our pass will be injected into so in our case and let's set it to just before the post processing now all we want is to take an image from the camera and apply a shader onto it so the way we do that is again we go into the execute function and in here we're going to simply call the blitt function so this function takes a source and applies a material with a shader and place a result in the destination so we're going to need a command buffer the source destination and the material with our shader now for the command buffer we can simply go on up here we go into the command buffer pool and we get the new command buffer okay so we use this one in here next we need a source now the source will be the convert texture from the camera so we can actually grab it down here when we have a reference to our script on render we can access the renderer to grab the camera convert target so this is what we need to pass on to our custom render pass so for that let's simply make a basic public field and down here we simply pass it so we go into our script upon render pass and you pass our source okay so now on our boot command we can use our source then the destination will also be our source and now finally we need our material so here in our render feature let's make a class to hold all of our settings so just like that just basic class with our material and now we need to remember to add the attribute systems here and I suppose so that our class shows up in the editor and now let's just make a public field at this time so there's our public field and now if we go back into the editor in here with our custom renderer selected we can see yep indeed we do have some settings and we do have a film for our material all right so let's make the material that we're going to use we create a new material let's call this the tent postprocessing and here and let's select a very simple shader so just a simple 10 shader we're going to inspect the shader and make a custom one in a bit so here we have our material and just select it and assign it ok now back in the code here we have this material field and we just need to pass it on to our render pass so I make a constructor then we'll receive it so you receive the material we're going to pass it in in here from these settings passing the material on to the render pass and the render pass we use the material in here on our plate now we have our material all right so we're almost there we have our command buffer and we're doing a plate now finally we tell it to execute this command buffer so we go into the context and call execute command buffer that's in our command buffer and finally that releases from the poem so we go to the pool and come release on our command buffer alright so that's pretty much it now if we go back into the editor and nope nothing has changed yet so the issue here is we cannot directly copy from into the source so we need to have a temporary texture in the middle so let's do just that in here let's create a new render texture then we initialize it here on the constructor we just give it a random name and now down here let's get a temporary rendered texture so go into the command buffer to get a temporary render texture let's pass in this ID and we wanted to match our current rendering data all right so now we have our temporary render texture now we're going to copy from the source onto that render texture and then after doing that then we copy from temporary onto the source all right just like that so we're doing this because we cannot directly copy from into the same thing so we need to use a temporary one in the middle of our process all right so now it should work and back into the editor and yep it immediately works so we have our custom post processing in fact being applied awesome now here one very important thing if you're making your own effects and need to debug to see what's going on then you can use the frame debugger so you go up here onto the window then analysis and in here you have the frame debugger this is a really useful tool so just hit on enable and now here we can view exactly what the renderer is doing and in what order now to find out which one of these is our custom pass we can actually go back into our code and in here when we are getting a new command buffer we can actually give it a name let's name it our custom lit render pass and now if we go back into the frame debugger if we go down here yep we can see our custom plate render pass so you can see how just before it yep there's no postprocessing effect applied and then afterwards yep we apply it so here on the first pass we can see that we are grabbing the convert texture and we are placing it on our temporary convert texture and then we have the second draw which takes from the temporary car texture and place it back onto our source camera counter texture so if you have issues with your effects then the frame debugger is a very useful tool alright so now that everything is set up we can finally easily make our custom effects so let's first inspect how the attend shader works and you here we are in our shader graph now for the output right now it is a simple sprite again if you're watching this many months in the future there may be a more dedicated master node for actual custom postprocessing effects but for now we use this one and then we really just take a tan color and apply a tint on to our main texture so the color texture that comes from the camera gets inputted onto the reference underscore main text now I've already done a bunch of effects in shader graph there's a playlist linked in the description so check it out all those can be applied as postprocessing effects so here we have our tint effect and by modifying the material we can modify our actual effect yep just like that and now in the material just swap out the shader for a different one now here is a pixelated shader and yep everything is extremely pixelated now here we have a very nice the song shader and looks really interesting so this one would be great for some kind of transition effects and here we have our board shader so yup here it is our postprocessing in fact it looks great so you can see how you can make whatever effects you want using the super useful graph and apply it as a postprocessing effect like I said this system is extremely extensible and customizable for example if you sound like your camera in here you can actually see which render you're using so for example let's make another custom Ford renderer okay so I made a different for render and applied it with a different material and now here if we select the pipeline asset we can add the other renderer and now on the camera here we get some light to drop down and yep now let's say we sound like the blur and there you go everything is similar it's like this one and everything is tinted so we could easily modify this through a script to get some really awesome effects so like I said extremely customizable alright so now that you have this knowledge go ahead and make some awesome effects check out the code monkey upon Steam interactive tutorials complete games and more click knowing the description and add it to your wish list this video is made possible thanks to these awesome supporters go to patreon.com/scishow natee code monkey to get some perks and help keep the videos free for everyone as always you can download the project files in Antonis from in Tacoma com subscribe to channel for more unity tutorials post a new question comes and I'll see you next time