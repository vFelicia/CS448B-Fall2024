In this video, I'll show you how to create two new routes in our Vapor API to update and delete data in our database. We will then call those two routes from the Swift UI iOS app. Let's get started. We are going to make the update and delete route routes. So let's first make a new function function. We will have a request that throws like the rest of them. We'll make a function called update, and it looks similar to the rest of them, and it will return an event loop future and it will return an Http status similar to the request. So if it works will return. Okay. Otherwise it will return some kind of error. The first thing we do when we get an update, we are going to be sending data over from the iOS app from postman about the song that we are updating. So we have to first decode the song similar to how we do it with the post request. So I'll just copy this because it's the same. And then I'll also add a comment. So this is what the route is going to look like. It will be a put request because that is what it looks like when we do an update, that's the request type and what we do when we do an update is we first look to see can we find the song that we are going to update? And then we will update the data itself. What we do here is we first query to find the song. So can we find the song that we give it from postman or from our iOS app? And so we look for the song based on its ID. And if we cannot find it, we will then row abort not found, which is a 404 error and unwrap. So it's unwrap or meaning. Can we unwrap this value because this returns an optional. If we look at find. If we click command, click on that and then click quick help. We see it returns an optional. So if we cannot unwrap this so unwrap or we can't, we will return four or four not found. But if we can, we continue and we will flat map this. So the first thing we do is take the value and basically set because there's like a pretend value here. We set the value of the title property equal to our new song title. So that is the song here. And then what we do is we return the instance of updating it. So we take this new song and update it on the database. And this update function really is kind of just like saving it. So if we command click on that, that doesn't give us any useful information. But really what we're doing is updating the value within the database for this one song, and if that all works out, okay, we transform it to okay. And then let's write the delete function as well. So this is our delete. And actually I messed up the comma up here. It won't be slashsongsomething. It'll just be the slashsongswell. And then this is what this route will look like. So for delete, it will be a delete kind of request. And we'll see that in post man in a minute and the route will look likesongid. And that's that UUID that we have for our song model. So what we do with the delete function is we first use our song model, and we're using fluent to do this finding and basically querying our database. So we do find and then we get the request parameters and we called it song ID. So that's what this part will look like. So it'll besongs. And then that long ID number from our database. We find it in this database. And then again, we unwrap the value if we have it. Otherwise we're going to throw a four or four. And what we do is a flat map, and we dot delete for this database, and we're deleting that song from the database. And then this is again a fluent function because we're using our song fluent model. And if everything goes well with that, we go ahead and transform it to. Okay, so let's go ahead and run this. But first we have to make sure the database is running. So I'll use the Docker desktop application rather than the terminal. So that was my testing one. Here is our actual API that's running. And then that is the database. So let's go ahead and just click run or start. And then this is now starting up this container and we can click on this row to see the terminal information as if we ran it from the terminal down here and it says it's starting and we can check if this is working using Azure Data Studio. Let's go ahead and open that. So we have Azure Data Studio. We're on the welcome page because we've already connected to this database. We can see it in the connections over here. But if we go and just double click on it, it brings up that list as if we were connecting to a new server. But we have all the information here because it saves it. I didn't check remember password, so it doesn't have it Typed, doesn't have it auto filled in here. But if I go ahead and type it and click on connect. So now we have a green dot here, meaning we're actually connected to it, and we should see something. There we go. Took forever to load. Okay, so we have a green dot. So we're connected and I double clicked on this. Usually it shows a list down here. I think mine still might be Loading, but we can go ahead and still click on the Songs table and click Select Top 1000, but we know because we can connect to the database. We know it's already up and running with Docker. Otherwise we wouldn't have been able to connect at all. So we see our two songs that we have in here. Let's go ahead and now run our API. So we just go ahead and click the run button within Xcode, and we will need to grab Postman as well to make our request. This build failed because we did not call the function because you have to call the function to be able to use the function. So we added our two routes update and delete down here. But what we didn't do up at the top is actually put them in our boot function so that we can use them. So there's another operation called Songs put, and this is using our routesongs. So it groups that route right here and then we have get and posts. But we also need to add the put, and then lastly, with the update, it looks a little different. There we go. Okay. I think those probably should be syntax highlighted, but my computer just doesn't know how to do that, but we have our songstock group, and we are grouping anything that has this ID on it, and we're going to call the delete function. So what that is it will look like Songid. And then this is what that song ID is so that the string is the same between these two and what it looks like when we actually use it within postman it'll look something like this is we have our URL, the route songs, and then this is the idea that's in our database. So that is finally calling our two functions. So we are calling to use Song delete, and we want to use our delete function that we have down there. And then when we do a put request, we use the update function right here. So we should be able to run this now and that should go away. We still failed. Oh, I spelled parameters wrong. Okay, now let's run it again. This dialog comes up, click on. Okay, and our server is starting. So that is good. So let's test our update function first. So I have all these tabs because I've been adding them and trying everything out. But we go ahead and you can click on a new tab or just use the one that you've been using. So we need to change our request type from Get or post and change it to Put because we're doing an update. So we have our URL right here. We have our songs route, and then we click on the body properties, and we want to change this to Raw and then change the type to JSON. So we type out our JSON model, which is just the title and the ID. So let's update one of these values, so we will need the ID and we'll need the title that we want to change it to. So if we click on this row and just click command C for copy and we fill that in right here for the ID property. And then right now it says year 3000, but we can change it to anything else. So let's change this from year 3000 and 2021, which is almost over. So let's change it to your 2022. So that's in the future or if you're watching this in the future, it's now in the past. So if we change this, let's go ahead and send our request. Okay. We sent our request and it gives us back status 200. Okay, so that's good. That means we did the right thing and everything worked, because right here we tell it to transform everything to okay, if everything else was good and we can confirm that this worked by going down to Azure Data Studio. So we click on Run and we see our data down here for this ID. We change the title to year 2022 instead of being year 3000. So we know our update function worked. So now let's test our delete function. So we go back to Postman and I have a new tab called Delete, but all this is doing is really just changing the type to delete. But for this one, we do not need a body property. So if you're using the same one, go ahead and select none here or just make a new tab and it resets sort of everything. So this is an old ID I was using. But let's go ahead and use one of these ID. So let's say we don't want your 2022 anymore. So copy the ID, go back into Postman and just paste it into this URL and let's hit send. We got back 200. Okay, so that's good. And we see in Vapor, there was our Put request, and here is our delete, and we know how we coded it. If we got back 200, that means everything was good and it was able to delete that. So let's go back to our Vapor database. Click on Run again. The only song that's left in our database is the Money song, and the year 2022 is now completely gone. So that part works. We have our API done. So we have our two new requests for update and delete. And then we have verified that using Postman and Azure Data Studio to check everything is working. Now let's go and write this functionality in the iOS app. Let's make the iOS app. So first we want to update a song. So to do that, let's first run the project to see what it looks like. And we don't have anything because we need to start in Grok, and that's not from our iOS app. That is from the API side, so we can run in another tab or I'll just open it into a different window. Over here. We are running the API on the left and we need to run in Grok, which I run from the downloads folder. So CD just goes back to our root directory and then I want to go to downloads inside of here. We have ingrock, so I do ingrock 80 80, which starts up in grocery, and we need to take this URL. Copy that and put it into our constants file. Okay, let's paste this here because we're still committing this. It looks like we're changing it, which is fine, but we need that URL there, and we need to stop this from running and run it again. We should see our two values that we saw that we saved earlier. I ran the project, but I forgot to add a slash onto it because you can see the URL right here. There's no slash before we have the slashsongs route. So I need to stop this and run it again. We ran our project. We can see we do one get request and it turns back a 200 and we see it in action. Our terminal over here so we know we are reading something, but when we want to update a song, we had add or update song view. And this is presented. If we look at our song list here, this is presented when we tap on it. So actually right now it'll just say selected. So if we go and just click tap on money, it just says selected, which is not what we want. Now we want to show this and update it, but we want to show not the add modal. We want to show the update modal. We did a lot of that set up in the last video, so let's change this. We want to change the modal property from add moduleequals update, and this will change this property that our sheet is viewing here. This was on dismiss it's right here. We do a switch. If it is update, we present the add updatesong view and we give it the current song. So let's go and run this and see if our view pops up. I think that's what autocomplete is telling me modal needs a song. So we see the song right here because we have to tell the next modal that's going to come up what song we want to update. And then that is this song for whichever one is actually selected. We run this and we see in the simulator. If we tap on money, we see almost everything is working. It fills in the word money, and we have updatesong here and we see it says update rather than saying add because it's presenting the right type of modal for which like state that we want to use. But we need to write our update function. So let's go into the view model of add updatesong, and we already wrote it here commented out because we knew we were going to put the updatesong function here, but we haven't actually made the function yet. So let's go and make it. Let's just put it right above here. Technically, personally, what I would do is move this one up, move this one up here. So you would have the add update action would be called and below it, the two functions that are called inside of it would be below, but it doesn't really matter what order. Let's type our function. Okay, this is our update method. Okay. Our update song method looks like this. We are creating our URL similar to how we did and the one up here. And then we're doing the exact same thing right here as we are making our URL into a URL object, and then we have our songs to update. So this would be this song right here. So we give it the song ID, which is passed over from the last view. When we are passing where did it go? Song list right here. When we pass the song over, it has an ID and it has a song title. So here's the song ID that gets passed over and then song title whatever is Typed into that song title text box. And we can see that if we go to the actual add song view. It's the song title right there. So we take that we make it into a song object, and we already have created this send data function. So we know if we look at our client send data, it is using whichever method that we specify. So back there we saw we did the put method, and here we're just passing the JSON over, which is what we want. So we already wrote the function that we have. All we had to do is implement this function in a different way. So we implemented this in almost the exact same way as we do an ad right here. But instead of using a post and creating a new song, we use a put method. So let's try that. Now what is this complaining about again, we need to Mark this with tryaweight because this function uses the async await pattern and that should go away. So it uses async await. So we need to tell this function to use it in that way. Let's go ahead and rerun this. So we have the song called Money. What is a different song title? Let's change this completely to let's change it to how you like that, because you can see I like the was that the band? Yeah, Black Pink, and they've been stuck in my head for a while. So we'll change it to this. And if we click update song, we see it updates and how you like that is now here rather than the song Money and we can even further conform confirm that if we go to Azure Data Studio, which I closed, so we have to open it again and check the database to see if it says how you like that instead of saying Money as the one record that is in there. So I'll go and connect to it and I didn't click Remember password, so I have to type it again. Click on Connect. So once we load our database, we see the one record and the only thing that's here is how you like that. So if we go to add a new song, just click on the add button and type in a new song. We'll call this one Money and click on Add song. Now we see both of them here. So if we go back to Azure Data Studio and click on run again or I might just close this and open it again because mine is having issues. Now we have both of our songs and they have two different IDs. So we know both of those are working and we know the read function works because we see them in the list. So that's all we had to do to update the song. We just had to add this one function because all of the work that we did in that last lesson set everything up for this one. So let's go now and create the delete function. So let's stop the app and I'll just move this out of the way. We need to go to the song list, and we are going to add a delete modifier on this for each loop. So first let's actually write the function and we will write that within our view model. So let's open the song list ViewModel. And instead of fetch songs, let's make a new function for deleting. So what we are going to do is use the delete function where it looks like right here on delete and then perform something that takes in and index that so ours will be ViewModel delete. But let's actually write that. Okay. We have almost certain everything. So we have offset and that's part of an index set or the type of it is index set. And if we click on the quick help here, it shows us that this is a range, because really you can kind of delete multiple things at once when you use index sets. So what we're doing here is iterating through all of the index sets. And actually this needs to go inside of here. Now we are going to iterate through every index set and delete each one in case there are multiple how we are going to code it is there won't be multiple at once, but this gives you the ability to do it that way. And then you can see we actually need to make a new function for deleting because we can't use let me delete those. We can't use the ones that we've already written because we have written fetch and we have written send data, and neither of those do a delete. So we do need to make that new function within our http client so we can use it here. And then this function delete gets used inside of song list. Actually it's ViewModel delete, and we don't actually need the app or the parentheses just because we're passing this function itself and it has the same signature that this was expecting. So we don't need to type the little extra characters there. But we do still need to make our delete function within our http client. So here is our delete function. We make a new URL request object, we make a new URL request object, and we set the method to delete, and we define those methods up above. We use the new URL session shared data instead of data tasks. This is the new async one and we give it a request and we are getting back data and response. But how we have it coded. We're not actually getting back data because we don't care what we get back. We just want back a response. So we're putting an underscore here and then this is a tuple or a tuple. I don't really know how it's pronounced. So that's the object that we're getting back. So we care about the response. So we have an underscore for the data, and then we take the response and try to cast it as an http URL response. And if that all works, we see if the status quo is equal to 200, and then if that is all good, then this function is like over. Otherwise it would throw an error that says bad response. So if we go back to our song list view model and try to use this, we should now get autocomplete. There we go delete at ID. So we have the ID that we defined above for the song ID, and then the URL is the URL that we defined here. So here this is putting everything all together. Otherwise we could have made first a URL string variable and then added this together. But just in this part I decided to put it all on one line. So we have that and that should be it. And we can see in our song list on delete. When that action happens, we are performing our delete function inside of this view model. So it's calling here. So let's go ahead and run the project and bring over Azure Data studio. Okay. We have our two songs here and let's just add a third. Just so we have kind of a few. They have a song called Stay. So I'll click on add song. And so now we have our three songs, but say we don't like how you like that. So if we do the swipe action of Swiping left, that automatically comes because we define this on delete action here. So that just works automatically. So we have slide here. It tells us delete. We click on delete and it's still there. Oh, I know why it's there, but I believe if we check our database. Okay. So it has gone from our database, but it's still on the app that happened because we did go about deleting it from the database, and we saw that that happens right here. So we know our http client is working. What we did not do is inside of this whole delete function. We use offsets and deleted that. So we did this functionality all worked. But what we did not do was delete it from our array of songs. So our view model has all of our songs here and we didn't delete it out of this. So we need to just call remove offsets and pass in the variable offsets. So let's stop this. So basically the array was still in memory. So that's why it came back, even though in reality it wasn't there. Let's try to run this again and see if it works. So if we go to add a new song, there's a song called Kill This Love. So if we add this song, so now we have our three songs here. But let's say we want to delete stay. There we go now that is deleted. And what we should see here is just money and killed us last. So I'm going to close this tab and open it again because I think mine is having an issue. And there we go we just see these two songs. So there are the UIDs and the two songs that we have and that we see in our app, and that is it. We are able to successfully update these songs and delete them. And in total, we can do all four options of crud of create read, update and delete. And there we go we have made two new routes to update and delete data with our vapor API, and we use those routes in our iOS app. Be sure to like and subscribe and tune in next week when we deploy our API to Heroku.