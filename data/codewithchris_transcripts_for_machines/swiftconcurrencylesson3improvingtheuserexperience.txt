Hi. My name is Steward Lynch, and this is the third of six videos in the iOS concurrency series. At the end of the second video we had a working application, but the user experience was not optimal. In this video. We're going to improve the user experience by doing two things. Whenever our app is fetching and Loading data, we want to present a spinning progress view on top of our view to indicate that the data is Loading. If an error does occur, then we want to know about it. So instead of printing the error to the console or doing nothing at all, we want to present an alert to our users with that error information and ask them to contact us with that information. Now, if you're just jumping into the start of this series, you can download the completed code from the second video in this series from the link in the description below. Sometimes our users might be on a slow connection, so fetching data from a network call might take some time to be retrieved and decoded. Your user shouldn't be sitting there wondering what's going on. You should give them some visual clue that something is happening and Swift UI gives us a nice spinner called a progress view that we can use for this. So in order to present the progress view, we'll need to have some sort of a published property in our view model that we can toggle so in the users list ViewModel, create a published property that you can call is Loading and set it equal to false. That makes it a boolean property. Then as soon as we start to fetch that data, we'll toggle it making it now true. Now a defer block is used for executing code just before transferring program control outside of the scope that the statement appears in. This means that when the function has completed so inside of our API service class, we can create a defer block and the code inside there will be executed after the data is retrieved and processed. So what do we want to do when that's done? Well, we want to toggle that is Loading again to set it back to false. Now, since that's on a background thread and we are using a published property, we'll need to make sure that we get it back onto the main thread and we'll do that again within a dispatchq main async block. So to display the progress view while it's Loading, well, we can return to the user's list view, and here we can create an overlay on the list view using the overlay function and the content will be a progress view, but we only want to display the progress view if the view model is Loading has been set to true. If we test this now we'll first need to set our four preview to False to get a real test. Now I'm on a fast network and I can't really notice that progress view. The data loads really quickly. Even when I try dark mode, it's not obvious. I really can't see it, so we can simulate a slow connection here by surrounding our API service call within a dispatchq main async afterblock, and we can set a delay of, say 1 second. So let's test once more. Now we can see it. So let's repeat this then for the post list view model. When we're fetching the posts, first we'll need a published property called is Loading and set it initially to false. Then we toggle it. When we start to fetch our posts, and then for our defer block, we can just copy it from our users list view model here and use it inside the getJSON function. Similarly, we can reuse the code that we created for the users list view overlay here because we use the same property names for the view model and the is Loading property. So let's make sure that we commit our source code. Now it looks like some of my assets weren't committed from the last commit. That question Mark is an indication, and I'm not sure what went wrong here, but let's select them and make sure that the commit now works to commit those to our repository. Now we've structured our app so that it doesn't crash when fetching and decoding data, it either prints out that decoding error or it just does nothing. There's no indication that anything goes wrong, and the user has no idea why they're not going to get the data. For example, let's go to our users list model and add another property, one that's going to invalidate the decoding. For example, that test B string it'll be invalidated because there is no key value pair in the JSON to correspond to this. So when we run this, we'll see that case decoding error is printed on the console. That's just the case name for our API error. That's not any help to our users, and it's not really much help to me. We want to present something more descriptive for each of these user cases, but before I do that, let's take away that delay in our fetch request. We just did that for testing. Now, if the error was an actual NS error, like what happens in our data task or in the decoding routine, we can pass along the localized description. That's part of that error along to the API error, and we can do that by using an enums associated value. Now I have a whole video on associated values for enum. If you're unfamiliar with that concept, I recommend that you take a look at it. And now that we have an associated value, we've got some errors, so we have to provide that associated value, which is the localized description. In the cases of our error here. And in the case of this error, we can safely unwrap it because it's not nil. In the second case, the catch block will generate an unwrapped error with its own localized description too, so we can use it here. But what about these other cases? Well, we can provide our own localized description for each of these cases. We've got our own error. We can create our own description, and the way that you do that is to make sure that your API error conforms to the localized error protocol, and this now provides us with a new property called error description, and it's an optional string, and we can make that into a computed property and switch on self and then allow Xcode again to generate the cases for us. Now for the three without an associated value, we can return our own custom localized string. We use Nslocalized string, and this accepts a string and a comment. Now the string is what you want to have as the localized error, and the comment is there for your translator. Should you actually be localizing your app to other languages? And this would be another video series entirely? I think so. Since we're not, we can just enter a string that makes sense like this one and leave the comment as an empty string. We can then copy and paste this into the remaining two cases, and we can adjust the string as needed to represent the error for the two that have an associated value. Already we'll simply return that string, which is the associated value that we passed in when we created the error and that's the error's actual localized description. So now our API error has a localized description for all five cases. Well, now we can use those strings as part of a message in an alert that we can present to the users whenever an error occurs. So let's return to the user's list view model and prepare for that. To present an alert. In our view, we'll need to provide not only the boolean property to trigger the alert, but also the message corresponding to the error that we can put in the alerts message. So we'll create a new published property first called Show Alert, and we'll set it initially to false. We'll also need to have an optional string property that we can set with our error message when we have an error, and this too has to be a published property. Now, whenever we have an error, we can set Show Alert to True and assign our localized error and further information as the alert error message. We need to do this on the main thread because we are changing a published property that will affect the UI. So inside a dispatchq main async block in users list view, then we can attach an alert to our list using the new iOS 15 alert type that will have a localized string as the title bound to a boolean. Four is presented with actions for buttons and a view for our message. The title will just be application error is presented is going to be bound to our View models show alert published property, and the action is that button that has a label of okay, but no action. And when it's tapped Swift, I will take care of dismissing the alert. Then for the message. If it's no longer optional, we can use the Viewmodel's error string as the string for the text view in our message. If we test this now, we see that our error is displayed. Great. Now, before we forget, let's fix that user model to remove that extra property because we've done a great job here. We're not going to get any errors, but just in case you do, your users are going to see it. Now, let's do the same thing for the post list view model and post list view. We can simply copy the code from the two files that we've already done because they'll be identical. First the two published properties, then the failure code to trigger the alert, and then for the View itself, we can copy the whole alert again. Because we use the same variable names. The code will just work well before we forget, let's update our source control by issuing a new commit. It looks like I missed one of those assets the last time, so let's make sure I do it here. Now, all five of our files are updated, and that's important because in the next video in this series, we're going to branch off of this main branch that we've been working on so that we can take a look at the new concurrency model introduced in iOS 15. We still need this branch, though, because we'll be checking out again later, though, and we'll branch off in another direction when we change our deployment target. So make sure you subscribe to the code with Chrischannel. If you haven't already and ring that Bell to get notification of all new videos. Thanks for watching and we'll see you next week.