Hi. My name is Jordan Lynch. I'm very happy to be offering you this series on behalf of Code with Chris. So the title of this series is iOS. Concurrency is much, much more. It's a six part series where I'll introduce you to JSON, decoding and creating models from JSON, building an API service to perform asynchronous network calls to fetch that JSON, we'll go through the traditional completion handler based URL functions, handling and reporting errors. Along the way. There are a lot of topics covered, as my intention is to provide you with methods and understanding that you'll be able to apply to your own projects both now and in the future. In this first video, we'll focus on creating our models from the JSON and an API service to handle the process. We'll create a generic function to handle the different API endpoints and models and use a result based completion handler with our own designed API error. If this is something you're interested in, then let's get started. First create a new Xcode iOS app project and make sure it's a Swift to I project and name it something like iOS concurrency. I always like to add an app icon and launch screen to my app so that they are easily recognizable in the simulator or on my phone. If I install it there, I provided you with some resources for this project. With these two items already created, you can find those in the link and in the description below. So go to the Assets folder of your project and drag the Launch Screen image into that folder. Next, select your Apps Target and then the Info tab to see the new iOS 15 Info P list. Drop down the Disclosure icon on the Launch screen, then click on the plus icon and Select Image Name. Make sure that you enter the image name with the lowercase L and uppercase S, but don't enter the PNG extension. Next. Right click on the App icon in the Assets folder and choose Show in Finder. Bring up that provided Resources folder once more and move the App icon App icon set into that folder, replacing the empty one. We've just installed the icon and launch screen. If you run your app now in the simulator when it launches, you should see that Launch screen. If you exit the app or quit and check the Simulator's home screen, you'll see that icon on your app. This project is going to be using the JSON Placeholder API to fetch and decode JSON. This API has a number of endpoints that you can use. One of them is the user's endpoint where we can fetch JSON corresponding to ten different users. As you can see from this JSON here, let's take a look at the post endpoint. Users are able to create posts as you can see from this endpoints JSON and there are 100 of them corresponding to ten for each of the ten different users. What we'll need to do is to create a struct that will model that JSON. And that's why we often call these structs that represent something a model. I have created a couple of YouTube videos on modeling data from JSON, and there are a number of tools available to you to do that as well. The tool that I use a lot is one called Ducky Model Editor. However, many people are happy with a free webpace tool called Qwikype. These tools are particularly useful if you want to model really complex objects that have nested JSON, our two are relatively simple, so I want to model them by hand. So first let's create a new group called Models. Next, create a new Swift file called User. Now I'm going to want to reference the user's endpoint, so I'll need to go back and copy that URL, and then I can paste it as a comment at the top of my struct so that I have quick reference to it. Well, now with that file created, I'm going to create that struct, and I'm going to call it the same name user. Now for the user, I'm really only interested in modeling the ID name, username and email. And since these are all top level keys in the key value pairs of this JSON, we can simply create properties that use the same name and the ID will be an Int, and the other three are strings. Now, since we're only going to be reading this information and not modifying it, we can create the properties as constants using lead. Now, in order to decode this JSON, the model has to conform to the quotable protocol. And because each one of these properties are simple types that conform to the quotable protocol already the entire struct wheel too, so we can Mark it as conforming to quotable protocol. We're also going to want to present our users in a list view, and it's much easier to do if the Struct conforms to the identifiable protocol. And the only requirement for that is that there is a unique property called ID, and we already have that. So let's do the same now for the posts JSON endpoint. First, let me copy the endpoint for the postural so that I can use as a reference. And then I want to create a new file called Post. And in that file I can paste that URL as a reference for our new model Struct. Now this URL gets all the posts, but what I want to know as well is how do I get the post for just one user? So let me return to the API documentation to find that endpoint. Here it is, and this is the one that I want. So let me copy and paste that URL in as well. Now I can create a new Struct using that same name for the posts. I want to model all four properties here, and they are all top level as well. So fairly easy to do, just creating our properties using the same names as the key values in our JSON. And again, since we'll be reading this information only and not modifying it will create it using lips as constants. Both the user ID and ID are INTs, while the title and body are strings. The user ID property corresponds to the ID property in our user model. The ID, though, is the unique property for this particular model. And again, in order to decode the JSON, the model has to conform to the quotable protocol. And because each of these properties are simple types that conform to the quotable protocol, the entire Struct will too. And with the ID property being here, we can conform the struct itself to the identifiable protocol. Now I have an entire series on JSON decoding, and it covers this as well as how to decode and encode your data, which we'll be going over soon. I'll leave a link here in the notes below. Now I want to create a Struct that I can use as a service that I can call from a variety of different views to fetch our data. Whether that be an array of user or an array of posts. Now, there are a number of ways to do this, and you may have heard of a Singleton, but it gets a lot of bad press about not being able to test. Well, we're not going to be running any unit tests on this project, but let's start right now by creating good habits, and anytime we want to access that service, we'll create a new instance of the service. So I'm going to create a group called Services. And even though there's only going to be one service that I create, I want to keep my code organized inside that folder group, I'll create a new file and I'll call it API service. And inside there I'll create a struct using that same name. Now the struct will have one property that will be the URL string representing the endpoint, and we're going to have two different ones, one for the users and one for the posts. So each time that we create an instance of this structure, we'll need to pass in a different string representing that endpoint. Next, we'll create a function called Get users. Now this function is going to have to return an array of users, so my first inclination is to return an array of users like this. Unfortunately, this won't work, at least not yet. Later on in the series, we'll be covering new concurrency models introduced in iOS 15, but as you are likely to see still, for quite a while, the older method of dealing with concurrency, we're going to start there. This will require using what is known as a completion handler, and eventually we're going to be using a result type as our completion handler's argument. But I'm getting ahead of myself if you are still confused. After I finish this video. I recommend that you watch the two videos I have on that topic and links are in the description below. Let's start easy now and build on this concept. The reason we need a completion handler is because we have no idea how long it's going to take for that network call to fetch that data. And since our code is inherently synchronous, it would move on to the next line before we received our data. And the completion handler is just a closure that we can pass in as an argument so that it will get executed when that data has been retrieved, and we can give that closure a name. And typically people call it something like completion or completion handler. So when this function has completed and we'll either have successfully retrieved our JSON and decoded it, or an error will have been produced. So when we call this function, we'll need to deal with either case. But first, I'm going to keep it simple and deal with the error right here within the function and only execute the closure if we successfully decoded the data. So the closure function is going to have an argument which will be an array of user that we've returned and it's going to return nothing or void. There will be another issue, however, as we'll be fetching that from a server and it's going to take. Some time the function itself will escape the scope before we're done. So we'll need to specify that this completion handler is going to escape. So we do that by marking the completion function as escaping. Well, now we can get to work. First, we'll need to create a URL from our string, and we can use a guard check for this. So we'll guard let URL equals the URL string from URL string. Else we'll just return from the function. Next, we'll use the URL sessions Singleton data task function with URL, and this also has a completion handler just like our function does. So we'll pass in the URL for the URL, and when we hit enter on the closure, we see that we can assign variables for the three different objects that are coming back. Data, response, and error. All three of these properties are optional. The most important thing that we have to do before we forget, however, is to make sure that this task gets initiated. So we'll also need to call resume because it's initially in a suspended state. So now we can check on those three optional items that we get back. First, we'll check the response to see if it has a status code of 200 and that it's not nil. So another guard check guard, which http response equal response as an http URL response, and also that the status quo is equal to 200 else we'll just return. We also only want to continue if there isn't an error. So guard if error is equal to nil, we can continue else we'll return from the function. If we get this far, then we'll need to check to see if we got data. So another guard check guard, but data equals data else return. Well, now that we've got the data, we can try to decode it. And the key word here is try. But first we'll need a decoder. Letdecoder equals JSON decoder. Now, because the decoding might fail and throw an error, which means generate an error, we have to create a do catch block to try and decode it. And this is such a common construct, the do catch block that I've created a code snippet for this. So anytime you see me do DTC that stands for do try catch. I have a code snippet that's going to generate that construct. Then we can let our decoded data be the result of trying to decode the array of user from that data, and if it's successful, we can just use that decoded data as the argument for our completion handler, which is completion, and it runs that function with that argument. If it's not successful, it fails. So we'll just catch that error and then just print that there was an error. Now this will work, but there are some severe limitations here, and you'd not want to ship an app like this using this function. When there is an error, we're not giving any feedback to the user, and it just exits the function. The only time you do anything is when you print out that there was an error to the console, but your user will never see that in a later video. We're going to go over error handling in more detail. But I want to set the stage here by changing this function to provide any errors to the caller, so that eventually we can bubble that error up and provide an error to our users in the UI using an alert, and this is where the result type comes in for our completion argument. A result is simply an en with two cases, either a success case with an associated value and that associated value will be in our case, the array of users, the successful completion or a failure case where the result is an error type. So instead of using simply an array of user in our completion handler, I want to use a result type so we can change our completion argument to a result where the two cases are array of user or an error. Then we need to fix that completion that we have in our function so that when we successfully decode the data, the result success case success has an associated value and that associated value is our decoded data. Still with me? Well, what about the failure case? Well, it's going to fail every time we fail the guard check or in that do catch block, we want to be more prescriptive. So I'm going to create my own API error enum with all five of the cases where we could have possibly failed, and the enum has to conform to the error protocol. So there are five different cases in that first guard, we had an Invalid URL, so I'll set the case to be Invalid URL. Then we check the response status. So my case is going to be Invalid response status, or perhaps the URL session didn't work at all. So it may be a data task error. Perhaps the data was corrupt, corrupt data. And then finally, once we get the data, perhaps our model is incorrect. So we'll get a decoding error. So now when we fail, we can do another completion using the failure case, and that has an associated value that we'll just use our case. So first we'll need to go back to where we define our result and say that we no longer want to have that error case just a generic error. We want to be specific and say that it's going to be our API error, and then each of those five cases we're going to now call our completion handler with the failure case, and the associated value is going to be the corresponding case from our API error. So first failure is an Invalid URL. Next, an Invalid response status, then a data task error corrupt data, and finally a decoding error. Now there are only two more things I want to do before I finish this video. This function is looking pretty good, but currently I can only use it for users and not posts, and when you look at this, though, the only time I use user is when I decode and define the associated value for the success case in our result type. It could be easy just to copy and paste this function and change this to get post and change user to post. However, there's a better way and that's using generics and I have a video on generics. If you want to find out more information on that topic again, a link will be in the description below. The function will work for any decodeable type object like our user and post objects, and we can use that fact by specifying that the function should only work if that's what we're dealing with, which is a decoded type. So when we define our function, we can specify that limitation and we can use a variable like T to represent that type and make sure that that type conforms to the decoded protocol. And then everywhere where we see user, we can replace it with the T placeholder. Now T is generic itself, and it can represent either a single object or an array of objects, so we don't really even need to specify array here. We'll be able to specify that when we call the function and we're almost done. And this is a service class that you can use in all of your projects, but to make it even more inclusive and I go through this in my quotable series, you may have a specific key decoding or date decoding strategy that you want to use, so I'm going to create two more arguments here. So before the closure, let's add two more parameters for this function. One is going to be a date decoding strategy, which is a JSON decoder date decodingstrategy, and the second is a key decoding strategy, which is a JSON decoder key decoding strategy. Now 99% of the time, the defaults are just fine. But since we are adding these two parameters when I call this function, I'm going to be forced to enter in what would be my default when I create the instance of this Get users function. So in order to make this optional for us, I can assign the most common default values in the initializer for each parameter. Then after we create our decoder, we can assign these properties to the decoder. That's almost it, but I forgot this function is still called Get users when in fact it's going to be more generic. So instead of calling it Get users, I'm going to change the name to getJSON instead. Well, that's it. We haven't tested it yet, but we've created the groundwork for our app, and the really good thing is that we've created a reusable API service class that you'll be able to use in your own projects in the future. In the next video I'll show you how you can use this class and we'll also be improving on it when we start working on error handling. Hopefully this hasn't been too technical, but it is worthwhile, I think, going through in some detail so that you understand why things are done this way. When we start to use the functions in a later video, we'll be converting this to an alternative version that uses the new Async and Await concurrency model. So in the next video of the series, we'll be building out the UI, and I'll introduce you to Voodoo, a modified MVVM design pattern, and utilize Xcode's source control features to ensure that our source code is protected. So make sure you tune in next week for the second video in the this series and subscribe to Chris's Channel to make sure that you get notifications of all new updates. Thanks for watching.