Hi. My name is Dort Lynch, and this is the second of six videos in the iOS Concurrency series. In the first video, we began by creating our models and a service so that we could fetch and decode JSON from the JSON placeholder API. In this video, I'll introduce you to Voodoo, a modified MVVM design pattern so that we can create new models and views to display the content that we fetch from our API endpoints. We'll also be seeing how we can use mock data so that we don't have to always make calls to the API. When we design our apps and you'll be introduced to get source control using Xcode. I'm going to be using what Mark Morkins from Big Mountain Studio calls Swift UI Voodoo, and this is a modified NVVM architecture. There are three parts. As you see a view, the observable object and the data object. Now we've already created our data objects. Those are our models. So I'll let you go to the post and I'm just going to start using it. The first thing we have to do is to change the name of our opening view from content view to represent what our first view is going to be, and that's going to be our users list view. So we can do this by right clicking on the name and choosing refactor. And when we type in our new name, this not only renames the view but also the file name and any instances where it is referenced, like in the app file. The other thing you might want to do is to change the preview to users ListView underscore preview and the header as well. Next, we'll create a group called Views and move that file into there. I'm just going to adjust the order a little bit in my Navigator. I have my view here that I want to modify, and I have data objects which are the user and post objects. And now I need my observable object, which I will call the users list ViewModel. So let's create a file in a new group called viewmodels. So inside that group, I'll create a new file that will call users List view model, and in there I'll create a new class with the same name but conforming to the Observable object protocol. Now this class is going to have a single published property called Users, and that's going to be an array of user, and I'll initialize it as an empty array. So this is before we fetch our JSON. It's also going to have a single function called Fetch users. So it's within this function then that we can call that function using our API service. So first we'll need to create an instance of the API service, and it requires a URL string for the endpoint. Well, we have that URL string back in our model so we can copy that and we can then just paste it in here as the argument for the API service instance within the function. Then we can call the API services getJSON function, and this provides us with a closing completion handler that is a result. However, this result type is generic, so we'll need to specify which objects we expect to come back as the cases for the argument for that completion handler. Well, we know that a result type has two cases, and for this instance, the first case, the success case is going to be an array of users, and the error is going to be of the type of our new API error, and then we can switch on the result in an Xcode 15. This nicely completes the case for me. However, I'm going to change the let success to be let users and let failure to be let errors. So users represents the users that we're getting back and error will represent any error that we might get. Now we know that that success type is that array of users, so we can assign those users then to that published property of users. But it's an asynchronous function that's executing on a background thread, and we're going to be using this array of users to update our UI. So we'll need to go back onto the main thread to do that using a dispatchq main async. And just like I had a code snippet for my do catch block, I have one for this dispatch queue as well. All I have to do is enter DQ. So for the failure, then I'll just print out the error at this time. We'll deal with this a little bit later. Great. Now we can use this view model back in our users list view. First we'll create a state object that I'll call VM that will be an instance of our users view model. Next we'll replace the body with a navigation view, and inside there let's create a list, and then within the list we'll iterate over our view models users with a for each loop, and then for each user in that array, then we'll create a V stack within an alignment that is leading. And then for two text views within that V stack, we'll first create one. It's going to represent the user name property. We'll set the font to title, and then the next one. We're going to represent the user's email in a text view, and then we'll set the navigation title to say users. We'll also set the list view style to just plain using the new condensed way of applying a list style. And then finally, when this view appears, we can call our view models fetch users function and thus update the view. So if we resume our canvas, all we see is the navigation bar. We don't see the preview, and this is because our preview provider hasn't fetched any of our users. This is only happening if we go into preview mode, so we'll have to enter preview mode to initiate the fetch and display that list of fetch users. I'd really like to see what my view looks like without having to make that network call. You may have noticed that Xcode provides us with a preview content folder, and this is where you can place content that you want to exclude from your release builds. When you upload to the App store, the content will be available to you during development or the debug stage, so this is a great place to store that kind of information, and the easiest way to do that, in our case, is to use a sample of the JSON that you'll actually get from your API. Now I recommend to use Safari without any JSON extension enabled, so that when we view our endpoints, the JSON will be displayed as JSON text in the browser window. So let's go get the ten users JSON from the JSON Placeholder API. All I have to do is select and copy the text to my clipboard. Then within the preview content group, I'm going to create a new file that I'll call users JSON. Now make sure you specify JSON as the extension and then replace the entire content with what you copied from your clipboard. Now I want to repeat exactly the same process for the post because we're going to be building out the UI for a list of posts as well. So we'll go to the post JSON endpoint. We'll copy that JSON, I'll return to Xcode and create a new file that I'll call posts JSON and paste the JSON into there. This content is now located in your application bundle during debug mode, so we'll need to somehow access that and I'm going to create an extension to bundle that will easily decode this data. So as long as it is a decoded type, which we know ours is, I'm going to share with you an extension that I copied and modified from Paul Hudson from hacking with Swift. It uses generics just like we did in our API services. Get JSON function to decode decodeable objects from files stored in your application bundle. Now I use this all the time, so I've created a just where I can get access to it at any time and link to this is provided in the description below. The code should look actually pretty familiar to you. It's just that we're getting our URL from the bundle instead of an endpoint, and instead of a result, completion handler decoding from a file isn't asynchronous so we can simply just exit with a fatal error if something goes wrong and return the decoded data. If we're successful now, I suggest that you just copy this to your clipboard. Now returning to Xcode, I'm going to create a new group that I'll call extensions, and inside that folder I'm going to create a new file that I'll call Bundle plus extension. Now just below the import, I'll just paste that extension it's ready to use, so feel free to use this in any of your projects. It's a really handy extension. Next, we'll create a file within the preview content folder that I'll call mock data. First, I'm going to create an extension to the user struct, and within there I'm going to create two static computed properties, one that will return an array of users, and another that's going to return a single user that we can use for our previews. The first will call mock users, which is an array of user. And what we're going to return is that array that we decode from our bundled file so we can simply use bundle main decode the array of user type self from the users JSON file within quotes for the single user. Then we can just create another static computer property called mock single user of type user, and we'll just return the first item from our mock users by accessing the static property on self at index zero. Well, we can do the same for ours. For post. So all we have to do is create a new extension for post, and then I'll just copy from above and anywhere I had user, I'll just change it to post. Now I'm also going to be needing a post for a single user. So I'll create one more static property that I'll call mock single users post array. It's a mouthful, but it's descriptive, and this will be an array of post, but I'll filter it so that it's using a user ID that matches the number one because I know that there is a user with an ID of one in my mock users. Great. So how do we use itnow? There's a problem with the fact that we're using a view model to fetch our users, and there's no easy way to display mock data while developing your UI in this case, because whenever your view model is instantiated, we set the array of users to an empty array, and then the view appears when we fetch users from the API. Now there are a couple of ways around this. You could create an alternative initializer for the view model. Like this, we create an extension on the user's view model, and in there we'll create a convenience initializer with an additional parameter called for preview. That's a boolean value that will default to false. Then we can call the selfdefparents initializer, which sets users to an empty array. And then if we specify that for preview has been true, we'll set the users to be our users mock users with this in place, then we can go back to the users list view, and anytime we want to show mock data in our initializer, we can simply change it so that we have this convenience initializer where we'll set for preview true and we see them without making a call to the endpoint. Our preview provider will generate that preview on the canvas. Now the bad news is that we will either have to remove the argument or set it to false when we ship. Otherwise our users will get that mock data first, even if it never makes a call to the API. So for this reason, I suggest that you place a warning above this state object to remind you that you need to remove that argument before you ship. Now the good news is that even if your argument is set to true whenever you run on the simulator or on a device, the preview will be overridden by the fetch users call on the API so that the data will quickly be replaced, but it's still not ideal. So remember to remove that argument or not use it at all and just keep pressing preview. However, if you're paying for a service that charges for fetch requests, you definitely don't want to do this. Now we're going to do a similar thing for our posts, and we'll create a post ListView model that conforms to the observable object like our users list view model. We'll have a published property, but this time it will be an array of post objects. Now the criteria for fetching posts for a user will be a user ID, and we won't know that user ID until we specify it. So let's make it optional and it will default as nil. And then like in our other view model, we want to fetch the posts, but we won't do that until our user ID has been specified. So we can use an iflet here to unwrap user ID. So first we'll need an endpoint for the single user post, so we can copy that from the post model. Then returning to our post list view model, we can create a new instance of that API service passing in that string, making sure that we place the hard coded one with the user ID from our ViewModel. Now inside that function, we can use a similar API call as when fetching our users. So let's just copy and paste that in here and adjust to fit. For our result. We're getting back an array of posts, not an array of user, and when we're successful, we get posts so we can set our published post to that decoded array to display the posts for the user. We'll need a new Swift UI view that uses this view model, so let's create a new file within our Views folder that we'll call Posts ListView. And inside that struct, we'll create a new state object for post list view model. Now we're going to be presenting this view from a navigation view, so we don't need to add one in here. It's already going to be here, but we can create our list, so let's just copy the code from the previous view and adjust to fit again. First, we'll change all references from users to posts or posts. For the first text view, let's pick the post title, but change the font to headline, and for the second we'll use the post body but also set a font for call out and change the foreground color to secondary, and then for the navigation title, we'll change it to Posts and change our navigation bar title display mode to be in line in the on appear. Then we can change this to fetch posts. The errors are all gone now, but our user ID in our View model is still nil, so we'll not be able to get any listings yet. We'll have to be injecting the ID when we tap on a row from our users list. So let's create a property here that's not going to change once we've passed it in, so it doesn't need to be a binding and it's going to be a user ID. We'll also need to pass in a user ID to stop the preview from complaining. So let me just enter a one here and then on appear. Before we fetch our posts. We'll set the user ID within our view model to be what was passed in and it will no longer be optional. Therefore, we'll generate the list view that we can be presented in this view. Similarly, we're not going to be seeing that navigation bar because our preview has no idea that our view is in a navigation view, so we can surround our preview with the navigation view just so that we can see what it looks like in our canvas. I'd also like to make sure that we have some mock data so that we can view the list of posts within our canvas without having to make a call to the API. So we're going to have to do the similar thing that we did with our list view model. So we'll go back to that one and then we'll just copy that extension and we'll change the extension to be a postless view model extension and adjusted here where we display instead a single user post array. So back in our view, then we can do the same thing by cautiously adding a preview argument when creating our Viewmont, then back in our list view. In order to be directed to the post list view, we'll need to create a navigation link and the navigation links destination is going to be our post list view passing in the selected user ID, and the label will be exactly what we have if I test this now, it all just works perfect. But one more thing, though, when I run this on the simulator, I get these constraint warnings showing up in the console, and this happens when you embed your views in an unstacked navigation view. I think this has to be an Xcode bug because I'm using Swift UI and not UI kit, and I have no idea how I can adjust constraints. If you want to suppress these errors, you can set a value for user defaults that can suppress the warning. So when your user's list view is first instantiated at launch time in the app file, we can assign this in the on appear function, and I do this again so often that I have another code snippet for this and we set the user default standard value to false for the key, which is in quotes. This UI constraintbased layout log unsatisfiable. So you've seen now that I've used three different code snippets so far, so if you're interested in code snippets, they're very powerful. I recommend that you watch this video that I created quite some time ago on creating your own code snippets. Well, we spent a lot of time so far in this project and we want to make sure that going forward. As we make adjustments, we can return to a point in time in the past in case we need to rework something. And this is known as source control. And the most common versioning system for developers is called Git, and Xcode provides us with access to Git right from its own source Control menu. I have an entire series on source Control with Git next code. If you're interested in learning more, I'll leave a link in the description below. All we have to do is select commit from the Source Control menu and enter a comment as to what stage you are in your project and that's a reference. We'll be exploring more source code features in future videos in this series. In the next video in this series, we'll be finishing up the first part of the series to provide better feedback to our users so that they'll know when our application is actually fetching data so they have to be patient. And if there are any errors, we can let them know to file a bug report with the developer. So make sure you subscribe to the code with Chrischannel. If you haven't already and ring that the Bell to get notifications of all new videos. Thanks for watching. Bye.