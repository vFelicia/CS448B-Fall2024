Hi. My name is Stewart Lynch, and this is the 6th and final video in the iOS with concurrency series. In this video we're going to see if we can apply the new iOS asynchronous concurrency methods to an Xcode project with a target of iOS iOS 14. This will require Xcode 13 two or later, and it wasn't until Xcode 13 two that Apple backported some of these features to targets of iOS 13 or earlier. If you're just jumping into the start of this series, you can download the completed code from the fifth video in this series from the link in the description below with Xcode 13. Two, some of the new concurrency features have been backported to iOS 13, and this is great news because perhaps we realized that by setting our target to iOS 15 only, we're missing out on a lot of users who have not upgraded their phones. We're currently using some iOS 15 specific APIs that will no longer be able to use. But I would really like to use this new asynchronous concurrency model as we're testing again, let's create a new branch by now. This should be familiar to you. Select the source Xcode Navigator and then right click on the main branch to check it out. Notice that it is now the active branch and we're going to branch off of this one right here. So we'll right click and create a new branch and I'll call it back Port. This time it created the branch and it checked it out all at the same time. So now it's my current active branch that I can work on. Now, this get JSON function in our API service is the completion handler version of our function, and it doesn't use the new async and await concurrency methods that were introduced in iOS 15 in videos four and five of this series. We changed that to use these new methods. Now, if you've updated your Xcode to version 13 two, you should now be able to take advantage of those new features and projects for targeting earlier versions of iOS. And this is one of the terms target applies to switch the application and you'll see both project and target the target, in a sense, means which of the Apple SDKs am I developing for? Is it macOS iOS iPadOS? Is it a Widget Kit application or one of many others? If you click on the target and then on the general tab, there is a deployment info section, and here you get to see what the iOS deployment target is. And in my case here it's set to iOS 15 two. This means that in order to install and run this application on your device, it has to be running iOS version 15 two or higher, and those who haven't upgraded yet can't run your application. As I said, you potentially may be losing out on a lot of customers. In most cases, the Swift UI going back to iOS 14 from iOS 15 requires only minor changes depending on what APIs you've implemented, and we'll see that shortly. Going back to iOS 13 is a little bit more problematic because there are more deprecated methods, so I'm going to take the less troublesome path and change my target back to iOS 14 and see what happens and what's going to be required. When we build, we get several errors, and these errors are all saying that a particular API that we're using is only available in iOS 15 and newer. The overlay and alert APIs we use in our code have changed since I was 14, so we're going to have to revert back to the deprecated versions that were available to us. Then it's important to note that Deprecated doesn't mean that we are playing with Fire. There are many Deprecated API that have been around for many, many years, so there's no need to panic at some point. However, in the future, though, when you change your target back to iOS 15 or higher, you should change the code again to remove the deprecated versions. If I click on one of the overlay errors, it takes us to that culprit. If you option click in the overlay error in users list view, we get the quick help and if we scroll down further, we see opening documentation. So let's do that and we see that it's available from iOS 15 on. I know that there's an iOS 14 version, however, because I used it and it doesn't put our view into this trailing closure. Rather Overlay didn't use a closure at all, so let's remove it. Now. The error here is hard to decipher, but if we enclose our clause here in a group, the error goes away. We can repeat that in the postlist view too, so we'll do the same thing. We'll remove the closure and embed it within a group. Let's check out the alert and option click and then drill down into the documentation. I can see that it too is iOS 15 on. Onlynow. If I search through the documentation and click on the alert that's found. I'm taken to another alert and I see that it's been available since iOS 13, but that it's been deprecated. It may take several releases for it to actually disappear, and by that time hopefully you've updated your code to use the more modern APIs. We can see that this documentation is within a section called Deprecated Views and Controls. Scrolling down. We can see the different initializers that were available to us. If we remove this code now we can start typing alert, and if we take a look at the options, we can scroll down and we'll see the two earlier versions and they are marked in Gray. That's an indication that they're deprecated or not available to us. However, we can make them available to us. Let's choose the is presented version and it needs to be bound to something which is our viewmodels shower alert inside the ContentView closure. We'll need to use what is known as an alert object, and there are a number of options here. The one we want is the one with title message, both being text views and an optional dismiss button for the title. We can use a text view and we'll just say application error for the message. We can use another text view with our view model's error message, but it's optional, so we'll not coalesce it with an empty string, and we don't need the dismiss button because as I mentioned, it's optional, so we can just remove it. We can repeat this process for the user's list view, and I happen to know that the ad alert is exactly the same, so we'll just copy it here and paste it or replace it with the same version. If we build now, there are no errors. Great, but we really haven't gained anything. What you have now is a project that you could have originally Xcode using Xcode Twelve under iOS 14. If you want to go back to iOS 13, you'd have to do more things like changing the navigation title to a navigation bar title you couldn't use State object, and there's probably a host of others, so I'm going to stop here, but you can go back as far as iOS 13 with Swift UI, the observer of you will notice that the list style is not complaining about my using Plane instead of using the full instance of Plane liststyle struct that we had to do in Xcode twelve, and it appears that the new style options have been backported, so we don't need to do anything to change them. Well, with Xcode 13 two, we learned that the new concurrency methods have been backboarded as far back as iOS 13. So if we want to update your API fetches to use this new Asynchronous version of the URL session data method, we're going to have to implement those new features, and this should greatly clean up our code. Well, it turns out that although Swift five five's new concurrency system is becoming backward compatible in exclude 13. Two, some of the built in APIs that make use of these concurrency features are still only available on iOS 15, Mac OS Monterey and the rest of Apple's 2021 operating systems. The good news, however, is that we are provided with another method that we haven't looked at yet, and it's a continuation mechanism that lets us retrofit existing code with Async await support. And what also is good news is that Xcode gives us some assistance here. If you Xcode and click on the function name for our existing completion handler version of Get JSON, you get three different options for converting this function to an Asynchronous version, and all three will work. But we really would like to understand this, so I can Xcode in the future from the Get go, so let's explore the options and we'll start from the bottom up. If I choose this method, it simply creates a new function that has the same first two parameters, but instead of a completion handler, it's an asynchronous throwing function just like our new one that we created in videos four and five. No error, then calling the new function yet JSON because as we saw in video four, we can have two functions with the same name so long as the function parameters are different. What this does use is the with check throwing continuation that calls our old completion handler function and then essentially maps the continuation into an Asynchronous one. That's pretty cool, but now I have two functions to clutter my code, and our View models are still calling the older version with the completion handler and not this version. So let's just undo this and take a look at our second one. If we choose this one, it basically does the same thing as we saw in the previous example, but it makes all of the same changes in line in the Asynchronous version of our function with the use of the checked throwing continuation block and adds continuation resume for each of the result enum cases. Now the errors we're getting here are all related to the function now not recognizing the API error case, since it's not specified in our function parameters, and we can fix that by pretending all of the cases with API error and by removing any unnecessary returns. Still, I have two functions to deal with, and our View models are still calling this older version with the completion handler and not this version. So let's undo once more. Let's go all in now then and convert our function completely so that we only have a single function to deal with. And that's what this first option will do for us. Well, we'll need to fix those return in errors for not knowing what type of error is still just like we did in the last version. The errors in this file all go away now, but when I build, I get four errors. Why is that? Well, it's because now I'm trying to call that old completion handler version that we had before and it's no longer here. So let's fix that and this will be a repeat of what we basically did in video four when we created the Async function from scratch in iOS 15 in users. Chris view model. Then let's remove from the fetch users function everything except the first two lines because we are going to need an instance of the API service and we want to set is Loading to true. But remember, we can now use the defer block right within our function. So after is Loading toggle we'll add the defer block. Then we can simply create a do catch block, and then within the do block, we can try and await the return from the API service. Get JSON function and assign it to our users and we can fix the error because we need to specify that our function getJSON is now an asynchronous function in the catch block. We can set show error to true and then set our error message with the errors localized description and that contact information, and then we have to decorate the function with App main actor to ensure that the function is dispatched back on the main queue, or we can copy everything from defer on down here and then go to the post list ViewModel and replace the corresponding part of the getpost function with the same content updating. Of course, users to posts specifying that the fetch post function is asynchronous and adding the app main actor to make sure that we get executed on the main thread. Again, we have a couple of errors left, though, and those are in our views, and that's because on up here we're trying to call an asynchronous function. Well, we can't use task as we did in iOS 15. It's one of those things that didn't get backported. However, you may recall that there's another option. We can use a unit of Asynchronous work called a task so we can embed within the on a peer our content inside a task and await the fetching of the JSON. Finally, then we can go to the post list view and do exactly the same thing for on appear. We can enclose our actions in an asynchronous task and then await the fetching of the posts we can build and run now and all errors will disappear and our application runs. We have successfully backported our application to run under iOS 14 using the new Asynchronous methods. Before we ship the app, though, make sure that you'll check any warning the app is giving you like this one here that we left for ourselves to make sure that the four previews is set to false. Now, the last thing I'm going to do is commit any changes to our local Git repository. Well, that's it. Thanks for joining me on this six part journey, and I hope that you've learned some useful and transferable skills. I want to thank Chris for inviting me to add content to his channel, and I look forward to being able to contribute more in the future. Thanks for watching.