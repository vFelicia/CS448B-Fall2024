hello welcome to learn Swift for beginners lesson 10 in this video you're going to learn about inheritance otherwise known as subclassing which allows us to build upon previous classes which we've already defined and it saves us a lot of time and effort and work so that we don't have to keep defining classes that do similar things okay so let's get started and see how this works let me start by doing a small recap of what you've learned in this Series so far so you learned about variables and constants to store and keep track of data you also learned about some control flow and conditional statements so that you can express logic and make decisions with your code and then you learn about functions where you can Define blocks of code that perform specific tasks as a way of organizing your code into more manageable chunks and then you learned about classes which is a further way where you can organize related code and related functions together as well as related variables um in the form of properties and then today you're going to learn about inheritance AKA subclassing as a way to further organize your code okay so let's take a look at uh inheritance in a playground so I'm going to launch xcode here I'm going to get started with a brand new playground and let's call this um inheritance playground okay let's just save it on my desktop top there and get rid of this line of code so let's say that the app we're building is kind of like a car simulator or something like that and we need to define a class that represents a car so we're going to start by creating a car class just like that and some of the things that it may have is for example it needs to keep track of a top speed right because different cars may have different uh ranges for the top speed I'm just going to initialize that to 200 so there may be a whole ton of other attributes or properties to do with cars but for demo purposes I only need one so I'm not going to go further than defining top speed there and I want to define a function so a car by definition is a vehicle that can be driven right so I'm going to create a function uh called drive just like that it doesn't accept any parameters and inside this function it's going to perform all the code that we need to drive a car but you know for this demo I'm just going to print driving at and then I'm going to put in top speed like that so this um this value in this top speed property get substituted in there and then it prints out driving at whatever this value is 200 so when I call the drive function it's going to print the statement out into the console Okay so we've defined our class here uh that represents a car and in the previous lessons you've learned about how to create a new object right from the car class so why don't we declare a constant uh called my ride and we're going to create a new car object and assign it into the constant my ride just like that we've created a new car object now let me try accessing um top speed right you press Dot and then you can access the property there so you can see it's running the playground okay you can see 200 there and let's try calling the function my ride. drive that and you can see it says driving at 100 okay so now let's say that in this driving simulator app I also have something called a super car or maybe a future car so it's the car of the future for example and it can fly so it's the flying car that will probably come in the future so we can Define another class to represent that and we can call it future car right and again this Future car because it is a car still it's going to have a top speed and let's say this top speed is 250 like that and it's also got a function called Drive um because you can still drive this car and again it's just going to print you know driving at top speed and also this car can fly so let me Define another function that represents you know uh flying the car so flying I'm just going to call it flying like that uh so here we've defined our car class we've defined a future car right here if I want to create another um let's call it my new ride this is a constant and this time I'm going to create a new future car object like that and then my new ride you can see has fly now right and it has drive and it has top speed now let me ask you this question see you can see the similar arities between car and Future car right they both have the properties of a basic car like a top speed and they both have this drive function which is very very similar in fact it's actually identical so this is pretty redundant right there's a lot of redundancy between these two class definitions so this is where inheritance or subclassing comes into play and is very helpful so what inheritance allows us to do is say that one class class inherits from another class and essentially what that means is that if Future car inherits from car it's going to inherit its properties and functions so you don't need to redefine them inside future car so let me show you what I mean here let's in future car let's delete this top speed property and let's delete this drive function and what I'm going to do instead is I'm going to make Future car inherit from car and the way you do that is after the uh class and then class name you put colon like that and then you put uh the the class that it inherits from so in this case I would put car so in this sort of relationship we have car at the top um and we have Future car at the bottom inheriting all of the properties and the functions from the car class in this case Future car would be called a subass of car and car would be called the super class of Future car and some people might call it the parent class so car is the super class or the parent class or maybe simply the parent of Future car let's go back to our playground and take a look at what this means um for our code here so you can see that my ride is still a car object and it still has top speed and it's still has drive but take a look at my new ride right it's a future car object and remember inside future car we've just defined fly we haven't defined anything else in here but if I type in my new ride and I press dot here and let autocomplete do its thing you can see that Future car actually has a drive function and actually has a top speed so you know if I do top speed you can see it's 200 and if I do drive you can see that now Future car or my new ride rather is also driving at 200 and furthermore actually my new ride can also fly okay so there's flying now there's actually a problem here because right now my car and my future car they're both driving at the same speed but remember the future cars are faster right initially I wrote the top speed was 250 so in this case what we can do is to do something called overriding and that allows you to take a function or a property from the parent class or the super class uh and redefine it to essentially that's where the word override comes from so you're overriding the parent version of that function and you're providing your own implementation or your own version of it let me just do it here so you can see what it means so we use the override keyword like that and then we have to declare Drive exactly as it is in the parent class so uh what we're doing is we're going to say print driving at and we're going to instead say top speed plus 50 because this guy goes faster so now you can see that when I call this guy when I call Future car. drive it doesn't use the parent classes Drive function it uses its own overridden definition of what Drive is right so that this is the code that it's running here and you can see it's driving at 250 okay so that's an example of overriding to provide um your own custom functionality now inside this overwritten method there is a way that we can access still um the parent functionality and you can do that by using the keyword super so let me show you what I mean inside this overwritten drive function I can actually access the parent class the definition um all the functions and properties in there if I type in super Dot and then I can access drive so when I do this super refers to the parent class or the super class and this Drive function is actually calling this guy up here right so in this case it doesn't make sense you can see in the console uh when I type in future car. drive it you know it calls the original definition of drive and then it prints this you know its own definition of drive so you know in this example doesn't really make sense but sometimes when you're building your apps what you want to do is add functionality and not override the functionality if that makes sense so you don't want to Place what's uh in the the parent class you just want to add to it and so you can do that if you you know you can call the original definition and then you can add your own code before or after that um to provide additional functionality so in this case maybe I'll just change the statement here and Rockets boosting at you know 50 or something like that so let's see so now you can see that uh this is my original car right when I call drive it says driving at 200 and then my future car is driving at 200 and it's doing something extra and so that's that's how this over it and function works okay so this is a simplified example of how subclassing works but it's essentially how it works and it's very predominant in the Swift programming language as I'm going to show you in the next lesson as you can can see inheritance allows you to save a lot of work by taking what's already there and then improving it or providing you know alternate definitions so you don't have to redefine everything all over again but you can build upon the classes that you already have okay thanks for watching please help me continue to create more videos for you by giving this video a thumbs up and subscribing to the channel uh I'll see you in the next lesson bye for now