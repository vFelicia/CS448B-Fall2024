In this video, I'll show you how to read and write data to your Cloud Firestore database by now, you should have set up your Firebase Project, your Xcode project, and added the Firebase SDK to your Xcode project. And if you haven't done that already, don't worry, because that's what we covered in the last week's video, which you can find right over there. Hey, Code crew, my name is Chris, and if you're new here, welcome. I've been teaching Beginners how to code and build app since 2013. So if that's what you want to do, you're in the right place. If you're just starting out and check out our 14 day Beginner challenge right over here. We have a community full of people going through the same thing right now. All right, with that said, let's dive in today's topic. All right. So here we're looking at our empty Cloud Firestore database. In the last lesson we had set up this Firebase project, initialize this database, and we have picked the server location where this database is going to be stored. And essentially, that's where we left off. So before we can dive into reading and writing data updating and deleting and all that fun stuff, we have to first understand how our data is being stored inside this database. In order to understand that there are only two terms which you really need to understand document and collection. So the data that you want to store is organized into documents. And then a collection is simply a collection of documents. And then finally, inside each document is where your actual pieces of data are stored, and the format that that data is stored in inside a document goes like this. Each piece of data has a label, it has a data type, and it has the value, which is the actual piece of data. So perhaps the easiest way to understand it is visually by starting to do it. So let's go ahead and click this Start collection button. Essentially, we are creating a folder, name or folder to contain documents. So let's give this collection an ID in the demo for this video, we are doing a sample sort of like a small todo list. Each document is going to represent a Todo item. So I'm going to give this collection I'm going to call it to do because it's going to contain all the to do documents. So I'm going to call that. Let's click on next. The example that they give here is, for example, if people can create user accounts in your app, you might have a user's collection. And inside that collection, each document would represent a user. And then inside each user document would contain all of the individual pieces of data for that user. So let's click on next. And here we are going to add the first document within the troduce. You can either manually specify the ID. Keep in mind, this has to be unique. So I'm just going to hit auto ID. It's going to generate that for us. And within this document right here these are going to be the actual pieces of data. Remember what I said before? Each piece of data contains three parts, the label, the data type and the actual value. So for this document that represents a todo item, I might put maybe the task or maybe let's just call it name. And this is probably what the user would type in. Go buy groceries. And this is the data type for the value that you want to store. String is text. And there's different types you can put. Now you can have one field, you can have multiple. So I'm going to hit add field again to add a second one and this one I'll call it notes, because maybe when we let the user add to item, we'll also let them put in some notes here I'll say maybe go with ten or something like that I had saved. There you go. We have our first collection. And within this collection we have a single document inside that single document. We have the actual pieces of data so you can see the field name or the label, whatever you want to call it along with its associated data. Let's go ahead and try a second document. Let's go hit add document and this is going to be added inside our two Duce collection. Go auto ID again. And here's the interesting thing. I don't have to put the same fields as I did for the earlier document. I could have completely different fields, completely different data types, completely different data. It's just going to make it a little tougher when you retrieve that data. If each document is completely different, then you're going to have to add the appropriate logic in your app to identify that and to react accordingly to keep things organized. I'm going to have the same fields. So I'll have the name string and this one maybe like go to the gym. And again we add another one and we'll keep it simple. Maybe this one leg workout. Save it. Alright. So now we have two documents. You can see that the data is inside each document and these documents are inside the troduce collection. So here's a simple data structure with some sample data which we can start working with inside Xcode before we leave here. I do want to note that inside each document you have the ability to start subcollections, which can contain sub documents or just documents. But essentially this chain can go on. So you can have a collection of documents. A document can have, you know, a sub collection within that document which could contain documents, and those documents could have subcollections inside them. And the chain can go on. So this is how the information is organized in your cloud Firestore. These are your root collections right here. So we're going to leave it at this level right now. We're not going to do any subcollections and go, well, fancy, this will be enough for our demonstration. And now let's jump into Xcode and see how we can work with this data. All right. So let's take a quick walk through of this demo Xcode project that I set up. And actually we started setting this up in the previous lesson in part one, where we set up Firestore. We had created this Xcode project and imported the Firebase SDK. Now what I've added since then is simply a view model. And this view model is an observable object. And so far it contains a list of strings. It's just an array of three string items. And what's happening in the view right here is I've got a list element, and it is. It is observing the list property of the model, and it's reading that and it's displaying each of the items in that array in a list component. Now, what we're going to attempt to do instead of using these hard coded items is to fetch the data from our database. So instead of Apple, banana and Orange or whatever I had, we want to say go to the gym and go buy groceries. Essentially want to list the names of these two two items. First of all, though, we need to create some sort of data model inside of our Xcode to represent these data items, because as it stands right now, even if we fetch that data from Firestore database, how would we represent them? How would we organize that data? So what we're going to do is create a struct. So I already organized these things to create a couple of folders for views, view models and models. This would be a data model to represent the data or to model the data that we want to display. Let's go new file, choose under iOS, choose Swift and we're going to call this a to do. So this is going to like an instance of this struct is going to represent a single to do. And typically what you want to do is just mimic to mirror the properties that you have inside your database. So for each to do item, you can see we have a name and we have a note and the data type for these or strings. So I'm just going to mirror it here. Name is a string and also notes is a string. The other thing that we want to capture is the document ID, because when we go to let's say update the data in this document or to delete it, even we're going to need that ID. So we're actually going to capture it in the property up here. And that's also strong. And because we're going to want to display a list of these to do items inside a Swift UI list component like this, what we can do to make our lives easier is have this conform to identifiable, and that means you just need an ID property here. And then when we display that list of to do, we're not going to have to specify that ID parameter, but we'll get to that. Okay. So what we've done here is we've created a struct to do that represents our documents to do documents right here. Next, what we're going to do is go back to the View model and change this list right here instead of an array of these strings. I want this to be an array of our to do items, and I'm going to create an empty array that is going to contain that. Because what we're going to do now is create a function or write a function that is going to go and fetch the data items when it comes back to then store on this list. And because this is a published property, it's going to the View code that we have here in Content View is going to pick up that change, and it's going to then update visually what you see in the user interface. So let's go back to the View model. Let's write a function. We'll call it Get data, and let's take a look at how we can do this. First thing you want to do is import Firebase so you can use those Firebase libraries in the Firebase SDK. I want to get a reference to the database and read the documents at a specificAPI. So this part is easy. We're gonna create a constant called DB, and then the Firestore class actually has a static method called Firestore, which returns the instance to us or the reference to that object that we're going to use to interact with our database right now that you have a reference to it. Let's use it. So DBT collection and this lets you specify which collection you want to access for us. It's going to be to do so that's what we're going to put right here as a string. And then next you could do several different things from here. You could create a new document within that collection. You can remove a specific document. But what we want to do is fetch all the documents inside this collection, and there is a method to do just that. It's called Get documents. We're going to use this one right here with a completion handler. And if we double click this, it's going to open up that closure that gets executed when the database call comes back. So this is going to perform that query, grab all the documents from the Todo's collection. It's going to come back and run this block of code right here, which you can customize note these two parameters, which are optional parameters. These could be nil. Any errors that happened will be stored in this parameter, and the actual documents that come back from this query are going to be stored in this snapshot parameter in a property called documents. So let's go ahead and try that out. First. Of all, I'm going to give these two parameters a name, snapshot and error. We're going to want to check for error first. And this way, if there is an error, we probably want to show that in the UI tell the user didn't work, try it again later or handle it some way. So if error is no, that means there are no errors, right. Errors or otherwise, you're going to want to handle the error. Okay. So if there are no errors, what we're going to want to do next is make sure that snapshot isn't mill because this was optional. Right. So we're going to say if that snapshot equals snapshot, that's going to let us use the same parameter name. And while making sure that that isn't mill, we're going to want to get all the documents and create to do to do essentially instances of this struct. Okay. So like I mentioned inside snapshot, there is a documents property, and this is an array of all of the documents. This is going to be a dictionary where the keys are the fields right here in the values are this right here. So I'll show you how to extract that data out from each document and put it into an instance of it to do so, one way you could do this is you can use a for loop. You can say for document in snapshot, documents and side here you can create each to do, but you can also do it this way. So snapshot do documents, dot map, and then let's open that up into a closure. And then here you can put let's see. Maybe you put D for document and here essentially gives you a chance to transform each document into to do so. This map function basically iterates through that array, and it performs this Xcode on each of the items, and then return that result to you in a collection. So for each document inside documents, we are going to instead return a new to do if that's what we want to change it to. Right. And in order to create it to do, we need to supply three pieces of information, the ID, which is going to be the document ID, the name and the notes. So let's go ahead and put do document ID. So this is a special property of the document, and that is going to be that document ID right there. But for these pieces of data inside the document, we need to use it as a dictionary to extract that. So it's going to be and we're going to specify the field name. So in this case it is a name. It doesn't know what data type it is. So we have to cast it. So we're going to say cast it as a string. If, for example, it's missing, maybe it's Nill. We are going to use the no coalescing operator, the double question Mark here. So if it can find this, if I can't find this this key value, pair this field and value it is going to put an empty string instead. So for notes, we're going to do the same thing. No, we're going to try to turn that into a string. If that doesn't work, we're going to put empty strings like that. So essentially for each document, it is going to return a todo item with the information from that document. And then here because it's going to return an array of information. Right. We are just going to assign the result to list right there. Okay. So self dot list equals that list right there. Right. So yeah, doing that is going to update this publish property, which is going to cause the code in here to detect that change in model list, and it's going to change the UI. But do note that this is happening in a background thread. So when you send out that request to the server or the database to get that data back, it's happening in the background and when from the background. When we run this code, it's going to cause a UI change. Whenever that happens, we don't want to do that sort of work in a background thread. We want to do the it foreground. And so since at the time of this recording we're still using Iowa 14, we are going to use the dispatch queue to put this back on the main thread. So dispatch Q dot main dot async update the property, the main thread since it causes UI changes, and then create a todo item for each document returned. Alright. So let's give this a try. We're going to go back to Content view, and then we're going on the initialization of this view. We are going to say model dot get data. Okay. And since this list property is now an array of to do items, we have to display the name, item name and we can get rid of this ID property since the two destructive identifiable. And let's run this in the simulator. See what happens now. There are a couple of things I'm glossing over. If you know, keywords like identifiable is is foreign to you, then you definitely want to check out our Beginner series and maybe even our Swift UI foundation course. Alright. Perfect. So from here you can see that it hit our Firestore database. It's fetched the two documents and it has put them into the list right here. And our View has captured that and updated what is visible to the user. Next, let's take a look at adding items into the database. So we're going to add a couple of text fields down here with a button to just insert some todo items into this to do collection. So first of all, go into the View model and I'll show you what the code looks like before we even get to modifying the UI. So up here let's say add data and we're going to pass in two pieces of information, the name of the to do and also any potential notes for them to do so. I'm going to say name, string, note, string. And then once again, we get a reference to the database. And then we add a document to a collection. So this is just like we did before Firestore, Firestore, Firestore. And then down here we use that reference DV DT. Well, first of all, specify the collection so that we can indicate which collection we want to add a new document to. This is going to be to do. And we're going to say add document. Now there are two different ones. This one is just add the document and you don't really care about what happens next. And the other one which we're going to use has an extra parameter that executes when the call comes back from the server. So this parameter is the data that we are putting into the document, and this one is the code that we want to run afterwards. So first of all, let's take a look at what data we want to send. We're not going to have to worry about the ID here because that's automatically going to be generated. This dictionary is going to be representing the data inside the document. Right. So we're going to specify a name key, passing the data there and in notes, key and passing the notes data. So again, this is going to be a dictionary. And first of all, we're going to put name and followed by the value. This is how you specify a key value pair for a dictionary and we're going to pass in name, which is what is what we're going to pass into this method. Okay. The next key value pair notes followed by that parameter notes. And then for this completion, Hamo, double click it to open closure. And it only has one parameter called error. And this is to let us know if there was any error in creating that document and adding the data. So here let's check for errors if error is nil, right. No errors. So this shouldn't be a comment. Handle the error in here. This is going to be if there are no errors, we want to fetch the data again so that we grab that latest to do item. So I'm just going to call self dot get data from here. And this is going to cause this to run, which is then going to grab all the documents in the deduce collection, and it's going to dispatch the result into the main thread to update the UI. Alright. And that's how simple it is to add a new document into a collection and the UI. We're going to want to add some text fields. So first of all, we're going to have two text fields, one to write the name of them to do, and the other to write the notes for this to do so, and to specify two state properties here. So we can capture that data from the user or name or notes. And what we're going to do is we're going to put this list into a stack. Alright. And then we're going to have a divider here followed by another V SDK, but two text field field name and we're going to bind it to this state property here. So whatever the user types in, it's going to be captured in that property. So in order to specify binding, we use the dollar sign. I have another text field notes. Right. But these text fields by default, the style for them is it doesn't have an outline. So I'm going to specify a text field style as a rounded border text field style and do that for both text fields. And I'm going to have a button down here. The button is add to do item and the action is call add data. Well like to add the to do item. So model do add data. We're going to pass in this information and this information and then after that we're going to do the text field. So let's take a look at how that looks. I think we might have to have some padding, actually. So why don't we specify group and put actually, I'm going to make this a stack spacing of let's say five and put these three in it on V stack because I have some special padding. Alright. So let's take a look at how that looks and see if we can actually add some data to our Firestore database. Alright. So we've got our thing here. Let's add a clean the kitchen, take the garbage. Okay. Let's add that. And you can see that instantly. We have our list updated. That must mean that it did go into the database. There it is. Alright. That's how easy it is to add items into our cloud Firestore database. Next, let's take a look at deleting deleting. Is it's pretty easy as well? So what we're going to do is go into the View model and add a new function called delete data, and we're going to expect a todo item to be passed in. Maybe we'll call it to do to delete. Okay. And again, get a reference to the database, specify the document to delete. So let B equals Firestore Firestore. And then here B. You could have to specify the path to that document along with the document ID. Let's say we wanted to delete this one that we just added right here. Right. So we're going to have to specify the path to do and then the document ID right there. Right. So it would be document path. And here we specify the specific document ID. However, we are passing that into the method right to do to delete ID and then delete. So you can either just call that method and be done with it. You don't care if it actually got deleted or not, or you can call delete with completion, which again just like when you add data, this closure gets called after the request returns so you can check if it actually deleted successfully. All right. No errors. We probably want to immediately remove it from the UI we want to it was successful. There were no errors in deleting that document. Then we probably want to remove that document from this list right here. So in that sense we can say list dot remove repo all were so we can specify condition. So remove all instances where let's open this up. We're gonna check for the to remove. So return to do is equal to we're going to check against the IDs. So to do ID equals to do to delete dot ID. Okay. So self list remove all. And because this is modifying this list, which is going to affect the view code and then have it reflected from the UI. We want to make sure we do that in the main thread dispatchqueue main async so move this right there. Update the UI from the main thread to do that was just deleted. So if so, it's going to go through this list of tides and if and for each to do it's going to check it against the ID of the one that we wanted to delete. And if it's a match, it's going to remove it. Okay. Now from the UI we need to call that. How are we going to call that? I'll probably add a little X right there. When I was 15. Releases will be able to really easily swipe to delete a probably what I'll be doing in the future. So I'm going to actually use an H stack here instead of just displaying that you do. I'm going to do a spacer followed by a button. And for the action it's going to be for the action is going to be calling model delete data and we're going to pass in the to do to delete it and then for the label. Let's do an image. I'm going to use SF symbols here. Symbols. This still in beta. I don't know because this one hasn't updated this in a long time, so I don't know if it's still in beta, but I think there's an X there minus circle. So we'll do that copy name. Okay. Let's run it now. Take a look. Okay. So I'm going to tap on clean the kitchen. Boom. It's gone and it's gone from here as well. Awesome. Last but not least, let's take a look at how to update data. Now. I don't have a let's see. I think I'm going to make this simple because I don't want to create additional new UI to do it, because the actual code to update data is very similar to adding data. Right. So let's put in to do here to do to update. Let's start with a reference equals Firestore Firestore, and then for this one, it's going to be DB collection. Again. We're always specifying the path and this is going to be we're going to specify a specific document, right. Because we want to update. Like if we want to update a piece of data, we need to know which document we're updating. So we're going to specify here to do to update ID, and then we're going to say set data in here. There are a couple of options at the core level you're passing in a dictionary. Now that dictionary containing all the key value pairs and things like that, you can either replace you overwrite everything that's existing in that document or you can choose to merge. So if you just specify set data and then you go to update name and then I'm just going to do a trivial example here like updated to do name hard code some stuff here. Okay. So when you run this, what is going to happen is whatever document ID you specify here, whatever you reference, it's going to replace any existing data is essentially going to blow away whatever data is in that document and replace it with what you have here. I could have three fields. I could have multiple fields. I could even have one field. Let's say I just specified this just a name and updated to do name. And let's say I targeted this specific ID. It would blow this away. It would get rid of these two pieces of data and just replace it with that one piece of data. So essentially it's overriding rather than updating. However, there is an extra parameter called merge. And when you hit merge and you say it's true, you want to merge, that means instead of overriding, it's going to combine. So let's do an example. Let me just inside here space or delete. Maybe I'll just add another button here. Essentially, I'll copy this. And instead of calling delete data, I'll call update data to delete. This was to do to update. And instead of minus circle, let's give it a plus like an edit the pencil pencil. Okay, so that's going to be our update button. Let's run this right now. Take a look at what happens when we actually tap on it. Okay, so go to the gym. I'm going to tap the pencil. And this is going to call this method right here. And it's going to target that to do document and it's going to set name to updated to do name merge is true. Wait. So that just disappeared inside the database is gone too. Tonight. Delete it by accident. What happened here on. Alright, so after some quick Googling, I figured out what was wrong. It turns out that these Swift UI buttons, when put inside a list row, sort of behaves in a special way where tapping on the row itself will trigger any and all buttons in there. So one way to work around this is to set a different style for this button. I know it's kind of weird, but we set this to a borderless button style. Then it's not going to get triggered when we tap on the row. It's not going to trigger both of these buttons, because that was why when I was tapping on the pencil. It was also triggering delete. So we weren't really seeing what we wanted to see. All right, so now let's launch it in the simulator and we are going to read some data because I got rid of all my to do. I don't have any right now let's add over the gym, blah blah and take out the garbage. Hello. And we can see these buttons here. Now, before I just realized before we try hitting update, I actually want to do a different one here. I want to make sure that it is successful. So set data. We're going to do the one with the document data and the merge and the completion. So for the document data, just change the name updated. Maybe we'll keep we'll keep the old name, but we're going to add updated to it. Merge is true. So I'm not going to override it completely. And completion when it returns. We want to just refresh the data. So I'm going to give it a parameter name there. Check for errors just like before. If error is nil, then we're going to say get the new data. Self get data. So now let's see what we have. If we take a look at the database right. We have take out the garbage. Hello and we have go to the gym. Blah blah. Alright, so I'm going to hit edit on, take out the garbage or actually let's do hit edit on. Go to the gym so we can see what happens here. Oops Breakpoint. Alright, now it's changed to update. Go to gym in the database. Updated College, but you can see it didn't it didn't blow this away. However, if we didn't specify merch equals true, it would have blown everything away and then replaced it with only this new updated name. So that's how you update data. All right, now you've got the basics of how to work with cloud Firestore in a Swift UI app. If you want to take this further and actually use Firestore in a real app, check out our Swift UI databases course where we do just that. And if there's something else you would like to explore on the Firebase platform. Do let us know. Go to roadmap code with Chris. Com. Click over to the ideas tab in there. You can suggest new video topics and vote on existing ones. We review regularly and we take video topics from there. And lastly, if you enjoyed this video, please give it a thumbs up. Consider subscribing to the channel. I appreciate that you watched it so far. Thank you for watching. I'll see you in the next one.