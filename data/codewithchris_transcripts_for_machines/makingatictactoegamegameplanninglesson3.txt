before we start to code our game we need to understand how it's played and determine how we can declare a winner X's and O's is a very simple game you start with the three by three Square and one player is designated as the X player and the other as the O player and they take turns placing an X or an o in one of the available slots a player wins if they can claim three squares in a row now these can either be three across like any of these moves or three down like these or in either of the diagonal directions so to code our game we can assign a number to each of these squares and a winning combination would correspond to the player having secured any one of these three combinations of squares so the winning combinations are the ones highlighted so the key then is that whenever a player makes a move we need to determine whether or not within the array of moves there is a winning combination before we start doing any coding I want to set up a new Branch so it'll be easier to roll back to the previous video should I make any breaking changes I can select the current branch which is our main branch and then create a new Branch from here I'm going to call this game planning now before I start that add any code to my project however I need to figure out how one can determine if our player's array of moves contains one of the winning arrays I like to use a playground to test things out so let's create a new playground here I'm just going to call it game planning for reference because I'm going to need it later I'm going to replace the text view here with a property called all that will be an array of all possible moves let me also create another property called winning moves and that's the array of arrays where each one is the array of three winning moves so there will be eight arrays within this winning moves array so first one two three the first row across and then I can duplicate this seven more times and replace each one of these triplets in the arrays with one of our winning move arrays in any given game a player will have made between 0 and 5 Moves before we've either reached a stalemate or a combination of one of those moves might match one of our winning moves so let's create a function called check winner that'll have one parameter that I'll call submitted moves and that's going to be an array event that will represent the array of moves made by a player at any given time we'll return a Boolean value representing whether or not that array contains a winning move now I've seen a number of different ways to do this but this is the way I do it first I check each of the moves in the winning moves array using a for each Loop then if moves all satisfy where the submitted moves contains will return true what I'm seeing here is that of each of these items in the winning row is contained within those submitted I must have a winner so I'll return true otherwise I return false and I can test this by printing the result of passing a random array of ins representing the moves like this when I run this playground I get true because the subset of that array must match one of the winning rows and that is the one five nine row now if I change this 9 to an 8 and then run again it fails and I get false so let's return to our project now and add some more models to our game models file the first is going to be an enum to represent the game piece which will either be an X or an o so I'm going to make this enum a string and just use x and O as the two cases now remember I have those two assets that we added and they're named exactly X and O so if I return now to my enum and the file here I can change the import to Swift UI instead of foundation and then I can create a computed property that'll be an image that simply returns an image made from the case's raw value next I want to create a player object so that I can keep track of which game piece the player is using the name of that player the number of moves that they've made along with whether or not they are the current player so let game piece will be a game piece type the name will be a string the moves will be an array of int that will initialize as an empty array and is current is a Boolean property that will be initialized as false so when we create a new player all we're going to have to do is specify the name and the game piece type next I want to create an enum that I can use as a namespace to give me access to all the possible moves and all the winning moves from anywhere within my project so I can return to my playground then and copy these two properties of these two variables and now I can paste these into the enum but I'll need to make them static properties so now using move dot all it'll give me access to that first array and move dot winning moves will give me access to the full array of all winning moves and I'll be able to use those somewhere else and that somewhere else is going to be within my player struct and from here then I can create a new computed property that I'm going to call is winner that's going to return a Boolean property if we return to our playground the body of this function is going to return a Boolean based on the value of submitted moves which in our case will be the moves stored in the move property of the player so I can copy the body from here and then paste it into the body of our computed property well winning moves is unknown but we have that enum move that's our namespace that'll provide us with that and then the moves Must ALL satisfy the fact that each one is contained within the moves array for this player so we'll need to specify self so as not to confuse it with the iterated moves well now that we have our game models and a way to determine if a player is a winner or not we can start to code our game which we'll do in the next video but first let's Commit This good work to our git Repository and we'll create a new Branch when we start that next video