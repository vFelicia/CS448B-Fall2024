in this video we will add a unit test target to a project that didn't have unit tests to begin with and then we are going to mock our network request so that our unit test will be getting data from a local json file as opposed to going to the network going to the internet and getting data this will isolate our unit tests to only test our personal code as opposed to testing the internet hello my name is michaela caron i am a fulltime ios developer and freelancer let's get started with unit testing the first thing we want to do is download the project that we're going to be unit testing so open terminal so you can hit command space and then in spotlight start typing terminal and it'll open or just you know use the spotlight search which will give you the same thing or if you really want to open it via finder so first thing we are going to do is go to our desktop so we want to type cd and then desktop and this autocomplete is part of one of the things that i have added onto my terminal so we do cd desktop and then hit enter and then yours will probably say like michaela carrera macbook pro or you know whatever your name is and then it'll say desktop so that's how you know you're on your desktop and if you type ls and hit enter i have a bunch of screenshots and a folder called testing but you should see whatever files are like sitting on your desktop and that's how you know you are in the right spot then i hit command k and that's how you clear the terminal and what we want to do is clone this project so the url will be in the description and or you can search it on github with code with chris and then yt vapor ios app so we are going to be unit testing the ios app that i created during the vapor series so if you want to see how this app is built go ahead and check out that series that'll be in the link in the description so we want to clone this so to do that click the drop down for code and select one of these you have to select the right one so typically almost everybody will use this https and you just copy that but to do that and actually use it you have to set up your personal access token with github for it to all kind of work if you don't want to do that you can use ssh which again you can see you have to set up a public ssh key which i haven't done but the one i personally use is github cli which this is just if you click on this learn more button um it allows you to like use github from the command line and i think that's super cool so i use this one and my github in terminal like on my computer is authenticated through that as opposed to https so pick whichever one you want and which one works if you don't know i would say they're both kind of easy i was sort of easy i would say pick https the github cli is actually not too bad it takes you through how to use everything this is kind of off topic real quick but if you download the command line tool right here it literally tells you how to authenticate which is not too bad but that's the one i'm going to use so we will copy this and then all i have to do is paste that if you did use one of the other two you'll see it's just a url so you need to type git clone and then paste this because if you just paste that into the terminal it won't work you would have to do git clone and then paste that so it would be like this but i'm going to use the github cli version so i just type exactly what was in there for mine because it has a gh repo clone and hit enter and then you can see it cloned it to our computer but we're still in the desktop directory so we type hello ls and hit enter and then you can see the project is yt vapor ios apps so we want to change directory into that one yt hit enter and see this is why i have this uh what is it plugin thing on my terminal because it like auto completes for me and i think that's super cool so if you want to use the same uh what is called plugin thing that i use on mine it's called fig it's called fig.io so you can download that if you want to okay so now that we have downloaded it you can see that we're in lesson three because there's multiple different lessons that's how i split up the project is lesson three goes into like building part of the app lesson four i don't think we even do anything and then lesson five is where we finish the rest of the app so we want to check out the lesson five branch because that's the one that has the finished code in it so to do that we can save git checkout and then we want to check out lesson five and then you can see it says branch lesson five set up to track remote branch from origin and then we switch to lesson five so the first part just means we're tracking the lesson five branch like in github and then it's called origin that's the name of the remote and then we switch to it which is what we want and you can see it in my terminal because of the plugin stuff that i have but also um if you type get branch and hit enter you should see we have lesson three and then five and we know we're on lesson five because that's where the little star is okay we have cloned the project but we need to open it so we could type open space and then a period and this will open it in finder for us like at this uh directory that we're in and then we just double click on this or you can type open and start typing the xcode project so it says open ytvaperiosapp.xcodeproject when you do this and hit enter it automatically opens the project for us now that we've opened the project let's see what it looks like so we are not going to use my iphone we're going to use the simulator i like the iphone 13 even though i don't have it as you can tell right there so let's run the project so if we click command r we have run the project and this is what we see it is just your basic crowd application meaning create read update delete so all it can do is fetch a list of songs so here's a list of songs that i've been listening to lately if we click the plus button here because this was very minimal there's literally like no title or anything telling you what to do but all you do is type in a song name so let's type in stay is another one they're songs if you click add a song we see that we added the song to the list and then we can click on the song and modify it so that's the update so update song okay rearranged that's okay we do that and then we can also delete so let's say kill this love delete and that's about it that's all the app does is those four different things but now we want to unit test it so this project was not written with unit tests so we want to go and add that add them manually so we can do that in a couple of ways we can go up to file and click add i think oh yeah i don't remember okay we click file and then click and then hover over a new and then go down to add target so we click on that and then this big list of things come up of pretty much a bunch of different stuff you can do in ios so make sure you have ios selected and let's filter this and type unit and what we want to add is a unit testing bundle so if we click on next we can do it this way another way to add unit test is to go over to the third well sixth little icon here if you hover over it it says this the test navigator so under here you can click the plus button in the bottom left and then just directly go to new unit test target which this would be the easiest way so if we would have clicked next on that other screen this is where we would have ended up at so this is our project name which it has a lot of hyphens in it and then it just tacks on tests at the end so that is fine with me or you can just call it like unit tests but i would just keep the default name it's easier we are under my team organization identifier we are writing swift then that's the project that we're in and then the target we are testing so target to be tested is this project so go ahead and click finish and then you'll see two things appear right here but let's go back to the project navigator in the project navigator we can click we can see a new folder called yt vapor ios test and you can see these are both at the same level but they're complete they're separate from each other now even though they're in the same xcode project so that's the name that we gave our test which was that really long name and then by default it creates a unit test class for us like we saw last time so let's just keep this one i do want to delete the test perform performance performance example we can leave those ones and then over in the test navigator that we saw this is the class name that we have right here so if we were to change this it would change right there which we're going to change it and then test example this is our one unit test that we have so if we want to run our unit test we click command u and that'll go ahead and run everything and you can see the project ran really quickly so it opens but then over here our unit tests pass because we're not doing anything so the first thing we're going to do we are going to be testing our view model so we can open all of these most of them actually we don't need the views we are going to test the song list view model and test fetching songs so this will go and perform a network request using async await so if we click on fetch and see what this does we can see right here that it uses url session to perform a network network request we make sure that we get a 200 back we decode the data into some kind of json object and you can see this is pretty this is generic i was going to say pretty generic but it is generic and then we return some kind of object but in the songlist view model you can see what we're actually decoding is uh of type song and then we set it to songs the song response is equal to our variable songs which is used in the song list which this won't show anything i don't think so this is just the view but you know right here there is a list but it's a network request so you don't see it on the swift ui preview so that's what we're going to be testing the first thing we have to do though is take out the singleton we want to make this we want to make this class so it is not a singleton anymore so to do that we can delete this private init because we will have an initializer and then we can delete this static variable called shared okay once we do that we will immediately have some issues so if we click command b and try to build it it doesn't build and then if we switch over to the issue navigator so you can click command five like command one is the first one command five yeah it just goes through command two three 234 but here we can see in our songless view model it says no member shared that's because we just deleted this variable called shared so now we have to find a different way to access this function so to access this variable what we are going to do is actually create an initializer and we are going to take in an object of http client and so we need a variable for this let's say bar http client is of type http client oops exclamation point and then inside the initializer set the value so self.http client so we're setting this one equal to this one and so when we are here instead of calling dot shared the variable we just deleted we want to use this object http client and then we'll call fetch so if we build this we still have three errors but that's okay so let's fix this one down here for this is the delete function use http client and now we have four errors we have four errors um because we are using the song list view model and we're sorry we're using the http client in the song list view model and in the ad update song view model okay so we've changed that one let's go click the top error so if we go to the add update song view model we don't want to use the shared instance anymore and now here we also need to use the initializer and we can initialize it with nothing or we have two initializers here because when we are on the song list which i'm going to get rid of the preview because we don't really need it you can see we call the song list the add update song view model with an empty initializer and with a song so inside inside the view model we have two initializers and we want to change it to use our http client but we need the client in both of the for both of them so we create our variable http client and both of them will then take in an http http client and we need to then open that and do the same thing and we are going to copy that and we will paste it down here we'll do the same thing and have this also taken one as well just like that so it's taking it in in two different ways when it was an empty initializer now it has this value and this one where it has a song and the http client you can see this blue over here because this project is under source control so in the project if we were to type git status we can see all of the different files that we have edited and the new file that we added as well but we won't be going into any of this and even if you try to push to this project you can't so it'll be fine if i did this it would work because i have the like developer access but you guys no none of you guys can't so it's okay okay what we want to do next is let's build it and we now we have six errors it just keeps growing this is refactoring um that's what that's what this is actually called is we are refactoring the application to we are changing what the code looks like but not really the functionality of the code so in the end it'll end up doing the same thing so let's go back here we need to use our http client and that messes up this indentation so if you highlight over this and hold ctrl and then click the letter i that fixes the indentation so we have six errors if we build it okay we have five we are getting closer and now here we are missing the argument for the http http client in the song list view so if we click fix because we added that initializer of needing this client we now have to initialize one so we create a new one at this point here and what are the other errors okay we go back to the song list so we're actually at the bottom that was the top of the file for the song list and we go to the bottom we have two different ones so if we click insert so what we are going to do is we are going to copy this one and initialize a new one for each of these so a better way possibly would to actually make the song list um have its own http client and then pass it into here and use the same one for that instance and both of those instances for this it kind of doesn't matter but that may be a better way to do it but this is the way that i'm going to do it for this example so if we click command b and build it we're almost there we only have one more error and this is in the ad update song view model and it's the update song part so let's take away the shared andrew http client and we build it and we still have one error oh it's the preview that's okay okay i still had that my clipboard so do http client to fix that one now if we build it we have build succeeded so if we go and run the application we can see it run and the same thing happens as we it still looks the exact same so we know personally we didn't break anything because we can see it still all working and we can test that by adding a new song so let's add i'm trying to think of one of their other songs and they have a song with four d's i can't pronounce it so we're just gonna add a bunch of these and then click add song and we see the song be added to this list and this was able to properly fetch it so we know everything's still works okay we have built the project we don't have any errors so the next thing we actually are going to be doing is we are going to actually mock the http client so if we want to close all the files and we're at this one http client so we want to mock this one because for it to be a unit test it cannot go out to the network because going out into the network to the internet means our app is relying on something else and what we want to do with you or what we want to accomplish with unit testing is testing our own code and our code doesn't test the internet so we need to isolate it away from the internet so to do that we want to start by making a protocol called http client protocol so a protocol is like a contract so what we want is we want our http client to conform to this protocol and by conforming that means that it has to follow whatever rules the protocol sets so right now if we built it it conforms because the protocol doesn't have anything in it but we want is we want it to have all of these functions in our protocol so we can literally copy like the function signature here and put it up in our protocol and when we build it it still conforms because our class is using or does have a function that the protocol says it must have and the reason we're doing this is so when we mock the client we will mock this functionality and make sure that it won't go and do this network request we will have it go and do something else so we want that one we want to add the send data function and scroll down we want to add the delete function so copy this one and put it up in our protocol so there we go we have these three functions and everything will still work when we click command b and build it because this does conform to this but if we were to add like another function called do something and then we build it we get an error because it says our client meaning our class does not conform to the protocol that we specified add protocol stubs if we click fix this is what happens is it literally says like your you must have a function that says do something otherwise like you don't conform but we don't need that so let's just erase that part okay so we did that but in order to actually use this is we are going to this is the real http client and we'll make a mock client which is a mock class that also conforms to this same protocol so let's go ahead and do that right now so let's add a new file so click on our yt vapor ios app tests and we want to make a swift file so click on next and http client let's call it mock http client like that and then make sure we are in the tests like folder and the target that's selected is the test so not our actual app target and click create let's create our class so let's type final class or we call it mock http client and we want it to conform to http client protocol so i add this final keyword because we're not inheriting from this our other stuff probably should have that but that's okay i'll just add it right there and so we get this error saying cannot find http client protocol in scope that's because our test target is completely separate from our app target code so we created this in the app target so our test target doesn't have access to it does our other yeah our other test doesn't have it either so what we actually have to do is import our code from the the app target so we do that with app testable import and we want to import yt vapor ios app so this is just whatever typically your project is named so if we do that we can see we have a different error of our mock client doesn't conform to that client protocol which makes sense because there's nothing here so if we go ahead and click fix on that we can see what shows up are the three functions right here that our protocol says your class must conform to or must have these three functions for it to work so let's go ahead and click code completion on all of those and we'll do something with that in a second and that needs a return oh well so what we actually want to do is what we want to have our code do right here is instead of using the real http client like this we want to use our mock client when we perform the unit test so the way that we do that is using what's called dependency injection so if we copy the name of our protocol we go to the song list view model we want to use that type instead so we are changing the type instead of using the http client we are using its protocol so this allows us to pass anything that conforms to our protocol so we know the real http client conforms and our mach 1 conforms so when we build this it's still not going to build because the mach 1 i know it does build oh when you type command b that's telling the app target to build by default you can change that but by default our app target does build technically over here our unit test target would fail but if we try to run unit tests if we click command u yeah we then see build failed because we haven't written any code here but if we click command b to build the project you can see build succeeded but here it's we want our protocol to conform or we want to use our sorry we want to use our protocol here as opposed to using the real instance of http client so we want to do that here and we also want to do that in add update view model so if we switch this from client to http client protocol switch all three of those we build it we are good okay everything's building we need to yeah we need to make our mock now so we are going to for focus on the fetching so we aren't going to do anything with these it looks like i think it should be fine if we don't write anything here but if we get an error we may have to write something but we do have an error on the fetch because the fetch returns an object called t and you can see as well the protocol stubs this is what they looked like for the protocol of like t codable blah blah blah but then over here you can see it just says t and then at the end they tack on this and encodable decodable you can write it either way i like the other way because it's kind of a little bit shorter you can do it like that so it says t is of type codeable so that's why it had the where t is encodable and decodable right here so i'm just going to do that to the others because i like it that way instead there and what we want to do is we want to mock our http client so that means instead of here doing the network request we want to do something else and the something else that we want to do is we want to load like a canned response of json that's in our test target so let's click command n on here to create a new file within our test target and unfortunately if we search json there's not really a g like there's geojson but there's not like a json file we just have to search not blank playground we just have to go down to empty no that's a documentation here other another empty file and click next and we want to make let's call it song response dot json and we want it again in our test target and make sure down here in targets it's our test target here not our actual app target and we click create so what we want to do is add a fake song response we are going to pretend like we'll give a json response back like what it would see from the server so here we are going to use this one so this is what the json looks like from our server it's literally just a title and a uid you could copy this exact one or type something else but it does have to look like this because if we look at our model it's a u it's a of type uid so it will have to whatever string this is it will have to parse to you uyd you i don't think would just be able to type like one two three but you can try it at c and let me know or i might test that later but that's what it's going to look like right now so that's our song response that we have so now we need to make this function go and get that response but to do that we are actually going to add a new type as well so if we click command and again we this one will be a swift file and let's call this mockable so again make sure it's test target and we're good so if we click enter or create we create a new file called mockable and what we are going to do is make a protocol and i got a spell right protocol called mockable and it'll conform to any object and what we want it to have is a reference to the bundle so that'll be var bundle and this is a get only property so when you make protocols you have to say are they getters or can you get the value or can you set the value so can you read or can you write you can do both or you can do not one or the other you can only have a get but if you have a set that means you also have to get it have a get if that made sense and then we'll have a function called load json and again we'll make it generic so this can conform to just decodable because all it's doing is decoding the data oops t so this means load json and we will load with a file name and then a type and the type has to be decodable so now we are going to make an extension to our protocol called mockable so an extension for protocols this means that like by default we're going to make default functionality for these two different things so when we have some object that conforms to mockable it can choose to use the default implementation or overwrite it and create its own implementation so we are going to use the default one so for this we need a variable called bundle and it's of type bundle and we are going to return for type of self and then and actually i don't feel like typing the whole thing out again so we are going to copy that paste it and then actually write something here so we're what we are going to do is we are going we are going to decode data from this json file so to do that we have to get the path so not get guard let path equal bundle dot url we are going to use for resource with extension so the first one and this is oh sorry not song response that's the one that we will be using but this is generic so that's file name and then with extension json so this could load any json file so you could really in the end copy this and use it in like any project and then we could have let's throw a fatal error with a message which is more descriptive than just like a print statement and just say fail to load json file but if all that works let's go ahead and have a do catch block and what this is going to do is let data is equal to try oh whoa not that one that's contents of that's what i want so let data equal try data contents of path and what this is doing is turning that that just says it by from data but it's taking this making a data object out of it and then what we want to do is decode that so let's do let decoded object equal to the jsondecoder.decode and we want to decode into of type t.self so it's an array of objects that are of type t so for us it'll be song and then from the data so that's that variable so we want to decode this data into that type and then lastly we will return the decoded object and then we have to write something in our catch statement so for this i like to put some print statements and use a emojis for everything because i think you can tell what's happening when you have emojis because like your console will look like something like this and it's confusing to find where things are so i use emojis for everything and again that was a shortcut thing i have on my computer if i type a colon and start typing like the emojis come up which is nice or you can type control command space and that's the default whoops emoji picker thing and you can also find that from edit and then go to emoji symbols you'll find that on under edit for like any application that has a text field so we want to do that and use string interpolation and print the error but we can also throw a fatal error that says failed to decode the json so there we go we have written mockable which is a protocol with the bundle and a load json function and what that does by default is returns the bundle for this target and then it gets the it gets some kind of file name that you pat that you pass into it that some file or json file specifically and we will decode that file using data we decode it into some kind of object and then we pass back the decoded object to return from this function and if that fails we print it and then actually throw a fatal error okay we have done that part now we need to actually use it so if we go into our mock implementation when we fetch the data we want to fetch it from our um want to fetch it from this whole mockable object as opposed to its default implementation of using a network request to the network so this helps us write the unit test because we're isolating our code so if we actually not type that we need to first make this conform to mockable and so it has mockable and now we can write return load json not straw song and this is of type and we're actually not going to write song here we are going to use the t the generic t um closure unused what is all this saying oh this needs to not be that that needs to be a comma and we should almost have everything oh yeah and this needs to be t dot self okay if we build that that builds but that's saying our what is this our app target builds but if we click command u it ran our unit test in our unit test pass because if we go back to them the only thing there is this test example and that doesn't do anything but we know our unit testing code that we have everything we've written down here passes okay that was a lot of code and we haven't even written our unit test yet so what we did was we added a unit test target to a project that did not have unit tests to begin with we have fully mocked out our http client so that instead of performing a network request to the internet we will perform a network and network request and actually go and get data from a local json file and we will go and get data from a local json file and in doing that we will isolate the unit test that we're going to be writing so stay tuned for the next lesson where we actually write our unit test