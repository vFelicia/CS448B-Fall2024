hey everybody my name is michaela karen i am a fulltime ios developer and freelancer let's get started writing a unit test in the last video we mocked our network request so if we open that and open the real one we mocked this http client so what it actually does is loads a json file from the unit test target as opposed to what the real http client does here is it goes to the actual like network to the internet and fetches the data and we were able to do this because this load json file is a part of mockable which is a custom protocol that we created it has the bundle and then the code that actually fetches the json data and with the http client we created our protocol http client and what this does is in our actual song list view model we take in the protocol as opposed to taking in the concrete type so this will allow us in our test to switch out the concrete type with our mock type in doing this this allows us to test our code as opposed to testing the network so when somebody has like a spotty internet connection their network downloading the data would take longer as opposed to somebody who has a fast internet connection so when we unit test we want to take that like completely out of the equation so let's go back to our original file that says yt vapor ios app test let's yeah let's just delete it so click on this and click delete and move to trash so click on the group folder here and click command n to make a a new file and for this you technically you could write a swift file or we can just click specifically on unit test case class and what this is it is a swift file but it sets up everything for you ahead of time so let's call this um songlessview model tess and then it is a subclass of xc test case and we are using swift so if we click next we want to save it in the app test group and then make sure it's in the proper target our test target and click create and when we clicked like a unit test case as opposed to just making a swift file because that's exactly what this is um all this is doing is just giving us all this boilerplate so we're actually going to delete it all so maybe we could have made a swift file but that's okay and you see on the left it says r that's because this project is under source control and so it thinks we were we removed that one file and then added it back and it thinks uh git thinks that we just renamed the file so it's like removing it but that doesn't really matter so what we want to do is make a setup method and the teardown methods so let's type setup and sometimes when you hit enter immediately it has this class function that is not the one that we want we want the normal setup function which would look like this but if you start typing setup again you can see the difference between the two the top one says initial state before a test case begins and then the bottom one says uh blah blah blah calling each test method in a test case so the whole test case is your class but the test method that's our actual like unit test so that's the one we want and you can see it doesn't have that word class in front of it so we want to do this for setup and tear down we want to call this super class so super dot setup and open that setup uh super dot tear down and what we want to test is our view song list view model so let's make a variable for it let's call it songlist vm and it is of type songlessviewmodel so if we try to run the unit test if we click command u it doesn't run because for one it doesn't have an initializer and two it says sunglass viewmodel not in scope so what we have to do is this test target is a completely different target meaning group of like scope of our app so we collapse that this is our test target and then this is our app target and they don't like talk to each other without you saying so so what we have to do is import our app targets code so we do that with at testable import then yt vapor ios app and this will typically be the name like of your project and this says it has no initializer so what we actually want to do is force unwrap it and then that should be good so what we're going to do in this setup is set it to a value because right now we know the type but it doesn't have a value yet so we want to do song list vm is equal to song list view model and we can see it takes in a type of http client protocol and then you know the variable is called http client so what we want to give it is our mock as opposed to giving it the real http claim or what do we call this mock http client and right here so we are setting the mock we're giving the mock to our view model rather than using the real http client here doo doo doo where'd it go like it does right here is where we can pass in whichever one we want the mock or the real one so we want to do that and then in the tear down we want to do not that one song list vm and just set it equal to nil because with setup and tear down this allows us to create our our unit test to have the same parameters when they start each test and when they end each test or no sorry when they start every new test so the setup is run before each test and then the teardown is run afterwards so this is like resetting our state and what we want to do is let's do funk test fetch songs successfully and when we do this we can go ahead and click on the diamond to run the whole class or just run this unit test and we run it it builds our app and says test succeeded which is good because our unit test or sorry our app yeah app test target sorry the test target is running and doesn't have any build errors but this isn't really doing anything because we're not asserting anything in this actual function so what we want to do is we want to test when we fetch songs and make sure that we fetch and receive the proper number of songs so when we look at our mock song response we have two different songs so we want to make sure that two songs are fetched properly so if we try or yeah we need to try first try oh wait songlessvm dot fetch songs um hopefully that works oh errors are thrown that is because we could either wrap this in a do catch or change our uh change the function the actual unit test function to say that it throws so then this should go away there we go and then lastly we want to assert so we want to xct assert let's do xct assert equal and we want to assert that the songs in our view model this the songs is equal to whatever was fetched from here because we can see it makes a url make sure that it's a url object from that string we do the fetch which this will be our mach1 so this will actually go and fetch the loaded json file set it to song response and then here we are setting the song response equal to this variable songs here so we want to do songlistvm.songs.count because it's an array is equal to 2. so we should be able to do that and our test should pass but it doesn't so why didn't this work the way it should have so it says zero is not equal to two so this one is the one that's getting back zero but according to our mock we should be returning our loaded json response which right here there's two values so i struggle with this for a really long time and i found out the reason is because in our songless view model this is a published variable so it acts a little bit differently as opposed to if it was just a normal variable so we have to write our unit test to account for that um where do we go here so what we actually want to do is use what are called expectations so we need to do let expectation yeah is equal to or which one is it xct test why am i not finding it there we go it is called xc test expectation um and then the description is um let's just call it songs so what an expectation is is basically we are we have to wait for something to happen so we think of it like we expect something to happen but we don't know when it's going to be happening so we have to tell the code when will this happen so with the expectation that is defining what is the expectation and it's called songs we could call it like published or fetch songs and then inside of our code here we are calling the fetch songs so that is doing the fetching and using our mock variable but we have to tell xcode how when do we expect this to finish so i thought with the try await it would just kind of work but that didn't work for me because of this published variable is what i found but if there's a different way to do this that you know of please let me know in the comments or tag me on instagram or twitter or tag code with chris i would love to know if there's a different way to do this but this is the one that i found that has worked so with this we want to do songlist vm and we are going to be using combine so we need to import combine at the top so this uses combine and for anyone who doesn't know this is a ray wonder like tutorial but combine it was announced at wwdc and it is a reactive framework so it's as you can see it's for handling events yeah would be the best way to say this it handles um publisher and subscriber so it handles when things happen and who should be listening to those things that are happening is sort of the gist of how all of this works so that's what this is we have to know right here we are fetching our songs and data is going into our songs variable that is a published variable so we need to know when that data was published so we have to subscribe to it meaning listen for that to happen so to do that we're using songlessvm and then dot songs is the published variable that we're listening to and then here we have drop first i will put a link for the um post that i found that sort of gave me all this code that like made it all finally work i'm not 100 sure why we're using drop first this when you look at the definition it says omits a specified number of elements and then down here it says the default is one so it's dropping the first time a value is assigned to it so i want to say that will be when the songless viewmodel is created at first the value is assigned and it's an empty array so i want to say that's what the drop first is but i'm not 100 sure and then sync is actually if we click command click on this and then click show quick help it says attaches as a subscriber with closurebased behavior to a publisher that never fails so this means and you can see see in the example if we have 0 to 3 and we have a that's a publisher and then we write sync we can see what happens for 0 to 3 every time the value of this variable changes so that's what we're listening to is when this value changes and the value should change here because in fetch songs if we go to our mock because that's the one that's being called we are loading the json but if we look at the actual view model here is that fetch so this is loading json and we are setting song response which which is just a variable but here song response is equal to self.songs so that's what we're listening to and then this is what that value is and what we want to do is do xct assert equal and we want to assert that value.count is equal to 2. so we want to assert the value.count because the value is whatever is in here which is the song's array so think of value as the songs array and then it's an array so it has a property called count and that's what we're actually checking and then we have to type expectation dot fulfill so this means at this point our expectation oh um our expectation it's this is we expect something to happen at some point here we go and do something we go to this code finally and then we can say hey our expectation it happened like the thing that we were waiting for finally happened so right here we also have wait for expectation because it's the code may run through here and run through this this is a closure but then we have to say hey wait for something to happen and this is not the right one we want to which one am i writing i want to write this one is weight okay this is the one that we want to use is wait for expectation so we are waiting for expectation so this is an array of expectations so it could you could have multiple of them and then the timeout is after like one second has passed this would automatically fail and the unit test would fail and then the last part of the this part with observing it is we have to put it into let's call a cancelable so this needs to be a set of any cancelable and we need that in our unit test or in our unit test class so we want to force unwrap that so we don't have that error with the no initializers and down here we will pass cancelables so if we command click on this to see more about it this says a set to store any cancelable and if you click on this the docs come up and tell you um incantable object that executes a provided closure when canceled we have this cancelable object and honestly i don't really know how this works exactly i haven't done too much with combine but when we have this sync here it says um it returns a cancel cancelable in instance which you can use to end assignment of the received value um and the deallocation of the result will tear down the subscription stream and then this is what we use for that so you can look and read more about what is any cancelable this type but you can see it's all part of combine which has to do with publishing and subscribing variables and reacting so once we write all of this we should be good so this you can see is from our field unit test when it says 0 is not equal to 2 but then now how it's working is we have an expectation meaning we expect something to happen but we just don't know when we are going to try to fetch songs and this is fetching from our local json file we run through this part which is observing those changes to the songs variable in our song list songlistviewmodel which is a published variable and then once we do have a value we can assert that it is equal to two so we can actually remove it from down here we could put it on either side inside of this closure or not but i've read that it's possible for this to all run before or sorry after this statement would have happened so technically it still may have shown 0 and 2. in reality when that may have not been true it just depends on whatever ran first so it says the best way would be to keep it inside of this closure so we'll erase that one but then here at the bottom we are waiting for our expectation to happen here until we know that there's a value and we know that inside of this sink and then that's when we can write expectation dot fulfill which means like our expectation is fulfilled the thing that we thought would happen has happened so now we're good and so when we go and run the unit test we see build succeeded and that failed why did this fail oh i see so this failed because we unexpectedly unwrapped nil and the reason for that is because we never set a value for this so what this is is a set so we write cancels is equal to empty it's empty array but i believe sets and arrays kind of use the same syntax so that's all we need is cancelables is equal to empty array and we could probably put that inside of our tear down as well okay now we should run this and it should pass and there we go we see this popup test succeeded and our test has passed so it took a lot of work to mock the network request and actually go about writing the unit test but we have now like proven that we can fetch we can fetch data from json and we can handle it correctly in our application so what we've done is we have tested a single thing but if we wanted to know how much of our code base we've actually covered in tests we use something called code coverage so if you go up here and i'm on xcode 13.2.1 right now so this is right here as opposed to it used to be kind of over here for xcode i think 12. um we click on this and click on edit scheme and what we want to do is go down to test typically it's on run so switch it to test and we want to check this box that says gather code coverage and we want to do it only for some targets and we click the plus and right now we only have our actual app target so that's what we want to test as opposed to if you had other thirdparty libraries they may show up here too and you don't want to test those you only want to test your own code so if we go ahead and click add it is noted right here and we click close so to actually figure what that figure out what that is we click command u and that runs all of the tests so if you had unit tests and ui tests it would run everything and that's what you want to gather all what's called the code coverage so we want to know what code is covered under unites and we can see that by going over to this far one over here navigator what is it called it is the report navigator so you can see these are all from like building the project over and over and over and the log of the build so that shows you like whatever it is that you did but we want to check this one that says coverage when we look at this we can expand this and we can see only 37.6 of our code is covered but when we click on it and expand it some more we can go more in depth and see how much of each file is covered so we can see the yt vapor ios app file that is 100 covered and then our actual um http client we can click on this and click this little arrow and it shows us whatever our code is covered or not by this little thing on the left and if you don't have this click this little line thingy and then make sure you have code coverage selected so mine i typically usually have the mini map open as well um i think i didn't have that the whole tutorial but i usually have that open as well but then you can also see the code coverage part which will tell you um this part of the code is covered meaning literally like calling the function but this part is not covered of testing that we got back a 200 response and you can see like individually line by line what is and isn't covered by a unit test if we go to like our song list view model we see most of that is covered and then our fetch songs we covered everything except the actual if the url is not a url object the code can exit at this point meaning it can throw and then the function would end we did not test that path but we tested the rest of it so that's why under sunglass vm we can see under fetch songs that's like 84.6 percent covered and that's how you can check your code coverage and like i said during the introductory video video it depends on what kind of code coverage your company may have or you personally want but overall you should go for quality of tests over a specific number or a specific percentage because it varies it's great like if you write a bunch of unit tests but if the unit tests aren't really useful then your code coverage kind of doesn't matter in the end so make sure you have quality over quantity of unit tests in this video we wrote a unit test that used a mocked network request so that we could isolate our unit tests and only test our code as opposed to also testing the network or testing the internet and we also enabled code coverage for our project