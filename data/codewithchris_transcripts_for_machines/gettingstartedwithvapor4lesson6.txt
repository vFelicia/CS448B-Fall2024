in this video we will learn about async await and what that means for our vapor application let's get started hey everyone my name is michaela karen i am a fulltime ios developer and freelancer let's learn how to use async await swift's new concurrency syntax within our vapor application the first thing we should talk about is what is async await so if we go to this site right here it is github and is called the swift evolution these are the documents for how the swift language is evolving because it is an open source language so if we go to this website which will be in the description below we can see what is async await so we can see information about the proposal and that it's now implemented in swift 5.5 and pretty much how all the decisions came about for this fee this language feature itself async await has to do with writing a synchronous code so right now in the swift language we can use closures and completion handlers but they can be hard to use and they're kind of very confusing at the beginning so what async await tries to do is make them easier to understand to write and then also to read so you can go through this and see all the different information about why they chose to add async await to swift and then there are four i believe four or five different problems of how they describe the reason for it so the first one you can see is called the pyramid of doom of here's a closure here's one more here's another here's another here's another and then we finally get to the result itself so that's the motivation behind async a you can see the playlist by stuart lynch about all about swift concurrency features and that also lesson 4 specifically is about async await the vapor documentation also has information about migrating your code from event loop futures which is what is in our code now to the async away syntax so if you go to the vapor docs and then along the side you click on basics and then click on async there's async await and a little bit lower you see migrating to async await so we'll go through how we do this but here's a little example of what it looks like the difference in the syntax so we're accomplishing the same thing we're just kind of writing it in a different way and hopefully it's a way that's more understandable for everybody so right here this is just a function to get a first user you can see returns an event loop future that is a string so we have user.query so we are querying our database we are unwrapping it and then also throwing in abort not found if for some reason we couldn't find this and then we are flat mapping it to a user we're changing a property and then we return update and then also map that and return a username so this looks very confusing and it's kind of hard to follow and read but when we use async await you can see it's marked as async throws we are first getting a user so we are awaiting to get a new user from the request we get the first one else so we have a whole guard statement else we are deciding to throw a not found error so this makes a lot more sense than seeing this first part here even though we're accomplishing the same thing it is easier to read here we're doing the same thing of changing that one property and then we are awaiting the update and then return user.name as opposed to needing to add another closure here so that's the basics in the difference in the syntax and then let's get started using it within our project the first thing we need to do to convert our code to the async await syntax is we need to update vapor because we need to update and make sure that our vapor version is up to date with all the new changes when they integrated async away into vapor because previously when we first began the series the a sick away syntax was integrated into the swift language itself which is how we could use it with the ios app but the vapor package for server side swift that had not yet integrated async awaits so that's why we didn't use it at the very beginning so now when we use it we need to upgrade vapor so to do that we can type brew upgrade vapor this will upgrade vapor the package the homebrew package on our computer but you could also type view brew update and brew upgrade so this would update homebrew so the actual package installation that we have which is it would update this package manager itself and this side we'll go ahead and update homebrew all of the different packages that we have so if you didn't care about all the different packages that were on your computer you could update all of them at the same time if you wanted to but sometimes that's not a good idea depending on what you're working on so you could just do brew upgrade vapor and i've already done this on my computer so it's probably just going to say upgrade yeah it says 18.5.1 at the time of this recording is already installed and you can see i have something else on my computer that's out of date after we have updated vapor with homebrew now we need to update our code so i have don't have it on my computer yet so we are just going to go ahead and clone it so i am using the github cli but a majority of people probably use just get clone and copy this url but i use the github cli just because i like it so let's cd onto the desktop i will just paste in gh repo clone but most people will say git clone and then this url but because i'm using the cli that's my command is a little bit different okay let's go in cd into the project so we type cd yt vapor so i have example because i was testing everything beforehand so we just go to yt vapor and you see we cloned lesson one because i made lesson one the default because when somebody starts out with a series that's what they would use but this is broken down into lesson one two four in the main and i believe main is five because we couldn't name it less than five because of how heroku deploys so we actually want the branch main because lesson one doesn't have all of the code but main does so we just type get checkout main we can see it says we are tracking origin main and we have switched to the main branch on my computer you can see it says get main but if you would to type git branch you'd see a list of your branches and a star by the one that you're on so once we do that we can open our package.swift so we type open package.swift and open up my other computer or my other screen so we have opened the project and you can see at the top it's loading so now it's loading all of our packages in now that we have cloned the project and open it the first thing we're going to do is because this is a project that i don't have on my computer yet let's edit the scheme and set the working directory so we go to edit scheme go to options check use custom working directory so let's choose our project which is the vapor api the example was the previous one i was working on so this is the actual one that we are working now click choose and then click close so we've set that mainly so we don't have a warning that shows up so let's run our api but we will probably get an error because we have not opened the database yet with docker and we do the first thing we do get is an error connection refused that is because we have not started the database so let's open a new tab so if i type command t that opens a new tab and we type dopper docker compose up db so that is the database starting so let's stop xcode run this so that will start our database for us it says ready to accept connections good and now let's run this and there we go it says server starting 127.0.0 and 8080. so if we open postman here we can go to that url which is our localhost do the slash songs endpoint and hit send and we get back an empty array because there's nothing in the database yet so the first thing we're going to do is we need to upgrade everything so that we're using the new syntax so we can get that out of the way we can stop the project and the first thing we're going to do is upgrade to swift tools 5.6 so this is a comment but it is still read by the swift package manager for the for how everything is set up here so i was kind of confused about that but it's even though it is a comment it is still read by the package manager so that's why we have to change the version that we're using because as we saw in the proposal swift was or async await was released in swift 5.5 but now at the current moment we are using swift 5.6 so that's why we are specifying the version here even though it is in a comment we need to be on mac os 12 and then we get this error because we haven't updated we haven't saved it and updated anything yet so we have 5.6 we have 12 and then we have to go down here and change this line instead of it saying target run dependencies this should say executable target like that and once we do that and save it it kind of tries to resolve everything but it's still struggling and that is because we need to actually upgrade all of these packages we could update them individually if there were so for some reason you needed to update some but not others but in this project it's okay to update everything so if we go to file packages update to latest package versions we see the loading bar going and updating everything so let's wait for that to finish okay there we go it looks like everything is updated and we can see our package.resolve has changed because a lot of these like revision numbers and version numbers have changed and pretty much it looks like all of it has changed because we've updated everything so now if we click command b we can build the project and check that everything still compiles and there we go we have a build succeeded which is good so that was upgrading vapor within our project itself now we need to change our code to use the new syntax so let's open sources app and then controllers so we'll need to upgrade the song controller and then we have the migrations let's update the song controller first so what we are going to do is change the syntax from the event loop future to using async await so the first thing we have to do is mark the function as async and then get rid of the event loop feature completely but we are still returning an array of songs because when we hit this end point to get all of the songs we still want to return an array of everything but now we have to change this in which it almost looks the same but we'll change the syntax try a wait because this function can thrill and we can see that with the throws try await song.query on database so we do request.db and we're getting all so it's still this almost still looks the same the only difference is that we are using now an async await function as opposed to an event loop future function in a lot of our examples for this application the benefits of async await like you kind of can't tell because we're using such a simple example but when you start making everything that's more complex and you may do multiple database calls within a single endpoint that's when you'll really see the benefits of using async await so this one was the first one and we can include the return key keyword if we wanted to but we don't have to because this function only has one line in it so that is this one and we can confirm it still works by running the project tapping okay our server has started and then if we hit send we still are getting back that empty array so let's stop it let's add a create so for the create function the first line of it is still going to look the same so actually let me i'll keep these so you can see the difference and let's go back and copy that line but we'll comment it out so you can see this one it literally looks the exact same except now we are using the async await version rather than the event loop future version but the syntax is still the same and they did that on purpose and then this one for posting a new update this part still looks the same because we are taking a request and decoding it into a song and that's going to happen no matter what but the actual act of creating the new song that will change to the event the asic await syntax so let's again get rid of the event loop future change that to async and type try await song dot save so you see there's the event loop future one and then the async one but we are using event sorry we are using async await we do our requests.db and then return dot okay so you can see in the new syntax we're doing the same thing here for saving the song to our database but we don't have to add this dot transform we are just waiting for this to finish so waiting for the server to perform that work and then once it's that once that is done we are then returning dot okay which is http status so it's running linearly now that we have changed the syntax here for return okay let's try both of these functions together so if we run the application again click okay okay we are started so if we send a request for get we still get back an empty array if we now send a new request for creating a song we are creating a song with the json that just has a title and it's and the title we're giving it is money and we go to body raw json like we did within the last couple videos and we changed this to make sure it's a post request so i already have all four of them up here but you may need to create a new tab so we hit send and it says 200 okay back because that's what we are returning back if it was successful so that was good so if we go to get we should be able to send a new request and now we have our new song called money so we can do a different one let's do have i still been listening to the same band i think i have okay so let's type a new song and this one will be kill this love because i've still been listening to the same band we send the post request we got back at 200 we go back to the get send that again and now we have two of our songs because it's an array of song objects so we are good so we know our get songs and we know the create songs work so the last two to update are update and delete so with update let's comment this one out and again we still need this line because it still works the same if we are getting a song from the ios app and then we have to decode it once we decode the song we have to get it from the database so to do that let's do guard let let's call it song from db and that is equal to try await song dot find and we are using the async one and it's not coming up because we should change this to async and we again want to return an http status so now when we type song.find it suggests the async one above the event loop future one and the id of this is our song.id and request.db so that is equivalent to what we are doing here and then else throw abort not found so that's what these two lines are doing once we have the song we want to change the property so let's do song dot d from db dot title is equal to song dot title so that is what this line is doing let's update it so we have to do try oh wait song from dd db dot update we're using async one and updaterequest.db so this is the actual act of updating the database and if all that goes well we are returning 200. so we return dot okay so that is similar to what this line was doing was return update and then transform that into okay but with async await we don't have to do that because if this were to fail it would automatically throw some kind of error for us so that is the update syntax and then lastly we have the delete syntax so let's comment this one out and we have to do the same thing we have to find the song and then once we find it we delete it so let's do guard let's song is equal to song dot find and it didn't come up with async await because i forgot to change that again so we are getting rid of the event loop future and changing it to async so we do song dot find and then now we have the async one coming up and then we do the same thing we're finding request.parameters oops.get and we're using song id and we're finding it and we are finding it in our database and in the case that we don't find it we are throwing abort not found which is more selfexplanatory than like unwrap and once we have found it now we want to delete the song oops delete quest.db and then return okay so again we are finding the song if we can't find the song we are throwing a not found error we are trying to delete the song from the database if this were to fail it would throw some kind of error otherwise we keep going and we were just returned okay so let's test all of this together now so let's go up and run the project and we have an error oh because i didn't mark these as try oh we need to try and await actually my bad try oh wait try oh wait because with async await that's the other half is the await is async is our function function is asynchronous and then a wait is the is how we are waiting for code to finish so we are waiting for this to finish and it's an asynchronous function or it has asynchronous functionalities so now if we run it we should be good and let's go back to postman so if we send our get request we have our two songs we've already tested the create work so let's test the update so let's update money so let's copy the id or actually we need the whole object so let's copy this whole object here go into here that was me testing everything so let's paste this object oh i don't know why all the tabs are messed up but we need the id because that's the id of the property that we're on and then let's change the title from money to lisa because that is the other single that she released and this is a put function and then the same endpoint and then we hit send and we got back 200 okay so that means it worked otherwise we would have gotten back an error right here so now if we go back to the get request we can see money was this 9671 so if we hit send again so we've killed this love but the 967 id the title has changed to la lisa so we know our update functionality is working as well so now if we want to test the delete let's delete kill this love so if we copy the id here we go into our delete function so you just change this to delete and we don't need a body for this one and we just add the id to the end of the url we hit send we got back 200 okay which means it was good but if we also use our get request and we send this one we only have one song that is coming back to us now so now we know all four of the endpoints that we created are working yeah so we have changed all four endpoints for create read update and delete for the vapor application but we can also change the migrations to use async await so if we go to create songs we can stop the project these also have event loop futures so we don't actually need to change these ones unless we really want to you can make it so that all the migrations you make going forward use async await but all the ones that you've previously written you can keep them in the syntax with event loop future so if we were to change these we use i async migration and if we were to hold command and click on this and jump to definition we can see async migration actually inherits from migration which is what we just changed so we don't have to change anything else we only need to change the what it inherits for part of this i mean when we when i met we don't have to change anything we don't have to change anything in our configure file for this line here so if we added new migrations here so if we were to do app.migrations.add and we added a new migration we can use async migration because async migration inherits from migration and this function takes in a migration so we wouldn't have to change anything in this line within the configure function but how we write them how we write an async migration that would change here so if we were to change this one which we don't have to but we are going to for this we don't return anything and we just have async throws so this is just changed to try await so this does have a return in front of it but because this is really a one line function we don't need the return oops so we have try await and then this is creating our database and then again right here we don't return anything but it's an async function and we just need to again just type try await because how it works is still the exact same it's just using the different syntax so we are not going to test this because the migration has already run so we don't really run it again in the way to test if we wanted to test that this migration that we have already written works we could just like delete the docker container and create a new one or you could just create new migrations and use the new syntax instead but this is how you would upgrade your migration syntax and that's it that's all the changes that we need to make to convert our current project from the event loop future syntax to swift's new async await syntax for the new concurrency features that we have we changed the package.swift file to use the new version of vapor and upgraded all the packages in the project and we updated the song controller to use the new async await syntax for all of the different endpoints that we have and then lastly we updated the migration to use the new async migration i'll see you in the next one bye