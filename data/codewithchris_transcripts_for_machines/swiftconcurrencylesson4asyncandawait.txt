Hi. My name is Stewart Lynch, and this is the fourth of six videos in the iOS concurrency series. At the end of the third video, we had our completed application and it was using a result based completion handler for our API services. Get JSON file function in this video we're going to be implementing the new Asynchronous methods introduced in iOS 15. This will introduce you to new terms such as async and await main actor, and then asynchronous unit of work called the task. Now if you're just jumping into the start of this series, you can download the completed code from the third video in this series from the link in the description below. The first thing we should do since we're going to be experimenting with a new feature is create a new branch for our project so that if things go right, we can always roll back to that one that we completed in the last video, and that's a fully working app. So switch to the source code Navigator. Then select the Repositories tab and expand the application. You'll notice that the current branch is the one that's called main, and if you expand the branches section, you'll see it right click on Main and choose new branch from Main and call it async and await no spaces. It should automatically check that branch out and switch to it. But if it doesn't like mine doesn't. I'll right click on the branch and choose check out. That means I'm leaving the old main branch behind and that code is safe and won't be touched. And you'll always know what branch you're on because you'll see that in the title bar. Now within the API service struct. I want to create a new function and I'm going to use the same name and this is going to be allowed because I'm going to be giving this function different parameters. Instead of providing a completion handler. I'm going to do what I used to do when I knew nothing about asynchronous nature of network calls, and in fact, I was bitten by this when I first started coding. I thought every line of code waited until the previous line of code completed before moving on. So I would call getJSON and then just return my array of objects from the call so I can copy everything except the completion handler from this method, then close it off and then return that decodeable object, which in our case is either an array of user or an array of posts, but we're using generic, so it's just T. Now. This means within my view model, I expect to get my array of user or post back immediately so that I can assign it to my published property, and that's what I would have thought. Well, let's try and fix this function up so that we can actually do that. Let me start the same way as before. I'm going to copy the pasted code, but since there's no completion handler. Let's just rule that out and just return. Now this isn't really good, because remember, we want to pass that error on up to our calling view so that we can present it to the user in an alert. So we can designate this function as being a throwing function, one that might throw an error or cause an error. And we do that by typing throws before the return. Then you can throw the error rather than returning. And what kind of error do we have? We have an Invalid URL error, so we can just throw the API errors Invalid URL case by designating a function as being a throwing function. Every time you call the function, you're going to have to at some point catch the errors that were thrown by it. So this means we'll be passing the error higher up the calling hierarchy. This function could have been called by another function that was itself called by another one, and at some point then you need to catch and deal with that error, or maybe translate that error into a different type of error. And that's where a do try catch block comes in and you'll see that in just a second. So here's where I ran into a roadblock when I'm fetching from a network. It's not asynchronous normally. We have to wait until I get that response before I can move on to the decoding the data, and this is the equivalent to a completion handler. We wait for it to complete processing before we pass it back as the argument for our completion function. Now, though, instead of using our previous Urlsession's data task with URL function, we're going to use a different version when we start typing Urlsession shared data. I see that there are a number of options and I can scroll down and there are some grayed out ones. And the one that I'm looking for is this one here, and you'll see why it's grayed out in just a minute, we see that it's marked with async throws. The throws means what we've just experienced. If we run into an error, we can throw that error back to the caller. But what about async well? I'll get to that in just a minute. We do see, however, that it will return both a data and a URL response, and this function itself has been designated as throwing. So here's what I talked about. Somewhere on down the chain. We have a throwing function and we're going to have to deal with it at some point. So let's deal with it here and convert that error into our own API error. So we'll catch that error and then pass it on up to our caller. Now the dialogue is optional so we can remove that and the URL is just our URL. So let's just use it. Remember, that function does return data and response. So we'll create a tuple of our own to assign those return values now Xcode is going to help us here. It generates an error, and it says that this function can throw, but it's not marked with try. So anytime a function throws, you have to use try. So that URL session function. It was a throwing function. So we'll have to try. Now this creates a new error, which is the async call in the function does not support concurrency, and that's when our function was designated as an async throwing function, and this is new for us. It means that that getJSON function needs to support concurrency. So we'll need to have to go back up to where we define our function and make it an async throwing function. Now we're not out of the water yet, though, because we're told now that the expression is async, but it's not marked with a weight, and that's because the function is asynchronous one, and we have no idea how long it's going to take for our data and response to come back. So we must wait for it before we move on in our code. And we do this by specifying that we await for that tuple before assigning it to our constant and the order matters. We first try and then we await for the result from our call. Now what if that data from the URL function actually produces an error that try through an error? Well, by using a simple try, we're saying that we want the error to bubble up to whatever ViewModel is calling that function, but I want to handle all my errors here in the same way right here in this function. So I'm going to catch that error and change it to one of my ATI error types and throw it. So for this, what I'll do is use a do catch block and in the catch block. Then I can throw our API services API error, which is the data task error case, and it needs an associated value, which is the localized description of the error that one level up through. So now we have data and response, so we can check exactly the same way as we did before. First for the response, we need to check that it's a code of 200 or throw, so we can do this inside a do catch block just like we did before. Only we have a completion handler to pass our error with. We don't have one anymore. So instead we're just going to throw an API error, which is the case Invalid response status. Still within the do block, we have that data and the data task error will have thrown an error. There been one. So now we can decode and return the decoded data now, unless there is an error decoding data, in which case, again, no completion handler, we'll need to throw the decoding error using that errors localized description as the associated value for our API error type. Well, that's it. We're done. Our app would still build and run because we're still calling that original function, though I haven't deleted it, at least not yet. Let's return now to our users list view model and change that call. We'll still need that instance of API service and the is Loading toggle function, but this getJSON function needs to be commented out for now, but I'll keep it here just for reference. Instead, we can use our new Apiservice get JSON function. Now we know that it's going to return our users, so let's assign the return value to users and we'll call that function. Now. Notice there are two of them. We want the async throws one. Now this generates an error call can throw, but it's not marked with try and the error is not handled. In fact, the order in which the error occurs as there are going to be three of them may be different from you, but the errors are the same as we saw earlier. First we'll need H Fry and we'll need to designate that function as being asynchronous. Then we'll need to await the result, but we're at the end of the line now. If we encountered any errors, we'll need to set our shoulder to true and set the error message so that the localized description is used for the message body so we can do that do catch block right now to handle that. Well, we're going to do it the same way that we did before by saying the show error alert to true and setting the error message to that errors localized description and we don't even need self. We no longer need this commented out code here for reference, so let's just delete it. Our is Loading property has been toggle to true, but we've never turned it off. Well, since this entire function is asynchronous we can place our defer block right after it and it won't be toggled or called if the execution is going to be deferred until the function exits its scope so we can just use defer is Loading toggle right after we assign it. Isn't this nice and clean so much easier to read and follow? Now users is a published property and this function is executing on a background thread, so we'll get that severe warning if we don't do something to fix that and set it back on the main thread. If I try to enclose this with a dispatchq main asyncblock I get an error in Swift five five, there is a new attribute called main actor that we can use to decorate the entire function and it will then dispatch this task onto the main thread. When we build we get an error though in the users list view because it's now calling that new get users function and that's an asynchronous function. So what we have to do is make sure that our on up here is asynchronous and so what we can do is we can within that on a peer function, create an asynchronous unit of work, which we'll call a task, and since that's asynchronous, we need to await the result. No try here, though, because we've caught any errors back in that fetch users function well. In iOS 15, we can go one step further than this. We can combine both on appear and task into a new asynchronous task method that adds an asynchronous task to perform. When this view appears. This code is much easier to follow and work with. When I make that call to fetch users, I'm either going to be successful or it'll throw an error. If successful, we assign the decoded data to our published property. Since this is our calling point of our throwing functions, we need to deal with any errors that were thrown earlier in the process, and therefore the do catch block. It all compiles properly. Now. No errors, but our posts are still using that old API service Get JSON function, so we want to fix that before we can remove it. So let's do that. Let's return to the user's list view model and we'll copy everything from the defer on down. Then in post list view. In the Fetch post function, we'll replace the old getJSON function with this new code. We just have to change our users to posts. It's complaining, however, because it's an async call in a function that doesn't support concurrency. Remember, anytime we've got concurrency, we need to specify that our function is asynchronous and also don't forget that we need to dispatch that task back onto the main queue, so we decorate the function with the main actor attribute. This requires one more change in the post list view as well, because we are now calling an asynchronous task, so we'll need to create that unit of work, which means we'll change a peer to task and then await the return of our posts. We can test now in the simulator and we'll see that it all works just as before, but with much more readable code. After having done all of that work, we want to make sure that you commit the changes to your Git repository. This is so much cleaner. Now in the fifth video in this series, we're going to take this even further. We are currently fetching all of our users at once, and then at one time we're fetching an individual user's post as needed, and we'll do that every time that we click on one of the rows in our users list. That's a lot of network calls if we're viewing a lot of different users posts. So what we'll do in the next video is retrieve all of the users and all of the posts in parallel so that they are all in memory and then filter the posts for each individual user as we need them a maximum of two network calls anytime we launch our application. So be sure you subscribe to the code with Chrischannel to get notification of new videos and I'll see you next week. Thanks for watching. Bye.