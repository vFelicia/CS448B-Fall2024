hey guys welcome to lesson 8 of how to build iPhone apps with no programming experience and in this lesson we're going to build upon the last and continue learning a couple more concepts of the Swift programming language we're going to look at subclassing and UI kit so let's start with the first subclassing in the last lesson we learned about classes and how you can create a class to describe a component in your app we also said that you can create multiple objects from one class and that's really convenient because let's say that we have two identical components in our app we can write a single class and create two objects from it to represent the two identical components well consider this scenario what if you need two components in your app and they're not identical but they're very similar let's say 90% similar in their behavior what we want them to do well you could write two separate classes one to represent each of those components where 90% of the code in those classes are the same but that's a waste of effort and furthermore it's generally a bad programming practice to have duplicate code everywhere because it makes code maintenance and debugging harder than it needs to be and this is where subclassing comes in it allows us to handle a scenario like this without having to duplicate 90% of that code code in other objectoriented programming languages there's a concept called inheritance and in Objective C and Swift it's known as subclassing so a subass is a class that inherits the properties and methods of another class so going back to our scenario with the two similar components we can write one class to describe the behavior of the first component then we can write a second class and declare it as a subass of the initial class that we wrote well when we do this the second class has all of the properties and the methods that we declared in the first class and you don't have to rewrite or redeclare all of those properties and methods instead we can just write code to represent a difference in the second class in this relationship this is the subass and this is the super class although sometimes I refer to the super class as the parent class now let's go back to our playground and see what a subass looks like so I'm going to start a new playground I've got xcode open here and call it subass playground and just save it on the desktop okay so in the last lesson we had a class called person so I'm just going to declare a person class again so if you practice it a couple of times you might might start to realize that um even without trying to memorize exactly how to declare a class you may remember how to do it so following along and trying it out on your own computer really goes a long way to help you remember things without having to memorize things so if you remember we need an init method and this time okay let me declare a property here and we'll give it an initial value of initial name okay and next I'm going to declare a method called walk and if you remember how to declare methods you used the funk keyword followed by the method name and then a set of round brackets and then a set of curly brackets inside here when this method is called I'm just going to print line I'm walking okay so let's test that out I'm going to declare a variable a and assign a new person object to it and then I'm going to set this object's name property to Alice and finally let's call the walk method and just see it print line here okay now we're going to demonstrate subclassing so I'm going to create another class which will subass person and I'm going to call this one superhuman and the way that you declare uh specify a subass is you use colon and then you put the name of the super class like that so just like that I've declared a class and it inherits all of the properties and methods of the person class I don't even need to specify an init method or initializer watch this so I can go VAR b equals superum to create a new superhuman object and assign it to the variable B and now I can go B do name and you can see that it registers it as initial name and I can go say B.W walk and you can say now you can see now that it printed it two times so just like that even though I don't have any of that stuff specified in here because superhuman is a subass of person it has all of person's methods and properties so this can be really handy next let's give superhuman some sort of additional functionality because otherwise we wouldn't need to create a subass right so in superhuman I'm going to add an additional method called fly and inside the fly method I'm going to print line I'm flying okay now I can go B do fly is available to me and now you can see that that method is called and I'm flying as printed out let's also add an additional property for good measure so up here I can add alter Eagle name String can just set that to Clark as an initial value I can see that when I go B dot you can see that the two properties are available alter ego name and fly are methods and properties inside the Superhuman class and name and walk are from the person class now if I went a DOT you can see it only has name and walk because a is a person object in this relation ship superhuman is the subass and person is the super class ironically okay let's consider another scenario in this case we have a subass superhuman that provides additional functionality but what if I wanted my subclass instead to override or provide a different functionality than the parent class for example what if I wanted when I call b. walk for the walk method to do something different than the walk method that was uh coded in the person class well you can actually do that so the way to do that is you can go override and then redeclare the exact same method as in the parent class so there's walk set of brackets and then set of curly brackets and this override keyword now when you call walk method on superhuman instead of executing this code in its parent class it executes this code it's superhumans implementation of the Walk method so in this one I'm going to say print line I'm walking really fast so let me erase these and demonstrate so now when I go b. walk you can see that this was triggered I'm walking really fast now if I didn't have this this method call would execute its parent classes functionality there's also a mechanism where you can do both so in this overridden method you can say you know print line I'm walking really fast but if you wanted to run the parent classes implementation you can go superwalk and super stands for the parent class so I can do that so now when you say B.W walk what happens is that it calls this override function this overridden walk method and it executes this line and then it calls the parent classes walk method and executes this code in here so there's some flexibility there and some powerful tools at your disposal while we're on the topic of overriding I want to mention one thing is that if you want to provide a custom initializer method for superhuman you would also need to override it and you would do it something like this override init and here you could provide your own custom initialization for superhuman however if you try to access uh your parent classes Properties or methods in this initializer method you're going to get an error so let's say super dotname equals super duper and you're going to get an error here that says self used before super. init call and it's basically complaining that you haven't called the parents initializer method yet so you can't use any of its properties or methods so all you have to do is actually just call super. init before you use any of the parent classes Properties or methods the reason is because the parents initializer method May initialize some values in the properties or it may set up some of the methods for use so before you use any of it you actually have to give the parent class a chance to initialize or set up anything it needs to set up now you actually know quite a bit about the Swift programming language and how it's structured and you know about the tools available to us to create these classes and describe our components in the apps well you'll be happy happy to know that Apple actually provides us with a whole slew of classes that are available to us to use to build our apps it makes building apps a lot easier because it lays out a lot of the groundwork that we need already that set of classes that Apple provides for us to lay out the groundwork for our app is called UI kit and UI stands for user interface so let's take a look at the documentation for it so if you go to to Google and typee in UI kit you'll get a whole bunch of results but it's not this one so don't be fooled by that uh scroll down until you see something from developer.apple.com this UI kit framework reference and the page should look like this so in your own time if you read this little bit of introduction and what sort of functions and features that UI kit provides you'll see that I kind of understated it when I said that provided a set of classes for us to use it's actually quite extensive and covers a lot of different functionality but we're going to scroll down until we reach this heading called classes along the left hand side are all of the classes that are in UI kit and on the right hand side are the descriptions for each of those classes however you'll notice that they're not all spaced evenly uh you'll notice that NS object is here as a root node and then underneath it are a couple more and underneath NS paragraph style is NS mutable paragraph style well actually NS mutable paragraph style is a subclass of NS paragraph style class which is a subclass of NS object NS object is actually at the very very top it's the root class for most and it says Objective C here but you can substitute that with swift because Swift uses UI kit as well so NS object is the root class of most Swift class hierarchies all of these other classes are subclasses of NS object directly or indirectly because sometimes it goes several layers deep if you scroll through this list of classes yourself you'll see how long it actually is there's a huge collection of classes here for us to use so what usually happens is that before we create our custom class if there's something similar already in UI kit what we want to do is we want to subass the UI kit class and then either using overriding or additional methods and properties code up our unique Behavior but we can use if we can use a UI kit as a uh as a parent class or a super class then we can inherit a lot of functionality without coding it ourselves and then the next lesson and I'll point out which ones and what they do we're going to be referring to this page a lot so make sure you bookmark it or have some way of getting back here it's also very useful because you can click into each of these classes and you can get some documentation on how to use this specific class and they have Swift or objective c or you can view both