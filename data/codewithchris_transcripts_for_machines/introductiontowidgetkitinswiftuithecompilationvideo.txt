learn how to add a widget extension to an existing app including reusing service classes building uis for different size classes and scheduling widget updates through a timeline hey code crew this is floor i've been developing ios apps since 2016 and i've been working on many different widgets over the past few months so i'm super excited to teach you about widget kit in this series this is lesson one where i will show you examples for great widgets by apple the current project setup and the example app that i have prepared for you next we will add a widget extension and go through everything that xcode automatically generates for us let's get started with some examples of grade widgets so you understand how all of this works how the ecosystem works and how they are built up so there is this great article from the apple developer website which is linked in the description which just gives a brief introduction to widget kit and i just want to show you a few of the examples that they have on their website here they have the little calendar widget they have a weather widget news music also for the activity app and so on then there are a bit larger widgets for the ipad with photos and a bigger calendar view but one thing that unites all of them is that they have at a glance information so you for example in the calendar widget you only have the next two events showing so when you have a glance at the widget you immediately know what it wants to show you and what information is there same for the weather widget you just have a quick look at it and then you instantly know the temperature and the current weather conditions there are also some more widgets that i want to show you that i have personally worked on the first one is a food tracker app which is based around a medium sized widget that you can see in the screenshot in the middle here and the idea is basically that you can track your meals through a widget where you can just tap either on the healthy or on the junk side of the widget the app will open up and all of your meals will get locked that way so there's a tiny bit of interactivity here but i will tell you more about that in just a second and then there's also another widget that i made for a swift ui jam a few weeks ago which is an almost fully working calculator widget so we can watch the video here it looks just like the calculator app from your iphone but then you can tap on the numbers and on the operators the app will briefly open up close back down again and then you will see your calculation and the end result inside of the widget i think this is very cool obviously this is not what apple intended widgets to be but there you can just see what's possible with the technology so getting back to widget kit itself widgets are built entirely in swift ui so it is not not possible to pull the ui kit for example via ui view representables or your view controller representables currently you can only use swift ui to build out the ui side so what's displayed inside of the widget as i said the main idea is to provide at a glance information these are just tiny portions of the screen the widgets are based on a timeline so you the developer can provide a timeline scheduled with timeline entries that all have an associated date and some data associated as well so you can for example schedule a timeline over the next five hours where at every full hour there is a timeline entry and then ios or ipad os or even mac os whichever system your widget is running on will execute that timeline and refresh the widget by itself so you're not guaranteed to have the widget refresh at exactly the time in your timeline entries that you have specified but the system handles it and the system also has some limitations for example you cannot refresh your widget a few hundred times per day there are just certain restrictions there set by ios but most users will never notice this and for most users the widgets will always stay up to date we will have a look at the timeline the timeline entries and so on in partially in this but mainly in the next lesson and then one last very important thing when talking about widgets is that you understand that they are static ui so there are no animations there are no videos there is no navigation and there are also no buttons the only dynamic thing that a widget can do is link into your main app and pass in some data there we will have a look at that in the third lesson of this series but until then you can just assume that a widget is more or less a very static view okay to get us started a bit quicker i have already prepared a very simple example app this is a simple todo list app based on the json placeholder api you might have already seen the json placeholder api if you want to have a more specific look at it it will be linked down in the description it's a very generic api with some yeah as the name suggests placeholder json data for users for posts and so on but we're just using the to do's route which you will also see in just a second so the main app only has a single view which you can see here on the right hand side if i press play then all of the to do's will be loaded you we will have a list here with the to do title on the left hand side and then the statues whether it's completed or not on the right hand side so some of these todo's are open some of them are already completed and if we tap on a todo item here a little sheet will come up telling us the id of the todo then once again the title and whether it's open or completed and then you can of course dismiss the sheet like always okay so let's briefly go over the content view here so you understand how this all was built and then we will have a look at our data class or to do and then also our service class so first of all as you can already see we have a navigation title here so we must also have a navigation view which surrounds everything in our content view here and then mainly we just have this single list here the rest of the code is just view modifiers but we mainly have the single list here iterating over all of the to do's which is a state variable here in the beginning this is an empty array of to do but later on i will show you how this gets filled and then inside of the list we just have a simple button for every row the button action is to set the selected to do which is another state variable to the to do of this current row so for example if i tap on the first one then that will will be the selected to do which is used for our sheet here at the bottom this has the item initializer where you can pass in an optional identifiable item in our case our selected to do state and if that is not nil so if there is some to do selected then the sheet will show up and show just a simple group box here i think this is not too important this is just for demonstration purposes if we just miss the sheet again we have our list again and then inside of the list button there is just a simple attributed string which is brand new in ios 15 where you can use some parts of markdown to for example bold a region of text so here you can see these double asterisks before and after the completed or open text which we just bolded as i said this is attributed string stuff not important for this series i just wanted to include it to make it look a tiny bit nicer since this is a very plain ui okay let's continue down so we already have covered the navigation title it's just my todo's and now the interesting part comes so um for our todo servers i have chosen to use the new script concurrency features if you want to learn more about that there is also a series about such concurrency made by stuart lynch um so it will probably also be linked down below you can go there after this video or if you have any understanding issues then you can just go there and have a look at it but i think it will be pretty straightforward basically what we're doing is we're attaching a task to the list task is very similar to unappear so the code in here gets executed the first time that the view appears but you can execute a synchronous code in here so we will have a look at how that works in just a second but bear in mind so this task will get executed one time at the beginning and everything in here is happening asynchronously in a background thread or can happen in the background that can also happen in the main thread depending on how it is scheduled internally and all that this task does in this case is call our to do service dot get all to do's function which calls the json placeholder api gets back all of the to do data and then puts it into our to do's state variable up here which will then be used inside of the list okay and then the last modifier here i already told you about the sheet so i think this should be pretty clear now let's move on into the data folder on the left hand side here so first of all we have our struct to do it's important that this had this conforms to two protocols the first one is decodable so we can decode it from json which you will see in a second in the todo service and the second protocol is identifiable so we can iterate over it in our swift ui list this just has four very simple attributes the user id the id of the to do the title of the to do and whether the todo is completed or not let's jump real quick into the json placeholder api and let's go to the endpoint that we're using which is slash to do's and here you can see where this data is coming from so this is just a json file sitting on the server and there you have um all of the same fields that i just showed you in our todo structs so you have the user id which is an integer the id which is an integer the title which is a string and then completed which is a boolean okay and then the last file that i have prepared is the to do service here this is just a very simple helper class to fetch all of the todo's from the json placeholder api since there is no need to instantiate a new todo service every time that we use it i just added a static shared instance here so we can always just say to do service dot shared instead of instantiating a new to do service we have our base url which is just the address of jsonplaceholder.typeycode.com and then it gets a bit more interesting with these three functions here the first one is a very generic networking function that you can use in any of your projects really but the important thing is that it is built using the swift concurrency features so let's have a brief look at how that works so inside of the function we first have or we first construct our url so when we call this function we pass in an endpoint for example todos and then the function will generate a url for us so in this case it would be https colon slash slash jsonplaceholder.typeycode.com slash and then here it would be for example to do's so this will be the endpoint we constructed here this can fail so if in case it fails we will just throw a url error of that url once we have our url we can use the url session dot shared dot data function which is similar to data task or data task publisher if you were using combine previously this function just creates a or takes the shared url session goes to the url that you uh handed over and then fetches all of the data from that url this is an asynchronous task so you have to wait for the results to be coming in and this can actually also fail or throw an error and hence we need to try to await the data from this url this function actually gives back both data and a url response so in your app you might want to check the url response for the status code or any info that the server gave back to you in our case we don't care about that so we can just omit the second value of the tuple here the url response by using the underscore and we will just unpack the tuple into our data variable and then the last step is pretty straightforward we just construct a json decoder and then we decode our to do in our case from the data now the interesting part here is and hence the name generic helper function we have some generics here so we have a generic type t which basically means that we could use this fetch function to fetch any type of data we could also fetch some users or whatever as long as that struct is decodable as the generic condition here says so let's see how that works i have two endpoint functions basically the first one is to get all to do's from the json placeholder which once again is asynchronous and can throw arrows but this one will return an array of type to do and this will basically just call our fetch function up here from the todo's endpoint so basically just the one that i showed you in the browser a minute ago as you've already seen the fetch function is asynchronous it can throw so we need to try to avoid the result of the function since we are using generics here we need to explicitly specify the type that we want to get back so in this case if we want to get all to do's we want an array of type to do and then we just return the result of the fetch function and then very similar for the last function which is called get to do with id we can use this one to get the data for a specific to do which we're using for the sheet for example this function returns a single todo instead of an array of todo's and it's basically the exact same from before so we need to specify the type over here since we are dealing with generics and then the only thing that we're changing is the end point so now we're not querying for all to do's requiring for to do's slash our id and if we look at that in the browser so here we have slash to do's and now we say slash one for example this will give us just the first todo item okay so now that you have seen the sample app that i have already created for you let's do the last thing for this video which is adding the widget extension to do that it's also very very simple since xcode does almost everything for you you just go to file new target and then in here you can either scroll through all of the extensions or you can just filter for widget extension double click it then give it a name so in our case i will call it widget kit course widget make sure to uncheck include configuration intent that is something that we're not doing in this series configuration intent can basically be used for siri it can be used for the user to customize your widget but this is not important for the series once you're done just hit the finish button and here you can say activate the scheme if you want to which what this does is basically it changes the theme up here in xcode so once you have an extension you can select when you're running your app which scheme you want to run so you can then either run your main app in the simulator or just run the widget extension in your simulator for now let's just say activate if you want to change this later on you can just go up here and select either your main app or your widget extension okay and then on the left hand side here you can see that a new folder was generated which is called just what we entered into the text field if we open that up there's just three files a basic info.plist file an asset catalog that you can use to provide assets like images and then there is the widget kit course underscore widget file this file contains all of the auto generated code from xcode let me go over the extension and tell you a few words about each of the different types that got generated and actually let's start at the bottom here so first of all same as in swift ui which i just closed there is also a preview available for your widgets i'm closing this right now so we have a bit more space by the way to open and close that canvas you can press command option enter and then there is something that you're probably already familiar with if you have worked in swift ui before because there is now this add main widget struct this is actually super similar to the admain abstract in your normal app where you have a body in which you just present your content view inside of a window group in this case but it also has the add main attribute which basically tells the device this is the entry point to the app start here and then it's the exact same thing for your widget this add main attribute will just tell the device this is the main starting point for the widget called this and then you're good to go so of course this is not an app this is a widget and it also has a body the body has the generic type of or the opaque type of widget configuration you can have there are basically two different types of widget configurations the first one is a static configuration which we are using in most widgets actually use a static configuration and there is also an intent configuration which you can use if you want to let the user edit the widget directly on the home screen not important for this series but just so you know there's two different types of configurations and then into the configuration you just pass basically an identifier of the widget which is defined up here by default this is just the name of your widget extension target you can change this of course especially if you add multiple widgets to your app later on and then into the configuration you also pass in a timeline provider we will have a look at that in just a second inside of the configuration you then have your actual view now this has a very long and complicated name we would change that also in a minute and into that view you pass in your timeline entries if you recall in the beginning of this lesson i talked to you about you can schedule a timeline with different timeline entries for set dates which in turn contains some data that you can pass to your view and basically these timeline entries here come from your timeline provider and get passed into your view over here you will see this more concretely in just a second you can also customize your widget configuration by for example giving it a display name which will then show up in the app library and you can also give it a description okay let's scroll up a bit here the next struct that got auto generated is the actual view this view gets passed in a timeline entry which is that piece of data that's scheduled through your timeline and then this example widget here that gets autogenerated just shows some text of the current date of the entry so nothing very special here and then the entry actually doesn't contain any data right now we will customize this in the next lesson the only important thing here is that your entry conforms to the timeline entry protocol which requires the entry to have a date property and then up here the most important and most interesting part of widgets is the timeline provider so all of this over here the timeline provider is responsible for scheduling your timeline entries for your widget over time for the next couple of hours for the next day or even weeks however long you want to schedule it there are three main functions functions that you need to implement here first of all the placeholder function this is used when the user is selecting your widget in the widget gallery on their actual device then there is the get snapshot function which just gets back the current version of the widget with just a simple timeline entry or just a single timeline entry and then there's the get timeline function which you can use to schedule a timeline for your widget including when it will refresh how often it will refresh and which data it will show the very last thing for this video will be taking all of these different structs and moving them into their own files to make it a bit easier to read and to understand what we're working with so over here in our widget folder we will add a new file and call this one provider and now a very very crucial detail when you create this file is that it needs to be in the widget target and not in the app target now you can hit create and in here let's import widget kit and then let's move our provider our timeline provider from the generated file into this new file and let's do the same for the simple entry and the view as well so create new file swift file let's call it simple entry make sure that the widget extension is checked here hit create import widget kit and then copy over our simple entry just like this and then one last time for our view here so let's hit command n new file let's call this widget view hit create here we need to import both widget kit and swift ui let's copy over this struct over here and move it into this new file and then we can also command click on it and say rename and then rename this long name to just widget view let's also remove this space here let's copy the name and make sure that it was renamed everywhere so for example for some reason xcode didn't rename it over here so let's get rid of these old names and replace them with the new shorter name in this lesson you learned about what can be done with widgets and how they are internally structured you saw that a widget is based on a timeline and timeline entries which get displayed in a plain old swift ui view learn about different size classes building a widget ui and deep linking into your app in this lesson hey code crew this is floor in the first lesson of this widget kit course you learned about how widget kit works under the hood how widgets are refreshed and everything that xcode automatically generates for you in lesson 2 we will have a look at building uis for different size classes and deep linking into the main app from the widget let's get right into it so we're starting in this lesson right where we left off in the last lesson and actually we don't need the content view what we need is our widget definition here so i already told you in the first lesson that there are different size classes that your widgets can have so that's the first thing that we will have a look at in this lesson to have a look at the size classes configure them and tell the system which size classes your widget supports you can just go to your static or your intent configuration basically just widget configuration and then there is a very simple modifier called supported families here you can just pass in an array of all of the widget families that you want to support one note though is that the system extra large family is only available for ipad apps since it cannot even fit on an iphone for this lesson we will focus on system medium which is basically two rows of apps at full width and also system large which is two which is four rows of app so almost the entire screen taken up by that widget while we're added let's also change the configuration name to my todo's and let's also change the widget description both of these strings are shown in the widget preview when the user wants to add a widget to their home screen so for example here for a description we could we could say view your latest todo's just like this okay so now we have told the system that our widget supports both the system medium and the system large widget family but now we have to actually implement both of these size classes and what we will do is we will switch on the size classes that we can reach from the environment and then provide different views to the widget based on which size class is currently selected for that there is an environment value that we can read so just say add environment and then the key path is widget family and this way we can basically read the size of the widget and what we can now do is just switch over this because it's an enum you just saw us set it up here in the supported families modifier just switch over it and then present different views so here let's remove the text and let's say switch widget family and now we're only interested in two cases because we only support system medium and system large so let's say dot system medium and let's also say dot system large and as always a switch must be exhaustive in swift meaning that either we have to cover all of the cases individually or we need to provide a default case in the end that should happen if none of the other cases holds true in our case or in in a place like this the default case will never be executed because we told the system that we only support medium and large but nevertheless we need to provide a default case so let's just say not implemented here and then we can forget about this for the system medium and the system large cases we will now implement widget uis so i will just hit command n say new swift ui file and let's call the first one medium size view make sure that it's a member of the widget extension and not of the main app hit create and then let's do the same with a large size view for both of these let's move them into a group over here in the widget just so we can separate everything so let's call this group views and in here let's move our widget view our large size view and our medium size view okay let's close these and open them up again let's start with the medium size view first of all we will want to receive a timeline entry the one that our widget view already got from the timeline and we will want to forward that into our medium size view so to work with timeline entries we need to import widget kit and then over here we just need to say we want to take in an entry and we can either say provider dot entry or we can just directly tell code to type which is simple entry let's do the exact same thing for the large size view so import widget kit and then let's add a var entry of type simple entry and actually since we're inside of widget kit we don't even need the previews here so we can just scrap them from both of these views that way xcode won't complain about any issues and now we can already start to add both of these views into our widget view so for the system medium let's just say medium size view with our entry and then also large size view with our entry okay for the medium size view we will now start to implement the ui and for that i want to show you a pretty neat trick how to have at least a decently looking ui up pretty quick for that we will use a group box with a label so a group box is basically just a wrapper around a bunch of views that groups and up and puts them into a box with some sort of grayish background and with the label initializer here we can pass in a label with a title and an image in our case we will use a system image the title will be my todo's and the system image will be list dot dash and now inside of the group box we can put our actual ui so in our case we will have an h stack here with first an image of a person for that we will use um the sf symbol for person let's make that resizable let's make that scale to fit and let's also give that a foreground color of secondary so um so a nice grayish touch then let's add a little divider so in case you didn't notice you can place dividers in v6 but also in h stacks and if you place them in h6 then they will be just a vertical line and then in here let's add a little vstack where we can display the contents of one of our todo items let's give this a leading alignment like this and then in here we will have two text elements the first one with the to do title right now we will just have some placeholder content here because we will fill out the timeline provider in the next lesson let's have this text as a headline font so give this the font of dot headline and then below our title we will have whether it is completed so here i will just say completed for now we will fill this with a tiny bit of logic in the next lesson as well and then here we'll just say this is a sub headline like this at the end let's also add a spacer so everything is aligned nicely and then let's also add some padding to the edge stack so nothing cuddles with the edges of the widget i would say okay that's the mediumsized view already done for this episode now let's move on to the large size view in here let's also remove the text and let's replace it with a v stack basically what we want is we want to have kind of like a notepad feel to this widget you already saw it in the first lesson how it will look in the end and let's implement that right now first of all there's this little header row at the top i will give that a spacing of 16. and in here let's add a little title called my todos then let's add the current date so date.now with the format of date time this is a very handy text initializer here where you can pass in a date and then it will be formatted nicely and then let's push all of that to the leading edge to format this a bit nicer let's give it eight points of padding let's give it a blue background let's give it a white foreground color to have a nice contrast to our blue background let's clip all of this so it's handled as a single view because now we will apply a shadow with a radius of 5 points if we were to not apply the clip modifier like this then the shadow would be applied to each individual sub view of our age stack but we only want the shadow once for the entire hdac so we need to clip everything into a single view okay next up we want to display a list of all of the currently open to do's or all of the currently available to do's for that we will create a for each and for now we will just feed this with random numbers we will not even use them we will just say underscore in because we don't even care about these numbers in the for each let's create an h stack with a circle this will basically be the indicator if the todo is already completed or not and here actually we don't need to say id we need to say self as the identifier we don't want the full circle we only want to stroke its border so we will say stroke with a line width of two let's scale this a little bit with a frame of 30 by 30. we don't care about the alignment since it's just a single circle and then let's overlay something here we want to overlay basically a little check mark if the todo is already completed so we will say if true for now since all of this is just mocked if true we will have an image with the system name of check mark okay so that's the first part of our rows next we want to add the todo title okay and then let's push everything to the leading edge with a spacer let's give this whole thing a bit of horizontal padding and then also add a divider underneath okay now that we have implemented both the large and mediumsized view let me run them on the simulator and show you how they look okay so the simulator is now running and you can already see our medium size widget here so all of this is a group box up here you can see our label that we added at the bottom here then there's this scaled system image that to do title and that it is already completed and if we swipe over to the next side we see a tiny bit of an issue with our large size view and that is because we have too many lines or too many cells here so let's reduce that to six and run it again and have a look okay this is already looking a lot better so we have our header here the only thing that i forgot to do is to add a little spacer below or for each so we don't have that white space at the top there so let's add the spacer here let's run this one last time okay and there you can see now the ui looks exactly how we wanted it we have our header here with the blue background and a tiny bit of shadow at the bottom here if you can even notice it then we have the title of my todo's and the current date then of course we have our rows of our different todo items as you know all of these are mocked right now okay in the second part of this lesson we will have a look at deep links so basically we want the user to be able to tap somewhere on the widget and then open up a specific piece of information inside of the app to achieve that there are a few steps that we need to take first of all we need to set up the target url in our widgets using either the widget url modifier on the entire ui or using specific link views for example for our rows here inside of the for each and then we also need to handle the on open url modifier inside of the main app that basically handles what the app displays when it gets opened through a widget url or any kind of deep link for that matter first of all we will have a look at the widget url modifier because it's a tiny bit easier to use for that we just have to add it as the last thing in our medium size view so the widget url modifier which needs a url and we will construct that right now from a string i will tell you about this once we yeah basically parse the url in the main app then you will see how all of this works basically what i usually do as the scheme i will just say the app name so just my app in this case colon slash slash then the different routes basically so here we'll have slash to do slash and then the identifier of a to do which we will later on get dynamically from our timeline provider right now i will just hard code this to be one okay and that's already the widget url modifier this is all we have to add to our widget to open a specific thing inside of our app or to at least tell the episode because right now the app doesn't handle anything befo before we do that let's have a look at the link view for our large size view for that we will grab our entire h stack here copy it and embed it in a link with a destination url and then as the label we will just paste back in the hdac and now you can already imagine this url is basically the exact exact same thing as before but the main difference is in the widget url modifier you can pass in an optional url which is uh happening here because the string initializer always gives back an optional url but in the link view you will need to pass in a nonoptional url so we will have to false unwrap this here in a real application you might not want to do that you might want to construct a url at a different place be sure that it exists and then pass it into your view for now in here we can basically put the exact same url as we had in our medium size view once again this identifier here is hard coded right now we will replace this with the identifier of that specific todo item later on all right that's already everything that we need to set up in our two widget views so we can close those up now and we have to move into our main app in our content view now we will now have to add the unopened url modifier at the end of our content view here and this basically gives us a closure passing in the url that the app called when it was opened from a url this is basically not called when the app is launched regularly this is only called in our case if the app is launched through the widget so if the user tapped on the widget then this closure here will get called and now our task is it to parse the url make sure that it's in the correct format download the data that we want to display and then display that data so first of all let's make sure that this url is correct so we will have to check if the scheme is correct and the scheme in our case needs to be my app so if we um one last time go back into one of our views the scheme is basically this right here in a web url this would be https for example next up we will have to check that the host is to do url.host equals to to do that's basically this route that i mentioned before and then lastly we need to extract the identifier so let's say that id equals an int from our urls path component number one so let's just say path components at the position one and that will be the number here at the very end which we hard coded right now but will then be filled in from our actual todo's now that we have all of that um let's make sure that in case any of this is um yeah is not working we will just return of the closure and do nothing you can also print that there is an issue here in case you want to debug it somehow okay now we have everything that we need basically that's just the id both of these are just arrow checks now i've already told you about this in the first lesson we will use the get to do function of our todo servers i've told you that this is using the new search concurrency features and that it is an asynchronous function that can throw errors but in the end returns us a single to do with that identifier that we pass into the function so let's use that and since we're not in an asynchronous context context we need to first of all create a task i already told you this function can fail so we need to wrap it in a do catch block and then for now we will just print the error but in reality you should handle the error in an adequate way now let's get to the meat so we want to download our todo from our um yeah our service so let's say let to do equals try to await all of this with concurrency stuff we already talked about this in the first lesson if you want to learn more about this just check the source concurrency um lessons they will be linked down below so we will try to await the to do service we have a shared instance here the get to do function with the identifier that we extracted out of the url here so let's just pass in that id once that finishes once the await is done basically we need to switch back to the main queue because this can happen in any queue and now we want to update our ui so we need to be on the main queue for that and if you remember from the first lesson we have this state of the selected to do here and if we set that to a to do then a sheet will be shown with information about that to do so we can just say selected to do equals our todo that we just loaded with our get to do function okay this was a lot of talking a lot of code let's run it in the simulator and see how it works okay so first of all let's have a quick look at the widget kit chorus app here okay everything still looks good now let's have a look at the mediumsized widget remember we added the widget url modifier here so you can tap anywhere inside of the widget then the app will open up and it will tell us all of the information about the to do with the identifier one because that's what we always passed in here as a hardcoded identifier and then if we close that again go to the home screen and now over here in the large size widget you will have to have a very yeah a sharp eye here if you click on the individual cells then they will get highlighted a tiny bit like a button and the app will get open so let me click on the third cell here you saw there was that little subtle button button click animation now the app opened again and we once again see information about the to do number one because that's just what we hard coded okay so in this lesson you learned about different size classes in widgets and how to show different ui components for those you also learned about deep links using widget url link and on open url in the main app learn how to provide data to a widget by reusing a service class from the main app and how to schedule that data in a timeline hey code crew this is floor in this lesson we will finally fill up the widgets with some life as we use the existing todo service from the main app we will also fill out the timeline provider and talk about different ways to schedule content for your widget so let's get right into it before we can start filling out the timeline provider we need to do a few setup things as i already mentioned we will want to reuse the to do service in order for us to be able to reuse the to do service in our widget extension it needs to actually be a member of the widget target right now let's open up the file inspector on the right hand side and then under target membership you can see that the to do service is only a member of the main app target so let's also add it to the widget extension this is one of the two files that we need to add the second one is to do itself as you can see we will return arrays of todo's and signal to do's in order to do servers so we definitely also need to have the todo struct inside of our widget extension so let's go over to that file and make sure that it's also a member of the widget extension next up we need to do one more setup step before we can implement the timeline provider and that is adding the data to our timeline entry you already learned about the importance of the timeline entry this is basically what is carried throughout the timeline and provided to your widget by the system at the correct date with the correct information the date is already specified here which is a requirement from the timeline entry protocol now let's also add the information and that's the to do's that should be shown at a specific date in our widget so let's just add a todo array here to our simple entry now we can actually use this entry to schedule updates in our widget using our timeline provider so we can close the simple entry here you can also close the todo over here as you can see now it doesn't compile anymore because we changed the requirements for our simple entry it now needs a date but it also needs a to do so let's try to fix all of these issues and at the same time i will explain you how each of these functions work briefly let me explain to you the placeholder function and actually let's not make me explain it to you let's just have a look at the definition oops the definition of the timeline provider and then you can see there are very very long descriptions of each of the functions for the placeholder function the getsnapshot function and the gettimeline function the placeholder function provides a timeline entry representing a placeholder version of the widget this is for example used when you display when your widget renders for the first time it can also be used in a widget gallery but i think there they actually use the get snapshot function now so basically we don't really need to care about what we return in the placeholder function as it's just a placeholder while the actual widget is loading so let's add the todo's here to our simple entry and to make life easy for us let's create an extension on to do to create some preview or some placeholder to do's with a given id so let's go back into the to do definition let's create an extension of to do and in here let's create a function called placeholder that takes in an id which is an integer and returns a to do for us and now we can use this in our um get place or in our placeholder function and also in other places later on for example for previews the function is really easy just construct a todo here using any user id it's just a place how that really doesn't matter what's important is that the id is unique because the todo is identifiable we have a list iterating or for each iterating of all of the to do's in our large size widget so it is important that the ids are unique and that's why we're passing in a id here in the placeholder function let's just pass that right into the to do for the title let's just say placeholder and for completed let's just say a random boolean so either one or two either true or false okay now that we have this placeholder function back in our provider we can now use that placeholder function here to fill out our list of to do's let's make one with the id 0 and one with the id 1 and then that should be good in our placeholder function here next up is the get snapshot function here we also have to create a simple entry or one single entry but instead of returning it like we're doing in the placeholder function we need to call the completion handler with this entry so very similar but now this can actually be called on your actual widget so we cannot use placeholder data here anymore instead we will use our to do service to get all to do's for that let's remove everything that is autogenerated here and since our todo service uses the new async await pattern let's directly start off by constructing a task so we can use asynchronous stuff and i can already spoiler it to you we will also need to catch some errors so we can also directly add a new catch block here now inside of the do block let's fetch the todo's from our todo service so let's say let to do's equal try to await to do service dot shared dot get all to do's you already know this we already used this or i already explained to you how this works next up let's construct a simple entry so let's say let entry equals a simple entry with the date of now and to do's of the todo's that we just fetched here and then let's call the completion handler with that timeline entry so let's just say completion with the entry in the catch case however we also want to call the completion block this case this time let's also return some placeholder so let's just say completion simple entry with the date of now and to do's we will just use placeholder zero now you can see here that the instance member placeholder cannot be used and that's because we forgot to say that this is a static function so we can directly call it on the type to do instead of a specific instantiated to do now these errors should also go away okay awesome now the last part which is also the most interesting and most important is the get timeline function let me remove everything and then let's go through the function step by step so you understand how it works similar to before we also have a completion handler but this time the completion handler doesn't accept one entry it actually accepts a timeline of entries that timeline is a collection of entries like an array but it also has a refresh policy that's the last thing that we will handle when setting up this get timeline function first of all let's do the same setup as before we know we're going to use the to do service so we will need a task we also need a do catch block inside of the do block let's fetch all to do's once again so let's say let all to do's equal try await our todo service dot shared dot get all to do's this is the exact same stuff as before then let's actually do a little trick here if you remember in our widget ui we will show a bunch of different todo's in our large size view this ui is meant for small amounts of data not for large amounts of data the ui will break if you pass in let's say 50 to do's because then the top bar will get pushed out of the screen so we will just um use the first five to do's that we get from the service so let's say let five to do's equal an array oops an array of our all to do's dot prefix of the length five this will give us the first five entries of the all to do's array that is not actually returning an array it's returning an array slice but we need an array so we will construct a new one here next let's also create a timeline entry so we will just create a new simple entry for the date of now with our five todo's in it up until now this is very similar to the get snapshot function and actually we should probably use this prefix 5 approach in the get snapshot function as well so let me copy it over and do it like this okay to make sure that the get snapshot function also doesn't break the ui okay so now we have our todo's we have our simple entry now what we need is a timeline and there are a couple of different ways to do this now one way is to create a bunch of different entries for example for right now in one hour in two hours and five hours and so on and pass all of them into a timeline and tell the timeline timeline to refresh once nothing is left in it anymore so in our case in five hours or what we are going to do construct a timeline with a single entry and tell it to refresh after some specific date has passed the idea is basically if you have content that you can already schedule right now throughout the day for example if you already have the users calendar you can schedule the whole calendar widget for the whole day but if you rely on live data that you download from the server which is what we're doing in our todo servers then it is always a good idea to only schedule one or two maybe three timeline entries and then force the timeline to refresh that way you will always have the most uptodate information so we will do the later we will create a timeline and this will accept an array of entries so we will just create an array with our single simple entry in it and then for the policy you can just hit dot as this is an enum very handy you can see there are three different reload policies the first one is at end so the timeline would reload when no more entry is left the second one is never i think this is very safe explanatory this means that the app itself will never reload the timeline but however it will get reloaded sometimes for example if the user restarts their phone adds or removes the widget things like that the system decides when the timeline is really reloaded you only tell the system your preferences basically as the developer and then the last one is after a specific date which is what we will use and the date that we will use is now advanced by basically 60 seconds times 60 times 30 so basically every 30 minutes this timeline should get refreshed in practice this will probably not happen every 30 minutes since timelines only get refreshed when the user is actually on their home screen so if the user has their device in standby for a few hours then the widget will never get refreshed and will only get refreshed once they view the home screen again okay and now the last thing let's call the completion handler with our timeline again okay now in the catch block we will just have our placeholder data once again for that let's create some timeline entries this is just an array of simple entry just uh one for now so let's say the date is now and the to do's is dot placeholder with the id 0 just one for now doesn't really matter hopefully this catch block will never take place then let's also create a timeline which is just a timeline with the entries array and with the reload policy we will just copy over the one from up here basically what this would mean is that after 30 minutes try again to build a timeline okay and then let's pass the timeline to the completion handler as well and with that our timeline provider is already done now let's use all of these pieces of data that we pass into the simple entries inside of our actual widget views to do that let's go to the medium size view okay in our views previously we hard coded all of the data like the to do title and whether it was completed but also the to do id down here in our deep link url in the medium size view we only want to show one to do so to do that let's grab the v stack let's cut it out and in here let's say if let to do equal our entry dot to do's dot first we will just access the first todo let's paste back in our vstack now in here instead of this hard coded string let's say to do dot title and instead of the completed let's say to do dot completed let's use the ternary operator here so let's say if the to do is completed we want to say completed and else we want to say that it's open as this is a unwrapping of the first object it might be nil so there might not be any todo's in the simple entry for example because we couldn't fetch any from the server because we succeeded to fetch from the server but the server just returned an empty array in this case with the json placeholder api this should never happen but in your main app you might want to put an else block here as well and then display some error state you could for example say couldn't load to do's try again later or something like that okay now let's also replace the hard coded id here in our widget url for that let's say entry dot to do's dot first dot id this is optional but we can't have an option in here so we will have to provide an alternative basically and we will just null coalesce it with zero okay that's it for the medium size view let's jump into the large size view as well okay in the large size view now if you remember we had this hard coded zero through six range let's get rid of that and instead let's say entry dot to do's we don't need to provide an identifier because we did mark our to do as identifiable itself and does have the id property okay let's go top to bottom here so the first thing that we need to replace is the id in our deep link for that we can just say to do dot id and we actually need to grab the todo in in our for each for that to work then we had our if true here this of course should mean if to do that completed only then we want to show that little check mark on top of the circle and then i want to do the title also let's grab that one from the actual to do okay that should be it let me spin up the simulator and let's have a look at if everything works if we can see all of the todo's and if the deep links still correctly link into the app okay so as you can see it doesn't quite compile yet and that's because we still have our preview down here which doesn't have the updated simple entry initializer so we also have to pass in some todo's into our little swift ui preview here and let's also just use the placeholder function for zero and then also another one for one and i think this should be it now yep looks good let's compile now and see if it runs okay so the simulator just launched and i added all of the widgets first of all here you can see the medium size view it fetched one of our todo's and if we tap on it then the app will open up and the little cheat will come up with some more detailed information about that to do and if we go back to the home screen and move over then we can see our large size widget which also fetched the last five to do's as we specified using the prefix operator and if we tap on any of these to do's then the fitting section will also open up and show up in the sheet because we passed down the correct id in the deep link this was the final lesson of the threepart widget kit course in this series you learned all the basics about widget kit how it works the way updates are scheduled multiple size classes reusing existing code and deep linking into your app