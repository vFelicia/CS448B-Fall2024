hi my name is stuart lynch and i'm very happy to be offering you this series on behalf of code with chris though the title of this series is ios concurrency it is much much more it's a six part series where i'll introduce you to json decoding and creating models from json building an api service to perform asynchronous network calls to fetch that json we'll go through the traditional completion handlerbased url functions handling and reporting errors along the way there are a lot of topics covered as my intention is to provide you with methods and understanding that you'll be able to apply to your own projects both now and in the future in this first video we'll focus on creating our models from the json and an api service to handle the process we'll create a generic function to handle the different api endpoints and models and use a result based completion handler with our own designed api error if this is something you're interested in then let's get started first create a new xcode ios app project and make sure it's a swift ui project and name it something like ios concurrency now i always like to add an app icon and launch screen to my app so that they are easily recognizable in the simulator or on my phone if i install it there i provided you with some resources for this project with these two items already created you can find those in the link in the description below so go to the assets folder of your project and drag the launch screen image into that folder next select your app's target and then the info tab to see the new ios 15 info.plist drop down the disclosure icon on the launch screen then click on the plus icon and select image name make sure that you enter the image name with the lowercase l and uppercase s but don't enter the png extension next right click on the app icon in the assets folder and choose show in finder bring up that provided resources folder once more and move the app icon app icon set into that folder replacing the empty one we've just installed the icon and launch screen if you run your app now in the simulator when it launches you should see that launch screen if you exit the app or quit and check the simulator's home screen you'll see that icon on your app this project is going to be using the json placeholder api to fetch and decode json this api has a number of endpoints that you can use one of them is the user's endpoint where we can fetch json corresponding to 10 different users as you can see from this json here let's take a look at the post endpoint users are able to create posts as you can see from this endpoints json and there are 100 of them corresponding to 10 for each of the 10 different users what we'll need to do is to create a struct that will model that json that's why we often call these structs that represent something a model i have created a couple of youtube videos on modeling data from json and there are a number of tools available to you to do that as well the tool that i use a lot is one called ducky model editor however many people are happy with a free web paste tool called quick type these tools are particularly useful if you want to model really complex objects that have nested json our two are relatively simple so i want to model them by hand so first let's create a new group called models next create a new swift file called user now i'm going to want to reference the user's endpoint so i'll need to go back and copy that url and then i can paste it as a comment at the top of my struct so that i have quick reference to it well now with that file created i'm going to create that struct and i'm going to call it the same name user now for the user i'm really only interested in modeling the id name username and email and since these are all top level keys in the key value pairs of this json we can simply create properties that use the same name and the id will be an int and the other three are strings now since we're only going to be reading this information and not modifying it we can create the properties as constants using let now in order to decode this json the model has to conform to the codable protocol and because each one of these properties are simple types that conform to the quotable protocol already the entire struct will too so we can mark it as conforming to codable protocol we're also going to want to present our users in a list view and it's much easier to do if the struct conforms to the identifiable protocol and the only requirement for that is that there is a unique property called id and we already have that so let's do the same now for the posts json endpoint first let me copy the endpoint for the post url so that i can use as a reference and then i want to create a new file called post and in that file i can paste that url as a reference for our new model struct now this url gets all of the posts but what i want to know as well is how do i get the post for just one user so let me return to the api documentation to find that endpoint here it is and this is the one that i want so let me copy and paste that url in as well now i can create a new struct using that same name for the posts i want to model all four properties here and they are all top level as well so fairly easy to do just creating our properties using the same names as the key values in our json and again since we'll be reading this information only and not modifying it we'll create it using lips as constants both the user id and id are ints while the title and body are strings the user id property corresponds to the id property in our user model and the id though is the unique property for this particular model and again in order to decal with the json the model has to conform to the equitable protocol and because each of these properties are simple types that conform to the quotable protocol the entire struct wheel too and with the id property being here we can conform the construct itself to the identifiable protocol now i have an entire series on json decoding and it covers this as well as how to decode and encode your data which we'll be going over soon i'll leave a link here in the notes below now i want to create a struct that i can use as a service that i can call from a variety of different views to fetch our data whether that be an array of user or an array of post now there are a number of ways to do this and you may have heard of a singleton but it gets a lot of bad press about not being able to test but we're not going to be running any unit tests on this project but let's start right now by creating good habits and anytime we want to access that service we'll create a new instance of the service so i'm going to create a group called services and even though there's only going to be one service that i create i want to keep my code organized inside that folder group i'll create a new file and i'll call it api service and inside there i'll create a struct using that same name now the struct will have one property that will be the url string representing the endpoint and we're going to have two different ones one for the users and one for the posts so each time that we create an instance of this struct we'll need to pass in a different string representing that endpoint next we'll create a function called get users now this function is going to have to return an array of users so my first inclination is to return an array of users like this unfortunately this won't work at least not yet later on in the series we'll be covering new concurrency models introduced in ios 15 but as you are likely to see still for quite a while the older method of dealing with concurrency we're going to start there this will require using what is known as a completion handler and eventually we're going to be using a result type as our completion handler's argument but i'm getting ahead of myself if you are still confused after i finish this video i recommend that you watch the two videos i have on that topic and links are in the description below let's start easy now and build on this concept the reason we need a completion handler is because we have no idea how long it's going to take for that network call to fetch that data and since our code is inherently synchronous it would move on to the next line before we received our data and a completion handler is just a closure that we can pass in as an argument so that it will get executed when that data has been retrieved and we can give that closure a name and typically people call it something like completion or completion handler so when this function has completed and we'll either have successfully retrieved our json and decoded it or an error will have been produced so when we call this function we'll need to deal with either case but first i'm going to keep it simple and deal with the error right here within the function and only execute the closure if we successfully decoded the data so the closure function is going to have an argument which will be an array of user that we've returned and it's going to return nothing or void there will be another issue however as we'll be fetching that from a server and it's going to take some time the function itself will escape the scope before we're done so we'll need to specify that this completion handler is going to escape so we do that by marking the completion function as escaping well now we can get to work first we'll need to create a url from our string and we can use a guard check for this so we'll guard url equals the url string from url string else we'll just return from the function next we'll use the url sessions singleton datatask function with url and this also has a completion handler just like our function does so we'll pass in the url for the url and when we hit enter on the closure we see that we can assign variables for the three different objects that are coming back data response and error and all three of these properties are optional the most important thing that we have to do before we forget however is to make sure that this task gets initiated so we'll also need to call resume because it's initially in a suspended state so now we can check on those three optional items that we get back first we'll check the response to see if it has a status code of 200 and that it's not nil so another guard check guard http response equal response as an http url response and also that the status code is equal to 200. else we'll just return we also only want to continue if there isn't an error so guard if error is equal to nil we can continue else we'll return from the function if we get this far then we'll need to check to see if we got data so another guard check guard but data equals data else return well now that we've got the data we can try to decode it and the key word here is try but first we'll need a decoder let decoder equals json decoder now because the decoding might fail and throw an error which means generate an error we have to create a do catch block to try and decode it and this is such a common construct the do catch block that i've created a code snippet for this so anytime you see me do dtc that stands for do try catch i have a code snippet that's going to generate that construct then we can let our decoded data be the result of trying to decode the array of user from that data and if it's successful we can just use that decoded data as the argument for our completion handler which is completion and it runs that function with that argument if it's not successful it fails so we'll just catch that error and then just print that there was an error now this will work but there are some severe limitations here and you'd not want to ship an app like this using this function when there is an error we're not giving any feedback to the user and it just exits the function the only time you do anything is when you print out that there was an error to the console but your user will never see that in a later video we're going to go over error handling in more detail but i want to set the stage here by changing this function to provide any errors to the caller so that eventually we can bubble that error up and provide an error to our users in the ui using an alert and this is where the result type comes in for our completion argument a result is simply an enum with two cases either a success case with an associated value and that associated value will be in our case the array of users the successful completion or a failure case where the result is a error type so instead of using simply an array of user in our completion handler i want to use a result type so we can change our completion argument to a result where the two cases are array of user or an error and then we'll need to fix that completion that we'd have in our function so that when we successfully decode the data the result success case dot success has an associated value and that associated value is our decoded data still with me well what about the failure case well it's going to fail every time we fail the guard check or in that do catch block we want to be more prescriptive so i'm going to create my own api error enum with all five of the cases where we could have possibly failed and the enum has to conform to the error protocol so there are five different cases in that first guard we have an invalid url so i'll set the case to be invalid url then we check the response status so my case is going to be invalid response status or perhaps the url session didn't work at all so it may be a dated task error perhaps the data was corrupt corrupt data and then finally once we get the data perhaps our model is incorrect so we'll get a decoding error so now when we fail we can do another completion using the failure case and that has an associated value that will just use our case so first we'll need to go back to where we define our result and say that we no longer want to have that error case just a generic error we want to be specific and say that it's going to be our api error and then each of those five cases we're going to now call our completion handler with the failure case and the associated value is going to be the corresponding case from our api error so first failure is an invalid url next an invalid response status then a data task error corrupt data and finally a decoding error now there are only two more things i want to do before i finish this video this function is looking pretty good but currently i can only use it for users and not post and when you look at this though the only time i use user is when i decode and define the associated value for the success case in our result type it could be easy just to copy and paste this function and change this to get posts and change user to post however there's a better way and that's using generics and i have a video on generics if you want to find out more information on that topic again a link will be in the description below the function will work for any decodable type object like our user and post objects and we can use that fact by specifying that the function should only work if that's what we're dealing with which is a decodable type so when we define our function we can specify that limitation and we can use a variable like t to represent that type and make sure that that type conforms to the decodable protocol and then everywhere where we see user we can replace it with the t placeholder now t is generic itself and it can represent either a single object or an array of objects so we don't really even need to specify array here we'll be able to specify that when we call the function and we're almost done and this is a service class that you can use in all of your projects but to make it even more inclusive and i go through this in my quotable series you may have a specific key decoding or date decoding strategy that you want to use so i'm going to create two more arguments here so before the closure let's add two more parameters for this function one is going to be a date decoding strategy which is a json decoder dot date decoding strategy and the second is a key decoding strategy which is a json decoder key decoding strategy now 99 of the time the defaults are just fine but since we are adding these two parameters when i call this function i'm going to be forced to enter in what would be my defaults when i create the instance of this getusers function so in order to make this optional for us i can assign the most common default values in the initializer for each parameter then after we create our decoder we can assign these properties to the decoder that's almost it but i forgot this function is still called get users when in fact it's going to be more generic so instead of calling it get users i'm going to change the name to get json instead well that's it we haven't tested it yet but we've created the groundwork for our app and the really good thing is that we've created a reusable api service class that you'll be able to use in your own projects in the future in the next video i'll show you how you can use this class and we'll also be improving on it when we start working on error handling hopefully this hasn't been too technical but it is worthwhile i think going through in some detail so that you understand why things are done this way when we start to use functions in a later video we'll be converting this to an alternative version that uses the new async and await concurrency model so in the next video of the series we'll be building out the ui and i'll introduce you to voodoo a modified mvvm design pattern and utilize xcode's source control features to ensure that our source code is protected hi my name is stuart lynch and this is the second of six videos in the ios concurrency series in the first video we began by creating our models and a service so that we could fetch and decode json from the json placeholder api in this video i'll introduce you to voodoo a modified mvvm design pattern so that we can create view models and views to display the content that we fetch from our api endpoints we'll also be seeing how we can use mock data so that we don't have to always make calls to the api when we design our apps and you'll be introduced to get source control using xcode i'm going to be using what mark markins from big mountain studio calls swift ui's vudu and this is a modified nvvm architecture there are three parts as you see a view the observable object and the data object now we've already created our data objects those are our models so i'll let you go through the post and i'm just going to start using it the first thing we have to do is to change the name of our opening view from content view to represent what our first view is going to be and that's going to be our users list view so we can do this by right clicking on the name and choosing refactor and when we type in our new name this not only renames the view but also the file name and any instances where it is referenced like in the app file the other thing you might want to do is to change the preview to users list view underscore preview and the header as well next we'll create a group called views and move that file into there i'm just going to adjust the order a little bit in my navigator i have my view here that i want to modify and i have data objects which are the user and post objects and now i need my observable object which i will call the users list view model so let's create a file in a new group called view models so inside that group i'll create a new file that i'll call users list view model and in there i'll create a new class with the same name but conforming to the observable object protocol now this class is going to have a single published property called users and that's going to be an array of user and i'll initialize it as an empty array so this is before we fetch our json it's also going to have a single function called fetch users so it's within this function then that we can call that function using our api service so first we'll need to create an instance of the api service and it requires a url string for the endpoint well we have that url string back in our model so we can copy that and we can then just paste it in here as the argument for the api service instance within the function then we can call the api services get json function and this provides us with a closing completion handler that is a result however this result type is generic so we'll need to specify which objects we expect to come back as the cases for the argument for that completion handler well we know that a result type has two cases and for this instance the first case the success case is going to be an array of users and the error is going to be of the type of our new api error and then we can switch on the result in an xcode 15 this nicely completes the case for me however i'm going to change the let's success to be let users and let failure to be let errors so users represents the users that we're getting back and error will represent any error that we might get now we know that that success type is that array of users so we can assign those users then to that published property of users but it's an asynchronous function that's executing on a background thread and we're going to be using this array of users to update our ui so we'll need to go back onto the main thread to do that using a dispatchq dot main dot async and just like i had a code snippet for my do catch block i have one for this dispatch queue as well all i have to do is enter dq so for the failure then i'll just print out the error at this time we'll deal with this a little bit later great now we can use this view model back in our users list view first we'll create a state object that i'll call vm that will be an instance of our user's view model next we'll replace the body with a navigation view and inside there let's create a list and then within the list we'll iterate over our view models users with a for each loop and then for each user in that array then we'll create a vstack with an alignment that is leading and then for two textviews within that stack we'll first create one it's going to represent the user.name property we'll set the font to title and then the next one we're going to represent the user's email in a text view and then we'll set the navigation title to say users we'll also set the list view style to just plain using the new condensed way of applying a list style and then finally when this view appears we can call our view models fetch users function and thus update the view so if we resume our canvas all we see is the navigation bar we don't see the preview and this is because our preview provider hasn't fetched any of our users this is only happening if we go into preview mode so we'll have to enter preview mode to initiate the fetch and display that list of fetched users i'd really like to see what my view looks like without having to make that network call you may have noticed that xcode provides us with a preview content folder and this is where you can place content that you want to exclude from your release builds when you upload to the app store the content will be available to you during development or the debug stage so this is a great place to store that kind of information and the easiest way to do that in our case is to use a sample of the json that you'll actually get from your api now i recommend you use safari without any json extension enabled so that when we view our endpoints the json will be displayed as json text in the browser window so let's go get the 10 users json from the json placeholder api all i have to do is select and copy the text to my clipboard then within the preview content group i'm going to create a new file that i'll call users.json now make sure you specify json as the extension and then replace the entire content with what you copied from your clipboard now i want to repeat exactly the same process for the post because we're going to be building out the ui for a list of posts as well so we'll go to the post json endpoint we'll copy that json i'll return to xcode and create a new file that i'll call posts.json and paste the json into there this content is now located in your application bundle during debug mode so we'll need to somehow access that and i'm going to create an extension to bundle that will easily decode this data so as long as it is a decodable type which we know ours is i'm going to share with you an extension that i copied and modified from paul hudson from hacking with swift it uses generics just like we did in our api services get json function to decode decodable objects from files stored in your application bundle now i use this all the time so i've created a just where i can get access to it at any time and a link to this is provided in the description below the code should look actually pretty familiar to you it's just that we're getting our url from the bundle instead of an endpoint and instead of a result completion handler decoding from a file isn't asynchronous so we can simply just exit with a fatal error if something goes wrong and return the decoded data if we're successful now i suggest that you just copy this to your clipboard now returning to xcode i'm going to create a new group that i'll call extensions and inside that folder i'm going to create a new file that i'll call bundle plus extension now just below the import i'll just paste that extension it's ready to use so you feel free to use this in any of your projects it's a really handy extension next we'll create a file within the preview content folder that i'll call mock data first i'm going to create an extension to the user struct and within there i'm going to create two static computed properties one that will return an array of users and another that's going to return a single user that we can use for our previews the first we'll call mock users which is an array of user and what we're going to return is that array that we decode from our bundled file so we can simply use bundle dot main dot decode the array of user type self from the users.json file within quotes for the single user then we can just create another static computed property called mock single user of type user and we'll just return the first item from our mock users by accessing the static property on self at index 0. well we can do the same for our post so all we have to do is create a new extension for post and then i'll just copy from above and anywhere i had user i'll just change it to post now i'm also going to be needing a post for a single user so i'll create one more static property that i'll call mock single users post array it's a mouthful but it's descriptive and this will be an array of post but i'll filter it so that it's using a user id that matches the number one because i know that there is a user with an id of one in my mock users great so how do we use it now there's a problem with the fact that we're using a view model to fetch our users and there's no easy way to display mock data while developing your ui in this case because whenever your view model is instantiated we set the array of users to an empty array and then the view appears when we fetch users from the api now there are a couple of ways around this you could create an alternative initializer for the view model like this we create an extension on the user's view model and in there we'll create a convenience initializer with an additional parameter called for preview that's a boolean value that will default to false then we can call the self the parents initializer which sets users to an empty array and then if we specify that for preview has been true we'll set the users to be our users.mock users with this in place then we can go back to the users list view and anytime we want to show mock data in our initializer we can simply change it so that we have this convenience initializer where we'll set for preview true and we see then without making a call to the endpoint our preview provider will generate that preview on the canvas now the bad news is that we will either have to remove the argument or set it to false when we ship otherwise our users will get that mock data first even if it never makes a call to the api so for this reason i suggest that you place a warning above this state object to remind you that you need to remove that argument before you ship now the good news is that even if your argument is set to true whenever you run on the simulator or on a device the preview will be overridden by the fetch users call on the api so that the data will quickly be replaced but it's still not ideal so remember to remove that argument or not use it at all and just keep pressing preview however if you're paying for a service that charges for fetch requests you definitely don't want to do this now we're going to do a similar thing for our posts and we'll create a post list view model that conforms to the observable object like our users list view model we'll have a published property but this time it will be an array of post objects now the criteria for fetching posts for a user will be a user id and we won't know that user id until we specify it so let's make it optional and it will default as nil and then like in our other view model we'll want to fetch the posts but we won't do that until our user id has been specified so we can use an if let here to unwrap user id so first we'll need an endpoint for the single user post so we can copy that from the post model and then returning to our post list view model we can create a new instance of that api service passing in that string making sure that we replace the hardcoded one with the user id from our view model now inside that function we can use a similar api call as when fetching our users so let's just copy and paste that in here and adjust to fit for our result we're getting back an array of post not an array of user and when we're successful we get posts so we can set our published post to that decoded array to display the posts for the user we'll need a new swift ui view that uses this view model so let's create a new file within our views folder that we'll call posts list view and inside that struct will create a new state object for post list view model now we're going to be presenting this view from a navigation view so we don't need to add one in here it's already going to be here but we can create our list so let's just copy the code from the previous view and adjust to fit again first we'll change all references from users to posts or post for the first text view let's pick the post title but change the font to headline and for the second we'll use the post body but also set a font for call out and change the foreground color to secondary and then for the navigation title we'll change it to posts and change our navigation bar title display mode to be inline in the on appear then we can change this to fetch posts the errors are all gone now but our user id in our view model is still nil so we'll not be able to get any listings yet we'll have to be injecting the id when we tap on a row from our users list so let's create a property here that's not going to change once we've passed it in so it doesn't need to be a binding and it's going to be a user id we'll also need to pass in a user id to stop the preview from completing so let me just enter a 1 here and then in on appear before we fetch our posts we'll set the user id within our view model to be what was passed in and it will no longer be optional therefore we'll generate the list view that we can be presented in this view similarly we're not going to be seeing that navigation bar because our preview has no idea that our view is in a navigation view so we can surround our preview with a navigation view just so that we can see what it looks like in our canvas i'd also like to make sure that we have some mock data so that we can view the list of posts within our canvas without having to make a call to the api so we're going to have to do the similar thing that we did with our list view model so we'll go back to that one and then we'll just copy that extension and we'll change the extension to be a postlist view model extension and adjust it here where we display instead a mock single user's post array so back in our view then we can do the same thing by cautiously adding a preview argument when creating our view model then back in our list view in order to be directed to the post list view we'll need to create a navigation link and the navigation links destination is going to be our post list view passing in the selected user id and the label will be exactly what we have if i test this now it all just works perfect but one more thing though when i run this on the simulator i get these constraint warnings showing up in the console and this happens when you embed your views in an unstacked navigation view i think this has to be an xcode bug because i'm using swift ui and not ui kit and i have no idea how i can adjust constraints if you want to suppress these errors you can set a value for user defaults that can suppress the warning so when your user's list view is first instantiated at launch time in the app file we can assign this in the on appear function and i do this again so often that i have another code snippet for this and we set the user default standard value to false for the key which is in quotes this ui constraint based layout log unsatisfiable so you've seen now that i've used three different code snippets so far so if you're interested in code snippets they're very powerful i recommend that you watch this video that i created quite some time ago on creating your own code snippets well we've spent a lot of time so far on this project and we want to make sure that going forward as we make adjustments we can return to a point in time in the past in case we need to rework something and this is known as source control and the most common versioning system for developers is called git and xcode provides us with access to git right from its own source control menu i have an entire series on source control with git and xcode if you're interested in learning more i'll leave a link in the description below all we have to do is select commit from the source control menu and enter a comment as to what stage you are in your project and that's a reference we'll be exploring more source code features in future videos in this series in the next video in this series we'll be finishing up the first part of the series to provide better feedback to our users so that they'll know when our application is actually fetching data so they have to be patient and if there are any errors we can let them know to file a bug report with the developer hi my name is stuart lynch and this is the third of six videos in the ios concurrency series at the end of the second video we had a working application but the user experience was not optimal in this video we're going to improve the user experience by doing two things whenever our app is fetching and loading data we want to present a spinning progress view on top of our view to indicate that the data is loading if an error does occur then we want to know about it so instead of printing the error to the console or doing nothing at all we want to present an alert to our users with that error information and ask them to contact us with that information now if you're just jumping into the start of this series you can download the completed code from the second video in this series from the link in the description below sometimes our users might be on a slow connection so fetching data from a network call might take some time to be retrieved and decoded your user shouldn't be sitting there wondering what's going on you should give them some visual clue that something is happening and swift ui gives us a nice spinner called a progress view that we can use for this so in order to present the progress view we'll need to have some sort of a published property in our view model that we can toggle so in the users list view model create a published property that you can call is loading and set it equal to false that makes it a boolean property then as soon as we start to fetch that data we'll toggle it making it now true now a defer block is used for executing code just before transferring program control outside of the scope that the statement appears in and this means that when the function has completed so inside of our api service class we can create a defer block and the code inside there will be executed after the data is retrieved and processed so what do we want to do when that's done well we want to toggle that is loading again to set it back to false now since that's on a background thread and we are using a published property we'll need to make sure that we get it back onto the main thread and we'll do that again within a dispatchq.main.async block so to display the progress view while it's loading well we can return to the users list view and here we can create an overlay on the list view using the overlay function and the content will be a progress view but we only want to display the progress view if the view model is loading has been set to true if we test this now we'll first need to set our for preview to false to get a real test now i'm on a fast network and i can't really notice that progress view the data loads really quickly even when i try dark mode it's it's not obvious i really can't see it so we can simulate a slow connection here by surrounding our api service call within a dispatchq dot main dot async after block and we can set a delay of say one second so let's test once more now we can see it so let's repeat this then for the post list view model when we're fetching the posts first we'll need a published property called is loading and set it initially to false then we toggle it when we start to fetch our posts and then for our defer block we can just copy it from our user's list view model here and use it inside the get json function similarly we can reuse the code that we created for the users list view overlay here because we use the same property names for the view model and the is loading property so let's make sure that we commit our source code now it looks like some of my assets weren't committed from the last commit that question mark's an indication and i'm not sure what went wrong here but let's select them and make sure that the commit now works to commit those to our repository now we've structured our app so that it doesn't crash when fetching and decoding data it either prints out that decoding error or it just does nothing there's no indication that anything goes wrong and the user has no idea why they're not going to get the data for example let's go to our users list model and add another property one that's going to invalidate the decoding for example let test be string it'll be invalidated because there is no key value pair in the json to correspond to this so when we run this we'll see that case decoding error is printed on the console that's just the case name for our api error that's not any help to our users and it's not really much help to me we want to present something more descriptive for each of these user cases but before i do that let's take away that delay in our fetch request we just did that for testing now if the error was an actual ns error like what happens in our data task or in the decoding routine we can pass along the localized description that's part of that error along to the api error and we can do that by using an enums associated value now i have a whole video on associated values for enum if you're unfamiliar with that concept i recommend that you take a look at it and now that we have an associated value we've got some errors so we have to provide that associative value which is the localized description in the cases of our error here and in the case of this error we can safely unwrap it because it's not nil in the second case the catch block will generate an unwrapped error with its own localized description too so we can use it here but what about these other cases well we can provide our own localized description for each of these cases we've got our own error we can create our own description and the way that you do that is to make sure that your api error conforms to the localized error protocol and this now provides us with a new property called error description and it's an optional string and we can make that into a computed property and switch on self and then allow xcode again to generate the cases for us now for the three without an associated value we can return our own custom localized string we use ns localize string and this accepts a string and a comment now the string is what you want to have as the localized error and the comment is there for your translator should you actually be localizing your app to other languages and this would be another video series entirely i think so since we're not we can just enter a string that makes sense like this one and leave the comment as an empty string we can then copy and paste this into the remaining two cases and we can adjust the string as needed to represent the error for the two that have an associated value already we'll simply return that string which is the associated value that we passed in when we created the error and that's the errors actual localized description so now our error our api error has a localized description for all five cases well now we can use those strings as part of a message in an alert that we can present to the users whenever an error occurs so let's return to the users list view model and prepare for that to present an alert in our view we'll need to provide not only the boolean property to trigger the alert but also the message corresponding to the error that we can put in the alerts message so we'll create a new published property first called show alert and we'll set it initially to false we'll also need to have an optional string property that we can set with our error message when we have an error and this too has to be a published property now whenever we have an error we can set show alert to true and assign our localized error and further information as the alert error message and we need to do this on the main thread because we're changing a published property that will affect the ui so inside a dispatch dispatchqueue.main.async block in users list view then we can attach an alert to our list using the new ios 15 alert type that will have a localized string as the title bound to a boolean for is presented with actions for buttons and a view for our message the title will just be application error is presented is going to be bound to our view model's show alert published property and the action is that button that has a label of ok but no action and when it's tapped swift ui will take care of dismissing the alert then for the message if it's no longer optional we can use the view model's error string as the string for the text view in our message if we test this now we see that our error is displayed great now before we forget let's fix that user model to remove that extra property because we've done a great job here we're not going to get any errors but just in case you do your users are going to see it now let's do the same thing for the post list view model and post list view we can simply copy the code from the two files that we've already done because they'll be identical first the two publish properties then the failure code to trigger the alert and then for the view itself we can copy the whole alert again because we use the same variable names the code will just work well before we forget let's update our source control by issuing a new commit it looks like i missed one of those assets the last time so let's make sure i do it here now all five of our files are updated and that's important because in the next video in this series we're going to branch off of this main branch that we've been working on so that we can take a look at the new concurrency model introduced in ios 15. we still need this branch though because we'll be checking it out again later though and will branch off in another direction when we change our deployment target hi my name is stuart lynch and this is the fourth of six videos in the ios concurrency series at the end of the third video we had our completed application and it was using a result based completion handler for our api services get json function in this video we're going to be implementing the new asynchronous methods introduced in ios 15. this will introduce you to new terms such as async and await main actor and an asynchronous unit of work called the task now if you're just jumping into the start of this series you can download the completed code from the third video in this series from the link in the description below the first thing we should do since we're going to be experimenting with a new feature is create a new branch for our project so that if things go awry we can always roll back to that one that we completed in the last video and that's a fully working app so switch to the source code navigator then select the repositories tab and expand the application you'll notice that the current branch is the one that's called main and if you expand the branches section you'll see it right click on main and choose new branch from main and call it async and await no spaces it should automatically check that branch out and switch to it but if it doesn't like mine doesn't i'll right click on the branch and choose checkout that means i'm leaving the old main branch behind and that code is safe and won't be touched and you'll always know what branch you're on because you'll see that in the title bar now within the api service struct i want to create a new function and i'm going to use the same name and this is going to allow because i'm going to be giving this function different parameters instead of providing a completion handler i'm going to do what i used to do when i knew nothing about asynchronous nature of network calls and in fact i was bitten by this when i first started coding i thought every line of code waited until the previous line of code completed before moving on so i would call get json and then just return my array of objects from the call so i can copy everything except the completion handler from this method then close it off and then return that decodable object which in our case is either an array of user or an array of post but we're using generics so it's just t now this means within my view model i expect to get my array of user or posts back immediately so that i can assign it to my published property and that's what i would have thought well let's try and fix this function up so that we can actually do that let me start the same way as before i'm going to copy the pasted code but since there's no completion handler let's just rule that out and just return now this isn't really good because remember we want to pass that error on up to our calling view so that we can present it to the user in an alert so we can designate this function as being a throwing function one that might throw an error or cause an error and we do that by typing throws before the return then you can throw the error rather than returning and what kind of error do we have we have an invalid url error so we can just throw the api errors invalid url case by designating a function as being a throwing function every time you call the function you're going to have to at some point catch the errors that were thrown by it so this means we'll be passing the error higher up the calling hierarchy this function could have been called by another function that was itself called by another one and at some point then you need to catch and deal with that error or maybe translate that error into a different type of error and that's where a do try catch block comes in and you'll see that in just a second so here's where i ran into a roadblock when i'm fetching from a network it's not asynchronous normally we have to wait until i get that response before i can move on to the decoding the data and this is the equivalent to a completion handler we wait for it to complete processing before we pass it back as the argument for our completion function now though instead of using our previous url sessions data task with url function we're going to use a different version when we start typing urlsession.shared.data i see that there are a number of options and i can scroll down and there are some grayed out ones and the one that i'm looking for is this one here and you'll see why it's grayed out in just a minute we see that it's marked with async throws the throws means what we've just experienced if we run into an error we can throw that error back to the caller but what about async well i'll get to that in just a minute we do see however that it will return both a data and a url response and this function itself has been designated as throwing so here's what i talked about somewhere on down the chain we have a throwing function and we're going to have to deal with it at some point so let's deal with it here and convert that error into our own api error so we'll catch that error and then pass it on up to our caller now the delegate is optional so we can remove that and the url is just our url so let's just use it remember that function does return data and response so we'll create a tuple of our own to assign those return values now xcode is going to help us here it generates an error and it says that this function can throw but it's not marked with try so anytime a function throws you have to use try so that url session function it was a throwing function so we'll have to try now this creates a new error which is the async call in a function does not support concurrency and that's when our function was designated as an async throwing function and this is new for us it means that that get json function needs to support concurrency so we'll need to have to go back up to where we define our function and make it an async throwing function now we're not out of the water yet though because we're told now that the expression is async but it's not marked with a weight and that's because the function is an asynchronous one and we have no idea how long it's going to take for our data and response to come back so we must wait for it before we move on in our code and we do this by specifying that we await for that tuple before assigning it to our constant and the order matters we first try and then we await for the result from our call now what if that data from the url function actually produces an error that try through an error well by using a simple try we're saying that we want the error to bubble up to whatever viewmodel is calling that function but i want to handle all my errors here in the same way right here in this function so i'm going to catch that error and change it to one of my ati error types and throw it so for this what i'll do is use a do catch block and in the catch block then i can throw our api services api error which is the data task error case and it needs an associated value which is the localized description of the error that that one level up through so now we have data and response so we can check exactly the same way as we did before first for the response we need to check that it's a code of 200 or throw so we can do this inside a do catch block just like we did before only we have a completion handler to pass our under error with we don't have one anymore so instead we're just going to throw an api error which is the case in valid response status still within the do block we have that data and the data task error will have thrown an error there been one so now we can decode and return the decoded data now unless there is an error decoding data in which case again no completion handler we'll need to throw the decoding error using that errors localized description as the associated value for our api error type well that's it we're done our app would still build and run because we're still calling that original function though i haven't deleted it at least not yet let's return now to our users list view model and change that call we'll still need that instance of api service and the is loading toggle function but this get json function needs to be commented out for now but i'll keep it here just for reference instead we can use our new api service get json function now we know that it's going to return our user so let's assign the return value to users and we'll call that function now notice there are two of them we want the async throws one now this generates an error call can throw but it's not marked with try and the error is not handled in fact the order in which the arrow occurs as there are going to be three of them may be different from you but the errors are the same as we saw earlier first we'll need a try and we'll need to designate that function as being asynchronous then we'll need to await the result but we're at the end of the line now if we encountered any errors we'll need to set our show alert to true and set the error message so that the localized description is used for the message body so we can do that do catch block right now to handle that well we're going to do it the same way that we did before by setting the show error alert to true and setting the error message to that errors localized description and we don't even need self we no longer need this commented out code here for reference so let's just delete it our is loading property has been toggled to true but we've never turned it off well since this entire function is asynchronous we can place our defer block right after it and it won't be toggled or called if the execution is going to be deferred until the function exits its scope so we can just use defer is loading toggle right after we assign it isn't this nice and clean so much easier to read and follow now users is a published property and this function is executing on a background thread so we'll get that severe warning if we don't do something to fix that and set it back on the main thread if i try to enclose this with a dispatchq.main.async block i get an error in swift 5.5 there is a new attribute called main actor that we can use to decorate the entire function and it will then dispatch this task onto the main thread when we build we get an error though in the users list view because it's now calling that new get users function and that's an asynchronous function so what we have to do is make sure that our on appear is asynchronous and so what we can do is we can within that on appear function create an asynchronous unit of work which we'll call a task and since that's asynchronous we need to await the result no try here though because we've caught any errors back in that fetch users function well in ios 15 we can go one step further than this we can combine both on appear and task into a new asynchronous task method that adds an asynchronous task to perform when this view appears this code is much easier to follow and work with when i make that call to fetch users i'm either going to be successful or it'll throw an error if successful we assign the decoded data to our published property since this is our calling point of our throwing functions we need to deal with any errors that were thrown earlier in the process and therefore the do catch block it all compiles properly now no errors but our posts are still using that old api service get json function so we want to fix that before we can remove it so let's do that let's return to the users list view model and we'll copy everything from the defer on down then in post list view in the fetch post function will replace the old get json function with this new code we just have to change our users to posts it's complaining however because it's an async call in a function that doesn't support concurrency remember anytime we've got concurrency we need to specify that our function is asynchronous and also don't forget that we need to dispatch that task back onto the main queue so we decorate the function with the main actor attribute this requires one more change in the post list view as well because we are now calling an asynchronous task so we'll need to create that unit of work which means we'll change appear to task and then await the return of our posts we can test now in the simulator and we'll see that it all works just as before but with much more readable code after having done all of that work we want to make sure that you commit the changes to your git repository this is so much cleaner now in the fifth video in this series we're going to take this even further we are currently fetching all of our users at once and then at one at a time we're fetching an individual user's post as needed and we'll do that every time that we click on one of the rows in our users list that's a lot of network calls if we're viewing a lot of different users posts so what we'll do in the next video is retrieve all of the users and all of the posts in parallel so that they're all in memory and then filter the posts for each individual user as we need them a maximum of two network calls anytime we launch our application hi my name is stuart 9chan this is the fifth of six videos in the ios concurrency series by the end of the fourth video we had converted our get json function into one that uses the new async and away concurrency method introduced in ios 15. in this video we're going to extend that even further by introducing you to parallel asynchronous concurrency using asynclet we'll create a new model to contain a user and all of that user's posts in an array and use that model after fetching all users and posts up front in two asynchronous calls in parallel when the user's list loads thus potentially reducing the number of network requests now if you're just jumping into the start of this series you can download the completed code from the fourth video of this series from the link in the description below now that we have much more easily readable code i want to show you where this really shines let's create a new experimental branch on this current branch so make sure you select the source control navigator then right click on async and await and create a new branch from here and call it parallel concurrency and make sure you check out that branch if it's not done automatically what i'd like to do now is to fetch all of our users and all the posts before presenting the list view and add a count of the number of posts per user alongside their name in the users list view then since i have all of the users posts i can pass them on to the post list view for that user instead of when i get there this should limit the number of server requests to 2 then no matter how many times i go from users to posts so to do this i'm going to need a new model that we can use to consolidate this information in the models folder create a new swift file called user and posts and in there create a struct with the same name i'm going to be using this in the users list view so i want to to conform to the identifiable protocol we'll need an id property to make sure that it does conform to that protocol so to make it easy let's just create one and we'll use the uuid now each object will contain a user and that user's posts so the user will be of type user and posts will be an array of post i do want one more thing though and that is the number of posts so that i can display it so i can create a computed property for this called number of posts and it will be an int that returns the post count in the users listview model right now we have a single function that fetches users what if after we fetch users then we fetch all of the posts and then run a loop through our users filtering the posts by id and then assigning them to that user so let's change this publish property here to no longer be an array of user but an array of user and posts of course this is going to break our code because we no longer have that published user property but we still have to keep track of them until we build our now empty user and posts array so let's just preface this with a let to create a constant users containing the array of fetched users but this is a new property and users won't know what it's expecting to retrieve so we'll need to specify that it expects an array of user this convenient init no longer uses any users and we've not set up any in our mock data for our new users and posts so let's just comment this out for now so how do we get all posts well the url for that can be found in the api documentation and we put that endpoint url as a comment at the top of our post struct so we'll copy that now and we'll create a new instance of the api service passing in that endpoint then we can asynchronously fetch all of the posts the same way that we fetched all of our users but this time for posts and it's an array of post now if we had to do this with our old callback method we'd be in a little bit of trouble since we would need to have nested these requests within an api service get json callback function with a completion handler here the power of async and await really shines this fetch post request won't be executed until the above one has completed so it looks almost synchronous well now that we have both users and posts we can loop on users and then we can determine that particular user's post by filtering the posts array where the user id is equal to the user id and we can use the array filter operation for this and using a higher order function really condenses your code and if you're familiar with the syntax it's quite easy to read if you are unfamiliar with this you can check out my video on higher order functions and this one here in particular includes the filter function well now that we have a user in all of her posts we can create a new user and posts so we can pass in the user and all of our posts and then we can append it to our users in posts publish property users in list view of course is broken because we no longer have an array of users we have an array of user and posts so in the navigation link we no longer are going to pass in the user id we want to pass the entire array so we'll just have to fix the post list view as well in a minute so for now let's just change this to post list view posts being user and posts dot posts for the label we'll need to change this to user and post dot user to access the user's name and the user's email properties i also mentioned we want to display the number of posts so we can do that right here by embedding the name text view in an h stack and then after the name we'll add a spacer and then present another text view with the computed property of the number of posts from our model and use string interpolation to surround the number with brackets all we have to do now is fix up that post list view now instead of having to create a view model i can remove this state object altogether we're not expecting a user id anymore we're expecting an array of post since our posts are no longer in a view model we can remove the vm there will no longer be a need for the alert here because we're not going to be fetching anything here and we can also remove the overlay and the task now our preview is complaining here so we'll need to fix that which means that we'll need more mock data but we'll come back to that for the moment let's just comment the preview out here i'm still getting an error when i want to build uh yeah i see i forgot that i commented out that convenience initializer so it no longer exists so i need to remove it here when we initialize if we test this in the simulator now it works and we see the number of posts besides each user it just so happens that this api actually has 10 posts per user but trust me if the count were different per user this would still work so let's fix that mock data for our preview we can create a new extension in our mock data file for user and posts and then create a static computed property that's called users and posts that is an array of our new user and posts object so we then repeat the same process that we did when we are in our users view model we'll create an empty array of new user and posts and then we'll loop through our mock users from the user model will create a new user and post filtering the post mock posts to get just the posts for that particular user and then we'll append it to that new user and post array and once the loop is completed we can return the new users and posts back then to the users list view model we can fix that extension so that users and posts is user and posts mock users and posts and then in the post list view then we can uncomment the preview to change that argument to posts and pass in the post mock single users post array and then back in the user's list view we could add back that convenience initializer because we have it again and whether we are in the preview mode or not we can decide if we want to see that mock data in the canvas when it's set to true if it's set to false it disappears if we go back and check out our code and however there is something that can be improved on even more we're fetching all of our users and then waiting until they're all fetched before we fetch all of the posts the fetching of the posts is not reliant on the fetching of users in fact we could be doing this in parallel well welcome to asynclet we can simply preface each of our api service calls with async so that it now reads async lat now this creates errors in our for loop because we'll need to wait for them to have finished first before carrying on before we can access both the users and posts so we'll need to try and await for both and we can do that by assigning them to a new variable but as i said we'll have to await for both of them so let fetched users fetch posts in the tuple await for the users and posts but as i said these are failing because we'll have to try for each of them then all we need to do in our loop is to change user to fetch users and posts to fetch posts we're now getting both the users and posts at the same time and then we can then run our loop testing now we see that it all works nicely and we're now saving on costly network calls let's finish now then by committing this branch to our git repository in the final video of this series we'll be checking out that old main branch again and branching off of it to change our target back to ios 14 and see if we can use these new asynchronous functions in an earlier ios this is what's promised in xcode 13.2 hi my name is stuart lynch and this is the sixth and final video in the ios swift concurrency series in this video we're going to see if we can apply the new ios asynchronous concurrency methods to an xcode project with a target of ios 14. this will require xcode 13.2 or later and it wasn't until xcode 13.2 that apple backported some of these features to targets of ios 13 or earlier if you're just jumping into the start of this series you can download the completed code from the fifth video in this series from the link in the description below with xcode 13.2 some of the new concurrency features have been backported to ios 13. and this is great news because perhaps we realize that by setting our target to ios 15 only we're missing out on a lot of users who have not upgraded their phones we're currently using some ios 15 specific apis that we'll no longer be able to use but i would really like to use this new asynchronous concurrency model as we're testing again let's create a new branch by now this should be familiar to you select the source code navigator and then right click on the main branch to check it out notice that it is now the active branch and we're going to branch off of this one right here so we'll right click and create a new branch and i'll call it back port this time it created the branch and it checked it out all at the same time so now it's my current active branch that i can work on now this get json function in our api service is the completion handler version of our function and it doesn't use the new async and await concurrency methods that were introduced in ios 15. in videos four and five of this series we changed that to use these new methods now if you've updated your xcode to version 13.2 you should now be able to take advantage of those new features and projects for targeting earlier versions of ios and this is one of the terms target applies switch the application and you'll see both project and target the target in this sense means which of the apple sdks am i developing for is it mac os ios ipad os is it a widget kit application or one of many others if you click on the target and then on the general tab there is a deployment info section and here you get to see what the ios deployment target is and in my case here it's set to ios 15.2 this means that in order to install and run this application on your device it has to be running ios version 15.2 or higher and those who haven't upgraded yet can't run your application as i said you potentially may be losing out on a lot of customers in most cases the swift ui going back to ios 14 from ios 15 requires only minor changes depending on what apis you've implemented and we'll see that shortly going back to ios 13 is a little bit more problematic because there are more deprecated methods so i'm going to take the less troublesome path and change my target back to ios 14 and see what happens and what's going to be required when we build we get several errors and these errors are all saying that a particular api that we're using is only available in ios 15 and newer the overlay and alert apis we use in our code have changed since ios 14. so we're going to have to revert back to the deprecated versions that were available to us then it's important to note that deprecated doesn't mean that we are playing with fire there are many deprecated apis that have been around for many many years so there's no need to panic at some point however in the future though when you change your target back to ios 15 or higher you should change the code again to remove the deprecated versions if i click on one of the overlay errors it takes us to that culprit if you option click in the overlay error in users list view we get the quick help and if we scroll down further we see open in documentation so let's do that and we'll see that it's available from ios 15 on i know that there's an ios 14 version however because i use it and it doesn't put our view into this trailing closure rather overlay didn't use a closure at all so let's remove it now the error here is hard to decipher but if we enclose our clause here in a group the error goes away but we can repeat that in the post list view too so we'll do the same thing we'll remove the closure and embed it within a group let's check out the alert and option click and then drill down into the documentation i can see that it too is ios 15 on only now if i search through the documentation and click on the alert that's found i'm taken to another alert and i see that it's been available since ios 13 but that has been deprecated it may take several releases for it to actually disappear and by that time hopefully you've updated your code to use the more modern apis we can see that this documentation is within a section called deprecated views and controls scrolling down we can see the different initializers that were available to us if we remove this code now we can start typing dot alert and if we take a look at the options we can scroll down and we'll see the two earlier versions and they are marked in gray that's an indication that they're deprecated or not available to us however we can make them available to us let's choose the is presented version and it needs to be bound to something which is our view models show error alert inside the content closure we'll need to use what is known as an alert object and there are a number of options here the one we want is the one with title message both being text views and an optional dismiss button for the title we can use a text view and we'll just say application error for the message we can use another text view with our view models error message but it's optional so we'll no coalesce it with an empty string and we don't need the dismiss button because as i mentioned it's optional so we can just remove it we can repeat this process for the user's list view and i happen to know that the ad alert is exactly the same so we'll just copy it here and paste it or replace it with the same version if we build now there are no errors great but we really haven't gained anything what you have now is a project that you could have originally coded using xcode 12 under ios 14. if you want to go back to ios 13 you'd have to do more things like changing the navigation title to a navigation bar title you couldn't use state object and there's probably a host of others so i'm going to stop here but you can go back as far as ios 13 with swift ui the observant of you will notice that the list style is not complaining about my using dot plane instead of using the full instance of plane list style struct that we had to do in xcode 12 and it appears that the new style options have been backboarded so we don't need to do anything to change them well with xcode 13.2 we learned that the new concurrency methods have been backboarded as far back as ios 13. so if we want to update your api fetches to use this new asynchronous version of the url session data method we're going to have to implement those new features and this should greatly clean up our code well it turns out that although swift 5.5 new concurrency system is becoming backward compatible in xcode 13.2 some of the builtin apis that make use of these concurrency features are still only available on ios 15. mac os monterey and the rest of apple's 2021 operating systems the good news however is that we are provided with another method that we haven't looked at yet and it's a continuation mechanism that lets us retrofit existing code with async await support and what also is good news is that xcode gives us some assistance here if you command click on the function name for our existing completion handler version of get json you get three different options for converting this function to an asynchronous version and all three will work but we really would like to understand this so i can code in the future from the getgo so let's explore the options and we'll start from the bottom up if i choose this method it simply creates a new function that has the same first two parameters but instead of a completion handler it's an asynchronous throwing function just like our new one that we created in videos four and five no error then calling the new function yet json because as we saw in video four we can have two functions with the same name so long as the function parameters are different what this does use is the with checked throwing continuation that calls our old completion handler function and then essentially maps the continuation into an asynchronous one that's pretty cool but now i have two functions to clutter my code and our viewmodels are still calling the older version with the completion handler and not this version so let's just undo this and take a look at our second one if we choose this one it basically does the same thing as we saw in the previous example but it makes all of the same changes in line in the asynchronous version of our function with the use of the checked throwing continuation block and adds continuation resume for each of the result enum cases now the errors we're getting here are all related to the function now not recognizing the api error case since it's not specified in our function parameters and we can fix that by prepending all of the cases with api error and by removing any unnecessary returns still i have two functions to deal with and our viewmodels are still calling this older version with the completion handler and not this version so let's undo once more let's go all in now then and convert our function completely so that we only have a single function to deal with and that's what this first option will do for us well we'll need to fix those return and errors for not knowing what type the error is still just like we did in the last version the errors in this file all go away now but when i build i get four errors well why is that well it's because now i'm trying to call that old completion handler version that we had before and it's no longer here so let's fix that and this will be a repeat of what we basically did in video 4 when we created the async function from scratch in ios 15. in users list view model then let's remove from the fetch users function everything except the first two lines because we are going to need an instance of the api service and we want to set is loading to true but remember we can now use a defer block right within our function so after is loading dot toggle we'll add the defer block then we can simply create a do catch block and then within the do block we can try and await the return from the api service get json function and assign it to our users and we can fix the error because we need to specify that our function get json is now an asynchronous function in the catch block we can set show error to true and then set our error message with the errors localized description and that contact information and then we have to decorate the function with app main actor to ensure that the function is dispatched back on the main cube well we can copy everything from defer on down here and then go to the post list view model and replace the corresponding part of the get post function with this same content updating of course users to posts specifying that the fetch post function is asynchronous and adding the app main actor to make sure that we get executed on the main thread again we have a couple of errors left though and those are in our views and that's because in on appear we're trying to call a asynchronous function well we can't use dot task as we did in ios 15. it's one of those things that didn't get backboarded however you may recall that there's another option we can use a unit of asynchronous work called a task so we can embed within the on appear our content inside a task and await the fetching of the json finally then we can go to the post list view and do exactly the same thing for on appear we can enclose our actions in an asynchronous task and then await the fetching of the posts we can build and run now and all errors will disappear and our application runs we have successfully backported our application to run under ios 14 using the new asynchronous methods before we ship the app though make sure that you'll check any warnings the app is giving you like this one here that we left for ourself to make sure that the four previews is set to false now the last thing i'm going to do is commit any changes to our local git repository well that's it thanks for joining me on this six part journey and i hope that you've learned some useful and transferable skills i want to thank chris for inviting me to add content to his channel and i look forward to being able to contribute more in the future thanks for watching