hey guys welcome to lesson five of learn Objective C and today we are going to be talking about memory management okay so in this video we're talking about memory management so for this xcode project you can download it in the link below in the description or you can click on The annotation on the screen to download it and this project I have created a custom class called my class and what we're going to be doing is creating an instance of it in viewcontroller.m and then I'll show you guys some memory management details so start by importing my class and then in here I'm going to create an instance of it so we've done this a couple of times in previous videos but what we didn't really talk about is memory management so in Objective C there is no garbage collector if you're familiar from other uh languages like C and stuff like that so what is happening right here is we're actually allocating space in memory for this instance of my class as a developer in Objective C we are responsible for indicating when objects are in use when they they're still needed or when they they're not needed and they're ready to be deallocated and you know have that memory freed up so there's a system in Objective C for indicating that and it's called a retain counter so each instance of an object has uh something called a retain counter and it's a simple um it's just the number basically for in instance in this object my class instance we just allocated an in initialized it the retain counter for this guy is one and that indicates that it's still in use anything above one means it's in use so what's important to note is that after iOS 5 there's something called Arc or automatic reference counting and that kind of takes care of this memory management stuff for you but behind the scenes this is still happening and it's important to understand it so that's why I'm still explaining it um pre iOS 5 what would you'd have to do in this case is you'd actually have to release it so if I allocate this um instance of this object and I'm doing something with it in my method at the end of the me uh the method I'd actually have to go call release on it and what that does is it decrements the retain counter of that object by one which would bring it to zero and what happens when the retain counter for the instance of this object reaches zero is a special method gets called on that object called dioc and then the memory gets freed up and it's returned to the system so in my class you won't see a dioc method here it's actually you know a method at NS object but you what you do is you override it so what we're doing here is overriding the dioc method when the retain counter for that instance reaches zero this method dioc automatically gets called we never call it manually so super is referring to the parent class of um of my class so we're calling our parents dioc method but in here you know can have any sort of custom code to release other objects that this instance may have created so if in using my class you know I've created a whole bunch of other objects and allocated an initialize other things in my dioc method I would want to clean up all of that stuff and if we don't do that properly then our app is going to have memory leaks and possibly lead to app crashes going back to view controller uh if we manually wanted to increment the uh retain counter on an instance we would use the retain so this alloc in nit Paradigm will automatically uh incremented by one that's why even without this retain uh my class instance would have a retain counter of one and then me calling release at the end of it would bring it down to zero so let's give you some examples of things that can go wrong in managing your own memory so for example if I were to call release on this reference variable here what would happen is it would bring the retain counter for my class instance down to zero and then diock would get called on that instance and that memory that that object was taken up would get released so if I try to uh access that instance of the object object here by let's say calling a method of it or trying to do something with it your app would crash now for example here's let me give you another example if I have another variable uh call it second reference and I point it to my class instance if I release it here keep in mind that the retain count is still one and then when I release it here the retain count of my class instance would be zero and then if I Tred to do something with second reference like call a method of it or something like that it would be pointing to you know something that doesn't exist anymore now what I'd actually have to do is assign it that so I'm incrementing by calling retain I'm increment ing the retain counter on that instance so now it sits at two and when I call release on it I'm decrementing it back to one and then uh I would be able to use second reference and call a method or do whatever with it and then at the end of the method I would have to call release on it to decrement it down to zero so that it gets cleaned up if I don't have this statement here and I would have a memory leak so now you guys know how Objective C handles memory management so with the introduction of iOS 5 and automa reference counting otherwise known as Arc you don't have to write those retain and release statements anymore so we're going to talk about that in the next episode now for your fact of the day did you know that the first iPhone was launched on June 29th of 2007 that's about five years ago six years ago actually and they've come up with well iPhone 2 iPhone 3 3GS 4 4s 5 that's six iphon that's once once a year so do you guys have any thoughts and comments on that let me know in the comment section below and I'll talk to you guys next time