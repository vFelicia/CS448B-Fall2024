For this video, I'll show you how to use Vapor to create tables, use migrations, and how to read and write data to the database. For this example, we are going to make a list of songs to read and write. Hey, everybody, my name is Mikayla Karen. I am a full time Iowa West developer, and recently I've started learning Vapor. So I'm excited to show you how you can use Vapor to build your own API. Okay, so here we are in our project directory. When I type LS for list, you can see all the different files that we have, so we can open this by typing Vapor Xcode, and then you see it says Opening project in Xcode. Okay, you can see when we open our project, you have all of the packages starting to load. So all of the packages, these are all the ones that we need for our project, and Xcode is going and fetching everything for us. The first thing we'll learn about are what our routes. So we looked at that briefly through the last project, or when we built the project for the first time, we open up this routes file and we see app get and it returns. It works, and then app get Hello returns. Hello world. So if we open postman and you may not see these, I just added these because we will be using them later. But if you just click on the little plus here, it might be over there. You can create a new request. So we will request from this after we run it, which we'll have to wait for mine to finish building for the first time, so you can see it's still fetching everything. But what we're going to do is we'll see that when we just hit the base route, it returns, it works. But then if we hit the base route, Helloworld or Hello, it gives us Hello world. And so this is our route. Really. But when we open the project for the first time, we actually have a bunch of files here. And this is a Todo controller create to do a model called to do, because by default, Xcode gives you a Todo project to start everything. Let's type this. Let's go to this. So we'll end up using songs, but right now we just hit the base route so that's the root route and wait for my project to finish building. Okay. Both succeeded. Okay, let's go ahead and build our project for the first time. So we click command R and make sure the scheme that's selected says my Mac. Okay, here we go. Okay. So when you run the project, sometimes you'll get this run would like to access your documents folder, or this might be wherever you ended up saving it, just click on. Okay, then we see notice starting server on 1270 one at Port 80 80. So right here I type in that exact URL, and when we hit send on the root directory. We have our request sending and we get back. It works and we can see right here. That's exactly what we wanted back. Then we do Hello. So the slash helloroot and we click send and we get back Hello world because that's what we Typed right here. So we can see that down here. So we went to the root directory first and then slash Hello. Net directory. But root next and then we have this controller. So let's go ahead and delete all of the controllers and everything that comes default with the project because we don't need that. So we just click on stop and then we'll see down here eventually. Once my computer gets there, it says it stopped it. And then this is a message that will sometimes come up. So when we try to start this again, it might give us that weird error where we have to do like Lsofi 80 80 and kill that one process. We'll get to that though. But let's go ahead and delete this to do controller. So just click on it. Click delete, move to trash and let's go ahead and delete everything else. So create the to do delete that one move to trash. Delete the to do model. We don't need that. And we can take out that line and it says can't find it because it's not there. And then inside of Configure, we can take out this migration thing here, which we're going to add it back with our own information so we can keep these routes here because it doesn't hurt anything to have them. But we are going to make our own controller. So we all write our own routes inside of the controller rather than writing them right here, because if you have a big application, it'll start to get very crowded. Let's go ahead and click on this and then do command in or file new. To create a new Swift file, we'll add a Swift file, so we click next. Xcode kind of does this rather than what it does with an iOS project, you can immediately type the file name here. So we will call this the Song controller, because this project will be about adding songs to a database you can see with vapor. It sometimes does this incorrectly. So we have the song controller, but it didn't rename this part of the file by default like it does when we do iOS projects. So we will just change it right there. And before we get into this part, actually, let's go ahead and create our migration, and I'll explain what that is. So let's name the migration createsongs So file new Swift file, and we will call this Crete Songs and rename this part again. Okay. So first, what are migrations migrations are used when creating our database. So when you think we have version control within our Xcode project, when we type new lines and change the Xcode, we use Git to tell us what have we changed? And we can revert back to certain points in time for migrations. With the database. For a database, we use migrations to do that, as opposed to using Git. So we need to first import fluent. And Fluent is a framework that's actually an Orm so that's an object relational Mapper or object relational mapping. And we will use that for the migration. So the migration will then track the differences between our database for things that we add. So first let's create a struct called Createsongs, and it will inherit from migration. So you can see it says fluent. Migration can handle database migrations, which include adding new tables or changing existing tables. So this is pretty much like get it's tracking all of our changes. But instead of for our Xcode, it's for our database, it will try to build, and I think it'll tell us there is an error. Okay. So when we build our project, it will give us this error that we do not conform to the protocol migration. So if we add the protocol stub, it gives us these two functions. So we said migration subtract changes. So prepare. These are the changes we want to make and then revert. This is what do we do if we wanted to revert those changes? Let's get rid of the Xcode completion. And the first thing that we're going to do is we will use this to create our table. So our table is going to be called songs. So we want to return from this and we want to use the database that we're using. So database schema. And we want to call this song. So this is the name of our table. And what does our table have? So tables have columns, and they have rows. So rows are all of our data. And then columns are the different properties of our data. So we want an ID property and we want a field. So the field we want to actually, that's not the right initializer. Yeah, we'll use this one, but we're only going to use part of it. So we want to give it a column name of title. Then what type it is? It is a string. We want to create a new field. We want to give it the name of title, and it will be of type string. And then we want to make this field required. And then here we want to create this. So this means we have a table called Songs. It has a column called ID and a column called title. And then we want to go ahead and create this table. And that's what all of this means. Now on the other side of reverting, if we want to revert all of the changes that we made and prepare, we have to do reverting here. So we create the table with these kinds of fields, and then to revert that change, we just delete the table completely. So this is our migration that we will make for our songs table. Now how do we represent the data that's in this table? We have to create a model for that. So if we go to the Models folder command n for a new file want to make a new Swift file, we will name the song. We need to import two things. We will need fluent and vapor. It's going to conform to model and content. So think of it like a normal class that we'd make within an iOS project. This is how we want to represent our data. But because we are using fluent, this is how you're going to query the data from the database. First, say static static schema equals songs. So this is what schema are we talking about? Meaning what table are we talking about? So this class will represent the Songs table. And then what is in this table? We have an ID property and a title property, but we can't have only this. We need to add a couple things on this to help with fluent and recognize everything that's in the table. When we add these on top of it, it's telling fluent that this property of ID matches the ID property within our table, and then the field that we were talking about when we look at the migrations matches. Now our property called title, and then we need to make our initializers. So we'll first have an empty initializer and then one with all of our properties. Okay, so here we have our two initializers. One will just be empty, meaning it doesn't accept anything meaning it'll have both of these. But then one that will set the ID property to Nil and then title. And then here we are setting those two properties. So our song class represents our data inside of our database, which here is our table, our table called songs, and it has the ID and title properties. And then we can see our model that we have song. It uses the table songs, and we have our ID and title properties. So let's go ahead and add data to our database. So we will do that with the song controller, as opposed to using routes in this file and making the route file get very long. We'll separate our logic into this controller. So this will be a struct called song controller, and you can see it automatically added vapor, because that's what we need for this route collection. We'll also need fluent instead of foundation. So our route collection. This is what is used because a controller is really just kind of a collection of different routes and different functionality. So when we try to build this, we will see that it again fails and tells us we need to conform to route collection, and we currently don't. Okay, so after it builds, we can see that it fails. And we want to add the protocol stubs. Let's go ahead and click fix and we just need this one function called boot. So kind of think of it like an init function. This is the first function that runs. So what we want to put in here. Okay. So first let's type letsongswoopedsongs. So what this is saying is when we go to the root route, so 1270 one and then dosongs everything that is then grouped under this will go to that. So to make that more clear to make a new function. Okay. So to make this more clear when we go to the routesongs, we then use thissongs get and then use index. Meaning when we go to songs, we want to use this function. So you can see that similar to when we do app get. Hello. It has the functionality right here. But because we are grouping it within the songs controller. When we go to Slashsongs, we want to group everything. Then instead of app yet we havesongs yet and we are using the index so that will look like this one. So we will go to the root route, then do theroutsongs and that's what we are making right here. So that's what this one means. So let's write the Xcode for what happens when we do this. So this is all we need. So we return songs query, which this means this is referring to our song right here our model. So because we are using fluent fluent is what is actually doing all of the functionality to go and talk to our database. So we do songs query meaning we want to go get data we want to do on the request DB. So this is our request, which is what it's called. When you say hit the database or hit an API, it usually means make a request. So this is called a request DB. So we want to use the database that we have, like within our project, and then we dot all because we want to get everything back. What this means when we dot all, we want to return everything that comes back from this query, and that will come back as an array of song items. But before we can do this, we haven't actually created the database. So when we can see in this configure file here, this is creating our database. It's a Postgres database. And then this is trying to get an environment variable for our host, the Port username password, and then the database name. But instead of making an environment file right now, if it can't find that, it'll just use uses this nil coalescing and we'll use whatever is given here by default. So by default our database host is localhost the vapor password and then the username, and then the password is right here, which these are generic. So this is not what you actually you don't want to hard Xcode any of these values in your Xcode. That's why right here it goes to an environment file, which will end up creating glider and then right here, you can see that we did delete the migration for creating that to do because we don't want to create to dos in our project, we want to create songs, but we do need this migration similar to this for creating songs. We want to create our song table. So if we go into configure, we type apps migrations so we have Typed app migrations add createsongs because we want to add our createsonguration to all of the migrations like lists. Of them. And then right here we do tryapp auto migrate. Wait. So this means all the migrations that we have, we want to actually run them, and that will go and create a database for us. And then it will wait for the auto to complete before doing everything else. Okay. And before we can run the project, we created our song controller, but we haven't actually added that to the routes file. So our only routes in the project right now are this root one and slash. Hello. Let's go and add our song controller. So we type, try app registercollection, and then we want to pass in our song collection or song controller. Sorry. And we can see it conforms to route collection. So that's saying right here we are adding the song controller, which conforms to collection. So this is the type of collection. And so now when we run our project, it will first go back to configure it'll. First create our database for us, and then right here it'll create the songs table that we have using the migrations. And then lastly, it'll try to run this function routes. If we go here that function, it will register these two routes, which we won't really use. But then here it'll register our song controller inside of song controller. We have a route called slashsongs. And then here we have the ability to read all of the different songs. So this is thesongsroute so if we go ahead and run this, nothing will really happen because we don't have anything in our database, but we can still run it anyways. I missed that. So we'll stop this and now run it. Okay. So in mind, we can see that we got the same error that the connection needs reset and connection refused. Okay. So what this actually means eventually show me like it can't do something. What this meant was that our database. So it says connection refused. So what are we connecting to? It cannot connect to the database because the database is actually not running yet what we need to do. So if you click command tab on our terminal here, it opens a new terminal window, basically, but within the same directory. So we're still in the same place. So let's go ahead and stop that. Eventually it'll stop. What we need to do is run our database because it's actually not running. What Vapor does iswith an Xcode. It kind of just only runs the application, the API sort of side. It doesn't really run the database. When we look at our Docker compose file, we can see here we can start the app and we can start the database separately. So let's do that. We need to start the database with Docker. So if I close this and you try to start the database. So if we do dockercomposeupdb, which this does have a hyphen, but I've Typed it without a hyphen, and it works just fine too. So if we type Docker compose FDB hit enter. It's trying to start the database, but if you get back this error of error response from Daemon, that just means that Docker is not running, and that's what I had just closed. So you need to type in Docker. So it'll try to open the Docker app. If you hit enter, you'll see up here the little Docker whale is trying to get up and running. So it says Docker desktop is starting. Let's wait for it to boot up. So this is the desktop application. It'll say Docker engine is starting. Once Docker started up, you may see this that says nothing is running or you don't have anything here or you'll have, like, one of those tip kind of prompts, but this one was actually from me testing the API, but we can close this or you can leave it open. It doesn't really matter. Let's go back here and type the same thing. Docker compose up DB. We hit enter. Now you can see it's starting to do something. So what it's doing is creating our database for us within a Docker container, and it's doing this by using our Docker file here in Docker compose. So now if you still had the Docker desktop application open, you can see Vapor API that is right here. That is the name of our project, and we are actually running it from the command line here, as opposed to running it just through the GUI application. You can expand this and see here is our database, and it's just called DB One, and it is of type. It's a Postgres database. So now that everything is running now, let's see if we run our API. We should not get a connection. Refused because our API was trying to connect to our database, but the database was not actually up and running yet. Okay, on mine, we saw this address already in use, so that's a different error that goes back to that weird command that we have to type in the command line because sometimes Xcode doesn't fully detach the process. So if we go back to our first terminal tab here and type LSO, it shows us all of these things that are running. So to know which one to actually close, it's usually the one that says local host. So I'm not sure why that actually appeared in mine, but typically what we'll do is delete the one that says something about localhost and we can delete this one. This is postman because I think this is the one that the database is running on, but apparently like froze mine. So if we click Command T to try to open a new tab, let's close that type lsof I 80 80 and don't have any spaces. It comes up with the same things we'll do kill nine and then the PID number. Okay, so if we look at this, it still says something is running. Let's try to kill that one as well. And if we type LSS, okay, now we don't have anything going. So now let's try to run our project again. Okay, here we go. Now we have server starting on our root computer, but we can't really see anything. Let's open postman. Okay. We have open postman. And if we try to hit the new route that we just created for getting all the songs. So this was me. I saved this request within postman. You can do this all without signing up for an account. If we try to click send, we get back an empty array and it says 200. Okay. And that's exactly what we want. A 200 response is a good response. And then we can see we hit the slashsongs route, but it says empty array because we haven't added anything to our database. If we want to look further into this, let's open up Azure Data Studio. So this was another one of the applications that we had to download. And with Azure Data Studio, we can then look at our data in the database directly without using the API. So to do that first, we need to add a connection and we are not using Microsoft SQL Server. We are using Postgres SQL and we have that option because cancel when we downloaded the extensions. We downloaded the extension Postgres so we can go to add connection Postgres SQL. So the server name is localhost because in configure right here the database host is called localhost. So database host and server name are like the same thing. We want to use password. We don't have Azure active directory, and then the username here we are using Vapor Username and Vapor password. You can click Remember password if you want. It doesn't really matter. We want to use Vapor database because that is the one that our configuration uses. We can give us a name. It doesn't really matter. It database and we click connect. Okay, so here we can see that the connection is live because it has a little green dot. If we click on Songs and just right click and then do Select Top 1000. This runs this query of select ID and select title from songs. And we have nothing here because there's nothing in our database, but we can see fluent migrations if we right click this one and click Select Top 1000. This shows us that the migration that we ran is called Createsongs, and then this is the first one that ran and this is the day and time that we ran this. So this is like our get commits. It has a record of all the different things that have happened, all the different migrations. And we can see here we don't have any data in our database at the moment. So let's create a new route that allows us to add data, because what we have so far is just allowing us to get data. Okay. So we stopped the project and we want to make a new route, so we need to make a new function. So we are going to make a function called Create. So our function takes in a request. All of them will take in a request because that is the request coming from Postman and the request coming from the iOS app. And then I haven't really talked about this. It's called Eventloop future. So this has to do with what is called futures and promises. So it's all about Asynchronous Xcode. And note, these tutorials are before Vapor has integrated Asynch awaits, which is the brand new Swift I believe, 5.5 functionality that is in iOS, and we will be using that with the iOS app, but it has not been merged into Vapor's framework just yet. And then right here we will return http status. So the status is like when we looked at postman just moved. This is the status. So 200 okay means something good happened. So we will return a status whether or not we were able to successfully create a song. So let's write the Xcode for this. Okay. What we wrote here is letsongals tryrequest content decode. So when we have this request, we are going to be decoding the content into a type of song self. So that's like when we do JSON decoding in iOS, this is pretty much the exact same thing, and we will decode our song type and we save it into a variable called song. And then we will save that to our database. So that is using song save. And we can use this because our modelsong is a part of fluent. So it has these functions inherently that it can use to talk to the database. So we save our song to our database. And then if that goes well, we transform it to okay. Meaning everything went well in the response from this entire request is going to be okay if it worked. So let's go ahead and run this. But actually before we run it, we have to add this to this boot function because we have added the get for the index, but we need to add the create. So instead of Get, we are using Post and these are different http methods. Get is usually for getting data, and post is usually for sending data. So we do songs post and that allows us to make a post request rather than a get request. Let's go ahead and run this and bring postman back up. We have a lot of windows so you could see when we did the get request. The request type is get when we hit the songs API or the route. But if we use a post request, we change this from get to post and then you can see the request. The URL is the exact same. So that was me testing one. But here what we need to do first is so you won't see this initially. It might be on like params. Go to the Body tab here and make sure you click on Raw and then select JSON for the type of this body. And we will use a title because that is one of the properties of our song model. We have an idea and a title, but we don't need to create the ID ourselves. The database will do that for us. Okay. This is the vapor pop up that comes up. Just click. Ok. And then our Vapor API is now up and running and postman. Let's add a new song. Let's add a song called Money, and if we click send, we get back a status of 200. Okay. And you can see we made a post request to the routethsongs, but we can actually see the data, but we can if we now use our other route that we had for getting all of the songs so you can see it says it's a get request, not a post request, and we don't have anything in the body because we're not sending anything over to the API. We're just sending our request to get back data. So if we click send now we have data coming back so you can see the ID that was created, which was that UUID. And then the title is Money. So that is the song that we just added. We used our API right here for a get and a post request to the route songs, and now we have created new data and we have read that data. We can also look at our Azure Data studio, and we can query our database directly. So if we click Run after we run our query, we can see the same ID number, and then the title is Money because that's the one item that we have in our database. So this allows us to look at our database directly rather than using our API here to query the data itself. Okay. And then that's pretty much it. We have created two different routes that allow us to read data and create new data. So here I will actually add this is the Get request to the Songs route, and this one and this one is the post request to the Songs route, and we can see that here we use Get and post. So let's stop the project from running. And then down here where we had our we can see everything where we had Docker running. If we click Control C that will stop the container completely, you shouldn't just close this window. You should just cancel this, cancels it gracefully to stop it. And then if we look in Docker desktop, we can see that it's not running anymore. Let's exit out of that. And then that's all we have to do. On the API side. We have created our table using migrations, and we learned that migrations are like Git, but for our database we created two routes, one to read data and one to write data and we are writing and reading a list of song titles. Lastly, we used Postman and Azure Data Studio so we can look at the data in our database and test our API without needing to write the iOS at first, if you enjoyed this video, give it a like below and write any comments. If you have any suggestions on future Vapor videos, we'd could do.