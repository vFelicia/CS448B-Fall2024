hey guys here's my dynamic programming tutorial with the zeroone knapsack problem as our example let me explain what the knapsack problem is first we have a certain number of items let's say we have n items or five in this case five items and each item has an Associated weight and value with it so the first item weighs one kilogram and is five dollars and the second item ways to kilograms and it's worth three dollars and the problem is we're trying to decide which items to put in our knapsack which can only carry a certain amount of weight let's say 10 kilograms we can only carry ten columns and we're trying to maximize the total the total amount of value that we carry with those items so for each item we're going to decide do we put it in the knapsack or outside the knapsack so let's just say yes or no or we could write it as one if it's in knapsack or no if it's not in the knapsack and our first class it looks very hard because if we make this decision for every item the total number of solutions the total number of potential solutions is gonna be two to the power of n or two to the power of five in this case but actually we can do much better than that with dynamic programming and you see how you can do it in a second here's a common procedure in dynamic programming we first come up with a recursive solution and then we memorize or store some of the in terminate results to make it run faster the third optional step is coming up with a bottomup approach but I'm not gonna do that just for simplicity sake for this particular case so here's our naive recursive solution the idea is we're gonna start with the last item and we're gonna move down the list and we ask ourselves for where the pointer is are we gonna put this item in the knapsack or not so for the first settlement of course that's yes or no and we'll also keep talk of how many items we have left to consider or you can see as the position of the pointer as well so it starts with five and we'll keep track of the amount of capacity we have left that starts with ten in our example 10 kilograms and the value we have so far starts with zero and if you said no for the first item or the last item this item then n becomes 4 we're essentially moving this pointer to the left so that becomes 4 and C capacity doesn't change so that's 10 and the value doesn't change so that's still 0 and if we said yes and becomes 4 we we have 4 items left to consider the capacity becomes 10 minus 5 equals 5 we can still carry 5 kilograms and the value becomes 0 plus 2 equals 2 and for each decision we ask ourselves for the fourth item are we going to put this in the knapsack or not so that's yes or no again so we keep repeating this process until we get to the last item this one so that's the idea behind our recursive solution but it works slightly differently in the code so let's see how that works so here's how our recursive solution works in our code we define this function KS knapsack that takes two variables the first variable is the position of the pointer that we're looking at or the number of items we have left to consider and the second variable is the amount of capacity we have left so the first call for this example is going to be cast of 5 because we have 5 items left to consider and 10 because we have 10 kilograms in our capacity and here's our base case if N equals 0 means we have no items left to consider and if C equals zero we don't have any capacity so we just return zero and from this function we're returning the optimal value that we can achieve with this pair of variables instead of the list of arguments itself so if you want to do that you'll need to change the code a little bit now if the current items weight is larger than our current capacity then we can't put it there so we just move the pointer to the left and we call this function again and if that's not the case we'll try both put in the item in the knapsack and not putting it there so if we don't put the item in your knapsack then we just call the same function with the same variables again with the pointer moved to the left and if we put it there will count in the current items value and we'll add it to this recursive call where the pointer is moved to the left and the capacity left is reduced by the current items weight and we'll just take the maximum one of those to get the optimal value by the way our values are stored in this array that starts with a dummy variable and our actual values so that's 5 3 5 3 2 and the reason is because when we have say the second element we can just call V of 2 and we get the right element the right value and it's the same thing with the weights so it also starts with a dummy variable and then actual weights so this is how our solution works but it's very very slow and let's see why that is if you think about the worst case scenario we try for the last settlement we try yes or no and then for the second last element we'll try puttin that item in there and not putting it there and so on so we're basically trying every possible case so the time plexy for this algorithm will be exponential which is very bad dynamic programming says we can do better than that by memorizing or storing some intermediate results or by noticing that there are some duplicates in our computation so here's how we can do it we have here a function that's almost exactly the same as what we had earlier except for these three lines and the first thing to notice here with the previous function we had is that there are only n times C possible variable pairs that we could have so in the example we had earlier this would be just 10 times 5 times 10 which is 50 possible variable pairs and what we were doing here is we are storing the results of this function in a twodimensional array with the height N and with C and we initialize it to undefined the outside function and then when we call this function if the result is already stored for that particular variable pair then we just return that instead of going through the whole thing and if that's not the case we'll go through the whole thing and before we return the result will store it in the array so we can reuse it later so what's the runtime for this function the first thing to notice to find that is that we reach this line only at most n times C times so we go through this whole thing at most n times C times and every time we go through this function the maximum number of recursive calls we make is just twice in this case this one on this one so the maximum number of times we call this function itself is about two times and C or just an order of NC and the time it takes to execute each car or time per call is just a constant time so that total amount of time it takes to execute this whole thing is just an order of NC which is much much better than the exponential time of complexity we had earlier all right hopefully you liked the video you might also like my other video about dynamic programming with maximum subsequence as our example and if you want to watch more videos like this one you can subscribe right here and see you soon