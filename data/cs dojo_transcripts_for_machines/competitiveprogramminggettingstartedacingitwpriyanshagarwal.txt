all right uh we're live uh i think i'm just going to assume that you know we're live and it's working and we see like i see that you know there are 81 people people watching right now uh assuming you know y'all can hear us thank you for being here and thank you for being here friends thank you so much ykay for inviting uh looking forward to this live stream yeah uh so let's just you know get right into it uh first of all did you want to introduce yourself and your background on competitive programming um yeah sure so hi guys my name is priyansh agarwal i'm pursuing an undergraduate degree in computer science uh right now i'm in third year so just one more year to go for until college ends apart from that i've been doing competitive programming for like the past 2.5 years i do have some remarkable achievements in that as well for example i have google kickstart you know global rank 6 and india rank 1 in the recent google kickstart rounds and yeah apart from that i've been creating a lot of content as well around competitive programming on my youtube channel and yeah i love teaching competitive programming is that cool um yeah i was kind of curious where do you think like you know that passion for like uh teaching comes from for you um okay so it's not like uh you know i had this passion for teaching for from a very long time uh since i started content creation i guess i started enjoying it a lot and i realized that if i can you know explain some concept that i have in my mind to somebody else in a beautiful way in a way that they can understand it uh you know that gives me a lot of dopamine so that's something do you feel like like is it something that runs in your family i mean don't worry like if this is a personal question but yeah i'm just curious yeah not not exactly like i don't have anybody or in my family as such teaching uh and yeah i mean i would be the first person who you know has even started content creation cool yeah i'm actually the same way uh but part says this man needs no introduction and yeah i guess you need no introduction you're already now on this like youtube world yeah that feels great to hear yeah uh and someone's asking like please share his channel link as well i already put it in the description so you should be able to yeah it's also there in the title as well so uh vik has tagged me as priyanka world so probably you can click on that and you'll you know be directed to my channel as well yep okay uh that's probably enough for the introduction so let's just get started um so i'm just gonna ask you kind of you know simply how should people get started with competitive programming okay so uh first of all in order to be uh you know able to start competitive programming you need to first of all start programming uh like you have you know competitive programming so obviously it requires programming right so i would suggest learning any programming language one of my favorite languages c plus plus some people in competitive programming also code in java and as well i mean also in you know python so i would suggest you know starting uh your cp journey by learning some programming language apart from that you'll realize with time is uh one thing that you realize with time is that competitive programming requires a lot of you know math stuff so if you're good with mathematics uh you know you should be good to go uh but if you're someone who's you know uh who doesn't have a lot of experience with mathematics i would suggest spending some time you know learning basics of number theory permutations combinations and basically in your algebra right once you're done with this uh when you're attempting a competitive programming problem you'll be in a very good position to you know jot down your observations in a mathematical form right uh and apart from that you should be like having a good typing speed i would say uh it's not something that is required initially when you're starting competitive programming uh but uh at one stage you realize uh that you know having a good typing speed also enables you to code very fast and also enables you to solve problems quickly because essentially when you're doing competitive programming you're given a bunch of problems that you need to write a code for uh and you know this code should run fast enough i mean it should run in a given amount of time and also you should be able to come up with a solution in a given amount of time right so essentially if you're you know coming up with a solution and able to code it up really very quickly and you know you're able to submit it before somebody else you're considered better than them uh in terms of competitive programming you know uh level so yeah i guess uh these are the three things that you should look for uh learn a programming language uh have some experience with mathematics not a lot and again like if you have a good typing speed i would say 30 wpm 30 words per minute or something like 40 words per minute uh you should be in a good position so yeah i hope that that answers your question yeah definitely um it's interesting that you mentioned math because i was kind of saying the same thing about you know coding interviews like math is like really helpful um and yeah i mean uh if uh if i were to put it this way uh maths is even more important for competitive programming than it is for interviews and data structures algorithms because if you look at data structures and algorithms you have a certain you know type of techniques that you can employ to solve a problem right so it gets kind of you know uh it is not very mathematics heavy but when you look at competitive programming problems they're essentially you know something like puzzles right so if you're if you want to solve puzzles you cannot be just thinking on an algorithmic level right you need to be able to you know jot down your observations on a pen and paper and that's more like you know jotting down some mathematical expressions so it becomes even more important in competitive programming yeah thank you for that and before we started going live you were mentioning how coding interviews and you know competitive programming are sort of related right uh yeah they are related so essentially uh if i were to put it this way uh if you are very good with competitive programming uh you have a very good chance of you know nailing all of these coding interviews this is primarily because when you look at competitive programming uh you're not just solving puzzle type of problems you're also solving algorithmic problems right and that is what is expected in most coding uh interviews they expect you to be able to solve algorithmic uh problems that you know might be requiring some data structures as well so if you look at competitive programming uh people are you know essentially solving very hard data structures algorithm algorithms uh algorithms problems in competitive programming right so i mean they are somewhat related if you're good with cp or you will be very good with dsa and interviews nice okay so i wanna you know keep our focus on like uh competitive programming in this one and there's a question that might be a good place to start uh how to get to expert from specialists in two months on cold forces so i think like the question before this one is like is chord forces even the right platform like what platforms do you recommend to get started okay so code forces is definitely not the first platform that you should be starting your competitive programming journey on uh i feel that if you have to start uh cp uh you can start on a platform like you know hacker rank or maybe hacker earth or maybe even geeksforgeeks and lead code right so you should start with a platform that is you know uh more rewarding uh for example if you look at lead code you know people are you know people mostly boast about the number of problems they sold on lead code people don't boast about their rating right uh and this is very different when you uh you know compare it to code forces uh code forces is like you know a competitive programming website wherein everybody is competing to you know gain their rating i mean to increase the rating uh so what happens on gold forces is that you have a rating system the person having the higher rating is considered to be at a higher level right uh so if you just start your competitive programming journey right from code forces what will happen is that you'll get really demotivated people who have experience over about two or three years in competitive programming uh would be you know very likely performing very uh you know i mean would be performing much better than you right so essentially when you're just starting out and if you see everyone performing much better than you uh you might get demotivated so yeah code forces is not the right platform to start uh i would suggest hacker rank kicks for geeks or even lead code if you just have to start right now right um okay and i thought you know you might be able to like it might be helpful for you to you know share your screen and maybe like kind of walk through the whole process of maybe like you know getting started for the beginners and then like you know for you to like prepare for like particular competitions how to get better and you know all of that might be helpful okay sure let's talk about some websites that are there on you know that are there for competitive program let me share my screen here give me a minute so i hope my screen is visible uh if you can confirm that yep i can see hopefully the viewers should be able to see it too cool can we have like a plus one in the chat or maybe a yes or a no in the chat that can confirm if my screen is visible yeah and then we can get started yeah i think we can just assume that you know it's visible and we can continue okay sure so i'll just show you some websites that are there for you know getting started first of all is hacker rank right uh so this is one website uh and i'll just you know uh keep opening some websites here uh so that uh you have an idea just a minute yeah i think this one it is cool so this is one website that you can get started at uh for competitive programming other one is hacker earth right and like i suggested geeks for geeks geeks or geeks doesn't have a lot of competitions as such like it doesn't have a lot of competitive programming contests uh but if you open this website you'll find a lot of you know implementations of data structures and algorithms so whenever you feel that you want to implement something uh you can you know refer to geeksforgeeks and you'll have an implementation for that uh other is leap code i mean lead code is not like a competitive programming website uh but this is something that you can you know refer to if you're preparing for uh coding interviews as well but this this can be considered like a good website to just start your problemsolving journey right these are the four websites which are uh i would say more rewarding for beginners right uh they don't focus a lot on competitions but they focus more on you know getting you started uh so these are the four websites hacker rank um hacker earth geeks for geeks and uh you know lead code now let's talk about websites that you should be referring to uh when you're already like at some level at some level in competitive programming or you've solved some problems uh you know uh that are like around competitive programming so the first website that you can refer to is like code chef then there is code forces and the last one is add coder right uh and uh what you'll notice is that all of these websites they have a certain you know uh rating system for example if you look at this website called code chef uh this is my profile on codechef and this is like my rating on coaching right the higher this number uh the more lev i mean uh the better i'm concerned uh i'm considered uh you know when when like my profile is shown right so uh this does provide you with some metrics for example at this rating which is two two zero one my global rank is 603 on this platform and my country rank is 286 right so you might be having two types of you know ratings one of them is your current rating and the other is your highest rating for example it might be visible here the highest rating is two two two five right and mostly when you're telling your rating to somebody you essentially want to tell them that uh tell them your highest rate right so this is one platform you can uh you know uh start attempting problems on once you have some hang of problem solving uh the next is code forces right this is my profile on code forces and again this has a rating system like my current rating is nineteen hundred and twelve and my maximum rating is two zero eight nine right and this just shows my like rating graph like uh for example if i attempt a competitive programming contest if i perform well my rating would go up if i don't perform well my rating would go down right so that's where the competition part comes into play if you are performing better than people who are at a higher level than you your rating will improve if you are performing you know worse than the people who are at a lower level than you your rating will go down right so this does have some metrics again the number of problems solved your heat map and all of that stuff and then there is this third website called uh you know add coder uh this again has a rating system uh i'll have to log in for that let me just see if i can log in yeah so this does have a rating system i don't attempt a lot of problems or a lot of contests on itcoder uh but yeah this these are the three websites that you should be referring to when you have some hang of competitive programming like uh the first four are yeah go on yeah so just quickly you know sort of i guess going back to more of the beginner side like if people want to like get into math or you know data structures and algorithms are there like any particular resources you recommend for that uh for data structures and algorithms again i would suggest going for geeks for geeks the third website that i show you showed you for beginners uh but if you you know want to get into mathematics part of this whole domain i would suggest uh you know going up to this website called project euler this is one website that has like you know math specific mathematics specific problems these are not competitive programming problems but but some somewhat like mathematics puzzles so yeah this is one website that you can refer to if you want to you know get good at mathematics cool and i guess they can people can just like go through those websites and maybe find some problems to work on something like that yeah sure and what uh you can do yk is that you can probably add the links of these in the description after this live stream i can provide you with all the links so that should be helpful to navigate yeah sounds good um okay i think i'm gonna take a question from the audience is stl necessary to store in cpp competitive programming first of all what's sdo and yeah um yeah sure so uh this question is very particular to you know people coding in c plus so stl is supposed to be standard template library and this library has a lot of you know standard functions uh for example let's say you have an array and you want to find out the minimum in that array one way could be to just run a for loop and find the minimum another way could be to use some standard function right so this library does provide a lot of standard uh template functions and you know a lot of data structures as well so uh i mean for beginners when you're just starting out let's say you haven't done any competitive programming you haven't you know even started your programming journey it would not be a good idea to go for standard template library at this point but once you get a hang of it like like i said once you are you know uh once you're a little comfortable with solving problems and when you're going on to these websites like code shaft code forces and appcoder that would be a good time to you know learn about this because whenever you're implementing some logic uh for a problem uh this this would come in handy you would require lesser code and lesser you know thinking of your own to implement some logics but yeah it is necessary uh i mean uh stl is necessary but uh not uh for a you know complete begin thank you um i think the related question is like what programming language should people use for competitive programming right so that's like a you know a hot question in competitive programming uh everyone who's starting a meditative programming wants to know what's the best language to start right uh so uh i would you know answer it in this way that uh first of all there is this language called c plus plus this is considered to be really good for competitive programming uh like you would have seen just now the person who asked this doubt uh you know has this doubt which is very specific to c plus plus right so most of the resources that you'll find uh online and you know most of the discussions that you find online would be happening mostly in c plus right so it's uh it's suggested that you start uh your journey of competitive programming with c plus but for people who have already you know some experiences some other languages for example some people would be could be totally familiar with java or python then for these people i wouldn't recommend switching to c plus plus just for competitive program you can you know achieve almost similar results as in c plus i mean in c plus in your own language as in c plus plus so uh you know if i were to just summarize it uh go for c plus plus if you haven't just started if you haven't started anything but if you have already started and you are familiar with some language stick to it and i mean if you haven't done it for a very long time then again you can go for c plus cool um okay so we're getting a lot of questions about um data structures and algorithms and i know we just answered it but do you think it would make sense for you to like share your screen again and just kind of go through some of those websites and show people like like where to click and stuff like that sure you mean for data structures algorithms yep okay sure right i hope my screen is visible so again these the the websites that i just discussed uh that i just talked about these are very uh cp specific i'll just keep the websites that are specific for dsa right so one of them is geeksforgeeks like i said this is one website that you can refer to for any implementation of like any algorithm i would say any algorithm any data structure that you find online there's a very high chance that you will find the implementation of that on geeksforgeeks another website that you can you know refer to for just the implementation part is cp algorithms right uh this is again competitive programming specific sorry uh this is my laptop you know going sideways just a minute cool so uh uh just give me a minute let's put it aside right i hope that's better cool so cpa algorithms is one website that you can refer to for any implementation of an algorithm for example let's go on to something like algebra right and you have binary exponentiation as a topic here now you go down and you'll find the implementation of this algorithm here right similarly you can you know uh browse through geeksforgeeks for any like implementations for example this is like a section on geeksforgeeks let's open something like uh let's open something like quicksort right uh quicksort on doubly linked list right so you'll also have the logic of that whole algorithm and you'll also have the implementation here right and they don't just provide you with the best implementation they provide you with you know implementations that are not uh absolutely optimal so you can you know go down and you know you can understand it along the way for example uh the first implementation could be just order of n square the second implementation could be order of n log n right so as you go down you'll realize that your code is getting optimized and you'll also have more idea about it right so this is one website that you can refer to for algorithms and data structures uh for implementations of you know algorithms and data structures that are cp specific i would recommend cp algorithms and for practicing again i would recommend lead code this is one website i mean this is one website that everyone uses so you can you know rely on this website for practicing dsa yeah thank you for that i think you oh yeah uh that's that's so good uh yeah sure i can share it again like if you have to add something sure i think just like sharing the screen just in general is helpful for like adding more visuals oh sure sure you want me to share it like for the entire duration i can do that yeah yeah yeah that might actually make sense um anyway we have a new question here by the way it's been 20 minutes uh so far how are you feeling so far pretty much i'm feeling great i mean uh answering all of these doubts i feel you know privileged to be here on your channel uh your channel is like really huge so yeah feeling great up until now cool yeah i mean it's it's good to have you here and it's good to like um like virtually see all the viewers here too they're almost like 300 people here which is really cool that's amazing yeah okay so this question says i recently started learning uh dsa i'm getting how to implement uh unlike stuff but facing difficulty while solving problems okay so i think that's a question that everyone who's starting dsa or problem solving would ask right so let me just tell you that you know uh in the beginning it might seem really overwhelming you look at a problem you don't have any idea how to solve it but trust me with time it gets better once you have solved a lot of problems uh like in my case if i show you my code forces profile uh and this is just one website that i've solved so many problems on there are other websites that have solved a lot of problems on so if you look at this i have sold almost 1900 problems right so that's just huge right and i've been doing cp for around like i registered three years ago on code forces i've been very active ever since right so if you look at my initial graph like if you look at these few performances initially what you'll see is that my graph isn't going up you know from the very beginning right uh in this phase my graph is going down like my rating graph is going down right and once i have some hang of competitive programming you'll see that my graph is going up now right so this is something that will happen with almost every one of you initially you will you know be totally overwhelmed by the fact that all of these problems are so difficult but once you get the hang of it you'll realize that this is actually enjoyable once you start enjoying problem solving then you know i mean you would put in a lot of effort to learn things that you don't already know and that's that's where the growth comes in right so yeah if i were to answer it it's just about practice and experience the more effort you put into it the better you will be yeah i you know i actually feel the same way like i feel like people should start with like easier ones like you know like you were saying lead code uh hacker rank and even like code wars i think is becoming popular recently it's i if i understand it correctly like it's more for beginners cold wars um i haven't heard of cold wars as such yeah some something something like that i'll like i'll put like all that info into the script you know the description later um but i know like people people struggle with you know lead code mediums sometimes so they can just start with you know leak code easy like you know once yeah yeah exactly so like if you look at lead code you don't just have very difficult problems you know you can browse through and just select the difficulty that you're comfortable with right for example if you're comfortable with you know hard problems go for heart problems if you're comfortable with just easy problems then start with easy problems once you start getting the hang of it uh let's say for example you're solving two easy problems try including one medium problem into your practice session once you get comfortable with solving some medium problems include more medium problems so you keep increasing your level bit by bit yeah yeah i really like that approach uh okay so you know i'm looking at like questions from time to time from the audience and we're getting a lot of questions about recursion and dynamic programming like do you have any tips on those um okay sure so let's begin with the question first of all if you have to learn recursion i would recommend going on to youtube or you know uh yeah i mean go on to youtube and look look for any playlist that is there for recursion so like you uh if you look at a playlist you know on recursion just uh keep these pointers in mind the first few videos should just talk about how you develop logic and then there should be some videos that uh you know help you solve some problems on recursion so once you do this you'll realize that you've also understood the logic in the first part and then you've you know solved some problems on it uh i mean by taking help of the you know creator who's creating that video after that you can go on and solve some problems on your own and this way i mean this is exactly how you learn any topic right uh if i were to like you know should i give some resources for recursion like uh how do you want me to go about it yeah sure if you could like you know zero on your screen sure let me like open this youtube stuff and let me just put in recursion here i mean that is what i do when i have to learn anything for that matter like you know you can probably go for this video this has one video and this just says recursion in one shot so you can go for this video you might have some playlists as well for example there is this playlist introduction i mean recursion basic to advanced backtracking series this has like 19 videos right so i think you you can go for this video right uh for example if you look at it first of all it talks about some logic then how do you build logic parameterized recursion after that like they have some problems on it right a combination some combination some do and all of that so this this could be like a this would be like a great start i would recommend going for this video if that's in english i'm not really sure if that's uh this is an english or is uh or it isn't hindi um but yeah you can choose your language and you know go for that cool so uh yeah i think i i missed about the dynamic programming part uh so once you're done with recursion you would have a you know better hand at dynamic programming because dynamic programming is nothing but you know essentially optimizing your recursive codes right so again for dynamic programming i would uh recommend this channel that is there on youtube uh this is one by karthik arora this is like one place that i learned dynamic programming from so you can you know head to this channel and you know learn about uh dynamic programming uh so if you look at this channel this has like a lot of stuff on dynamic programming for example this series uh dynamic programming beginner to advanced then there are uh you know series on digit dp then there is a series on dp with bit masking right so i think this this could be like a one stop channel for learning dynamic programming and yeah after that if you want to solve some problems i would recommend going for this website called cses problem set right so you look at this dynamic programming section this has a lot of amazing problems so i would recommend solving the first uh at least 10 or 12 problems from this section uh the last few are kind of little difficult so if you're just starting out i would recommend trying out the first 10 or 12 problems but if you're already comfortable with dynamic programming i would recommend solving all of these problems for dynamic programming cool thank you thank you for sharing all of that and i just want to quickly mention you know i have videos on like recursion dynamic programming uh oh sure you can check out cs20 i mean that's again a great challenge yeah thank you for that i think you would be having some playlists i guess right yeah i have some players that but the best way to do that like is just to find like on youtube search people can just search like a schedule then i'm programming recursion you know different things but i don't wanna like talk too much about myself so let's let's see if there's let's close this yeah uh actually there's this interesting question um there are builtin data structures in many highlevel programming languages so why do we need to learn it okay that's an interesting question so uh let's say i give you a problem that requires you to use some data structure for example which data structure should we take let's say you want to you know implement some problem in graphs right you might have some inbuilt implementation for graphs available in let's say java or c plus plus but now if you want to you know do some modifications in the code of the graph right uh you can you can't do that if it's already available as an inbuilt library right uh but if you want to solve some problem you might have to tweak in a lot of stuff there for example if you look at this data structure called segment trees right i don't think any language or any programming language any high level programming language has its inbuilt implementation but yeah even if they do have it you would essentially have to write a lot of code to tweak it right uh so yeah i think it is very important to you know understand how all of these data structures are implemented because at the end of the day you might have to you know reimplement them or reimplement them or you know you might have to make some changes in them and again like you know solving some problems that are data structures or algorithms uh heavy uh build up your problem solving skills as well so when you are you know working for some it's a big tech company and you want to implement some logic and they don't have some inbuilt implementation of that data structure uh you know you could you know write it on your own so i think that's something that uh something where you know this all comes into play uh i'm curious like when you're working on a competitive programming problem are you allowed to use like you know external libraries do you write your own libraries okay that's actually a very uh interesting question and an amazing question because uh like i used to be of this opinion when i was starting competitive programming that i cannot use any external code i cannot use any external library i will have to write everything on my own but that's not how it works so if i if you look at my github i do have this whole you know let me open my github sorry my laptop is like really far so i have to you know reach out for it okay so this is one website uh this is one like you know repository that i have of my own for uh some inbuilt i mean for some you know template codes for example if i go on to something like range queries right and if i go on to segment tree so this is the code of a segment tree right you look at this this is like huge so let's say you have a problem on code forces that requires you to use segmentry now you cannot you know implement that whole segmentary logic on your own at that very point right so uh having some uh you know template codes ready readily available for you does help i mean if you do if you if you feel lazy and you don't want to implement all of these codes on your own you can you know refer to this public repository that i have of my own cp templates this does have a lot of implementations this does have a have implementations of a lot of algorithms for example hldsm heavy light decomposition now you look at this code this is like huge you wouldn't essentially be you know uh coding this on spot right this is this is just insane this is huge so yeah you can use external codes and uh it is always preferable to use you know external libraries and external repositories to pick up codes from all right um yeah that that actually kind of gives me a lot of um kind of followup questions but i'm wondering like if if we it would make sense for us to like go through maybe one or two questions um i don't know like i'm thinking like lead code easy medium or hack around like something on the easier side so we can go through it quickly or or maybe like if depending on like how comfortable you feel we could go like for something more challenging too yeah we could go on for something challenging but it's just that my laptop is a little you know a little away from me so it's kind of difficult to code uh but yeah we can go for uh any problem let's let's see any problem that we have only could maybe or let's say we go on code forces yeah so let's go for problem set and pick up some easy problem because then uh you know i don't want to be seen as you know somebody spending a lot of just a lot of time of the stream just thinking about some problem right so let's pick up some easy problem 800 is supposed to be like the easiest level on code forces so let me just you know sort them by the number of submissions right so do you want to pick up this problem can we solve this problem yeah let's try it sure okay so let me just read through it and let me increase the font a little so that everyone can see this okay so we have this question one day three best friends this is something that i haven't solved already right so let's try to solve it on spot uh one day three best friends petya vasa and tanya i don't know how to pronounce that uh decide to form a team and take part in programming contests participants are usually offered several program several problems during programming contests long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution right otherwise the friends won't write the problem solution the contest this contest offers n problems to the participants for each problem we know which friend is sure about the solution help the friends find the number of problems for which they will write a solution okay great so if you look at this problem uh what they're telling you is that you have n problems right i mean in this problem itself let's say you have n questions right and you have these three players let's call them a b and c so if you look at this matrix uh i mean these are like you know let me just show it to you okay so i haven't read the input part here the first line contains m n is the number of questions that are there in this problem the number of problems in the context then n lines contain three integers each right so for example if you look at this you know this sample input so this has two problems in it because it's written two here right and for each of these problems you get a list of three numbers uh for example let's say for the first problem you have one zero zero this just means that a is comfortable solving this problem b is not and c is not right similarly if you look at the second problem uh a is not comfortable solving it b is comfortable solving it and c is also comfortable solving it right in this problem what they're asking you is to you know tell them the number of problems uh that you know they will write a solution to and there's a condition to this whole thing the condition is that if you have to write a solution for a problem at least two of the three people should be comfortable solving it right uh for example let's go through this sample input so if you look at the first problem it is you know i mean two people are comfortable solving it so that's essentially one potential problem that you can solve uh that you can write a solution for right uh for the second problem again all three of them are comfortable solving it so we'll write a solution for it for the third problem you'll see only one person is comfortable solving it right so we won't write a solution for it fine uh so if i were to implement it using code let's go about doing that so this is some code that i've you know written beforehand let me erase all of this now again if you look at this whole entire code that i have here uh you know this is like some template code that i have already available for me right uh i mean i will start writing my solution from this point so i'm using c plus plus i mean this is like just uh this is just like a walkthrough uh you know on how you submit problems on uh on code forces right so let's take the input into n in n is what n is the number of problems that you know you will be getting for this whole problem right and then you have this uh what you have three integers for every problem right so let's keep an ah let's keep a variable called answer answer is the number of you know uh number of problems that we'll write a solution for right so we go through n problems and we take in the input right let me just see right so these are the three inputs that i have taken for each problem and what i'll do is i'll just check whether you know two people can solve this problem or not and how can i do that like uh you know one tells me uh if i have one written here this just means that uh that person is comfortable right so essentially i can just add them all up and see if you know that number is greater than equal to 2 or not so if a plus b plus c is greater than equal to 2 i just add one to my answer what does what does this imply this implies that this problem is solvable by me this this problem is uh you know something that all of these three people will be writing a solution to right and at the end we just print this right i hope uh this sign let's see okay let's copy this input here and let's see if our output is coming out to be same okay we have two uh towards the intended output here we're getting two let's copy another sample input now what you would you know observe here is that in this problem you're given some sample inputs and some sample outputs sorry here so if you look at this problem there are some sample inputs and some sample outputs what does this mean this is not like you know the test cases on which your solution will be tested upon these are just sample inputs and outputs right uh essentially your problem will be tested on a lot of other test cases your solution will be tested on a lot of other test cases right so let's try to submit this problem let's copy this code and let's submit it and let's see what is the verdict that we get and i just hope i've read this problem correctly because i don't want to end up you know getting a wrong answer or something like that on a very easy problem okay so now you look at this uh uh you know submission that i made and the verdict is accepted what does this mean this just means that i have a correct solution for this problem right and you look at this solution that i submitted on this problem i have a wrong answer on pretest five what does this mean this just means from a list of test cases that this problem has my solution failed on the fifth test case right uh let me decrease the font here you know sorry yeah so now if you look at the solution this was i mean this is one huge solution obviously i wouldn't have implemented it on squad i would have picked up some code from my library uh from my repository that i have now look at this this was the test case that was there for this problem the output okay sorry i'm somehow you know pressing this whole thing yeah now you look at this problem this was the test case that was there in this problem the output that my code generated was 499 but the answer for this test case was zero right so this will give me a wrong answer my solution will be considered accepted if it passes on all the test cases right this was one solution uh when i got a wrong answer then similarly we have this verdict called time limit exceeded right if you look at this code uh on this last test case uh this test case my code you know returned this verdict i mean i got this word it called time limit exceeded what does this mean this just means that while running my code on code forces code forces wasn't able to get the answer in a limited amount of time right for example if you look at this problem if let's say i run an infinite loop right let's say i run an infinite loop before i do anything sorry right this is like an infinite loop right so let's save this and let's submit this solution on code sources right let's have people guessing in the chat what would we get as you know an output i mean get as a as a verdict what do you guys think we'll get as a verdict will we get wrong answer or will we get time limit exceeded or will we get accepted or will i get compilation error if there is if somebody can spot some compilation errors in my code i mean that that would be interesting let's see what are we getting so this is running on the first test case but but we have an infinite loop right so this gives this gives me this verdict called time limit exceeded on the very first test right so i hope ykk that was helpful like you know going through this problem although this was very easy i didn't have to think a lot of this no that's that's actually really helpful um so like in each of these problems the input is always like a text file and output is uh just a single uh value okay that's a good question again uh the input is uh the input could be like a text file but the output could not be just you know one uh one output like one character or one number for example if you look at this output this is like a this is like some peculiar stuff right so it's not essentially always a number uh it could be some string as well it could be some entirely i mean it could be just one line as an right so it could be anything you just have to print the output in the way that they expect you to print it for example look at this problem let's say instead of printing one let's say i just print something like this let's say print two before printing one now what do you expect would you expect uh getting a right answer or a wrong answer obviously you'll get a wrong answer right because code forces wants you to print one but you're printing this to one this is not intended right so i mean you just have to follow what you know they tell you to output all right um by the way it's been 40 minutes so far since the stream started how are you feeling i'm feeling great i mean you know uh if i can solve some problem on stream that's like a totally different feeling so essentially if you look at my youtube channel as well most of them are competitive programming streams right so essentially i'm just solving some problems on those streams and it feels great so yeah that was great nice uh yeah i'm wondering if we can like quickly answer a question then try solving another problem if you're down for it yeah sure like uh probably you can try out some difficult problem because these are like very easy and they don't require any thinking yeah sounds good let me just you know stop presenting for a while and let's see if we have some doubts in the chat right and then we can get back to presenting yeah uh so the question we have here is it would be great for beginners if you tell them about some of the biggest cp contests in the world okay now good question so uh first of all you have all of these websites like code forces code chef at coder right all of these websites you can refer to for solving problems and also for attempting competitive programming contests but these are not like you know uh uh very prestige uh i mean uh you know contests that are known by everyone right so there are contests like google code jam google uh google kickstart uh then there are contests like facebook hacker code chef smackdown right so there are like a lot of contests like these these are you know very well known fine so probably we can add the links to all of these in the description after this video uh it would be very you know difficult to like go through one of them because there are just a lot of them yeah sounds good um yeah i mean if you if you want to solve another problem i think people will like that too um sure just give me a minute let me go through the chat and see if we have something interesting yeah um people are someone's asking you know python or c plus plus we are you know we already answered it earlier basically c plus plus if you're just getting started but if you're already familiar with like python java or other languages you know don't switch right away necessarily like start with what you have and then you know switch if you want later great uh okay so somebody's asking should we go for a lead code problem uh instead of a code for this problem yeah i think we can do that because that's like a totally different environment so let's go for a lead code and let me pick up some problem i mean i don't want to you know end up wasting a lot of time just explaining how i'm thinking about the solution i do want to spend some time explaining how you can you know attempt problems on all of these platforms right uh so i hope this is yeah this is my account only and yeah i mean for that matter i haven't done a lot of lead code uh like if you look at my profile i haven't solved a lot of problems as such like only 33 easy 66 uh sorry 56 medium and just 15 heart problems so yeah mostly i do attempt contests only on lead code i don't you know end up spending a lot of time solving problems so let's see i don't even know how to navigate on this platform so much let's see let's go on to problems only and then let's pick up some easy problem only for now uh we don't want to you know just waste time trying to think about solutions yeah i think easier medium would be okay for for you probably yeah i mean for me anything is okay but i don't want to end up you know uh just making this whole stream like a competitive programming problemsolving stream right now let's pick up this problem let's see i think it's okay people will probably enjoy that okay sure let's let's go for like something like a medium problem yeah medium sounds good cool let me just read through this problem if i've already played since i've already opened it okay so i think this this is not interesting let's uh this is like very easy this just inbuilt implementation you can use right let's go for something like medium how do i set the difficulty yeah and if you're in the chat tell us what problems you want us to solve yeah and in fact you know uh don't just tell us what problems you want to solve but let's say if you've picked up some problem think about approaches to you know solve that problem right uh so let's see which problem do we want to like solve swap nodes and pairs something like this should we go for this one maybe uh so the nice thing you know to me about lead code is like i think it shows like how many people like like you know like the question i don't know if it shows that in this way oh yeah yeah it does show that as well so i think we should pick up some problem that is like you know liked by some people so uh i don't know what is this implemented generate parentheses or yeah whatever you want i guess okay i think this is like a linkless problem i don't really like you know playing up with linked lists so let's not solve this yeah i mean link list is more like the data structures algorithms it's not even about competitive programming yeah so uh what were you suggesting bracket generating bracket sequences something like this right uh which one uh you said something around bracket sequence yeah i guess go to 22 yeah scroll down 22 okay okay 22 generate parentheses okay okay so this problem is uh given n pair of parentheses write a function to generate all combinations of wellformed parentheses okay that's interesting and uh i mean n is uh you know n is the number of brackets i mean the number of parentheses that you want to use for example if n is equal to three you want to use three opening brackets and three closing brackets right uh so i mean if i were to just implement it in a very brute force manner what i could do uh do is you know just uh have this thing what like i can just you know uh pick up any bracket sequence i can pick up this first one this this first bracket sequence and i can just you know check all of its uh you know i mean how should i put it like i can just permute it right i can just consider all the permutations of this string and if any of them is valid i just include it in my answer right so how does that sound you know this approach let me just pick up the first sequence and just you know uh do all the permutations on it uh that's surely gonna sound like that efficient right yeah it's not it's it's not definitely it's not efficient but if you look at the constraints here n can go up till eight right so i mean it won't run but this is something i want to just put put up right uh so that people can you know look at how we're approaching problems right so i mean that's that's one approach but that wouldn't run uh again we haven't really talked about time and space complexity uh but the solution that i'm suggesting right now is like you know uh 2n factorial so if you have n brackets i mean if you have uh n as the input you have two in brackets right and if you consider all the permutations of it that's like two n factorial so here it would be like 16 factorial right uh so 16 factorial is like really huge and it won't work right so uh i mean i hope that that makes sense like you know in terms of time complexity it's really difficult to explain right now because i haven't really talked about time complexity but just assume that the approach that we discussed right now was really inefficient in terms of time right uh i hope that's that's fine like you know seeing it in this way no yeah i think that's pretty clear cool uh so how do we go about generating all the valid you know parentheses i mean that's the approach that we just discussed was definitely you know not the most efficient but another approach could be something like this let's say uh you know we have int n as the number we can you know have some opening brackets and we can have some closing brackets right so let's say we have opening equals to n and closing equals to n right and initially how many brackets have we used already uh induced equals to zero right so this is our initial state our initial state is you know we have zero brackets that we've used already uh and we have how many remaining brackets we have n opening brackets remaining and in closing brackets remaining right so i can just you know write a dp solution like you know dp of used comma opening comma closing and try out all the possibilities and then the complexity would be what complexity would be time would be like order of what order of n into n into n and space would be again order of n into n into n right so how does that sound like should we go about implementing the solution so could you explain that again okay sure so uh we have this input which is int n right what does this mean this just means that i have n closing brackets and opening brackets right so essentially i can just have a dynamic programming state what could what would that state be it would be just simply the number of brackets that i've used till now uh you know how many brackets do i have remaining i mean we don't even need this used thing so let's just have this thing right so the final time complexity would be order of n square and the space complexity again would be order of n square now let me just explain the solution it's very difficult for beginners to understand because obviously this is like a medium problem but look at it this way initially what do you have initially you have in opening brackets and you have in closing brackets what would you do now you would try to place some opening bracket or some closing bracket at the index that you are at right so if you are at any index you would want to essentially place some opening bracket or some closing bracket that's the two possibilities that you have right and i mean it doesn't really matter which opening bracket are you placing placing are you placing the first opening bracket or the last opening bracket right so that's like a simple dynamic programming state uh like does that make sense uh yeah i think so so you're what i'm doing is something like this dpf opening closing and uh this is you know considers all the ways uh are you gonna try to uh create an array of brackets and then kind of concatenate them into your string later yeah yeah yeah yeah but uh to be honest you know it's it would be really difficult to implement it on spot you know i mean it's not difficult to implement but that would just take up a lot of time so that's primarily why i did not want to choose a problem that requires a lot of implementation right yeah and i hope that that doesn't sound you know something like you know me being very incompetent no i i totally get that like it's it's hard to like solve something on the spot um but yeah how about you know how about you know we just implement the first approach that came to our mind i mean we could show we could show how you know we implement problems on lead code and how we submit them right so let's say if you talk about the first uh you know uh bracket sequence that you have already is something like this let's say we have string initial right initial is something like this and we just place n opening brackets first and then right so this is the first initial string that we have let's try to print this and let's see what we're getting let's turn this code okay i think we'll get some compilation error because just a minute we haven't returned anything okay let's see what is the error that we are having we have this right so this is what we are getting initially this is the first bracket sequence that you have in the line right and next what we can do is we can consider all of its permutations right and whichever of them is like a valid permutation we just include that in our answer so let's try to do it that way so we have vector string sorry we already have that available so let's do something like this so okay so uh let me just explain this function which is like the next permutation what does what this does is that it takes a permutation of a string or an array or a vector and just it just returns the next permutation if it's available if it is not available it just you know exits from this loop so this is this is this function that i'll have to implement which is this valid tool valid so i just have to check here whether this permutation that i'm considering is valid or not right how do you check whether a bracket sequence is valid uh a bracket sequence is valid as long as you have more or you know equal number of opening brackets before closing brackets right so we could have in sum equals to zero and we could just iterate on the string so if i equals equals to opening i just do sum plus plus l psi do some minus minus and i just take check if sum is greater than equal to 0 sorry if sum is less than equal to less than 0 i just return false because that's not a valid uh subsequence right a valid uh sequence cool so let's try to run this code and let's see if you're getting some compilation errors okay i haven't named it correctly okay so do you see that you're getting all of the valid subsequences here when n is three uh and we're getting the right answer so let's try to submit this also you know we won't get a right answer because uh this is like you know very heavy in terms of time so but let's see let's try to submit it and let's see what what is the verdict that we're getting okay somehow we're getting success i mean that uh it shouldn't have happened uh some i mean some more reasons why i should hate lead code probably yeah i mean if any good yeah with eight brackets it's it's probably okay i guess no no it's actually not okay like if you look at it we have something like this uh if n is equal to eight the number of brackets that i have are what we have and we have 2 into n right so that's like 16 factorial ways and i don't think that should work uh how many 16 16 factorial okay let's consider it this way uh so we have 6 factorial 6 factorial is what 6 factorial is 7 20 right so we have 720 into 7 into 8 into 9 into 10 into 11 into 12 into 13 into 14 into 15 into 16. okay this is really huge i mean uh if you look at uh sorry are you able to see this this yeah it is this huge yeah and this this won't run but but somehow it's running i don't know how right yeah that's that's not the most efficient way to solve this problem uh like i was saying the dp approach that i was suggesting is much better like you know cool so yeah that's that's how you submit solutions on lead code right uh so with with a dp approach i guess so like you know when you when you call like uh when you call the same function like recursively you would like append uh to what you have right right right like you would start at like index zero and then kind of uh go go to like index one two three and then just like keep adding stuff uh just like that yeah but we'll also you know be storing what is our current state so essentially we won't be repeating everything again and again right right yeah i guess generating everything is it's not it's not an efficient approach the dynamic programming approach oh i mean like uh the initial approach that you were just talking about the the it's the like more efficient approach right yeah definitely the dynamic programming approach you know is much more efficient and it will be only considering the valid sequences right so we won't be even going into the invalid sequences so that's that's definitely better than this cool um do you ever use like python to solve things by the way um i don't know i haven't really used a lot of python uh what i do is sometimes you know if you look at c plus plus like if you look at this number let's say i tell you this huge number uh let's open python and we have a equals to something like let me increase the font a equals to something like 2 to the power 1000 right if you print okay sorry it is a equals to 2 to the power 1 000 yeah now if you print this number this is like huge right uh you can't fit this number in c plus plus so sometimes when i you know uh don't want to get into a lot of precision and all of it all of that stuff i do end up using python as in but for competitive programming mostly not because it's uh it's slower it's lower than c plus plus yeah uh yeah i remember someone was asking earlier like do you get judged on like time and space complexity or just the runtime no you only get judged on the runtime it doesn't matter what your space and time complexity is but it's like very you know it's they both are correlated the better your time complexity the lesser time it will take for your code to run in right so essentially you're not just on time complexity you're run you're just on the runtime but in order to be able to code for a particular runtime you'll have to look at the time complexities cool um yeah it's it's been almost an hour so you know we can end it if you want like yeah because you know basically we can end it whenever you want what time is it over there uh it's 10 16 p.m but yeah i mean uh i'm cool like answering some more questions for like five to ten minutes uh and then we can end it yeah sure so let me just stop presenting my screen yeah let me see if if there are any questions and i think if there's anyone oh this one's kind of a good one is it necessary to be good at uh destruction algorithms to get a job okay it depends on what job you're applying to so it kind of totally depends on the type of company you're applying for like for example if you look at all of these fan companies like facebook amazon google netflix they do require you to be a very good problem solver and also be very good at data structures and algorithms right so for these companies uh yeah you would uh have to be good at dsa in order to crack their interviews but if you look at all of these interviews by these startups right so startups don't really care about a lot uh i mean they don't really care a lot about your problem solving skills or your data structures and algorithm knowledge what they care about is your development skills for example if there are two candidates one of them is a great competitive programmer is a great uh you know problem solver and let's say the other one is very good at you know implementing stuff in react or let's say is very good with python right and i mean that's like a development skill this is like a problemsolving skill right so startups would prefer the second type of person and you know big tech companies which are established would prefer the first type of person but again it's not like you know startups are bad or these big tech companies are good uh both of them you know are paying a huge amount of money to you know their employees so yeah both of them are good options it's not essential uh it's not you know totally required that you go along this dsa path and learn all of these dsm then go for then go apply for a job you can also be very good at development and then go and apply for a job as well yeah both of them work but you need to be good at some skill yeah cool uh thank you for that i you know i i totally agree with that sort of approach um anyway i feel like this is a good probably a good time to end the stream but yeah totally um did you have any anything like you wanted to add to this conversation we've had so far um not exactly like uh so far it's been great it was really great coming on this you know huge youtube channel that you have of your own right and talking about competitive programming um and thank you so much for like you know taking out time for this and you know scheduling all the meetings and you know putting out all of this stuff on twitter so that more people can come and join and uh yeah apart from that like for the people who've like you know who don't know about me a lot uh i also have a youtube channel on competitive programming so if this was the conversation that you know got you some uh i mean that got you interested i would definitely recommend you know checking out that youtube channel of mine and i hope you know you find some insightful content there as well cool um yeah i think this like i said this is probably a good time to end this stream uh if anyone's interested in you know learning more about uh competitive programming go check out uh preacher's channel twitter account everything everything's uh in the description and you know if you're new on this channel make sure to subscribe if you want and you know feel free to follow me on twitter too because i've been pretty active on twitter at waikidojo okay uh thank you so much everyone and have a nice day bye