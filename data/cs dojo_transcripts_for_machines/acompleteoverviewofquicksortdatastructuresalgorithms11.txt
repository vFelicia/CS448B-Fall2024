hey everyone in this video i'm gonna give you an introduction to an overview of quick sorts and by the way i recently restarted my patreon page so i would really appreciate it if you could check it out i'm gonna put a link to it in the description below anyway let's get started so suppose you're given an array of integers for example this one and your task is to sort it in the ascending order just like that and one approach you can use for this is quick sort quick sort implements a recursive function which we're going to call qs that takes three arguments the given array l and r l and r will be two integers that are going to represent the indexes that will show the section of the array that we want to sort so for example if you're given this array and if l happens to be 4 the index of this element right here and r happens to be 6 the index of this element right here then after running this function with these particular arguments this array will be like this so the section of the array that's between l and r will be sorted just like that so if you want to sort the entire array using qs you just need to give the same array with l being 0 the index of the first element and r being 6 in this particular case the index of the last element and to implement this recursive function qs we'll first take care of the base case that's when l is greater than or equal to r if l is equal to r if they are pointing to the same element for example this one then that will mean that the section of the array that we want to sort has only one element that's already sorted so there's nothing to do and if l is greater than r it's sort of the same thing the section of the array that we want to sort has no elements so there's nothing to do and that means we can just return from this function okay so that's the base case but what about the recursive case for that let's take a look at this example here where we're given this particular array with l being 0 and r being 6 or the index of the last element of this array in a recursive case we're going to do what's called partition i'm going to explain what it is in a second but for that we're going to use this function called partition that takes three arguments just like qs it's going to take r l and r and this is gonna do what's called partition for the array for the section between l and r so let me explain what it means exactly the first step for partitioning is to pick what's called a pivot i'm going to explain what it is in a second and there are different ways of choosing your pivot but one simple approach is to pick the last element as your pivot so that's this number right here in this particular case then the goal of this partition function is to divide this array into two groups the first group is going to be all the numbers that are less than the pivot so in this particular case that's these three numbers minus two minus one and zero and those numbers should come to the left of the pivot and the second group of the numbers that we're going to examine is going to be the numbers greater than the pivot so those are these three numbers 3 2 and 4 in this particular case and these three numbers should come to the right of the pivots and obviously the pivot should come in between those two groups of numbers so in this particular case after running the partition function the array should look like this as you can see after running the partition function the pivot will come to the center of the array and all the numbers less than the pivot are to the left of it and all the numbers greater or equal to the pivot are to the right of it and we don't care about the ordering of the numbers within each group these numbers happen to be sorted but as you can see these numbers in this group are not sorted either way another thing to note here is that we're going to write this partition function so that it's going to do the partitioning and then it's going to return the new index of the pivot so in this particular case that's right here and so it's going to return 3 or the index of the pivots and then we can store it in a new variable which we're going to call p here and i'm going to show you how to implement partition later but let's just here for now say that we already have this function so after partitioning the given section of the array we'll already know that the position of the pivot right here is correct so that means that this position isn't going to change after sorting this entire array so all we need to take care of after partitioning is this group of numbers and this group of numbers we need to sort this section and then this section and we can do that by calling qs on this section and then qs on this section we can do that with qs of r l and p minus 1. so here we're saying we're going to sort the section of the array between l which is right here and p minus 1 which is right here and then we're going to do the same thing for the other section with q s of r p plus 1 and r so we're saying we're gonna sort the section over the array between p plus one and r and by repeating this process uh recursively we'll be able to sort the entire array now let's take a look at how partition might be implemented but before i show you some code i'm going to give you an overview of how it works and for that i'm going to use an example where we have an array of 11 elements just like this one and to explain it actually i'm going to jump into the middle of running this algorithm instead of at the beginning and i'm doing it that way because i think the middle part is easier to understand and then you know i'm going to explain the beginning part later anyway let's say here that we're trying to partition the entire array and our pivot is the last element 10 right here and to run this algorithm we're going to use two indexes j and i j will keep track of the current number that we're examining and this is going to be part of a for loop that we're going to use so that for loop is going to say move j from the beginning of this array up to the number that's right before the pivots and currently we're examining this number let's say and in each iteration of the for loop we want to make sure that all the numbers we've seen so far are separated into two groups the first group is the numbers that are less than the pivot and the second group is the numbers that are greater than or equal to the pivot and we want to do it in the way that i this index right here will always point to the last number out of the numbers less than the pivots in other words there are two conditions that we want to always satisfy the first one is that all the numbers from the beginning up to i are less than the pivot and the second one is that all the numbers between i and j not including i are greater than or equal to the pivot and like i said earlier we're currently examining this number and those two conditions are already satisfied because 12 is already greater than the pivot so we can move to the next number by incrementing j by 1. and at this point uh one of those conditions is not satisfied anymore and uh we can fix that by doing this we're gonna increment i by one or move i over here and then swap the values at i and j just like that and that way those two conditions are satisfied again so all the numbers up to i are less than the pivot and all the numbers after that up to j are greater than or equal to the pivots so we can keep going move j over here and since this number 16 is already greater than the pivot there is nothing to do so let's move j over here and as you can see the number at j is less than the pivot so we'll need to do the same thing uh increment i by one or move i over here and then swap the values at i and j just like that okay and let's uh finish this up by moving j over here or by incrementing j by one and then uh doing the same thing increment i by 1 and then swap other values at i and j all right and as you can see at this point this array has been grouped into two groups of numbers the number is less than the pivot and the numbers are greater than the pivot but the last thing we need to do is we need to make sure that the pivot is between those two groups we can do that by swapping the pivots with the value at i plus 1 this value right here so let's swap those two values just like that and then we're done partitioning like i said from our partition function we're supposed to return the index of the pivot so we can just return i plus 1 because that's the index of the pivot okay so now that we hopefully understand how this partition algorithm works let's take a look at some suit code uh like i said earlier we're gonna call this function partition and it's gonna take three arguments the given array l and r and this function is going to apply partition to the section of the array between l and r let's say here as an example that we're given this particular array with l being the beginning of the array or zero and r uh being the end of the array or six in this particular case and the first step of this function is going to be define the pivot and that's going to be the value at r or the last element of the section of the array that we are trying to partition and that's going to be 0 in this particular case and then we're going to define i to be o minus 1. in this particular case i will be initialized to minus 1. and then we're going to run a for loop for j from l this element up to r minus 1 the last index before the pivot and in each iteration of this for loop we're going to check if the current number that we're examining or r of j is less than the pivots if that's the case for example the current number we're examining minus 2 is less than the pivot which is 0. if that's the case then we're going to increment i by 1 and then we're going to swap r of i and r of j so those two numbers happen to be the same number in this particular case so we're swapping this number by itself and nothing happens but let's continue with this for loop so after that we'll move j over here and since uh the current number that we're examining 3 is greater than or equal to pivot so nothing happens and so we move j over here and at that point this number is less than the pivot so we're going to move i over here and then we're going to swap the numbers at i and j and just like that we can keep going with this for loop until j is right here at that point our array is going to look like this uh j is going to be right here and i is going to be right here uh after that we want the people to be between those two groups of numbers and we can do that by swapping r of i plus 1 this number right here 5 and our pivot r of r so that's this number and this number and once it's swapped 0 will come here and 5 will come here we just need to return uh i plus 1 the index of the pivots okay so that's my suit code but you can check my actual implementation in python and java at this url too okay so that's the quick sort algorithm but what about the time complexity to understand this we'll need to consider the best case the worst case as well as the average case so let's start with the worst case that's when the given array is already sorted like this one or when we have a lot of duplicates in the given array like this one and actually the time complexity of these two cases will be the same so let's just consider a case where the given array is already sorted for this particular example uh to sort this array with the qs function that we saw earlier we would call it with the given array 0 and 6. so 0 would be right here at the beginning of the array and 6 would be the index of the last element of the array and the pivot will be this one and after running the partition function for the entire array actually what's going to happen is the pivot will stay here and all the elements will stay where they are so nothing is going to happen to this array and after finishing a partition we'll need to call qs for the rest of the array other than the pivots we can do that with qs of r and 0 and 5. and we end up doing the same sort of thing over and over again so we would call qs of r and zero and four after that and so on until we get down to qs of r uh zero and one so the pattern we see here is that the number of elements that we need to examine in the qs function starts at let's say n the number of elements in the entire array and then we get down to n minus 1 and so on n minus 2 up until 1. so as i said this is the number of elements that we need to examine in the qs function each of these numbers but it's also the number of iterations that we need to go through in our main for loop to be precise you might say if we have n elements given to the qs function we'll need to go through n minus 1 for loops in our partition function but it's roughly n so if you want to add up the total number of for loop iterations that we need to go through for this entire execution of the function then we can just add these numbers up so we get this one n times n plus 1 divided by 2 which is o of n squared and that's why we get o n squared as the time complexity of the worst case scenario and what about the best case well the best case is every time we chose our pivot it happens to be the best choice so it means it happens to be at the median or the closest number to the median of the given section of the given array so as you can see in this particular case the number of integers less than the pivot is equivalent to the number of integers greater than the pivot in the best case scenario like that we would start with n elements that we need to deal with in our qs function and then in the subsequent cause of qs we would have to deal with n over two elements in one of the calls and n over two in the other one uh it's going to be slightly less than n over two uh but it's going to be about n over two and in the subsequent cause after that uh we would need to deal with n over four elements and so on uh until we get down to uh single elements and what's interesting here is if you look at each level if you look at the top level for example you can see that we would go through about n for loops in our partition function in this level and if you look at the second level we can do the same kind of analysis for uh this call in the partition function we would need to deal with n over 2 for loops and for this one we need to deal with n over 2 for loops as well so the total number of loops that we need to go through for the second level is going to be of n as well or about n uh loops it's going to be the same thing with this level and this level as well and this kind of analysis will show you that uh executing everything on each level will take off and in time and you might say well how many levels do we have in this recursion tree well we can use the same kind of argument uh as the one i used in my binary search video to show that the number of levels here is going to be about log n or log 2 of n so basically what i'm saying here is that we have log n levels here and for each level and the time complexity is of n so to find the total time complexity for the best case scenario we can just multiply them together and we get of n log n so that's the time complexity for the best case scenario you might say what about the average case well it's more tricky to think about but given a few assumptions we can actually show that the time complexity for the average case is also of n log n and by the way those few assumptions are first that there are no duplicates so we don't have a case like this and second that the ordering of the array is random and i saw this proof in a book i used as a reference to make this video so in case you're curious about the proof i'll put a link to the book in the description below as well okay and before i go i wanted to mention a few things to note about the implementation details the first one is how to choose the pivot of course in our implementation we chose the last element but another method is to pick a random element as your pivot or equivalently you can before running our quicksort function you can reach shuffle the given array randomly and then pick the last element as the pivot and another method for choosing the pivot is called median of three the idea of this approach is instead of picking one element you would choose three elements randomly from the given section of the given array and then you would pick the median of those three numbers and that way you'll be able to decrease the probability that you would pick a bad pivot for the given section of the given array okay and the second thing i wanted to discuss is dealing with duplicates because as we saw quicksort doesn't perform well when there are a lot of duplicates in the given array one way to deal with this is called threeway quick sort in case you're curious about it i'm gonna put a link to a page that describes this method but the idea of this method is that instead of dividing the given section of the given array into two groups we divide it into three groups the first group is going to be the numbers less than the pivot the second group is going to be the numbers equal to the pivot and the third group is going to be the numbers greater than the pivot again in case you're curious about it i'm going to put a link to a page with more info about it in the description below anyway that's all i wanted to talk about in this video i hope you enjoyed this video and uh thank you as always for watching my videos i'll see you guys in the next one