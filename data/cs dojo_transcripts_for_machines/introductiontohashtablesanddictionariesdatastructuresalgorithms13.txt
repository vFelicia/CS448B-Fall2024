hey everyone in this video i'm going to give you an introduction to hash tables and dictionaries first of all let me explain what a dictionary is and then i'm going to explain how it can be implemented using a hash table so here's an example of a dictionary as you might guess this is essentially a table that shows different people's age and you can ask this table or this dictionary how old is paul for example then you get the number 29 right away or you can ask it how old is chloe and you get 88 and that operation can be called search because you're looking for a specific key for example paul to find the corresponding value uh in that case 29 and these pairs are often called key value pairs by the way so a dictionary is basically a collection of these key value pairs or a data structure that can store these key value pairs so that you can retrieve the value of any of those keys quickly and in additionally you can define a few more operations one is insert and that would be adding a new entry to this table by saying bob is eight for example another one is delete and that would be dealing an existing entry for example you might say well i don't want this data about chloe anymore when you implement a dictionary you should be able to implement it ideally so that all of these operations take only one in time on average and a hash table is a good way to do that to build a hash table the first thing you'll need is an array so here i have an array of eight elements just as an example and let's say that we want to use the array or the hash table to represent the dictionary that we saw earlier this one to do that we're going to put each key value pair in one of these slots but to do that we need a way to decide which key value pair is going to go into which slot of this array one way to do that would be to look at the first letter the first character of each key and compare it to the letter a and compute how many characters away it is from the letter a so for example for this key paul you can look at the first letter p convert it to the lowercase p and compare it to the lowercase a and in ascii code you'll be able to see that p is 15 characters away from a but 15 wouldn't be an index of this array because that would be out of range so you would need to use for example the model operator mod 8 mod of the length of the array to get the desired range that would be 0 to 7 inclusive and with that method you would get 7. so at that point you can put this key value pair paul 29 over here at index 7. and just like that we can decide which index of the array we want to use for each key value pair so jane would be over here at index one chloe would be over here and alex would be over here and actually what i showed you here is already a hash table so basically to construct a hash table you need an array and the dictionary you want to represent and a way to decide which index of the array you want to use for each key value pair another way to describe the same thing would be to say we need a function that turns each of these keys whether they're strings or anything else into an index of this array that we constructed and we could call that function for example h1 and with the method that i just showed you h1 of paw would be 7. and this function is usually called a hash function and that's why this whole thing is called a hash table but this particular hash function that i just showed you might not be ideal for a few reasons one of them is this if you consider english names there might be a lot of names that start with j and if you put for example josh in this dictionary or this hash table it would try to go into the same bucket as jane and the same thing with jennifer and that would be called a collision when multiple keys would try to go into the same spot of this array and there is a way to deal with collisions and we're going to talk about those but for now you should know that we want to avoid collisions as much as possible to keep your hash table efficient and so one way to deal with a problem like that would be to consider most of the letters or many of the letters in the given key if not all of the letters and one such function is called djb2 and i'm going to put a link to some information about that in the description just in case you're curious about it anyway when you're choosing a hash function for your hash table there are a few things that you should consider one is that it should be fast to compute and the other one is that is to try to avoid collisions as much as possible and that's pretty much it when it comes to the criteria in some textbooks they might say your hash functions should be uniformly distributed or random looking or something like that but it's really not necessary for practical purposes and it's not necessarily better than nonuniformly distributed functions so if you're choosing a hash function for your hash table you should really only consider these two criteria and when you're choosing a hash function for security purposes you might have other concerns but here we're only talking about a hash function for a hash table okay let's now talk about how to do with collisions we're going to talk about two families of methods for dealing with collisions in this video and the first one is called chaining with this method instead of storing the key value pairs directly in the array we're going to store them in a linked list and from each element of the array we're going to have a pointer to that linked list and that linked list is going to contain all the key value pairs that were assigned to that particular slot in the array so for example if you have another key value pair that was assigned to this same slot then what we'll need to do is we'll need to put the new key value pair at the beginning or at the top of this linked list just like that and if you have another key value pair that was assigned to an empty slot then we'll need to create a new linked list containing this single element and then have a pointer that points to the new linked list from that slot and with chaining insertion only takes oh one in time or constant amount of time and what about search well to explain that i'll need to first define a few variables and here is the number of elements that we have put in so far in this hash table and m is the length of the array so this alpha which is n over m is going to show how full this hash table is so right now because n is 4 and m is 8 alpha is exactly a half and with this you can show that search only takes o 1 plus alpha in time what this means is that if you keep alpha below a certain number below let's say 1 search would only take a constant amount of time and this o 1 plus alpha is the average time and here you might say what if i don't want to use this extra data structure outside of this array then the approach you might want to use is called open addressing and there are a few different flavors for it i'm going to explain the simplest one first which is linear probing with linear probing or with open addressing in general we store all the key value pairs within the array itself just like you can see here let's say here that we have another key value pair that collides with this one then with linear probing all we need to do is we'll need to check the element that's directly to the right of the collision and if it's empty we can just put it there and if another element collides with this one again we'll need to check this element and then this element next until we find an empty element and then we can put it in there so just like that if this new q value pair collides with this one we'll need to keep checking the elements to the right until we find an empty one so i would say linear probing is an okay approach but it could be inefficient when you have a lot of elements and that's because these elements are likely to start forming clusters when you have a lot of them so for example you have a cluster of five elements here and when you have a cluster of five elements or maybe a lot more elements it would take you know extra time to go through all of them and to find an empty spot and one way to solve that issue is called double hashing so let me explain how double hashing works let's say that this key value pair happens to collide with this one then what we're going to do is similar to linear probing in a way that we're going to jump ahead and check other elements to see if they're empty but instead of jumping ahead by one element we're going to pick a number here let's say 3 to determine how many elements we want to check ahead so if we pick three here we're going to check one two three this element the third element and we're gonna check every third element ahead of that so since this is empty we're going to put it here but if another pair collides with this one and if we happen to pick three again we're gonna check the third element and then we're going to jump ahead by three elements again so that would be one two it would be this almond but since it doesn't exist we're gonna jump back here and the nice thing about double hashing is that every time we have a collision uh depending on the key or depending on the starting point we're going to produce a slightly different sequence every time the sequence of the elements that we're going to check so let's say that this new pair collides with this one we might pick uh one for the number of elements that we're going to drop ahead if we pick one we're going to just go to this element and find that this is empty so we don't necessarily jump from here to here and have another equation and that's why we're less likely to have clusters in double hashing and that's why it can be more efficient than linear probing to summarize this we first pick our initial index for the given key with a hash function h1 with the model operator the length of the array in this particular case 8 and then the next index that we're going to check is going to be the original index plus c the number that we're going to pick for the particular key mod 8. and the next one after that is going to be i plus 2c mod 8 and so on and here i think the natural question would be how do we pick this number c well one condition that we need to satisfy is that gcd of c and m or the greatest common divisor or the greatest common factor of c and m should be 1 and m is the length of the array here and that's because by satisfying this condition we can make sure that this sequence of indices will eventually cover the entire array and one convenient way to make sure that's true is to always set m the length of the array to be a prime number and c to be a positive integer and that way gcd of c and m will automatically be 1. okay so how do we pick c uh here's one way of picking it assuming that m is a prime number we're going to use a second hash function which we're going to call h2 and then we're going to put a key into that function and then do some operations here so let me explain what we're doing here here we're applying the mod operation with m minus 1 to the result of the hash function and that way the range of the results that we can get from this whole expression is going to be 0 to n minus 2 inclusive and by adding 1 to that result we're going to get the range 1 to n minus 1 inclusive and that's the range that we want and here the natural question after that is how do we pick h2 for that i ran an experiment and i tried a few different approaches so here's uh the first approach i tried we have h1 the original hash function and to make h2 i simply appended a letter which i picked it could be anything but i picked d here to the key so if the key is jane i just put jane d to h1 and then i used that as h2 and it actually seemed to perform pretty well and by the way the h1 i used for this one is the default hash function of python which seems to be based on dj b2 which i mentioned earlier and the second approach i tried is simply this so i used exactly the same hash function as the original one as the second hash function and so much surprisingly it performed as well as the first approach but i would say if you want to try implementing double hashing yourself you should try a few different hash functions because the performance probably depends on your particular environment and the particular kind of input data that you get anyway with double hashing you can show that with a few assumptions that to complete either the search operation or the insertion operation you need to check almost this number of elements on average that's 1 over 1 minus alpha where alpha is n over m so again n is the number of elements that we've put in so far in the hash table and m is the length of the array so just like i said before alpha shows how full your hash table is so let's say that alpha is two thirds then this expression one over one minus alpha becomes three so that means that to complete search or insertion you need to check at most three elements on average so basically if you keep alpha below a certain number let's say two thirds again you'll be able to complete search or insertion in constant time so what i would suggest if you're implementing double hashing by yourself well at least one way to do that would be to pick m to be a prime number let's say 7 or 701 and then as soon as alpha becomes uh greater than twothirds resize the array pick a larger prime number than the original m and then transfer all the elements to the new array and that way resizing the array takes extra time but at least for search and insertion it's only going to take a constant amount of time as long as alpha stays low enough okay so that's my introduction to hash tables and dictionaries but there are a few things i wanted to mention before i go one is that there is a coding interview problem that i covered a while ago on this channel and for that problem you can actually use one of these concepts to solve it so i'll put a link to that video in the description below just in case you want to watch it the other one is that i tried implementing a hash table in python so i'm going to put a link to that code in the description below as well and from that code you'll be able to see how i ran the experiment i mentioned earlier too anyway thank you as always for watching my videos and i'll see you guys in the next one