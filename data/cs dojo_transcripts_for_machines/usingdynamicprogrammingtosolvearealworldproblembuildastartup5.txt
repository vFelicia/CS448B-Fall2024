hi everyone so recently as some of you know I've been working on a project where I try to start a real startup that's based on this app I'm making for learning languages and in this process I run into a problem where I needed to use dynamic programming to solve it so I'm going to show you what the problem was and how I solved it so like I explained it in one of my previous videos on this app I'm developing which I'm thinking about calling Edit dojo people are gonna write stuff in different languages and other people are gonna fix them or edit them for them so one person might write the breakfast I had today was awesome and someone else might edit them edit this too this at the professor I had today was awesome and the function I was trying to make is the function that shows the difference between these two sentences so given these two sentences we want to be able to say that you know this word has been deleted from the first centers and also this word and then these two words have been sort of added to the second sentence and there are a few different ways of going about it one is to compare these two sentences word for word that's what I've done and that's why you see you know these two words changed but another way to do this is to compare these two sentences character by character so if you take the approach the UI might look like this instead so here you can see that instead of showing the whole words being changed we're only saying okay you know this character o has been deleted and the same thing with this letter e so which one is a better approach well I think either one works but in my opinion the comparison by word approach is much easier to read so that's what I'm gonna use for English but the thing is for languages like Japanese there's no easy way to split a sentence by worse so I decided to use the comparison by character approach for languages like Japanese and in this video I'm gonna explain the comparison by character approach because it's much simpler to explain anyway whichever approach you decide to take this problem actually reduces to another problem called the longest common subsequence problem I already talked about it in one of my really old videos actually but let me explain what it is here again so in the longest common subsequence problem you're given two strings for example these two a b c d and a c DB you want to be able to find a common subsequence between these two strings that's the longest so in this particular example the answer would be this one a CD so as you can see this is a subsequence of the first string you know it's a CD right here and it's a subsequence of the second string as well a CD right here and there are usually multiple common subsequences between these two given strings in this example another common subsequence would be this one a B you know there's a B right here and there's a B right here in the second string as well but in this problem you want to be able to find the longest one of those common subsequences and again in this example the the answer is this one and sometimes there are multiple answers you know there are multiple mungus common subsequences but let's just say that here you know we just want to be able to find at least one of them and it doesn't matter which one we find okay now let me just quickly explain how we can apply this problem to solve the problem that we saw earlier so let's say that the original text is this one I am waiting and let's say that someone else fixed it to this one I've been waiting then what we can do is we can first find the longest common subsequence between these two strings that would be this one i spaced space waiting and then to find which parts of the first string has been deleted we can compare this string with the longest common subsequence this one which is basically the common part of these two strings and then when you do that you see that this part just am has been deleted from the first string because the common string ice space space waiting is right here and then what's left is just this part and then you can do the same thing to the second string to see which parts have been added to the second string so compare the common string with the second string and you see that the ports that have been added is this part and this part and then you know you can highlight those parts to get this text okay so that's going to be the idea of my solution of course the first step of going about this solution is to solve the longest common subsequence problem so let me show you how I would solve that part okay so I'm gonna write a function called LCS of these two strings and this function is going to return the longest common subsequence of these two strings and I'm gonna solve this problem recursively and one case of this recursive solution it's gonna be when the given two strings have the same first letter in this case a right here and in that case we'll say whatever the longest common subsequence of these two strings is it must have a as the first letter so it's sort of like taking off these two letters and then saying the longest common subsequence of these two strings is gonna be a concatenated with the longest common subsequence of these two strings b c d and c de b the rest of the strings so we can write that as the longest common subsequence of these two strings is going to be a concatenated with the longest common subsequence of the rest of the strings b c d and c da b and this might be actually a little bit hard to get your head around so I'd recommend you know playing with a few examples to see why this is actually the case anyway let's go to our next case that's when the given two strings don't have the same letter at the beginning we have B C D and then C D B for example in this case so in this case we're gonna try two things one is we're gonna take off the first letter of the first string and then we'll ask ourselves what's the longest common subsequence of the rest of the strings so CD and CD EB and then we're gonna do the same thing with the second string take off you know the first letter of the second string and then ask ourselves what's the longest common subsequence of BCD and dB and it turns out whichever is the longer common subsequence is going to be the longest common subsequence of the given two strings so we can informally write it as the longest common subsequence of these two strings b c d and c d eb is compare you know these two longest common subsequence CD and CD B and then B C D and D B so that's CD and CD b or b c d and d b right here and then just take the longer one of them I was just ready as Max again you know this might be a little bit hard to get your head around so I recommend you know playing around with a few examples here too now if you implement this function as is you need to create new strings every time we call this function so for example if you're given LC s of these two strings ABCD and s DB we'll need to create these two strings b c d and c DB to call this function recursively and that's pretty wasteful but we don't have to do that instead of doing that we're gonna pass in two new arguments that are going to specify which letters we're currently examining in these two strings so instead of saying you know LCS of a b c d and a c DB will say LCS of these two strings and then 0 0 and that's gonna mean we're examining this letter right here which has the index 0 and this letter right here whose index is also 0 and then when we call this function recursively instead of generating new strings we're just gonna change the indices so we'll say LCS of ABCD is DB and then 1 1 because now we're examining these two letters B and then C right here whose index is both 1 and we can do the same thing for this case as well instead of passing a b c d and c de be the original strings might be a b c d and a c DB and then you know we're passing 1 1 as we saw earlier and then instead of creating these two or these four strings we're just gonna change the indices again so this is gonna be like that max of LCS of the same strings and then 2 1 and then i will see s of the same strings and 1 2 ok so let me show you how i would implement this function recursively and i'm gonna show you that using pseudocode so like we saw earlier we're gonna write a function called LCS of s1 s2 the two strings and ione itwo the two indices of the letters that were examining and then outside this function we're gonna have to call this function with the two given strings and 0 0 because we're gonna start with the first letters anyway the first thing we're gonna do in our main function is we're gonna take care of the base case and that's when I 1 is equal to s1 s length or I 2 is equal to s2 slangs and this is sort of like saying what's the longest common subsequence between an empty string with another string and the answer is an empty string so we're gonna return an empty string from here and the next case that we need to take care of is when the current letters that were examining s1 square brackets i 1 and s2 square brackets I 2 are the same if that's the case we're going to return it's one of the current letter S one of I one it should be i one here concatenated with the longest common subsequence of s 1 s 2 I 1 + 1 and I 2 + 1 and if we haven't returned yet at this point that means that the current letters that we're examining are different so in that case we'll need to find 2 results without a and without B result a is going to be LCS of s 1 s 2 I 1 plus 1 and I 2 and then without B is going to be as LC s of s 1 s 2 I 1 and then I 2 plus 1 and then we're gonna have to compare the lengths of these two strings and then we turned a longer one so we can do that with if result a s length is longer than result B's length then we're going to return result a and otherwise we're gonna return result B okay so this function works this implementation works but it turns out it's very very inefficient and the reason is because we end up calling you know the same function LC s with exactly the same arguments over and over again depending on the strings so for example we might call LC s of s 1 s 2 2 3 over and over again depending on what the strings are and every time we call this function you know we need to recompute what the result is for for these particular arguments and this is where the idea of dynamic programming comes in you know dynamic programming says why not store the return value of this function with these particular arguments so that we can reuse it and so that's the idea let's see what the code is gonna look like ok so this is part of the dynamic programming solution code and it's pretty much exactly the same as what we saw earlier except for this additional argument that I added here called memo this is going to be a twodimensional array that's gonna store the return values of this function LCS and so before we call this function we're gonna have to initialize a new twodimensional array whose size is gonna be s 1 dot length by s 2 dot length and then the results or the return value of LC s of s 1 s 2 I 1 I 2 memo is going to be stored right here in this twodimensional array at the indices I 1 and I 2 and so you know outside of this function we're gonna have to initialize that and then call LC s with s 1 s 2 actually 0 0 and then memo let's just assume here that every element of this array is gonna be initialized to either undefined or no ok and once you have that after taking care of the base case we'll say if memo at the indices I 1 and I 2 is not undefined that means that we've already seen these particular arguments you know i1 and i2 and we've already stored the return value of this function with those arguments in memo at this at this location so we're just gonna return that by saying we turn memo square brackets I 1 and I 2 and what about this case when we haven't returned at this point and when the letters that we're examining are the same this case right here in that case instead of returning you know the thing that we saw earlier the first letter concatenated with LCS or the results of the next LCS call we're gonna store that a memo at the location that we saw earlier at I 1 and I 2 just like that memo skyrockets I 1 and I 2 is equal to this thing that we're gonna return and since we just store the return value of this function with these particular arguments a memo of i1 and i2 instead of computing it again we're just gonna return that just like that right here ok and to make this function complete you need to do the same thing basically for the second case when s1 square brackets I 1 is not equal to s2 square brackets I 2 so before you return the result you'll need to store it in memo and then return that instead okay so once you have all of that this function is going to be complete but what about the time complexity well just in case you're curious here it is suppose we write s once length as l and s twos length as M then the time complexity of this function is going to be this assuming that my analysis is correct it's going to be bigoh of L times M and if you're curious why that's the case I'd recommend watching my old video about the longest common subsequence and this is actually much better than the naive recursive solution that we saw earlier which has an exponential time Quebec City ok so that's the idea of this code but let me show you if we can actually implement it using javascript okay so here's the setup I have here I have this HTML file testa HTML for showing the test cases we have a few test cases here one of them is this one the original text is ABCD and the edited text is a fkd and the longest common subsequence between these two is ad so our function given these two strings should return ad so that's the expected result and the result of our function will come in here after actual result and our function right now just looks like this it's just a function that's called LCS that's going to take two strings s1 and s2 and returns a string so if I change this to hello we should see hello right here okay let's start by implementing the naive recursive approach I'm gonna create a new function called helper which we're gonna call recursively so this helper function is gonna take four arguments the two strings s1 and s2 and then the indexes the indices of the letters that were examining that should be zero zero at the beginning so let me define the functional helper here this is gonna take s1 s2 and they i1 and i2 and just for testing let's return hello to make sure that's showing on our HTML file here and by the way I'm gonna put the end result of my code today at CSD dojo da yo / text so you can play around with my code yourself anyway let me implement the rest of the recursive solution so the base case was when I 1 is equal to s ones length or s I 2 is equal to s tooth length we should return just an empty string and then the second case is if s1 square brackets i 1 or the current letter that we're examining is equal to s2 square brackets i 2 then we should return is 1 I 1 that's the current letter that we're examining concatenated with helper of s 1 is 2 I 1 plus 1 and then I 2 plus 1 and for the last case I would say first let result a be equal to helper of s 1 s 2 I 1 plus 1 and then I 2 and results B should be helper of s 1 s 2 I 1 and then I 2 plus 1 and then whichever is the longer we're gonna return us the results so I'll say if results is length is larger than results B's length then we're gonna return result a and else otherwise return result B okay so this should work let's see if it works by going back to the browser and when i refresh this actually this takes too long and the reason is because the naive recursive solution is you know very inefficient so too sort of fix that for now we have you know three test cases right one of them is pretty short but the other two are kind of long let me close this window for now so the two test cases that we have here pretty along the text I am waiting for in snow and the break the breakfast I had today was awesome so the naive recursive solution is efficient enough for the first case but not efficient enough for that two other cases so I'm gonna take them out just by changing the code here and then I'm gonna go back to the browser and when I open the file again I see the correct result okay let's now make this code more efficient by using the approach that we saw earlier so the first thing we want to do in this parent function LCS is we want to initialize a new two dimensional array called memo whose size is gonna be s once that length by its to that length in JavaScript there is a neat trick for doing that so let me just write it here first I'm going to write square brackets dot array is one's length this produces an array of length s one's length whose elements are going to be undefined and then I'm gonna say dot map e ro and then array s2 length so with this we can create a twodimensional array whose size is s1 start length by s2 style length after that we'll just need to pass this memo to this helper function so let's add memo here and then also here basically everywhere a helper is called so here here and here so this doesn't change anything algorithm eyes but let's just make sure that everything still works and it does so let's go back to the code editor and then let's keep going okay the next step is after taking care of that base case we'll say if memo I 1 I 2 is not exactly equal to undefined then we're just going to return that memo of i1 and i2 and then in the first case when s 1 i1 s 1 of I 1 is equal to s T of i2 we're gonna store this return value a memo of i1 and i2 and then we're gonna return that instead and we're gonna do the same thing here to we're going to first define a new variable called results and then instead of returning a result a and result be here I'm gonna put it here so results is equal to result a or result B and then before we return the result we're gonna put that in memo of i1 i2 and then we're gonna return that instead so this is gonna hopefully work let's see if it works for this particular test case and it does let's fixed test HTML so that we can you know test the other cases to hopefully this is going to be fast enough for for the other two cases too so let's see if it works here and it looks like it's working so in this case the expected result is I waiting for snow and the actual result is the same and it looks like it's working for the third case too okay so what I'm gonna do now is I'm gonna implement the rest of the algorithm here so that we can actually show the difference between the two given sets of text ok so here's what I have now as you can see you know we have for example in this example we have the original text the edited text we have the LCS but we also have the this view where we are showing the original text but we're also showing you know which parts of it have been deleted we show the edited text we show which parts have been added in blue text and the way I did it is like I explained earlier I compared the LCS of these two strings with the strings so for the original text I said okay what's the difference between I waiting for snow and I am waiting for snow and the difference is am so I highlighted that part in red and then I basically did the same thing you know compared LCS with the edited text and the difference is this part the bin and that part has been highlighted in blue using CSS okay so like I said earlier I'm gonna put all this code in CS nose without oil slash text so you can you know check how it works and play around with it and also I recently set up a discord server for this channel so you should come join us at C a snowsuit I owe slash D if you haven't yet and this was of course part of my build a startup series which you can find at CH dojo da io / start or through a link in the description below anyway thank you as always for watching my videos and I'll see you guys in the next one