00:01 - wrapper classes
00:03 - we know
00:04 - in the object oriented programming
00:07 - language everything exists in the form
00:09 - of classes and objects
00:12 - but the primitive data types are not as
00:16 - objects
00:17 - because they have defined in the
00:20 - language itself sometimes we may require
00:23 - to convert primitive data types into
00:26 - objects for this purpose we can use
00:30 - wrapper classes so
00:33 - wrapper classes are used when we require
00:36 - to convert primitive data types into
00:39 - objects
00:40 - wrapper class wraps the data type and
00:44 - gives the appearance of an object
00:48 - we know that we have
00:50 - eight primitive data types for all the
00:53 - primitive data types we have
00:55 - corresponding wrapper classes
00:58 - let us see the corresponding wrapper
01:00 - classes
01:03 - for byte data type we have wrapper class
01:07 - byte but
01:08 - b letter will be
01:10 - capital same like that for short
01:15 - short with capital s
01:18 - for ind we have
01:20 - fully the word integer with capital i
01:25 - for long
01:26 - capital l long
01:28 - for float capital f float
01:31 - for double capital d double
01:34 - and
01:35 - for
01:36 - character we have
01:38 - fully the word character with capital c
01:43 - boolean type we have capital b
01:46 - boolean
01:48 - wrapper classes are in
01:50 - java dot lang
01:52 - package so we already know
01:55 - java.lang package is a default package
01:59 - we don't need to
02:00 - import it
02:02 - so for byte we have java dot
02:04 - lang dot byte
02:06 - and then for short java dot
02:09 - lang dot shot and so on
02:12 - let us see the
02:13 - method with the example
02:18 - for integer we have integer dot parse
02:22 - inter
02:24 - and the value of the string
02:26 - example
02:28 - if n is the variable and then integer
02:31 - dot parse into
02:33 - 36 so here 36 36n
02:35 - object which is a string object this
02:38 - will be converted into integer value
02:42 - then we will be able to perform some
02:44 - operations
02:47 - same like that integer dot value of
02:51 - that string will convert that into
02:54 - integer value
02:56 - if it is an integer then we can convert
02:59 - into string integer dot to string of the
03:03 - value of integer so it get converted
03:05 - into string same like that we have for
03:09 - all other
03:11 - data types also
03:13 - here we will see mainly
03:15 - integer and character type
03:22 - so in character type we have
03:24 - few things which are more important in
03:27 - programming
03:30 - if we need to convert
03:32 - a small letter into capital letter then
03:36 - we may use this character dot to
03:39 - uppercase of that character so here for
03:42 - example i have given small a this will
03:45 - be converted into capital a same like
03:48 - that character dot to lower case of that
03:52 - character so that is being converted
03:55 - into lower case
03:57 - so output of these two functions are
04:00 - character type
04:02 - but all other
04:03 - are boolean type
04:05 - see character dot
04:08 - is upper case so that means it is like a
04:11 - question we can just remember like that
04:14 - so it says
04:16 - whether it is uppercase or lowercase
04:19 - that means is uppercase means if it is
04:21 - true it will say true otherwise it is
04:24 - going to give false so here i have given
04:27 - is upper case of
04:28 - r so r small r which i have given the
04:31 - value is not capital letter so it gives
04:34 - false
04:35 - same like that character dot is upper
04:38 - case
04:39 - that is h i have given here it is true
04:41 - it is h is upper case so it is true same
04:44 - like that
04:46 - whether it is letter or digit also we
04:48 - can get
04:50 - character dot is letter that means it
04:53 - will give whether it is true or false so
04:56 - j i have given which is true and then if
04:59 - i give
05:00 - digit
05:01 - then the 5 is a digit so again it says
05:05 - true
05:06 - let us have an example program
05:21 - press
05:23 - wrapper
05:43 - i will create the variables needed
05:46 - in number
05:48 - and then
05:50 - character type c i create
05:53 - then boolean type
05:56 - b to give the output
05:58 - so let me have
06:01 - number
06:02 - is equal to
06:06 - integer
06:08 - dot
06:09 - parse
06:11 - in that is i with capital
06:14 - and then i give here just 23
06:18 - so the value which i have given inside
06:20 - the quotation will be a string type
06:23 - isn't it so that will be converted into
06:26 - number type which is
06:28 - integer type
06:30 - so just let me print this
06:32 - system dot out dot
06:35 - print line of
06:38 - string to number we have converted just
06:40 - for reference i am giving this
06:43 - so plus
06:45 - the variable is number
06:48 - i create a string variable
06:51 - string s
06:52 - to convert
06:54 - integer to string so i give
06:57 - integer dot 2
07:00 - string off so the value which i give may
07:02 - be
07:03 - just 45
07:05 - it get converted into string type
07:07 - so let me print this
07:10 - system dot out dot
07:12 - print line off
07:15 - here i am going to print
07:17 - number two string
07:22 - plus that is yes
07:26 - i already mentioned that is declared c
07:29 - as a character type let me give some
07:32 - value for it
07:34 - c is equal to just i give i
07:38 - so the character type always be
07:40 - mentioned inside the single
07:42 - quotation so c is equal to
07:49 - character dot
07:50 - 2
07:52 - upper
07:54 - case of
07:56 - c
07:58 - so the c is value is i
08:00 - that is going to be converted into
08:02 - capital i
08:03 - let me print after converting it
08:06 - system dot out dot
08:10 - print line of
08:16 - upper
08:17 - case of
08:20 - i
08:24 - plus that is c
08:27 - here c is value has been changed to
08:29 - uppercase of that again i just change
08:32 - the value of c here c is equal to
08:37 - c is equal to i just give capital m here
08:40 - capital m
08:42 - and then let me change this
08:45 - c is equal to
08:48 - character dot
08:50 - to lower
08:53 - case of
08:55 - c
08:57 - so let me print again just copy this
09:06 - this is lowercase
09:09 - lowercase of m i have given that
09:11 - msc
09:15 - now
09:16 - let me check whether it is
09:18 - uppercase or lowercase so we have
09:20 - already given boolean data type
09:23 - so
09:24 - b is equal to the value of c let it be
09:28 - like that
09:29 - the output value of this
09:31 - function going to be boolean type so b
09:34 - is equal to
09:36 - character dot
09:38 - is
09:40 - upper case of c
09:45 - system dot
09:47 - out dot
09:49 - print line off
09:50 - so let me just give a reference here
09:56 - whether
09:59 - m
10:01 - is
10:03 - upper case
10:07 - let's see
10:09 - same like that let me change this
10:11 - b is equal to
10:14 - character dot is
10:17 - lawyer case
10:19 - of c
10:23 - system dot out dot
10:26 - print lineup
10:29 - [Applause]
10:32 - by that
10:35 - m is
10:38 - lawyer case
10:42 - plus c
10:48 - same like that let us check whether
10:50 - digit or not
10:52 - so b is equal to
10:56 - character dot
10:58 - is
11:01 - digit
11:02 - the value that is c
11:04 - so whether m is
11:07 - digit or not it will say
11:19 - whether
11:22 - m
11:23 - is
11:26 - digital
11:32 - let us also check whether it is letter
12:04 - later
12:08 - plus
12:10 - uh we supposed to give b
12:12 - so we have changed that value right as b
12:15 - boolean
12:16 - so we supposed to give for all these
12:18 - b let us change this b
12:22 - so this is lowercase of m is going to be
12:24 - c both are c
12:26 - and these are all
12:28 - b
12:34 - okay here we have to change this
12:37 - simple let us compile this
12:40 - no syntax error
12:48 - so string to number number to string
12:51 - this value we cannot identify whether it
12:53 - is
12:54 - string or number
12:56 - in case of number we will be able to
12:58 - make operations like addition
13:00 - subtraction on string we can just
13:02 - contact
13:04 - uppercase of i is capital i
13:06 - lower case of m is
13:09 - small m
13:10 - whether m is upper case false see the
13:13 - last value it is changed already capital
13:15 - m to small m so it is given as
13:17 - false
13:18 - then where it is lower case it is true
13:20 - because we have already changed the
13:22 - value of c there
13:23 - as
13:24 - small m so that is true so whether
13:28 - m is digit it is false whether m is
13:30 - later true
13:33 - auto boxing and auto unboxing
13:40 - automatic conversion of a primitive
13:42 - value into an object of the
13:44 - corresponding wrapper class
13:46 - is referred as auto boxing
13:50 - similar way but in opposite conversion
13:53 - of an object into its corresponding
13:56 - primitive data type is referred as auto
13:59 - unboxing
14:02 - let us understand with few examples
14:07 - now i initialize a variable
14:10 - of integer data type
14:12 - called h
14:16 - value 16
14:18 - this is ordinary primitive data type
14:21 - now if i want to convert this into an
14:23 - object which is corresponding to its
14:25 - wrapper class we know now what is
14:28 - wrapper class corresponding wrapper
14:30 - classes integer i capital
14:34 - integer now i give the object name
14:39 - let me have obj h
14:41 - is equal to
14:43 - new
14:44 - integer of
14:47 - h
14:48 - so the primitive data type here it is
14:50 - getting converted into its object
14:57 - this is called boxing
15:01 - let us check by printing it
15:06 - i say here object
15:09 - just for reference
15:12 - plus
15:14 - object h obj h
15:29 - you can see
15:31 - the object is printed here
15:36 - now let me tell you what is
15:38 - auto boxing
15:41 - instead of giving the new keyword and
15:44 - then integer of age
15:46 - we directly say here as
15:49 - h
15:50 - so this statement is taken care by the
15:53 - compiler
15:55 - automatically it is being done
15:57 - so it is converted into its object
15:59 - called obj is
16:01 - of its corresponding wrapper class
16:03 - integer this is auto boxing
16:11 - let us run this also
16:17 - you can see the second time the output
16:19 - has come
16:22 - now let us understand what is
16:25 - unboxing
16:27 - unboxing is nothing but
16:29 - again converting this object
16:32 - into its ordinary primitive data type
16:35 - so let me give in
16:38 - now i use some other variable say a
16:41 - is equal to
16:44 - obj
16:45 - h
16:46 - see this is an
16:48 - object
16:49 - that object is been converted into
16:51 - ordinary data type so this is
16:54 - auto unboxing
17:02 - let me print this
17:07 - this is
17:09 - unboxing
17:16 - okay
17:24 - you could
17:26 - you could see that unboxing
17:31 - you may have a question
17:33 - what is the need of this
17:37 - as object oriented programming
17:39 - everything resides as object and class
17:44 - so even you store the primitive data
17:46 - type it is automatically converted or
17:49 - wrapped into its
17:51 - object
17:53 - you may have some situation
17:55 - in advanced programming where you need
17:58 - all the data as object
18:00 - not as primitive data
18:03 - so that is the reason why
18:06 - concept of boxing and auto unboxing is
18:09 - introduced in java
18:10 - sometimes we need to convert one data
18:13 - type into another data type
18:15 - right for example integer to string
18:18 - at that time the object only will be
18:21 - helpful
18:22 - see let us check
18:23 - i am trying to convert
18:26 - string
18:27 - str
18:28 - is equal to
18:30 - obj
18:31 - h
18:32 - dot 2 string
18:37 - okay now this will be converted as
18:40 - string
18:44 - now let me print this
18:51 - so i will be printing here string
19:04 - you could see that it is printed 16
19:07 - that is a string
19:11 - now
19:12 - if this is not an object
19:16 - okay
19:17 - so let us give a r h
19:19 - let me give h itself
19:22 - i am trying to convert this age that is
19:25 - primitive data type to string will it
19:28 - accept
19:30 - see
19:31 - that is an error
19:34 - so this is the purpose of
19:37 - having the
19:38 - object
19:39 - how we can say class as user defined
19:43 - data type
19:44 - we know java provides eight primitive
19:47 - data types these are fundamental data
19:50 - types
19:52 - java also allows to create own data
19:55 - types using primitive data types and
19:58 - these are known as composite data types
20:01 - as composite data types are defined by
20:03 - user these are also called user defined
20:07 - data types
20:08 - creating user defined data types
20:11 - sometimes
20:12 - some logically related elements needed
20:15 - to be used under a single unit
20:18 - to handle and serve to such situations
20:21 - we create own data type through classes
20:25 - for example we may need to have the
20:28 - following data of an cuboid
20:31 - it may have length breadth and height
20:34 - let us consider class called volume
20:38 - here instance variable l b and h are
20:42 - available
20:44 - here is an constructor
20:46 - without any parameter that is default
20:48 - constructor is available
20:51 - the values of i b and h are
20:54 - initialized as default values
20:58 - next one more constructor is there
21:01 - with parameter
21:03 - that is all three are integer type
21:05 - length breadth and height here l b and h
21:08 - are initialized once we create
21:12 - volume of
21:13 - that becomes a composite data type
21:16 - object of this can be declared whenever
21:19 - is needed
21:20 - there may be some more method and then
21:22 - main method also
21:24 - here another statement we can see which
21:27 - creates an object or instance called v
21:32 - and then some more statements may be
21:34 - there and then class get closed
21:37 - creating objects
21:39 - we know a class provides the blueprint
21:42 - for objects creating object has three
21:46 - parts
21:48 - first one is declaration
21:50 - declaration declares a variable with a
21:53 - name
21:54 - referring an object of the program
21:57 - and this will be left side of the
22:00 - assignment operator
22:02 - for example volume v
22:05 - here v is an object of class called
22:09 - volume
22:10 - the next one is instantiation
22:14 - right side to the assignment operator
22:16 - new
22:17 - operator
22:18 - is used to
22:20 - create object and allocate space for the
22:23 - object
22:24 - for example
22:26 - new volume of
22:28 - creating object is creating instance of
22:31 - a class
22:32 - so it is named as
22:34 - instantiating
22:36 - the third step is initialization
22:39 - new operator is followed by a
22:42 - call to a constructor
22:44 - this initializes the attributes of the
22:46 - new object
22:48 - for example
22:49 - v is equal to new volume of name of the
22:52 - class and the constructor are same here
22:55 - it is volume
22:56 - we combine this and then we write volume
22:59 - v is equal to new volume of and then we
23:01 - terminate
23:03 - let us now learn how to use this object
23:06 - to access variables and functions
23:11 - to access the variable of an object or
23:14 - to call function we can use dot operator
23:18 - that is a dot
23:22 - syntax to access variable is
23:25 - object name
23:26 - dot
23:27 - variable name and then we terminate
23:31 - example
23:32 - v is the object name and then dot l is
23:36 - the variable name we terminate this
23:41 - syntax to call the function
23:46 - object name dot
23:48 - function name and then if any parameters
23:51 - are available will be given inside the
23:54 - brackets and then we terminate
23:58 - for example
23:59 - v dot display off then we terminate
24:03 - as there is no parameter it is empty
24:06 - here
24:07 - let us learn
24:08 - how to create objects
24:11 - access variables and functions through
24:13 - the object
24:14 - using a program
24:16 - i create a class
24:19 - user defined class
24:28 - class udc
24:33 - i create class variables
24:37 - static in l comma b comma h
24:41 - and also vol
24:44 - now
24:45 - public
24:46 - wide
24:47 - value of a method i create here
24:50 - and then here i pass
24:52 - reference data type so i will be giving
24:55 - udc space
24:58 - i give rd
25:03 - so now i can initialize the variable
25:07 - using rd dot
25:10 - l is equal to
25:13 - 4
25:15 - rd dot
25:16 - b is equal to
25:19 - 3
25:20 - rd dot
25:22 - h is equal to
25:24 - 2
25:25 - then now i create one more method
25:30 - public wide
25:32 - calc
25:38 - before calculating i need the values of
25:42 - variables
25:43 - to get the variable values i will create
25:46 - the
25:47 - object and i will call the method value
25:51 - udc
25:53 - rd
25:55 - is equal to nu
25:57 - udc
25:59 - now i will
26:01 - call it
26:03 - value
26:04 - of
26:06 - rd here
26:09 - after calling i can just calculate the
26:11 - volume v yl is equal to
26:14 - length into breadth into
26:16 - height
26:18 - now i will have a method
26:24 - wide
26:27 - display off
26:29 - here i will simply print the
26:32 - volume
26:34 - system dot out dot
26:36 - print lineup
26:42 - volume of
26:44 - cuboid is equal to
26:47 - plus v yn
26:50 - now i will create a main method
26:53 - public static y main of
26:57 - string of arguments
27:02 - so again i have to create a
27:05 - object and call other two methods
27:10 - so udc
27:11 - i give obj
27:14 - is equal to new
27:16 - udc
27:17 - of
27:19 - obj dot
27:21 - calc
27:23 - obj dot
27:27 - display off
27:30 - let us compile
27:33 - no syntax header
27:35 - will run this
27:39 - so you can see volume of keyboard 24 is
27:41 - displayed
27:45 - class has user defined data type now
27:48 - a class is a collection of objects we
27:51 - already know now
27:52 - that contains a set of data items and
27:55 - related functions
27:57 - therefore we can say that a class is a
28:00 - data type that creates its object
28:04 - classes are defined by the user
28:07 - where programmer can declare certain
28:10 - characteristics and behavior
28:12 - so we can say that a class is a user
28:15 - defined data type of a composite data
28:19 - type
28:21 - let us see the difference between
28:23 - primitive and user defined data types
28:28 - primitive data types are inbuilt in java
28:32 - user defined data types are created by
28:35 - user
28:38 - primitive data types can hold single
28:40 - value
28:41 - user defined data types can hold set of
28:44 - values
28:45 - primitive data types are available in
28:48 - all parts of java program
28:50 - here the availability of user defined
28:52 - data type will be
28:54 - upon their scope
28:58 - size of primitive data types are fixed
29:02 - the size of user defined data types
29:04 - depend on their
29:06 - constituent members
29:09 - encapsulation and access specifiers
29:11 - we know two main things which are in the
29:14 - class are data members which contains
29:17 - informations
29:19 - and functions or methods
29:22 - that performs operations sometimes we
29:24 - may need to access or manipulate the
29:27 - data inside the class
29:30 - there may be unauthorized access and
29:33 - misuse also then to keep it safe from
29:36 - unauthorized access java uses mechanism
29:39 - of binding both data members and
29:42 - functions
29:43 - called encapsulation
29:46 - encapsulation ensures
29:48 - that a user cannot access the data of an
29:51 - application without using its functions
29:55 - so
29:56 - encapsulation is defined as the wrapping
29:59 - up of data under a single unit
30:02 - it is the mechanism that binds together
30:05 - code and the data it manipulates
30:07 - as per the requirement
30:09 - variables and functions of a class can
30:12 - be made to be hidden from other classes
30:16 - therefore this is also known as data
30:18 - hiding
30:19 - to remember encapsulation we can think
30:22 - of capsule where data variables and
30:25 - methods are wrapped as a class
30:28 - let us know how to achieve encapsulation
30:32 - to restrict the unauthorized access java
30:36 - has three keywords called access
30:38 - specifiers
30:41 - first one is public
30:42 - next is protected and private while
30:46 - declaring data members
30:48 - any one of these keywords
30:50 - is specified with data members or method
30:53 - prototype let us learn the access level
30:56 - of these access specifiers if public is
31:00 - given as access specifier then it is
31:03 - accessible by any class
31:05 - it may be inside the package or even
31:08 - outside the package sub class are class
31:10 - of other package
31:13 - if protected is indicated
31:15 - it may have access inside the package
31:19 - and also outside the package that
31:22 - inherit the class
31:24 - if private is given
31:26 - then it can be accessed only within the
31:30 - class
31:31 - even in the same package other class
31:33 - also won't be able to access this
31:36 - and not even by inheritors
31:40 - when we don't give any access specifier
31:43 - then it becomes public within a package
31:46 - that means it cannot be accessed outside
31:48 - the package and this is defined as
31:51 - default
31:52 - if we need an example for encapsulation
31:55 - we can consider this an employee may
31:57 - have access to his salary
32:00 - but he cannot change the cell you know
32:04 - management only can have an
32:05 - authorization to change the salary of
32:08 - that employee
32:09 - so where the method
32:11 - display is there it may have public
32:14 - access specifier so that any one of the
32:17 - employee can see the salary part
32:20 - but access to data members and function
32:24 - cannot be given as public
32:27 - it can be as private
32:29 - so that management only will have the
32:31 - authorization to change the salary of
32:34 - the templates
32:36 - i will demonstrate encapsulation
32:38 - using program which we have already done
32:41 - earlier
32:42 - i will give just few examples
32:46 - we learned
32:47 - packages in our 23rd video so
32:50 - the basic operation was a package which
32:54 - i created then here is a class which i
32:57 - called a class from this package that is
33:00 - outside of this package
33:01 - this class is available let us check
33:03 - this
33:05 - see here there are
33:07 - two classes inside this package
33:10 - one is called sum
33:13 - so here i have
33:15 - calculated sum of two variables and
33:18 - printed
33:19 - here you can see i have given public as
33:22 - the
33:23 - access specifier
33:24 - then if we see this diff
33:27 - so here also i have given public as the
33:29 - access specifier
33:31 - let us come out of this
33:34 - so here
33:36 - i have a class
33:38 - called import
33:40 - bo pack
33:41 - where i have
33:43 - called
33:45 - the sum dot main and diff dot main which
33:48 - is inside that
33:49 - basic operation package
33:51 - as some and if both are
33:54 - having public as access specifier we can
33:57 - call that outside the package so we can
33:59 - run this and check
34:06 - so sum is also given difference is also
34:08 - given here
34:11 - so here 45 plus 55 was the argument here
34:14 - 83 and 78 it gave the difference
34:17 - let us once again go to the package
34:24 - now here in the
34:25 - class called diff
34:27 - i will call
34:29 - the sub so that is
34:31 - s-u-m
34:32 - dot main was the method and then i am
34:36 - giving the
34:37 - parameter value
34:39 - for example i give 6 and
34:41 - 7.
34:43 - i will compile this
34:46 - see there is no syntax error
34:48 - because the sum was having public one
34:52 - and then this is inside the package
34:55 - let us run this
35:01 - so for difference i am giving 100
35:04 - and 150 so it will show difference as
35:07 - 50 and the sum it will go and run from
35:10 - there
35:11 - so it will
35:12 - give the result so it has given the
35:14 - result
35:15 - sum is 13.
35:17 - so we can see
35:19 - if public is given as access specifier
35:21 - it can be accessed from anywhere
35:24 - now i will change this access specifier
35:27 - this public into
35:29 - protector
35:34 - so let me compile this
35:38 - so you could see here
35:40 - error found in class
35:43 - so let us see what is the error so
35:45 - modifier protractor
35:47 - not allowed here
35:49 - so now let us
35:51 - do without this
35:52 - so that will becomes default here
35:55 - i have not specified any public or
35:58 - private or protected so compile this
36:01 - no syntax error
36:04 - so i have already in difference i have
36:06 - called it
36:09 - so it is here you can see
36:10 - that will it work or not it will work
36:13 - because it is in the same package
36:16 - so i give
36:18 - 200
36:21 - 100
36:24 - so the difference is 100 sum is
36:26 - 13.
36:31 - now let us go outside the package
36:34 - then i will run this now
36:38 - you can see here it shows a
36:40 - error because when we don't specify
36:43 - anything that becomes default it will be
36:46 - available only in the package not
36:48 - outside the package
36:51 - so let us close this
37:00 - now i will have a sub class here
37:03 - i will create
37:06 - class
37:08 - product
37:09 - extends
37:13 - sum
37:14 - so extends is a keyword which is used to
37:19 - inherit the property of the
37:21 - main class
37:22 - so i will write now
37:28 - public
37:30 - static
37:33 - wide
37:34 - try u and then i u
37:37 - into x comma in
37:40 - y
37:45 - now i will have
37:47 - s is equal to
37:49 - x into y
37:51 - so i wanted to use the variable s which
37:54 - is in the
37:56 - sum
37:57 - class
38:00 - so i will give as a class variable here
38:05 - static
38:06 - in ps
38:08 - as the functions are static i have given
38:11 - as static variable here
38:16 - so let us compile this
38:19 - so no syntax error so the variable which
38:22 - is given in the main class could be
38:25 - accessed in
38:26 - derived class
38:28 - now let us change this into private
38:33 - let us see
38:34 - which is outside the
38:37 - class
38:41 - so you can see that
38:43 - it is showing an error message
38:46 - so you can see main in command has
38:49 - private access in basic operation dot
38:52 - sum
38:53 - so we won't be able to
38:55 - access
38:56 - some here even in a same package from
38:59 - another class we won't be able to
39:02 - access it students i hope
39:04 - now it is very clear
39:06 - how this public protected and private
39:09 - access specifier works
39:12 - here public doesn't have any restriction
39:15 - the private is fully restricted it is
39:18 - available only within the class
39:22 - when we don't give anything as a access
39:24 - specifier and then only inside the
39:26 - package it acts like a public
39:29 - scope and visibility of variables
39:33 - the scope of variable refers in which
39:36 - part of program the variable can be used
39:41 - visibility of variables in a program
39:44 - depends on the type of variables we use
39:48 - so there are three types of variables
39:51 - available
39:54 - class
39:54 - variables instance variables
39:58 - and local variables that is including
40:00 - parameters
40:02 - let us see what is class variables
40:06 - variables that declared inside the class
40:09 - and outside all the blocks and also
40:12 - mentioned as static are called class
40:14 - variables
40:16 - these are visible in any part of the
40:19 - class i will explain through a simple
40:22 - program
40:25 - so i am creating a class
40:27 - called basic calc
40:39 - i will import
40:41 - java.
40:42 - util dot
40:44 - scanner
40:46 - class
40:48 - basic calc
40:52 - class variables are declared
40:54 - inside the class but outside the methods
40:57 - are any block
40:59 - it is also mentioned as static so i will
41:01 - give
41:02 - static in x comma y to numbers i take
41:07 - and then
41:08 - sum my
41:09 - calculate and then also product i
41:11 - calculate
41:13 - so now we can declare the
41:15 - method
41:18 - public
41:21 - static
41:24 - void
41:26 - input of iq
41:29 - so i will take input for x and y
41:34 - scanner sc is equal to new
41:37 - scanner of
41:39 - system dotting
41:43 - system dot out dot
41:46 - print off i say
41:50 - enter first number
41:54 - for that i take
41:57 - x is equal to
41:59 - sc dot
42:01 - next in tough
42:04 - then again i need to take the second
42:06 - number
42:08 - we copy and paste it here
42:10 - i make it this is
42:12 - y and then this is second number
42:17 - so now we have taken the input
42:20 - let me create one more method
42:22 - called calcaf are some we will do
42:26 - wide
42:27 - sum of
42:30 - so here simply i create
42:32 - sum of two numbers
42:35 - s is equal to x plus y so now i wanted
42:38 - to print this
42:51 - now i will create one more method
42:56 - white
42:58 - pro of
43:04 - so now i give p is equal to
43:06 - x into y
43:09 - then i also
43:10 - print this
43:14 - so i am giving here
43:16 - product
43:20 - then here it has
43:22 - p
43:24 - now i will create a main method
43:37 - i wanted to call all the methods for
43:40 - that i need to create a
43:42 - object
43:43 - the class name is
43:46 - basic
43:47 - calc
43:49 - obj i give as a object name is equal to
43:52 - new
43:58 - basic calculus
44:00 - then now
44:01 - the object name that is obj
44:04 - dot
44:06 - input of
44:08 - then
44:09 - obj dot
44:12 - sum of
44:14 - obj dot
44:16 - pro f
44:19 - so let me compile this
44:27 - enter first number 87
44:30 - 23
44:33 - so you can see the result is there
44:40 - so now it is clear that when we give as
44:42 - a class variable it can be in any part
44:45 - of the
44:47 - program so x is there in this method
44:50 - and y also there
44:52 - this s is in
44:55 - sum method p is in some other method
44:58 - so here you can see this is a static
45:00 - method
45:02 - these two are not static method again
45:04 - here main method is static method
45:09 - so let us read once again
45:12 - variables that declared inside the class
45:15 - and outside all the blocks
45:17 - and also mentioned as static
45:19 - so all this we have done
45:22 - then it is visible any part of the
45:24 - program
45:27 - next
45:28 - instance variable
45:30 - variables that declared inside a class
45:33 - and outside all the methods and blocks
45:36 - is called as an
45:37 - instance variable
45:39 - so here the difference is
45:41 - we are not giving us static
45:46 - scope of an instance variable is
45:48 - throughout the class except in static
45:50 - methods
45:52 - so let us see this
45:56 - so now i have static here i just remove
45:59 - this study here
46:03 - let me compile
46:06 - so you can see
46:07 - errors found in the class
46:10 - let us see what and all the error
46:13 - so non-static variable x cannot be
46:15 - referenced from a static context
46:21 - the next one again
46:23 - y also the same way
46:25 - here s is there
46:27 - this is
46:28 - in the
46:30 - non-static method so it can allow
46:33 - same like that the p also can be allowed
46:36 - in this
46:37 - method which is non-static
46:40 - method
46:42 - so here we are not using any variables
46:45 - directly we have printed here itself
46:52 - so if we remove this static from this
46:55 - method
46:57 - then we can
46:58 - compile this no syntax error
47:01 - so now this will run without a problem
47:05 - so let us run this one
47:11 - first number
47:15 - then second number
47:18 - so we get the result here
47:26 - so the variable which is inside the
47:28 - class
47:29 - but outside the blocks
47:31 - without static
47:33 - then it is called instance variable
47:37 - next one
47:38 - local variables
47:41 - all other variables which are not
47:43 - instance and class variables are treated
47:46 - as local variables
47:48 - including the parameters
47:51 - of a local variable is until the control
47:55 - leaves the block in which it is declared
47:57 - if we declare a variable inside the
47:59 - method it will not be available in other
48:02 - methods if there are some blocks
48:05 - inside the block if we
48:07 - declare
48:08 - then interior blocks are not visible
48:11 - outside
48:13 - if we have variable outside the blocks
48:16 - the interior blocks can have the
48:18 - variable
48:19 - so let us go back to the program
48:22 - now what i do i remove this
48:25 - x and y from here
48:31 - then i make it inside this method
48:35 - in x comma y
48:38 - see here it is inside
48:41 - this input off
48:44 - so you can see here
48:46 - there is no error in this block
48:48 - so here already it is showing as an
48:50 - error here
48:53 - because x and y
48:55 - is outside this method so that is in
48:57 - another method cannot find symbol
49:00 - variable y even cannot find symbol
49:03 - variable x
49:05 - even here in the next method also we
49:08 - won't be able to
49:10 - get the variable
49:12 - so whenever we use many methods
49:14 - where we are using common variables then
49:17 - it should be
49:18 - static
49:19 - variable that is a class variable inside
49:22 - the class
49:23 - but before all the methods itself we
49:25 - will declare so that will be the
49:27 - best
49:28 - one in case if we have these two
49:32 - in input itself so i will
49:35 - cancel this
49:36 - method itself i delete the method and
49:39 - then put it inside this
49:41 - here s is equal to x plus y also been
49:43 - calculated here itself it is printed so
49:46 - there won't be any problem
49:48 - because
49:49 - s and p are
49:51 - instance variable here
49:53 - it can be allowed inside this
49:55 - input of and then x and y are local
49:58 - variables
50:01 - so let us have this as
50:05 - a comment line i just hide this
50:12 - so now compile
50:14 - there won't be any problem it will print
50:15 - it will print the
50:17 - sum of that number
50:23 - so first number is 5 second number is 10
50:26 - so 15
50:28 - is the answer here
50:34 - now i will show how it works inside the
50:37 - blocks and outside the blocks
50:39 - for that
50:41 - in this method itself i create a for
50:43 - loop
50:45 - for
50:48 - i say
50:50 - x is equal to 5
50:52 - when x is lesser than or equal to 10
50:57 - x plus plus
51:01 - now simply i print x
51:15 - x so that is in print line next next
51:17 - line it will print
51:19 - we have already declared x inside the
51:22 - method
51:23 - so
51:24 - it is taking for this for loop now
51:27 - compile this there won't be any syntax
51:29 - error
51:31 - in case i declare here
51:33 - one more
51:36 - into m
51:39 - then m is equal to
51:41 - m plus 1
51:46 - so i will have ms 25 just for example
51:51 - see i come out of this for loop and i
51:53 - say
51:56 - system dot out dot
51:58 - print line of iqm
52:03 - see inner loop i have declared m
52:06 - it is outside the loop so here
52:10 - it will not work so interior variables
52:13 - will not work outside the block of the
52:16 - code compile so cannot find symbol
52:19 - variable m
52:21 - but at the same time
52:23 - x is in the method
52:25 - it is used
52:26 - inside that
52:27 - for loop so that is inner block so it is
52:30 - available here
52:32 - so now let us see as a parameter
52:35 - so here i will not have this import
52:38 - statement
52:41 - then i will not have all these
52:47 - into x
52:49 - comma
52:50 - into y
52:52 - so i have given s is equal to x plus y
52:55 - so let us not have this for loop and all
52:59 - so this is a very simple one
53:01 - s is equal to x plus y
53:03 - will be done without any error no error
53:06 - here
53:08 - so let us have this now
53:11 - so i delete
53:12 - this then i remove this also
53:16 - so x and y are parameter here
53:20 - it is the next method which is
53:24 - called this x and y see here you can see
53:26 - cannot find symbol variable y
53:30 - so the parameter also a local variable
53:33 - only
53:35 - all other variables which are not
53:36 - instance and class variables are treated
53:39 - as
53:40 - local variables including parameters
53:44 - scope of a variable
53:45 - is until the control leaves the block in
53:48 - which it is declared
53:51 - variables declared in interior blocks
53:54 - are not visible outside of that block
53:57 - variables declared in exterior blocks
54:00 - are visible to the interior blocks
54:07 - string handling
54:08 - let us now see string class
54:12 - creating string
54:13 - a string is a reference data type so the
54:16 - variable yes i have taken
54:18 - string s is equal to keyboard inside the
54:20 - double quotation and i terminate
54:23 - so this is the way of initializing the
54:25 - string variable
54:28 - string object
54:31 - string str here str is the object name
54:34 - that is a valid identifier can be
54:36 - anything equal to new keyword we use and
54:39 - then string of mouse i have given inside
54:41 - the double quotation where the mouse is
54:43 - stored in the
54:44 - string object called str next
54:49 - string buffer class
54:51 - creating string buffer object string
54:53 - buffer sb1 is equal to new string buffer
54:56 - off here sb1 string buffer object has
54:59 - been created nothing be stored in this
55:02 - next
55:03 - string buffer sb2 is equal to new string
55:06 - buffer of joystick i have given in the
55:08 - double quotation
55:09 - where in the sb2
55:11 - object joystick has been stored
55:14 - the third way
55:16 - sb3 is equal to new string buffer of 20.
55:19 - here
55:20 - 20 is the integer number it creates a
55:23 - object where it can store 20 characters
55:26 - in java there are many functions for the
55:29 - string let us see one by one
55:32 - the function here
55:33 - length of
55:35 - so what will be the output data type
55:37 - always it will be integer the length
55:39 - says how many characters are available
55:42 - in the string including the special
55:44 - character r space
55:47 - so here output data type is in
55:51 - for example i have given here key chain
55:53 - there is a space between key and chain
55:56 - which is in the double quotation dot
55:58 - length of
56:00 - so here it will count all the
56:02 - characters available in it three four
56:05 - five six seven eight nine so nine will
56:07 - be the output
56:09 - next to upper case of
56:12 - here the output data type will be string
56:15 - only
56:16 - the function example here
56:19 - drive dot to upper case of see here d is
56:22 - already there capital
56:24 - r i v is in small letter so which are
56:26 - all in small going to be converted into
56:29 - upper case so then the output will be
56:31 - drive in all in capital letters
56:34 - next to lower case of
56:37 - the output of this also be string type
56:40 - for example
56:42 - i have taken monitor here to lower case
56:45 - off
56:46 - it will be giving this monitor in the
56:49 - lower case
56:50 - the next one
56:52 - replace of
56:53 - old character dot new character that
56:55 - means we are going to give a character
56:58 - which is available in the string and
56:59 - then we are going to change into the new
57:01 - character which we want to replace
57:05 - so again the output data type will be
57:07 - string itself
57:08 - here for example i have given store dot
57:12 - replace o comma a see o is a letter here
57:16 - that is a character so it is been in
57:19 - single quotation same like that a is
57:21 - also given in the single quotation
57:24 - so the output will be o is been replaced
57:27 - with a so it will be star
57:31 - next trim off
57:33 - here
57:34 - the output data type again is string
57:36 - type
57:38 - for example i have given some space i
57:41 - love
57:42 - java then again some more space
57:45 - what it does it will cut all the extra
57:48 - spaces before and after the string so
57:52 - that means
57:53 - it starts from i and then it ends with a
57:56 - the extra space before and after the
57:59 - string going to be
58:00 - trimmed
58:02 - next concat off
58:04 - concat is going to be string type output
58:08 - here for example
58:10 - key which is given inside the double
58:11 - quotation that is first string and then
58:14 - concat
58:15 - of
58:16 - board i have given again
58:18 - in the double quotation
58:20 - here these two are going to be added
58:23 - together which is going to display
58:26 - nearby
58:27 - so keyboard will be the
58:29 - output
58:31 - then value of
58:33 - so this is also going to be string type
58:36 - the function here example string dot
58:39 - value of 32 so 32 is a
58:43 - integer number here
58:45 - please note that o is capital value all
58:48 - in small and then o is capital f is in
58:50 - small letter so the integer value going
58:54 - to be converted into string value that
58:56 - is just 3 2 as the
58:59 - object here there are many string
59:01 - functions
59:02 - in this class we will see only this much
59:04 - we will continue that in the next class
59:07 - now i will demonstrate all these string
59:10 - functions through a java program
59:14 - string str is equal
59:16 - to i just give here mirror
59:23 - ah let me take a length of this
59:26 - so i need a variable integer variable so
59:29 - that is in l is equal to
59:31 - str dot
59:34 - length of
59:36 - so let me print this
59:51 - plus l
59:54 - sorry here
59:57 - now let me also
59:59 - convert into upper case
60:03 - so i can store this
60:05 - in the new variable after converting
60:07 - into
60:08 - upper case otherwise directly i can
60:09 - print
60:10 - so let me
60:12 - assign to a new variable
60:15 - string str 2iq
60:17 - is equal to
60:19 - str dot
60:21 - 2
60:22 - u is in capital
60:24 - upper and then case c is in
60:26 - capital so
60:29 - now str2 becomes upper case of mirror
60:32 - let me print this also
60:45 - in upper case this just for reference i
60:47 - am giving
60:48 - so that is str
60:50 - to after converting into upper case it
60:52 - is going to print
60:54 - let me convert
60:55 - one more
60:56 - string into lower case
60:58 - system dot
61:00 - out dot
61:02 - print line up
61:03 - i am just giving here
61:07 - this is
61:08 - my book
61:13 - dot
61:14 - to lower case of
61:16 - l should be capital
61:18 - then c should be capital lowercase of so
61:22 - now this is going to convert this is my
61:24 - book into
61:25 - lower cases here this is
61:28 - in small all other things are in capital
61:31 - so let us
61:32 - compile
61:34 - then
61:35 - run this
61:38 - so you can see here length of the string
61:40 - is 6 in upper case so mirror became in
61:43 - uppercase this is my book so this has
61:46 - already in the small letters all others
61:49 - were in big letters so it has been
61:50 - converted into small letters
61:52 - the next we are going to see here is
61:57 - replace of
61:59 - so let us replace any of the string with
62:01 - the
62:02 - other letter
62:04 - what i will do here
62:07 - system dot out dot
62:10 - print line off
62:12 - i will give here
62:14 - snow
62:16 - snow
62:17 - dot
62:18 - replace
62:20 - of a old character to be given here
62:24 - yes i change this
62:25 - here in single quote yes
62:28 - and then comma
62:30 - instead of that i change it to
62:32 - k
62:33 - so capital k
62:35 - so now the s letter has been changed
62:37 - into k
62:38 - so it is going to be printed we don't
62:40 - need all these things let me remove this
62:46 - so compile this
62:51 - so you can see that
62:53 - s n o w become k and o w
62:59 - so let us learn about
63:00 - trim function now i will give here
63:04 - string str is equal to
63:07 - with some space i give snow
63:14 - now
63:16 - system dot out dot
63:19 - printline off
63:23 - i am going to print str
63:27 - next
63:28 - let me take
63:32 - this without
63:33 - space that is trimming it
63:37 - i'll paste that same here
63:40 - then i here i give dot
63:43 - trim off
63:45 - so what it will do first it is going to
63:46 - print the original
63:49 - string here with the space and the next
63:51 - it is going to print after trimming it
63:54 - if i give space after this we cannot
63:56 - understand but we can understand whether
63:58 - there is space previous to the string or
64:01 - not
64:02 - let us compile this
64:09 - so you can see that the extra space here
64:11 - has been cut
64:17 - let us give
64:18 - a lengthy string
64:22 - snow is cool
64:28 - so it is going to cut only the space
64:31 - after
64:32 - and before not
64:34 - which is in between so in between
64:36 - whatever is there it is going to stay
64:37 - like that
64:42 - next let us see the concat function i
64:44 - will add one more
64:46 - string with the
64:47 - str
64:49 - so let me do like this
64:51 - system dot out dot
64:54 - print line of
64:57 - str
64:59 - dot
65:01 - concat
65:03 - with
65:04 - if we
65:06 - take
65:07 - it
65:08 - in the hand
65:11 - let me cut this
65:12 - i'll take this also so with this str1 it
65:15 - is going to add if we take it in the
65:18 - hand
65:22 - compile this
65:28 - so snow is cool if we take it in the
65:30 - hand
65:31 - it is
65:32 - displayed together
65:36 - now let us learn
65:38 - value of function let me take
65:41 - in
65:41 - n is equal to
65:43 - 45
65:45 - so let me print this
65:48 - system dot out dot
65:50 - print line off
65:53 - after converting into string so that is
65:57 - string dot
65:59 - value of
66:02 - that is n now this is going to be
66:04 - converted into string value it is not
66:07 - going to be integer value how we can
66:09 - know this
66:10 - after converting this
66:12 - we won't be able to add any number with
66:14 - this for example i add
66:17 - just 10 with this if it is a number then
66:20 - it is going to be 55 if it has been
66:22 - converted into
66:24 - string 10 is going to appear nearby
66:27 - let us
66:28 - compile and check
66:33 - see here it has been converted into
66:35 - string so it has been
66:37 - displayed and the nearby 10 is been
66:39 - displayed
66:40 - index number of a string each character
66:43 - in a string will have its index number
66:46 - so here i have given exhibition e is
66:49 - having
66:50 - 0 as index number so always the index
66:54 - number starts with 0 and then it will
66:57 - keep on continuing until the last
67:00 - character so here last character we have
67:03 - 9 as the index number if we see the
67:05 - length of this is going to be 10 so the
67:09 - last index of the character is going to
67:12 - be one lesser than the total length of
67:15 - the string
67:17 - so we can say index of last character is
67:20 - equal to length of string minus 1
67:23 - in case if we see the position of the
67:26 - character it is going to be
67:28 - one
67:29 - more than the index number
67:32 - so that is for example if we take this b
67:35 - here
67:36 - one two three four five so this is the
67:39 - fifth
67:40 - character in the string but it will have
67:44 - four as index so if we wanted to know
67:46 - the position what we do we can add one
67:50 - with the index so position of the
67:52 - character is equal to index of the
67:54 - character plus 1
67:58 - here we have index off so it is going to
68:02 - give the index of particular character
68:05 - output will be
68:07 - integer type
68:08 - for example i have application dot index
68:11 - of p so it is going to give the index of
68:14 - p so that is the first occurrence of p
68:16 - it is going to be displayed
68:19 - so it will be 1 so that is 0 and then 1
68:22 - next we have last inductor so here again
68:25 - the index is going to be
68:28 - integer data type
68:29 - then same application we say
68:32 - application dot last index of p
68:35 - here the last occurrence of p is going
68:38 - to be taken so it is going to be this p
68:41 - so that is 0 1 2 so 2 is going to be the
68:45 - output next we are having character
68:48 - so we will give the index number output
68:52 - is going to be
68:53 - character type
68:55 - so for example i have computer dot
68:58 - character at 6 so the index which we are
69:00 - going to
69:02 - give is inside the bracket here
69:04 - so it will take the character at index 6
69:08 - so 0 1 2 3
69:11 - 4 5 6 so e is going to be the output
69:15 - next we have ends with so it is going to
69:18 - check whether the string ends with the
69:21 - particular
69:23 - string
69:24 - so output data type is going to be
69:28 - true or false so that is boolean
69:32 - so phone dot ends with o
69:35 - so it is going to be false
69:37 - next i have starts with
69:40 - so again it is going to say whether it
69:42 - is true or not so again boolean data
69:44 - type
69:45 - cell dot starts with c which is given
69:48 - inside the quotation here so it is true
69:51 - c is right one
69:53 - so next we are having equals
69:56 - this will check whether
69:59 - given strings two strings are equal or
70:02 - not
70:03 - and then give the output as true or
70:05 - false so again it is going to be boolean
70:08 - data type
70:09 - so here we give first string here dot
70:12 - equals of the second string inside the
70:15 - bracket
70:17 - so it is false because pin is not equal
70:20 - to capital pen here next we have equals
70:23 - ignore case of
70:25 - it is going to check whether both the
70:27 - strings given are equal or not by
70:29 - ignoring the case whether it is in upper
70:32 - case or lower case it is going to ignore
70:36 - so it is
70:37 - boolean type again
70:38 - pin dot equals ignore case of pin so
70:42 - both are equal
70:44 - if you ignore the case so it is going to
70:46 - be true
70:48 - we have
70:49 - few more functions
70:52 - we will see that in the next class let
70:55 - us know how to run all these using a
70:58 - program
70:59 - i will create the class
71:10 - i will copy the codes from the previous
71:12 - one
71:14 - let me copy all these codes
71:22 - then change the
71:23 - name of the
71:24 - class
71:27 - instead of number we are going to have a
71:30 - string
71:31 - enter a
71:32 - string
71:35 - so string
71:37 - str is equal to
71:39 - br dot
71:41 - field line off
71:43 - we are going to get the index of a
71:45 - letter
71:46 - so we need integer variable
71:50 - in i is equal to
71:52 - so here string variable str dot
71:56 - index
71:57 - off
71:59 - so let us give just
72:01 - letter
72:03 - o
72:08 - let us print this
72:09 - [Applause]
72:25 - right
72:27 - let us close the
72:28 - method close the class
72:31 - compile this
72:32 - no syntax error
72:35 - let us run this
72:38 - so i say here
72:41 - book
72:43 - so index of o that is first occurrence
72:45 - of o so it is going to be 1
72:47 - 0 and
72:48 - 1. let us check the last index
72:53 - so let us copy again the same code
72:57 - then modify this
73:01 - i am going to have here
73:03 - last index
73:04 - so
73:05 - last index
73:07 - of
73:08 - o
73:09 - so let me change here last index
73:13 - last index of letter o
73:17 - it is going to be
73:19 - digitally
73:21 - last index
73:22 - then we are going to print also last
73:24 - index
73:34 - i'll give computer
73:37 - application
73:41 - so you can see index of voice one
73:44 - from the beginning the last index of o
73:46 - is 18.
73:51 - now let us delete all this
73:55 - we will see character function for that
73:58 - we need character data type output
74:00 - so
74:02 - character c is equal to
74:05 - str dot
74:08 - character at
74:09 - maybe just i am giving
74:12 - 6. so it is going to give the character
74:17 - at index 6
74:19 - let us print this
74:22 - [Applause]
74:49 - so character at index six is e
74:56 - next we will see starts with and ends
74:58 - with so for that we need boolean data
75:00 - type
75:01 - so we will change here
75:04 - boolean
75:05 - for starts with siu
75:08 - s is equal to str dot
75:12 - starts
75:13 - w is in capital
75:15 - with
75:16 - so we are giving here
75:18 - inside the
75:19 - double quotation so i just give here
75:23 - a
75:26 - and then
75:28 - boolean ends with
75:31 - str dot
75:33 - ends
75:38 - let me give
75:40 - r
75:42 - so let me change this
75:58 - yes
75:59 - and then
76:00 - same we will just copy here
76:03 - whether ends with
76:08 - then whether it is with r
76:10 - then this is e
76:14 - compile this
76:20 - i say number
76:23 - so whether it starts with a false
76:25 - whether it ends with r it is true
76:31 - here not only a single character we can
76:34 - give a word also or
76:37 - a string we can give if the same string
76:40 - occurs then it will say whether it
76:42 - starts whether it ends for example let
76:45 - me give here function
76:51 - here
76:52 - i give java
76:55 - so let us change here also
77:00 - and here java
77:04 - compile this
77:12 - and your string function
77:16 - [Applause]
77:20 - so you can see
77:21 - starts with
77:22 - function false but ends with
77:25 - java it is
77:28 - true next we are going to learn
77:33 - equals and
77:34 - equals ignore casa so i will copy this
77:37 - again
77:40 - let me have
77:42 - here another string
77:46 - so here str1
77:50 - now i have taken two
77:53 - string type
77:54 - let me check
77:57 - booed in
77:58 - check is equal to
78:01 - str
78:02 - dot
78:03 - equals off
78:06 - i'm giving here
78:08 - str1
78:10 - the next boolean
78:14 - checks
78:15 - ignoring
78:16 - case
78:20 - str dot
78:27 - ignore
78:28 - case of
78:31 - this str1
78:33 - so now it is going to check whether str1
78:36 - whatever we have given
78:38 - whether it is equal to the next string
78:40 - which is
78:41 - given by the user same like that after
78:45 - ignoring the case it is going to check
78:48 - let us print the result
79:12 - so let me copy this and change for
79:14 - ignore case
79:18 - whether both the strings are equal
79:25 - that is check
79:27 - i see
79:32 - no syntax error
79:36 - enter the string
79:40 - pencil
79:42 - another string
79:45 - pin in small
79:47 - then
79:48 - c
79:49 - c i l in capital
79:54 - so whether both the strings are equal
79:56 - false
79:57 - whether both the strings are equal after
79:59 - ignoring the case it is true so it
80:02 - ignored whether
80:03 - capital r in small
80:07 - sub string and compare to functions we
80:10 - are going to see substring will accept
80:13 - two integer arguments or a single
80:16 - integer argument integer value they are
80:19 - given is the index number
80:22 - here it accepts one single integer value
80:25 - that is index number of the character
80:28 - present in the string
80:30 - this is taken as starting index and the
80:33 - remaining all the index
80:35 - characters will get displayed
80:37 - so the output data type will be string
80:40 - type
80:41 - for example we have
80:43 - cupboard dot substring of 3
80:46 - here we have
80:48 - 0
80:49 - 1
80:50 - 2 and then 3 is the argument given so
80:54 - from starting
80:56 - 3 that is b
80:57 - remaining everything it is going to be
81:00 - taken so output here will be board
81:05 - next we have here
81:07 - two integer argument that is two index
81:10 - number this is a starting index number
81:12 - and this is ending index number
81:14 - so again output type is going to be
81:16 - string type for example if we take
81:19 - cupboard dot substring of 0 comma 3 so
81:23 - the starting is 0 so
81:25 - the 3 is
81:27 - not included in the output so it is
81:29 - going to take 0 1 and 2 so it will have
81:33 - 0 c u
81:36 - p p is 2 b that is 3 is excluded here
81:41 - so you will have output as cup
81:46 - first let us check this through a
81:48 - program and then we will learn compare
81:51 - to function
81:54 - these codes already you know i have
81:56 - taken input from the user the variable
81:59 - name given to the string is s1 so i am
82:02 - going to take the output i give string
82:07 - s2
82:08 - is equal to so the string value that is
82:11 - s1 given by the user
82:13 - dot
82:15 - substring of
82:17 - the value i give for
82:19 - example i give 5
82:21 - then i terminate so i will print this
82:45 - so that is s2
82:47 - now let us consider
82:50 - string s3
82:51 - is equal to
82:53 - s1
82:54 - dot
82:56 - substring of
82:59 - 6 comma
83:00 - 9
83:03 - so let me print this again
83:13 - 6 and
83:15 - till 9
83:17 - is s3 is the answer
83:24 - so i give here dictionary
83:28 - so what is going to be the output
83:32 - we have given substring as 5 here so
83:36 - 0 1 2 3 4 5 so the fifth index starts
83:41 - from
83:42 - o so o n a r y is going to be the first
83:47 - output and the next output going to be 6
83:50 - to 9
83:51 - so
83:52 - it is going to be
83:54 - n a r so y is 9 that is excluded
84:07 - before learning comparative let us learn
84:09 - about
84:11 - ascii code of characters
84:13 - compare to function
84:15 - going to
84:16 - compare two strings using ascii value of
84:20 - the character so here we have the ascii
84:23 - value of each character
84:26 - from zero to nine
84:29 - 48 is the ascii value for 149 and then
84:33 - so on so for 9 it is 57
84:37 - then for capital a it starts from 65 66
84:42 - 67 like that and then up to z it is 90
84:46 - same like that a small letter
84:49 - a
84:50 - has 97 as its value and then z has 122
84:55 - as its value compared to function going
84:59 - to compare
85:00 - two strings
85:01 - lexicographically
85:03 - that means as in the dictionary it is
85:06 - going to compare
85:09 - so here we have compared to
85:11 - t is in capital here
85:14 - the output is going to be integer type
85:16 - after comparing this function not only
85:20 - compares lexicographically
85:22 - but also compares the length of the
85:24 - string i will explain with some examples
85:31 - here we use the first string
85:34 - dot compared to the second string inside
85:37 - the bracket
85:40 - example i have
85:42 - mouse is the first string value dot
85:46 - compared to the second string value here
85:49 - as book
85:51 - here see the first letter of
85:55 - this is m
85:56 - and
85:57 - the first letter
85:59 - is b here so the ascii value of m
86:02 - is 109 and ascii value of b is 98 so the
86:08 - difference between this going to be
86:11 - given so that is 109 minus
86:14 - 98 is going to be 11.
86:18 - in case here it is book and here it is
86:21 - mouse it is going to do 98 minus
86:25 - 109 so that is going to be minus 11
86:29 - the next example here
86:33 - i have
86:34 - money bag and then money pass
86:39 - so as per the dictionary
86:41 - money until that both are same
86:43 - so b here it starts a different letter
86:46 - here it is p is different letter so it
86:49 - is going to consider the ascii value of
86:51 - b
86:52 - minus ascii value of p
86:55 - so here b has 98 as its value
86:58 - p has 112 as its value so 98 minus 112
87:04 - is minus 14
87:08 - next here i have
87:11 - pencil dot compared to pin so it is
87:14 - going to compare these two see here pin
87:18 - is already there in the pencil later
87:20 - whatever the character is available in
87:22 - pencil is not there here it is going to
87:25 - compare
87:26 - the length so that is pencils
87:30 - length is
87:31 - 6 and the pin
87:33 - length is 3 so 6 minus 3 it is going to
87:36 - be 3 is the output
87:40 - next i have here
87:43 - record compare to record so both are
87:46 - same the output is going to be
87:49 - zero
87:52 - let us do all this through a program
87:56 - let me delete all these
88:01 - so here i will change as
88:03 - user input
88:05 - that is br
88:06 - dot
88:08 - read line off
88:10 - so here i have two inputs before this i
88:13 - will prompt
88:19 - so enter another string
88:22 - another string so
88:24 - user gives s 1 s 1 string and s 2 s
88:27 - other string i am just comparing
88:28 - directly i give in the printing
88:30 - statement
88:47 - so that is i am giving here
88:51 - s 1 dot
88:54 - compared to
88:56 - that is s2
88:59 - let us compile this
89:01 - no syntax error
89:07 - as we have seen in the example i give
89:09 - mouse
89:11 - then book
89:14 - so 11 was the answer there you got this
89:19 - next let me give the
89:21 - other type of input
89:23 - let me give money back
89:27 - then money purse
89:31 - so you can see minus 14 as we have seen
89:34 - in the example
89:37 - so now i give
89:39 - pencil
89:42 - and then pin so it is length now
89:45 - 6 minus 3 is 3
89:49 - next let us give the
89:51 - same input
89:54 - for example
89:55 - mouse
89:57 - mouse so it is 0
90:01 - so here
90:02 - i have
90:03 - c80 compared to a and t so
90:06 - it is totally different the first letter
90:09 - it is going to be
90:11 - c and then
90:12 - here a
90:14 - the difference going to be these 2 is 2
90:17 - the next one here
90:19 - cell phone dot
90:21 - compare to cell pouch
90:28 - cr minus 7 is answer
90:31 - so until cel p
90:33 - it is same and then here h and here o is
90:37 - compared so here h is having smaller
90:39 - value o is having bigger value so it is
90:43 - in minus value
90:48 - so minus seven and then here i am
90:50 - comparing pencil and pin we have already
90:52 - seen
90:53 - so it is three and then here block and
90:56 - block so both are same it is going to be
90:59 - zero
91:00 - how to apply these string functions in a
91:03 - program
91:04 - we will learn how to reverse a word and
91:07 - we will check whether the given word is
91:10 - palindrome or not palindrome word is a
91:13 - word that does not change even if we
91:16 - read in reverse also
91:18 - next we will see how to reverse a
91:21 - sentence before going to a program let
91:24 - us learn the technique of reversing a
91:27 - word
91:29 - different people will have different
91:31 - level of thinking skills
91:34 - you may think differently than i think
91:38 - so here i am explaining two ways to
91:41 - reverse a string
91:44 - here i have a string called photo which
91:48 - is stored in variable called s1
91:51 - so if i wanted to
91:53 - reverse it i should take character by
91:55 - character and then i should add it in
91:58 - reverse order
92:00 - for that we have to extract each
92:02 - character we already know the index
92:05 - number of
92:06 - strings
92:08 - so that is
92:10 - p will have 0 h will have 1 o2 and then
92:13 - at last it is going to be 4
92:16 - to extract each character and put it in
92:19 - reverse order i use loop that is for
92:22 - loop
92:24 - so here this i is for index so index
92:28 - starts from 0 so i initialized as 0 and
92:32 - then it is going to end when it is
92:35 - lesser than the length so the length
92:37 - will be 5 lesser than length that is
92:40 - length minus 1 so instead of that i used
92:44 - lesser than so it is not going to take 5
92:47 - but it will take up to 4 which is lesser
92:49 - than 5 and then it is in ascending order
92:53 - so i have used i plus plus
92:56 - every time i want to take one letter and
92:59 - then put it in reverse order and then i
93:02 - have to store that in a new string for
93:05 - that i need one more string i already
93:08 - initialized as s2 here
93:13 - so here i have s2 is equal to character
93:17 - i plus s2 initially s2 is not having any
93:21 - value here so character at i in the
93:24 - beginning when i is equal to 0
93:26 - it will be
93:28 - p
93:29 - so p plus
93:31 - no value so that s 2 is added here and
93:34 - then you are getting the result as s to
93:37 - sp and then when i value increased to 1
93:42 - s 2 will have character at i that is h
93:45 - here so h plus p
93:49 - then when i is equal to 2
93:52 - the character we are going to take is o
93:54 - and then o plus hp so it becomes ohp so
93:59 - like that it is going to reverse one by
94:02 - one until i is equal to four at last it
94:06 - becomes o plus t o h p so that is in
94:09 - reverse p h o t o it is reversed now
94:13 - when i is five then it becomes false
94:16 - then it stops this is one method the
94:19 - other method is
94:20 - using for loop in reverse order what i
94:24 - do here i i initialize as length minus 1
94:28 - so that is 5 minus 1 will be 4 initially
94:31 - it starts from 4 and then what i do
94:34 - until
94:35 - greater than or equal to 0 so i go in
94:39 - reverse order so it is i minus minus
94:42 - first it takes s2 which is nothing plus
94:45 - character at i so that is character at 4
94:48 - it is going to take and then it is going
94:51 - to add with s2
94:53 - so you will have
94:55 - s2s0
94:56 - and then
94:58 - when i is 3
95:00 - it is going to take
95:02 - t
95:02 - so already s 2's values
95:05 - o plus t
95:07 - it becomes o 1 t
95:09 - when i is 2
95:11 - then s 2 is ot plus
95:14 - o
95:15 - it becomes
95:17 - oto then i is equal to one it becomes
95:20 - oto plus h then i is equal to zero
95:24 - s2 is equal to oto h plus p so this is
95:29 - also
95:30 - reversed you can use any one of these
95:33 - method to reverse a word
95:36 - so here when you go in ascending order
95:39 - you will be using character i plus s2 so
95:43 - you are adding the characters before s2
95:46 - in case you are going
95:48 - backwards that is from the last you are
95:51 - coming you will have length minus 1 and
95:54 - then you will add that character type
95:57 - after s2 these are main difference
96:00 - between these two but however the answer
96:03 - is same
96:05 - let us go to a program and execute this
96:10 - these codes i have readmedly copied to
96:14 - take the input from the user so now i
96:17 - have to give
96:19 - new string variable
96:24 - with the value
96:28 - nothing in it
96:30 - now i will have for loop
96:46 - i have used here first method
96:49 - the new string
96:50 - s2 is equal to
96:55 - dot
96:57 - character at
96:59 - i
97:01 - plus
97:02 - s2
97:04 - so this loop will reverse the word just
97:07 - after
97:08 - completing the loop we will print this
97:27 - plus
97:28 - s2
97:30 - so close the
97:31 - method close the class compile this
97:41 - so i give here laptop
97:45 - so you can see
97:47 - l a p t o p it is in reverse order
97:57 - if
97:58 - s 1 and s 2
98:00 - are equal then we say
98:03 - palindrome word so we don't need to
98:06 - print this
98:07 - let us simply check this if
98:12 - s1
98:13 - dot
98:15 - equals
98:17 - ignore
98:18 - case of
98:20 - s2
98:22 - see if we don't give this equals ignore
98:25 - case of then if the user gives a mixed
98:28 - characters
98:30 - with uppercase and lowercase then java
98:33 - will not show as palindrome though it is
98:35 - paren wrong word this is boolean type so
98:39 - we are checking whether it is true or
98:41 - not
98:43 - if this is true we say
98:58 - this is palindrome otherwise we can say
99:01 - here
99:03 - yes one
99:05 - plus is palindrome else
99:08 - we will say not a palindrome
99:24 - so i give here
99:26 - 11
99:27 - l e v e l
99:29 - so your level is a parent rule
99:33 - in case if we give
99:36 - l e v l uppercase first letter
99:40 - then also it will say level is parent
99:43 - rom because we ignore the case while
99:45 - checking
99:46 - if we don't give this
99:48 - see let us
99:50 - cancel this equals
99:55 - so now it is only equals
99:57 - compile this
100:02 - i give here madam
100:03 - m-a-d-a-m see i mixed m is capital all
100:07 - others are small
100:08 - so madam is not a palindrome so to avoid
100:11 - this we supposed to give here equals
100:14 - ignore case
100:20 - we will change the for loop here
100:23 - as we saw in the second method so unit i
100:27 - is equal to
100:35 - s1 dot
100:36 - length
100:37 - of minus 1
100:40 - and then
100:41 - i is
100:43 - greater than or equal to
100:45 - 0
100:46 - i minus minus
100:51 - so it is going to come in reverse so we
100:53 - are going to
100:55 - take this out and then put that in the
100:57 - ending
101:04 - so let us compile this also
101:10 - now i give
101:12 - radar
101:15 - so radar is valid let me check with some
101:18 - other
101:19 - word which is not a palindrome
101:24 - key is not a palindrome
101:29 - let us do a program to reverse a
101:32 - sentence now
101:34 - reversing word and reversing sentence is
101:36 - different if we reverse the sentence
101:39 - using the same technique what it is
101:41 - going to happen
101:42 - so every alphabet
101:44 - in a sentence will change to its
101:48 - opposite position
101:49 - every word will
101:51 - get reversed
101:53 - so to straighten the word we will use
101:56 - this in the beginning so it will not
101:59 - reverse the word so i cut this here and
102:02 - then put it here plus
102:04 - s2 so now we should identify a word so
102:08 - when it can identify as a word means if
102:11 - there is space with that word so from
102:14 - the ending it starts
102:16 - coming backwards when it finds the space
102:19 - and then let us stop and print the word
102:23 - and then again let us go to the next
102:25 - word and then when it comes to the first
102:28 - word there will not be a space given by
102:31 - the user for that we supposed to add one
102:35 - space with the input so we will do it
102:38 - here
102:40 - yes 1 is equal to
102:43 - c single space
102:45 - plus
102:47 - s1
102:48 - so the new string s1 is with the space
102:52 - in the beginning
102:54 - so here we will have the condition
102:58 - s1
103:00 - dot
103:01 - character at
103:04 - i
103:05 - is equal to equal to
103:07 - space
103:08 - so this is a character data type here so
103:11 - we will put it in single quotation to
103:13 - check so we give one space
103:16 - then what it will do
103:19 - it will print the word
103:35 - and then s2 becomes again nothing
103:39 - so that is for a new word again so s2
103:44 - is equal to
103:47 - so these are remaining codes which we
103:50 - used for palindrome just i delete this
103:53 - let us compile this
103:55 - no syntax error
104:01 - so i give
104:04 - this is a book
104:09 - okay
104:10 - we have given print line so it has
104:12 - printed in next next line let us give
104:15 - here
104:18 - print
104:30 - so you can see here it is reversed
104:35 - dear students
104:39 - to print
104:40 - number of digits present
104:43 - before and after
104:45 - the decimal point of a double type
104:47 - number
104:48 - first i will explain the idea of
104:52 - finding digits before and after
104:54 - decimal point of a number so here the
104:57 - number is given as double type for
105:00 - example i have 345.6721
105:06 - so here the output should be the number
105:09 - of digits available before the decimal
105:12 - point so that is 3 here and then after
105:15 - the decimal point that is 4 in this
105:18 - example
105:19 - for this we take a double type number
105:22 - and then what we do is
105:24 - convert into a string type we already
105:28 - learnt about wrapper class using wrapper
105:31 - class we will convert this double type
105:33 - into string type so if we write this
105:36 - string function this double type number
105:40 - will get converted into string type
105:43 - now we can easily find how many
105:46 - characters are there before this decimal
105:49 - point using the index value and also we
105:53 - can find the number of characters after
105:56 - this decimal point
105:58 - this number i will take it as an example
106:01 - number one
106:03 - so here we have the index for this
106:06 - string now
106:10 - see number of digits before decimal
106:13 - point after decimal point
106:16 - index always start from zero
106:19 - so 0 1 2
106:21 - 2 will be the index number of
106:24 - ones place so later that you will get a
106:27 - dot that is a decimal point
106:30 - as it is starting from 0 if we take the
106:33 - index of this
106:35 - point that is dot
106:37 - then we will have the number of digits
106:39 - before the decimal point so we can
106:42 - extract the index of
106:44 - dot
106:45 - there
106:46 - but if we want to
106:48 - know the number of digits after this
106:51 - decimal point then what we can do total
106:54 - number of digits present here minus
106:59 - digits present before the decimal point
107:02 - otherwise we can do
107:05 - last index minus index of point
107:08 - instead of
107:09 - this we say length minus 1
107:12 - minus index of point so that we can get
107:16 - the result so that is
107:19 - 8 minus 1 that is the 7 is the last
107:21 - index here then 7 minus index of this
107:25 - dot is 3 so 7 minus 3 becomes 4 c 1 2 3
107:30 - 4 digits are there
107:33 - so here in this first example i have
107:36 - index of
107:37 - dot is three so three characters are
107:41 - three
107:42 - digits are present before the decimal
107:44 - point
107:45 - and for number of digits after the
107:48 - decimal point we take the total length
107:51 - of this that is 8
107:54 - minus 1 is the last index that is 7
107:57 - minus the index of
107:59 - this dot that is 3 so we get 4 see there
108:04 - there are 4 decimal places
108:07 - let us check with another example
108:11 - here i have another number so index of
108:16 - this dot is 5 so 1 2 3 4 5 numbers are
108:21 - present there before the decimal point
108:24 - and then
108:26 - here there are three
108:27 - digits after the point so what we do the
108:31 - total length of this is 9
108:34 - minus 1 is the last index we get 9 minus
108:37 - 1 that is 8 minus
108:40 - index of
108:41 - dot is 5 so we get 3 as the answer so
108:44 - this is the logic of extracting the
108:47 - number of digits present
108:50 - before and after the decimal point
108:53 - this is a good example program how to
108:56 - convert from double type to a string
109:00 - type
109:00 - let us go to the program
109:09 - now i will have double type input
109:13 - double
109:14 - d
109:15 - is equal to
109:18 - double dot
109:19 - parse
109:22 - double of
109:24 - br dot
109:25 - read line off
109:29 - as we are having io dot star here we
109:32 - will have throws io exception
109:37 - so whatever we have taken the number as
109:40 - d we will convert into string so we will
109:43 - give string
109:46 - let us have s
109:47 - is equal to the wrapper class
109:50 - double
109:51 - dot
109:52 - 2
109:53 - string of
109:54 - the d which we have used
109:58 - to store the value of digits before the
110:02 - decimal point i will have integer
110:04 - variable called b
110:07 - in b that is before
110:09 - s dot
110:12 - index
110:13 - of
110:16 - the character dot
110:20 - to store
110:22 - after the decimal point i have in a is
110:25 - equal to
110:26 - last index we are arriving by
110:29 - 1 lesser than the length so s dot
110:34 - length of minus 1
110:36 - minus
110:38 - b
110:40 - let us print both the results
110:43 - so before i have b
110:45 - plus
110:50 - digits
110:52 - every single so digit i put s in the
110:56 - bracket
110:57 - digits
110:58 - before the
111:00 - decimal point
111:18 - compile this
111:24 - i give some number
111:29 - so three digits before the decimal point
111:32 - four digits after the decimal point
111:44 - count the number of words in a sentence
111:46 - and print the initial of the name to
111:49 - take the input let us import the
111:52 - package
111:58 - we are going to write the program to
112:01 - count the number of words in the
112:02 - sentence
112:14 - so class
112:32 - rows
112:34 - io
112:36 - exception
112:38 - let us create the variables we need
112:41 - string variable str to take the sentence
112:44 - from the user
112:46 - then to count we need
112:48 - into count
112:49 - when we need to count we have to
112:52 - give the initial value as 0 so that
112:54 - counting always starts from 0 let us
112:57 - create the object for the
112:59 - buffer reader class
113:06 - instead of creating object for the
113:09 - input stream reader and then buffer
113:11 - reader object we can also create in this
113:14 - way
113:15 - so that is buffer reader br is equal to
113:17 - new
113:20 - buffered
113:21 - reader of
113:23 - new
113:25 - input
113:26 - stream
113:30 - feeder off then system dot in
113:37 - so again we close this
113:39 - so we can do it in two statement
113:41 - differently otherwise we can also do
113:43 - using
113:44 - this type of statement
113:46 - we have given a space here that should
113:48 - not be there
113:51 - so let us prompt the user to give the
113:54 - input
114:07 - sentence
114:08 - so we can give print instead of print
114:10 - line
114:13 - so now assigning the input
114:15 - str is equal to
114:17 - vr dot
114:22 - you know that
114:24 - each word is separated by the
114:26 - space
114:28 - so after a word
114:30 - there will be a space if we count the
114:32 - space then this
114:34 - word is being counted same like that we
114:37 - will keep on counting the number of
114:39 - space but at last when we see there
114:42 - won't be a space given by the user so at
114:45 - that time what we do we add one more
114:48 - space after getting the input from the
114:51 - user
114:54 - but by mistake
114:56 - user also gives the space after the full
114:59 - stop then what we can do
115:02 - we can trim it using
115:04 - trim function so that the extra spaces
115:08 - before and after the
115:10 - sentence will get trimmed so let us give
115:13 - here dot
115:15 - trim off
115:18 - now what we do
115:19 - str is equal to
115:22 - str
115:24 - plus
115:25 - one space
115:26 - we add
115:29 - now we go to the condition
115:31 - inside the form we will create the for
115:34 - loop for
115:36 - in
115:37 - i is equal to
115:39 - 0
115:40 - i is lesser than
115:43 - str dot
115:45 - length of
115:47 - i
115:48 - plus plus
115:53 - so if
115:57 - character at
115:59 - that is str dot
116:02 - str dot character at
116:06 - i
116:08 - is equal to equal to
116:10 - so character type should be given in c
116:12 - single quotation so we check for one
116:15 - single space
116:19 - then what we do we
116:21 - increase the count count plus plus we
116:24 - increase by one
116:26 - so until the last index it will keep on
116:28 - doing
116:30 - after it becomes false
116:33 - it will come out of the for loop so we
116:36 - will print the
116:38 - number of count here
116:53 - plus count
116:55 - in case if we give this inside this for
116:58 - loop
116:58 - then it will print every time it counts
117:02 - we don't need that
117:04 - let us compile this no syntax error
117:11 - java is
117:15 - very interesting so we have four words
117:17 - here so number of words in a sentence
117:19 - four
117:23 - let us create another class
117:27 - initials
117:33 - i will copy the codes from the previous
117:35 - one
117:48 - so this is program to
117:51 - print the initials
117:55 - of the
117:57 - given name
118:00 - so here i change the class name
118:05 - we are not going to count anything here
118:07 - so let me delete this
118:12 - and then enter a name
118:20 - with
118:22 - first
118:24 - middle and
118:26 - last name
118:32 - so we don't need to trim here
118:37 - so here
118:40 - we want to print the
118:42 - first character of
118:44 - every
118:45 - name given
118:46 - so first character means we can count
118:49 - the space after that the next character
118:52 - we can
118:53 - take
118:54 - but
118:55 - when the user gives the input there will
118:58 - not be space in the beginning what we do
119:01 - here is
119:02 - going to add the space
119:04 - before the string so let us delete this
119:08 - and then i am going to add here
119:18 - now the character after the space we are
119:21 - going to
119:22 - extract and then take it as a new word
119:25 - so for the new word i give a
119:28 - new variable
119:30 - string variable st
119:33 - r1
119:35 - so initially it should be
119:37 - without any value
119:40 - so now i give the for loop
119:47 - i is lesser than
119:48 - s t r dot
119:52 - length of
119:53 - the i
119:54 - plus plus
120:00 - so i am going to give the condition if
120:04 - str dot
120:06 - character at
120:08 - i
120:09 - is equal to equal to i am checking for
120:11 - space
120:12 - so one single quote
120:14 - then one space i have given
120:16 - so if it is so then i am going to add to
120:19 - the next letter to the string one str1
120:23 - is equal to
120:25 - str
120:26 - dot
120:27 - character at
120:31 - i
120:32 - plus 1 so i is space
120:34 - the plus one is the next character so it
120:37 - will extract the next character here
120:44 - this is added with
120:46 - the new string str1
120:50 - now let us print the new string
121:02 - initials
121:04 - of given name you can say of
121:07 - given
121:08 - name
121:11 - plus
121:12 - str1
121:15 - so let us close the
121:17 - method and close the
121:18 - class
121:20 - compile this no syntax error
121:27 - so
121:28 - i give kamshi
121:31 - krishna
121:36 - see vkg it has come
121:38 - we have not given any
121:40 - extra character that so we can assign
121:42 - here
121:44 - the full stop there
121:46 - so we can add with this
121:48 - plus
121:50 - a dot otherwise one space
121:53 - so compile this
121:58 - right computer
122:02 - let us understand why we need array
122:07 - think about we need to store
122:10 - 50 students details that is 50 students
122:13 - name
122:15 - their subject marks for 10 subjects and
122:18 - we are also storing the average of
122:21 - each student
122:23 - how many variables we require
122:28 - to store names
122:30 - 50 variables we require
122:33 - to store 10 subject marks of 50 students
122:37 - then 10 into 50 we require 500 variables
122:43 - to store average again we need 50
122:46 - variables so totally we may require
122:49 - 600 variables
122:51 - can you remember all these variables
122:55 - can you handle these variables easily
122:59 - no
123:00 - so
123:01 - we use arrays
123:03 - if we use arrays just we need to have
123:07 - three array variables one is for storing
123:10 - the names
123:11 - second is
123:13 - to the marks of the subjects and then
123:16 - third is for to store average
123:19 - let us understand more how it is going
123:22 - to store these variables think about
123:26 - sets are matrix in mathematics
123:29 - same like that when i
123:31 - declare an array
123:33 - i store same type of elements here i
123:37 - have names as array so i will be storing
123:41 - all the string variables just for
123:43 - example name one name to up to name 10
123:47 - i can have one more array to store the
123:50 - marks of the students
123:54 - here i store 10 marks of a student in a
123:58 - first row and then the second student's
124:02 - mark will be in the second row like that
124:05 - i keep on storing all the 10 students
124:08 - marks of 10 subjects
124:11 - each so now you can imagine this as
124:15 - matrices mathematics to store the
124:18 - average i have one more array
124:22 - here i store
124:25 - average of these first row as first
124:28 - element of this array and then the
124:31 - second rows average i store here like
124:34 - that again i have 10 elements of the
124:38 - array say here the first array is having
124:41 - only single row so then this is called
124:45 - single dimensional array here i have
124:50 - 10 rows
124:52 - and 10 columns
124:56 - this is called
124:57 - double dimensional array
124:59 - again to store average i have single
125:03 - dimensional array
125:05 - this is to just visualize about how
125:08 - array values are stored in the array let
125:12 - us learn how to create an array we have
125:17 - two steps
125:18 - to declare an array
125:20 - first we give data type and the name of
125:24 - the array and then array symbol we
125:26 - terminate
125:27 - if it is an ordinary variable then we
125:30 - won't have this array symbol this is
125:32 - only the difference to declare an array
125:35 - and ordinary variable this will create
125:38 - only
125:39 - array
125:40 - to allocate the memory for that array
125:43 - again we have the next step that is name
125:46 - of the array whatever we have given here
125:49 - will be given equal to new keyword is
125:52 - used one space and then the data type
125:55 - already which we have done here same
125:58 - data type we will have and then the size
126:00 - of the array is given
126:03 - the size of the array means how many
126:05 - elements we are going to store in that
126:08 - particular array
126:09 - that is also called length of that array
126:14 - here is an example
126:16 - to store temperature i create an array
126:19 - that is integer type so in one space and
126:23 - then temp
126:25 - then array symbol i give i terminate
126:27 - this this is the first step the next
126:30 - step i have temp is equal to new space
126:34 - integer type that is in and then the
126:37 - size is given inside the array symbol
126:40 - that is 20.
126:42 - so here now i will have
126:44 - array to store 20 elements
126:49 - these two steps can be combined in a
126:52 - single statement like this
126:55 - that is data type
126:57 - space
126:58 - name of the array then open the square
127:01 - bracket close the square bracket is
127:03 - equal to new data type again the size
127:08 - or i also can have
127:10 - data type the array symbol can be here
127:14 - and then again array name
127:16 - equal to new data type of size
127:20 - whether the array symbol is here or here
127:22 - that doesn't make any difference both
127:25 - are right
127:27 - so here
127:29 - in a single line i have int space
127:32 - temp
127:33 - array symbol is equal to new int of 20
127:38 - total number of elements
127:41 - an array can store is called length of
127:43 - that array so this is the length of that
127:45 - array now let us understand how we can
127:49 - store the values in that array
127:52 - if we have integer type of array of size
127:55 - 10
127:56 - array allows you to store 10 integer
128:00 - values continuously so every block is
128:05 - addressed with unique address
128:07 - this addresses
128:09 - index number
128:11 - so
128:12 - to refer each block of memory index
128:14 - number is used here i have an integer
128:18 - array which can store
128:20 - 10 integer value
128:22 - here each block is allocated with size
128:25 - of integer variable so that is 4 bytes
128:29 - for integer so each block is given with
128:33 - a unique address that is index number so
128:36 - the index number always will start from
128:39 - zero first
128:41 - block will have index number as zero
128:44 - then second block will have index number
128:46 - as one third will have two
128:49 - so on like that we will have up to
128:54 - 9 so if we have an array of 10
128:59 - in size the last index number will be 9
129:02 - so that is one lesser than the
129:05 - array length
129:06 - now how do we store the value in that
129:10 - particular block
129:13 - to store the value in first block that
129:17 - is which is having index number as 0 we
129:21 - will indicate inside this symbol so that
129:23 - means address of that index
129:26 - for example we have arr of 0 so that is
129:30 - the index number and then i have given
129:33 - 84s value so 84 goes and stores in this
129:36 - place same like that if i give
129:39 - a r of 1 and then 70 is the value 70
129:42 - will get stored like this
129:45 - so all other values i just stored
130:00 - so at last the 9th index that is 10th
130:04 - memory allocation
130:06 - 62 is been stored
130:08 - even this address
130:10 - so that is index number can also be used
130:13 - to retrieve the data from that block
130:17 - so remember index number always starts
130:20 - from zero
130:22 - index number is also called subscript so
130:26 - the index number what we have here is
130:28 - also called subscript
130:30 - then the last index is always one lesser
130:34 - than the size of the array
130:37 - that is last index is equal to length
130:40 - minus 1 let us learn
130:43 - how to calculate memory size of an array
130:47 - so total allocated memory of an array
130:49 - depends on its data type and number of
130:53 - elements present in it
130:57 - we know the data types memory
131:00 - size
131:01 - byte will have 1 byte short 2 byte
131:05 - integer will have 4 long 8 bytes float 4
131:10 - bytes double 8 bytes and then character
131:13 - 2 bits
131:15 - if we have an array
131:19 - of integer
131:21 - the size of that array is 5 then how do
131:24 - we calculate the memory of an array
131:28 - number of elements that is 5 into size
131:32 - in
131:33 - bytes so that is 4 here so 5 into 4 is
131:38 - equal to 20 bytes let us see another
131:40 - example
131:42 - here we have character array which is
131:45 - having
131:46 - 8
131:47 - elements so
131:49 - 8 into 2 is equal to 16 bytes is the
131:53 - memory size of that array let us learn
131:56 - how to create array in a program
132:02 - creating array as a class name
132:12 - class
132:15 - creating array
132:31 - so now let me declare an array of
132:34 - integer type
132:37 - in
132:38 - let me have the name of the array is
132:40 - height
132:42 - so i am going to store the height of
132:44 - students is equal to
132:46 - so after height we supposed to give
132:50 - array symbol open square bracket close
132:53 - the square bracket and then we should
132:55 - give new keyword and then again the data
132:58 - type that is int of the size we are
133:01 - going to say here is
133:03 - as
133:04 - 20
133:07 - now array is declared how to store the
133:10 - value in that array we can have
133:14 - name of the array inside the square
133:17 - bracket we will give 0 as first index so
133:20 - that is the address of that array is
133:22 - equal to i am storing
133:25 - 156
133:29 - same like that
133:32 - index 1
133:35 - is equal to 165
133:38 - now
133:39 - third element
133:45 - 2
133:47 - is equal to 1
133:49 - 43
133:52 - right off
133:54 - so here fourth element index will be 3
133:58 - is equal to
134:00 - 172
134:03 - then fifth element
134:06 - that is address will be 4 that is index
134:09 - number is 4 is equal to
134:11 - 180
134:13 - so let us have just 5 instead of 20 let
134:17 - us reduce this
134:19 - so i have 5 so i have store all the
134:22 - values let us print and check how to
134:25 - print this we can print it in single
134:28 - statement
134:35 - so we will be giving the
134:38 - address of the element which is
134:40 - like this
134:42 - i'll copy this paste it here
134:44 - so
134:45 - plus i give one space otherwise we won't
134:48 - be able to identify i give space or even
134:51 - we can give comma let me give comma so
134:54 - like this
134:55 - i will give all five
134:59 - elements to print
135:04 - so here it is
135:06 - one
135:08 - then
135:09 - here it is
135:11 - 2
135:15 - this is
135:16 - 3
135:19 - here
135:20 - 4.
135:21 - so we have
135:23 - given
135:24 - all the address to print
135:29 - let us compile this
135:32 - no syntax error
135:34 - so we will run and check whether it is
135:36 - printing or not
135:37 - so you can say it is printed
135:44 - so here instead of giving like this one
135:47 - by one all the elements in different
135:50 - statement to store we can also use a for
135:54 - loop for this see let us delete all this
135:58 - i will have far
136:00 - so the index always starts from 0 so int
136:04 - i is equal to
136:05 - 0 iq then i is lesser than
136:10 - or equal to 4 because the index is
136:14 - 4
136:15 - at last otherwise just directly we can
136:17 - give lesser than 5
136:20 - that is lesser than the length of the
136:22 - turret and then terminate i plus plus
136:28 - so now i am going to take input for this
136:31 - from the user so i will have here
136:34 - import
136:35 - java.util.scanner
136:41 - so i will create an object for that
136:46 - obj is equal to new
136:49 - scanner of
136:51 - system dot in
136:54 - now we will prompt the user
137:05 - five integer elements
137:11 - so this is going to be given only once
137:14 - so it is not inside the for loop
137:16 - this scanner class i have already taught
137:18 - you in the
137:19 - uh
137:20 - third video tutorial
137:22 - so you can watch and learn if you are
137:25 - not familiar with this so here you open
137:28 - and close the bracket inside i write
137:31 - name of the array is here height
137:34 - height off see instead of giving the
137:36 - index 1 2 3 like that i am going to give
137:40 - i so it starts from 0 and then up to 4
137:44 - is equal to the object name obj dot
137:48 - next
137:49 - in top
137:51 - so it will store the values given by the
137:54 - user in each
137:56 - block now let us compile this
137:59 - no syntax error
138:01 - so
138:02 - directly we can give the values now
138:05 - enter the
138:07 - integer elements now
138:09 - so i just give
138:10 - 150
138:12 - 145 175 185 165
138:19 - so you can see that all these are
138:21 - printed and then again when we give the
138:25 - output this also can be done using for
138:28 - loop it will be easy instead of giving
138:30 - this many times so what i do here again
138:33 - i create a for loop
138:36 - into i is equal to
138:39 - 0 again we can give i because scope of
138:42 - this i get over when this for get
138:45 - closed
138:46 - is equal to
138:48 - i is lesser than
138:50 - 5.
138:53 - i
138:54 - plus plus
138:57 - so what i do here
138:59 - i will just print only
139:05 - this much
139:07 - and then here i say i
139:11 - if this is a single statement even we
139:13 - don't need to open and close the bracket
139:16 - so let us compile this
139:18 - nose inductor
139:23 - so enter the elements
139:34 - so you can see that again it has been
139:36 - printed we have given
139:38 - print line so it is printed in next next
139:40 - line if we give here print and then it
139:43 - will print in the same line
140:02 - so you can see that it is given
140:08 - if we take
140:09 - user input like that then we need to
140:14 - create and declare array like this
140:16 - instead of this if it is a fixed
140:19 - number of elements and the elements are
140:22 - also given inside the program we have
140:24 - another way to give
140:26 - so let us cancel which are all
140:29 - are not needed
140:30 - delete this
140:32 - and then we are not taking
140:34 - any of this
140:37 - even this i am not going to have only
140:39 - printing statement i have so how we can
140:41 - give here we can have flower bracket
140:45 - inside this we can give the details of
140:49 - array for example 1 45 comma 1 49
140:56 - 1 five four
140:58 - one
141:00 - four nine
141:03 - one more
141:05 - comma
141:06 - 155
141:09 - this is directly initializing the array
141:12 - so again if we need to print we can give
141:15 - it in a for loop and then we can print
141:18 - compile this no syntax error
141:24 - so you can say this
141:25 - it is printed
141:29 - let us revise
141:32 - definition
141:33 - array is a named collection of similar
141:36 - elements that holds a fixed number of
141:39 - elements so we cannot change
141:42 - the length of the
141:44 - array once if it is declared and then
141:48 - all the elements will be the same data
141:50 - type
141:52 - we cannot have different data type in a
141:55 - single array
141:58 - total number of elements
142:00 - an array can store is called the length
142:03 - of that array
142:06 - every block of memory within the array
142:09 - has unique address which is called index
142:12 - number
142:15 - we can use index number to assign values
142:19 - to particular block of memory and also
142:22 - we can retrieve the values for that
142:25 - particular block of memory
142:28 - once an array is declared it can be
142:31 - initialized anytime
142:34 - by assigning the value to that array
142:37 - index number always starts from zero
142:42 - so we know
142:44 - length of the array is one greater than
142:47 - the last index otherwise last index is
142:50 - one lesser than the length
142:54 - index number is also called subscripts
143:00 - the total allocated memory of an array
143:03 - depends on its data type and the number
143:06 - of elements present in it
143:10 - we will learn passing array as an
143:12 - argument
143:14 - getting length of an array
143:16 - and out of bounds exception in array i
143:19 - will demonstrate
143:20 - passing array as an argument through a
143:23 - program
143:27 - passing ariu
143:36 - class
143:39 - passing
143:40 - array
143:43 - i create a method
143:46 - static
143:48 - void
143:50 - passing as array name
143:52 - and then i will give the
143:55 - integer array to pass
143:57 - so in
143:59 - name of the array i give as a
144:03 - and array symbol
144:04 - here i am not supposed to give
144:07 - size of the array
144:09 - because
144:10 - when it receives
144:12 - array elements
144:14 - automatically it will assign the length
144:16 - of the array
144:22 - we can give the array values in the
144:25 - arguments itself
144:26 - so after giving the values
144:29 - let us sum up all the values
144:32 - in that array so i need a variable to
144:35 - sum
144:37 - in
144:38 - sum is equal to 0 as initial value
144:42 - so we need to take each and every
144:44 - element from that array
144:47 - so what we can do we can
144:49 - give a for loop
144:52 - for
144:54 - from 0th index
144:56 - whatever is stored up to the last index
144:59 - we have to take all the elements to sum
145:02 - so in
145:03 - i is equal to 0
145:07 - i assume
145:08 - we are going to give 5 elements
145:11 - i is lesser than 5 so that is 0 1 2 3
145:16 - and 4
145:17 - i
145:18 - plus plus
145:24 - get the sum i give sum is equal to
145:27 - sum
145:28 - plus
145:30 - a of
145:31 - i
145:33 - i terminate this
145:34 - so it will take
145:36 - element from zeroth element to the last
145:39 - element that is fourth element
145:42 - then i will print the sum after the loop
146:02 - plus sum
146:06 - let me compile this
146:08 - no syntax error
146:12 - when i give the
146:14 - value for that array i must give inside
146:16 - the flower bracket so as i assigned five
146:20 - elements so i will give one two three
146:22 - four five each separated with commas
146:26 - okay
146:28 - here
146:29 - i have given
146:31 - loop
146:32 - variable will go up to 5 iterations
146:36 - but in case user gives less or more what
146:40 - happens
146:41 - let us see
146:43 - again let us run this
146:47 - now i give just
146:49 - three elements one two three
146:52 - okay
146:54 - so you can see it has come back to the
146:56 - program and it shows
147:00 - java.lang.arrayindex out of bounds
147:02 - exception
147:03 - this error happens
147:05 - when the
147:06 - loop tries to get the element which is
147:09 - not available in the array so that means
147:12 - we have given only three elements that
147:14 - is 0 1 and
147:16 - 2 when it is trying to get the third
147:19 - element from the
147:20 - array it is not available so
147:23 - automatically it shows out of bounds
147:26 - exception
147:27 - so we should match number of iterations
147:31 - in the loop to the
147:33 - last index of that array
147:35 - in this case we were not knowing the
147:38 - length of that array so at that time we
147:41 - can
147:42 - take the length of array by using
147:46 - length
147:47 - function
147:50 - to find the length of array we write
147:54 - name of the array dot
147:56 - length and we terminate
147:59 - for example
148:02 - if we have array called arr
148:05 - then we initialize the value like this
148:08 - to find the length of this we can write
148:12 - a rr dot length and then we terminate if
148:15 - we wanted to store this length in a
148:18 - variable
148:19 - then we can initialize the variable
148:22 - int l is equal to
148:25 - because the length is in integer
148:28 - arr dot length so automatically length
148:32 - of that array
148:33 - will be stored in variable called l here
148:36 - in the example we have eight elements so
148:40 - l will be eight
148:43 - let us go back to the program
148:45 - so now here we can have one more
148:48 - variable called length
148:50 - and then we initialize this as
148:53 - l is equal to
148:54 - a is the name of the array dot l e n g d
148:59 - h
149:00 - then we term it so automatically the
149:02 - length of the array given is
149:04 - stored in l so we will give instead of
149:08 - ah constant here we will give l
149:10 - so now no matter
149:13 - how much every element is given there in
149:15 - the argument it is taken
149:19 - so let us
149:20 - run this
149:22 - now i give
149:25 - six elements
149:27 - one two three four five and six
149:33 - okay so it could show the result
149:38 - now i will demonstrate another program
149:42 - where we take the
149:44 - input from the user for the array and
149:46 - then we pass that array to the
149:49 - other method
149:51 - may be the same method so to take the
149:54 - input i will have
149:57 - import
149:58 - java dot io
150:00 - dot star and then
150:02 - determinate so i will have another
150:05 - method
150:08 - static
150:09 - wide
150:12 - input off as we have imported io class i
150:16 - will give
150:18 - throws io
150:20 - exception
150:25 - so let me declare first a
150:27 - integer array variable i will take it as
150:30 - class variable static
150:35 - int
150:37 - array called b
150:38 - so is equal to new
150:41 - int off
150:43 - may be size 10.
150:47 - now to take input let us create the
150:50 - buffer reader object
151:01 - of new
151:03 - input
151:05 - stream
151:06 - reader of
151:09 - system
151:11 - dot in
151:12 - then we close terminate
151:14 - we will prompt the user
151:17 - system dot out dot
151:20 - twin lineup
151:22 - we say
151:23 - input
151:28 - then
151:30 - integer
151:31 - array
151:33 - element
151:35 - to take
151:36 - 10 elements i will have for loop
151:41 - if i is equal to
151:43 - 0
151:44 - i is
151:45 - lesser than we can give lesser than 10
151:48 - otherwise lesser than
151:50 - b dot
151:53 - length then i plus plus now even if we
151:56 - change the value of this also not a
151:58 - problem so i give now 4
152:00 - so again we don't need to change here as
152:03 - lesser than 400 so better always we will
152:06 - say the
152:08 - length here in the for loop
152:11 - so let us
152:12 - assign the value
152:15 - b of
152:16 - i
152:18 - is equal to
152:20 - integer
152:21 - dot
152:23 - parse into of
152:27 - br dot
152:29 - read lineup
152:33 - so now this method
152:35 - takes the
152:36 - elements for the
152:38 - array called b
152:41 - now we will pass this value
152:44 - to this method
152:46 - how we will write the main method
152:50 - public
152:51 - static void
152:52 - main of
152:54 - string of
152:56 - arguments then we will say throws
153:00 - io
153:04 - exception so we have to create object
153:07 - for that class so class name
153:12 - passing
153:13 - array
153:14 - and then
153:16 - object name object obj is equal to new
153:20 - pa ssing passing array
153:24 - off
153:25 - so now i will call the methods
153:28 - first i will call the method which is
153:30 - input method so that we will take the
153:32 - input for that array b
153:34 - so i will write obj dot
153:38 - input off
153:39 - now i will call
153:41 - passing method so obj dot
153:45 - passing
153:46 - off see here i have taken values for
153:51 - array b
153:52 - i will pass this value to the
153:54 - method here
153:59 - so i write here b
154:01 - then terminate
154:05 - let us again change this to 10 itself
154:09 - now compile this
154:13 - no syntax error
154:15 - we have to run the main method
154:19 - so it is asking 10 inputs 1 2 3 4 5 6 7
154:24 - 8 9
154:25 - and then 10 we already know it will be
154:27 - 55
154:28 - so let us check whether it is right or
154:30 - wrong
154:31 - so sum of all the elements given array
154:32 - is
154:33 - 55
154:35 - to print only even elements from an
154:37 - array
154:39 - to print sum of even elements and odd
154:42 - elements to print the count of even and
154:45 - odd elements
154:48 - to print smallest number and largest
154:51 - number from an array
154:54 - let us create a program
155:01 - print even
155:11 - import java dot
155:13 - io dot star
155:19 - class
155:22 - print even
155:37 - [Applause]
155:42 - let me declare an array integer type
155:45 - name of the array arr of
155:48 - is equal to new
155:50 - in tough
155:52 - i will give size as 10.
156:22 - prompt the user
156:41 - to take 10 elements i will give a for
156:44 - loop
156:48 - in i is equal to 0
156:51 - i is lesser than we can say a r r
156:55 - dot
156:56 - length
156:57 - then i plus plus
157:03 - so arr
157:05 - of i
157:08 - is equal to
157:11 - integer dot
157:13 - pass into
157:16 - br dot
157:18 - we line up
157:20 - then we terminate this so now we have
157:22 - taken
157:23 - input for that array so that is 10
157:25 - elements we have taken
157:28 - now let us give a line outside the loop
157:31 - saying
157:32 - following are even elements so
157:35 - system dot outdoor
157:38 - print lineup
157:53 - so now
157:54 - we have to
157:55 - check the
157:56 - elements one by one whether the element
157:59 - is
158:00 - even or not
158:01 - to access
158:03 - each element again we will give a for
158:05 - loop
158:06 - let us copy the same for
158:12 - loop we already know how to find
158:16 - even numbers
158:17 - if the number is divisible by 2 that is
158:21 - without reminder then we say
158:24 - the number is
158:25 - even number
158:27 - so to get the remainder we will use
158:30 - percentage symbol that is modulus let us
158:33 - give that in the condition
158:36 - arr
158:38 - of
158:40 - i
158:42 - modulus
158:43 - 2
158:44 - equal to equal to 0 so
158:47 - it
158:48 - divides by 2 and gets the
158:50 - remainder if remainder is 0 then what we
158:54 - will do we will print the element
158:57 - so
158:58 - system dot
158:59 - out dot
159:01 - print line of
159:03 - we say af
159:05 - sorry a rrf
159:08 - i
159:11 - think
159:13 - if we need the elements to be printed in
159:15 - the same line we can cancel this
159:18 - and then we can add one comma or space
159:21 - with this
159:21 - so i will add one space here
159:25 - so let us compile this
159:27 - no syntax error
159:32 - so enter 10 elements
159:35 - 45
159:36 - 3
159:37 - 7
159:39 - 84
159:40 - 96
159:42 - 12
159:43 - 15
159:45 - 17
159:46 - 21
159:48 - 18
159:50 - so
159:50 - we can see here only even numbers are
159:54 - printed
159:57 - now
159:58 - program 2
159:59 - get the sum of even number and sum of
160:02 - odd number
160:03 - so i will give
160:04 - some
160:06 - even
160:08 - odd as a class name
160:22 - so before this
160:23 - i will import
160:29 - java.io dot star
160:34 - rest of the code i will copy from the
160:36 - previous program
160:39 - so even we can copy from here to here
160:49 - we don't need this line let us delete
160:51 - this
160:53 - so
160:54 - after entering all the numbers
160:57 - we will again have a far low
161:01 - if it is even number we will add it
161:04 - to even sum so for that we need
161:07 - a variable even for odd sum we need a
161:10 - variable so let us give
161:13 - int
161:14 - sum of e1
161:16 - equal to zero initially
161:19 - then sum of
161:21 - odd
161:22 - also zero initially
161:27 - now we have already checked whether it
161:28 - is even or not if it is even we will add
161:32 - with this
161:33 - sum of even so
161:35 - se
161:36 - equal to se plus
161:39 - arr
161:40 - of
161:42 - i
161:43 - otherwise we can also give
161:45 - plus c equal to here
161:47 - plus equal to
161:50 - and then
161:53 - else otherwise
161:56 - sum of odd
162:00 - plus equal to
162:01 - arr of
162:04 - i
162:05 - so then we close this
162:07 - for
162:08 - see
162:10 - if it is true
162:12 - that is even number then it will add
162:14 - with the sum of even
162:16 - otherwise it should be
162:18 - odd number automatically it will add
162:21 - with
162:22 - this variable
162:24 - so now we have to print the sum of e1
162:27 - and sum of r
162:41 - sum of
162:42 - even
162:44 - numbers
162:47 - from
162:48 - given
162:49 - array
162:52 - plus
162:53 - s e
163:00 - so here odd number
163:04 - so this will be s o
163:07 - now we will close the
163:10 - method
163:12 - and then
163:13 - class
163:14 - just compile this
163:16 - no syntax error to check the right
163:18 - result i will give the sequence of
163:20 - number just i will give one two three
163:23 - only
163:24 - one two three four five six seven eight
163:29 - nine
163:30 - and ten
163:32 - so even numbers
163:34 - total is 30 and odd numbers total is 25
163:38 - you can check
163:42 - next we will learn
163:45 - counting number of even elements and
163:48 - number of odd elements so
163:51 - count even
163:53 - odd iq
163:59 - i will copy whole program from the
164:01 - previous program
164:15 - here instead of
164:17 - taking the sum of
164:19 - even numbers and sum of odd numbers just
164:22 - we are going to count so
164:24 - let us change the variable name
164:27 - count even number
164:30 - then count odd number
164:34 - so initially the count is 0 for both
164:37 - so if this is true then what we will do
164:39 - we will just increase the count of even
164:42 - number
164:43 - c e
164:44 - plus plus else what we will do we will
164:47 - increase the count of odd number
164:51 - co
164:52 - plus plus
164:53 - so now we are going to
164:55 - print
164:59 - number of
165:05 - even numbers
165:07 - of given array
165:12 - that is
165:13 - co sorry ce
165:17 - here
165:19 - number of
165:22 - odd numbers
165:24 - of given array
165:27 - that is
165:28 - ceo
165:30 - let us change the class name
165:36 - and give count
165:39 - compile this
165:41 - no syntax editor
165:42 - let us run this
165:45 - any number let us give 11
165:47 - 15
165:49 - 18
165:50 - 20
165:52 - 48
165:53 - 65 71
165:56 - 0 3
165:58 - minus 11
166:01 - minus 32
166:05 - let us count 1 2
166:09 - 3 4
166:10 - 5 6 are odd numbers
166:14 - so remaining 4 will be
166:16 - even numbers
166:20 - next program to find the smallest and
166:24 - largest element of that array
166:39 - i will copy again the code from the
166:41 - previous one
166:43 - i will copy until
166:45 - this
166:54 - i will change the class name
167:02 - largest smallest
167:05 - let us have double type of array so i
167:07 - will change this
167:10 - double
167:11 - again here also double
167:16 - so
167:17 - instead of
167:18 - counting here i will have the smallest
167:21 - element and the largest element so again
167:24 - i will change even the
167:26 - data type of the smallest also will be
167:27 - smallest or largest also will be double
167:30 - type itself so double
167:32 - instead of ce largest
167:36 - and then here
167:37 - smallest
167:43 - so we cannot initiate as zero
167:45 - in case the user gives negative numbers
167:48 - so it cannot be
167:50 - zero so i will
167:52 - take a
167:53 - element from array itself so let us take
167:57 - just first element itself
167:59 - this arr
168:01 - of
168:02 - 0 that is index
168:05 - same like that
168:06 - smallest also let us take first elements
168:09 - itself arr
168:11 - of 0.
168:14 - now i will give the condition to find
168:17 - the largest element of that array
168:21 - it takes all the element of that array
168:23 - that is a r r of i and then if it is
168:30 - greater than
168:31 - largest
168:34 - sometimes it is also possible to be same
168:37 - number so we will give greater than or
168:39 - equal to also
168:41 - so if this is true i will assign the
168:44 - element to the variable largest so
168:48 - largest is equal to arr of i
168:55 - now i close the for loop so now
168:58 - i will search
169:00 - for smallest one so again we will have
169:02 - the same loop
169:08 - now we are going to find the smallest
169:11 - one so we will have lesser than or equal
169:14 - to smallest
169:22 - so if it is true the
169:24 - element will go to
169:26 - smallest
169:34 - now let us print the
169:35 - largest and smallest elements
169:38 - so i copy this
169:52 - largest element is plus
169:55 - largest
170:03 - so here smallest element is
170:10 - smallest
170:15 - let us close the
170:17 - method
170:20 - close the class
170:25 - compile this
170:28 - uh we have done a mistake here while
170:30 - typing the variable it should be capital
170:33 - l
170:34 - here also should be capital n
170:36 - let us check
170:37 - here we have given
170:39 - capital so here also should be
170:42 - capital so we should be very careful
170:44 - while writing this
170:48 - then okay so here we have given double
170:52 - but in the previous program it was
170:54 - integer so let us change this
170:59 - double
171:00 - here also double
171:07 - any other error let us compile and check
171:10 - no syntax error now
171:15 - so enter 10
171:16 - elements 31.01
171:20 - minus
171:21 - 63.12
171:24 - 45
171:26 - 39.47
171:31 - zero zero two
171:33 - eighty
171:34 - five point
171:36 - zero zero four five
171:38 - eleven point
171:40 - one one one one one
171:43 - thirty
171:44 - seven 48.23
171:52 - 0.4
171:55 - so we can see here
171:57 - the largest number which i have given at
171:59 - the last
172:00 - the least number is minus 63.12 so it is
172:04 - right
172:08 - searching elements in an array
172:11 - let us know what is search
172:13 - the process of
172:15 - checking a particular value in an array
172:17 - refers to such
172:19 - if the value is present in the array
172:22 - then index number of that element will
172:25 - be displayed
172:27 - for example
172:28 - we have array called a and then these
172:31 - are the elements
172:33 - if we search for value 7
172:36 - and then it is available in 0 1 2 3 4
172:41 - and
172:42 - fifth index number
172:44 - so we will print it is available at
172:47 - index number five
172:49 - if we see search techniques we have
172:52 - commonly used two techniques that is
172:55 - linear search and binary search
172:58 - linear search
173:00 - each element of the array is compared
173:03 - one by one with the given value to be
173:06 - searched
173:07 - this will be done until the value is
173:10 - found otherwise this will continue until
173:14 - the last index
173:16 - this technique is also called sequential
173:19 - search technique
173:21 - let us learn the linear search technique
173:24 - before starting the search we will
173:27 - initialize a variable as false that is
173:30 - boolean type variable
173:32 - so boolean flag i have given the
173:35 - variable name here and then i
173:37 - initialized as false flag is the common
173:41 - variable name which we use in the
173:44 - search technique
173:47 - for example if i have an array like this
173:52 - for your better understanding i have
173:54 - also displayed index number here
173:57 - let us imagine that we are searching for
174:00 - value 54 here
174:03 - linear search will search by comparing
174:06 - the element of first index to the last
174:10 - index so
174:12 - value in index number 0 will be compared
174:15 - with the given value
174:17 - then it is false here it will go to the
174:21 - next index number
174:22 - that is 1 and then it is comparing again
174:25 - it is false so it will keep on comparing
174:28 - like this it becomes false third one it
174:31 - is false
174:33 - fourth one again it will be false
174:36 - fifth one also it is false
174:40 - now sixth one
174:42 - it is true
174:47 - when the search is successful then we
174:49 - print the index number of the
174:52 - element which is available
174:56 - and then
174:58 - we assign that flag as
175:00 - true when search is successful and then
175:04 - we don't need to check for the rest of
175:06 - the elements so what we do we break
175:09 - using the break statement
175:12 - if no elements are matched with the
175:15 - given value
175:16 - value of flag will be false
175:20 - it never get changed into true so if it
175:23 - is false then we print element not found
175:27 - this is how linear search technique
175:30 - works
175:31 - let us create a program i will
175:34 - demonstrate
175:35 - let us create a class
175:37 - before that i will keep ready copying
175:39 - the codes from the previous program
175:50 - [Applause]
175:58 - so i copied the codes
176:00 - until we take the input
176:04 - i'll change the class name here
176:10 - then we are taking the
176:13 - double type of array okay let it be as
176:16 - double type
176:17 - then we don't need to have this variable
176:20 - instead of that we need a boolean
176:22 - variable which is
176:25 - initialized as
176:26 - false so
176:29 - boolean
176:30 - flag is equal to
176:32 - false
176:35 - after taking the input we have to start
176:38 - searching for the element before that we
176:41 - have to get the element which we are
176:43 - searching for so let us prompt the user
176:46 - to give the input for the element which
176:48 - we are searching
177:06 - so let me have only print
177:12 - elements are double type so we give
177:14 - double
177:15 - s is the variable
177:17 - we store the value to be searched
177:20 - is equal to
177:22 - double
177:24 - dot
177:25 - parse
177:27 - double of
177:29 - br dot
177:30 - read
177:32 - line off when we terminate
177:35 - now we give the photo
177:39 - in i is equal to
177:41 - 0
177:42 - i is
177:43 - lesser than the length of the array so
177:45 - we can give
177:46 - a r dot
177:49 - length
177:51 - i plus plus
177:57 - so from the index number 0 until the
178:01 - last index
178:02 - it will keep on searching so we give the
178:06 - condition here if
178:09 - the element
178:11 - that is arr of i
178:15 - is equal to equal to the value which we
178:18 - are searching for that is yes
178:25 - so
178:26 - it will search one by one
178:28 - until it gets
178:30 - if this is true
178:31 - we will print
178:33 - system dot out dot
178:36 - print line of
178:43 - element
178:45 - found at
178:47 - index equal to
178:49 - plus index will be i
178:53 - then
178:54 - turn the flag as true
178:57 - flag is equal to
178:59 - true
179:00 - then we will break it so we don't need
179:02 - to search anymore
179:06 - this is when it finds the element which
179:09 - we are searching for
179:12 - if it is not finding it will keep on
179:14 - searching until the end but still the
179:17 - flag will remain false itself
179:20 - so
179:23 - after completing the search
179:25 - we will say if it is not found if
179:30 - flag is equal to equal to false
179:32 - if it remains same
179:34 - then we say
179:37 - system dot out dot
179:39 - printline of
179:47 - element
179:48 - not found
179:49 - then we will close the method close the
179:53 - class
179:55 - will compile this
179:57 - no syntax error
180:02 - value 10 values
180:29 - so
180:30 - let me
180:31 - give the value which is available here
180:34 - 5457.65
180:38 - let me check before 0 1 2 3 4 5 6 7
180:44 - so 7th is the index number of this
180:47 - number so i give enter
180:49 - so element found at index 7
180:54 - let me run once again
181:17 - so i am searching which is not available
181:23 - element not form
181:27 - if we are having string elements so let
181:29 - us change this and learn
181:32 - so i am having string type of
181:35 - array
181:43 - so array length i give just
181:45 - 5.
181:49 - and then here when we check this we will
181:53 - not have equal to equal to instead of
181:56 - that we will check
181:58 - dot equals
182:01 - dot
182:03 - equals
182:04 - of
182:05 - s
182:07 - if we need to ignore the case we can
182:09 - give equals ignore case of
182:14 - and then here we will not have all this
182:22 - so we have only br dot read line up to
182:25 - take the input and also searching
182:28 - element
182:29 - this is string
182:41 - so let us compile this
182:43 - no syntax error
182:45 - so let us run this
182:50 - so i will be giving
182:52 - keyboard
182:54 - mouse
182:57 - pen drive
183:00 - laptop and i give printer
183:05 - enter the value to be searched i give
183:07 - mouse
183:12 - so element found at index 1
183:14 - 0 1
183:17 - binary searching array binary search
183:20 - works only for
183:23 - sorted array it may be sorted by
183:26 - ascending order or descending order
183:29 - in this type of search
183:31 - search value is compared with middle
183:33 - element of array
183:35 - if the value matches with the middle
183:38 - element then search gets completed
183:41 - if the match is not found at the middle
183:44 - element
183:45 - again it will search
183:47 - with middle element of first half
183:50 - otherwise
183:51 - second half it depends on the searching
183:54 - value
183:55 - or sorting of the array
183:57 - for example if the value being searched
184:00 - is lesser than the middle element then
184:03 - it gets performed only in the first half
184:07 - this is in the ascending order array if
184:09 - the value being searched is greater then
184:12 - it will perform in the second half of
184:15 - the array
184:16 - this process will keep on repeating
184:19 - until the
184:21 - element is found
184:22 - are until search get completed
184:26 - if element is not found then search will
184:29 - get completed when first index number is
184:32 - equal to the last index number
184:35 - we will understand this by few examples
184:39 - later once again we will come to this
184:41 - and then we will read
184:43 - so i have array
184:44 - integer array having the values like
184:47 - this let us search
184:49 - for element
184:50 - 23
184:54 - so for your reference i have given index
184:56 - numbers starts from 0 and the last index
184:59 - number here is 11.
185:01 - now it should find the middle index
185:04 - number and then
185:06 - for that whichever element is there it
185:08 - will compare with that element
185:11 - how the middle element is found is like
185:13 - mathematics we will take the first index
185:17 - and the last index we add both and
185:20 - divide by 2 automatically we will get
185:22 - the mean so that is the middle index we
185:24 - will get for your better understanding i
185:27 - have matched first index last index even
185:30 - the middle index with the colors please
185:32 - follow the colors also so that it will
185:34 - be easy for you to understand
185:37 - for the first time
185:39 - the search will be in the
185:41 - whole array
185:42 - so
185:43 - it takes the first index
185:45 - as 0
185:46 - last index as 11 here and then we will
185:50 - add first index and last index
185:54 - divided by 2 so we will be getting
185:58 - 5.5 index number cannot be 5.5 so we
186:03 - leave the decimal part and then take
186:06 - only the integer part
186:09 - here in the program also it will do
186:11 - automatically implicit conversion that
186:14 - is integer divided by integer it gives
186:17 - only the integer value
186:19 - as quotient
186:20 - now in the middle element
186:23 - 37 is there
186:26 - so we are searching for 23
186:30 - it is lesser than 37 so when it is
186:33 - sorted array there is no meaning in
186:36 - searching this
186:38 - second half
186:39 - because what we are searching will be in
186:42 - the first half only
186:44 - because search element is lesser than
186:47 - the middle element so it will not search
186:50 - in the second half
186:52 - now the middle element is already
186:54 - compared so
186:56 - remaining
186:58 - segment that is index from 0 to 4 only
187:01 - we have to search
187:04 - so here first index remains as 0 itself
187:08 - but the last index instead of 11 it
187:10 - should be 4. we already found middle
187:13 - element as 5 so what we do middle
187:16 - element minus 1 we will give the
187:19 - next last
187:20 - index so in round 2 we will have first
187:24 - index as 0 last index is 4 so 0 plus 4
187:28 - divided by 2 we will get 2 as the result
187:33 - so in 2
187:35 - 23 is available which is equal to which
187:38 - we are searching so what happens
187:42 - search becomes successful and then it
187:44 - will print the index number of that
187:48 - element let us see next example
187:52 - i have a new array here after removing
187:55 - the last element of the previous array
188:01 - so let us search for element 51
188:04 - i have the index number
188:06 - from 1 to 10
188:09 - so at round 1 the first index number
188:12 - will be 0 and the last index number will
188:15 - be 10.
188:16 - so middle element we find
188:19 - 0 plus 10 divided by 2
188:22 - we get exact 5
188:24 - at index number 5 i have 37
188:29 - so 51 is greater than 37
188:33 - so no meaning in the searching first
188:36 - half so automatically it will search in
188:39 - the second half first index of the new
188:42 - segment is arrived by adding one with
188:45 - the middle element so it becomes 6
188:48 - last index remains unchanged
188:52 - so now
188:53 - we get
188:56 - 6 plus 10 divided by 2 that is 16
188:59 - divided by 2 we get 8 as middle element
189:03 - of this segment
189:06 - at index 8 54 is available
189:11 - 51 is lesser than 54
189:15 - so it is not necessary to search
189:19 - the second half again
189:23 - now the first index remains same
189:26 - the last index will be
189:28 - middle index minus 1
189:30 - that is 8 minus 1
189:33 - so now for round 3 the new value
189:38 - of middle index will be
189:40 - 6 plus 7 divided by 2 that is
189:43 - 6.5 here again we will take only the
189:46 - integer part that is 6x index so at
189:50 - index 6 45 is available so 51 is greater
189:55 - than 45 first half we don't need to
189:58 - search to get the first index we add
190:01 - middle index plus 1 we get 7. the last
190:05 - index is also 7
190:08 - see now first index is also say 7 last
190:12 - index is also 7 if
190:15 - the element is not found at this index
190:18 - then search also will stop
190:21 - let us check
190:24 - 7 plus 7 divided by 2 will be
190:26 - 7 itself
190:28 - so we get 51 here
190:31 - 51 which is we are looking for it
190:34 - becomes successful
190:36 - if some other element is at that place
190:39 - and then it becomes unsuccessful as
190:41 - first element and last element both are
190:44 - same index
190:45 - let us go to one more example
190:52 - index number of this array is
190:55 - 0 to 11
190:56 - so let me search for
190:58 - element 11
191:01 - at round 1
191:04 - first index is 0 and last index is 11
191:08 - so we will have middle element as
191:11 - 0 plus 11 by 2 as 5.5 only integer part
191:15 - of this we will take so we will take 5
191:18 - at 5 33 is the value available
191:24 - 11 is lesser than 33
191:27 - so
191:29 - greater than the middle element index
191:30 - numbers we don't need to search
191:33 - the first index of new segment of array
191:36 - will be
191:37 - 0
191:38 - the last index will be middle
191:40 - index minus 1 that is 4 so at round 2
191:45 - 0 plus 4 divided by 2 is equal to 2
191:49 - element at index number 2 is 23 which is
191:54 - again lesser than 11
191:56 - so
191:57 - the first half will be searched second
191:59 - off we don't need to search
192:02 - first index remains the same
192:04 - last index is middle index minus 1 so
192:08 - that becomes 1 so at round 3
192:12 - 0 plus 1 divided by 2 it will be 0.5
192:16 - so we take only 0
192:18 - at 0 11 is available which is equal to
192:22 - the element which we are searching for
192:24 - so search becomes successful
192:27 - i will give you the last example where
192:30 - the search element is not available
192:33 - so example
192:34 - 4
192:40 - i am searching for 53 which is not
192:43 - available in this article
192:45 - so here
192:46 - the first index is 0 last index is
192:50 - 10
192:51 - so we get 5 s answer
192:54 - at 5 we have 37
192:57 - 53 is greater than 37
193:00 - so it will not search in the first half
193:04 - first element becomes middle element
193:07 - plus 1
193:08 - last index remains same now at round 2
193:12 - 6 plus 10 by 2 it becomes 8 again
193:17 - at index 8
193:19 - 54 is available 53 is lesser than 54
193:24 - so the second half will not get searched
193:28 - now the first index remains same
193:31 - last index is middle index minus 1 so
193:35 - that is 7.
193:36 - so at round 3
193:38 - 6 plus 7 divided by 2 it is 6.5
193:42 - so it will take only integer that is 6
193:45 - at 6 45 is available
193:48 - 45 is
193:50 - lesser than 53
193:53 - so we don't need to search in the first
193:55 - half so index number
193:58 - of first element will be middle index
194:00 - plus 1 that is 6 plus 1 is equal to 7
194:05 - and the last index also 7
194:08 - so at round 4
194:11 - 7 plus 7 divided by 2 is equal to 7
194:15 - so at index 7 51 is available again
194:19 - which is not correct being first index
194:22 - and last index are same search stops
194:25 - then it becomes unsuccessful
194:28 - students when we do manually we will do
194:31 - like this but when we do a program all
194:34 - this round 1 round 2 round 3 round four
194:37 - all will be done in the loop so
194:40 - it will be very easy to write the
194:42 - program just we need to understand how
194:45 - we change the first induction last index
194:48 - and which segment to be searched let us
194:51 - do a program as usual i will copy
194:55 - codes from the previous program until we
194:58 - take the input
195:02 - i'll create a new class called binary
195:05 - search
195:11 - i change the name of the class
195:17 - here we need three variables
195:19 - instead of this we will have
195:22 - first index is zero
195:25 - as default and then
195:27 - last index in the beginning
195:30 - it will be
195:32 - one lesser than the length of array
195:35 - that is arr dot
195:38 - length minus 1
195:41 - and also we need middle index that is m
195:46 - here we take the input
195:48 - after taking the input user will also
195:51 - give the element to be searched so for
195:54 - that
196:05 - [Applause]
196:12 - then i assign the value
196:15 - hint s is equal to
196:18 - integer
196:19 - dot
196:21 - parse
196:22 - into
196:24 - vr dot
196:26 - d lineup
196:29 - now we need a loop to perform but we
196:33 - don't know the exact number of
196:35 - iterations it is going to happen
196:37 - so we cannot use for loop instead of
196:40 - that we will use while loop
196:45 - what condition here we can give
196:48 - the first index always will be lesser
196:50 - than
196:51 - last index
196:53 - and it will search until first index
196:55 - becomes last index that is both the
196:58 - index becomes same so we will give the
197:00 - condition here first index is lesser
197:03 - than or equal to last index
197:10 - first we need to find the middle index
197:12 - so middle index is equal to
197:16 - first index
197:18 - plus
197:19 - last index
197:21 - divided by 2
197:23 - do not forget to put this first index
197:26 - plus last index inside the bracket
197:28 - otherwise
197:29 - it will give other meaning that is l
197:31 - divided by 2 and then it will add with
197:33 - the first index
197:36 - then it will not work after finding the
197:39 - middle element we will compare
197:42 - element of that index for that we will
197:44 - give if condition if
197:48 - so which we are searching is s
197:50 - equal to equal to
197:53 - arr of that middle index
197:56 - m
198:00 - so if this is true
198:02 - we can print the index number where it
198:04 - is available so
198:06 - system dot out dot
198:09 - print line of
198:15 - element is
198:19 - available at
198:20 - index
198:22 - that is m is the index so m we will
198:25 - print
198:26 - and then
198:27 - we should have boolean type variable so
198:30 - we have not given that we will give here
198:34 - boolean
198:37 - flag is equal to false as default value
198:40 - so now it will become
198:42 - true
198:45 - flag is equal to
198:47 - true and then we can break the
198:51 - loop
198:53 - else if
198:55 - condition
198:56 - if search is
198:58 - greater than
199:00 - arr
199:02 - of m
199:04 - then what we do
199:08 - we will not search in the first part of
199:11 - that
199:12 - array so first index will become
199:15 - f is equal to middle index plus 1
199:21 - else
199:23 - automatically it will be
199:25 - s will be lesser than a or r of m
199:29 - so
199:29 - now what we do
199:32 - last index will be
199:36 - middle index minus 1
199:39 - so this will keep on repeating until
199:42 - f is equal to
199:43 - l
199:44 - so if it is
199:46 - false then it comes out of the loop
199:50 - now we can print
199:52 - if
199:55 - flag is equal to equal to false
199:58 - otherwise this we can also write
200:00 - flag is not equal to false so not we can
200:04 - write here
200:05 - then
200:06 - we will print
200:09 - system dot
200:10 - out dot
200:12 - printline of
200:15 - element
200:18 - not form
200:21 - so now we will close the
200:24 - method
200:25 - close the
200:26 - class
200:28 - let us compile
200:31 - no syntax error
200:33 - we will run this
200:36 - i will give
200:37 - 1
200:38 - 6
200:39 - 9
200:41 - 23 it should be sorted
200:43 - so we should give the greatest value
200:45 - only 67
200:48 - 86
200:51 - 90
200:53 - 12
200:57 - 1 56
201:00 - 178
201:02 - so which we are looking for
201:04 - maybe
201:05 - six
201:08 - so element is available at index 1.
201:14 - let us run once again
201:20 - 1 5
201:22 - 9 23
201:26 - 56
201:28 - 4 78
201:31 - 5 98
201:34 - 6
201:35 - 34
201:37 - 7
201:39 - 100
201:41 - 841
201:46 - so let us search for
201:49 - 841
201:52 - so element is available at index nine so
201:55 - that is one lesser than the
201:57 - length last index
201:59 - so in case it is in descending order
202:06 - how we can do it
202:08 - instead of
202:09 - s is greater than a or r of m we will
202:13 - just
202:14 - change into
202:15 - lesser than
202:17 - a r of m so automatically the whole
202:20 - process reverses
202:23 - let us check
202:25 - no syntax error
202:30 - i give 987
202:33 - eight seven six
202:35 - six five four
202:38 - five four three
202:40 - four three two
202:43 - two one
202:44 - zero
202:46 - one one two
202:49 - one one zero
202:50 - or not eight
202:53 - ninety five
202:55 - so let us search for
202:58 - four thirty two
203:03 - so it is at index 4 0 1 2 3 4.
203:10 - let us run once again
203:17 - 10
203:18 - 9
203:20 - 8
203:23 - 7
203:24 - 5
203:25 - 3
203:26 - 1
203:27 - minus
203:29 - 10
203:31 - minus 12
203:34 - minus 15
203:37 - so let me check minus 12
203:42 - it is available at index 8.
203:45 - so students
203:47 - it is clear
203:48 - now let us learn how to search in string
203:52 - type of array so i will change the array
203:54 - type
204:03 - so let me change this as six
204:08 - then when we take the input we will have
204:11 - only
204:12 - br dot read line up
204:15 - and then even this will be
204:18 - string type
204:21 - then taking the input will be br dot
204:23 - lead line off
204:27 - here in the condition instead of equal
204:29 - to equal to
204:30 - we will use
204:32 - dot compare to
204:34 - which gives the
204:36 - integer type
204:37 - output checks lexicographically
204:41 - string functions i have already
204:43 - explained in the previous lessons
204:45 - you can check there
204:48 - s dot
204:52 - compare to
204:55 - then this will be inside the bracket
204:58 - which is
205:01 - equal to equal to zero
205:05 - here again we will have
205:07 - the same thing
205:09 - when it is greater than
205:11 - 0
205:12 - greater than 0 is for
205:14 - ascending order of that array
205:17 - that is ascii value of first letter of
205:20 - the string which we are comparing is
205:22 - greater than the
205:24 - middle element
205:26 - so we will get the positive value which
205:29 - is greater than 0 so at that time we
205:32 - will not
205:34 - compare the first half of the array so
205:37 - it becomes first
205:39 - index will be middle index plus one
205:43 - in case it is descending order array
205:45 - then we will change the symbol to lesser
205:48 - than 0
205:50 - let us compile this
205:57 - let me give
206:01 - anant
206:15 - is
206:20 - joshua
206:23 - so we will search for
206:24 - issuer
206:29 - it is available at index 4 so 0 1 2 3
206:32 - and 4
206:34 - 5 is the last index
206:40 - in case it is
206:41 - in descending order we change this into
206:44 - lesser than symbol
206:46 - compile
206:50 - i give
206:51 - windows
206:53 - unix
206:56 - office
206:59 - microsoft
207:03 - excel
207:07 - dos
207:10 - let me check for unix
207:14 - so element is available at index one
207:18 - here we have given
207:20 - ten elements
207:21 - it remained we didn't change at all so
207:23 - it was six right we can give six
207:28 - i should give in the descending order
207:31 - so let me give
207:33 - hp
207:37 - logitech
207:40 - lenova
207:44 - epson
207:48 - del
207:49 - acer
207:51 - let me check for del
207:56 - so element is available at index 4 it is
207:59 - right
208:01 - students let us revise the points once
208:03 - again
208:43 - thank you students