00:00 - hello students in the previous classes
00:03 - we have seen
00:04 - keywords identifiers and literals in
00:07 - this class we are going to see
00:09 - operators and also delimiters in the
00:11 - programming context
00:12 - operators are backbone of any
00:16 - operation or function
00:19 - what are operators they trigger some
00:22 - computation
00:23 - when it has been applied to the variable
00:25 - or constant when we talk about
00:27 - operators we also need to know about
00:29 - operands
00:30 - operands are nothing but variables or
00:32 - values
00:34 - here for example a plus b we will take
00:37 - a plus symbol is the operator which
00:40 - operates a and two both operands
00:43 - similarly if we take
00:45 - 7 multiplied by 5 and the multiplication
00:48 - symbol is
00:49 - operator and then 7 and 5 are operands
00:52 - there are different types of
00:53 - operators arithmetic operators
00:56 - assignment operators
00:58 - relational operators identity operators
01:01 - membership operators shift operators
01:05 - logical operators and bitwise operators
01:08 - we will see one by one with examples
01:12 - arithmetic operators are nothing but the
01:14 - operators which we
01:16 - normally use in mathematics first here
01:19 - we are having
01:20 - plus that is addition for example 5 plus
01:24 - 20
01:24 - results 25 similarly minus that is
01:28 - subtraction
01:29 - 11 minus 1 which gives 10 here
01:32 - instead of multiplication symbol in
01:34 - mathematics
01:35 - in computers always we use star symbol
01:39 - so 100 multiplied by 5
01:43 - results 500 and then
01:46 - exponent exponent is nothing but
01:49 - the power so to get the power we will be
01:52 - having 2 times
01:53 - the star symbol for example
01:56 - 5 star star 2 that is
02:00 - 5 to the power 2 so that is 5 into 5
02:04 - 25 it will be resulting division first
02:07 - operand divided
02:08 - by second operand here we should note
02:10 - that
02:11 - the result is given with decimal places
02:14 - for example here 44 divided by 8 when we
02:17 - divide we get 5.5
02:20 - addition subtraction multiplication all
02:22 - these it depends
02:23 - how we give the input if we are giving
02:26 - input with the decimal place and then
02:28 - output also will be with a decimal place
02:30 - here next we are having modulus which is
02:33 - percentage symbol
02:34 - this percentage symbol is an operator
02:36 - which returns the remainder
02:38 - when first number is divided by the
02:40 - second number for example
02:42 - 62 mod 6 that means
02:45 - 62 10 times it goes and then 2 is the
02:49 - remainder
02:50 - it doesn't take a decimal form and then
02:53 - it returns 2 as the
02:55 - result next we are having floor division
02:57 - flow division is nothing but
02:59 - it divides and then leaves the decimal
03:02 - places
03:03 - and then gives only the integer value
03:05 - for example
03:06 - 58 floor division by 10 actually if it
03:10 - is normal division it will be 5.8 it
03:12 - will not take
03:13 - 0.8 and then it gives only 5 as the
03:16 - result
03:17 - here all the operators used two operands
03:20 - python also provides an operator where
03:23 - one operand can be used
03:25 - that is called unary operator
03:28 - so there are two unary operators that is
03:32 - plus
03:32 - and minus when we say plus that is also
03:35 - a binary operator
03:37 - so we always call it as unary plus for
03:40 - example
03:41 - a is equal to 10 then plus a
03:44 - that results plus 10 but we cannot
03:47 - differentiate it
03:48 - but at the same time unary minus
03:51 - so if a is 10 if we say minus
03:55 - a see now it negates the value that
03:58 - means it becomes -10
04:00 - all the arithmetic operators are also
04:02 - binary operators
04:04 - that means all these requires two
04:07 - operands to operate
04:09 - next we will see relational or
04:12 - comparison operators
04:14 - relational operator determines the
04:16 - relation between two operands
04:19 - and results as boolean literal that
04:21 - means it will produce a result as true
04:24 - or
04:24 - false as it compares two operands it is
04:27 - also
04:28 - called comparison operator
04:31 - we are having totally six operators here
04:34 - first one it is lesser than this symbol
04:38 - in the keyboard you can find just above
04:40 - the space bar
04:42 - in the right side see the point is
04:44 - facing left side
04:46 - the first operand that is left side
04:48 - operand should be smaller
04:50 - and the right side operand should be
04:53 - greater
04:53 - it checks whether the left operand is
04:56 - smaller than the
04:58 - right operand for example 6 lesser than
05:01 - 25
05:02 - so it is correct so it will produce true
05:04 - as a result
05:06 - next we are having greater than symbol
05:08 - the left
05:09 - side operand should be greater than the
05:12 - right side operand
05:13 - for example 102 is greater than
05:16 - 50 this is also correct so it results
05:19 - true then here we are having
05:22 - lesser than or equal to it should be
05:25 - lesser than
05:26 - r equal for example 35 is lesser than or
05:29 - equal to 30
05:30 - it is not correct so it will be
05:32 - resulting in false
05:34 - next one greater than or equal to 71
05:38 - is greater than or equal to 75 so this
05:41 - is
05:41 - also not correct so it produces false
05:46 - and then equal to equal to 2 times v u
05:50 - it checks whether both the operands are
05:53 - equal
05:54 - for example 100 is equal to equal to 100
05:57 - video
05:58 - so it is correct so it produces true as
06:02 - the result
06:03 - see here you need to remember if you are
06:05 - giving one single time equal to mark it
06:08 - assigns the value to the variable
06:10 - two times you give equal to together and
06:12 - then it becomes the relational
06:14 - operator it checks whether both the
06:17 - operands are equal or
06:19 - not next we are having not equal to
06:22 - this is written using the exclamatory
06:25 - symbol and then
06:26 - equal to mark it checks whether both the
06:28 - operands
06:29 - are not equal to 18 is not equal to 20
06:33 - that is true now let us go to python
06:35 - ideally
06:36 - let us check all the arithmetic
06:37 - operators first we will have addition
06:39 - first operand i give
06:41 - 20 and the operator plus i give
06:44 - 30. see we are having two operands so
06:46 - this is binary
06:48 - operator so 50 is the result similarly
06:50 - subtraction and
06:51 - multiplication then we'll check the
06:53 - exponent that is
06:55 - 5 2 times star i give that is 5 to the
06:57 - power
06:58 - and then 3 i give so 5 into 5 into 5 125
07:02 - we will get as a result
07:04 - next we will have the division operator
07:06 - for example i give
07:08 - 40 divided by 10
07:11 - unlike others we will have with decimal
07:15 - place
07:15 - next modulus so that is a percentage
07:18 - symbol
07:19 - for example if i give 12 modulus 10
07:23 - it will produce 2 as the result as it is
07:26 - going to give the remainder
07:28 - now floor division 59 two times
07:32 - division symbol i give and then i give
07:34 - five normally
07:35 - if it is ordinary division and then it
07:37 - will say with the point that is 11.8
07:41 - but here we will get only 11. all these
07:43 - are using two
07:44 - operands so binary operators now we will
07:47 - see the
07:48 - unary operator where it will use only
07:50 - one single
07:51 - operand to operate i say a is equal to
07:54 - 20
07:55 - and then i say plus a we will have 20
07:58 - only
07:58 - but as plus 20 the plus is not shown in
08:01 - the result
08:02 - so we can't see the difference here at
08:04 - the same time if we give
08:06 - minus a we will be able to see the
08:08 - difference
08:09 - it will show minus 20 as the result
08:12 - so as we are using only single operand
08:15 - it is called
08:16 - unary operator we call it as unary plus
08:20 - and unary minus next we will see some
08:22 - examples for
08:23 - relational operators 5 is greater than
08:26 - 10 is it true or false it is not correct
08:30 - so it will be false
08:34 - 65 is lesser than 100 is
08:38 - true 70 is greater than or equal to 70
08:42 - so it checks even the equality so it is
08:45 - true
08:46 - 83 is lesser than or equal to
08:50 - 100 so this is also true and then
08:53 - checking only the equality 22
08:56 - is equal to equal to 22 so it is true
08:59 - right
09:00 - at the same time 23 is equal to equal to
09:02 - 21 if i give it is not true
09:04 - then not equal to is using exclamatory
09:07 - mark i give
09:08 - 10 is not equal to 10 so it is false
09:12 - assignment operators assignment operator
09:15 - is
09:16 - equal to symbol this always assigns the
09:19 - value
09:20 - to the variable which is left side to
09:23 - the
09:23 - operator for example we are having m is
09:26 - equal to 5
09:27 - value 5 is assigned to variable called
09:30 - m assignment operator equal to can be
09:33 - combined with other operators
09:35 - which assigns new result to the same
09:38 - variable for example here
09:40 - m plus equal to 2 the meaning of this is
09:44 - m is equal to m plus 2 so what happens
09:47 - 5 plus 2 is assigned to the variable
09:51 - m similarly we can also combine with
09:54 - other operators like subtraction
09:58 - multiplication and then also exponent
10:01 - and division modulus and then floor
10:04 - division
10:05 - this assignment operator can also be
10:07 - combined with
10:08 - other operators that is other than
10:10 - arithmetic operators
10:12 - let us understand by executing it now
10:14 - let me consider
10:16 - m is equal to 25 so if i give
10:20 - m plus equal to 20 then the new value of
10:24 - m will be 45 so
10:27 - the value is over written as 45 here let
10:30 - us have the same value
10:32 - let me give m minus equal to 10 so now
10:36 - m will be 35 similarly
10:40 - m divided by equal to 5
10:43 - so 35 divided by 5 is 7
10:46 - now let us get the exponent m star
10:50 - star equal to 2 so 7 7's are 49 will be
10:54 - the
10:54 - answer no see as before i told
10:58 - 7.0 is there 7.0 into 7.0 it gives 49.0
11:04 - if it is only 7 without a decimal
11:08 - point there then it will give 49 alone
11:10 - without
11:11 - 0.0 let us assign some other value to m
11:15 - m is equal to 100 now
11:18 - m floor division equal to
11:21 - 22 if i give the result will be only the
11:24 - integer part not the fractional part
11:26 - logical operators there are three
11:29 - logical operators
11:31 - the first one is and the second one is
11:34 - r and the other one is not these logical
11:38 - operators
11:39 - works on relational expressions as well
11:42 - as
11:43 - numbers or strings are sequence
11:46 - if we check with the relational
11:48 - expressions
11:50 - the end operator evaluates true
11:54 - if both the conditions are true for
11:56 - example i have
11:58 - two expressions with logical operator
12:01 - and
12:03 - 5 is greater than 1 and
12:06 - 10 is lesser than 50. see if you take
12:09 - 5 greater than 1 that is true
12:12 - and 10 is lesser than 15
12:15 - that is also true so if both the
12:18 - expressions
12:19 - are true then this end logical operator
12:23 - results with true next r operator
12:27 - either one of the expression is true
12:29 - then
12:30 - it will be evaluating as true
12:34 - so for example 5 is equal to equal to 6
12:37 - see
12:37 - actually this is not correct so that
12:40 - means
12:40 - false 5 is lesser than 15 that is true
12:44 - so false or true it gives
12:47 - true as the output not operator see not
12:51 - operator complements the operand not
12:54 - operator
12:54 - works with only single operand 5 equal
12:57 - to equal to 6 it checks whether 5 is
12:59 - equal to equal to 6 or not so this is
13:01 - false so
13:03 - not false that is complements its it
13:05 - becomes true
13:06 - we will see all the combinations as
13:08 - truth table
13:10 - for and here false and false
13:14 - results false false and
13:17 - true is false true and false
13:21 - is also false true and true only becomes
13:25 - true so either one of the expression is
13:28 - false
13:28 - it gives false only as the output so
13:31 - this is
13:32 - and operator now if you see
13:35 - r operator either one of that is true
13:38 - and then it results true
13:40 - false and false both are false so it is
13:42 - false
13:43 - false and true so there is one true so
13:45 - it is true
13:46 - true and false again one true is there
13:48 - so it is true
13:49 - true and true also true not operator so
13:52 - if
13:53 - a is false and then it gives true as a
13:55 - result if
13:56 - a is true and then false is the result
13:59 - now next we will see how it works on
14:01 - numbers strings
14:03 - and sequence see here
14:06 - numbers are strings or sequence
14:09 - has either it is true value or
14:13 - false value don't take it as a literal
14:16 - as a constant
14:17 - true or false you consider here as that
14:20 - value which is true value or
14:23 - false value to represent it i have given
14:26 - true and false completely in the small
14:29 - letters
14:30 - known type you know that is always false
14:33 - boolean false letter is there that is
14:36 - also false value
14:38 - if you take number so that is 0
14:41 - or 0.0 otherwise
14:44 - imaginary number that is 0j if you take
14:47 - any of this is false value
14:50 - any empty sequence that is false value
14:53 - any empty mapping so that is dictionary
14:56 - we will see
14:56 - later about that just you remember now
14:59 - that empty mapping also falls all values
15:03 - other than these are considered as true
15:05 - values
15:06 - you please remember this now let us
15:08 - check how it works
15:10 - on and operator if a is
15:13 - false and b is false both
15:16 - are having as false value and then
15:20 - a is returned as output false value
15:23 - and true value so that is if a is
15:26 - false and b is true and then the value
15:31 - a is returned if a is true
15:34 - and b is false and then b is returned
15:38 - if a is true and b also true
15:42 - and then b is written see remember here
15:45 - false and false gives a means whatever
15:48 - is residing in false that only
15:52 - false and true it gives false as a
15:54 - result
15:55 - because we already learned false and
15:58 - true
15:59 - is false right so the value in a
16:02 - question will be returning
16:04 - similarly true and false it is there
16:08 - it gives false only as the result if
16:11 - true
16:11 - and true then be as a result you also
16:14 - need to remember
16:16 - that if first value is true
16:20 - then only it will evaluate the second
16:23 - value whether it is true or not
16:25 - even the syntax is wrong it will not
16:28 - check at all
16:29 - if false is found as the first value
16:33 - it returns immediately as false it will
16:35 - not
16:36 - check whether the second value is true
16:38 - or false
16:39 - now let us check r if a is false and b
16:42 - is false
16:43 - the value b is returned if a is false
16:47 - and
16:47 - b is true either one of this true is
16:50 - true
16:50 - to be returned so automatically b is
16:52 - returned
16:54 - if a is true and b is false
16:58 - a is been returned that is true value
17:00 - and then
17:02 - a and b both are true and then a is been
17:04 - written
17:05 - not it automatically complements
17:10 - so false values there it gives
17:14 - the true as a literal you remember this
17:16 - is not as the value
17:18 - it gives as a literal
17:21 - similarly if true value is available
17:23 - there and then it gives false
17:25 - if you are not clear still by these
17:28 - examples you will get to know
17:30 - how it works take this example
17:33 - open and close single quotations so that
17:36 - means
17:36 - nothing is inside it is an empty
17:39 - sequence
17:40 - and operator and pin is inside the
17:43 - single quotation that means it has some
17:45 - value
17:46 - so it is true value false value
17:50 - and true value so false and true means
17:54 - it will be returning false that is yes
17:57 - value so yes values single quotation
18:00 - open and close it returns that in
18:02 - output the second example here
18:05 - something given inside the quotation
18:07 - that is true value
18:09 - here also it is true value true value
18:11 - and operator true value
18:14 - true and true it evaluates
18:17 - b's value so b's value here whatever is
18:20 - there is python there
18:21 - so python has been returned here you can
18:24 - see open and close curly brackets
18:26 - which denotes a dictionary empty
18:30 - dictionary
18:30 - so that means it is false value
18:33 - similarly
18:34 - 0.0 is also false value
18:37 - it is false are false
18:40 - so both are false it returns
18:44 - the value which is b so that is 0.0 is
18:48 - been returned
18:50 - now not 10 so 10 is some value so that
18:53 - is true value right
18:54 - so not true that becomes
18:58 - false let us also execute and check so
19:02 - that
19:02 - it sets in your mind very clearly now
19:05 - let me take 10 which is true value and
19:09 - i have book as a string so this is also
19:13 - true value
19:13 - true value and true value will be
19:16 - returning
19:16 - the value which is at position b that is
19:19 - book is going to be the output
19:21 - now i am having 0.0
19:24 - and 75 so end operator has been used
19:28 - this is false value and then 75 is true
19:31 - value
19:32 - when it is false it will not care about
19:35 - what is their next operand so
19:37 - automatically it gives
19:38 - 0.0 as the value and then now
19:42 - 100 and i have empty quotation so which
19:46 - is true
19:48 - if in case it is true and then it goes
19:50 - to the
19:51 - second operand to check whether it is
19:53 - true value or not
19:54 - so now it is false value it will be
19:56 - returning the false value
19:58 - i have here 0 j that is false value
20:02 - and then r 25 which is true value
20:06 - here r operator is there the second
20:09 - value which is 25 is true
20:12 - so automatically it will be returning 25
20:14 - as output
20:15 - now i am having 1000 r
20:19 - i have empty sequence so this is true
20:22 - value
20:23 - our false value it will be returning
20:26 - the true value that is thousand next i
20:29 - have
20:30 - computer in the quotation which is true
20:33 - value
20:34 - r and then i have mobile here
20:37 - so true value or true value
20:40 - it gives a s value that is computer
20:44 - next not i have not 50 50 is some value
20:50 - so that is true value
20:51 - so not true will become false
20:56 - next we are having bitwise operators
20:59 - bitwise
21:00 - operators are similar like logical
21:02 - operators
21:03 - but here we are having four operators
21:06 - these operators
21:07 - works on binary first we are having and
21:11 - we call it as bitwise and for example
21:15 - if a is equal to 1 and b is equal to 0
21:19 - a and bitwise b
21:22 - gives false that is 0 that is
21:26 - a and b true and false
21:29 - gives false but as
21:32 - binary output that is 0
21:35 - next we are having bitwise inclusive r
21:38 - normally we call it as bitwise r if a is
21:41 - equal to 1 and b
21:42 - is equal to 0 same value we will retain
21:45 - here also
21:46 - a r b will result in 1
21:50 - next bit wise exclusive r that is
21:53 - xr here if both the operands are same
21:57 - and then it results 0 otherwise
22:00 - it gives 1 here
22:03 - a xr b
22:07 - 1 xr 0 this will result in 1.
22:12 - next we are having bitwise complement
22:15 - it is also called bitwise ones operator
22:19 - for a the output will be
22:23 - minus of a plus 1 here
22:26 - bitwise complement operator b is given
22:30 - that is 0
22:31 - it will be resulting in minus 1. here i
22:34 - have a truth table for you
22:36 - first let us see for and if
22:40 - a is 0 and b is 0 a and b
22:43 - is 0 0
22:46 - and 1 results in 0 1 and 0 also results
22:50 - in
22:50 - 0 1 and 1 that is true and true will be
22:54 - giving true that is one
22:57 - next a is 0
23:00 - b 0 then a r b is going to be 0
23:05 - 0 and 1 is 1 1 and 0 is
23:08 - 1 1 and 1 also 1
23:11 - next x are 0
23:14 - and 0 so that is both are similar it
23:17 - results in 0
23:19 - 0 and 1 it is 1
23:22 - 1 0 again 1 1
23:26 - and 1 is similar so it returns 0
23:30 - bitwise complement 0 complements
23:33 - as 1 1 is complemented as 0
23:37 - next we are having identity operators
23:39 - there are two identity operators one is
23:42 - ease and other one is e is not
23:46 - is if both the operands are pointing
23:49 - same memory location
23:51 - returns true for example
23:54 - let us have a is equal to 5 b is also 5
23:57 - and then now a is b so both are having
24:01 - same value that is same memory location
24:03 - it denotes
24:05 - so it will result as true is not
24:08 - is opposite to that if both the operands
24:11 - are not pointing the same location
24:14 - and then it will be giving false as
24:17 - output next we are having membership
24:19 - operators
24:20 - here also we are having two operators
24:23 - one is
24:24 - in and then other one is not in
24:28 - in checks whether the variable is in
24:30 - sequence
24:31 - if it is there and then it will be
24:33 - giving true as
24:35 - output see here app that is a string
24:39 - in application see if you check app is a
24:42 - part of
24:43 - application string so that is true
24:47 - next we are having not in it checks
24:49 - whether the variable is
24:50 - not in the sequence for example
24:53 - text not in textbook see actually text
24:57 - is a part of textbook so it is false
25:01 - next we are having shift operators this
25:04 - also
25:05 - works with the binary
25:09 - two angle brackets together mention
25:12 - the operand which is left side is
25:15 - been moved to the right by the number of
25:19 - bits specified by the
25:20 - right operand for example i have 1
25:23 - 0 0 1 binary number right shift operator
25:28 - and then 2 this 2 says how many digits
25:32 - the number moves right side so here
25:35 - it will move 2 digits that means 0
25:39 - and 1 last 2 digits will be moved
25:42 - so no further places available there so
25:45 - it is been removed actually then it
25:48 - becomes only one
25:49 - zero similarly lift shift operator
25:52 - shifts the binary number to the
25:56 - left side by number of digits specified
25:59 - in the
26:00 - right side for example same 1 0 0 1
26:04 - but it shifts 3 digits to the left side
26:07 - that means 1 0 zero one is moved
26:11 - three digits so where the empty places
26:14 - are there
26:15 - zeros are filled so now if you see
26:18 - automatically
26:19 - the value changes like one zero zero one
26:22 - zero zero 0 i will demonstrate all these
26:25 - operators
26:25 - using python ideally now
26:29 - bitwise and operator it works on
26:32 - binary numbers we know so first operand
26:34 - iq
26:35 - using 0 b and then
26:38 - 1 and operator 0
26:42 - b and 1 so 1 and 1
26:45 - will be resulting in 1 the output is
26:48 - with
26:48 - decimal number system let us see one
26:52 - more example
26:53 - 0 b 0
26:56 - and 0 b 1 so it should be result in
27:01 - 0 now let us see
27:04 - r operator 0 b 0
27:09 - r 0 b 1
27:12 - it will be resulting in 1 0 b
27:16 - 1 r
27:19 - 0 b 0 so it will be resulting in
27:24 - 1 again let us see now
27:28 - x r if it is similar and then
27:31 - 0 is the output so 0b 1
27:34 - xr then 0
27:37 - b 1 so it will be resulting in 0
27:42 - if it is 0 and 1 let us check 0 b
27:46 - 0 bitwise xr 0 b
27:50 - 1 so both are different now it will be
27:52 - resulting in 1.
27:54 - now let us see bitwise complement if i
27:56 - see bitwise complement
27:58 - of 0 it will be 1 next
28:02 - we will see identity operators that is
28:05 - ease
28:05 - and e is not if address of the memory
28:08 - locations
28:09 - are same and then it will be resulting
28:12 - in true i said
28:13 - instead of putting the value in the
28:15 - variable
28:16 - it denotes the address this i will
28:18 - explain you in the
28:20 - future classes in detail for now
28:23 - i just say a is equal to 10
28:27 - and also b is equal to 10 now the
28:30 - address of
28:30 - a and b both the variable will be
28:32 - pointing to the
28:34 - same memory location so it will be
28:37 - resulting in true if i give
28:40 - a is b so that is true
28:43 - similarly if i say a is
28:47 - not b then it will be giving false
28:50 - next we are having membership operators
28:53 - it is nothing but
28:54 - in and not in python
28:58 - in python textbook see python is there
29:01 - right so it will be giving true
29:03 - now if i say py
29:06 - not in python
29:11 - so it is false shift operators
29:14 - this also works on binary 0 b
29:19 - 1 0 0 1 0 i give
29:22 - and then shift operator
29:26 - right side shifting two digits
29:30 - so at last one and zero will be removed
29:34 - only
29:34 - one zero zero will be there but it will
29:37 - be showing the output in the
29:39 - decimal integer we will just
29:43 - convert into binary and check binary of
29:46 - 4 so it is 1 0 0
29:50 - you can see 1 0 0 before that 0 b
29:53 - denotes binary number now left shift
29:56 - operator
29:58 - 0 b i say 1 1 1
30:01 - 1 again 0 1 shifting three digits
30:04 - so three zeros are added to the right
30:07 - side that means
30:08 - it moves three digits left side the
30:11 - empty spaces are filled with zeros
30:14 - so now the answer is 488 if we check
30:18 - what is the equivalent binary then we
30:21 - will come to
30:22 - know binary of 488 the previous number
30:26 - with that
30:26 - three zeros added in the right side so
30:29 - that means the number moved
30:31 - to the left side three digits at last
30:34 - the tokens we have delimiters delimiters
30:38 - are also known as
30:39 - punctuators or separators most of the
30:42 - time
30:43 - they give the structure to the
30:45 - programming language
30:46 - the most commonly used delimiters of
30:49 - python programming language
30:51 - are parenthesis square brackets curly
30:55 - brackets
30:56 - all these used for grouping and then dot
30:59 - comma semicolon colon at the rate
31:02 - all these are punctuation marks even
31:05 - arithmetic operators and
31:07 - assignment operators even bitwise
31:09 - assignment operators
31:11 - all these are also delimiters
31:14 - usage of these delimiters will
31:18 - understand better
31:19 - when we are doing the programming
31:22 - students i hope you understood all the
31:25 - topics clearly
31:27 - keep watching my channel learn more
31:30 - thank you