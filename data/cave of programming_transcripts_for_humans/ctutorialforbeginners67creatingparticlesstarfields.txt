With timestamps:

00:00 - [Music]
00:12 - [Music]
00:17 - hello this is John from Cave of
00:20 - programming. comom in this tutorial
00:23 - we're going to take a look at creating
00:26 - particles um represented by pixels that
00:29 - we can plot on our screen so at the
00:32 - moment I've got this uh window which
00:35 - just displays a block of color and
00:37 - slowly Cycles through um different
00:41 - possible
00:42 - colors uh so I'm going to use that later
00:44 - on I'm going to save that code um for a
00:47 - while but what I want to do now is
00:49 - Define a particle class and display
00:52 - those particles on the
00:55 - screen so let's let's go to eclipse and
00:58 - um let's create a new class CL here so
01:00 - I'll right click project go to new class
01:04 - and I'll call this particle and I I'll
01:07 - keep it in this Cave of programming
01:10 - namespace um I I don't know if I'll need
01:14 - a Constructor and Destructor but let's
01:16 - let's define them because there
01:18 - certainly no harm in having them let's
01:20 - click
01:21 - finish um I'm also going to Define
01:24 - another class here which I'm going to
01:26 - call swarm and swarm is going to manage
01:30 - a collection of particles so let's um
01:33 - again I'll give it a constructed
01:34 - Destructor I'll call it swarm and put it
01:37 - in this Cav programming Nam space
01:40 - again so we've got two new classes here
01:43 - now let's go to particle and let's start
01:46 - thinking about what kind of properties a
01:48 - particle will have so we're going to
01:51 - Define some private instance variables
01:55 - here and um I suppose the most
01:58 - fundamental uh thing about the state of
02:00 - a particle is that it needs an X and Y
02:03 - position on the
02:06 - screen and now I'm going to make these
02:08 - double so let's say double and I'll call
02:11 - this mcore x m to say mcore to say that
02:14 - it's um a member variable just to make
02:17 - that clear although that's that's
02:19 - certainly not um absolutely necessary
02:23 - and let's have a Double
02:25 - mcore Y now the reason I'm making the
02:28 - double is because even though on on the
02:32 - screen um we're dealing with individual
02:34 - pixels so the X and Y location are
02:37 - always uh always
02:39 - integers I want to be able to change
02:42 - these values gradually and um then just
02:45 - sort of round them off to the nearest
02:47 - pixel
02:48 - position so if if I want to change for
02:51 - example the x value gradually by adding
02:53 - some small number to it like .01 every
02:56 - time the screen refreshes of course I
02:58 - can't do that if it's an integer so
03:00 - although we have to display it at kind
03:02 - of an integral position at a particular
03:05 - pixel it's its position um may be um
03:10 - maybe somewhere between two pixels we
03:12 - just kind of round it off uh to the
03:15 - nearest pixel when we actually display
03:17 - it but having a double position allows
03:19 - us to move it conceptually bit by bit so
03:24 - and that avoids having to move it by an
03:27 - entire pixel every time we move it um so
03:31 - we can achieve more of an illusion of
03:33 - smooth
03:36 - movement uh so we've got um X and Y
03:40 - that's that's probably all we really
03:43 - need to to start with just an X and Y
03:47 - position for the particle as far as I
03:50 - can think um at the
03:52 - moment let's go to the particle
03:56 - Constructor here and um in the
04:01 - Constructor I could initialize the X and
04:04 - Y values really so yeah let's let's
04:08 - maybe do that what I'm going to do is
04:10 - I'm going
04:11 - to
04:14 - include standard libh standard li.
04:19 - because I want to use a function called
04:23 - Rand like that and uh Rand returns a
04:27 - random number between not and a constant
04:30 - called
04:32 - randor
04:34 - Max so uh this this returns an integer
04:37 - and this is an integer I believe so this
04:40 - division would wouldn't really make any
04:41 - sense but if I multiply Rand by a double
04:46 - or if I cast it to a double like that
04:49 - this will then return as a random number
04:51 - between note and
04:54 - one now what I'd really like to do is um
04:59 - i' I'd like to have the particles kind
05:02 - of move within some um some virtual
05:05 - space but I don't want that virtual
05:07 - space to be tied to the screen
05:08 - dimensions because then if I change the
05:11 - time the if I change the size of the
05:13 - screen or something then um the way our
05:17 - our program works has fundamentally
05:19 - changed I want to have the particles
05:21 - move around in some space of a fixed
05:24 - size some mathematical space and then
05:26 - we'll map that later onto the screen
05:30 - so I'm going to initialize the
05:33 - exposition of the particle to somewhere
05:36 - between let's say arbitrarily minus1 to
05:39 - + one so we can imagine that the
05:42 - particle inhabits a plane with uh
05:44 - cartisian coordinates if you've ever
05:46 - done any maths were um the X minimum X
05:50 - and Y coordinates are both minus one and
05:52 - the maximum possible X and Y coordinates
05:55 - are both plus one and if if you've never
05:58 - studied C cian coordinates you might
06:00 - want to just have a look at a page on
06:03 - them you know just for uh sort of 10
06:05 - minutes or something just to get the
06:07 - idea but they they're relatively
06:10 - simple so um if I set um this is going
06:14 - to set x equal from equal to something
06:16 - from n to one but I want it to be from
06:19 - um minus one to + one so let's let's
06:23 - firstly maybe work on the Range there so
06:26 - if I multiply Rand by 2.
06:30 - not so now we don't need the cast a
06:33 - double because this bit is is a double
06:35 - now let's we could put brackets around
06:37 - that just to be doubly short so to speak
06:40 - uh so this should give us a number in
06:41 - the range not to plus 2. not and if I
06:46 - then subtract one from that I think I'm
06:50 - right in saying that we've now got um a
06:54 - range of minus1 to plus
06:58 - one so for first firstly I increased the
07:00 - range there so that instead of being not
07:03 - to one it was not to two then I
07:05 - subtracted one which gives us minus one
07:08 - to+ one if I've if I've got this correct
07:11 - what's the U warning there bad character
07:13 - sequence sometimes I find this happens
07:16 - and I think I'm somehow typing um
07:19 - invisible characters that it doesn't
07:21 - like I'm not sure how but yeah that
07:24 - that's fix that I just had to delete
07:26 - sort of underlined the space there and I
07:28 - just had to delete it and and put the
07:30 - space back in again maybe I hit the ALT
07:32 - key by mistake or something but it
07:34 - doesn't seem to stop it compiling though
07:36 - let's let's do the same with um with Y
07:39 - as well so let's set y equal to some
07:42 - random number from minus one to +
07:46 - one so that's our particle covered now
07:50 - usually what I do is I would um Supply
07:55 - like a get method for X and Y but we're
07:58 - going to have to deal with lot of
08:00 - particles and we're going to have to get
08:02 - X and Y values over and over again every
08:04 - time the screen refreshes for a huge
08:06 - number of particles so perhaps it's
08:08 - better to Simply um to Simply make these
08:12 - values public and access them directly
08:16 - that breaks
08:17 - encapsulation but um we're forced in
08:21 - games and simulations and things like
08:24 - that often to uh adopt a programming
08:27 - style that's not ideal for the sake of
08:30 - efficiency so it might be better to make
08:32 - this public an alternative thing that
08:34 - you you often see done is instead of
08:37 - explicitly declaring this as public what
08:39 - we could do is by default in a class if
08:42 - I write it like this these will be
08:45 - private by default but there's also a
08:48 - thing called a struct in C++ and if I
08:51 - just change this from a class to a
08:53 - struct the only difference between a
08:54 - class and a struct is that the members
08:58 - are public by default so um if I do this
09:04 - then we know that the intention is to
09:06 - access these directly and that they are
09:09 - now public so maybe I'll do that so
09:11 - that's the only difference between a
09:12 - class and a stru and that's the sort of
09:14 - thing they ask you on interviews as well
09:16 - is that by default in a class member
09:19 - variables are private if you don't
09:20 - specify an access modifier and instruct
09:24 - they're public by default and I'm just
09:26 - making them public for the sake of
09:28 - efficiency although ideally we wouldn't
09:31 - do
09:32 - that so that's my particle covered um I
09:35 - also need to initialize this random
09:39 - number generator because I I think it
09:42 - return as far as I know it Returns the
09:44 - same random numbers in sequence every
09:46 - time and I'd like it to return different
09:48 - ones every time we can do that by going
09:53 - um for example to main here and um if I
09:58 - include
10:00 - here
10:03 - include standard lip again standard li.
10:06 - H and um using namespace
10:11 - standard um I've missed out there D
10:14 - there then I can call a function here
10:16 - called
10:17 - srand and uh
10:20 - srand seeds the random number generator
10:23 - with a number uh which makes it produce
10:26 - a different sequence of random numbers
10:27 - every time and uh to for the seed number
10:31 - so I need to supply it with some number
10:32 - to seed it with I can use a function
10:34 - called
10:35 - time which is found in time. H I think
10:40 - but it's probably already included so
10:42 - we've got stlh there's no harm in
10:45 - including time. H if it exists it does
10:49 - kind of change its name from uh
10:51 - implementation to implementation uh
10:54 - let's just check what the error is here
10:56 - so um there's something there it doesn't
10:58 - like
10:59 - I'm just going to check um the program
11:03 - that I implemented previously in case
11:05 - I've got this slightly wrong somehow
11:08 - let's just check where I seeded my time
11:12 - so somewhere in here I should have
11:18 - seeded my
11:21 - um random number
11:23 - generator oh yes there we
11:26 - go ah yes so time the time function
11:29 - takes null um it it can return the time
11:34 - into a struct that you pass it if I
11:36 - remember rightly and this this might be
11:38 - wrong so don't take this as gospel uh
11:40 - but we don't want it to do that we just
11:42 - want to we don't want it to return
11:43 - anything other than um the number of um
11:48 - milliseconds I think it is since
11:51 - 1974 or whatever it is something like
11:54 - that to be honest this is one thing that
11:57 - I've got so used to typing that that
11:59 - I've um stopped wondering what it
12:02 - actually does let's let's close some of
12:05 - these no but um you can certainly Google
12:09 - for that if you're interested but
12:11 - basically this formula here seats our
12:13 - random number generator okay so let's
12:15 - let's leave that um and go back to our
12:19 - our program
12:20 - okay I'm going to close everything
12:22 - actually so that I don't get confused
12:25 - and open them again here so that's
12:27 - that's not even the right program here
12:29 - we go so particle.
12:31 - H um Okay so we've got our particle now
12:34 - and um now I want to class that
12:37 - organizes the particles because we're
12:39 - going to have to deal with a massive
12:40 - load of particles and um I I'd like some
12:44 - class that can organize them all so um
12:47 - I've got my swarm here that I've
12:51 - created and uh I'm going to give this a
12:54 - private member variable here let's say
12:58 - that it's
12:59 - uh well if I include here if I
13:04 - include
13:06 - um uh double quotes because it's a local
13:08 - include file particle. H and I'm I'm I'm
13:12 - using this C programming
13:15 - namespace then I can say in here
13:19 - particle pointer let's call this mcore P
13:25 - particles uh M because it's a instance
13:28 - variable p because it's a
13:30 - pointer then in my Constructor here
13:34 - let's go
13:35 - to swarm dot um
13:40 - CPP probably this is a reasonable place
13:42 - to initialize this let's set that equal
13:45 - to
13:47 - new um new particle
13:51 - array and how many particles do we want
13:54 - well I can define a constant let's call
13:56 - the constant n particles
14:01 - and uh let's go to swan. H and make that
14:06 - a I'll make it public just in case we
14:08 - need to use it outside of swarm yes we
14:12 - probably will in fact let's say n
14:14 - particles and let's make that a con
14:18 - static int and set it equal to some
14:22 - number like um 5,000 you might want to
14:24 - make this lower if your pro if your
14:26 - computer's a bit slow but if it is
14:28 - you'll find out later on but let's let's
14:30 - try um 5,000 to start with so we're
14:33 - going to have 5,000 different particles
14:35 - and now we mustn't forget in swan. CPP
14:39 - in the destructor here we have to delete
14:42 - mcore P particles and because it's an
14:44 - array we need these square brackets so
14:47 - mcore P
14:51 - particles so now we've got a load of
14:55 - particles there so this is this is going
14:58 - to all at memory and also fill that
15:01 - memory with a bunch of particle objects
15:05 - and when the particle Constructor for
15:07 - each particle runs it's going to assign
15:10 - a different like random location to
15:13 - itself now I I also want to be able to
15:16 - get particles from my swarm so I'm going
15:19 - to go to swarm Doh here and create a
15:22 - public method which returns a particle
15:27 - pointer and we'll call it
15:29 - um I could call it get particles or even
15:32 - just
15:33 - particles sometimes it's nice to emit
15:36 - the get um but perhaps get particles
15:40 - would be clearer let's call it get
15:43 - particles and I'll actually implement it
15:45 - here in line because it's only going to
15:47 - be a small function so I'll implement it
15:49 - in the header and we'll just say return
15:51 - mope P
15:55 - particles now we should think about
15:57 - conate here
15:59 - um this particle's pointer we don't want
16:01 - to point it to anywhere else ever once
16:05 - we've U once we've set it equal to
16:07 - something in our
16:09 - Constructor so why not make it a const
16:13 - pointer to a
16:16 - particle and when when we actually
16:19 - return it we we want to make sure that
16:22 - um the the the when we actually get this
16:26 - pointer outside of this class we want to
16:28 - make sure that it it can't the particles
16:31 - that it points at can't be changed we
16:33 - only want to change
16:35 - them uh possibly within this class or
16:39 - within the particle class itself so let
16:41 - let's say that this returns a cons
16:43 - pointer in other words a pointer that
16:45 - can't be made to point anywhere else to
16:48 - a particle that's const so a con pointer
16:52 - to a particle that's const so the
16:54 - particle can't be changed either using
16:57 - this pointer that's returned
16:59 - let's try that let's just build this
17:01 - thing um and see if it
17:05 - builds so I've got um an error here oh
17:08 - yes because um I um signed this in the
17:12 - in the
17:15 - Constructor
17:16 - um maybe I can't really make it const
17:19 - because I I have to change it at least
17:22 - here so yeah that's that's a shame but I
17:25 - don't really see a clear way around that
17:26 - so let's get rid of this const actually
17:29 - because sorry not that one this one
17:31 - because otherwise we can't even assign
17:34 - it in the Constructor okay let's let's
17:35 - try
17:39 - this so I think I think that looks good
17:43 - now let's see if we can actually draw
17:45 - these particles um so let's let's go to
17:49 - main.cpp and uh in main.cpp I'm going to
17:52 - declare a swarm somewhere here uh let's
17:55 - declare a
17:57 - swarm swarm I'll call it swarm so that
18:00 - the class has an uppercase s that's the
18:02 - convention I'm following and I'll make
18:04 - the actual object the same name with a
18:07 - lowercase s some people hate this uh
18:10 - convention but I quite like it we've
18:11 - only got one swarm here and my classes
18:14 - all have an uppercase letter so uh the
18:17 - object can just have a lowercase letter
18:19 - there then uh in my in my while loop
18:22 - here I need to get a pointer to all the
18:24 - particles I want to draw before I do
18:27 - that let's let's comment out
18:30 - and
18:31 - some code here let's comment out the
18:34 - stuff that displays that um um puts the
18:38 - colored block on the screen we're going
18:39 - to use that later so I just comment it
18:41 - out for the moment with a multi-line
18:43 - comment here SL star star slash uh and
18:47 - we'll use it later now that should
18:48 - hopefully give us a black screen and
18:50 - hopefully it shouldn't crash or anything
18:53 - um let's not continue cuz we've got an
18:55 - error there so I've got unused variable
18:58 - elapse but that's um that's just a
19:00 - warning we can include that in the
19:04 - comment we've also got a error unknown
19:07 - time unkknown type swarm and that's just
19:09 - cuz I got I forgot the header so let's
19:12 - include here swarm
19:16 - Doh let's try building it again see if
19:19 - it builds this time whoops build
19:23 - project and yeah it looks it looks fine
19:26 - now let's run it and we get a nice black
19:29 - screen okay so now let's see if we can
19:32 - plot that collection of particles with
19:33 - their random positions so they won't
19:35 - move at the moment we can maybe do that
19:37 - in the next tutorial quite exciting but
19:40 - we can at least plot them so we have
19:42 - something that looks like um sort of
19:44 - like stars so what we need to do is um
19:48 - we need to Loop through all the
19:50 - particles let's say for in I equals n i
19:54 - less than swarm colon colon n particle
19:59 - that's the number of particles I
20:02 - ++ uh before we do that actually we need
20:04 - to say uh
20:07 - particle well it's actually const
20:11 - particle pointer const So reading this
20:15 - backwards con pointer to a particle
20:17 - that's
20:18 - con um call this let's call this P
20:21 - particles equals swarm doget particles I
20:26 - don't use the class name here by stake
20:29 - we need the the object that we created
20:33 - there need to put that that semicolon in
20:36 - the right
20:37 - place then we can we can get each
20:39 - particle so we can say
20:42 - particle
20:43 - particle particle let's call it
20:46 - equals um P
20:49 - particles brackets
20:51 - [Music]
20:53 - I we could call that P particle to EMP
20:56 - emphasize it's a pointer um but um um
20:59 - I'll just call it particle I think so
21:01 - we've got we're getting the individual
21:03 - particles one by one and now we need to
21:05 - just plot them on the screen using that
21:06 - position how can we do that well we're
21:09 - going to have to map the particle space
21:13 - um which goes from minus one to plus one
21:14 - on both X and Y to the actual screen
21:18 - space so if we get um let's say
21:22 - n uh let's call this x equals particle
21:27 - dox now what what do we have to do to X
21:30 - the particle X from minus1 to + one to
21:33 - map it to a location on the
21:36 - screen well the first thing is we we
21:38 - don't want it to be negative so let's
21:40 - add one to it um because that will make
21:43 - it range instead of from minus1 to+ one
21:45 - now it'll be from n to
21:48 - two uh and let's let's surround that
21:50 - with brackets and then if we multiply
21:54 - this by um so if it's ranging from n to
21:58 - two if we if we multiply it by half of
22:00 - the width of the screen it's going to
22:03 - range from not to the screen width it
22:06 - has to be half because we're going from
22:07 - not to two uh so if we multiply two by
22:11 - half of the screen width we get the
22:13 - screen width so let's try this let's say
22:15 - multiply it by um I think we can use the
22:19 - constant from
22:20 - screen screen
22:24 - width I I think that that should should
22:29 - that should
22:31 - work um yeah so we we we add oh yes it's
22:36 - actually not X but mcore X so we add add
22:41 - one so that the x is from not to two and
22:45 - multiply by the screen width I think
22:47 - they should do the trick that the
22:50 - disadvantage of this actually would be
22:52 - that um position note for the particle
22:56 - so note + one would be yeah multiply by
23:00 - half the screen WID sorry if if the
23:02 - position is at particle not we'd like
23:05 - that to be in the center of the screen
23:07 - but does that actually work so um the
23:10 - EXP position of the particle is not add
23:13 - one it's one multiply it by half the
23:16 - screen width yes I think it actually
23:18 - does work I think this might actually
23:21 - work let's let's try it let's also get y
23:24 - in the same way so int y y equals
23:29 - particle. mcore
23:32 - y
23:34 - plus plus one to make it go from n to
23:38 - two instead of minus1 to + one multiply
23:41 - it by half of the screen
23:45 - height so
23:48 - screen
23:50 - height divide by oops screen height
23:54 - divide
23:55 - by divide by two
23:59 - and then hopefully we you'll have we'll
24:01 - have the Y ranging from not up to the
24:04 - screen height now one question in my
24:07 - mind is here um could the if if if the
24:12 - particles act actually at one then isn't
24:16 - it going to end up actually at um the
24:20 - screen width if the screen width is 600
24:22 - it's going to be actually at 600 we
24:25 - don't we don't want that because that's
24:27 - actually off the screen because um the
24:30 - the pixels in the screen start numbering
24:32 - at zero so if you go up to um screen
24:36 - width let's say then it's actually off
24:38 - the screen but for for our purposes here
24:42 - um it doesn't matter too much because
24:43 - we've implemented a set pixel function
24:47 - in screen.
24:49 - CPP which actually checks let's see set
24:54 - pixel is in here oh yes we we haven't
24:57 - actually done any checking but we could
24:59 - make this check and make sure that it
25:01 - doesn't plot a pixel that's off the
25:03 - edges of the
25:05 - screen um I I think this wouldn't plot
25:08 - pixels off the edges of the screen
25:10 - because
25:12 - um Rand divided by rammax would have to
25:16 - actually return one for that to happen
25:19 - well yes that probably could happen
25:20 - actually let's take care of this problem
25:24 - uh rather than agonizing over the exact
25:27 - possible pi pixel values of particles
25:30 - let's simply make set pixel refuse to
25:33 - plot a pixel off the edge of the screen
25:36 - so we can put a check here this is in
25:37 - screen. CPP and set pixel let's say if x
25:41 - is less than
25:43 - not
25:44 - or X
25:47 - is um greater than or equal
25:51 - to um
25:55 - screen width
25:59 - or Y is less than
26:03 - n or Y is greater
26:08 - than or equal to screen height then
26:14 - instead of plotting a pixel we'll just
26:16 - return like that so we'll only plot a
26:19 - pixel if it's within not screen width
26:23 - minus one including screen width minus
26:25 - one or Y is y y also has to be um
26:30 - greater than not and it has to be less
26:32 - than screen height so I think I think
26:35 - that's good now this this is inefficient
26:37 - if you if you really needed to squeeze a
26:40 - lot of processing power out of your
26:42 - computer then you would uh maybe want to
26:46 - think more carefully about exactly what
26:48 - you were plotting on the screen and
26:51 - possibly not do this but um this used to
26:54 - be something that people bothered about
26:56 - more in the early days of games
26:58 - programming when computers really
27:01 - struggled to produce uh anything that
27:03 - looked good at all um but now it's it's
27:07 - a lot more common to have some kind of
27:09 - clipping as we call it on the screen
27:12 - just to make sure that if you try to
27:13 - plot something over the edge of the
27:15 - screen um that it just it won't plot
27:18 - because otherwise if we didn't do
27:19 - something like this plotting a pixel off
27:21 - the edge of the screen could easily
27:23 - crash your program so although this is
27:25 - very inefficient checking this for every
27:27 - single pixel that we plot um maybe uh
27:32 - it's not a bad idea here I think our
27:33 - program will probably still run fast
27:36 - enough well I know it will on this
27:38 - computer and it saves us having to
27:40 - really agonize about the exact values of
27:43 - pixels that were're plotting so um let's
27:46 - let's go back now to main.cpp so now
27:49 - we've calculated the positions of the
27:51 - particles they might be slightly off the
27:53 - edge of the screen one pixel off the
27:55 - edge but we don't have to worry about
27:56 - that anymore now we can use screen do
28:00 - set
28:02 - pixel and we can put the X and Y
28:04 - positions in there and for the colors
28:06 - for the moment Let's uh well we could
28:09 - use these rather nice colors that we've
28:11 - calculated here let's just make them
28:13 - white for the moment though to maximum
28:16 - 255 for red green and blue so that it's
28:18 - easy to see them and let's finally run
28:21 - this and see if it works here's the
28:23 - moment of truth and then indeed it works
28:26 - and we've got sort of star field it
28:28 - doesn't really look like a Starfield
28:29 - it's a bit ugly but we're going to make
28:31 - it look a lot nicer later on one last
28:34 - little thing that we could do here which
28:36 - might be nice would be to uncomment
28:40 - these
28:41 - colors get rid of the stuff that
28:45 - draws uh that fills in the entire screen
28:48 - here and move this above where we're
28:52 - plotting the
28:54 - particles format the code and then use
28:57 - those colors to red green and blue to
29:01 - draw the pixels let's try this and see
29:04 - how this looks so it's not going to look
29:06 - very pretty but you can see we've got a
29:08 - load of stars if you got a good
29:11 - imagination and you might be able to
29:13 - tell uh from this video that they are in
29:16 - fact slowly changing color okay so
29:19 - that's it for this tutorial very long
29:21 - tutorial uh but I wanted to get to the
29:23 - point where you could actually see
29:24 - something new in the next tutorial what
29:27 - we're going to do is we're going to
29:28 - animate these particles uh so even more
29:31 - exciting and we're going to get them
29:33 - moving around the screen so until next
29:36 - time happy coding
29:38 - [Music]

Cleaned transcript:

hello this is John from Cave of programming. comom in this tutorial we're going to take a look at creating particles um represented by pixels that we can plot on our screen so at the moment I've got this uh window which just displays a block of color and slowly Cycles through um different possible colors uh so I'm going to use that later on I'm going to save that code um for a while but what I want to do now is Define a particle class and display those particles on the screen so let's let's go to eclipse and um let's create a new class CL here so I'll right click project go to new class and I'll call this particle and I I'll keep it in this Cave of programming namespace um I I don't know if I'll need a Constructor and Destructor but let's let's define them because there certainly no harm in having them let's click finish um I'm also going to Define another class here which I'm going to call swarm and swarm is going to manage a collection of particles so let's um again I'll give it a constructed Destructor I'll call it swarm and put it in this Cav programming Nam space again so we've got two new classes here now let's go to particle and let's start thinking about what kind of properties a particle will have so we're going to Define some private instance variables here and um I suppose the most fundamental uh thing about the state of a particle is that it needs an X and Y position on the screen and now I'm going to make these double so let's say double and I'll call this mcore x m to say mcore to say that it's um a member variable just to make that clear although that's that's certainly not um absolutely necessary and let's have a Double mcore Y now the reason I'm making the double is because even though on on the screen um we're dealing with individual pixels so the X and Y location are always uh always integers I want to be able to change these values gradually and um then just sort of round them off to the nearest pixel position so if if I want to change for example the x value gradually by adding some small number to it like .01 every time the screen refreshes of course I can't do that if it's an integer so although we have to display it at kind of an integral position at a particular pixel it's its position um may be um maybe somewhere between two pixels we just kind of round it off uh to the nearest pixel when we actually display it but having a double position allows us to move it conceptually bit by bit so and that avoids having to move it by an entire pixel every time we move it um so we can achieve more of an illusion of smooth movement uh so we've got um X and Y that's that's probably all we really need to to start with just an X and Y position for the particle as far as I can think um at the moment let's go to the particle Constructor here and um in the Constructor I could initialize the X and Y values really so yeah let's let's maybe do that what I'm going to do is I'm going to include standard libh standard li. because I want to use a function called Rand like that and uh Rand returns a random number between not and a constant called randor Max so uh this this returns an integer and this is an integer I believe so this division would wouldn't really make any sense but if I multiply Rand by a double or if I cast it to a double like that this will then return as a random number between note and one now what I'd really like to do is um i' I'd like to have the particles kind of move within some um some virtual space but I don't want that virtual space to be tied to the screen dimensions because then if I change the time the if I change the size of the screen or something then um the way our our program works has fundamentally changed I want to have the particles move around in some space of a fixed size some mathematical space and then we'll map that later onto the screen so I'm going to initialize the exposition of the particle to somewhere between let's say arbitrarily minus1 to + one so we can imagine that the particle inhabits a plane with uh cartisian coordinates if you've ever done any maths were um the X minimum X and Y coordinates are both minus one and the maximum possible X and Y coordinates are both plus one and if if you've never studied C cian coordinates you might want to just have a look at a page on them you know just for uh sort of 10 minutes or something just to get the idea but they they're relatively simple so um if I set um this is going to set x equal from equal to something from n to one but I want it to be from um minus one to + one so let's let's firstly maybe work on the Range there so if I multiply Rand by 2. not so now we don't need the cast a double because this bit is is a double now let's we could put brackets around that just to be doubly short so to speak uh so this should give us a number in the range not to plus 2. not and if I then subtract one from that I think I'm right in saying that we've now got um a range of minus1 to plus one so for first firstly I increased the range there so that instead of being not to one it was not to two then I subtracted one which gives us minus one to+ one if I've if I've got this correct what's the U warning there bad character sequence sometimes I find this happens and I think I'm somehow typing um invisible characters that it doesn't like I'm not sure how but yeah that that's fix that I just had to delete sort of underlined the space there and I just had to delete it and and put the space back in again maybe I hit the ALT key by mistake or something but it doesn't seem to stop it compiling though let's let's do the same with um with Y as well so let's set y equal to some random number from minus one to + one so that's our particle covered now usually what I do is I would um Supply like a get method for X and Y but we're going to have to deal with lot of particles and we're going to have to get X and Y values over and over again every time the screen refreshes for a huge number of particles so perhaps it's better to Simply um to Simply make these values public and access them directly that breaks encapsulation but um we're forced in games and simulations and things like that often to uh adopt a programming style that's not ideal for the sake of efficiency so it might be better to make this public an alternative thing that you you often see done is instead of explicitly declaring this as public what we could do is by default in a class if I write it like this these will be private by default but there's also a thing called a struct in C++ and if I just change this from a class to a struct the only difference between a class and a struct is that the members are public by default so um if I do this then we know that the intention is to access these directly and that they are now public so maybe I'll do that so that's the only difference between a class and a stru and that's the sort of thing they ask you on interviews as well is that by default in a class member variables are private if you don't specify an access modifier and instruct they're public by default and I'm just making them public for the sake of efficiency although ideally we wouldn't do that so that's my particle covered um I also need to initialize this random number generator because I I think it return as far as I know it Returns the same random numbers in sequence every time and I'd like it to return different ones every time we can do that by going um for example to main here and um if I include here include standard lip again standard li. H and um using namespace standard um I've missed out there D there then I can call a function here called srand and uh srand seeds the random number generator with a number uh which makes it produce a different sequence of random numbers every time and uh to for the seed number so I need to supply it with some number to seed it with I can use a function called time which is found in time. H I think but it's probably already included so we've got stlh there's no harm in including time. H if it exists it does kind of change its name from uh implementation to implementation uh let's just check what the error is here so um there's something there it doesn't like I'm just going to check um the program that I implemented previously in case I've got this slightly wrong somehow let's just check where I seeded my time so somewhere in here I should have seeded my um random number generator oh yes there we go ah yes so time the time function takes null um it it can return the time into a struct that you pass it if I remember rightly and this this might be wrong so don't take this as gospel uh but we don't want it to do that we just want to we don't want it to return anything other than um the number of um milliseconds I think it is since 1974 or whatever it is something like that to be honest this is one thing that I've got so used to typing that that I've um stopped wondering what it actually does let's let's close some of these no but um you can certainly Google for that if you're interested but basically this formula here seats our random number generator okay so let's let's leave that um and go back to our our program okay I'm going to close everything actually so that I don't get confused and open them again here so that's that's not even the right program here we go so particle. H um Okay so we've got our particle now and um now I want to class that organizes the particles because we're going to have to deal with a massive load of particles and um I I'd like some class that can organize them all so um I've got my swarm here that I've created and uh I'm going to give this a private member variable here let's say that it's uh well if I include here if I include um uh double quotes because it's a local include file particle. H and I'm I'm I'm using this C programming namespace then I can say in here particle pointer let's call this mcore P particles uh M because it's a instance variable p because it's a pointer then in my Constructor here let's go to swarm dot um CPP probably this is a reasonable place to initialize this let's set that equal to new um new particle array and how many particles do we want well I can define a constant let's call the constant n particles and uh let's go to swan. H and make that a I'll make it public just in case we need to use it outside of swarm yes we probably will in fact let's say n particles and let's make that a con static int and set it equal to some number like um 5,000 you might want to make this lower if your pro if your computer's a bit slow but if it is you'll find out later on but let's let's try um 5,000 to start with so we're going to have 5,000 different particles and now we mustn't forget in swan. CPP in the destructor here we have to delete mcore P particles and because it's an array we need these square brackets so mcore P particles so now we've got a load of particles there so this is this is going to all at memory and also fill that memory with a bunch of particle objects and when the particle Constructor for each particle runs it's going to assign a different like random location to itself now I I also want to be able to get particles from my swarm so I'm going to go to swarm Doh here and create a public method which returns a particle pointer and we'll call it um I could call it get particles or even just particles sometimes it's nice to emit the get um but perhaps get particles would be clearer let's call it get particles and I'll actually implement it here in line because it's only going to be a small function so I'll implement it in the header and we'll just say return mope P particles now we should think about conate here um this particle's pointer we don't want to point it to anywhere else ever once we've U once we've set it equal to something in our Constructor so why not make it a const pointer to a particle and when when we actually return it we we want to make sure that um the the the when we actually get this pointer outside of this class we want to make sure that it it can't the particles that it points at can't be changed we only want to change them uh possibly within this class or within the particle class itself so let let's say that this returns a cons pointer in other words a pointer that can't be made to point anywhere else to a particle that's const so a con pointer to a particle that's const so the particle can't be changed either using this pointer that's returned let's try that let's just build this thing um and see if it builds so I've got um an error here oh yes because um I um signed this in the in the Constructor um maybe I can't really make it const because I I have to change it at least here so yeah that's that's a shame but I don't really see a clear way around that so let's get rid of this const actually because sorry not that one this one because otherwise we can't even assign it in the Constructor okay let's let's try this so I think I think that looks good now let's see if we can actually draw these particles um so let's let's go to main.cpp and uh in main.cpp I'm going to declare a swarm somewhere here uh let's declare a swarm swarm I'll call it swarm so that the class has an uppercase s that's the convention I'm following and I'll make the actual object the same name with a lowercase s some people hate this uh convention but I quite like it we've only got one swarm here and my classes all have an uppercase letter so uh the object can just have a lowercase letter there then uh in my in my while loop here I need to get a pointer to all the particles I want to draw before I do that let's let's comment out and some code here let's comment out the stuff that displays that um um puts the colored block on the screen we're going to use that later so I just comment it out for the moment with a multiline comment here SL star star slash uh and we'll use it later now that should hopefully give us a black screen and hopefully it shouldn't crash or anything um let's not continue cuz we've got an error there so I've got unused variable elapse but that's um that's just a warning we can include that in the comment we've also got a error unknown time unkknown type swarm and that's just cuz I got I forgot the header so let's include here swarm Doh let's try building it again see if it builds this time whoops build project and yeah it looks it looks fine now let's run it and we get a nice black screen okay so now let's see if we can plot that collection of particles with their random positions so they won't move at the moment we can maybe do that in the next tutorial quite exciting but we can at least plot them so we have something that looks like um sort of like stars so what we need to do is um we need to Loop through all the particles let's say for in I equals n i less than swarm colon colon n particle that's the number of particles I ++ uh before we do that actually we need to say uh particle well it's actually const particle pointer const So reading this backwards con pointer to a particle that's con um call this let's call this P particles equals swarm doget particles I don't use the class name here by stake we need the the object that we created there need to put that that semicolon in the right place then we can we can get each particle so we can say particle particle particle let's call it equals um P particles brackets I we could call that P particle to EMP emphasize it's a pointer um but um um I'll just call it particle I think so we've got we're getting the individual particles one by one and now we need to just plot them on the screen using that position how can we do that well we're going to have to map the particle space um which goes from minus one to plus one on both X and Y to the actual screen space so if we get um let's say n uh let's call this x equals particle dox now what what do we have to do to X the particle X from minus1 to + one to map it to a location on the screen well the first thing is we we don't want it to be negative so let's add one to it um because that will make it range instead of from minus1 to+ one now it'll be from n to two uh and let's let's surround that with brackets and then if we multiply this by um so if it's ranging from n to two if we if we multiply it by half of the width of the screen it's going to range from not to the screen width it has to be half because we're going from not to two uh so if we multiply two by half of the screen width we get the screen width so let's try this let's say multiply it by um I think we can use the constant from screen screen width I I think that that should should that should work um yeah so we we we add oh yes it's actually not X but mcore X so we add add one so that the x is from not to two and multiply by the screen width I think they should do the trick that the disadvantage of this actually would be that um position note for the particle so note + one would be yeah multiply by half the screen WID sorry if if the position is at particle not we'd like that to be in the center of the screen but does that actually work so um the EXP position of the particle is not add one it's one multiply it by half the screen width yes I think it actually does work I think this might actually work let's let's try it let's also get y in the same way so int y y equals particle. mcore y plus plus one to make it go from n to two instead of minus1 to + one multiply it by half of the screen height so screen height divide by oops screen height divide by divide by two and then hopefully we you'll have we'll have the Y ranging from not up to the screen height now one question in my mind is here um could the if if if the particles act actually at one then isn't it going to end up actually at um the screen width if the screen width is 600 it's going to be actually at 600 we don't we don't want that because that's actually off the screen because um the the pixels in the screen start numbering at zero so if you go up to um screen width let's say then it's actually off the screen but for for our purposes here um it doesn't matter too much because we've implemented a set pixel function in screen. CPP which actually checks let's see set pixel is in here oh yes we we haven't actually done any checking but we could make this check and make sure that it doesn't plot a pixel that's off the edges of the screen um I I think this wouldn't plot pixels off the edges of the screen because um Rand divided by rammax would have to actually return one for that to happen well yes that probably could happen actually let's take care of this problem uh rather than agonizing over the exact possible pi pixel values of particles let's simply make set pixel refuse to plot a pixel off the edge of the screen so we can put a check here this is in screen. CPP and set pixel let's say if x is less than not or X is um greater than or equal to um screen width or Y is less than n or Y is greater than or equal to screen height then instead of plotting a pixel we'll just return like that so we'll only plot a pixel if it's within not screen width minus one including screen width minus one or Y is y y also has to be um greater than not and it has to be less than screen height so I think I think that's good now this this is inefficient if you if you really needed to squeeze a lot of processing power out of your computer then you would uh maybe want to think more carefully about exactly what you were plotting on the screen and possibly not do this but um this used to be something that people bothered about more in the early days of games programming when computers really struggled to produce uh anything that looked good at all um but now it's it's a lot more common to have some kind of clipping as we call it on the screen just to make sure that if you try to plot something over the edge of the screen um that it just it won't plot because otherwise if we didn't do something like this plotting a pixel off the edge of the screen could easily crash your program so although this is very inefficient checking this for every single pixel that we plot um maybe uh it's not a bad idea here I think our program will probably still run fast enough well I know it will on this computer and it saves us having to really agonize about the exact values of pixels that were're plotting so um let's let's go back now to main.cpp so now we've calculated the positions of the particles they might be slightly off the edge of the screen one pixel off the edge but we don't have to worry about that anymore now we can use screen do set pixel and we can put the X and Y positions in there and for the colors for the moment Let's uh well we could use these rather nice colors that we've calculated here let's just make them white for the moment though to maximum 255 for red green and blue so that it's easy to see them and let's finally run this and see if it works here's the moment of truth and then indeed it works and we've got sort of star field it doesn't really look like a Starfield it's a bit ugly but we're going to make it look a lot nicer later on one last little thing that we could do here which might be nice would be to uncomment these colors get rid of the stuff that draws uh that fills in the entire screen here and move this above where we're plotting the particles format the code and then use those colors to red green and blue to draw the pixels let's try this and see how this looks so it's not going to look very pretty but you can see we've got a load of stars if you got a good imagination and you might be able to tell uh from this video that they are in fact slowly changing color okay so that's it for this tutorial very long tutorial uh but I wanted to get to the point where you could actually see something new in the next tutorial what we're going to do is we're going to animate these particles uh so even more exciting and we're going to get them moving around the screen so until next time happy coding
