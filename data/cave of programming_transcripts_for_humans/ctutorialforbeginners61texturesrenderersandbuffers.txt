With timestamps:

00:16 - hello this is John from cave of program
00:20 - common in this tutorial we're gonna send
00:24 - color of our window to white and
00:26 - although that may not sound like much
00:29 - but we're actually going to enable pixel
00:32 - access effectively in this window which
00:34 - at the moment is black and we're gonna
00:38 - just make sure that the things basically
00:41 - working by setting the window to white
00:45 - oh here we go so we've got a black
00:47 - window at the moment I've just that
00:48 - externally started three copies of this
00:51 - and we're going to enable pixel access
00:54 - here and then just make the whole thing
00:56 - turn white which is quite easy to do
00:57 - before we go on to setting individual
01:00 - pixels
01:03 - so of course this isn't strictly
01:06 - speaking and speaking and SDLT tutorial
01:09 - it's a c++ tutorial on just using SDL as
01:12 - an example of a graphics API because we
01:15 - need some kind of API and I don't have
01:18 - all the details of the STL API in my
01:22 - head so for that reason I'm going to
01:23 - refer to a finished project that I
01:26 - created by as I explained in a previous
01:28 - tutorial looking up tutorials on the
01:31 - Internet relating to STL and then
01:33 - changing a few things by consulting the
01:36 - API official API documents by searching
01:40 - for function names so I'm gonna kind of
01:43 - cannibalize my own code here and copying
01:46 - bit by bit in fact I'll I'll type it out
01:48 - and I'll explain as much as I can as we
01:51 - go along but my knowledge of STL is
01:53 - thought is not very in-depth I just
01:56 - figured out enough to get this working
01:58 - so I hope you'll forgive me effort
02:00 - actually copying my own code rather than
02:03 - just speaking from the top of my head I
02:05 - could have memorized this stuff but it
02:07 - would have been a little bit sort of
02:09 - fake because I certainly don't know STL
02:13 - all that well and by the way I hope that
02:15 - you'll follow along and after each video
02:18 - implement your own version of this
02:21 - program either exactly the same or even
02:24 - slightly
02:25 - different but that's a really good thing
02:29 - to do to get the most out of these
02:30 - videos otherwise if you're just watching
02:32 - them this this will kind of never sink
02:34 - into your head
02:35 - unfortunately so let's let's take a look
02:39 - at the program that I actually finished
02:42 - it's particle explosion program which is
02:46 - down here I've called a STL test and if
02:49 - we go to my I've got an object a class
02:53 - in here called screen which we're going
02:56 - to construct later on but first I want
02:58 - to get just a basic main function that
03:03 - just illustrates that the kind of basic
03:07 - elements of what we need here and later
03:09 - on I'm going to refactor it and make it
03:11 - more object-oriented so that we don't
03:13 - get into a tangle when we add more and
03:15 - more code to this so in my screen class
03:19 - here I've got an init method and in here
03:24 - we are creating a thing called a
03:26 - renderer and a thing called a texture so
03:31 - my understanding here is that the
03:33 - renderer is something we use in STL to
03:36 - actually draw on the window we've got a
03:37 - window but we need a renderer to render
03:40 - stuff in other words draw stuff on it
03:42 - and we also need a texture which is
03:46 - gonna that is like a bitmap that we can
03:50 - draw directly to so we'll be creating
03:52 - the renderer doing stuff with a texture
03:55 - and then passing the texture to the
03:57 - renderer and then telling the renderer
03:59 - to display in the window basically let's
04:03 - take a look at the header file here
04:04 - because I need the types for the
04:06 - renderer and the texture and we've also
04:08 - I've also created here what I've called
04:11 - a buffer and what this is is just an
04:14 - area of memory where we're going to get
04:18 - inset information that's going to relate
04:21 - to pixels and we're going to actually
04:23 - then use that memory to to write to the
04:27 - texture which will pass to the renderer
04:29 - which will display on the window so it's
04:32 - like a chain of three different things
04:33 - here there may be a simpler and better
04:35 - we're doing this but this this is a way
04:38 - that definitely works and it seems
04:41 - reasonably efficient so this is where
04:43 - I've kind of settled on but you may find
04:46 - a better way of doing this as possible
04:48 - so let's go to screen dot H yeah and in
04:55 - screen dot H somewhere this is still
04:58 - screen dot CPP so we need to go down
05:01 - here here's my renderer texture and
05:04 - buffer so so let's let's create those
05:08 - objects in in our main file first of all
05:13 - so I need to go to the right project
05:15 - here that I've just created main dot CPP
05:18 - and somewhere before we actually use
05:22 - these I'm gonna have to create a
05:25 - relevant objects let's maybe do it here
05:26 - so I need a SDL underscore render
05:32 - pointer and let's call that renderer and
05:39 - we need to set that equal to the return
05:45 - value of crate renderer function which
05:49 - is somewhere down here let's take a look
05:53 - so here we are STL crate renderer let's
05:55 - type that out so SDL underscore create
05:59 - renderer
06:03 - and what what what arguments do we need
06:05 - to pass to this well let's take a look
06:08 - so that the first document is the window
06:11 - that the render is going to render into
06:13 - that's like that so we've called that
06:16 - just window to point it to the window
06:18 - the next argument is minus one which if
06:21 - we look at the documentation well let's
06:23 - start doing a seconds at the moment
06:25 - we've got a syntax error that prevents
06:27 - the documentation showing or you could
06:29 - just paste this into Google and the last
06:32 - argument I figured out by looking at the
06:34 - API document that's STL renderer present
06:37 - vsync so I'm gonna copy that and what
06:41 - this does is it ensures that I render
06:47 - is synchronized with the vertical
06:48 - refresh of the screen so your computer
06:51 - screen is gonna refresh a certain number
06:53 - of times a second
06:55 - like I don't actually know how many
06:57 - let's say it's 30 times a second 50
07:00 - times I'm not sure and it refreshes from
07:04 - the top left hand corner it goes across
07:07 - the rows and moves downwards so it
07:10 - redraws the screen from the top left
07:13 - goes right across to there to the top
07:16 - right and then it does the next row a
07:18 - bit further down the screen going from
07:21 - left to right again and if you try to
07:24 - draw something to the screen when a
07:26 - render is in progress like this half way
07:28 - down you see something called shearing
07:30 - where this kind of effect where you see
07:33 - sort of flickering on the screen and
07:34 - there's a visible line that flickers
07:36 - somewhere across the screen horizontally
07:39 - we want to we want that not to happen so
07:43 - you want to make sure that I rendering
07:44 - is synchronized with that refresh so
07:46 - that we don't try to render to the
07:48 - window when the screens actually
07:51 - refreshing and at least on my machine
07:54 - adding this flag here to Crane renderer
07:57 - synchronize seems to sync rise properly
08:00 - and it prevents shearing if we look at
08:03 - the crate renderer documentation yeah
08:05 - then we see the first argument is our
08:07 - window the second one this is minus one
08:10 - just to say that we want to just
08:13 - initialize the first rendering driver
08:15 - available whatever that is I'm not
08:17 - really sure and but it's basically a
08:20 - kind of default option there and the
08:22 - last one as I say found out by looking
08:24 - at the API document by googling by
08:28 - pulling this function name into Google
08:30 - so that that's our renderer created and
08:33 - let's let's go back and see if we can
08:35 - create texture here so now we need STL
08:40 - STL underscore I think it's texture text
08:44 - text your pointer I quite like having
08:48 - that asterisk next to the actual
08:49 - variables so I'll put it there so I
08:52 - pointed to an STL texture which I'll
08:54 - call texture
08:55 - so this is the thing that the renderer
08:57 - is gonna render and which were gonna
09:00 - write our pixel information to if we
09:03 - take a look at that then again quite
09:06 - complicated arguments ball go through
09:07 - them bit by bit so we've got STL on the
09:10 - score crate texture
09:11 - STL on the score creates texture spot
09:18 - the semicolon and the brackets in there
09:20 - first document is our renderer so let's
09:25 - put that in render the second argument
09:30 - here is this can be a number of possible
09:34 - arguments a number of possible constants
09:37 - depending on how many bits how many
09:42 - bytes basically you want to represent
09:44 - one pixel so I'm going to use this STL
09:49 - pixel format RGB a 8 8 8 8 which uses 1
09:56 - byte for each pixel so that means for
09:59 - each pixel we've got we can select one
10:02 - of 0 to 255 different shades of each
10:09 - color so each pixel actually uses it
10:12 - actually uses 32 bits or 4 bytes three
10:17 - of those bytes are going to represent
10:19 - the color information of the pixel red
10:22 - green and blue and each red green and
10:26 - blue value can have 0 up to 255
10:29 - different possible values 255 is the
10:32 - maximum value we can fit in one bite if
10:36 - we flip all the bits to one the other
10:40 - value here AAA's stands for alpha which
10:42 - is basically a transparency we won't be
10:46 - using that and I've read lots of reports
10:48 - that doesn't work in STL and that seems
10:51 - to be my experience but actually I think
10:54 - that you can set various flags here in
10:56 - there to various functions to get up
10:58 - working but I'm not going to make use of
11:00 - it in this tutorial in any case
11:03 - let's let's take a look at what's next
11:05 - so now we've got STL texture access
11:08 - static now this this has to do with the
11:12 - way that we're writing to the texture I
11:15 - can't really remember the details of
11:17 - this but basically we want to take a
11:19 - load of memory containing values for
11:22 - each pixel the right and directly to the
11:24 - texture every time we go around this
11:27 - loop and that flag enables us to do that
11:30 - so let's put that in and finally we've
11:36 - got screen width from the screen height
11:37 - so let's just copy those we've already
11:40 - gotten these constants defined in our
11:42 - program up here so we can put those in
11:46 - because their texture needs to know how
11:48 - big it's going to be and it's format
11:50 - that so we've got our texture and I
11:53 - renderer we also need to remember to
11:56 - deallocate a resources allocated to
11:59 - those so I've done that in my final
12:02 - program in a method called
12:05 - close so they were using STL destroy
12:08 - texture an STL destroy rendering so
12:11 - let's go ahead and put that in we
12:14 - destroy the text at first because it's
12:15 - using the renderer so we probably should
12:18 - destroy that first otherwise we're gonna
12:20 - have if we destroyed a renderer then
12:22 - we're still gonna have a texture that's
12:23 - using that that destroyed renderer I'm
12:26 - not sure if that matters but it's
12:27 - prudent to get them in the appropriate
12:29 - order let's say STL destroy renderer
12:35 - renderer and after that we can do s STL
12:41 - destroy texture texture passing texture
12:50 - hopefully that should do the trick
12:54 - it's probably a good idea to check if
12:57 - these are null let's take a look at the
13:02 - documentation and see if it says
13:06 - anything about returning null so I'll
13:09 - just search google for the function name
13:11 - here and so it returns null if there was
13:16 - an error and we can call SD I'll get
13:18 - error as well so we could we could check
13:23 - that it's probably prudent to do so
13:26 - let's say if renderer is equal to null
13:34 - then if you don't check it on your
13:37 - programs basically just gonna crash if
13:39 - this doesn't work properly let's say C
13:41 - out could not create render endler and
13:50 - let's just return some nonzero integers
13:54 - to signal an error and a say gif texture
13:57 - equals null well just gone the caps lock
14:02 - on here then C out could not create
14:07 - texture
14:11 - pendler and then i'll return some other
14:14 - value could just return north here it as
14:18 - I said previously it doesn't really
14:19 - matter if we could create the window but
14:24 - not the renderer we we probably that in
14:29 - either case we we should probably call
14:30 - STL quit like this if we if we could
14:38 - create the window and so by the stage we
14:41 - have crate to the window so we should
14:43 - probably put destroy window in here as
14:46 - well
14:47 - let's put destroy window before we call
14:50 - STL quit if we are able to create the
14:56 - renderer but not the texture we should
14:58 - probably destroy at least the the
15:00 - renderer so at this point by this point
15:04 - we've created the renderer but not the
15:06 - texture so let's destroy the renderer
15:09 - now this is a lot of repetition of code
15:12 - we could refactor this and perhaps I
15:15 - will in a final tutorial so I don't
15:17 - really like or like in a later tutorial
15:20 - because I don't really like having
15:21 - multiple calls to the same functions in
15:24 - here we could have something that sort
15:27 - of checks if any of those are null and
15:32 - destroys them if they're not nor later
15:35 - on rather than repeating all this stuff
15:37 - but we'll leave it from the moment
15:38 - because the object for the moment is
15:41 - just to get a basic program working even
15:43 - if it's ugly that demonstrates the basic
15:46 - principle and then we can refactor it
15:48 - and make it more elegant so we've got
15:51 - our render and our text you others
15:53 - there's another thing that we need now
15:54 - which is we need some sort of area of
16:00 - memory that could there's big enough to
16:01 - hold the information for all the pixels
16:04 - on the screen because we're going to
16:05 - take that that memory and we're going to
16:08 - basically write it to the texture so
16:10 - we're going to update the texture with
16:12 - that information
16:13 - and what I'm going to use is this type
16:18 - you in 32 so I'm gonna say here you in
16:25 - 32 pointer now what what is you in 32
16:28 - this is a type declared by STL which on
16:31 - most systems will be equivalent to an
16:33 - int + int is usually 32 bits but it's
16:38 - possible that on some systems because
16:40 - C++ is not absolutely standardized that
16:43 - a an int might not be 32 bits could be
16:47 - something else
16:47 - so for that reason SDL of have defined
16:50 - this type which is guaranteed to be 32
16:53 - bits but it's basically an int can we
16:55 - want to allocate enough enough of these
16:58 - for all the pixels on the screen because
17:02 - if you think about it here so we've got
17:04 - for each pixel we've got four values red
17:07 - green blue and alpha each of those is
17:09 - one byte so for every pixel we've got
17:12 - four bytes which is 32 bits 4 times 8 is
17:17 - 32 so for every pixel we need a in size
17:22 - of 32 bit bit of memory to represent all
17:28 - the information that's going to be in
17:29 - that pixel or the colors of it basically
17:31 - so we're going to allocate enough memory
17:33 - for all the pixels on the screen
17:35 - and each one's going to require 32 bits
17:37 - so let's say here I'll call it buffer
17:41 - buffer just means an area of memory
17:43 - basically equals new you int 32 and the
17:49 - amount of memory that I have to allocate
17:51 - is gonna be
17:55 - screen width screen width times the
17:59 - screen height because it is just screen
18:03 - just a rectangle which is screen width
18:06 - pixels wide and screen Heights pixels
18:09 - high so that's that buffer and we must
18:12 - remember to free this later on as well
18:15 - so let's go down here and say delete and
18:20 - we need the array brackets because it's
18:23 - it's an array that we've allocated there
18:25 - delete buffer
18:30 - okay so that looks good now you might
18:32 - wonder what happens if memory allocation
18:35 - fails some C++ systems new will return
18:41 - null at that point and we can we can
18:45 - actually configure new to make it do
18:47 - that but by default on most systems it
18:49 - will raise an exception we haven't
18:51 - looked at exceptions I'm saving that for
18:53 - my intermediate C++ course which I which
18:56 - is probably coming next but the bottom
19:00 - line is your program will crash possibly
19:02 - with an error message but it will crash
19:05 - we're not really gracefully but so
19:08 - hopefully somewhat gracefully if we
19:10 - can't allocate memory at that point the
19:12 - trouble is because we're not doing
19:15 - anything with this exception we then
19:17 - wouldn't be able to call these functions
19:20 - but I'm not gonna worry about this for
19:22 - this program by dearly we would check
19:26 - for that but you're this is gonna
19:29 - succeed unless your computer's
19:31 - incredibly tight on memory if it's so
19:33 - tight on memory that we can't allocate
19:35 - being like 32 bits for each pixel on the
19:38 - screen then probably a lot of programs
19:41 - are going to be crashing anyway so this
19:42 - is kind of a justification of why I'm
19:45 - not checking this but ideally in a kind
19:48 - of professional program ideally you'd
19:50 - probably check to see if memory could be
19:54 - successfully allocated although I be
19:57 - willing to bet that very many programs
20:00 - that are on sale do not check but to be
20:04 - perfect we really should so I've I've
20:09 - allocated that I've located a render and
20:11 - a texture and a buffer that we need to
20:13 - contain all the information for the
20:15 - pixels and I've freed all those
20:18 - resources as well down here now what we
20:22 - need to do is we need to update the
20:26 - texture with the information contained
20:28 - in this buffer which at the moment is
20:30 - just garbage and I then need to tell the
20:35 - renderer to render in other words draw
20:37 - the texture
20:39 - so let's look at how we do that I really
20:41 - can't remember but I'm gonna consult my
20:43 - final program again so if we look at I
20:47 - think is screened update here yeah here
20:50 - we go
20:50 - so we need this stuff so the first thing
20:53 - we needs SDL update texture and I've got
20:56 - our eventually I'm gonna move this into
20:57 - this loop so they were updating the
20:59 - texture every time this loop occurs but
21:01 - for the moment I'm just gonna put it
21:03 - above this loop let's say s DL on the
21:06 - Scott updates texture let's check what
21:11 - we do with that so the first argument is
21:15 - the texture so we pass in our texture
21:18 - second argument is null or take a look
21:20 - at what this is in the moment then we
21:26 - pass in our buffer that we actually
21:28 - starts containing the information that
21:30 - we want to update the texture with or it
21:33 - will do once we set that up and then we
21:36 - pass the pitch and the pitch is the
21:40 - number of memory allocated to one row of
21:42 - pixels so if you think about what that
21:45 - is it's gonna be screen width that's the
21:49 - number of pixels multiply it by size of
21:53 - new int 32 which is 4 bytes or we could
21:59 - just pass in screen width times 4 so on
22:01 - seems to be soaring something in the
22:03 - background I apologize for that but
22:05 - anyway I carry on so if we look at the
22:08 - documentation yeah so we've got a
22:10 - texture is the first argument that we
22:13 - need and the next argument is no if we
22:17 - want to update the whole thing and then
22:20 - we've got the raw pixel data that we
22:22 - want to update it with and finally we've
22:25 - got the pitch which is the number of
22:27 - bytes it says between rows that pixel
22:29 - data so in other words that the number
22:34 - of bytes per row of pixels I'm not sure
22:37 - I says between but if you want to go
22:39 - from one row to the next this is how
22:42 - many bytes you have to add on it's
22:45 - possible if we're allocated some really
22:47 - strange
22:49 - sighs for the window that we might have
22:51 - extra bytes at the end of a a row of
22:55 - pixels that aren't actually use of a
22:56 - rendering and then maybe the pixar will
22:58 - be different to the number of pixels in
23:00 - a row but that's not the case here so
23:02 - this this seems to work fine
23:04 - so we update the texture with the pixel
23:08 - information contained in this buffer and
23:11 - the next stage is we clear the renderer
23:14 - so let's call STL on the score render
23:18 - render Ecklie up I think it is all
23:21 - render clear and pass in the renderer
23:28 - something wrong there maybe it's
23:30 - rendered there okay there we go
23:34 - then we copy the texture to the renderer
23:38 - so let's do that so SDL on the score Ren
23:45 - render copy first document is the
23:50 - renderer then the texture then all know
23:55 - and know from what are these I don't
24:00 - know well the renderer and the texture
24:02 - obviously ah to render and the texture
24:04 - and then we've got null and that's the
24:07 - first mall is specified and we want to
24:10 - use the entire texture and Seconal is to
24:13 - specify that we want to use the entire
24:15 - renderer finally I think we've got
24:17 - render present so we've got STL
24:22 - underscore render present
24:26 - and this is basically it's just actually
24:33 - doing the render its presenting a render
24:35 - to the window it's actually rendering it
24:38 - so were copying the pixels to our buffer
24:41 - then passing the buffer to the renderer
24:43 - after after clearing it and then we're
24:46 - presenting the was to render on the
24:49 - screen now if if I run this there is
24:52 - also going to be a bit random let's try
24:55 - let's try running it see what happens
24:58 - whoops that's the wrong that's the wrong
25:02 - thing that's my final program let's try
25:04 - this so go to project build project and
25:08 - we'll run it so it's just black it
25:13 - wouldn't it would not have surprised me
25:15 - if we'd seen a load of garbage in that
25:17 - because when we allocate this memory
25:19 - it's gonna contain just whatever happens
25:21 - to be in that memory that was allocated
25:23 - and it seems that for me this time at
25:26 - least there's nothing in that memory so
25:28 - it's just blank but the reason it could
25:30 - be something in that memory what we want
25:33 - to do now is we want to write something
25:37 - in write some pixel information into
25:39 - this buffer so that we can see something
25:41 - happening on the screen I'm gonna use a
25:43 - very very very useful function which
25:46 - everyone should know about called memset
25:48 - memset allows you to set a block of
25:51 - memory with a particular value so the
25:54 - first argument is the buffer the second
25:57 - argument is the value that we're going
26:00 - to write into every bite of that memory
26:02 - so it's got 255 because we want to try
26:05 - to get every bite
26:07 - cycle to its maximum value red green
26:09 - blue and alpha and actually give us a
26:11 - white color and then if I remember
26:15 - rightly we need the number of bytes that
26:16 - we want to set which is gonna be is
26:19 - gonna be screen width
26:24 - times scream pipes number of pixels
26:29 - times size of invites you into 32 so
26:37 - hopefully I've got this right we're
26:38 - going to write the maximum value that we
26:41 - can put in a byte in every byte in all
26:44 - of these bites and memset is a very
26:46 - quick function which is one of the
26:48 - reasons it's very very useful so let's
26:51 - let's try that see what we get now
26:53 - so we've now we've got a wide screen
26:55 - which is what we wanted now another way
26:59 - of representing 255 which I'm going to
27:01 - be using in this tutorial rather than
27:04 - 255 probably for the most part is we can
27:11 - write this in hexadecimal so hexadecimal
27:14 - is it's another number system like
27:16 - binary like the familiar decimal where
27:19 - we use each digit can have one of
27:21 - sixteen possible values starting in
27:24 - naught and going up through 1 2 3 4 5 6
27:26 - 7 8 9 and then we supplement some extra
27:29 - values by going ABCDE and F so in
27:34 - hexadecimal 255 is 0xff the reason this
27:39 - is particularly useful but by the way Oh
27:42 - X is just a prefix in C++ to say this is
27:45 - a hexadecimal value and the reason this
27:47 - is really useful is because if we well
27:53 - we'll see later on that if we want to
27:54 - pack multiple bytes into one into one
28:01 - single U and 32 value a 30 to the end
28:04 - then we end up with just two digits per
28:09 - byte in hexadecimal system which means
28:13 - it's easy to see which byte represents
28:18 - what's in the final integer that
28:20 - represents the color of that pixel on
28:22 - the screen I'll go into that later on
28:25 - but that's basically the advantage of it
28:29 - we need exactly two digits here to
28:32 - specify one byte and if you're packing
28:35 - bytes into
28:37 - an int value Dan it works out that it's
28:41 - very easy to see which by corresponding
28:43 - in our case to which color but we'll get
28:45 - onto that later
28:46 - so 255 in hexadecimal is FF line art
28:50 - let's just run it again channel it still
28:52 - works so that looks that looks really
28:56 - good
28:58 - probably in the next tutorial what we'll
29:02 - do is well that there are several things
29:05 - to do next but basically we need to deal
29:08 - with pixel access next and we're
29:12 - probably going to do that in a next
29:14 - tutorial
29:14 - we also need to think about colors how
29:18 - we're going to devise what colors to
29:20 - draw on the screen and I might do that
29:23 - in this basic program as well if you
29:25 - look at this program now this is a big
29:29 - main function and we could carry on like
29:34 - adding stuff to this but it by the end
29:37 - it would be really huge and not easy to
29:40 - understand we could split this up into
29:43 - multiple different functions that's kind
29:46 - of C style programming but what we're
29:48 - going to be doing is splitting this up
29:50 - into classes but we're going to continue
29:52 - working with this for a moment because
29:54 - before I want to refactor into classes I
29:58 - want to just make sure we've got a
29:59 - little demo program and it is still
30:01 - quite little really that just
30:03 - demonstrates all the basic things that
30:06 - we need to do and then we can proceed
30:08 - forwards in confidence so we'll probably
30:11 - take a look at pixel access and possibly
30:14 - colors in the next tutorial
30:16 - so until then happy coding
30:25 - you

Cleaned transcript:

hello this is John from cave of program common in this tutorial we're gonna send color of our window to white and although that may not sound like much but we're actually going to enable pixel access effectively in this window which at the moment is black and we're gonna just make sure that the things basically working by setting the window to white oh here we go so we've got a black window at the moment I've just that externally started three copies of this and we're going to enable pixel access here and then just make the whole thing turn white which is quite easy to do before we go on to setting individual pixels so of course this isn't strictly speaking and speaking and SDLT tutorial it's a c++ tutorial on just using SDL as an example of a graphics API because we need some kind of API and I don't have all the details of the STL API in my head so for that reason I'm going to refer to a finished project that I created by as I explained in a previous tutorial looking up tutorials on the Internet relating to STL and then changing a few things by consulting the API official API documents by searching for function names so I'm gonna kind of cannibalize my own code here and copying bit by bit in fact I'll I'll type it out and I'll explain as much as I can as we go along but my knowledge of STL is thought is not very indepth I just figured out enough to get this working so I hope you'll forgive me effort actually copying my own code rather than just speaking from the top of my head I could have memorized this stuff but it would have been a little bit sort of fake because I certainly don't know STL all that well and by the way I hope that you'll follow along and after each video implement your own version of this program either exactly the same or even slightly different but that's a really good thing to do to get the most out of these videos otherwise if you're just watching them this this will kind of never sink into your head unfortunately so let's let's take a look at the program that I actually finished it's particle explosion program which is down here I've called a STL test and if we go to my I've got an object a class in here called screen which we're going to construct later on but first I want to get just a basic main function that just illustrates that the kind of basic elements of what we need here and later on I'm going to refactor it and make it more objectoriented so that we don't get into a tangle when we add more and more code to this so in my screen class here I've got an init method and in here we are creating a thing called a renderer and a thing called a texture so my understanding here is that the renderer is something we use in STL to actually draw on the window we've got a window but we need a renderer to render stuff in other words draw stuff on it and we also need a texture which is gonna that is like a bitmap that we can draw directly to so we'll be creating the renderer doing stuff with a texture and then passing the texture to the renderer and then telling the renderer to display in the window basically let's take a look at the header file here because I need the types for the renderer and the texture and we've also I've also created here what I've called a buffer and what this is is just an area of memory where we're going to get inset information that's going to relate to pixels and we're going to actually then use that memory to to write to the texture which will pass to the renderer which will display on the window so it's like a chain of three different things here there may be a simpler and better we're doing this but this this is a way that definitely works and it seems reasonably efficient so this is where I've kind of settled on but you may find a better way of doing this as possible so let's go to screen dot H yeah and in screen dot H somewhere this is still screen dot CPP so we need to go down here here's my renderer texture and buffer so so let's let's create those objects in in our main file first of all so I need to go to the right project here that I've just created main dot CPP and somewhere before we actually use these I'm gonna have to create a relevant objects let's maybe do it here so I need a SDL underscore render pointer and let's call that renderer and we need to set that equal to the return value of crate renderer function which is somewhere down here let's take a look so here we are STL crate renderer let's type that out so SDL underscore create renderer and what what what arguments do we need to pass to this well let's take a look so that the first document is the window that the render is going to render into that's like that so we've called that just window to point it to the window the next argument is minus one which if we look at the documentation well let's start doing a seconds at the moment we've got a syntax error that prevents the documentation showing or you could just paste this into Google and the last argument I figured out by looking at the API document that's STL renderer present vsync so I'm gonna copy that and what this does is it ensures that I render is synchronized with the vertical refresh of the screen so your computer screen is gonna refresh a certain number of times a second like I don't actually know how many let's say it's 30 times a second 50 times I'm not sure and it refreshes from the top left hand corner it goes across the rows and moves downwards so it redraws the screen from the top left goes right across to there to the top right and then it does the next row a bit further down the screen going from left to right again and if you try to draw something to the screen when a render is in progress like this half way down you see something called shearing where this kind of effect where you see sort of flickering on the screen and there's a visible line that flickers somewhere across the screen horizontally we want to we want that not to happen so you want to make sure that I rendering is synchronized with that refresh so that we don't try to render to the window when the screens actually refreshing and at least on my machine adding this flag here to Crane renderer synchronize seems to sync rise properly and it prevents shearing if we look at the crate renderer documentation yeah then we see the first argument is our window the second one this is minus one just to say that we want to just initialize the first rendering driver available whatever that is I'm not really sure and but it's basically a kind of default option there and the last one as I say found out by looking at the API document by googling by pulling this function name into Google so that that's our renderer created and let's let's go back and see if we can create texture here so now we need STL STL underscore I think it's texture text text your pointer I quite like having that asterisk next to the actual variables so I'll put it there so I pointed to an STL texture which I'll call texture so this is the thing that the renderer is gonna render and which were gonna write our pixel information to if we take a look at that then again quite complicated arguments ball go through them bit by bit so we've got STL on the score crate texture STL on the score creates texture spot the semicolon and the brackets in there first document is our renderer so let's put that in render the second argument here is this can be a number of possible arguments a number of possible constants depending on how many bits how many bytes basically you want to represent one pixel so I'm going to use this STL pixel format RGB a 8 8 8 8 which uses 1 byte for each pixel so that means for each pixel we've got we can select one of 0 to 255 different shades of each color so each pixel actually uses it actually uses 32 bits or 4 bytes three of those bytes are going to represent the color information of the pixel red green and blue and each red green and blue value can have 0 up to 255 different possible values 255 is the maximum value we can fit in one bite if we flip all the bits to one the other value here AAA's stands for alpha which is basically a transparency we won't be using that and I've read lots of reports that doesn't work in STL and that seems to be my experience but actually I think that you can set various flags here in there to various functions to get up working but I'm not going to make use of it in this tutorial in any case let's let's take a look at what's next so now we've got STL texture access static now this this has to do with the way that we're writing to the texture I can't really remember the details of this but basically we want to take a load of memory containing values for each pixel the right and directly to the texture every time we go around this loop and that flag enables us to do that so let's put that in and finally we've got screen width from the screen height so let's just copy those we've already gotten these constants defined in our program up here so we can put those in because their texture needs to know how big it's going to be and it's format that so we've got our texture and I renderer we also need to remember to deallocate a resources allocated to those so I've done that in my final program in a method called close so they were using STL destroy texture an STL destroy rendering so let's go ahead and put that in we destroy the text at first because it's using the renderer so we probably should destroy that first otherwise we're gonna have if we destroyed a renderer then we're still gonna have a texture that's using that that destroyed renderer I'm not sure if that matters but it's prudent to get them in the appropriate order let's say STL destroy renderer renderer and after that we can do s STL destroy texture texture passing texture hopefully that should do the trick it's probably a good idea to check if these are null let's take a look at the documentation and see if it says anything about returning null so I'll just search google for the function name here and so it returns null if there was an error and we can call SD I'll get error as well so we could we could check that it's probably prudent to do so let's say if renderer is equal to null then if you don't check it on your programs basically just gonna crash if this doesn't work properly let's say C out could not create render endler and let's just return some nonzero integers to signal an error and a say gif texture equals null well just gone the caps lock on here then C out could not create texture pendler and then i'll return some other value could just return north here it as I said previously it doesn't really matter if we could create the window but not the renderer we we probably that in either case we we should probably call STL quit like this if we if we could create the window and so by the stage we have crate to the window so we should probably put destroy window in here as well let's put destroy window before we call STL quit if we are able to create the renderer but not the texture we should probably destroy at least the the renderer so at this point by this point we've created the renderer but not the texture so let's destroy the renderer now this is a lot of repetition of code we could refactor this and perhaps I will in a final tutorial so I don't really like or like in a later tutorial because I don't really like having multiple calls to the same functions in here we could have something that sort of checks if any of those are null and destroys them if they're not nor later on rather than repeating all this stuff but we'll leave it from the moment because the object for the moment is just to get a basic program working even if it's ugly that demonstrates the basic principle and then we can refactor it and make it more elegant so we've got our render and our text you others there's another thing that we need now which is we need some sort of area of memory that could there's big enough to hold the information for all the pixels on the screen because we're going to take that that memory and we're going to basically write it to the texture so we're going to update the texture with that information and what I'm going to use is this type you in 32 so I'm gonna say here you in 32 pointer now what what is you in 32 this is a type declared by STL which on most systems will be equivalent to an int + int is usually 32 bits but it's possible that on some systems because C++ is not absolutely standardized that a an int might not be 32 bits could be something else so for that reason SDL of have defined this type which is guaranteed to be 32 bits but it's basically an int can we want to allocate enough enough of these for all the pixels on the screen because if you think about it here so we've got for each pixel we've got four values red green blue and alpha each of those is one byte so for every pixel we've got four bytes which is 32 bits 4 times 8 is 32 so for every pixel we need a in size of 32 bit bit of memory to represent all the information that's going to be in that pixel or the colors of it basically so we're going to allocate enough memory for all the pixels on the screen and each one's going to require 32 bits so let's say here I'll call it buffer buffer just means an area of memory basically equals new you int 32 and the amount of memory that I have to allocate is gonna be screen width screen width times the screen height because it is just screen just a rectangle which is screen width pixels wide and screen Heights pixels high so that's that buffer and we must remember to free this later on as well so let's go down here and say delete and we need the array brackets because it's it's an array that we've allocated there delete buffer okay so that looks good now you might wonder what happens if memory allocation fails some C++ systems new will return null at that point and we can we can actually configure new to make it do that but by default on most systems it will raise an exception we haven't looked at exceptions I'm saving that for my intermediate C++ course which I which is probably coming next but the bottom line is your program will crash possibly with an error message but it will crash we're not really gracefully but so hopefully somewhat gracefully if we can't allocate memory at that point the trouble is because we're not doing anything with this exception we then wouldn't be able to call these functions but I'm not gonna worry about this for this program by dearly we would check for that but you're this is gonna succeed unless your computer's incredibly tight on memory if it's so tight on memory that we can't allocate being like 32 bits for each pixel on the screen then probably a lot of programs are going to be crashing anyway so this is kind of a justification of why I'm not checking this but ideally in a kind of professional program ideally you'd probably check to see if memory could be successfully allocated although I be willing to bet that very many programs that are on sale do not check but to be perfect we really should so I've I've allocated that I've located a render and a texture and a buffer that we need to contain all the information for the pixels and I've freed all those resources as well down here now what we need to do is we need to update the texture with the information contained in this buffer which at the moment is just garbage and I then need to tell the renderer to render in other words draw the texture so let's look at how we do that I really can't remember but I'm gonna consult my final program again so if we look at I think is screened update here yeah here we go so we need this stuff so the first thing we needs SDL update texture and I've got our eventually I'm gonna move this into this loop so they were updating the texture every time this loop occurs but for the moment I'm just gonna put it above this loop let's say s DL on the Scott updates texture let's check what we do with that so the first argument is the texture so we pass in our texture second argument is null or take a look at what this is in the moment then we pass in our buffer that we actually starts containing the information that we want to update the texture with or it will do once we set that up and then we pass the pitch and the pitch is the number of memory allocated to one row of pixels so if you think about what that is it's gonna be screen width that's the number of pixels multiply it by size of new int 32 which is 4 bytes or we could just pass in screen width times 4 so on seems to be soaring something in the background I apologize for that but anyway I carry on so if we look at the documentation yeah so we've got a texture is the first argument that we need and the next argument is no if we want to update the whole thing and then we've got the raw pixel data that we want to update it with and finally we've got the pitch which is the number of bytes it says between rows that pixel data so in other words that the number of bytes per row of pixels I'm not sure I says between but if you want to go from one row to the next this is how many bytes you have to add on it's possible if we're allocated some really strange sighs for the window that we might have extra bytes at the end of a a row of pixels that aren't actually use of a rendering and then maybe the pixar will be different to the number of pixels in a row but that's not the case here so this this seems to work fine so we update the texture with the pixel information contained in this buffer and the next stage is we clear the renderer so let's call STL on the score render render Ecklie up I think it is all render clear and pass in the renderer something wrong there maybe it's rendered there okay there we go then we copy the texture to the renderer so let's do that so SDL on the score Ren render copy first document is the renderer then the texture then all know and know from what are these I don't know well the renderer and the texture obviously ah to render and the texture and then we've got null and that's the first mall is specified and we want to use the entire texture and Seconal is to specify that we want to use the entire renderer finally I think we've got render present so we've got STL underscore render present and this is basically it's just actually doing the render its presenting a render to the window it's actually rendering it so were copying the pixels to our buffer then passing the buffer to the renderer after after clearing it and then we're presenting the was to render on the screen now if if I run this there is also going to be a bit random let's try let's try running it see what happens whoops that's the wrong that's the wrong thing that's my final program let's try this so go to project build project and we'll run it so it's just black it wouldn't it would not have surprised me if we'd seen a load of garbage in that because when we allocate this memory it's gonna contain just whatever happens to be in that memory that was allocated and it seems that for me this time at least there's nothing in that memory so it's just blank but the reason it could be something in that memory what we want to do now is we want to write something in write some pixel information into this buffer so that we can see something happening on the screen I'm gonna use a very very very useful function which everyone should know about called memset memset allows you to set a block of memory with a particular value so the first argument is the buffer the second argument is the value that we're going to write into every bite of that memory so it's got 255 because we want to try to get every bite cycle to its maximum value red green blue and alpha and actually give us a white color and then if I remember rightly we need the number of bytes that we want to set which is gonna be is gonna be screen width times scream pipes number of pixels times size of invites you into 32 so hopefully I've got this right we're going to write the maximum value that we can put in a byte in every byte in all of these bites and memset is a very quick function which is one of the reasons it's very very useful so let's let's try that see what we get now so we've now we've got a wide screen which is what we wanted now another way of representing 255 which I'm going to be using in this tutorial rather than 255 probably for the most part is we can write this in hexadecimal so hexadecimal is it's another number system like binary like the familiar decimal where we use each digit can have one of sixteen possible values starting in naught and going up through 1 2 3 4 5 6 7 8 9 and then we supplement some extra values by going ABCDE and F so in hexadecimal 255 is 0xff the reason this is particularly useful but by the way Oh X is just a prefix in C++ to say this is a hexadecimal value and the reason this is really useful is because if we well we'll see later on that if we want to pack multiple bytes into one into one single U and 32 value a 30 to the end then we end up with just two digits per byte in hexadecimal system which means it's easy to see which byte represents what's in the final integer that represents the color of that pixel on the screen I'll go into that later on but that's basically the advantage of it we need exactly two digits here to specify one byte and if you're packing bytes into an int value Dan it works out that it's very easy to see which by corresponding in our case to which color but we'll get onto that later so 255 in hexadecimal is FF line art let's just run it again channel it still works so that looks that looks really good probably in the next tutorial what we'll do is well that there are several things to do next but basically we need to deal with pixel access next and we're probably going to do that in a next tutorial we also need to think about colors how we're going to devise what colors to draw on the screen and I might do that in this basic program as well if you look at this program now this is a big main function and we could carry on like adding stuff to this but it by the end it would be really huge and not easy to understand we could split this up into multiple different functions that's kind of C style programming but what we're going to be doing is splitting this up into classes but we're going to continue working with this for a moment because before I want to refactor into classes I want to just make sure we've got a little demo program and it is still quite little really that just demonstrates all the basic things that we need to do and then we can proceed forwards in confidence so we'll probably take a look at pixel access and possibly colors in the next tutorial so until then happy coding you
