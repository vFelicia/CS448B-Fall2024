With timestamps:

00:17 - hi this is John from Kenya of program
00:21 - comm and this tutorial can take a lot at
00:24 - blaring the screen and a particle
00:27 - explosion program so if we run this in a
00:30 - moment we've got an explosion and it's
00:33 - circular and it should happen at a
00:35 - similar speed on any computer although
00:38 - on slow computer is going to be jerky
00:41 - and in this tutorial we're going to look
00:45 - at adding a blur effect which will make
00:48 - you look a lot nicer and a lot more like
00:50 - some kind of weird natural phenomenon
00:53 - than it does at the moment if you are
00:56 - finding that this program is already
00:58 - jerky on your computer one thing to do
01:01 - is make sure that you compile the
01:03 - release target so in Eclipse that's
01:05 - project build configuration set active
01:08 - release because the release versions of
01:11 - programs which are not set up to use the
01:13 - Eclipse debugger or Visual C++ debugger
01:16 - which we're not using anyway and we
01:18 - haven't used a they run faster than
01:21 - debug programs if you've got a really
01:26 - old slow complete computer then you
01:28 - might get very jerky results with this
01:31 - very expensive blur algorithm expensive
01:34 - in terms of CPU time but let's have a go
01:38 - at it anyway and see see how it looks so
01:42 - I'm going to go to my main dot CPP and
01:48 - in main dot CPP we were actually at one
01:51 - point clearing the screen and I'm not
01:54 - going to clear the screen anymore I'm
01:56 - gonna get rid of this what we're gonna
01:58 - do is blur the particles out every time
02:01 - this loop iterates we're going to apply
02:03 - a blur so a particle will leave a
02:05 - blurred trace behind it and at the
02:08 - moment now if I run this which is
02:10 - see all the positions of all the parts
02:14 - of course as they go along I'm not going
02:16 - to be a race so it was quite horrendous
02:17 - but it's going to look good when we
02:20 - apply the blur I stopped going to
02:23 - implement a method which were going to
02:24 - call before updating the screen before
02:27 - displaying the results of that plotting
02:30 - the particles which are called
02:33 - screen dot blur let's call it Fox blur
02:37 - there are various ways of blurring the
02:41 - screen doing glare algorithms or so on
02:43 - photographs from that matter in photo
02:45 - editing software you can use that
02:48 - Gaussian blur which is a kind of
02:50 - natural-looking
02:51 - blur but we're going to use a thing
02:53 - called a box blur which is very simple
02:56 - to implement and this is going to be the
02:58 - most difficult bit in some ways so the
03:01 - whole tutorial is going to take a while
03:02 - to explain this but it will give some
03:05 - really beautiful effect at least if your
03:07 - computer is fast enough to display it
03:10 - reasonably quickly yeah box box blur
03:17 - there are various ways of implementing
03:20 - it and I'm gonna just implement it in a
03:24 - kind of common sense sort of way I'm
03:25 - gonna explain what you want to achieve
03:27 - I'm gonna just coat that but if you
03:29 - after seen this video if you do long
03:32 - internet you can find various ways of
03:34 - optimizing box blur to make it run
03:37 - faster so if you don't have if you do
03:39 - experience speed issues with this
03:42 - blurring algorithm there are ways of
03:44 - optimizing it and making it faster and
03:46 - you can find that by searching on Google
03:48 - quite easily there's a number of pages
03:50 - that I explain that let's go to screen
03:53 - door age and add this the prototype for
03:58 - box blur as a public function yeah and
04:02 - public
04:02 - a third go to scream dot cpp and
04:06 - somewhere in here and let's go ahead and
04:09 - implement this let's say void scream box
04:14 - blow now what i want to do here is
04:19 - instead of drawing the screen directly i
04:23 - want to look at look at the screens it
04:28 - is with pixels on it and in calculate a
04:31 - new screen with blurred values for all
04:34 - the pixels so i can't apply this
04:40 - algorithm to the screen pixel by pixel
04:42 - because we'd end up confusing the value
04:46 - calculated for one pixel with the volume
04:49 - is calculated for the last pixel we we
04:53 - can't mix up our workings as we're going
04:55 - along what we need to do is create a
04:58 - whole new scream and pixels and put our
05:03 - calculations in this second screen and
05:05 - then draw that second screen so in
05:09 - screen knowledge we've got a we've got a
05:13 - buffer somewhere here so we've got this
05:17 - buffer and i'm gonna create a second
05:19 - buffer so that we can look at one buffer
05:22 - and put our calculated blur results in
05:24 - the second buffer so let's let's copy
05:27 - this line and i'm going to call this
05:31 - buffer 1 now the buffer two so now we
05:36 - need to go to screen lock cpp look at
05:38 - the syntax errors now and wherever we
05:40 - got buffer m under Scott buffer we need
05:43 - to have buffer 1 and buffer too so here
05:47 - I've got buffer 1 and we also need to
05:50 - initialize M underscore buffer to norm
05:55 - and scrolling down here this is where
05:59 - we're actually allocating the buffer so
06:01 - I'm going to copy that line and we're
06:02 - going to allocate but for one and got
06:04 - four to hear what clearing the buffer
06:08 - getting rid of any garbage in the memory
06:10 - verse so now we want to do with buffer 1
06:12 - and what for - this is the screen play
06:15 - function which we're actually not going
06:17 - to use but just for the sake of
06:18 - completeness let's add buffer warning
06:22 - before - yeah I actually since we're not
06:30 - gonna use this function that since I'm
06:31 - not sure anymore exactly what it should
06:34 - probably do we probably better off just
06:38 - getting rid of this let's get rid of the
06:39 - screen clear function because I'm no
06:41 - longer sure what bit you would want to
06:44 - clear or why in this program so let's
06:47 - clear it let's get rid of it continuing
06:50 - in screen dot CPP this is where we're at
06:52 - in set pixel this is well at plotting
06:54 - pixels so I don't want to plot the
06:56 - pixels to the second buffer only to the
06:58 - two buffer one so I'm going to change
07:00 - this to buffer 1 and similarly when we
07:03 - update the text here with the results of
07:05 - the pixels in the buffer I'm gonna just
07:10 - use buffer 1 now and finally we need to
07:15 - remember to delete the buffers so let's
07:18 - delete buffer one until you before - now
07:23 - if we go back to the box blur
07:25 - implementation so I want a copy from one
07:28 - buffer and write to another and the
07:30 - buffer that I want to write to is buffer
07:32 - one because it's buffer 1 that were then
07:34 - going on to draw on the screen but at
07:36 - the moment all the pixels are stored in
07:39 - buffer 1 what I'm going to do is is I'm
07:41 - going to stop and I'm going to swap the
07:43 - pointers so buffer 2 points at work
07:45 - before one originally pointed out and
07:47 - then we're going to copy from buffer -
07:50 - into buffer 1 now a naive way of doing
07:53 - that would be to say and underscore
07:55 - buffer 1 equals M underscore buffer
07:59 - to a spot common yeah it's what the
08:03 - buffers so big solve info is in prefer
08:12 - to and we are drawing to M underscore
08:16 - buffer 1 so a naive way of swapping this
08:21 - would say mmm Scott before 1 equals M
08:24 - under scope of the 2 and M on Scott
08:26 - before 2 equals M underscore before 1
08:29 - the object here is to point before to at
08:33 - whatever memory buffer 1 was pointing at
08:36 - and to point before 2 or whatever memory
08:40 - but for one was pointing at how I set
08:42 - back the right way around well hopefully
08:44 - you understand what I mean
08:45 - but problem is this isn't gonna work as
08:47 - we directed but for once pointed or for
08:49 - to I known was setting buffer to 2
08:52 - pointer the redirected or for long so
08:55 - these now both point to the memory
08:57 - that's pointed at by buffer to what we
09:01 - need to do is have a temporary variable
09:02 - in here so these buffers are of type you
09:06 - int pointer you in 32 points up I need a
09:11 - very book called tempio such a pointer
09:15 - and I'm gonna say 10 equals M on the
09:21 - scope are for 1 so we've stored the
09:24 - location that buffer 1 was pointing out
09:26 - then I'm gonna change before Wang 2
09:28 - pointer the buffer to memory then I can
09:32 - change before to 2 points at the stored
09:34 - original value of before Wang which is
09:37 - now intended this is very common
09:39 - the thought designing pattern in
09:42 - computer programs where you use a
09:44 - temporary variable and use it to swap
09:46 - two values and in fact I think we've
09:48 - even seen it before in this course when
09:50 - we were reversing a string we've seen a
09:52 - similar probably we've seen a similar
09:55 - idea
09:56 - I can't quite remember so let's check
10:00 - this we've got temp at buffer one before
10:02 - one is then pointing it before too but
10:04 - for two points of ten so we've swapped
10:06 - the areas of memory around now what we
10:08 - want to do is iterate through all the
10:10 - pixels look at buffer two which now
10:13 - contains the pixel information that's
10:15 - been written into it and do some
10:17 - calculations to create the blur effect
10:19 - and copy it into the buffer one which is
10:22 - now a clean buffer and then we can plot
10:25 - those values on the screen and we're not
10:28 - gonna erase any of the buffers in
10:30 - between iterations of the game loop here
10:34 - what we're gonna do is were we're gonna
10:39 - keep blurring the same screen more and
10:42 - more so when we when we draw a screen
10:44 - will blur whatever was on the screen
10:47 - previously and then well we'll take one
10:52 - of us on the screen previously draw the
10:53 - pit new pixel on it and then blur it so
10:56 - every time we draw the screen and the
10:59 - stuff that was on it previously will get
11:01 - more and more blurred only the new stuff
11:04 - will be comparatively sharp and that's
11:07 - going to give us some beautiful trails
11:10 - on our pixels that will blare out more
11:11 - and more as a pixel moves along a bit
11:15 - like sort of comment training it's sort
11:18 - of fighting tail that sort of expands as
11:21 - a comment goes by or I imagine it does
11:24 - so now that's iterate over all the
11:27 - pixels so let's have a loop here for int
11:31 - y equals not y less than screen screen
11:40 - height y plus plus and within that we're
11:44 - going to go over all the pixels in this
11:46 - particular row so 4 into X because
11:50 - naught
11:51 - X less than screen width X plus plus and
11:59 - by the way I was thinking of
12:02 - implementing a get pixel function but
12:04 - the trouble is we've got this problem
12:05 - that we have to get the pixel from one
12:07 - buffer after and sort of right into a
12:11 - second buffer so it's not like we're
12:14 - getting set in pixels on the same buffer
12:16 - so I'm just gonna implement the get
12:18 - pixel stuff using a bit shifting stuff
12:22 - that we've seen previously
12:23 - in this function here directly in here
12:25 - to get the colors of pixels from what is
12:29 - now buffer to and then right and using
12:33 - set pixel into before one now within
12:37 - this we've we've got we've got
12:40 - particularly side enta pfizer particular
12:42 - pixel so we've got a particular pixel
12:46 - but surrounding that pixels are eight
12:48 - other pixels so you can even think of
12:51 - them as lesson zeros they look a bit
12:53 - like this so we're looking at this pixel
13:00 - in the middle here but around it are a
13:04 - bunch of other pixels and we want to
13:06 - what we want to do is we want to add up
13:10 - the color values the red green and blue
13:13 - values in each of these pixels that's a
13:16 - total of nine pixels then divide the
13:18 - results by nine and plot that result
13:21 - back into the pixel we're interested in
13:25 - setting here so the color values of this
13:28 - central pixel which which is a location
13:32 - X Y will become an average of the color
13:36 - values that all of the pixels around it
13:38 - including itself and that's what creates
13:40 - the box blur effect so to iterate
13:44 - through all these nine pixels we're
13:47 - going to have yet another nested loop in
13:49 - here
13:50 - so for int coal or I could use a short
13:55 - or something by I use int because we've
13:58 - got enough memory here for int let's say
14:03 - I say Rome put into Rho equals minus 1
14:07 - Rho less than so we'll do this loop
14:11 - while the Rho is less than plus 1 Rho
14:14 - plus plus and we're going to add this
14:17 - value which ranges from minus 1 through
14:20 - 0 up to plus 1 we're going to add that
14:23 - to our X&Y actually to the Y position
14:26 - for the row and that will give us this
14:29 - row 4 minus 1 this row 4 0 and this row
14:33 - 4 plus 1 and within that we'll have
14:36 - another nested loop for int Col equals
14:39 - minus 1 while Col is less than Walton
14:44 - sorry I should have said they're less
14:45 - than or equal to 1 because we want this
14:48 - to go minus 1 naught 1 Michael is less
14:52 - than or equal to 1 call plus plus and
14:58 - now we can calculate and develop the
15:02 - coordinates each of these pixels in this
15:04 - grid let's call this int we can call it
15:10 - like pixel X or new X or current X or
15:16 - something let's call it current x equals
15:21 - x plus cold and in current y equals y
15:30 - plus Rho so if you think about it and
15:36 - what we'll end up with here are well n
15:39 - we'll end up with for every pixel that
15:41 - we look at every single pixel on the
15:43 - screen will end up examining will ever
15:47 - iterating through all of the pixels in
15:50 - this grid of mine pixels that surround
15:53 - it including the actual pixel itself
15:56 - crop for when Rowen collar
15:58 - both 0 sis current ex is done a range
16:02 - over all of these pixels one by one if
16:05 - you think about it now we want to get
16:11 - the that color values on these
16:13 - pixels and add them all together so I'm
16:15 - gonna have outside of these this inner
16:20 - loop that iterates over the grid of
16:22 - pixels here but within these outer loops
16:24 - that iterate through each of the pixels
16:26 - in the screen I need to have some color
16:31 - values that can tote a lot and these
16:32 - color values are going to end up being
16:34 - more than you could store in an unsigned
16:36 - char because we're adding up the values
16:38 - from nine pixels so I'm gonna have here
16:40 - at int let's call it red total I'll set
16:46 - it equal to naught in green total equals
16:51 - naught an int blue total equals naught
16:56 - now we need to get the color of the
17:01 - pixel at this location and add up all
17:03 - the separate components but because
17:06 - we're iterating over all the pixels in
17:08 - the screen is possible that this pixel
17:11 - could be off the edge of the screen
17:13 - because if we start with pixel x equals
17:17 - north y equals north then we try to get
17:20 - pixel that's to thee let's take to the
17:22 - upper left of it for example that pixels
17:25 - not on the screen so we need some way of
17:27 - ignoring pixels he about off the edge of
17:30 - the screen so let's say here if current
17:34 - X is greater than or equal to 0 and so
17:41 - we want a logical honor to C++ use to an
17:44 - science and also we need to say that the
17:48 - current X must be less than the screen
17:53 - width because the maximum interest we
17:56 - can have is one less than the screen
17:59 - width because we start numbering in zero
18:01 - and we've got screen with number
18:03 - pixels this is an array so we need to
18:07 - make sure that X is between these two
18:09 - values and also we must have currents Y
18:12 - is greater than or equal to naught and
18:18 - as well
18:20 - currents y must be less than screen
18:24 - height and if so we can go ahead and get
18:29 - the color value of that pixel and by the
18:33 - way in C++ the way these fans function
18:36 - or ORS for example is that the computer
18:42 - will go through each of these clauses
18:44 - and for animals for example each of all
18:48 - of these must be true to make the
18:50 - condition as a whole true when to
18:52 - execute the Earth Day they have to all
18:54 - be true because we've handed them all
18:55 - together and so if it goes through it or
18:59 - stop checking them from the left and as
19:00 - soon as it finds one that's false it
19:03 - will stop going through all of these and
19:06 - it won't bother doing the rest because
19:08 - this is no need as soon as you find the
19:10 - false one
19:10 - it's going to check all of these and
19:12 - it's only going to do that if if every
19:16 - one of these conditions in the air that
19:17 - we've handed together are true as
19:19 - because we've used the logical animal
19:21 - let's get the pics of Conover so I'm
19:24 - going to say I'll use the STL type new
19:28 - in 32 which means that unsigned integer
19:31 - that is guaranteed to be 32 bits
19:34 - normally it means is 32 bits but it's
19:37 - not guaranteed can be different on your
19:38 - machine as possible
19:40 - so you in 32 color equals and now we
19:44 - need to access the buffer that contains
19:46 - a pixel information which is now but for
19:48 - 2 because we swapped it with baka one so
19:51 - we need to say off an underscore buffer
19:55 - to and formula is it's why sorry not why
20:04 - but current y x screen
20:10 - with that's the number of rows down that
20:14 - we're going plus current X this is how
20:20 - we get from x and y-coordinates to an
20:23 - index within this array which again you
20:28 - have to think about it a little bit the
20:29 - first time and see it but then you see
20:31 - that this does work so that guess is the
20:34 - color and now we need to get the red
20:36 - green and blue components out of that
20:38 - color so that we can sum them all
20:40 - together so you wouldn't be any good to
20:44 - summing up all the colors and then
20:46 - dividing by nine to get the average
20:48 - color because well if you think if you
20:52 - just think about it carefully you
20:54 - realize that it wouldn't work it takes a
20:55 - bit of thinking about but in fact that
20:59 - just doesn't do the trick at all we need
21:01 - to we need to actually go to the trouble
21:02 - of getting out of the individual red
21:04 - green and blue components stunning them
21:06 - separately and dividing them by nine
21:08 - separately so let's take a look the
21:11 - screamed I know not scream - let's take
21:14 - a look at set pixel actually because in
21:17 - that we see other color information maps
21:20 - to an integer we see that when we valley
21:23 - red here and then shifted red a byte
21:27 - along to the left and then green in and
21:29 - blue so the way it works is we've got a
21:34 - alpha value I think yeah because I know
21:38 - that blue is also shifted right at the
21:40 - end though so I think the format here is
21:42 - we've got red here green blue and then
21:47 - alpha which is a transparency that we're
21:50 - not using so the red if I've got this
21:54 - right is shifted three bytes along to
21:59 - the left in this and this thing here so
22:02 - as we start off putting it right there
22:04 - and then by the time we finish we've
22:07 - done one two three shifts which is 24
22:11 - bits three bikes to move it three bikes
22:14 - over whoops
22:16 - to the to the right hand side there
22:19 - do we do my typing there there we go so
22:24 - to get the red value out what we can do
22:27 - is let's go back to the box blur we can
22:31 - say here what again we use the STL type
22:34 - u int 8 which is an 8-bit unsigned 8-bit
22:39 - int or we could use on sign char it's
22:41 - the same red equals color and we need to
22:47 - write shift the color by 24 bits to get
22:52 - the red value if I've got this right and
22:55 - this is this is tricky to get right
22:57 - every time i implement it I do something
23:00 - wrong and then have to think very
23:02 - carefully over what I've done putting in
23:04 - see out statements to check that all the
23:06 - different values are what they expect or
23:08 - what I expect them to be but I'm hoping
23:12 - that I can get it right this time
23:13 - so now to get the ewings 8 green value
23:18 - that was only shifted by 16 bits in the
23:21 - color and he wins
23:24 - ADEs blue is just shifted by 8 bits and
23:29 - the last value minute color is the red
23:34 - value so he I just shifted 8 after I put
23:36 - the blue on I only shifted it by 1 by 8
23:39 - bits to the left so if we shift the
23:42 - color by 8 it's this way and then take
23:44 - the last two digits of it and in fact in
23:46 - hexadecimal we've got a blue value as we
23:49 - saw in in a previous tutorial now we can
23:53 - say here if we get if we get a valid
23:58 - pixel that we can get color values out
24:00 - of it we're gonna say red total plus
24:03 - equals red green total plus equals green
24:10 - blue total plus equals blue
24:15 - now we've summed up all these values for
24:19 - a box surrounding this pixel here at X&Y
24:23 - and we're going to go after this loop
24:26 - that iterates over that grid at nine
24:27 - pixels and now we can say you int 30 you
24:32 - in eight this is going to be the actual
24:34 - color that was set pixel to red because
24:37 - red total divided by nine is there in
24:41 - nine pixels in that grid you insane
24:43 - green equals green total divided by nine
24:48 - you in eight blue equals blue total
24:52 - divided by nine we've used red up here
24:55 - but there's no problem using it here as
24:57 - well because remember variables scoped
25:00 - to the innermost pair of brackets where
25:02 - they're defined so yeah these these
25:05 - colors they only exist between these two
25:08 - brackets here these variables then we
25:11 - use them and then we discard them
25:13 - basically similarly these totals here
25:16 - they're stoves to these brackets that
25:20 - actually define the business of checking
25:23 - one pixel think you should be there I've
25:30 - got that right yeah so that they're
25:32 - defined to the inner most set of
25:34 - brackets belonging to the four loops
25:36 - that actually check one individual pixel
25:39 - and then from the next pixel these are
25:42 - really close so that completely reset
25:45 - okay so now we've got that we can use
25:47 - our septic so which remember sets in to
25:49 - buffer one but we copied the the last
25:52 - lot of pixel information on the screen
25:54 - to buffer to we're reading from that and
25:58 - plot and banked but for one with set
26:00 - pixel which will plot the results of
26:03 - their on the screen and next time you go
26:06 - round round the game moved in main dot
26:08 - CPP will blur that same buffer again
26:12 - after plotting the new pixel on it so
26:15 - it'll get more and more blurred as it
26:17 - goes along for any given particular
26:19 - pixel trail
26:20 - which is what we want so let's say set
26:23 - pixel XY red green blue now if I've got
26:31 - this right it will work and if I haven't
26:33 - it won't and let's try this let's run it
26:37 - I don't know if I've forgotten anything
26:38 - yeah so yes it works
26:42 - now this doesn't look too great at a
26:45 - moment when it expands a bit like this
26:47 - starts to look kind of cool especially
26:52 - if you look at the pixels on the outer
26:54 - edge the reason it doesn't look as good
26:56 - as it does in the final program is
26:58 - because we still need to tweak the
27:00 - behavior of the pixels we've got big
27:02 - sort of solid white bunch of pixels
27:05 - there it won't load a solid color and we
27:08 - want to do some things like making them
27:09 - move in a more interesting way and
27:11 - trying to make this circle more ragged
27:13 - as well which we can also do so we're
27:16 - going to look at that in future
27:17 - tutorials but I leave it there for now
27:19 - so again I'd encourage you to have a go
27:22 - at that if you really get stuck and you
27:24 - can't get it to work and can always copy
27:27 - my source code here and try to examine
27:31 - what you've got different to my code um
27:34 - I'll make this code available wherever
27:36 - the lectures available on my website on
27:39 - YouTube I can't attach the source code
27:41 - it will be on my website if you're
27:43 - watching on udemy.com it'll be attached
27:45 - to the lecture if there's some other
27:47 - system I have this video on that only
27:50 - allows you to attach source code at the
27:53 - end of all the lectures than out attach
27:54 - it to the final lecture but it will be
27:56 - there somewhere except on YouTube where
27:58 - you can attach files but it's this is
28:01 - this is very tricky but if you can get
28:03 - your head around this or even 90% of
28:05 - this and if you can get it working more
28:07 - to the point then you've really done
28:10 - something quite amazing took me a long
28:12 - time before I could get the hang of blur
28:15 - algorithms like this this is pretty
28:17 - advanced C++ really you have to think
28:19 - hard to get this to work so I miss
28:22 - challenge but it's a
28:23 - it's worth having having it go out so
28:28 - we'll look at probably changing pixel
28:31 - motion a bit more in the next tutorial
28:32 - but we've almost come to the end of this
28:34 - now we've almost got a final program
28:36 - pass them until next time happy coding
28:46 - you

Cleaned transcript:

hi this is John from Kenya of program comm and this tutorial can take a lot at blaring the screen and a particle explosion program so if we run this in a moment we've got an explosion and it's circular and it should happen at a similar speed on any computer although on slow computer is going to be jerky and in this tutorial we're going to look at adding a blur effect which will make you look a lot nicer and a lot more like some kind of weird natural phenomenon than it does at the moment if you are finding that this program is already jerky on your computer one thing to do is make sure that you compile the release target so in Eclipse that's project build configuration set active release because the release versions of programs which are not set up to use the Eclipse debugger or Visual C++ debugger which we're not using anyway and we haven't used a they run faster than debug programs if you've got a really old slow complete computer then you might get very jerky results with this very expensive blur algorithm expensive in terms of CPU time but let's have a go at it anyway and see see how it looks so I'm going to go to my main dot CPP and in main dot CPP we were actually at one point clearing the screen and I'm not going to clear the screen anymore I'm gonna get rid of this what we're gonna do is blur the particles out every time this loop iterates we're going to apply a blur so a particle will leave a blurred trace behind it and at the moment now if I run this which is see all the positions of all the parts of course as they go along I'm not going to be a race so it was quite horrendous but it's going to look good when we apply the blur I stopped going to implement a method which were going to call before updating the screen before displaying the results of that plotting the particles which are called screen dot blur let's call it Fox blur there are various ways of blurring the screen doing glare algorithms or so on photographs from that matter in photo editing software you can use that Gaussian blur which is a kind of naturallooking blur but we're going to use a thing called a box blur which is very simple to implement and this is going to be the most difficult bit in some ways so the whole tutorial is going to take a while to explain this but it will give some really beautiful effect at least if your computer is fast enough to display it reasonably quickly yeah box box blur there are various ways of implementing it and I'm gonna just implement it in a kind of common sense sort of way I'm gonna explain what you want to achieve I'm gonna just coat that but if you after seen this video if you do long internet you can find various ways of optimizing box blur to make it run faster so if you don't have if you do experience speed issues with this blurring algorithm there are ways of optimizing it and making it faster and you can find that by searching on Google quite easily there's a number of pages that I explain that let's go to screen door age and add this the prototype for box blur as a public function yeah and public a third go to scream dot cpp and somewhere in here and let's go ahead and implement this let's say void scream box blow now what i want to do here is instead of drawing the screen directly i want to look at look at the screens it is with pixels on it and in calculate a new screen with blurred values for all the pixels so i can't apply this algorithm to the screen pixel by pixel because we'd end up confusing the value calculated for one pixel with the volume is calculated for the last pixel we we can't mix up our workings as we're going along what we need to do is create a whole new scream and pixels and put our calculations in this second screen and then draw that second screen so in screen knowledge we've got a we've got a buffer somewhere here so we've got this buffer and i'm gonna create a second buffer so that we can look at one buffer and put our calculated blur results in the second buffer so let's let's copy this line and i'm going to call this buffer 1 now the buffer two so now we need to go to screen lock cpp look at the syntax errors now and wherever we got buffer m under Scott buffer we need to have buffer 1 and buffer too so here I've got buffer 1 and we also need to initialize M underscore buffer to norm and scrolling down here this is where we're actually allocating the buffer so I'm going to copy that line and we're going to allocate but for one and got four to hear what clearing the buffer getting rid of any garbage in the memory verse so now we want to do with buffer 1 and what for this is the screen play function which we're actually not going to use but just for the sake of completeness let's add buffer warning before yeah I actually since we're not gonna use this function that since I'm not sure anymore exactly what it should probably do we probably better off just getting rid of this let's get rid of the screen clear function because I'm no longer sure what bit you would want to clear or why in this program so let's clear it let's get rid of it continuing in screen dot CPP this is where we're at in set pixel this is well at plotting pixels so I don't want to plot the pixels to the second buffer only to the two buffer one so I'm going to change this to buffer 1 and similarly when we update the text here with the results of the pixels in the buffer I'm gonna just use buffer 1 now and finally we need to remember to delete the buffers so let's delete buffer one until you before now if we go back to the box blur implementation so I want a copy from one buffer and write to another and the buffer that I want to write to is buffer one because it's buffer 1 that were then going on to draw on the screen but at the moment all the pixels are stored in buffer 1 what I'm going to do is is I'm going to stop and I'm going to swap the pointers so buffer 2 points at work before one originally pointed out and then we're going to copy from buffer into buffer 1 now a naive way of doing that would be to say and underscore buffer 1 equals M underscore buffer to a spot common yeah it's what the buffers so big solve info is in prefer to and we are drawing to M underscore buffer 1 so a naive way of swapping this would say mmm Scott before 1 equals M under scope of the 2 and M on Scott before 2 equals M underscore before 1 the object here is to point before to at whatever memory buffer 1 was pointing at and to point before 2 or whatever memory but for one was pointing at how I set back the right way around well hopefully you understand what I mean but problem is this isn't gonna work as we directed but for once pointed or for to I known was setting buffer to 2 pointer the redirected or for long so these now both point to the memory that's pointed at by buffer to what we need to do is have a temporary variable in here so these buffers are of type you int pointer you in 32 points up I need a very book called tempio such a pointer and I'm gonna say 10 equals M on the scope are for 1 so we've stored the location that buffer 1 was pointing out then I'm gonna change before Wang 2 pointer the buffer to memory then I can change before to 2 points at the stored original value of before Wang which is now intended this is very common the thought designing pattern in computer programs where you use a temporary variable and use it to swap two values and in fact I think we've even seen it before in this course when we were reversing a string we've seen a similar probably we've seen a similar idea I can't quite remember so let's check this we've got temp at buffer one before one is then pointing it before too but for two points of ten so we've swapped the areas of memory around now what we want to do is iterate through all the pixels look at buffer two which now contains the pixel information that's been written into it and do some calculations to create the blur effect and copy it into the buffer one which is now a clean buffer and then we can plot those values on the screen and we're not gonna erase any of the buffers in between iterations of the game loop here what we're gonna do is were we're gonna keep blurring the same screen more and more so when we when we draw a screen will blur whatever was on the screen previously and then well we'll take one of us on the screen previously draw the pit new pixel on it and then blur it so every time we draw the screen and the stuff that was on it previously will get more and more blurred only the new stuff will be comparatively sharp and that's going to give us some beautiful trails on our pixels that will blare out more and more as a pixel moves along a bit like sort of comment training it's sort of fighting tail that sort of expands as a comment goes by or I imagine it does so now that's iterate over all the pixels so let's have a loop here for int y equals not y less than screen screen height y plus plus and within that we're going to go over all the pixels in this particular row so 4 into X because naught X less than screen width X plus plus and by the way I was thinking of implementing a get pixel function but the trouble is we've got this problem that we have to get the pixel from one buffer after and sort of right into a second buffer so it's not like we're getting set in pixels on the same buffer so I'm just gonna implement the get pixel stuff using a bit shifting stuff that we've seen previously in this function here directly in here to get the colors of pixels from what is now buffer to and then right and using set pixel into before one now within this we've we've got we've got particularly side enta pfizer particular pixel so we've got a particular pixel but surrounding that pixels are eight other pixels so you can even think of them as lesson zeros they look a bit like this so we're looking at this pixel in the middle here but around it are a bunch of other pixels and we want to what we want to do is we want to add up the color values the red green and blue values in each of these pixels that's a total of nine pixels then divide the results by nine and plot that result back into the pixel we're interested in setting here so the color values of this central pixel which which is a location X Y will become an average of the color values that all of the pixels around it including itself and that's what creates the box blur effect so to iterate through all these nine pixels we're going to have yet another nested loop in here so for int coal or I could use a short or something by I use int because we've got enough memory here for int let's say I say Rome put into Rho equals minus 1 Rho less than so we'll do this loop while the Rho is less than plus 1 Rho plus plus and we're going to add this value which ranges from minus 1 through 0 up to plus 1 we're going to add that to our X&Y actually to the Y position for the row and that will give us this row 4 minus 1 this row 4 0 and this row 4 plus 1 and within that we'll have another nested loop for int Col equals minus 1 while Col is less than Walton sorry I should have said they're less than or equal to 1 because we want this to go minus 1 naught 1 Michael is less than or equal to 1 call plus plus and now we can calculate and develop the coordinates each of these pixels in this grid let's call this int we can call it like pixel X or new X or current X or something let's call it current x equals x plus cold and in current y equals y plus Rho so if you think about it and what we'll end up with here are well n we'll end up with for every pixel that we look at every single pixel on the screen will end up examining will ever iterating through all of the pixels in this grid of mine pixels that surround it including the actual pixel itself crop for when Rowen collar both 0 sis current ex is done a range over all of these pixels one by one if you think about it now we want to get the that color values on these pixels and add them all together so I'm gonna have outside of these this inner loop that iterates over the grid of pixels here but within these outer loops that iterate through each of the pixels in the screen I need to have some color values that can tote a lot and these color values are going to end up being more than you could store in an unsigned char because we're adding up the values from nine pixels so I'm gonna have here at int let's call it red total I'll set it equal to naught in green total equals naught an int blue total equals naught now we need to get the color of the pixel at this location and add up all the separate components but because we're iterating over all the pixels in the screen is possible that this pixel could be off the edge of the screen because if we start with pixel x equals north y equals north then we try to get pixel that's to thee let's take to the upper left of it for example that pixels not on the screen so we need some way of ignoring pixels he about off the edge of the screen so let's say here if current X is greater than or equal to 0 and so we want a logical honor to C++ use to an science and also we need to say that the current X must be less than the screen width because the maximum interest we can have is one less than the screen width because we start numbering in zero and we've got screen with number pixels this is an array so we need to make sure that X is between these two values and also we must have currents Y is greater than or equal to naught and as well currents y must be less than screen height and if so we can go ahead and get the color value of that pixel and by the way in C++ the way these fans function or ORS for example is that the computer will go through each of these clauses and for animals for example each of all of these must be true to make the condition as a whole true when to execute the Earth Day they have to all be true because we've handed them all together and so if it goes through it or stop checking them from the left and as soon as it finds one that's false it will stop going through all of these and it won't bother doing the rest because this is no need as soon as you find the false one it's going to check all of these and it's only going to do that if if every one of these conditions in the air that we've handed together are true as because we've used the logical animal let's get the pics of Conover so I'm going to say I'll use the STL type new in 32 which means that unsigned integer that is guaranteed to be 32 bits normally it means is 32 bits but it's not guaranteed can be different on your machine as possible so you in 32 color equals and now we need to access the buffer that contains a pixel information which is now but for 2 because we swapped it with baka one so we need to say off an underscore buffer to and formula is it's why sorry not why but current y x screen with that's the number of rows down that we're going plus current X this is how we get from x and ycoordinates to an index within this array which again you have to think about it a little bit the first time and see it but then you see that this does work so that guess is the color and now we need to get the red green and blue components out of that color so that we can sum them all together so you wouldn't be any good to summing up all the colors and then dividing by nine to get the average color because well if you think if you just think about it carefully you realize that it wouldn't work it takes a bit of thinking about but in fact that just doesn't do the trick at all we need to we need to actually go to the trouble of getting out of the individual red green and blue components stunning them separately and dividing them by nine separately so let's take a look the screamed I know not scream let's take a look at set pixel actually because in that we see other color information maps to an integer we see that when we valley red here and then shifted red a byte along to the left and then green in and blue so the way it works is we've got a alpha value I think yeah because I know that blue is also shifted right at the end though so I think the format here is we've got red here green blue and then alpha which is a transparency that we're not using so the red if I've got this right is shifted three bytes along to the left in this and this thing here so as we start off putting it right there and then by the time we finish we've done one two three shifts which is 24 bits three bikes to move it three bikes over whoops to the to the right hand side there do we do my typing there there we go so to get the red value out what we can do is let's go back to the box blur we can say here what again we use the STL type u int 8 which is an 8bit unsigned 8bit int or we could use on sign char it's the same red equals color and we need to write shift the color by 24 bits to get the red value if I've got this right and this is this is tricky to get right every time i implement it I do something wrong and then have to think very carefully over what I've done putting in see out statements to check that all the different values are what they expect or what I expect them to be but I'm hoping that I can get it right this time so now to get the ewings 8 green value that was only shifted by 16 bits in the color and he wins ADEs blue is just shifted by 8 bits and the last value minute color is the red value so he I just shifted 8 after I put the blue on I only shifted it by 1 by 8 bits to the left so if we shift the color by 8 it's this way and then take the last two digits of it and in fact in hexadecimal we've got a blue value as we saw in in a previous tutorial now we can say here if we get if we get a valid pixel that we can get color values out of it we're gonna say red total plus equals red green total plus equals green blue total plus equals blue now we've summed up all these values for a box surrounding this pixel here at X&Y and we're going to go after this loop that iterates over that grid at nine pixels and now we can say you int 30 you in eight this is going to be the actual color that was set pixel to red because red total divided by nine is there in nine pixels in that grid you insane green equals green total divided by nine you in eight blue equals blue total divided by nine we've used red up here but there's no problem using it here as well because remember variables scoped to the innermost pair of brackets where they're defined so yeah these these colors they only exist between these two brackets here these variables then we use them and then we discard them basically similarly these totals here they're stoves to these brackets that actually define the business of checking one pixel think you should be there I've got that right yeah so that they're defined to the inner most set of brackets belonging to the four loops that actually check one individual pixel and then from the next pixel these are really close so that completely reset okay so now we've got that we can use our septic so which remember sets in to buffer one but we copied the the last lot of pixel information on the screen to buffer to we're reading from that and plot and banked but for one with set pixel which will plot the results of their on the screen and next time you go round round the game moved in main dot CPP will blur that same buffer again after plotting the new pixel on it so it'll get more and more blurred as it goes along for any given particular pixel trail which is what we want so let's say set pixel XY red green blue now if I've got this right it will work and if I haven't it won't and let's try this let's run it I don't know if I've forgotten anything yeah so yes it works now this doesn't look too great at a moment when it expands a bit like this starts to look kind of cool especially if you look at the pixels on the outer edge the reason it doesn't look as good as it does in the final program is because we still need to tweak the behavior of the pixels we've got big sort of solid white bunch of pixels there it won't load a solid color and we want to do some things like making them move in a more interesting way and trying to make this circle more ragged as well which we can also do so we're going to look at that in future tutorials but I leave it there for now so again I'd encourage you to have a go at that if you really get stuck and you can't get it to work and can always copy my source code here and try to examine what you've got different to my code um I'll make this code available wherever the lectures available on my website on YouTube I can't attach the source code it will be on my website if you're watching on udemy.com it'll be attached to the lecture if there's some other system I have this video on that only allows you to attach source code at the end of all the lectures than out attach it to the final lecture but it will be there somewhere except on YouTube where you can attach files but it's this is this is very tricky but if you can get your head around this or even 90% of this and if you can get it working more to the point then you've really done something quite amazing took me a long time before I could get the hang of blur algorithms like this this is pretty advanced C++ really you have to think hard to get this to work so I miss challenge but it's a it's worth having having it go out so we'll look at probably changing pixel motion a bit more in the next tutorial but we've almost come to the end of this now we've almost got a final program pass them until next time happy coding you
