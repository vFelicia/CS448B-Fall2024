um i will um just um just go over the agenda um and also just brief back into indexing and then we'll come back to where we were before so um our agenda today is back on the list um also introductions uh because we are recording right now in fact um so uh if you have um uh so so just as a heads up this will be listed on a youtube later um so we'll be covering next things licensing list functions and also a demo at the end um i'm not sure when we arrived but i'll just go over this really quick um and that's you index uh you index uh you next starting at zero um you can't index out of the array although i still throw a list error i'll show an example all that so you can exit you start indexing zero the first element in uh one in this case you try to index out but if you'll throw an indexer you can index from the back as well negative one being this element right here essentially uh one from the back or in this case it is the one for from the back and then you can do that for as much as you like as well and then you can also run into index areas if you try to index out from the back so if you have any questions or the people who came late then please come and ask questions um yeah so you can do some uh setting of the actual values itself during this uh mutability um yeah earning one inverse list yeah that's absolutely correct um the reason why that is is because the the the the two optional parameters that you're passing in um for the first option uh is zero because uh the default is zero and it starts to zero uh the next optional parameter um or a default parameter is the end of the list or the language list so essentially you try to go from the the end of the list to the beginning of the list indexing backwards or using a negative one step in there or it will go backwards so more on slicing that's more exciting so the question was why does this example not include zero or not include one you can see that you know it goes from five four three and two and it doesn't do one the reason why that is is because the end operator uh or the end parameter um does not include uh it is inc conclusive so it is sort of the same idea once you go from zero to four it doesn't include this five because the last element is not um it's not included so if you go from four to zero zero is not included so therefore one won't be printed so uh um yeah so this is what i was talking about with regards to uh the default parameters uh the digital default parameter of this was is a negative one i believe so um actually sorry it's not it's not exactly negative one but it's essentially to the end of the list so therefore you start at zero and two three and then it goes uh it's zero one two three yeah to four and then it goes to the end of the list the actual counter of this being the end of the list might be it's not exactly that it's not exactly the blank slate actually yeah the the the optional parameter in this case would be the end of the list and then if you try to index out to the end of the list uh normally it'll throw an index error but if you want to include that left element you go one above what you can usually um index um in this case the optional parameter is not the end parameter but the first parameter that being the beginning that lifts so you go from zero one two and then not include into three so that would be zero one two not including three which would be the four in this case so one two three and then um in this case um here i'll make it even better um the optional parameter is the beginning of the list the end of the list and negative one is the error that you put in for the step so therefore it would then reverse the list so you're going from uh not quite the beginning of the list because then uh uh if you try to do do this and this i believe i lost my mistake it does pretty empty but it's something close to you know the end of the list and that way you're able to reverse it so as far as what is a print you know you have no start parameter you have no end parameter so therefore the optional parameters or the default parameters of those uh is the beginning of the list to the end of the list so therefore this prints out the entire list this is just an example in which you um do the exact same thing except you have a step of two so it'd be one three and possibly including five i think it does include five yeah and then this is an example of what camilo had said before about this reversing list so good all right cool so um we sort of had this list uh data structure we've been interacting with it through slicing and initialization as well as um indexing as well but there are also just a variety of other functions that you can use with a list in order to modify or uh or to sort of work with what is the actual contents of the list um and this is by no means an exhaustive um account of all the list functions in fact in order to get that you might want to google python three lists functions over here the python box you can see that there is quite a lot but we'll just be covering perhaps the most important ones so um let's see you begin with this initialized list of one two three two um this is something that we've seen before and then what happens when you use the pen method with the element that you want to append to it you place it at the end of the list over here and not only do you do that you modify the list itself so it doesn't sort of it doesn't return a copy of the list it is you know the mutable data structure itself so when you do that you get one two three two four because four has just been intended to do that um let's see i'm gonna make this not just i'm not i'm not gonna make it pop too because most common use cases of pop is that um it removes the last element which i should be working this it removes the last element the last index um and then returns that element as well so you have initialized as one two three and two you first printed a so that should just be one two three and two and then when you pop it it will return the two because it removes the element at the last list and then when you print again the list should have been modified such that the last element of the list is no longer there so you can see that you know you start with your original data structure you pop it it returns to and then you print it again and then it no longer has two at the end and then you can pass some parameters as well such that you remove things in the middle of the actual data structure as well although um i would advise you actually to not do this for reasons i won't get into now but essentially there are certain operations in python that's uh for list specifically that runs slower than others because of the way that the lists are implemented actually in the in the depths of the language so the difference between pop and remove is that uh you can see that um when when we try to pop the the index at two it returns the three and then it modifies it such that you have your one two two list afterwards and in this case actually removes the first two yeah so actually remove doesn't remove the actual um index but remove the first case of what you passed in here and this is an example of a function that may run slower if you have like a longer list but we don't want to get into that right now and also when you do that it doesn't uh return to as well so you can see it best most likely this will print a none and then this is different from when you popped it it actually did return the value and then finally insert another example of something that most likely you probably don't want to do too often or you have a very long list because they'll run slowly um is um insert um let's see inserts index two right so the first parameter is the index you want to insert that so in that case it'd be zero one and then two over here the inserts sort of before so this it would be um index two if you got inserted um uh once you have inserted it so you can see that is the case that you have uh next arrow index one and the next two and because you inserted index two ten is now there um see if i can show an example of why you don't want to pop or insert or you want to pop it a space for index and i'll show you why that may be so we're going to create a very large list of say a million elements um i'm not going to print a but we're going to just see how long it takes for these functions to run so see let's uh pop right here is that so pop will be very quick with an insert which should be very slow if you try to insert and like the middle of the actual so pop is very quick and then see how long it takes to get to here it was all right so maybe we'll add another zero search 10 and next two oh wait yeah insert 10 i think um generally these their structures are quite efficient um from a clear sense perspective um this operation should take a little bit longer but uh so an example of why you may not want to insert is because generally if you insert see if you do this and just comment out the actual insert this will be pretty quick i believe yeah this should be pretty quick but then this itself should be relatively slow when comparing the two although still not super slow um if we can use the timing function and get more into that then i would but it's a little bit slow let's see i'll start your interrupt i only see half your shirt screen i don't see the console so let me get to this question first can you do with the strings through the list yes um and the reason why that is is actually so i'm not sure by it um you can do indexing and slicing of a string but because what it does is that it converts a string into a list prior to doing that once you try to use any sort of indexing or spacing operations on it but and then and you can see like an example that here i will show you okay this should be fine so rather than oh god it should really be working so rather than this being a list now it's string a b c d e f g i'm indexing works as you might expect you have to try to get the character as index zero um it's a slicing works but perhaps not in the way that you may expect so for example you want to slice from zero to two you might think that okay it's a b right zero one but then when you do that um actually it does work the way that you expect um see if this works as well yeah so uh slide slicing works with the list as well um but then because a streaming is an immutable type when you try to append something not only will not recognize that function because string object has no uh and its list um list has that uh as that function against two lists first then you would be able to then see this this is now a valid operation just kind of a to the end of it um but uh yeah um because append is something that modifies the actual immutable uh data structure list and the string is an immutable data structure you won't be able to append to it and in fact when you do things like string edition a is equal to a plus another string let's add a to the end of that it's creates a um it creates a new string actually it doesn't append to the end of it um the details of which you might learn in computer science class regarding data functions and algorithms but essentially rather than just adding a to the end of the string what it does is that it copies the entire thing as an a at it and then it says so it's much slower operation which might come into play if you um if you sort of work with long strings or long lists or long screens as opposed to long lists so this is sort of a interesting demo of what the capabilities of the list are sort of combining everything that we had just seen in addition to what we had learned last week in regards to infinite loops and um what happened here anyways i'll just ignore that i guess hopefully the invitation is not okay big list if envelope syntax line 38 i see okay somebody over here i guess i'm a little bit confused about which one i should be using let's so um there's a few configs that you can set um first it runs through this infinite wild true loop um it prints out this cursor for you to sort of type into and then it waits for your input um in this case if we type exit it will just um let's go here oh yeah i think you'll run this one again so actually i will start this again i won't exit i should actually exit the terminal um because you just input exit it reads configuration and um if you do it again try to set a config like screen just just initialize this list um all right yeah so uh you're trying to set one under configs but it has to be in the format of config is equal to the value say like 100 and then afterwards that contact is set so therefore when you exit it should um actually kind of confused about what this example is because i didn't quite i was the one who wrote it um all right yes let's print.config list once we actually exit screen brightness to 100 and then when you exit out it should print out you know your list of screen rightness and now how that does that is that um it takes your input um it splits uh this parameter or the string you just put it into two parts so the extreme brightness part and the and the actual um integer part it checks if um it's in the configs that that being said right here and then once you exit it out it will just print out how it was so um yeah that's like so something that you can do with liz you can write command line operations although this is by all means sort of um it's uh like a small part of what lists are used for in actual computer science or software development context yes camille says you can always convert a string to a list um yes that that's true um the difference being that uh when you do so it then becomes list which is sort of immutable data structure and then in order to get it back into a string you have to use the the the join function um which i can actually i think this is quite a useful list function so i will sort of demonstrate that as well to go back to that point so you have your string as as before abcde abc um if you print the list is going to also then you convert it into the list itself you can see that you know it's not the string itself but rather it's the list of the individual charge of the string um and then once you have that in that format you can convert it back into a string by using the join function which you take all the elements inside of this list and then you put it together with the separator over here so when you do that it becomes acde again if you change the separator to a dash it'll print out a so as i said before this is all the things that you can do or all the functions that were list in fact that itself was a stream function that took a list in as a parameter so there's even more things that you can do with the lists that we can't possibly get through um in all the time today so now we're under 505 which is in which you the audience answers five questions in five minutes and i believe that emily will be taking over for this uh yeah so let's start the five under five okay that's perfect let's start with the first question so as you can see we have a section of the code on the screen so can anyone tell me what the output would be for this code okay so here is the answer so as you can see the output is actually four cat and one so the reason for this is because um the first start option is not given and the second stop option is also not given which means that it will start at the beginning of the string and it will move all the way until the end of the string note the negative in the steps that's moving backwards so it'll start at four which is the first index um in a string that is going backwards and then yeah yep perfect if everyone understands that then you can see how the output would be four cat and one so let's move on to the next slide hey so what is the output of this code okay perfect so as you can see yep the answer is boop that is correct and just as a reminder of something you might have learned before since the first if statement is an and uses an and expression the statement will only evaluate the first part so it will evaluate if a is smaller than 10 and if the first condition is false it won't even check the second part which is four in a and it'll just skip to the else statement and print boop and it's similar to an or expression where if the first condition in the expression is already true the second one won't be checked at all so it will like the program will try and save the time and just skip checking something that doesn't need to be checked next question question number three now you have this piece of code what do you think it will output this one's actually quite tricky so you guys are actually correct it will be an empty list because it starts from the negative indexing and it's trying to go all the way back to the beginning but since a list can't yeah well you were correct in guessing it was an empty list actually because of how the indexing works it won't be able to access the earlier indexes in the code so it'll just produce an empty set okay fourth question so here is an example of a piece of code and you guys will have to try and spot the problem in it so let's go in to the answer slide and that is correct as you can see in the second line it uses two different types of quotation marks and that doesn't really work in python so you should only use one set of quotation marks yes it is it's super hard to spot these problems but it's great for debugging that you can actually see where the problems in the code is so yeah just remember that each pair of quotation marks should be only used to either use the double or just the single when you're you trying to identify something as a string okay everyone last question it's another kind of error that could happen when writing your code see what the answer is it's all good it's all good so as you can see these the problem with using true is true equals false is in the first line because we aren't able to use keywords as variables or identifiers so since at the beginning in the first line they're trying to use true as a variable but in the loop they're trying to use true for it um as like a boolean and that is impossible so it's just you try and avoid using keywords such as true false and or not these kind of terms as variables because they're actually used as identifiers in the in programming already so just avoid using these words as variables okay cool i think that is the end of the five under five all right great thank you very much emily even though i can hear you the entire time it seems like we've got some great participation so i guess i'm going to skip the workshop because this is very similar to that example that we had before regarding system preferences and configs so um because we're coming up on time i know that people have to leave soon but if you're able to sort of attempt this challenge problem then this would be very good for your understanding of lists and how to use them in fact in this problem uh you may have to even look up some documentation about how to do certain things uh using a python list python or using separate data structures to make it uh faster so the challenge problems is in uh itself find the first missing positive number in the list so for example um zero itself is not a missing positive number um so let's check out one one is not missing because it's in the list two is not listing uh because it's in the list and three is not listing uh missing these lists so therefore the first missing positive number is four uh it should do the same thing with this next list uh one is in the list two is in the list but the first one missing positive number is three um regardless of whatever this is so the first challenge is to do so without certain you can do it in sort of a slow way without using any extra data structures um because this was originally a set stand lists lessons so we sort of have some remnants of that um the next challenge is to do it with using a set um you may have to do some googling on how to exactly use that but the applications here are is pretty straightforward um and then finally uh the challenge is to do it both in a way that scales very well um it scales such that when you run this algorithm it it goes pretty fast regardless of how long the list itself is and also you have to do it without using any extra space or any new data structures or converting your existing data structure into something else i'll go over the answer and this function or this function itself essentially what it does is that it just times how long a function takes so we have three solutions here one with the new data structure that you haven't learned yet this uses a set um and it uses extra space as well so uh this is sort of a fast but a little bit cheaty way because or actually it's not like cheap but it just doesn't fulfill the um the actual stipulations of the challenge itself this one does but it is quite slow and we can see exactly how slow uh later and this one is the version that uses no extra data structures or extra space and it uses everything that we learned in this lesson in addition to the previous lessons regarding for loops and also it runs in a relatively quick way so i'll just give sort of a quick um a quick overview if people are still in this call um let's see so regarding extra space um it uses something called the set what we do is that you know we take everything um that's uh in the array and then we cast it or convert it into a set and what a set allows you to do is that allows you to look up whether or not something is in the set or it's not in the descent in a very fast time it's not sort of a search through the entire array it is just in we call it a constant time operation or or one operation so then you go from one starting at one you know the first positive number to the last possible positive number that which would be the length of the array because um if you consider that you know you have all these elements in this ring and if you have uh and all of them are there then the last possible one is the is the last element or the actual length of the ring so if you run uh this function um it checks if it's uh if if when you're going through from all the possible positive numbers um checks if it's in the set itself and then if it's not there you return that number otherwise you return one above it which is all the possible elements that could be there are in the original array and then therefore you want to return one over that which is the first possible um uh missing positive element this one is slower and it looks very very similar but essentially what you do is that you don't ever create this new set you don't use extra space and you don't use the the data structure set um at all but rather what you do is that you do uh you you check if and it's not in the array in fact this keyword is exactly the same but because the array is an ordered uh data structure you can do a search very quickly for the actual like what is inside of the array or this little list so therefore it'll run very very slowly when it starts to get to larger um larger elements and then i can show you and then this i can get into later but i'll just just show you that it took 12 seconds for a list of 10 000 elements for the slow first amazing to run which was what i had said for the brings low and then for the one that didn't fulfill the challenges stipulations it took just uh 0.25 uh milliseconds which is two orders of magnitude probably three orders of magnitude faster than the slow function um but uh you can see that my implementation which fulfills the challenge because it doesn't use any stats or any extra space it still runs in a reasonably quick amount of time even though it's ten thousand you know it's a matter of two uh orders of magnitude it's not that much slower than using extra space so we'll see how we did that so the idea is um and this would make more sense if you sort of knew what sets were again this lesson used to be about both lists and success but essentially what you do is that you sort of use your existing array as a way to check whether or not that element is already existent in the original array you use this sort of as itself so you use the initiative array as the way to check if the number is already in the original array for example if uh you're trying to find like the first positive missing number and you want to check if one two and three are in an array we then can use in x1 and index three and we can set it as negative to indicate that yes it is there so therefore we sort of change the search operation from scanning the entire array to just an o of one index access and in reality because we're not trying to we're trying to conserve space here we use the next zero into this index answer and the idea is that for every single one of the numbers that are not going to be in that set of uh of numbers that will be um sort of impossible uh answers for the first missing positive you you set that to a number that that won't interfere with what we're going to be doing next and what we're going to be doing next is specifically that if the number is in the set of possible missing numbers you set it to a negative and what this does essentially is that if you had already said that before if you had have copies of the same element in this first set of possible first missing positive numbers in the actual array itself then it won't set it to a negative again thus making it positive it'll just keep making it negative so therefore when you actually iterate through the actual array itself the first missing positive is actually the first uh positive number um that is uh that is that is positive in the array because we had set everything from uh prior to that already as negative to indicate that it is integrated so we return the actual index itself so that is how you do the challenge problem