all right so today i'm gonna be going over um the last lesson which is about recursion um just like with the stuff we talked about classes the important part is that um you guys understand the more conceptual like stuff with recursion um but i would recommend you again to like try and practice this with java um but it's most important that like the first thing for recursion is you understand how to um how to read a recursive method so like how to be able to look at a recursive path and be like okay this is what actually does and then the next part is be able to being able to like design a recursive method on your own so basically um while go over is just like what is recursion um why do we use recursion and then finally um how you should be thinking about recursion so first off um recursion is kind of just like what i would call like a fancy for loop um it's basically a method that calls itself and why i call it a fancy for loop is basically any for loop can be written into like or any recursive method can be written into a very complicated for loop so um and oftentimes like under the hood um compilers will actually turn recursive methods into a for loop so but in general like a recursive method is just a method that calls itself and this is sort of like a visual representation so like we have a cat that's like that's kind of like recursing into like the screen so next um if recursion is just like a for loop underneath why do we ever use recursion so the reason um recursion is good is in some cases it's actually easier to think through a problem um recursively and also recursion makes things a lot readable um if you understand like how to read a recursive method also like there are some data structures um aka like data trees that are easier to implement using recursion so basically it's easier like this image here is a basically a binary search tree and a lot of the methods related to this kind of data structure is actually a lot easier to um to implement using recursive methods and then finally there are some languages that are a little bit based around recursion so like there are some functional languages like ocamo um or racket or lisp that are that have like this sort of other um paradigm that's not really like java where like they really like recursive methods so it's really um helpful to be able to have like be able to think recursively basically all right so finally i'm just gonna talk about like how you should be thinking through a recursive method so recursion is actually based on this um type of this basically this logic um proof method called inductive reasoning so basically it's sort of like a domino effect proof where it's like if you prove um two kinds of cases then basically it'll um it'll be true for the rest of the cases infinitely so um there are two parts of the inductive reasoning and recursion the first one is basically your base case so in in terms of recursion this is basically the condition where your recursive function actually returns a value and then um you also can think of it as like your base i'll actually be live coding a recursive function later so the next slide i'll actually be um just like working through an actual recursive method like creating one so um maybe like once i actually like once i actually like start doing like creating a recursive method i think like some of this will sort of um sort of click because like yeah this slide is a little bit of me like sort of talking at you about it so maybe if you see it in like in code it'll make sense i could also um like also just implement this method and then show you like where like these boxes fit into like the actual code is that all right well yeah yeah maybe do the demo first maybe that'll clear it up sure all right so this is the double i'm just gonna fork this so um over here i'm just gonna be implementing two recursive methods so both of these are um are more mathy so one is factorial and one is fibonacci um is anyone not familiar with like the fibonacci sequence or um or factorials i'm all right i can explain both of them to you then um so basically factorial is the um here we go so basically factorial is is like if you're given say like a number x x factorial which is like this exclamation point would be like x times x minus 1 um times x minus 2 all the way down to um times one basically so once um basically it'll take the product of like x all the way down to like all the way down to one so for example um like trying to think of an easy number so for example three factorial would be like three times two times one and then another rule is zero factorial is one um does that make sense for factorials basically like you're multiplying a number down all the way to like the um to the value one and then if you do zero factorial that's also one um fibonacci sequence this is a sequence that's like starts with one one two three five eight and this is sort of like a sequence or a pattern where um the two the um the nth term so like say the they say the third term is basically the sum of the previous two terms so like two is the sum of one and one um five is a sum of two and three and then eight is the sum of um three and five so this is just like um a a number sequence that like that has a pattern to it so these two are um are pretty pretty good examples from or they're pretty common examples of recursive methods so um first i'll just be be showing you like how to like how to create the um or how to implement these methods recursively and then once we run it um we should be able to print like these correct values all right so for factorio um basically we want two cases so a base case and then a recursive case or i like to call this a recursive call so basically um we want to first define like one factorial stops so basically factorial will stop when um when you reach one right or when you're or technically like you reach zero because the zero factorial is one so we'll basically define like we'll check if i is equal to one or i is equal to zero we'll just return one because that's like the um that's like one factorial is one and so is zero factorial so that's basically when we're stopping this like factorial method and then finally all you have to do is a recursive call so basically we're gonna call factorial and we're gonna decide like how we're gonna increment i so for factorial then we can trust that this method just works um does that make sense i think so but um maybe one i mean i don't know how is someone gonna set a value for i at some point or what how does it work um basically yeah it'll like do all this stuff with on the factorial method and like do the recursive function and then this factorial method will return an integer and that's like what it turns out so like technically it's the same idea as like as i'm printing out just like any number like three or ten so factorial that thing that you have highlighted is is um considered to be what an integer or a double or a or does it have any def i mean can it it's basically an integer right yeah so i'm in that factorial like i say method yeah yeah okay okay okay thank you you're from so yeah so basically for factorio it's like over here it's technically like solving or like solving for this expression inside of like or solving for this factorial method first before like doing the print all right so next we'll move on to something a little bit more complicated so this is the fibonacci method um the idea with fibonacci again is just that like the um the nth term is basically the sum of the previous two terms so if um let's say n equals and let's use let's use a rig indexing so um this will be 0 1 2 3 4 five so if n equals five then basically um n minus 1 is is 5 or the n minus 1 term and then the n minus two term is three and then the m term which is eight is just the sum of um the n minus one term and the n minus two term so just like before we're gonna define a base case and then we're gonna define a recursive call so for the base case um it's pretty this one's pretty simple so if and if like the anthem we're finding is either zero or one we're just going to return one because that's the start of um the fibonacci sequence so this is basically when the recursive method stops and then the trickier part is just um defining this recursive call so i don't think i've said this before but recursive call you're always supposed to return something otherwise like it won't like otherwise your method won't return the very end so yo return we're gonna return some sort of recursive call that that like calls the fibonacci sequence so up here we're actually gonna have two recursive calls in this statement and we're going to add them together because these are going to be sort of like the um n minus one term and mi 2 term so to find the n minus 1 term we're just gonna we're just gonna call the fibonacci nothing again and then same with the n minus two terms and then that's it that's basically like the fibonacci method so if we run it it should return three and zero or not oh no when i wrote the comments no this is i wrote the comments wrong don't leave yet if you don't mind yeah because i looked at this before class and i didn't understand it at all but now now i do but that's because you've added so much okay then could you move down to line number 15 have it start at 15 where the sixth and thank you so much no problem all right so next oh shoot so next um we could just go through the quest questions so first um what's the base case i feel like i've already showed you the um the answers but so is it like the case that leads to the method calling a different method the first time the code in the recursive method the case that ends the recursion or the case that leads to a method calling itself so we have one answer for c another answer for c anyone else have have an answer all right so yeah the correct answer is c um the base case will not always be like the the first or depending on like how you like to code your recursive methods the base case might not always be like the first line all right yep so the correct answer is b so basically um the recursive case is basically when you don't reach the base case so if you don't find a find a needle um basically when you find a piece of hay that's when you basically want to loop back and continue your search um any questions about that quiz question all right so question number three which of the following program structures is a recursive method is a recursive method the most similar to so is a recursive method like a loop an ifelse statement an abstract class or an array all right so yeah basically a recursive method actually like what for a lot of compilers um they'll actually secretly turn recursive methods into for loops but um basically a recursive method is just like a really fancy for loop but it's a lot a lot more readable than having like a for loop that's like that has a bunch of different conditions and then finally or secondary last um we have this code um basically just this method called do something it takes in it um an integer n and it does some sort of like recursive call or something so what will be the output of this code one inside the main method i called do something and the n is equal to three here like yeah it could be it can be a little um like especially when we just have a method called like do something it's really like it can be a little um daunting to like try and figure it out but um try to go step by step so like first what's the base case of this when does this method stop basically when n is greater than zero does it stop oh right no it's it writes something out no it's if it's not greater than zero yeah and it returns zero so next like in this recursive call um what do you think like this recursive call looks like like what do you think it's trying so we know like first off it's sort of like taking n and it's adding something so it's adding the do something of n minus one so we sort of like think about it and like let's say like or if we sort of think about it on a greater scale like do something like what do you think just by looking at like this line do what does do something do you could also try to compare it to um to some of the methods in the demo that we we wrote so like in fibonacci sequence it kind of like we kind of also had something similar where it's like fibonacci n minus 1 plus fibonacci n minus 2. but in this case we just do n plus do something n minus 1. so i don't i don't know yeah this this could be like this can be a little tricky if you're like not used to you thinking recursively um basically we're sort of um where first off we're like we have this base case so like we're sort of recursing down to n equals zero so when n equals zero um we just return zero and once we look at this recursive case it's sort of like n plus like plus like the do something of n minus one so it's sort of like if you sort of like think about it's like n plus n minus one plus n minus two plus like n minus three all the way down to like zero so we're basically this is basically like a summation so um if n was equal to let's say like let's say zero it will return zero if n equals one then we return like one plus do something one minus one which would be zero so one plus zero and they would sort of like go on after that so it's basically taking the um the summation of n so once we get to three it would be like three plus do something three minus one um actually let me see if i could yeah so like the correct answer um actually i play in chat it's c so i can sort of let me see if there's a good there's a way for me to write this out so basically the general gist of this is um or this is we don't really know what we don't really know what do something means um but again like with what um we talked about with factorial fibonacci the actual name of the method doesn't mean anything like this could be called um this could be called like abc or even like um even foo or something like that but it's the content of the method that actually matters because like the um and this like like do something itself is not like a keyword or like or some sort of special name it's just like a placeholder okay so basically um for do something this is this is not job code this is all like all just nodes um the base case we identified as if if n is equal to zero or actually less than or equal to zero we return zero and then otherwise the recursive case or recursive call we will just do n plus do something n minus 1. so the example i gave for um do something one is um first off we check that if n equals or is less than or equal to zero one is not less than or equal to zero so we'll go straight to the recursive call so the recursive call would just be one plus do something one minus one so over here we're just plugging in the numbers for like the general recursive call yeah so what we do now what but what does do something one minus one mean what is it equal to so that's where we're gonna figure out next so next we're gonna we're gonna um solve for this like do something one minus one call so this is basically equal to do something zero right because we can just like instead of one yes so we just solve for that um inside of the method or inside the parameter and next we'll check is zero less than or equal to zero that's true so we've hit the base case so return zero now once we get back to this do something one um once we've unwrapped like or i like to call it unwrapped so once we like unwrap the recursive call we sort of like um recurse down to the base case the um the final solution would just be one plus zero so basically um this like do something is only part of the final return method so this is actually what we want to return in the end and this do something we're only like solving for a part of the final return like value yeah so basically for we have like this recursion workshop um just a heads up though this one is a lit is set up a little differently than um than like our usual workshops so basically for this one we've already given you a like a recursive method and it's your job to basically identify like what's the base case um and explain like what um each part of this implementation of this recursive method means so like what does this line mean why do we have this um also like what does this line mean and like why do we have it and then find like what is what like what is this like what do these lines mean um like for example is it a recursive call is it a base case um and then what's sort of like the logic behind this method so and then you can either like answer it directly in the replica and like in the comments or you can answer it in the google in the submission form and finally um we would really really appreciate it if you um gave feedback for this class and like their previous classes in general um it really helps us um when students give feedback just so we know like what can we tweak for like the next time we teach this and what can we improve in the future