With timestamps:

00:00 - hey everybody my name is michaela karen i 
am a full-time ios developer and freelancer  
00:05 - let's get started writing a unit test
00:09 - in the last video we mocked our network request 
so if we open that and open the real one  
00:18 - we mocked this http client so what it 
actually does is loads a json file from  
00:25 - the unit test target as opposed to 
what the real http client does here  
00:30 - is it goes to the actual like network 
to the internet and fetches the data  
00:35 - and we were able to do this because this load 
json file is a part of mockable which is a custom  
00:42 - protocol that we created it has the bundle and 
then the code that actually fetches the json data  
00:49 - and with the http client we created our protocol 
http client and what this does is in our actual  
00:56 - song list view model we take in the protocol 
as opposed to taking in the concrete type  
01:04 - so this will allow us in our test to switch 
out the concrete type with our mock type
01:11 - in doing this this allows us to test our 
code as opposed to testing the network  
01:16 - so when somebody has like a spotty internet 
connection their network downloading the data  
01:20 - would take longer as opposed to somebody 
who has a fast internet connection  
01:23 - so when we unit test we want to take 
that like completely out of the equation  
01:27 - so let's go back to our original file that says 
yt vapor ios app test let's yeah let's just  
01:34 - delete it so click on this and click delete and 
move to trash so click on the group folder here  
01:41 - and click command n to make a a new file and for 
this you technically you could write a swift file  
01:48 - or we can just click specifically on unit test 
case class and what this is it is a swift file  
01:54 - but it sets up everything for you ahead 
of time so let's call this um songlessview
02:02 - model tess and then it is 
a subclass of xc test case  
02:06 - and we are using swift so if we click 
next we want to save it in the app test  
02:12 - group and then make sure it's in the proper 
target our test target and click create
02:20 - and when we clicked like a unit test case as 
opposed to just making a swift file because  
02:25 - that's exactly what this is um all this is 
doing is just giving us all this boilerplate  
02:33 - so we're actually going to delete it all so maybe 
we could have made a swift file but that's okay
02:41 - and you see on the left it says r that's 
because this project is under source control  
02:46 - and so it thinks we were we removed that one 
file and then added it back and it thinks  
02:51 - uh git thinks that we just renamed 
the file so it's like removing it  
02:56 - but that doesn't really matter so what we want 
to do is make a setup method and the teardown  
03:02 - methods so let's type setup and sometimes when you 
hit enter immediately it has this class function  
03:08 - that is not the one that we want we want the 
normal setup function which would look like this  
03:13 - but if you start typing setup again you can see 
the difference between the two the top one says  
03:20 - initial state before a test case 
begins and then the bottom one says  
03:25 - uh blah blah blah calling each test method in a 
test case so the whole test case is your class  
03:31 - but the test method that's our actual like unit 
test so that's the one we want and you can see  
03:36 - it doesn't have that word class in front of it 
so we want to do this for setup and tear down
03:46 - we want to call this super class so super dot 
setup and open that setup uh super dot tear down  
03:54 - and what we want to test is our view song list 
view model so let's make a variable for it  
04:01 - let's call it songlist vm and it is of type 
songlessviewmodel so if we try to run the  
04:08 - unit test if we click command u it doesn't run 
because for one it doesn't have an initializer  
04:14 - and two it says sunglass viewmodel not in 
scope so what we have to do is this test target  
04:20 - is a completely different target meaning group of 
like scope of our app so we collapse that this is  
04:27 - our test target and then this is our app target 
and they don't like talk to each other without you  
04:32 - saying so so what we have to do is import our app 
targets code so we do that with at testable import  
04:41 - then yt vapor ios app and this will 
typically be the name like of your project  
04:48 - and this says it has no initializer so what 
we actually want to do is force unwrap it
04:54 - and then that should be good so what we're going 
to do in this setup is set it to a value because  
04:59 - right now we know the type but it doesn't have 
a value yet so we want to do song list vm is  
05:04 - equal to song list view model and we can see it 
takes in a type of http client protocol and then  
05:14 - you know the variable is called http client so 
what we want to give it is our mock as opposed  
05:19 - to giving it the real http claim or what do we 
call this mock http client and right here so we  
05:27 - are setting the mock we're giving the mock to our 
view model rather than using the real http client
05:35 - here doo doo doo where'd it go like it 
does right here is where we can pass in  
05:42 - whichever one we want the mock or the real one
05:48 - so we want to do that and then in the tear 
down we want to do not that one song list  
05:55 - vm and just set it equal to nil because with 
setup and tear down this allows us to create our  
06:02 - our unit test to have the same parameters when 
they start each test and when they end each test  
06:09 - or no sorry when they start every new test 
so the setup is run before each test and  
06:14 - then the teardown is run afterwards 
so this is like resetting our state  
06:18 - and what we want to do is 
let's do funk test fetch songs
06:27 - successfully and when we do this we can go ahead 
and click on the diamond to run the whole class or  
06:33 - just run this unit test and we run it it builds 
our app and says test succeeded which is good  
06:39 - because our unit test or sorry our app yeah app 
test target sorry the test target is running  
06:49 - and doesn't have any build errors but this isn't 
really doing anything because we're not asserting  
06:53 - anything in this actual function so what we want 
to do is we want to test when we fetch songs and  
07:01 - make sure that we fetch and receive the proper 
number of songs so when we look at our mock song  
07:07 - response we have two different songs so we want to 
make sure that two songs are fetched properly so  
07:14 - if we try or yeah we need to try first try oh wait 
songlessvm dot fetch songs um hopefully that works
07:31 - oh errors are thrown that is because we 
could either wrap this in a do catch or
07:38 - change our uh change the function the actual unit 
test function to say that it throws so then this  
07:47 - should go away there we go and then lastly 
we want to assert so we want to xct assert  
07:56 - let's do xct assert equal and 
we want to assert that the songs  
08:03 - in our view model this the songs is equal to 
whatever was fetched from here because we can see  
08:11 - it makes a url make sure that it's a url object 
from that string we do the fetch which this will  
08:18 - be our mach1 so this will actually go and fetch 
the loaded json file set it to song response and  
08:24 - then here we are setting the song response equal 
to this variable songs here so we want to do
08:31 - songlistvm.songs.count because 
it's an array is equal to 2.
08:42 - so we should be able to do 
that and our test should pass
08:47 - but it doesn't so why didn't this work the 
way it should have so it says zero is not  
08:56 - equal to two so this one is the one that's 
getting back zero but according to our mock  
09:02 - we should be returning our loaded json 
response which right here there's two values  
09:10 - so i struggle with this for a really long 
time and i found out the reason is because  
09:15 - in our songless view model this is a published 
variable so it acts a little bit differently  
09:22 - as opposed to if it was just a normal 
variable so we have to write our unit test  
09:27 - to account for that um where do we go 
here so what we actually want to do
09:34 - is use what are called expectations
09:39 - so we need to do let expectation yeah is equal to
09:48 - or which one is it xct test 
why am i not finding it
10:01 - there we go it is called xc test 
expectation um and then the description is
10:14 - um let's just call it songs so what an expectation 
is is basically we are we have to wait for  
10:20 - something to happen so we think of it like we 
expect something to happen but we don't know when  
10:26 - it's going to be happening so we have to tell the 
code when will this happen so with the expectation  
10:32 - that is defining what is the expectation and 
it's called songs we could call it like published  
10:38 - or fetch songs and then inside 
of our code here we are calling  
10:46 - the fetch songs so that is doing the 
fetching and using our mock variable  
10:51 - but we have to tell xcode how when do we expect 
this to finish so i thought with the try await it  
10:56 - would just kind of work but that didn't work 
for me because of this published variable is  
11:01 - what i found but if there's a different way 
to do this that you know of please let me  
11:05 - know in the comments or tag me on instagram or 
twitter or tag code with chris i would love to  
11:10 - know if there's a different way to do this but 
this is the one that i found that has worked
11:16 - so with this we want to do songlist vm and we are 
going to be using combine so we need to import  
11:24 - combine at the top so this uses combine and for 
anyone who doesn't know this is a ray wonder like  
11:31 - tutorial but combine it was announced at wwdc 
and it is a reactive framework so it's as you  
11:39 - can see it's for handling events yeah would be 
the best way to say this it handles um publisher  
11:46 - and subscriber so it handles when things happen 
and who should be listening to those things that  
11:50 - are happening is sort of the gist of how all of 
this works so that's what this is we have to know  
11:57 - right here we are fetching our songs and 
data is going into our songs variable that  
12:02 - is a published variable so we need to know when 
that data was published so we have to subscribe  
12:07 - to it meaning listen for that to happen so to 
do that we're using songlessvm and then dot  
12:15 - songs is the published variable 
that we're listening to
12:27 - and then here we have drop first 
i will put a link for the um  
12:34 - post that i found that sort of gave me all 
this code that like made it all finally  
12:38 - work i'm not 100 sure why we're using drop first 
this when you look at the definition it says  
12:45 - omits a specified number of elements and then down 
here it says the default is one so it's dropping  
12:50 - the first time a value is assigned to it so i want 
to say that will be when the songless viewmodel is  
12:55 - created at first the value is assigned and it's 
an empty array so i want to say that's what the  
13:01 - drop first is but i'm not 100 sure and then sync 
is actually if we click command click on this and  
13:08 - then click show quick help it says attaches 
as a subscriber with closure-based behavior  
13:13 - to a publisher that never fails so this means and 
you can see see in the example if we have 0 to 3  
13:20 - and we have a that's a publisher and then we 
write sync we can see what happens for 0 to 3  
13:27 - every time the value of this variable changes so 
that's what we're listening to is when this value  
13:32 - changes and the value should change here because 
in fetch songs if we go to our mock because that's  
13:38 - the one that's being called we are loading the 
json but if we look at the actual view model
13:45 - here is that fetch so this is loading json 
and we are setting song response which  
13:50 - which is just a variable but 
here song response is equal to  
13:54 - self.songs so that's what we're listening 
to and then this is what that value is  
14:01 - and what we want to do is do xct assert equal and 
we want to assert that value.count is equal to  
14:09 - 2. so we want to assert the value.count because 
the value is whatever is in here which is the  
14:16 - song's array so think of value as the songs 
array and then it's an array so it has a  
14:22 - property called count and that's what we're 
actually checking and then we have to type
14:29 - expectation dot fulfill so this means 
at this point our expectation oh  
14:35 - um our expectation it's this is we 
expect something to happen at some point  
14:40 - here we go and do something we go to this code 
finally and then we can say hey our expectation  
14:47 - it happened like the thing that we were waiting 
for finally happened so right here we also have
14:55 - wait for expectation because it's the 
code may run through here and run through  
15:00 - this this is a closure but then we have to say 
hey wait for something to happen and this is  
15:09 - not the right one we want to
15:24 - which one am i writing i want to write
15:32 - this one is weight
15:38 - okay this is the one that we want to use 
is wait for expectation so we are waiting  
15:43 - for expectation so this is an array of 
expectations so it could you could have multiple  
15:47 - of them and then the timeout is after like one 
second has passed this would automatically fail  
15:53 - and the unit test would fail 
and then the last part of the
15:59 - this part with observing it is we have to 
put it into let's call a cancelable so this  
16:06 - needs to be a set of any cancelable and we need 
that in our unit test or in our unit test class
16:32 - so we want to force unwrap that so 
we don't have that error with the  
16:36 - no initializers and down here we will pass
16:43 - cancelables so if we command 
click on this to see more about it  
16:48 - this says a set to store any 
cancelable and if you click on this  
16:53 - the docs come up and tell you um incantable object 
that executes a provided closure when canceled  
17:00 - we have this cancelable object and honestly 
i don't really know how this works exactly  
17:07 - i haven't done too much with combine but 
when we have this sync here it says um  
17:14 - it returns a cancel cancelable in instance which 
you can use to end assignment of the received  
17:21 - value um and the de-allocation of the result will 
tear down the subscription stream and then this is  
17:29 - what we use for that so you can look and read more 
about what is any cancelable this type but you can  
17:37 - see it's all part of combine which has to do with 
publishing and subscribing variables and reacting  
17:44 - so once we write all of this we should be good 
so this you can see is from our field unit test  
17:51 - when it says 0 is not equal to 2 but then now how 
it's working is we have an expectation meaning we  
17:57 - expect something to happen but we just don't 
know when we are going to try to fetch songs  
18:02 - and this is fetching from our local json file we 
run through this part which is observing those  
18:10 - changes to the songs variable in our song list 
songlistviewmodel which is a published variable
18:18 - and then once we do have a value we can 
assert that it is equal to two so we can  
18:22 - actually remove it from down here we could put 
it on either side inside of this closure or not  
18:29 - but i've read that it's possible for 
this to all run before or sorry after  
18:36 - this statement would have happened so technically 
it still may have shown 0 and 2. in reality when  
18:42 - that may have not been true it just depends on 
whatever ran first so it says the best way would  
18:47 - be to keep it inside of this closure so we'll 
erase that one but then here at the bottom we are  
18:54 - waiting for our expectation to happen here until 
we know that there's a value and we know that  
19:00 - inside of this sink and then that's when we can 
write expectation dot fulfill which means like our  
19:05 - expectation is fulfilled the thing that we thought 
would happen has happened so now we're good  
19:12 - and so when we go and run the unit test 
we see build succeeded and that failed
19:22 - why did this fail oh i see so this failed 
because we unexpectedly unwrapped nil  
19:29 - and the reason for that is because we never set 
a value for this so what this is is a set so we  
19:38 - write cancels is equal to empty it's empty array 
but i believe sets and arrays kind of use the same  
19:45 - syntax so that's all we need is cancelables is 
equal to empty array and we could probably put  
19:53 - that inside of our tear down as well okay 
now we should run this and it should pass  
20:01 - and there we go we see this pop-up 
test succeeded and our test has passed  
20:06 - so it took a lot of work to mock the 
network request and actually go about  
20:11 - writing the unit test but we have now like proven 
that we can fetch we can fetch data from json and  
20:18 - we can handle it correctly in our application so 
what we've done is we have tested a single thing  
20:25 - but if we wanted to know how much of our 
code base we've actually covered in tests  
20:28 - we use something called code coverage so if you 
go up here and i'm on xcode 13.2.1 right now  
20:36 - so this is right here as opposed to it used 
to be kind of over here for xcode i think 12.  
20:41 - um we click on this and click on edit scheme and 
what we want to do is go down to test typically  
20:48 - it's on run so switch it to test and we want to 
check this box that says gather code coverage  
20:55 - and we want to do it only for some targets
20:59 - and we click the plus and right now we only have 
our actual app target so that's what we want  
21:04 - to test as opposed to if you 
had other third-party libraries  
21:07 - they may show up here too and you don't want to 
test those you only want to test your own code  
21:12 - so if we go ahead and click add it is noted 
right here and we click close so to actually  
21:18 - figure what that figure out what that is 
we click command u and that runs all of the  
21:23 - tests so if you had unit tests and ui tests it 
would run everything and that's what you want  
21:28 - to gather all what's called the code coverage so 
we want to know what code is covered under unites  
21:34 - and we can see that by going over to this far one 
over here navigator what is it called it is the  
21:40 - report navigator so you can see these are all from 
like building the project over and over and over  
21:47 - and the log of the build so that shows you like 
whatever it is that you did but we want to check  
21:53 - this one that says coverage when we look at 
this we can expand this and we can see only 37.6  
21:59 - of our code is covered but when we click on it 
and expand it some more we can go more in depth  
22:04 - and see how much of each file is covered so we 
can see the yt vapor ios app file that is 100  
22:11 - covered and then our actual um http client we 
can click on this and click this little arrow  
22:21 - and it shows us whatever our code is covered 
or not by this little thing on the left and  
22:27 - if you don't have this click this little line 
thingy and then make sure you have code coverage  
22:32 - selected so mine i typically usually have the 
mini map open as well um i think i didn't have  
22:37 - that the whole tutorial but i usually have 
that open as well but then you can also see  
22:42 - the code coverage part which will tell you um 
this part of the code is covered meaning literally  
22:49 - like calling the function but this part is not 
covered of testing that we got back a 200 response  
22:55 - and you can see like individually line by 
line what is and isn't covered by a unit test
23:02 - if we go to like our song list view model we see  
23:06 - most of that is covered and then our 
fetch songs we covered everything  
23:10 - except the actual if the url is not a url object 
the code can exit at this point meaning it can  
23:17 - throw and then the function would end we did 
not test that path but we tested the rest of  
23:21 - it so that's why under sunglass vm we can see 
under fetch songs that's like 84.6 percent covered  
23:33 - and that's how you can check your code coverage 
and like i said during the introductory video  
23:38 - video it depends on what kind of code coverage 
your company may have or you personally want but  
23:44 - overall you should go for quality of tests over a 
specific number or a specific percentage because  
23:50 - it varies it's great like if you write a 
bunch of unit tests but if the unit tests  
23:54 - aren't really useful then your code 
coverage kind of doesn't matter in the end  
24:00 - so make sure you have quality 
over quantity of unit tests
24:06 - in this video we wrote a unit test 
that used a mocked network request  
24:10 - so that we could isolate our unit tests and 
only test our code as opposed to also testing  
24:15 - the network or testing the internet and we 
also enabled code coverage for our project

Cleaned transcript:

hey everybody my name is michaela karen i am a fulltime ios developer and freelancer let's get started writing a unit test in the last video we mocked our network request so if we open that and open the real one we mocked this http client so what it actually does is loads a json file from the unit test target as opposed to what the real http client does here is it goes to the actual like network to the internet and fetches the data and we were able to do this because this load json file is a part of mockable which is a custom protocol that we created it has the bundle and then the code that actually fetches the json data and with the http client we created our protocol http client and what this does is in our actual song list view model we take in the protocol as opposed to taking in the concrete type so this will allow us in our test to switch out the concrete type with our mock type in doing this this allows us to test our code as opposed to testing the network so when somebody has like a spotty internet connection their network downloading the data would take longer as opposed to somebody who has a fast internet connection so when we unit test we want to take that like completely out of the equation so let's go back to our original file that says yt vapor ios app test let's yeah let's just delete it so click on this and click delete and move to trash so click on the group folder here and click command n to make a a new file and for this you technically you could write a swift file or we can just click specifically on unit test case class and what this is it is a swift file but it sets up everything for you ahead of time so let's call this um songlessview model tess and then it is a subclass of xc test case and we are using swift so if we click next we want to save it in the app test group and then make sure it's in the proper target our test target and click create and when we clicked like a unit test case as opposed to just making a swift file because that's exactly what this is um all this is doing is just giving us all this boilerplate so we're actually going to delete it all so maybe we could have made a swift file but that's okay and you see on the left it says r that's because this project is under source control and so it thinks we were we removed that one file and then added it back and it thinks uh git thinks that we just renamed the file so it's like removing it but that doesn't really matter so what we want to do is make a setup method and the teardown methods so let's type setup and sometimes when you hit enter immediately it has this class function that is not the one that we want we want the normal setup function which would look like this but if you start typing setup again you can see the difference between the two the top one says initial state before a test case begins and then the bottom one says uh blah blah blah calling each test method in a test case so the whole test case is your class but the test method that's our actual like unit test so that's the one we want and you can see it doesn't have that word class in front of it so we want to do this for setup and tear down we want to call this super class so super dot setup and open that setup uh super dot tear down and what we want to test is our view song list view model so let's make a variable for it let's call it songlist vm and it is of type songlessviewmodel so if we try to run the unit test if we click command u it doesn't run because for one it doesn't have an initializer and two it says sunglass viewmodel not in scope so what we have to do is this test target is a completely different target meaning group of like scope of our app so we collapse that this is our test target and then this is our app target and they don't like talk to each other without you saying so so what we have to do is import our app targets code so we do that with at testable import then yt vapor ios app and this will typically be the name like of your project and this says it has no initializer so what we actually want to do is force unwrap it and then that should be good so what we're going to do in this setup is set it to a value because right now we know the type but it doesn't have a value yet so we want to do song list vm is equal to song list view model and we can see it takes in a type of http client protocol and then you know the variable is called http client so what we want to give it is our mock as opposed to giving it the real http claim or what do we call this mock http client and right here so we are setting the mock we're giving the mock to our view model rather than using the real http client here doo doo doo where'd it go like it does right here is where we can pass in whichever one we want the mock or the real one so we want to do that and then in the tear down we want to do not that one song list vm and just set it equal to nil because with setup and tear down this allows us to create our our unit test to have the same parameters when they start each test and when they end each test or no sorry when they start every new test so the setup is run before each test and then the teardown is run afterwards so this is like resetting our state and what we want to do is let's do funk test fetch songs successfully and when we do this we can go ahead and click on the diamond to run the whole class or just run this unit test and we run it it builds our app and says test succeeded which is good because our unit test or sorry our app yeah app test target sorry the test target is running and doesn't have any build errors but this isn't really doing anything because we're not asserting anything in this actual function so what we want to do is we want to test when we fetch songs and make sure that we fetch and receive the proper number of songs so when we look at our mock song response we have two different songs so we want to make sure that two songs are fetched properly so if we try or yeah we need to try first try oh wait songlessvm dot fetch songs um hopefully that works oh errors are thrown that is because we could either wrap this in a do catch or change our uh change the function the actual unit test function to say that it throws so then this should go away there we go and then lastly we want to assert so we want to xct assert let's do xct assert equal and we want to assert that the songs in our view model this the songs is equal to whatever was fetched from here because we can see it makes a url make sure that it's a url object from that string we do the fetch which this will be our mach1 so this will actually go and fetch the loaded json file set it to song response and then here we are setting the song response equal to this variable songs here so we want to do songlistvm.songs.count because it's an array is equal to 2. so we should be able to do that and our test should pass but it doesn't so why didn't this work the way it should have so it says zero is not equal to two so this one is the one that's getting back zero but according to our mock we should be returning our loaded json response which right here there's two values so i struggle with this for a really long time and i found out the reason is because in our songless view model this is a published variable so it acts a little bit differently as opposed to if it was just a normal variable so we have to write our unit test to account for that um where do we go here so what we actually want to do is use what are called expectations so we need to do let expectation yeah is equal to or which one is it xct test why am i not finding it there we go it is called xc test expectation um and then the description is um let's just call it songs so what an expectation is is basically we are we have to wait for something to happen so we think of it like we expect something to happen but we don't know when it's going to be happening so we have to tell the code when will this happen so with the expectation that is defining what is the expectation and it's called songs we could call it like published or fetch songs and then inside of our code here we are calling the fetch songs so that is doing the fetching and using our mock variable but we have to tell xcode how when do we expect this to finish so i thought with the try await it would just kind of work but that didn't work for me because of this published variable is what i found but if there's a different way to do this that you know of please let me know in the comments or tag me on instagram or twitter or tag code with chris i would love to know if there's a different way to do this but this is the one that i found that has worked so with this we want to do songlist vm and we are going to be using combine so we need to import combine at the top so this uses combine and for anyone who doesn't know this is a ray wonder like tutorial but combine it was announced at wwdc and it is a reactive framework so it's as you can see it's for handling events yeah would be the best way to say this it handles um publisher and subscriber so it handles when things happen and who should be listening to those things that are happening is sort of the gist of how all of this works so that's what this is we have to know right here we are fetching our songs and data is going into our songs variable that is a published variable so we need to know when that data was published so we have to subscribe to it meaning listen for that to happen so to do that we're using songlessvm and then dot songs is the published variable that we're listening to and then here we have drop first i will put a link for the um post that i found that sort of gave me all this code that like made it all finally work i'm not 100 sure why we're using drop first this when you look at the definition it says omits a specified number of elements and then down here it says the default is one so it's dropping the first time a value is assigned to it so i want to say that will be when the songless viewmodel is created at first the value is assigned and it's an empty array so i want to say that's what the drop first is but i'm not 100 sure and then sync is actually if we click command click on this and then click show quick help it says attaches as a subscriber with closurebased behavior to a publisher that never fails so this means and you can see see in the example if we have 0 to 3 and we have a that's a publisher and then we write sync we can see what happens for 0 to 3 every time the value of this variable changes so that's what we're listening to is when this value changes and the value should change here because in fetch songs if we go to our mock because that's the one that's being called we are loading the json but if we look at the actual view model here is that fetch so this is loading json and we are setting song response which which is just a variable but here song response is equal to self.songs so that's what we're listening to and then this is what that value is and what we want to do is do xct assert equal and we want to assert that value.count is equal to 2. so we want to assert the value.count because the value is whatever is in here which is the song's array so think of value as the songs array and then it's an array so it has a property called count and that's what we're actually checking and then we have to type expectation dot fulfill so this means at this point our expectation oh um our expectation it's this is we expect something to happen at some point here we go and do something we go to this code finally and then we can say hey our expectation it happened like the thing that we were waiting for finally happened so right here we also have wait for expectation because it's the code may run through here and run through this this is a closure but then we have to say hey wait for something to happen and this is not the right one we want to which one am i writing i want to write this one is weight okay this is the one that we want to use is wait for expectation so we are waiting for expectation so this is an array of expectations so it could you could have multiple of them and then the timeout is after like one second has passed this would automatically fail and the unit test would fail and then the last part of the this part with observing it is we have to put it into let's call a cancelable so this needs to be a set of any cancelable and we need that in our unit test or in our unit test class so we want to force unwrap that so we don't have that error with the no initializers and down here we will pass cancelables so if we command click on this to see more about it this says a set to store any cancelable and if you click on this the docs come up and tell you um incantable object that executes a provided closure when canceled we have this cancelable object and honestly i don't really know how this works exactly i haven't done too much with combine but when we have this sync here it says um it returns a cancel cancelable in instance which you can use to end assignment of the received value um and the deallocation of the result will tear down the subscription stream and then this is what we use for that so you can look and read more about what is any cancelable this type but you can see it's all part of combine which has to do with publishing and subscribing variables and reacting so once we write all of this we should be good so this you can see is from our field unit test when it says 0 is not equal to 2 but then now how it's working is we have an expectation meaning we expect something to happen but we just don't know when we are going to try to fetch songs and this is fetching from our local json file we run through this part which is observing those changes to the songs variable in our song list songlistviewmodel which is a published variable and then once we do have a value we can assert that it is equal to two so we can actually remove it from down here we could put it on either side inside of this closure or not but i've read that it's possible for this to all run before or sorry after this statement would have happened so technically it still may have shown 0 and 2. in reality when that may have not been true it just depends on whatever ran first so it says the best way would be to keep it inside of this closure so we'll erase that one but then here at the bottom we are waiting for our expectation to happen here until we know that there's a value and we know that inside of this sink and then that's when we can write expectation dot fulfill which means like our expectation is fulfilled the thing that we thought would happen has happened so now we're good and so when we go and run the unit test we see build succeeded and that failed why did this fail oh i see so this failed because we unexpectedly unwrapped nil and the reason for that is because we never set a value for this so what this is is a set so we write cancels is equal to empty it's empty array but i believe sets and arrays kind of use the same syntax so that's all we need is cancelables is equal to empty array and we could probably put that inside of our tear down as well okay now we should run this and it should pass and there we go we see this popup test succeeded and our test has passed so it took a lot of work to mock the network request and actually go about writing the unit test but we have now like proven that we can fetch we can fetch data from json and we can handle it correctly in our application so what we've done is we have tested a single thing but if we wanted to know how much of our code base we've actually covered in tests we use something called code coverage so if you go up here and i'm on xcode 13.2.1 right now so this is right here as opposed to it used to be kind of over here for xcode i think 12. um we click on this and click on edit scheme and what we want to do is go down to test typically it's on run so switch it to test and we want to check this box that says gather code coverage and we want to do it only for some targets and we click the plus and right now we only have our actual app target so that's what we want to test as opposed to if you had other thirdparty libraries they may show up here too and you don't want to test those you only want to test your own code so if we go ahead and click add it is noted right here and we click close so to actually figure what that figure out what that is we click command u and that runs all of the tests so if you had unit tests and ui tests it would run everything and that's what you want to gather all what's called the code coverage so we want to know what code is covered under unites and we can see that by going over to this far one over here navigator what is it called it is the report navigator so you can see these are all from like building the project over and over and over and the log of the build so that shows you like whatever it is that you did but we want to check this one that says coverage when we look at this we can expand this and we can see only 37.6 of our code is covered but when we click on it and expand it some more we can go more in depth and see how much of each file is covered so we can see the yt vapor ios app file that is 100 covered and then our actual um http client we can click on this and click this little arrow and it shows us whatever our code is covered or not by this little thing on the left and if you don't have this click this little line thingy and then make sure you have code coverage selected so mine i typically usually have the mini map open as well um i think i didn't have that the whole tutorial but i usually have that open as well but then you can also see the code coverage part which will tell you um this part of the code is covered meaning literally like calling the function but this part is not covered of testing that we got back a 200 response and you can see like individually line by line what is and isn't covered by a unit test if we go to like our song list view model we see most of that is covered and then our fetch songs we covered everything except the actual if the url is not a url object the code can exit at this point meaning it can throw and then the function would end we did not test that path but we tested the rest of it so that's why under sunglass vm we can see under fetch songs that's like 84.6 percent covered and that's how you can check your code coverage and like i said during the introductory video video it depends on what kind of code coverage your company may have or you personally want but overall you should go for quality of tests over a specific number or a specific percentage because it varies it's great like if you write a bunch of unit tests but if the unit tests aren't really useful then your code coverage kind of doesn't matter in the end so make sure you have quality over quantity of unit tests in this video we wrote a unit test that used a mocked network request so that we could isolate our unit tests and only test our code as opposed to also testing the network or testing the internet and we also enabled code coverage for our project
