With timestamps:

00:02 - hello kokuru
00:03 - welcome to the core data series in this
00:05 - lesson we're going to go through what
00:06 - core data is
00:08 - its benefits and how you're going to use
00:10 - it with xcode
00:11 - first of all what is it core data is
00:13 - apple's
00:14 - local object graph persistence framework
00:17 - now before i scare you away
00:18 - in simple terms it's a way for you to
00:21 - store data on your
00:22 - device locally and then retrieve it
00:24 - later for use
00:25 - the data stays locally on the device so
00:27 - it's not a solution for sharing data
00:29 - with other users
00:30 - and it's not a solution for syncing data
00:32 - across multiple devices
00:34 - although some of that can be done when
00:36 - you combine core data with cloud kit
00:38 - next why should we even use core data
00:40 - well assuming you need to store data in
00:42 - your app
00:43 - some benefits of using core data include
00:45 - number one it's a first party apple
00:47 - framework so it plays nicely and has a
00:49 - tighter integration with
00:50 - other apple apis and frameworks number
00:53 - two
00:54 - being a first party framework means that
00:56 - apple is going to make sure that any new
00:58 - technology it releases
00:59 - will work with it at least i'd like to
01:01 - think that apple would make a bigger
01:03 - effort to make sure that core data plays
01:05 - nicely with anything that they release
01:07 - number three you don't have to install
01:09 - any third-party sdks
01:11 - which means you don't have to work with
01:12 - cocoapods or trying to keep third-party
01:14 - code libraries
01:15 - up to date all right now for some
01:18 - drawbacks of using core data
01:19 - number one it's not a remote database
01:22 - solution although syncing across devices
01:24 - should be able to be done with cloudkit
01:27 - to be honest i haven't looked into this
01:29 - very much myself yet number two the
01:31 - classes and methods to work with core
01:33 - data may be confusing at first so
01:35 - there's a little bit of a learning curve
01:37 - but i hope
01:38 - in this video series i can simplify that
01:40 - for you
01:41 - number three you have to retrain your
01:43 - brain to think of core data as an
01:44 - object graph persistence framework
01:47 - object
01:48 - graph persistence framework let's take a
01:51 - look at what that means
01:52 - it all has to do with how you interact
01:54 - with core data you see with traditional
01:57 - databases
01:57 - you explicitly insert create update and
02:01 - delete data from the database
02:03 - now even though under the hood core data
02:05 - is using an sqlite
02:07 - database you don't have to explicitly
02:09 - tell core data to insert create
02:11 - update or delete you just create and
02:13 - work with objects in your app like
02:15 - normal and behind the scenes core data
02:17 - will manage the data persistence
02:18 - for you let's take a look at a diagram
02:21 - to see how this works
02:23 - okay so let's say you have two classes
02:25 - family and person
02:27 - the person class contains some
02:28 - properties and the family class has a
02:30 - property storing the person
02:32 - objects for that family you create a
02:34 - family object in several person objects
02:37 - and then you relate those person objects
02:39 - to the family object
02:41 - now you want to store it in core data
02:43 - how do you do that
02:44 - well there are a few core data
02:46 - components that are needed
02:48 - one is the persistent container you can
02:50 - think of this as a
02:52 - representation of the core data store or
02:54 - database
02:55 - however your objects don't interact with
02:58 - the persistent container directly
03:00 - there's a layer on top of the persistent
03:02 - container called the managed object
03:05 - context think of this as sort of a
03:08 - data manager layer your objects will go
03:11 - through
03:11 - the managed object context to be stored
03:14 - or retrieved from the persistent store
03:17 - now these objects in memory along with
03:19 - how they relate to each other
03:21 - is called an object graph when you store
03:24 - the objects
03:24 - into core data all of the data in the
03:27 - properties
03:28 - along with the relationships are
03:30 - preserved in other words
03:31 - the object graph when you retrieve them
03:34 - from core data back into memory you can
03:36 - get them back
03:36 - in the same state they were in before so
03:39 - that's why they call
03:40 - core data an object graph persistence
03:42 - framework
03:43 - now to complete our understanding of how
03:45 - core data works
03:46 - let's revisit our diagram in previous
03:50 - lessons i've shown you how to work with
03:51 - json
03:52 - and decode them into usable objects in
03:54 - our app this process of changing the
03:56 - data into a different format and back
03:58 - is known as encoding and decoding or
04:01 - serializing
04:02 - and deserializing while core data needs
04:04 - to do the same thing here
04:06 - it serializes the object into a format
04:08 - that can be stored in the underlying
04:10 - sqlite database
04:11 - and then it'll deserialize it back into
04:14 - the objects in memory
04:16 - the code or functionality to do that
04:18 - serializing and deserializing process
04:20 - is with a class called ns managed object
04:24 - so if you want your class to be able to
04:26 - be captured in core data
04:28 - you need to subclass ns managed object
04:30 - that gives
04:31 - objects of your custom class the ability
04:33 - to be stored with core data
04:35 - okay so now your objects can be
04:37 - serialized and stored with core data
04:39 - however
04:40 - when you want to bring that object back
04:42 - from core data how does it know what
04:44 - format to deserialize
04:45 - that data back into in other words if
04:48 - you're trying to bring your person back
04:50 - how does it know about your person class
04:52 - and what properties your person class
04:54 - contains
04:55 - well here's the final piece of the core
04:57 - data puzzle
04:58 - in this example we use the person class
05:00 - that subclasses ns managed object
05:03 - well you don't actually create and write
05:05 - this person class yourself
05:07 - instead there's a visual editor where
05:09 - you have to define the class
05:10 - in the core data model they call the
05:12 - class an entity
05:14 - and the properties of your class are
05:15 - called attributes of that entity
05:18 - then after you've defined the entity and
05:20 - attributes
05:21 - in other words your class and its
05:22 - properties you generate the swift
05:25 - classes from this core data model
05:27 - file it's just a command you run from an
05:30 - xcode menu and they'll generate the
05:32 - class files for what you've defined
05:34 - in the core data model the generated
05:36 - class will automatically
05:38 - be a subclass of ns managed object so
05:41 - that core data can serialize and
05:42 - deserialize it
05:44 - then you use that generated class like
05:46 - you would any other class
05:48 - and core data can now store objects of
05:50 - that class and bring them back when
05:52 - needed
05:52 - so let's do a quick recap of how we're
05:54 - going to work with core data
05:56 - you define your entities and attributes
05:58 - in the core data model
06:00 - then you generate your classes from the
06:02 - core data model
06:03 - then you get a reference to the core
06:05 - data persistent container
06:07 - from the persistent container you get a
06:09 - managed object context
06:11 - and through that managed object context
06:14 - you can create objects and store them in
06:16 - core data
06:16 - for retrieval for later use now core
06:19 - data has
06:20 - a stigma of being hard to understand and
06:23 - use
06:23 - i hope i've demystified it at least a
06:25 - little bit for you in this video
06:27 - in the next lesson we'll do a real
06:29 - example of using core data in xcode
06:31 - all right i'll see you there
06:35 - hey code crew in this lesson we're going
06:37 - to do a real example of using core data
06:39 - inside xcode
06:41 - i'll go through two different scenarios
06:43 - number one how to start your xcode
06:45 - project with core data enabled
06:47 - and number two how to add core data
06:49 - functionality to an existing
06:51 - xcode project now even if you're only
06:54 - interested in number two
06:55 - i would still highly recommend that you
06:57 - watch through part one because in part
06:59 - one
06:59 - i'm going to be highlighting the
07:01 - different core data components that are
07:03 - needed
07:03 - now just a quick recap of the previous
07:05 - lesson in case you didn't see it
07:07 - to work with core data we need four
07:09 - things number one
07:10 - is to define our entities and attributes
07:13 - in the core data model
07:14 - number two is to generate the classes
07:17 - from the core data model
07:18 - number three get a reference to the core
07:20 - data persistent container
07:22 - and then number four get the managed
07:24 - object context
07:26 - through which we save and retrieve our
07:28 - objects
07:29 - all right let's jump into xcode and do
07:31 - this all right first we're going to talk
07:33 - about setting up core data with a brand
07:35 - new xcode project and then
07:36 - afterwards we're going to talk about how
07:38 - to add core data to an existing xcode
07:40 - project
07:41 - so here i'm going to set up a brand new
07:43 - xcode project here
07:45 - and i'm going to choose single view
07:46 - application and
07:48 - all you need to do to set up core data
07:51 - is to make sure this check box is
07:53 - enabled
07:54 - so let's call this our core data demo
07:59 - and just make sure that's enabled and
08:02 - let's hit next oh by the way i am still
08:05 - using
08:05 - storyboards ui kit here so if you're
08:08 - following this demo you can select the
08:10 - same thing
08:11 - let's click next and i'm going to save
08:13 - this on my desktop
08:15 - now the first thing you'll notice is
08:17 - that enabling that
08:19 - use core data option gave you this file
08:22 - along with your new project this data
08:26 - model
08:26 - file and when you click that you get
08:28 - this visual editor to define your
08:30 - entities and attributes
08:32 - if you remember from the slide we just
08:34 - saw the first step
08:35 - is to define our entities and attributes
08:37 - so let's go ahead and do that through
08:39 - this visual interface
08:41 - down here click add entity and you're
08:43 - going to see your new entity here
08:45 - now you can either edit the name by
08:48 - clicking it once
08:49 - so you make it editable or you can come
08:51 - in here and just
08:52 - change the name of the entity so i'm
08:54 - going to use the same example as
08:56 - we did in lesson one of this core data
08:58 - series which is
08:59 - to use the person and family analogy
09:02 - we're only going to start with person
09:03 - for now later when we talk about
09:05 - relationships in core data then we're
09:07 - going to
09:08 - define our family entity as well all
09:11 - right so before we move on to attributes
09:14 - there are a couple of things i want to
09:15 - point out in terms of the attributes for
09:17 - the entity
09:19 - number one is the name which we've just
09:21 - defined number two
09:22 - is this this module or namespace
09:26 - if you have an xcode project which
09:28 - houses multiple modules or xcode
09:30 - or other projects i mean then you can
09:33 - define
09:33 - which namespace you want this entity to
09:36 - be a part of
09:37 - by default it's global so for
09:40 - i think for most of us who are just
09:42 - creating an xcode project for a single
09:44 - app
09:44 - that has one module you don't have to
09:47 - worry about this
09:48 - but just in case your project has
09:50 - multiple modules
09:51 - and you don't want this person class
09:53 - name to clash with
09:54 - some other person class name in another
09:57 - module then you can
09:58 - definitely define uh the namespace here
10:01 - or rather which
10:02 - namespace this person is part of
10:05 - the next part is codegen now
10:08 - after we define our entities and
10:10 - attributes when we generate the classes
10:13 - you can actually do that either manually
10:15 - or have xcode do that for you
10:17 - when you build and run the app by
10:19 - default
10:20 - xcode will do it for you automatically
10:22 - but for now i want you to change
10:24 - this option to manual none because i
10:26 - want to show you how to do it manually
10:28 - and then i will also tell you about the
10:30 - other two options because there are
10:32 - trade-offs to be made so let's go ahead
10:34 - and select manual none for now
10:36 - all right now we're ready to add our
10:37 - attributes so under here
10:40 - you can click this plus symbol to add a
10:42 - new attribute
10:43 - or you can click this add attribute icon
10:46 - down here which i think is not as
10:48 - intuitive
10:49 - as this guy so go ahead and click add
10:51 - item
10:52 - and then you can give it a name so our
10:54 - first one was
10:55 - just name so let's just name it that and
10:58 - then
10:58 - the type let's choose string so we're
11:01 - going to add another one
11:04 - we had gender here and again this was a
11:07 - string
11:08 - now the next one was age
11:11 - and the type was actually an int
11:15 - now you'll see in the type here there's
11:17 - integer 16 32
11:19 - and 64. if you're not familiar with what
11:22 - those are
11:24 - basically they define the size of the
11:26 - integer now i'm going to pull up
11:28 - a web page here that shows you the
11:32 - differences
11:33 - with the different integer types so
11:35 - you'll notice that there's different
11:37 - types of
11:37 - ins there's 8 32 64 and you can see that
11:41 - the ranges
11:42 - go up as this number goes up and there's
11:45 - also a u-int
11:46 - version of each of these sizes u stands
11:49 - for unsigned which means that there's no
11:52 - negative range so as you can see in 64
11:55 - gives you the largest range
11:57 - but we don't usually have to select
12:00 - which type of in we use
12:01 - right when you define in swift of a new
12:04 - variable of the int type
12:06 - you don't have to specify any of these
12:09 - well under the
12:10 - hood that int type that you specified is
12:13 - one of these types and it
12:14 - really depends on what platform
12:17 - your code is running on because
12:19 - different cpu
12:20 - architectures store data differently
12:23 - some are 32-bit some are 64-bit and some
12:25 - as you can see
12:26 - might be 8 or 16. there's this website
12:28 - here that i found
12:30 - specifying the different architectures
12:33 - of the
12:33 - ios platforms and you can see in here
12:38 - sort of what cpu architecture it's using
12:41 - and whether it's 32-bit or not
12:43 - and as you can see as we scroll down
12:45 - this list these are the older iphones
12:47 - and ipods and ipads and as you scroll
12:49 - down to the newer ones
12:51 - at this point you know in
12:54 - 2015 it looks like everything starts to
12:58 - be 64-bit
13:00 - so as you can see here down to you know
13:02 - the latest ones down here
13:04 - it's all 64-bit so it's safe to say when
13:06 - you're declaring a swift int
13:08 - and your app is going to be running on
13:10 - one of the newer devices
13:12 - 2015 and above that it's going to be
13:14 - 64-bit architecture
13:16 - so your int is actually an int 64
13:19 - with this range so going back to the
13:22 - core data now
13:23 - what should you specify here well don't
13:26 - get the wrong idea
13:27 - just because for the age you won't need
13:29 - such a big range
13:30 - thinking specifying in 16 might save you
13:34 - some memory or save you some space it
13:35 - doesn't work like that the memory
13:37 - allocated for that
13:38 - age variable will still be 64-bit so you
13:41 - might as well
13:41 - just choose 64-bit so that's kind of
13:45 - a long explanation about those
13:48 - about what those differences are now you
13:50 - might also notice on this list
13:52 - that we don't have array types
13:55 - or you know object types or anything
13:58 - like that
13:59 - well if you wanted to specify let's say
14:01 - an array of
14:04 - let's say for name for example and we
14:06 - wanted to specify an array of names
14:09 - instead you choose transformable and
14:11 - then
14:12 - over here on the right hand side for the
14:15 - name attribute
14:16 - you can set a custom class and we can
14:19 - set this to be a type of
14:21 - string array or if it's maybe
14:25 - referencing another custom class that
14:27 - you have you can
14:28 - put the class name there and when this
14:32 - entity gets generated this uh
14:35 - name attribute will be transformed into
14:38 - a name property
14:39 - of that type so i'm just going to set it
14:42 - back to string for now
14:44 - so if you want to learn more about
14:46 - configuring entities
14:47 - there is apple documentation for that
14:50 - talking about the different attributes
14:51 - and the different things you can
14:53 - specify i'll link this page in the
14:56 - description below the video
14:58 - now i want to talk about generating code
15:00 - from this entity
15:02 - generating the classes i mean now
15:04 - earlier i mentioned that there are a
15:05 - couple ways to do it
15:07 - manual class definition and category
15:09 - extension
15:10 - let's start by manually generating this
15:13 - so go ahead to editor click create
15:17 - ns manage object subclass make sure that
15:20 - there's a check mark beside your data
15:21 - model
15:22 - and a check mark beside your entity
15:24 - click next and you can just save it
15:26 - anywhere
15:26 - it's going to create two files here and
15:29 - typically what i'll do is create a
15:32 - model group and move that in there so
15:34 - things are a little more organized
15:36 - so you'll notice that there are two
15:38 - files for your one entity
15:40 - and it's person plus core data class and
15:42 - person plus core data properties
15:44 - let's start with this one now this one
15:47 - is the class declaration
15:49 - for person or your entity you know
15:52 - and it's subclassing ns managed object
15:55 - which i told you before that your entity
15:58 - or your class
15:58 - needs to do in order to be saved and
16:00 - retrieved and basically work with core
16:02 - data
16:03 - now the second file is an extension of
16:06 - your class
16:07 - so if that's new to you just think of
16:09 - these two files combined together
16:11 - is your complete person class this
16:15 - extension contains
16:18 - all of your attributes as properties and
16:21 - you can see the data types are exactly
16:22 - what we specified
16:24 - notice that there's also this type
16:26 - method here called fetch request
16:28 - so later on we're going to be able to
16:30 - generate
16:32 - a query or a fetch request simply by
16:35 - typing person
16:36 - the class name dot fetch request but
16:39 - we'll get into that part later
16:40 - for now the key thing i want to mention
16:42 - is why this is split into two classes
16:45 - um the reason is because for this class
16:48 - definition or declaration here this is
16:51 - where you want to put
16:52 - all of your custom code if there are
16:54 - custom methods you want to put into this
16:56 - class
16:57 - this is where you would do it this one
17:00 - i would try not to modify because when
17:02 - you regenerate these classes
17:05 - maybe you've made a change to your model
17:07 - and you regenerate these classes
17:09 - whatever changes you've done here are
17:11 - going to be overwritten
17:12 - so speaking of which whenever you make a
17:16 - change
17:18 - to any of the attribute names or the
17:20 - types or maybe you add a new attribute
17:22 - or something like that you're going to
17:23 - want to regenerate those classes
17:26 - so then you can go ahead and delete your
17:28 - classes
17:29 - if you've if you've made changes here
17:31 - definitely don't delete this file
17:33 - only to only delete this one right here
17:35 - right because this is the one that
17:37 - just defines all of your properties
17:42 - but this is what manually generating
17:45 - your classes and tails
17:46 - you're going to have to manually make
17:48 - sure that
17:50 - this extension this property extension
17:53 - here
17:54 - is up to date with what you've defined
17:56 - here now let's talk about
17:58 - having xcode automatically generate
18:00 - these classes for you
18:03 - so if we click on the entity and we go
18:05 - under code gen
18:06 - by default if you remember earlier
18:10 - by default it was set to class
18:11 - definition when it's set to this
18:13 - you don't have to manually generate the
18:16 - classes
18:17 - so you wouldn't have these these would
18:19 - you would basically delete these you
18:20 - wouldn't have you wouldn't have done
18:22 - this
18:23 - what happens instead is that when you
18:26 - build your xcode project those two files
18:28 - right there
18:29 - they automatically get generated for you
18:32 - behind the scenes you'll never see them
18:33 - that means you cannot edit them so a
18:36 - drawback
18:37 - with having xcode automatically do this
18:40 - for you
18:40 - is that if you wanted to put some like
18:43 - custom logic or custom methods
18:45 - in your person class you can't because
18:46 - you won't have these two files to modify
18:50 - um but the advantage is that you don't
18:52 - have to manually
18:54 - make sure that these this file is up to
18:56 - date
18:57 - with whatever you've defined here
18:59 - because every time you build your xcode
19:01 - project
19:01 - those two classes will get regenerated
19:03 - behind the scenes
19:05 - so what we've done here is we've
19:08 - manually generated these and
19:10 - i have the entity set to automatically
19:13 - generated on build
19:14 - what's going to happen if i build the
19:16 - project now well
19:18 - i'm going to get an error because what's
19:20 - happening
19:21 - is when i hit build on xcode it's trying
19:24 - to generate
19:25 - those two files for the entity because
19:28 - i've set it to that
19:29 - but it also recognizes that i have these
19:32 - two files here in my project so it's
19:34 - clashing if you look at the error
19:36 - it's going to say you know multiple
19:39 - commands produce that file
19:40 - so this is what you don't want in order
19:42 - to fix a problem like this
19:44 - you can simply go ahead and delete these
19:46 - move these to the trash
19:47 - if you want to ultimately have xhood
19:50 - automatically generate them to you
19:52 - for you i mean you move these two files
19:55 - to trash
19:56 - go to product and then clean build
19:58 - folder make sure you remove
19:59 - any artifacts and then you can rebuild
20:01 - your project
20:02 - or if you want if you want to manually
20:06 - do it just set this to
20:07 - manual none but you cannot have a
20:09 - combination of having xcode
20:11 - automatically generated for you
20:12 - and have these existing in your exclude
20:15 - project all right so now for the last
20:17 - code gen option which is category
20:19 - extension
20:20 - when you have it set to this xcode is
20:24 - only going to generate this
20:27 - extension file for you automatically
20:29 - which means you can go ahead and delete
20:31 - this
20:33 - now this is sort of like a happy medium
20:35 - you can just
20:36 - straight up move it to the trash
20:39 - this is a happy medium because you still
20:41 - get this one file
20:43 - which you have to manually generate
20:44 - initially and then you go ahead and
20:46 - delete that category extension file
20:48 - but now you can add your custom logic in
20:50 - your custom methods
20:52 - and you don't have to make sure that the
20:56 - extension containing all of the
20:59 - properties
21:00 - is up to date with the model because
21:03 - having it set to a category extension
21:06 - for the code gen
21:07 - every time you build your xcode project
21:09 - it's going to
21:10 - generate that half of the class for you
21:14 - and right now i have an error probably
21:16 - because i didn't
21:17 - build my um build sorry clean my build
21:21 - folder
21:22 - as you can see it's still complaining
21:23 - multiple commands produce
21:25 - so i'm going to go back to product clean
21:28 - build folder
21:29 - and i know that having this code gen set
21:33 - to category extension
21:35 - and having this other half here if i
21:38 - press command b
21:39 - i'm going to get the full definition of
21:42 - my entity so i guess to sum it up
21:48 - manual is full control right you have to
21:51 - generate two files
21:52 - but you have to just make sure that it's
21:55 - like congruent with what you've defined
21:57 - here
21:58 - class definition is no control you don't
22:01 - get to add
22:02 - you don't get to modify the classes at
22:03 - all it gets generated behind the scenes
22:05 - when you build the xcode project
22:07 - and category extension is it
22:09 - automatically generates
22:10 - half of it for you and the other half
22:12 - you can
22:13 - customize the code okay so now we've
22:15 - defined our entities and attributes
22:17 - we've generated the classes
22:19 - now we need a reference to the core data
22:21 - persistent store
22:22 - well when you created this xcode project
22:25 - and you
22:26 - enabled use core data in the app
22:28 - delegate
22:29 - it's actually set up something
22:31 - additional for you down here
22:33 - you can see that now we have this
22:36 - persistent container
22:38 - property and this lazy keyword just
22:41 - means that it's not going to
22:43 - run all this code and create that
22:46 - container
22:47 - until you access it for the first time
22:50 - but this is your core data persistent
22:52 - container and it's
22:54 - a property in your app delegate so
22:56 - that's how you're going to access this
22:58 - persistent container
22:59 - as you can see here this name here maps
23:03 - to this
23:04 - core data this data model file right
23:08 - here
23:09 - all right so because this property is in
23:12 - the app delegate
23:13 - we can access it from any view
23:15 - controller or any other class
23:17 - in our entire project all right now
23:19 - let's go into the view controller and
23:20 - let me show you how to access the
23:22 - persistent container from there
23:25 - so we need a reference to the persistent
23:27 - container you can access the app
23:29 - delegate first
23:30 - by typing ui application
23:35 - i don't know about this one but this is
23:37 - how i
23:38 - would normally do it
23:41 - uiapplication.shared.delegate
23:43 - and you can see that it's optional here
23:45 - but the type is ui application delegate
23:47 - but we got to cast it
23:48 - as our app delegate
23:52 - okay and then now that it's
23:55 - our app delegate you can access the
23:57 - persistent container property
24:00 - right so this gives us access to that
24:02 - core data persistent container
24:04 - but if you remember from lesson one we
24:06 - don't interact with the core data
24:08 - persistent container directly
24:10 - we use the managed object context and in
24:13 - order to get a reference to that so that
24:15 - we can
24:15 - use the manage object context
24:18 - we just have to access a property on the
24:20 - persistent container
24:22 - called the view context you can see the
24:24 - data type for this is
24:25 - ns managed object context so this is
24:28 - actually what we need
24:29 - in order to store our data retrieve our
24:32 - data from
24:33 - core data and all of that but don't
24:36 - worry i'm getting a little ahead of
24:37 - myself
24:38 - because in the next lesson we're going
24:40 - to look at creating retrieving updating
24:41 - and deleting data
24:42 - through the managed object context for
24:44 - now i just wanted to show you how
24:46 - we can access the persistent container
24:49 - and
24:50 - also the managed object context now
24:53 - before we go into adding core data to
24:55 - an existing project i just want to show
24:56 - you one more thing in appdelegate
24:59 - because aside from this persistent
25:00 - container property there was also
25:02 - another thing down here
25:04 - called it also added this save context
25:07 - method
25:08 - and as you can see all this method is
25:10 - helping you do
25:11 - is it's getting a reference to the
25:15 - managed object context and then
25:18 - detecting if there has been any changes
25:20 - to the data
25:21 - and then saving right so it's
25:25 - just an easy way for you to save changes
25:28 - to your persistent container so you can
25:31 - do it by simply calling
25:32 - the save context method of the app
25:35 - delegate
25:37 - okay so when you start a new xcode
25:39 - project and you enable core data right
25:41 - off the bat
25:42 - you get the core data model file
25:44 - included and
25:45 - in the app delegate you have methods to
25:47 - access the core data persistent
25:49 - container
25:50 - and manage the object context now if you
25:53 - have an existing xcode project that you
25:54 - want to convert to using core data you
25:56 - won't have these things currently in
25:58 - your xcode project
25:59 - now let me show you how to add them so
26:01 - that you can use core data
26:03 - all right so now let's say you have an
26:05 - existing project that you didn't set up
26:07 - with core data so i'm just going to
26:08 - create
26:10 - a test project here and i'm going to
26:13 - i'm not going to enable use core data
26:19 - let's create that there and so let's say
26:22 - this is your existing project well
26:24 - all you have to do number one is add
26:26 - that data model file
26:29 - so go ahead and add a new file
26:33 - and under core data choose data model
26:37 - right and you can save this
26:39 - uh with whatever your name of your
26:42 - project is so
26:43 - i guess i'll call this testproject.xc
26:46 - data model and here you know you have
26:48 - your entities you're going to define
26:50 - your
26:50 - entities and attributes as normal
26:54 - also in appdelegate you'll notice that
26:56 - you do not have that persistent
26:58 - container property that i showed you and
27:00 - we don't have that save
27:01 - context method as well so you would
27:05 - just essentially add that code here but
27:08 - i don't really know that code by heart
27:11 - and i don't expect many people will so
27:14 - what i
27:15 - usually do is i create a brand new xcode
27:18 - project
27:20 - with core data enabled just to get that
27:22 - code and i'll copy and paste it in here
27:24 - so i can take that demo that we were
27:27 - just working on
27:29 - and i can copy this
27:32 - right that's the persistent container
27:37 - property but you have to make sure that
27:39 - this name right here
27:41 - matches that right so test
27:44 - project and that's the that's the
27:48 - core data data model file that you added
27:51 - and you also have to import core data at
27:53 - the top because
27:54 - otherwise the classes wouldn't be
27:57 - recognized
27:58 - right and then you can go back to your
28:00 - other project and just copy the saved
28:02 - context
28:03 - code over as well
28:07 - and it's as simple as that now the other
28:10 - thing is
28:10 - in an existing project you probably have
28:13 - your own
28:14 - model files already or your own model
28:16 - classes i mean
28:18 - you would have to redefine them as
28:21 - entities here
28:22 - along with their attributes and all of
28:23 - the relationships which
28:26 - a couple lessons later we'll talk about
28:28 - but you'd have to redefine all of those
28:29 - things
28:30 - and then regenerate the classes to
28:33 - replace
28:34 - your current model classes and then you
28:37 - would also have to alter the way
28:39 - that you get the data and in the next
28:41 - lesson you'll learn how to create
28:42 - retrieve
28:43 - update and delete data from core data so
28:46 - you're going to have to modify your
28:47 - existing project a little bit
28:49 - so that it uses that managed object
28:52 - context
28:53 - to fetch the data save the data and all
28:55 - of that stuff
28:57 - all right so in this lesson you learned
28:58 - how to set up your xcode project to use
29:00 - core data
29:01 - in the next lesson you'll learn how to
29:02 - create retrieve update and delete data
29:04 - from core data so i'll see you there
29:09 - hey code crew in this lesson we're going
29:11 - to continue our core data series and
29:12 - i'll show you how to create retrieve
29:14 - update and delete data from core data
29:17 - all right now let's jump into xcode
29:19 - all right so in this xcode project i'm
29:21 - going to show you how to create retrieve
29:22 - update and delete data from core data
29:25 - now i did
29:26 - set up a lot of the ui for this project
29:29 - and i'm only going to be focusing on the
29:31 - core data transactions bit
29:34 - and the reason for that is because if i
29:35 - showed you how to build the ui
29:37 - 90 of this lesson would have just been
29:39 - building ui with 10
29:41 - being the actual core data bits which is
29:44 - the focus of this lesson so
29:45 - that's why i built it out but i'm going
29:47 - to walk you through the ui work that
29:48 - i've done so far
29:49 - and i'm going to show you where the
29:51 - missing core data bits are that we're
29:52 - going to fill out together
29:54 - okay so first of all what data are we
29:56 - working with here
29:57 - so back in lesson two and lesson one we
30:00 - were talking about a person entity
30:02 - same thing here person entity these
30:04 - attributes are the same
30:05 - which i've defined i've generated the
30:08 - uh actually before that i've set the
30:11 - code gen to manual and none that means i
30:13 - have to manually
30:14 - generate the sub classes and you can see
30:16 - that i have done that here
30:17 - so here's my class there's nothing in
30:19 - here and these are the properties
30:21 - mapped to the attributes okay so what
30:24 - does the ui look like
30:26 - if i go to the main.storyboard you'll
30:28 - see that i have a
30:29 - table view which i'm going to use to
30:31 - display all of the people
30:33 - in our database and then we have an add
30:36 - button up here
30:36 - which i'm going to show an alert or a
30:39 - pop-up with a text box
30:40 - where we can type in a name and that's
30:42 - going to add a new entry
30:43 - into our core data database we're going
30:46 - to be able to swipe each row
30:48 - to delete that person from the database
30:50 - and finally we're going to be able to
30:52 - tap on a row
30:54 - and pop up that alert again and be able
30:56 - to edit the name
30:57 - and then save it so that's updating data
31:00 - now i do want to mention that in this
31:01 - lesson i'm not going to explain how
31:03 - table views work
31:04 - and how you know a lot of this ui is
31:07 - constructed because
31:09 - we've gone through a lot of this stuff
31:11 - in previous lessons if
31:12 - you haven't seen those or you're still
31:14 - confused about table views and
31:16 - protocols and delegates and stuff like
31:18 - that and how the table view gets data
31:20 - from the view controller
31:21 - do visit my other lessons especially the
31:23 - 29 day beginner challenge which i'll
31:25 - link to
31:26 - i'll put a card up on the screen so
31:28 - let's dive into the view controller and
31:30 - let me show you some of the code
31:32 - we're going to do retrieval first i'm
31:34 - going to show you how the table view
31:36 - gets the data
31:37 - and then we're going to hook that up to
31:38 - core data so this items property right
31:41 - here
31:41 - this is the array of data that is
31:44 - powering the table view as you can see
31:46 - now it's not set to anything but that's
31:49 - where we come in and we're going to
31:50 - hook it up to our core data data so
31:53 - we're going to start at the top by
31:56 - getting a reference
31:57 - to the managed object context remember
32:00 - from the previous lessons i explained
32:01 - that you don't work with the core data
32:03 - persistent store directly
32:05 - there is a layer called the managed
32:07 - object context
32:09 - that you interact through to save and
32:12 - retrieve your data
32:14 - so how do we get a reference to this
32:15 - managed object context
32:17 - well inside the app delegate here
32:21 - you see this property for persistence
32:23 - container
32:24 - so we're going to get a reference to
32:25 - this which is going to give us the
32:28 - core data persistent container and
32:30 - there's a property on this
32:32 - object which gives us the managed object
32:35 - context
32:36 - so up here we're going to say
32:41 - ui application dot shared
32:44 - dot delegate and we're going to cast
32:46 - that as
32:48 - an instance of the app delegate
32:52 - and then we can access that property i
32:54 - just showed you called persistent
32:55 - container
32:56 - and then a property off of that called
32:59 - the
33:01 - view context this is the one we're
33:02 - looking for the ns manage the object
33:05 - context
33:06 - so we're going to keep a reference to
33:08 - that and we're going to call it context
33:09 - up there and that's going to make it
33:10 - easy for us to
33:14 - basically use the context to retrieve
33:16 - and save
33:17 - we're going to be using this reference a
33:19 - lot okay so down here
33:21 - in the view did load this is standard
33:23 - hooking up table view stuff
33:25 - there is this method here called fetch
33:27 - people
33:29 - and that's this method right here as you
33:31 - can see it doesn't do anything right now
33:33 - but we are going to fetch the data from
33:36 - core data to display
33:40 - in the table view all right so the way
33:43 - we do this
33:44 - is context dot
33:47 - fetch and you can see here that first of
33:50 - all it throws an error if it cannot
33:52 - fetch what you're asking it to fetch
33:53 - then it's going to raise an error so we
33:55 - do have to
33:56 - wrap this in a do catch block and handle
33:59 - that error
34:00 - but you'll notice that the other thing
34:02 - it accepts is a fetch request
34:04 - now we're going to start by putting in a
34:07 - very simple fetch request to say
34:10 - retrieve all of the people objects but
34:13 - in the next lesson
34:14 - we're going to take a look at other
34:16 - types of requests that you can do to
34:18 - sort and filter all right so let's
34:20 - choose one of these
34:21 - and let's choose this one right here i
34:24 - don't think it really matters right now
34:27 - and i pointed this out to you
34:30 - in lesson one or two but you can see
34:34 - here that it's got a
34:36 - a static or type method here called
34:39 - fetch request
34:40 - and this actually returns a fetch
34:44 - request
34:45 - for all of the person entities in core
34:48 - data
34:48 - so this is the method that we're going
34:51 - to call of the person class
34:53 - to generate a fetch request that we're
34:55 - going to pass into
34:57 - the managed view context so let's take a
34:59 - look at how that works
35:00 - so since it's a type method i don't have
35:03 - to declare a new instance of person i
35:05 - just go person
35:06 - dot fetch request like that all right so
35:09 - i'm passing in a request to grab
35:11 - all of the person objects
35:14 - in core data and we can either
35:18 - you know we can either do the try
35:20 - keyword like that
35:21 - to not care if any errors get raised or
35:24 - we can actually handle the error
35:25 - properly
35:26 - so you know we're going to do a do
35:30 - catch block like this and again i'm not
35:32 - gonna explain or cover this in depth
35:34 - right here
35:35 - since this lesson is sort of a little
35:38 - more advanced
35:38 - so essentially we are trying to
35:42 - uh trying to fetch this
35:46 - so we are going to assign the results
35:48 - it's going to be an array of
35:50 - person objects we're going to assign it
35:52 - to this property up here so
35:55 - self dot items equals
35:58 - we're gonna try so after all of the
36:01 - items get fetched then we assign it to
36:03 - this array we gotta tell the table view
36:05 - to
36:05 - um refresh or reload its data so that's
36:08 - what we're gonna do here
36:10 - table view dot reload data
36:14 - now i'm going to do this in
36:17 - the main queue because sometimes we're
36:19 - going to be calling this fetch people
36:20 - method
36:21 - from a background thread so the way we
36:24 - do that is we use
36:26 - dispatch queue.main.async and this is
36:29 - going to
36:30 - um because this is ui work when you
36:32 - reload the table view it's
36:34 - essentially going to fire all of those
36:37 - methods to
36:38 - grab the cells and stuff like that and
36:40 - that's ui work so
36:41 - we want to make sure that we're doing
36:43 - that in the main thread and just in case
36:45 - you're not sure about why
36:46 - it's really the main thread that should
36:48 - be updating and handling the ui
36:50 - when you start trying to do that from
36:51 - the background then a background process
36:53 - or thread then
36:54 - you might start getting performance
36:57 - impact or hits
37:01 - okay so just from doing that we should
37:04 - be able to see something because i do
37:05 - have
37:06 - a single person object inside core data
37:09 - right now
37:11 - so if i run the project
37:14 - you're going to see
37:17 - that it indeed goes to fetch data
37:21 - and we have one entry and it's just
37:23 - placeholder right now
37:25 - yeah just ignore that for a second
37:31 - the reason why it says placeholder is
37:33 - because for this
37:34 - self or row at method
37:37 - i just set the text of the label for
37:40 - that row to placeholder
37:41 - but we're going to i guess we could
37:43 - change that right now
37:45 - so we're going to get the person from
37:47 - the array
37:48 - uh let person equals self thought items
37:52 - and we're going to pass in index
37:54 - path.row and that's going to give us the
37:56 - person
37:57 - and then in here we're going to say
37:58 - person dot
38:00 - uh name
38:06 - this is an optional so i'm just going to
38:08 - force unwrap it
38:09 - and we'll grab the name so let's run it
38:11 - again and
38:12 - instead of placeholder text we actually
38:14 - see the name of the
38:16 - person object all right so now
38:20 - that's fetching data from core data it's
38:22 - as easy as that
38:23 - except that right now you can only fetch
38:26 - all of all of it you don't know how to
38:28 - sort of sort and filter but we're going
38:30 - to cover that
38:30 - in the future all right now for adding
38:33 - data
38:34 - how do we add data right now when we
38:36 - click this button
38:38 - i'm just popping up a pop-up to ask for
38:41 - the name of the person and we're going
38:42 - to create that new person object and
38:45 - add it to core data all right so that's
38:48 - this button handler right here add
38:50 - tapped so all i'm doing here
38:52 - is creating a new pop-up you can see
38:55 - here
38:55 - i'm adding a text field and then i am
38:59 - writing a submit button that says add
39:02 - right and when that add button gets
39:05 - tapped on
39:06 - so if we go back here you know they'll
39:08 - fill in a name like joe
39:10 - when this add button gets tapped on this
39:13 - is the code that's going to get run
39:15 - all right so how do we access the text
39:18 - in this field
39:19 - well the alert since we added a text
39:23 - field to the alert through this
39:24 - add text field method we can access the
39:27 - array of text fields
39:28 - like this alert dot text fields and we
39:31 - can access the first one because there
39:32 - only is one we only did this once right
39:35 - so that's our text field right here and
39:38 - here we're going to create a new person
39:39 - object
39:40 - and then we're going to assign the name
39:42 - and the age and
39:44 - the gender and stuff like that all right
39:45 - so let
39:47 - new person equals and we're going to try
39:50 - to create a new person object
39:53 - like usual by using these rounded
39:55 - brackets but you'll see here that
39:57 - because this is a subclass of ns managed
40:00 - object
40:01 - right that's what allows it to be saved
40:05 - into core data
40:06 - like we had talked about because that's
40:09 - the case
40:12 - you'll see that i have this option right
40:14 - here right to
40:15 - create this person object in a specific
40:18 - context
40:19 - right and accepts a parameter and let's
40:21 - manage the object context well
40:23 - we're going to pass in the context
40:27 - that
40:30 - self.context we're going to pass in this
40:32 - context up here
40:35 - right that's how we're interacting with
40:37 - our core data persistent
40:38 - container right so where was that code
40:41 - right here
40:42 - so just like that we've created a new
40:44 - person object
40:46 - in that context and now we're going to
40:47 - set some properties for it so newperson
40:50 - dot name is equal to text field dot text
40:54 - and this is that text field right there
40:57 - in the pop-up
40:59 - and for the age i'm just gonna set it to
41:02 - some arbitrary number
41:06 - same thing with gender but i assume that
41:08 - you would you would ask for all of this
41:10 - data
41:10 - you know when you're adding a new person
41:13 - okay so
41:14 - just creating a person object in the
41:16 - context is not enough to save the data
41:18 - you actually have to
41:20 - save it if you don't save it then
41:23 - the next time you run it you won't
41:25 - actually find this person anymore it
41:27 - doesn't get
41:28 - saved into core data so the way you save
41:30 - the data
41:31 - is through the managed object context
41:35 - so self.context dot save
41:38 - and that's simply it notice that this
41:40 - method also throws
41:42 - right so you can do you can you can wrap
41:44 - it in a do catch block and
41:47 - you know try to catch an error if
41:49 - there's a problem saving it
41:51 - so you have to put a try keyword in
41:52 - front of the throw method
41:54 - you can do this and try to catch the
41:56 - error if there's a save
41:58 - data error or you can
42:01 - simply not care if there are errors or
42:04 - not and do that
42:07 - if this were an actual app i would
42:10 - definitely try to catch all the errors
42:11 - and
42:12 - respond to and let the user know that
42:14 - there was an error in saving the data
42:15 - and all that
42:16 - all right so saving the data and then we
42:18 - have to refresh the table view
42:20 - because we've um
42:24 - all we've done now is create a new
42:25 - person object and we've saved it to core
42:28 - data
42:28 - but that doesn't change
42:32 - this array which the table view is
42:34 - reading off of right
42:36 - so i'm going to call the
42:40 - fetch people method right here
42:45 - self dot fetch people and just in case
42:48 - you don't remember about this fetch
42:49 - people method
42:51 - if i scroll up here it all it does is
42:54 - it hits the managed object context
42:57 - passing in a person
42:58 - fetch request to grab all of the people
43:00 - object back
43:01 - assigns it to this property which the
43:03 - table view is reading off of
43:05 - and then calls tableview.reload to
43:07 - reload the data
43:09 - and good thing that this puts it on the
43:11 - main thread
43:12 - because we're calling it from a
43:15 - background thread right here
43:17 - and this is a button handler from the
43:19 - submit button okay the last thing to do
43:21 - is add the button to the alert
43:22 - and then to present the alert so let's
43:24 - run this code
43:26 - and we should be able to add new objects
43:30 - to our database
43:30 - so let's say joe when i hit add what's
43:34 - going to happen
43:34 - it's going to create a new person object
43:37 - in our
43:38 - object manage object context it's going
43:39 - to save the context
43:41 - thereby saving the object into core data
43:43 - and then it's going to call fetch
43:44 - to fetch that data back from core data
43:47 - or
43:47 - fetch that fetch joe back from core data
43:50 - so add boom
43:51 - we got joe nice all right so now let's
43:53 - do delete
43:55 - so i i did this
43:58 - it's just a swipe action on the table
44:01 - view row
44:01 - it's actually very easy to do down
44:05 - uh where was it right here trailing
44:08 - swipe
44:09 - action so that's what we're configuring
44:10 - so we're going to create a new swipe
44:12 - action
44:13 - all it is is a ui contextual action
44:16 - and uh the style is destructive since
44:18 - it's going to be a delete
44:19 - function the title is delete and then
44:22 - here
44:22 - is the handler the code for what happens
44:26 - when you trigger that swipe action so
44:28 - first let's get
44:29 - a reference to the person object that we
44:31 - want to remove
44:33 - so let's person to remove
44:37 - equal self dot items all right and
44:41 - as a parameter it tells you which row
44:43 - was swiped on
44:44 - here so index path dot
44:47 - row okay that's going to give us the
44:50 - person to remove
44:52 - this is optional so let's unwrap that
44:55 - okay so now actually to remove the
44:57 - person and again
44:59 - we do these core data functions through
45:01 - the managed object context
45:03 - so self.context dot
45:07 - actually delete object and you just pass
45:09 - in the object
45:11 - so here we're gonna pass in person to
45:12 - remove and again you have to save
45:15 - or else it's not gonna take effect so
45:17 - view dot context
45:19 - dot save again it throws so you're going
45:22 - to
45:25 - wrap this in a do catch and catch that
45:27 - error if there was
45:30 - an error in deleting in the deletion
45:34 - save the data and then refresh the data
45:37 - here
45:39 - self dot fetch
45:42 - people all right so let's run this
45:46 - and test that out so let's delete joe
45:51 - delete so he's gone and if i
45:54 - rerun my app
45:59 - you'll see that we only have ted okay so
46:02 - we can add another person sammy
46:07 - to replace joe okay so now the last
46:09 - thing is
46:10 - did select row when we let's say select
46:14 - sami all i'm doing here is throwing up a
46:16 - pop-up
46:17 - same idea with the text field let's take
46:19 - a look at the code
46:21 - we have here did select row here i'm
46:24 - just
46:25 - getting the person that was selected
46:27 - through this parameter
46:28 - that that indicates which row was tapped
46:31 - on
46:32 - and then i'm creating an alert i'm
46:34 - adding a text field
46:36 - and i am getting a reference to that
46:38 - text field from here
46:40 - and i'm pre-loading the person's name
46:43 - all right the selected person preloading
46:46 - his or her name
46:47 - into the text field so that when when it
46:50 - brings up the text field we have the
46:52 - existing name in there already
46:54 - and then i configured a save button
46:57 - so you can see here the handler when
47:00 - that
47:01 - gets tapped that is where we are going
47:03 - to edit the name
47:07 - so the selected person
47:10 - we got a reference to it up there
47:12 - already dot name
47:14 - is equal to whatever name is in the text
47:18 - field now
47:19 - you know assuming that person did
47:20 - actually change the name
47:22 - and again save the data
47:36 - and then finally refresh refetch the
47:39 - data
47:44 - so let's run this code right now oh and
47:47 - the last thing i did was
47:49 - add the save button to the alert and
47:50 - then present the alert when
47:53 - upon tapping of a row okay so let's tap
47:56 - on sammy and let's save
47:59 - save sami as joe so now when i relaunch
48:02 - the app
48:03 - you can see that it's ted and joe
48:06 - so just to do a quick recap on all four
48:08 - of the operations we talked about
48:11 - in terms of fetching
48:14 - you call the fetch method of the managed
48:16 - object context and you pass in a fetch
48:18 - request now that could be a fetch
48:20 - request for all of the objects of that
48:22 - type
48:22 - or it could be one that's sorted and
48:25 - filtered
48:26 - upon which you'll learn in a future
48:28 - video
48:29 - in terms of inserting people or or
48:31 - adding new data
48:34 - what you do is you create a new object
48:36 - in the context
48:38 - right and then you call save and then
48:41 - for deleting
48:45 - you call the delete method of the
48:47 - context then you pass in the object you
48:49 - want to delete
48:50 - from core data and then you have to
48:51 - remember to save it
48:53 - and finally for updating
48:56 - you simply change whatever you want to
48:58 - change on that
49:00 - object and then you save it all right so
49:04 - now you learned how to create retrieve
49:06 - update and delete data
49:07 - in core data in the next lesson you'll
49:09 - learn how to sort and filter the results
49:11 - that you get back from core data
49:12 - all right i'll see you there
49:16 - hey code crew in the last lesson you
49:18 - learned how to create retrieve
49:19 - update and delete data from your core
49:21 - data database in this lesson we're going
49:23 - to learn how to filter and sort our data
49:25 - so that you can retrieve
49:26 - only the results that you want from your
49:28 - core data database
49:29 - now filtering allows you to only return
49:31 - the results that match a specified
49:33 - criteria
49:34 - while sorting allows you to return your
49:36 - results in ascending or descending order
49:38 - based on an attribute that you specify
49:41 - all right let's jump into xcode so here
49:44 - we have the xcode project that we worked
49:46 - on in the last lesson
49:47 - and just as a reminder in this fetch
49:50 - people method
49:51 - we were retrieving all of the person
49:53 - objects from our core data store
49:55 - through the managed object context if
49:58 - you remember we don't interact with the
50:00 - core data persistent store directly
50:02 - right we create retrieve update and
50:04 - delete data through the managed object
50:06 - context
50:06 - so that's what this variable refers to
50:09 - context.fetch
50:10 - and that fetch method is how we retrieve
50:13 - data
50:14 - from the core data store now you have to
50:16 - pass in a fetch request
50:18 - into that fetch method and this fetch
50:20 - request
50:21 - actually indicates what you want to
50:22 - retrieve you know how it's sorted what
50:24 - sort of criteria
50:25 - you have for retrieving the data in this
50:28 - particular case
50:29 - we wanted to fetch all person objects
50:32 - and so
50:32 - we just passed in a fetch request as is
50:35 - now where did this fetch request come
50:37 - from
50:38 - if you take a look we're calling a class
50:40 - method called
50:41 - fetch request on the person class so
50:44 - let's
50:45 - go into that and take a look at what it
50:46 - is let's go into this
50:48 - person class here as you can see here
50:50 - this is the fetch request
50:52 - class method and what is returned from
50:55 - this method
50:55 - is a new nsfetch request object
51:00 - and the data type of the data returned
51:03 - is set to
51:04 - the person right and
51:08 - that is what gets returned right and so
51:11 - it's
51:12 - essentially going to fetch all person
51:14 - objects in order to filter and sort we
51:17 - actually have to set some properties
51:19 - on this fetch request before we pass it
51:21 - into this fetch method
51:22 - so why don't we instead of
51:26 - putting in the fetch request here
51:29 - let's declare a variable or constant up
51:31 - here
51:35 - and move this line of code and just
51:38 - have the fetch request up here right and
51:41 - then we're going to set
51:43 - the filtering and sorting
51:46 - on the request and then we're going to
51:50 - pass the request
51:51 - into the fetch method now
51:55 - you're going to get an xcode error as
51:57 - you can see here ambiguous use of fetch
51:59 - request so you
52:00 - actually have to indicate the type
52:03 - that this is an nsfetch request and the
52:05 - data type that it's going to return
52:08 - is person so now that we have a
52:10 - reference to the request up here
52:12 - let's take a look at how we can do
52:14 - filtering first
52:16 - i'm going to run the project so that we
52:18 - can see what data we're working with
52:20 - and so we can decide what data we want
52:22 - to filter for
52:25 - so as you can see we have four names
52:26 - here i am going to just
52:28 - do a simple filtering for
52:32 - only person objects with the name ted
52:34 - all right so
52:35 - let's go ahead and stop the project
52:39 - now to filter based on some criteria we
52:42 - use this class called
52:43 - ns predicate which lets you define
52:45 - different sorts of
52:46 - conditions in a
52:49 - very easy to understand sort of text
52:51 - manner you'll see right here
52:53 - so let i'm just going to call it
52:57 - i'm just going to call it pred equals ns
53:00 - predicate
53:02 - and we can define we can use this one
53:06 - or we can define a format and pass in
53:08 - the arguments
53:09 - so because we want to define criteria
53:11 - based on the name
53:12 - property of the person class
53:15 - let's take a look here so you see it's
53:18 - got a name property
53:19 - that's where you saw the ted the joe the
53:21 - abbey the mic
53:23 - so i'm going to specify this string
53:26 - where i'm going to say the name property
53:29 - contains
53:32 - ted like that and you have to put this
53:36 - criteria here in single quotes
53:43 - and then we have to add this predicate
53:46 - to a property on the request
53:48 - so the fetch request actually has a
53:51 - property called predicate where you can
53:53 - pass in
53:54 - the criteria that we just defined and
53:57 - just like that if i run it now it's
53:58 - going to only return
54:00 - person objects where the name contains
54:02 - ted and i will show you a couple of
54:04 - different examples of
54:05 - sort of what you can filter on in a
54:07 - second and how you can
54:09 - combine different things and use
54:11 - different operators here
54:13 - so let's run the project to quickly see
54:15 - what we have
54:17 - so as you can see here it's only got the
54:20 - person
54:21 - ted now now you saw earlier how i was
54:24 - configuring this format
54:26 - and there was a second parameter because
54:29 - typically the thing that you want to
54:31 - filter on may be dynamic
54:33 - right this you might not know this
54:35 - beforehand so you can't actually code it
54:38 - in like i have now
54:39 - so in that case what you do is you put
54:42 - in a sort of wildcard character
54:44 - and that is defined by percentage at and
54:47 - then you can do comma
54:48 - here and then you can specify whatever
54:50 - variable contains the thing that you
54:52 - want to filter on
54:53 - now i don't actually have a variable to
54:56 - indicate what i want to filter on
54:58 - so here i can just put an example
55:01 - as a string but if you had something
55:04 - that you wanted to filter on
55:06 - you can specify a wildcard in your
55:08 - criteria
55:10 - and then indicate that dynamic variable
55:12 - here
55:13 - now let's take a quick look at some
55:15 - other ways you can define your criteria
55:16 - using
55:17 - ns predicate so here i have the apple
55:20 - documentation for the ns predicate class
55:23 - there are some common examples i'll go
55:25 - through with you
55:26 - in the overview but there's also a
55:28 - detailed guide
55:30 - that you can go through called the
55:31 - predicate programming guide i'll provide
55:33 - all these links below the video
55:35 - this guide if you want to really dive
55:37 - deep into how
55:38 - you can express your queries using ns
55:40 - predicate definitely take a look
55:43 - now some of the more common examples are
55:45 - contains which is the keyword we just
55:47 - used
55:48 - there's also equality with double equal
55:51 - signs and you can use like
55:53 - here's contains you can ignore case and
55:56 - diacritics
55:57 - which are the accents on top of letters
55:59 - if you want to ignore both of them you
56:01 - just put a
56:02 - angle bracket and sorry square brackets
56:04 - and you put cd to ignore both or just c
56:06 - or just d to ignore these respective
56:09 - things
56:10 - you can also combine different
56:12 - conditions together just like an
56:13 - if statement using or and and and there
56:16 - are different keywords to express
56:17 - time and you can use math inequalities
56:20 - like less than or
56:21 - greater than and so on and so forth so
56:24 - definitely give these things a look
56:26 - if you are trying to express some sort
56:28 - of query and you're not finding
56:30 - the right way to write it i'm sure a
56:32 - quick browse through
56:33 - this predicate programming guide will
56:35 - give you some insight on how to express
56:37 - that query
56:38 - again links to these documents below the
56:40 - video all right now let's take a look at
56:42 - sorting now similar to how the ns
56:45 - predicate class is used to define your
56:47 - criteria
56:48 - for how to filter the ns sort descriptor
56:51 - class is used to indicate how your
56:52 - results should be sorted
56:54 - let's go ahead and create an ns sort
56:56 - descriptor and
56:58 - indicate that the names should be sorted
57:00 - in alphabetical order
57:01 - now let's take a look before before we
57:04 - do that
57:06 - let's just comment out this predicate
57:10 - and i'm gonna run the project again so
57:13 - that we can see how it's sorted
57:15 - naturally first so you can see here it's
57:18 - joe ted mike and abby and it's
57:20 - it's not an alphabetical so i'm going to
57:22 - want to sort it in ascending order
57:25 - so let's go ahead and create a new sort
57:28 - descriptor
57:30 - ns sort descriptor
57:33 - and as you can see here again you sort
57:35 - by a particular attribute or
57:38 - in this case they call it the key and
57:40 - we're going to specify ascending
57:42 - is true or false so i'm going to sort by
57:45 - name
57:46 - and i'm going to say ascending is true
57:48 - and now
57:49 - just like with the predicate we have to
57:52 - set it to the request
57:55 - so request has a property called sort
57:57 - descriptors
57:58 - and if you take a look at the type it's
58:00 - actually an array of sort descriptors
58:02 - the reason for this is so that you can
58:04 - specify multiple levels of sorting
58:07 - for example a list of names is usually
58:09 - sorted by last name
58:11 - but however if two people have the same
58:13 - last name then their first name is used
58:15 - to determine who comes first
58:17 - so in this case since we only have one
58:19 - sort descriptor we still have to
58:21 - pass in an array however it can be an
58:24 - array of just
58:25 - our single sort descriptor like that
58:29 - all right now i'm going to run the
58:31 - project and you'll see that it's going
58:32 - to be sorted by name
58:34 - in ascending order as you can see
58:37 - it's abby joe mike and ted now before we
58:40 - end this lesson i want to point out a
58:42 - few more useful properties
58:43 - of the nsfetch request class that you
58:46 - can use to customize your fetch for
58:48 - example
58:49 - you can limit the number of objects that
58:51 - you return using fetch limit
58:53 - you can also start the result set from a
58:56 - certain offset
58:58 - such as this property right here and you
59:00 - can choose to only return specific
59:02 - properties
59:03 - of the objects and much much more so
59:06 - i'll link to this article
59:08 - or documentation below the video
59:11 - alright so in this lesson you learned
59:13 - that you can customize certain
59:14 - properties
59:15 - of the fetch request before passing it
59:17 - into the fetch method of the managed
59:19 - object context
59:20 - specifically you can specify a predicate
59:23 - using the ns predicate class
59:25 - and you can specify sort descriptors
59:27 - using the
59:28 - ns sort descriptor class alright i hope
59:31 - that was helpful
59:32 - in specifying how your objects get
59:33 - returned from core data
59:35 - in the next lesson i'll show you how to
59:36 - specify relationships between your
59:38 - different entities
59:39 - in your data model
59:43 - hey code crew in the last lesson you
59:44 - learned how to filter and sort your data
59:46 - using the predicate and sort
59:48 - descriptor's properties of the fetch
59:50 - request
59:51 - in this lesson you'll learn how to
59:52 - specify relationships between your core
59:54 - data entities
59:55 - alright let's get started if you
59:58 - remember in lesson one of this core data
59:59 - series
60:00 - i showed you a diagram that illustrated
60:02 - what an object graph is
60:04 - we had the person objects and a family
60:06 - object
60:07 - and the family object held an array of
60:09 - person objects
60:10 - we're going to recreate this
60:11 - relationship in our data model
60:13 - let's go into xcode so here's the data
60:16 - model for our core data entities
60:18 - and the first thing we're going to do is
60:20 - to add a family entity so
60:22 - go ahead click add entity and let's
60:25 - change this
60:26 - entity name
60:29 - to family
60:32 - the other thing we're going to do is
60:34 - let's just add
60:36 - an attribute called name and change it
60:39 - to string
60:41 - finally here's the part where we define
60:44 - the relationships between our different
60:46 - entities
60:47 - so we're looking at the family entity
60:49 - right now we're going to hit plus
60:51 - under relationship and we're going to
60:54 - name
60:54 - this relationship and what ends up
60:57 - happening
60:57 - is it's going to be a property just like
60:59 - these attributes are
61:01 - so i'm going to call this people
61:04 - and it's going to essentially store
61:08 - all of the person objects that's part of
61:11 - this family
61:12 - so the destination is basically the data
61:15 - type
61:16 - i'm going to choose person and
61:20 - inverse here there's nothing to select
61:22 - for now but we're going to talk about
61:23 - that
61:24 - in just a second so first of all let's
61:27 - go over to the attributes
61:29 - section of this relationship and specify
61:31 - the type
61:32 - and change it from 2 1 to many and that
61:35 - means that
61:36 - this people property can
61:39 - store multiple person objects
61:41 - essentially it's going to be an array
61:43 - of person objects now let's go over
61:46 - to the person and we're also going to
61:49 - specify a relationship here
61:51 - but in the inverse so it's going to
61:54 - define
61:55 - that a person belongs to a family
61:59 - so under relationship hit plus again
62:03 - and for this property
62:06 - i'm going to call it family and the
62:08 - destination is essentially the type of
62:10 - this property
62:11 - it's going to be family and for the
62:14 - inverse
62:15 - if you pull this down now you're going
62:17 - to see that there is an
62:18 - inverse and this is that relationship
62:21 - that we defined
62:22 - here right in the family entity so
62:25 - that's what we're going to want to
62:26 - select
62:29 - and then if you go back to the family
62:31 - entity under this relationship you're
62:33 - going to see that
62:34 - this inverse has automatically been set
62:37 - for you
62:38 - right and you can specify that the
62:40 - inverse of this relationship
62:42 - is the family property of the person
62:44 - object
62:45 - and the reason we specify this inverse
62:47 - is so that core data
62:48 - can maintain the data integrity of our
62:52 - object graph even if you're not going to
62:55 - use the inverse
62:56 - for example you know you want a family
62:59 - object to hold
63:00 - multiple references to different person
63:03 - objects but you don't really
63:04 - care that a person object has a
63:06 - reference back to the family object
63:08 - you should still specify this inverse
63:10 - relationship
63:11 - in your data model again this is
63:13 - something that apple recommends that we
63:15 - always
63:16 - specify this inverse relationship so
63:18 - that it lets core data
63:20 - maintain the integrity of the data
63:23 - all right now that we've specified this
63:25 - simple relationship between our family
63:27 - and person entities
63:28 - let's go ahead and regenerate our
63:31 - our classes actually i forgot for this
63:34 - family entity
63:35 - i'm going to set it to manual code
63:36 - generation as well
63:38 - just like i have for the person and
63:40 - since
63:41 - it's set to manual that means we have to
63:43 - regenerate these classes every time we
63:45 - make a change
63:46 - now first of all i'm going to go ahead
63:48 - and delete my existing
63:50 - person class because as you can see
63:54 - it doesn't account for that relationship
63:57 - that i just added
63:59 - so let's go ahead select both of these
64:01 - and choose delete
64:03 - and move it to trash now i'm going to
64:06 - choose
64:08 - editor and i'm going to choose create
64:11 - ns managed object subclass select the
64:14 - data model
64:16 - make sure that my entities are selected
64:18 - the ones that i want to
64:19 - generate the classes for hit next
64:22 - and let's just save it right there now
64:25 - i'm going to drag all of these into my
64:27 - model
64:27 - group so one of the first things i like
64:30 - to do
64:30 - after generating these classes is press
64:32 - command b just to make sure that
64:34 - everything builds successfully
64:36 - and if you get a failure sometimes it's
64:39 - just because
64:40 - xcode's detecting some artifacts that
64:42 - should be gone in the build folder
64:44 - so what you do is go to product and hit
64:47 - clean build folder and that will usually
64:50 - do the trick and you can press command b
64:52 - and build it again just to make sure
64:54 - that everything is fine
64:55 - and also sometimes xcode won't detect
64:59 - your new classes and you'll get some
65:00 - weird autocomplete errors
65:02 - and you'll see some xcode errors even
65:04 - though you can run the app
65:06 - successfully if that happens to you
65:08 - usually quitting xcode and restarting it
65:10 - will do the trick and that's what
65:11 - happened to me the first time i was
65:13 - working with this
65:14 - so i just thought i'd mention it now
65:16 - what i'd like to do is just to review
65:18 - the classes that were generated and
65:20 - point out some of the differences to you
65:22 - based on what we edited in the data
65:24 - model so taking a look at this
65:26 - person class now we have a family
65:29 - property
65:30 - you can see that the data type is family
65:31 - so this is a reference from the person
65:34 - to the family the inverse
65:37 - if we go to the family class you can see
65:40 - that
65:41 - here's the name attribute that we
65:42 - specified and here's also the people
65:44 - relationship that we specified the data
65:46 - type is actually an
65:48 - ns set it contains a set of people
65:51 - but take a look at this down here there
65:53 - are a couple of
65:54 - methods so there's two methods it's
65:57 - called the same thing add to people but
65:59 - this is allowed because the
66:00 - the signature is different all right the
66:02 - the parameter that you pass in is
66:04 - different
66:05 - one is for adding a single person object
66:08 - to that
66:09 - set here and this one is
66:12 - if you want to add you know multiple
66:14 - person objects
66:15 - to this set same thing goes for remove
66:20 - remove a single person or remove a set
66:22 - of people
66:24 - now i think you can guess that it's
66:25 - pretty straightforward to specify this
66:27 - relationship
66:28 - and that's why i didn't really modify
66:31 - the user interface
66:32 - of our existing demo app to accommodate
66:35 - families and to specify relationships
66:37 - between people and families because the
66:39 - work that
66:40 - it would have taken me just to create
66:43 - that
66:43 - all of that new user interface it's much
66:46 - faster for me just to demonstrate to you
66:48 - and show you the code
66:50 - for you to create a couple of these
66:52 - entities specify the relationships and
66:54 - save it to our core data
66:56 - database so let's go ahead and do that
66:58 - i'm going to go into our view controller
67:02 - and maybe i will um i'll just do it in
67:06 - in a random method here because i don't
67:09 - want to
67:10 - i don't want to confuse you by writing
67:13 - it
67:14 - in some other method so i'm just going
67:16 - to say
67:17 - uh relationship demo
67:21 - and just create this new function here
67:24 - or a new method here for us to write
67:26 - this code so
67:27 - let's create a family
67:34 - create a person and then lastly
67:38 - we have to remain remember to save save
67:41 - the context
67:42 - okay so let family
67:46 - equals so we're going to create a new
67:48 - family object
67:49 - in our managed object context
67:53 - so that's the context we want to create
67:55 - it in
67:57 - and why don't we go ahead
68:02 - let's set that to var actually because i
68:03 - want to change the name
68:09 - let's call this the abc family and let's
68:12 - create a new person
68:17 - in this context as well and
68:20 - oops let's set the person's name
68:25 - to maggie
68:29 - okay so how do we specify a relationship
68:32 - between
68:33 - the family and the person well there are
68:35 - actually two ways you can do it
68:37 - because we actually have relationships
68:40 - or properties
68:40 - pointing both ways so very simply
68:44 - you can set the family property of the
68:47 - person
68:50 - to this family up here and just like
68:53 - that you've specified that relationship
68:55 - um after you do that when you
68:59 - try to access family dot
69:02 - people you'll find that maggie is
69:05 - actually in that set right and you're
69:08 - gonna have to save it so context
69:11 - dot save
69:14 - so that's the first way you can specify
69:16 - the relationship and as you can see
69:18 - super easy the second way you can do it
69:21 - is by using those methods that i showed
69:23 - you see
69:25 - add to people and obviously you probably
69:28 - have to do this down here
69:38 - you pass in the person and actually
69:43 - we can use let for this
69:47 - and so that's the second way using any
69:49 - of these two ways to specify
69:51 - relationships between your objects and
69:53 - building your object graph like that
69:54 - after you save it to core data and you
69:57 - bring it back
69:57 - those relationships will get maintained
70:00 - right so if you bring back this family
70:01 - you'll be able to
70:03 - um look through the people and find
70:05 - maggie and likewise if you only bring
70:07 - back maggie
70:08 - from a core data fetch you're going to
70:11 - be able to access this family object
70:13 - through the person.family property
70:16 - like that
70:20 - all right so that's the end of the core
70:21 - data series for now you know just enough
70:24 - to start applying this knowledge
70:25 - and using core data in an app now having
70:28 - this core data knowledge is already
70:29 - going to open up a lot of
70:31 - app possibilities and ideas that we can
70:33 - build together on this channel
70:34 - if you don't want to miss it please make
70:36 - sure you're subscribed to the channel by
70:37 - hitting that red subscribe button below
70:39 - and lastly if you enjoyed this series
70:40 - and you learned something new please
70:42 - give this video a thumbs up it really
70:43 - helps with the youtube algorithm and
70:45 - getting exposure for this series
70:47 - finally i'll leave you with this what
70:49 - kind of app are you going to build with
70:51 - these newly found core data skills
70:53 - let me know by leaving a quick comment
70:54 - below alright i'll see you in the next
70:56 - lesson

Cleaned transcript:

hello kokuru welcome to the core data series in this lesson we're going to go through what core data is its benefits and how you're going to use it with xcode first of all what is it core data is apple's local object graph persistence framework now before i scare you away in simple terms it's a way for you to store data on your device locally and then retrieve it later for use the data stays locally on the device so it's not a solution for sharing data with other users and it's not a solution for syncing data across multiple devices although some of that can be done when you combine core data with cloud kit next why should we even use core data well assuming you need to store data in your app some benefits of using core data include number one it's a first party apple framework so it plays nicely and has a tighter integration with other apple apis and frameworks number two being a first party framework means that apple is going to make sure that any new technology it releases will work with it at least i'd like to think that apple would make a bigger effort to make sure that core data plays nicely with anything that they release number three you don't have to install any thirdparty sdks which means you don't have to work with cocoapods or trying to keep thirdparty code libraries up to date all right now for some drawbacks of using core data number one it's not a remote database solution although syncing across devices should be able to be done with cloudkit to be honest i haven't looked into this very much myself yet number two the classes and methods to work with core data may be confusing at first so there's a little bit of a learning curve but i hope in this video series i can simplify that for you number three you have to retrain your brain to think of core data as an object graph persistence framework object graph persistence framework let's take a look at what that means it all has to do with how you interact with core data you see with traditional databases you explicitly insert create update and delete data from the database now even though under the hood core data is using an sqlite database you don't have to explicitly tell core data to insert create update or delete you just create and work with objects in your app like normal and behind the scenes core data will manage the data persistence for you let's take a look at a diagram to see how this works okay so let's say you have two classes family and person the person class contains some properties and the family class has a property storing the person objects for that family you create a family object in several person objects and then you relate those person objects to the family object now you want to store it in core data how do you do that well there are a few core data components that are needed one is the persistent container you can think of this as a representation of the core data store or database however your objects don't interact with the persistent container directly there's a layer on top of the persistent container called the managed object context think of this as sort of a data manager layer your objects will go through the managed object context to be stored or retrieved from the persistent store now these objects in memory along with how they relate to each other is called an object graph when you store the objects into core data all of the data in the properties along with the relationships are preserved in other words the object graph when you retrieve them from core data back into memory you can get them back in the same state they were in before so that's why they call core data an object graph persistence framework now to complete our understanding of how core data works let's revisit our diagram in previous lessons i've shown you how to work with json and decode them into usable objects in our app this process of changing the data into a different format and back is known as encoding and decoding or serializing and deserializing while core data needs to do the same thing here it serializes the object into a format that can be stored in the underlying sqlite database and then it'll deserialize it back into the objects in memory the code or functionality to do that serializing and deserializing process is with a class called ns managed object so if you want your class to be able to be captured in core data you need to subclass ns managed object that gives objects of your custom class the ability to be stored with core data okay so now your objects can be serialized and stored with core data however when you want to bring that object back from core data how does it know what format to deserialize that data back into in other words if you're trying to bring your person back how does it know about your person class and what properties your person class contains well here's the final piece of the core data puzzle in this example we use the person class that subclasses ns managed object well you don't actually create and write this person class yourself instead there's a visual editor where you have to define the class in the core data model they call the class an entity and the properties of your class are called attributes of that entity then after you've defined the entity and attributes in other words your class and its properties you generate the swift classes from this core data model file it's just a command you run from an xcode menu and they'll generate the class files for what you've defined in the core data model the generated class will automatically be a subclass of ns managed object so that core data can serialize and deserialize it then you use that generated class like you would any other class and core data can now store objects of that class and bring them back when needed so let's do a quick recap of how we're going to work with core data you define your entities and attributes in the core data model then you generate your classes from the core data model then you get a reference to the core data persistent container from the persistent container you get a managed object context and through that managed object context you can create objects and store them in core data for retrieval for later use now core data has a stigma of being hard to understand and use i hope i've demystified it at least a little bit for you in this video in the next lesson we'll do a real example of using core data in xcode all right i'll see you there hey code crew in this lesson we're going to do a real example of using core data inside xcode i'll go through two different scenarios number one how to start your xcode project with core data enabled and number two how to add core data functionality to an existing xcode project now even if you're only interested in number two i would still highly recommend that you watch through part one because in part one i'm going to be highlighting the different core data components that are needed now just a quick recap of the previous lesson in case you didn't see it to work with core data we need four things number one is to define our entities and attributes in the core data model number two is to generate the classes from the core data model number three get a reference to the core data persistent container and then number four get the managed object context through which we save and retrieve our objects all right let's jump into xcode and do this all right first we're going to talk about setting up core data with a brand new xcode project and then afterwards we're going to talk about how to add core data to an existing xcode project so here i'm going to set up a brand new xcode project here and i'm going to choose single view application and all you need to do to set up core data is to make sure this check box is enabled so let's call this our core data demo and just make sure that's enabled and let's hit next oh by the way i am still using storyboards ui kit here so if you're following this demo you can select the same thing let's click next and i'm going to save this on my desktop now the first thing you'll notice is that enabling that use core data option gave you this file along with your new project this data model file and when you click that you get this visual editor to define your entities and attributes if you remember from the slide we just saw the first step is to define our entities and attributes so let's go ahead and do that through this visual interface down here click add entity and you're going to see your new entity here now you can either edit the name by clicking it once so you make it editable or you can come in here and just change the name of the entity so i'm going to use the same example as we did in lesson one of this core data series which is to use the person and family analogy we're only going to start with person for now later when we talk about relationships in core data then we're going to define our family entity as well all right so before we move on to attributes there are a couple of things i want to point out in terms of the attributes for the entity number one is the name which we've just defined number two is this this module or namespace if you have an xcode project which houses multiple modules or xcode or other projects i mean then you can define which namespace you want this entity to be a part of by default it's global so for i think for most of us who are just creating an xcode project for a single app that has one module you don't have to worry about this but just in case your project has multiple modules and you don't want this person class name to clash with some other person class name in another module then you can definitely define uh the namespace here or rather which namespace this person is part of the next part is codegen now after we define our entities and attributes when we generate the classes you can actually do that either manually or have xcode do that for you when you build and run the app by default xcode will do it for you automatically but for now i want you to change this option to manual none because i want to show you how to do it manually and then i will also tell you about the other two options because there are tradeoffs to be made so let's go ahead and select manual none for now all right now we're ready to add our attributes so under here you can click this plus symbol to add a new attribute or you can click this add attribute icon down here which i think is not as intuitive as this guy so go ahead and click add item and then you can give it a name so our first one was just name so let's just name it that and then the type let's choose string so we're going to add another one we had gender here and again this was a string now the next one was age and the type was actually an int now you'll see in the type here there's integer 16 32 and 64. if you're not familiar with what those are basically they define the size of the integer now i'm going to pull up a web page here that shows you the differences with the different integer types so you'll notice that there's different types of ins there's 8 32 64 and you can see that the ranges go up as this number goes up and there's also a uint version of each of these sizes u stands for unsigned which means that there's no negative range so as you can see in 64 gives you the largest range but we don't usually have to select which type of in we use right when you define in swift of a new variable of the int type you don't have to specify any of these well under the hood that int type that you specified is one of these types and it really depends on what platform your code is running on because different cpu architectures store data differently some are 32bit some are 64bit and some as you can see might be 8 or 16. there's this website here that i found specifying the different architectures of the ios platforms and you can see in here sort of what cpu architecture it's using and whether it's 32bit or not and as you can see as we scroll down this list these are the older iphones and ipods and ipads and as you scroll down to the newer ones at this point you know in 2015 it looks like everything starts to be 64bit so as you can see here down to you know the latest ones down here it's all 64bit so it's safe to say when you're declaring a swift int and your app is going to be running on one of the newer devices 2015 and above that it's going to be 64bit architecture so your int is actually an int 64 with this range so going back to the core data now what should you specify here well don't get the wrong idea just because for the age you won't need such a big range thinking specifying in 16 might save you some memory or save you some space it doesn't work like that the memory allocated for that age variable will still be 64bit so you might as well just choose 64bit so that's kind of a long explanation about those about what those differences are now you might also notice on this list that we don't have array types or you know object types or anything like that well if you wanted to specify let's say an array of let's say for name for example and we wanted to specify an array of names instead you choose transformable and then over here on the right hand side for the name attribute you can set a custom class and we can set this to be a type of string array or if it's maybe referencing another custom class that you have you can put the class name there and when this entity gets generated this uh name attribute will be transformed into a name property of that type so i'm just going to set it back to string for now so if you want to learn more about configuring entities there is apple documentation for that talking about the different attributes and the different things you can specify i'll link this page in the description below the video now i want to talk about generating code from this entity generating the classes i mean now earlier i mentioned that there are a couple ways to do it manual class definition and category extension let's start by manually generating this so go ahead to editor click create ns manage object subclass make sure that there's a check mark beside your data model and a check mark beside your entity click next and you can just save it anywhere it's going to create two files here and typically what i'll do is create a model group and move that in there so things are a little more organized so you'll notice that there are two files for your one entity and it's person plus core data class and person plus core data properties let's start with this one now this one is the class declaration for person or your entity you know and it's subclassing ns managed object which i told you before that your entity or your class needs to do in order to be saved and retrieved and basically work with core data now the second file is an extension of your class so if that's new to you just think of these two files combined together is your complete person class this extension contains all of your attributes as properties and you can see the data types are exactly what we specified notice that there's also this type method here called fetch request so later on we're going to be able to generate a query or a fetch request simply by typing person the class name dot fetch request but we'll get into that part later for now the key thing i want to mention is why this is split into two classes um the reason is because for this class definition or declaration here this is where you want to put all of your custom code if there are custom methods you want to put into this class this is where you would do it this one i would try not to modify because when you regenerate these classes maybe you've made a change to your model and you regenerate these classes whatever changes you've done here are going to be overwritten so speaking of which whenever you make a change to any of the attribute names or the types or maybe you add a new attribute or something like that you're going to want to regenerate those classes so then you can go ahead and delete your classes if you've if you've made changes here definitely don't delete this file only to only delete this one right here right because this is the one that just defines all of your properties but this is what manually generating your classes and tails you're going to have to manually make sure that this extension this property extension here is up to date with what you've defined here now let's talk about having xcode automatically generate these classes for you so if we click on the entity and we go under code gen by default if you remember earlier by default it was set to class definition when it's set to this you don't have to manually generate the classes so you wouldn't have these these would you would basically delete these you wouldn't have you wouldn't have done this what happens instead is that when you build your xcode project those two files right there they automatically get generated for you behind the scenes you'll never see them that means you cannot edit them so a drawback with having xcode automatically do this for you is that if you wanted to put some like custom logic or custom methods in your person class you can't because you won't have these two files to modify um but the advantage is that you don't have to manually make sure that these this file is up to date with whatever you've defined here because every time you build your xcode project those two classes will get regenerated behind the scenes so what we've done here is we've manually generated these and i have the entity set to automatically generated on build what's going to happen if i build the project now well i'm going to get an error because what's happening is when i hit build on xcode it's trying to generate those two files for the entity because i've set it to that but it also recognizes that i have these two files here in my project so it's clashing if you look at the error it's going to say you know multiple commands produce that file so this is what you don't want in order to fix a problem like this you can simply go ahead and delete these move these to the trash if you want to ultimately have xhood automatically generate them to you for you i mean you move these two files to trash go to product and then clean build folder make sure you remove any artifacts and then you can rebuild your project or if you want if you want to manually do it just set this to manual none but you cannot have a combination of having xcode automatically generated for you and have these existing in your exclude project all right so now for the last code gen option which is category extension when you have it set to this xcode is only going to generate this extension file for you automatically which means you can go ahead and delete this now this is sort of like a happy medium you can just straight up move it to the trash this is a happy medium because you still get this one file which you have to manually generate initially and then you go ahead and delete that category extension file but now you can add your custom logic in your custom methods and you don't have to make sure that the extension containing all of the properties is up to date with the model because having it set to a category extension for the code gen every time you build your xcode project it's going to generate that half of the class for you and right now i have an error probably because i didn't build my um build sorry clean my build folder as you can see it's still complaining multiple commands produce so i'm going to go back to product clean build folder and i know that having this code gen set to category extension and having this other half here if i press command b i'm going to get the full definition of my entity so i guess to sum it up manual is full control right you have to generate two files but you have to just make sure that it's like congruent with what you've defined here class definition is no control you don't get to add you don't get to modify the classes at all it gets generated behind the scenes when you build the xcode project and category extension is it automatically generates half of it for you and the other half you can customize the code okay so now we've defined our entities and attributes we've generated the classes now we need a reference to the core data persistent store well when you created this xcode project and you enabled use core data in the app delegate it's actually set up something additional for you down here you can see that now we have this persistent container property and this lazy keyword just means that it's not going to run all this code and create that container until you access it for the first time but this is your core data persistent container and it's a property in your app delegate so that's how you're going to access this persistent container as you can see here this name here maps to this core data this data model file right here all right so because this property is in the app delegate we can access it from any view controller or any other class in our entire project all right now let's go into the view controller and let me show you how to access the persistent container from there so we need a reference to the persistent container you can access the app delegate first by typing ui application i don't know about this one but this is how i would normally do it uiapplication.shared.delegate and you can see that it's optional here but the type is ui application delegate but we got to cast it as our app delegate okay and then now that it's our app delegate you can access the persistent container property right so this gives us access to that core data persistent container but if you remember from lesson one we don't interact with the core data persistent container directly we use the managed object context and in order to get a reference to that so that we can use the manage object context we just have to access a property on the persistent container called the view context you can see the data type for this is ns managed object context so this is actually what we need in order to store our data retrieve our data from core data and all of that but don't worry i'm getting a little ahead of myself because in the next lesson we're going to look at creating retrieving updating and deleting data through the managed object context for now i just wanted to show you how we can access the persistent container and also the managed object context now before we go into adding core data to an existing project i just want to show you one more thing in appdelegate because aside from this persistent container property there was also another thing down here called it also added this save context method and as you can see all this method is helping you do is it's getting a reference to the managed object context and then detecting if there has been any changes to the data and then saving right so it's just an easy way for you to save changes to your persistent container so you can do it by simply calling the save context method of the app delegate okay so when you start a new xcode project and you enable core data right off the bat you get the core data model file included and in the app delegate you have methods to access the core data persistent container and manage the object context now if you have an existing xcode project that you want to convert to using core data you won't have these things currently in your xcode project now let me show you how to add them so that you can use core data all right so now let's say you have an existing project that you didn't set up with core data so i'm just going to create a test project here and i'm going to i'm not going to enable use core data let's create that there and so let's say this is your existing project well all you have to do number one is add that data model file so go ahead and add a new file and under core data choose data model right and you can save this uh with whatever your name of your project is so i guess i'll call this testproject.xc data model and here you know you have your entities you're going to define your entities and attributes as normal also in appdelegate you'll notice that you do not have that persistent container property that i showed you and we don't have that save context method as well so you would just essentially add that code here but i don't really know that code by heart and i don't expect many people will so what i usually do is i create a brand new xcode project with core data enabled just to get that code and i'll copy and paste it in here so i can take that demo that we were just working on and i can copy this right that's the persistent container property but you have to make sure that this name right here matches that right so test project and that's the that's the core data data model file that you added and you also have to import core data at the top because otherwise the classes wouldn't be recognized right and then you can go back to your other project and just copy the saved context code over as well and it's as simple as that now the other thing is in an existing project you probably have your own model files already or your own model classes i mean you would have to redefine them as entities here along with their attributes and all of the relationships which a couple lessons later we'll talk about but you'd have to redefine all of those things and then regenerate the classes to replace your current model classes and then you would also have to alter the way that you get the data and in the next lesson you'll learn how to create retrieve update and delete data from core data so you're going to have to modify your existing project a little bit so that it uses that managed object context to fetch the data save the data and all of that stuff all right so in this lesson you learned how to set up your xcode project to use core data in the next lesson you'll learn how to create retrieve update and delete data from core data so i'll see you there hey code crew in this lesson we're going to continue our core data series and i'll show you how to create retrieve update and delete data from core data all right now let's jump into xcode all right so in this xcode project i'm going to show you how to create retrieve update and delete data from core data now i did set up a lot of the ui for this project and i'm only going to be focusing on the core data transactions bit and the reason for that is because if i showed you how to build the ui 90 of this lesson would have just been building ui with 10 being the actual core data bits which is the focus of this lesson so that's why i built it out but i'm going to walk you through the ui work that i've done so far and i'm going to show you where the missing core data bits are that we're going to fill out together okay so first of all what data are we working with here so back in lesson two and lesson one we were talking about a person entity same thing here person entity these attributes are the same which i've defined i've generated the uh actually before that i've set the code gen to manual and none that means i have to manually generate the sub classes and you can see that i have done that here so here's my class there's nothing in here and these are the properties mapped to the attributes okay so what does the ui look like if i go to the main.storyboard you'll see that i have a table view which i'm going to use to display all of the people in our database and then we have an add button up here which i'm going to show an alert or a popup with a text box where we can type in a name and that's going to add a new entry into our core data database we're going to be able to swipe each row to delete that person from the database and finally we're going to be able to tap on a row and pop up that alert again and be able to edit the name and then save it so that's updating data now i do want to mention that in this lesson i'm not going to explain how table views work and how you know a lot of this ui is constructed because we've gone through a lot of this stuff in previous lessons if you haven't seen those or you're still confused about table views and protocols and delegates and stuff like that and how the table view gets data from the view controller do visit my other lessons especially the 29 day beginner challenge which i'll link to i'll put a card up on the screen so let's dive into the view controller and let me show you some of the code we're going to do retrieval first i'm going to show you how the table view gets the data and then we're going to hook that up to core data so this items property right here this is the array of data that is powering the table view as you can see now it's not set to anything but that's where we come in and we're going to hook it up to our core data data so we're going to start at the top by getting a reference to the managed object context remember from the previous lessons i explained that you don't work with the core data persistent store directly there is a layer called the managed object context that you interact through to save and retrieve your data so how do we get a reference to this managed object context well inside the app delegate here you see this property for persistence container so we're going to get a reference to this which is going to give us the core data persistent container and there's a property on this object which gives us the managed object context so up here we're going to say ui application dot shared dot delegate and we're going to cast that as an instance of the app delegate and then we can access that property i just showed you called persistent container and then a property off of that called the view context this is the one we're looking for the ns manage the object context so we're going to keep a reference to that and we're going to call it context up there and that's going to make it easy for us to basically use the context to retrieve and save we're going to be using this reference a lot okay so down here in the view did load this is standard hooking up table view stuff there is this method here called fetch people and that's this method right here as you can see it doesn't do anything right now but we are going to fetch the data from core data to display in the table view all right so the way we do this is context dot fetch and you can see here that first of all it throws an error if it cannot fetch what you're asking it to fetch then it's going to raise an error so we do have to wrap this in a do catch block and handle that error but you'll notice that the other thing it accepts is a fetch request now we're going to start by putting in a very simple fetch request to say retrieve all of the people objects but in the next lesson we're going to take a look at other types of requests that you can do to sort and filter all right so let's choose one of these and let's choose this one right here i don't think it really matters right now and i pointed this out to you in lesson one or two but you can see here that it's got a a static or type method here called fetch request and this actually returns a fetch request for all of the person entities in core data so this is the method that we're going to call of the person class to generate a fetch request that we're going to pass into the managed view context so let's take a look at how that works so since it's a type method i don't have to declare a new instance of person i just go person dot fetch request like that all right so i'm passing in a request to grab all of the person objects in core data and we can either you know we can either do the try keyword like that to not care if any errors get raised or we can actually handle the error properly so you know we're going to do a do catch block like this and again i'm not gonna explain or cover this in depth right here since this lesson is sort of a little more advanced so essentially we are trying to uh trying to fetch this so we are going to assign the results it's going to be an array of person objects we're going to assign it to this property up here so self dot items equals we're gonna try so after all of the items get fetched then we assign it to this array we gotta tell the table view to um refresh or reload its data so that's what we're gonna do here table view dot reload data now i'm going to do this in the main queue because sometimes we're going to be calling this fetch people method from a background thread so the way we do that is we use dispatch queue.main.async and this is going to um because this is ui work when you reload the table view it's essentially going to fire all of those methods to grab the cells and stuff like that and that's ui work so we want to make sure that we're doing that in the main thread and just in case you're not sure about why it's really the main thread that should be updating and handling the ui when you start trying to do that from the background then a background process or thread then you might start getting performance impact or hits okay so just from doing that we should be able to see something because i do have a single person object inside core data right now so if i run the project you're going to see that it indeed goes to fetch data and we have one entry and it's just placeholder right now yeah just ignore that for a second the reason why it says placeholder is because for this self or row at method i just set the text of the label for that row to placeholder but we're going to i guess we could change that right now so we're going to get the person from the array uh let person equals self thought items and we're going to pass in index path.row and that's going to give us the person and then in here we're going to say person dot uh name this is an optional so i'm just going to force unwrap it and we'll grab the name so let's run it again and instead of placeholder text we actually see the name of the person object all right so now that's fetching data from core data it's as easy as that except that right now you can only fetch all of all of it you don't know how to sort of sort and filter but we're going to cover that in the future all right now for adding data how do we add data right now when we click this button i'm just popping up a popup to ask for the name of the person and we're going to create that new person object and add it to core data all right so that's this button handler right here add tapped so all i'm doing here is creating a new popup you can see here i'm adding a text field and then i am writing a submit button that says add right and when that add button gets tapped on so if we go back here you know they'll fill in a name like joe when this add button gets tapped on this is the code that's going to get run all right so how do we access the text in this field well the alert since we added a text field to the alert through this add text field method we can access the array of text fields like this alert dot text fields and we can access the first one because there only is one we only did this once right so that's our text field right here and here we're going to create a new person object and then we're going to assign the name and the age and the gender and stuff like that all right so let new person equals and we're going to try to create a new person object like usual by using these rounded brackets but you'll see here that because this is a subclass of ns managed object right that's what allows it to be saved into core data like we had talked about because that's the case you'll see that i have this option right here right to create this person object in a specific context right and accepts a parameter and let's manage the object context well we're going to pass in the context that self.context we're going to pass in this context up here right that's how we're interacting with our core data persistent container right so where was that code right here so just like that we've created a new person object in that context and now we're going to set some properties for it so newperson dot name is equal to text field dot text and this is that text field right there in the popup and for the age i'm just gonna set it to some arbitrary number same thing with gender but i assume that you would you would ask for all of this data you know when you're adding a new person okay so just creating a person object in the context is not enough to save the data you actually have to save it if you don't save it then the next time you run it you won't actually find this person anymore it doesn't get saved into core data so the way you save the data is through the managed object context so self.context dot save and that's simply it notice that this method also throws right so you can do you can you can wrap it in a do catch block and you know try to catch an error if there's a problem saving it so you have to put a try keyword in front of the throw method you can do this and try to catch the error if there's a save data error or you can simply not care if there are errors or not and do that if this were an actual app i would definitely try to catch all the errors and respond to and let the user know that there was an error in saving the data and all that all right so saving the data and then we have to refresh the table view because we've um all we've done now is create a new person object and we've saved it to core data but that doesn't change this array which the table view is reading off of right so i'm going to call the fetch people method right here self dot fetch people and just in case you don't remember about this fetch people method if i scroll up here it all it does is it hits the managed object context passing in a person fetch request to grab all of the people object back assigns it to this property which the table view is reading off of and then calls tableview.reload to reload the data and good thing that this puts it on the main thread because we're calling it from a background thread right here and this is a button handler from the submit button okay the last thing to do is add the button to the alert and then to present the alert so let's run this code and we should be able to add new objects to our database so let's say joe when i hit add what's going to happen it's going to create a new person object in our object manage object context it's going to save the context thereby saving the object into core data and then it's going to call fetch to fetch that data back from core data or fetch that fetch joe back from core data so add boom we got joe nice all right so now let's do delete so i i did this it's just a swipe action on the table view row it's actually very easy to do down uh where was it right here trailing swipe action so that's what we're configuring so we're going to create a new swipe action all it is is a ui contextual action and uh the style is destructive since it's going to be a delete function the title is delete and then here is the handler the code for what happens when you trigger that swipe action so first let's get a reference to the person object that we want to remove so let's person to remove equal self dot items all right and as a parameter it tells you which row was swiped on here so index path dot row okay that's going to give us the person to remove this is optional so let's unwrap that okay so now actually to remove the person and again we do these core data functions through the managed object context so self.context dot actually delete object and you just pass in the object so here we're gonna pass in person to remove and again you have to save or else it's not gonna take effect so view dot context dot save again it throws so you're going to wrap this in a do catch and catch that error if there was an error in deleting in the deletion save the data and then refresh the data here self dot fetch people all right so let's run this and test that out so let's delete joe delete so he's gone and if i rerun my app you'll see that we only have ted okay so we can add another person sammy to replace joe okay so now the last thing is did select row when we let's say select sami all i'm doing here is throwing up a popup same idea with the text field let's take a look at the code we have here did select row here i'm just getting the person that was selected through this parameter that that indicates which row was tapped on and then i'm creating an alert i'm adding a text field and i am getting a reference to that text field from here and i'm preloading the person's name all right the selected person preloading his or her name into the text field so that when when it brings up the text field we have the existing name in there already and then i configured a save button so you can see here the handler when that gets tapped that is where we are going to edit the name so the selected person we got a reference to it up there already dot name is equal to whatever name is in the text field now you know assuming that person did actually change the name and again save the data and then finally refresh refetch the data so let's run this code right now oh and the last thing i did was add the save button to the alert and then present the alert when upon tapping of a row okay so let's tap on sammy and let's save save sami as joe so now when i relaunch the app you can see that it's ted and joe so just to do a quick recap on all four of the operations we talked about in terms of fetching you call the fetch method of the managed object context and you pass in a fetch request now that could be a fetch request for all of the objects of that type or it could be one that's sorted and filtered upon which you'll learn in a future video in terms of inserting people or or adding new data what you do is you create a new object in the context right and then you call save and then for deleting you call the delete method of the context then you pass in the object you want to delete from core data and then you have to remember to save it and finally for updating you simply change whatever you want to change on that object and then you save it all right so now you learned how to create retrieve update and delete data in core data in the next lesson you'll learn how to sort and filter the results that you get back from core data all right i'll see you there hey code crew in the last lesson you learned how to create retrieve update and delete data from your core data database in this lesson we're going to learn how to filter and sort our data so that you can retrieve only the results that you want from your core data database now filtering allows you to only return the results that match a specified criteria while sorting allows you to return your results in ascending or descending order based on an attribute that you specify all right let's jump into xcode so here we have the xcode project that we worked on in the last lesson and just as a reminder in this fetch people method we were retrieving all of the person objects from our core data store through the managed object context if you remember we don't interact with the core data persistent store directly right we create retrieve update and delete data through the managed object context so that's what this variable refers to context.fetch and that fetch method is how we retrieve data from the core data store now you have to pass in a fetch request into that fetch method and this fetch request actually indicates what you want to retrieve you know how it's sorted what sort of criteria you have for retrieving the data in this particular case we wanted to fetch all person objects and so we just passed in a fetch request as is now where did this fetch request come from if you take a look we're calling a class method called fetch request on the person class so let's go into that and take a look at what it is let's go into this person class here as you can see here this is the fetch request class method and what is returned from this method is a new nsfetch request object and the data type of the data returned is set to the person right and that is what gets returned right and so it's essentially going to fetch all person objects in order to filter and sort we actually have to set some properties on this fetch request before we pass it into this fetch method so why don't we instead of putting in the fetch request here let's declare a variable or constant up here and move this line of code and just have the fetch request up here right and then we're going to set the filtering and sorting on the request and then we're going to pass the request into the fetch method now you're going to get an xcode error as you can see here ambiguous use of fetch request so you actually have to indicate the type that this is an nsfetch request and the data type that it's going to return is person so now that we have a reference to the request up here let's take a look at how we can do filtering first i'm going to run the project so that we can see what data we're working with and so we can decide what data we want to filter for so as you can see we have four names here i am going to just do a simple filtering for only person objects with the name ted all right so let's go ahead and stop the project now to filter based on some criteria we use this class called ns predicate which lets you define different sorts of conditions in a very easy to understand sort of text manner you'll see right here so let i'm just going to call it i'm just going to call it pred equals ns predicate and we can define we can use this one or we can define a format and pass in the arguments so because we want to define criteria based on the name property of the person class let's take a look here so you see it's got a name property that's where you saw the ted the joe the abbey the mic so i'm going to specify this string where i'm going to say the name property contains ted like that and you have to put this criteria here in single quotes and then we have to add this predicate to a property on the request so the fetch request actually has a property called predicate where you can pass in the criteria that we just defined and just like that if i run it now it's going to only return person objects where the name contains ted and i will show you a couple of different examples of sort of what you can filter on in a second and how you can combine different things and use different operators here so let's run the project to quickly see what we have so as you can see here it's only got the person ted now now you saw earlier how i was configuring this format and there was a second parameter because typically the thing that you want to filter on may be dynamic right this you might not know this beforehand so you can't actually code it in like i have now so in that case what you do is you put in a sort of wildcard character and that is defined by percentage at and then you can do comma here and then you can specify whatever variable contains the thing that you want to filter on now i don't actually have a variable to indicate what i want to filter on so here i can just put an example as a string but if you had something that you wanted to filter on you can specify a wildcard in your criteria and then indicate that dynamic variable here now let's take a quick look at some other ways you can define your criteria using ns predicate so here i have the apple documentation for the ns predicate class there are some common examples i'll go through with you in the overview but there's also a detailed guide that you can go through called the predicate programming guide i'll provide all these links below the video this guide if you want to really dive deep into how you can express your queries using ns predicate definitely take a look now some of the more common examples are contains which is the keyword we just used there's also equality with double equal signs and you can use like here's contains you can ignore case and diacritics which are the accents on top of letters if you want to ignore both of them you just put a angle bracket and sorry square brackets and you put cd to ignore both or just c or just d to ignore these respective things you can also combine different conditions together just like an if statement using or and and and there are different keywords to express time and you can use math inequalities like less than or greater than and so on and so forth so definitely give these things a look if you are trying to express some sort of query and you're not finding the right way to write it i'm sure a quick browse through this predicate programming guide will give you some insight on how to express that query again links to these documents below the video all right now let's take a look at sorting now similar to how the ns predicate class is used to define your criteria for how to filter the ns sort descriptor class is used to indicate how your results should be sorted let's go ahead and create an ns sort descriptor and indicate that the names should be sorted in alphabetical order now let's take a look before before we do that let's just comment out this predicate and i'm gonna run the project again so that we can see how it's sorted naturally first so you can see here it's joe ted mike and abby and it's it's not an alphabetical so i'm going to want to sort it in ascending order so let's go ahead and create a new sort descriptor ns sort descriptor and as you can see here again you sort by a particular attribute or in this case they call it the key and we're going to specify ascending is true or false so i'm going to sort by name and i'm going to say ascending is true and now just like with the predicate we have to set it to the request so request has a property called sort descriptors and if you take a look at the type it's actually an array of sort descriptors the reason for this is so that you can specify multiple levels of sorting for example a list of names is usually sorted by last name but however if two people have the same last name then their first name is used to determine who comes first so in this case since we only have one sort descriptor we still have to pass in an array however it can be an array of just our single sort descriptor like that all right now i'm going to run the project and you'll see that it's going to be sorted by name in ascending order as you can see it's abby joe mike and ted now before we end this lesson i want to point out a few more useful properties of the nsfetch request class that you can use to customize your fetch for example you can limit the number of objects that you return using fetch limit you can also start the result set from a certain offset such as this property right here and you can choose to only return specific properties of the objects and much much more so i'll link to this article or documentation below the video alright so in this lesson you learned that you can customize certain properties of the fetch request before passing it into the fetch method of the managed object context specifically you can specify a predicate using the ns predicate class and you can specify sort descriptors using the ns sort descriptor class alright i hope that was helpful in specifying how your objects get returned from core data in the next lesson i'll show you how to specify relationships between your different entities in your data model hey code crew in the last lesson you learned how to filter and sort your data using the predicate and sort descriptor's properties of the fetch request in this lesson you'll learn how to specify relationships between your core data entities alright let's get started if you remember in lesson one of this core data series i showed you a diagram that illustrated what an object graph is we had the person objects and a family object and the family object held an array of person objects we're going to recreate this relationship in our data model let's go into xcode so here's the data model for our core data entities and the first thing we're going to do is to add a family entity so go ahead click add entity and let's change this entity name to family the other thing we're going to do is let's just add an attribute called name and change it to string finally here's the part where we define the relationships between our different entities so we're looking at the family entity right now we're going to hit plus under relationship and we're going to name this relationship and what ends up happening is it's going to be a property just like these attributes are so i'm going to call this people and it's going to essentially store all of the person objects that's part of this family so the destination is basically the data type i'm going to choose person and inverse here there's nothing to select for now but we're going to talk about that in just a second so first of all let's go over to the attributes section of this relationship and specify the type and change it from 2 1 to many and that means that this people property can store multiple person objects essentially it's going to be an array of person objects now let's go over to the person and we're also going to specify a relationship here but in the inverse so it's going to define that a person belongs to a family so under relationship hit plus again and for this property i'm going to call it family and the destination is essentially the type of this property it's going to be family and for the inverse if you pull this down now you're going to see that there is an inverse and this is that relationship that we defined here right in the family entity so that's what we're going to want to select and then if you go back to the family entity under this relationship you're going to see that this inverse has automatically been set for you right and you can specify that the inverse of this relationship is the family property of the person object and the reason we specify this inverse is so that core data can maintain the data integrity of our object graph even if you're not going to use the inverse for example you know you want a family object to hold multiple references to different person objects but you don't really care that a person object has a reference back to the family object you should still specify this inverse relationship in your data model again this is something that apple recommends that we always specify this inverse relationship so that it lets core data maintain the integrity of the data all right now that we've specified this simple relationship between our family and person entities let's go ahead and regenerate our our classes actually i forgot for this family entity i'm going to set it to manual code generation as well just like i have for the person and since it's set to manual that means we have to regenerate these classes every time we make a change now first of all i'm going to go ahead and delete my existing person class because as you can see it doesn't account for that relationship that i just added so let's go ahead select both of these and choose delete and move it to trash now i'm going to choose editor and i'm going to choose create ns managed object subclass select the data model make sure that my entities are selected the ones that i want to generate the classes for hit next and let's just save it right there now i'm going to drag all of these into my model group so one of the first things i like to do after generating these classes is press command b just to make sure that everything builds successfully and if you get a failure sometimes it's just because xcode's detecting some artifacts that should be gone in the build folder so what you do is go to product and hit clean build folder and that will usually do the trick and you can press command b and build it again just to make sure that everything is fine and also sometimes xcode won't detect your new classes and you'll get some weird autocomplete errors and you'll see some xcode errors even though you can run the app successfully if that happens to you usually quitting xcode and restarting it will do the trick and that's what happened to me the first time i was working with this so i just thought i'd mention it now what i'd like to do is just to review the classes that were generated and point out some of the differences to you based on what we edited in the data model so taking a look at this person class now we have a family property you can see that the data type is family so this is a reference from the person to the family the inverse if we go to the family class you can see that here's the name attribute that we specified and here's also the people relationship that we specified the data type is actually an ns set it contains a set of people but take a look at this down here there are a couple of methods so there's two methods it's called the same thing add to people but this is allowed because the the signature is different all right the the parameter that you pass in is different one is for adding a single person object to that set here and this one is if you want to add you know multiple person objects to this set same thing goes for remove remove a single person or remove a set of people now i think you can guess that it's pretty straightforward to specify this relationship and that's why i didn't really modify the user interface of our existing demo app to accommodate families and to specify relationships between people and families because the work that it would have taken me just to create that all of that new user interface it's much faster for me just to demonstrate to you and show you the code for you to create a couple of these entities specify the relationships and save it to our core data database so let's go ahead and do that i'm going to go into our view controller and maybe i will um i'll just do it in in a random method here because i don't want to i don't want to confuse you by writing it in some other method so i'm just going to say uh relationship demo and just create this new function here or a new method here for us to write this code so let's create a family create a person and then lastly we have to remain remember to save save the context okay so let family equals so we're going to create a new family object in our managed object context so that's the context we want to create it in and why don't we go ahead let's set that to var actually because i want to change the name let's call this the abc family and let's create a new person in this context as well and oops let's set the person's name to maggie okay so how do we specify a relationship between the family and the person well there are actually two ways you can do it because we actually have relationships or properties pointing both ways so very simply you can set the family property of the person to this family up here and just like that you've specified that relationship um after you do that when you try to access family dot people you'll find that maggie is actually in that set right and you're gonna have to save it so context dot save so that's the first way you can specify the relationship and as you can see super easy the second way you can do it is by using those methods that i showed you see add to people and obviously you probably have to do this down here you pass in the person and actually we can use let for this and so that's the second way using any of these two ways to specify relationships between your objects and building your object graph like that after you save it to core data and you bring it back those relationships will get maintained right so if you bring back this family you'll be able to um look through the people and find maggie and likewise if you only bring back maggie from a core data fetch you're going to be able to access this family object through the person.family property like that all right so that's the end of the core data series for now you know just enough to start applying this knowledge and using core data in an app now having this core data knowledge is already going to open up a lot of app possibilities and ideas that we can build together on this channel if you don't want to miss it please make sure you're subscribed to the channel by hitting that red subscribe button below and lastly if you enjoyed this series and you learned something new please give this video a thumbs up it really helps with the youtube algorithm and getting exposure for this series finally i'll leave you with this what kind of app are you going to build with these newly found core data skills let me know by leaving a quick comment below alright i'll see you in the next lesson
