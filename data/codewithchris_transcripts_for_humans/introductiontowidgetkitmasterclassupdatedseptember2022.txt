With timestamps:

00:00 - learn how to add a widget extension to 
an existing app including reusing service  
00:05 - classes building uis for different size classes 
and scheduling widget updates through a timeline  
00:13 - hey called crew this is floor i've been developing 
ios apps since 2016 and i've been working on many  
00:19 - different widgets over the past few months so 
i'm super excited to teach you about widget kit  
00:24 - in this series this is lesson one where i will 
show you examples for great widgets by apple  
00:30 - the current project setup and the example app 
that i have prepared for you next we will add a  
00:35 - widget extension and go through everything that 
xcode automatically generates for us let's get  
00:41 - started with some examples of grade widgets so you 
understand how all of this works how the ecosystem  
00:46 - works and how they are built up so there is this 
great article from the apple developer website  
00:52 - which is linked in the description which just 
gives a brief introduction to widget kit and i  
00:57 - just want to show you a few of the examples that 
they have on their website here they have the  
01:01 - little calendar widget they have a weather widget 
news music also for the activity app and so on  
01:12 - then there are a bit larger widgets for the 
ipad with photos and a bigger calendar view  
01:19 - but one thing that unites all of them is that they 
have at a glance information so you for example in  
01:26 - the calendar widget you only have the next two 
events showing so when you have a glance at the  
01:32 - widget you immediately know what it wants to show 
you and what information is there same for the  
01:37 - weather widget you just have a quick look at it 
and then you instantly know the temperature and  
01:42 - the current weather conditions there are also 
some more widgets that i want to show you that i  
01:46 - have personally worked on the first one is a food 
tracker app which is based around a medium sized  
01:53 - widget that you can see in the screenshot in the 
middle here and the idea is basically that you can  
01:59 - track your meals through a widget where you can 
just tap either on the healthy or on the junk  
02:04 - side of the widget the app will open up and all of 
your meals will get locked that way so there's a  
02:11 - tiny bit of interactivity here but i will tell you 
more about that in just a second and then there's  
02:16 - also another widget that i made for a swift ui jam 
a few weeks ago which is an almost fully working  
02:23 - calculator widget so we can watch the video here 
it looks just like the calculator app from your  
02:30 - iphone but then you can tap on the numbers and 
on the operators the app will briefly open up  
02:36 - close back down again and then you will see 
your calculation and the end result inside of  
02:41 - the widget i think this is very cool obviously 
this is not what apple intended widgets to be  
02:46 - but there you can just see what's possible 
with the technology so getting back to widget  
02:51 - kit itself widgets are built entirely in swift ui 
so it is not not possible to pull the ui kit for  
02:58 - example via ui view representables or your view 
controller representables currently you can only  
03:04 - use swift ui to build out the ui side so what's 
displayed inside of the widget as i said the main  
03:11 - idea is to provide at a glance information these 
are just tiny portions of the screen the widgets  
03:16 - are based on a timeline so you the developer can 
provide a timeline scheduled with timeline entries  
03:25 - that all have an associated date and some data 
associated as well so you can for example schedule  
03:32 - a timeline over the next five hours where 
at every full hour there is a timeline entry  
03:38 - and then ios or ipad os or even mac os whichever 
system your widget is running on will execute  
03:45 - that timeline and refresh the widget by itself so 
you are not guaranteed to have the widget refresh  
03:50 - at exactly the time in your timeline entries 
that you have specified but the system handles  
03:57 - it and the system also has some limitations 
for example you cannot refresh your widget  
04:03 - a few hundred times per day there are just certain 
restrictions there set by ios but most users will  
04:09 - never notice this and for most users the widgets 
will always stay up to date we will have a look  
04:14 - at the timeline the timeline entries and so on in 
partially in this but mainly in the next lesson  
04:20 - and then one last very important thing when 
talking about widgets is that you understand that  
04:26 - they are static ui so there are no animations 
there are no videos there is no navigation  
04:32 - and there are also no buttons the only dynamic 
thing that a widget can do is link into your  
04:40 - main app and pass in some data there we will have 
a look at that in the third lesson of this series  
04:47 - but until then you can just assume that a widget 
is more or less a very static view okay to get  
04:55 - us started a bit quicker i have already prepared 
a very simple example app this is a simple to-do  
05:01 - list app based on the json placeholder api you 
might have already seen the json placeholder api  
05:07 - if you want to have a more specific look at 
it it will be linked down in the description  
05:12 - it's a very generic api with some yeah as the 
name suggests placeholder json data for users for  
05:19 - posts and so on but we're just using the to do's 
route which you will also see in just a second  
05:24 - so the main app only has a single view which you 
can see here on the right hand side if i press  
05:29 - play then all of the to do's will be loaded 
you will have a list here with the to do title  
05:37 - on the left hand side and then the statues whether 
it's completed or not on the right hand side so  
05:42 - some of these to-do's are open some of them are 
already completed and if we tap on a to-do item  
05:49 - here a little sheet will come up telling us 
the id of the to-do then once again the title  
05:55 - and whether it's open or completed and then you 
can of course dismiss the sheet like always okay  
06:01 - so let's briefly go over the content view here 
so you understand how this all was built and  
06:06 - then we will have a look at our data class or to 
do and then also our service class so first of all  
06:14 - as you can already see we have a navigation title 
here so we must also have a navigation view which  
06:19 - surrounds everything in our content view here and 
then mainly we just have this single list here  
06:26 - the rest of the code is just view modifiers but 
we mainly have the single list here iterating over  
06:33 - all of the to do's which is a state variable here 
in the beginning this is an empty array of to do  
06:40 - but later on i will show you how this gets filled 
and then inside of the list we just have a simple  
06:46 - button for every row the button action is to 
set the selected to do which is another state  
06:53 - variable to the to do of this current row so for 
example if i tap on the first one then that will  
06:59 - will be the selected to do which is used for 
our sheet here at the bottom this has the  
07:06 - item initializer where you can pass in an 
optional identifiable item in our case our  
07:13 - selected to do state and if that is not 
nil so if there is some to do selected  
07:19 - then the sheet will show up and show just a simple 
group box here i think this is not too important  
07:25 - this is just for demonstration purposes if we 
dismiss the sheet again we have our list again  
07:31 - and then inside of the list button there is just 
a simple attributed string which is brand new in  
07:36 - ios 15 where you can use some parts of markdown to 
for example bold a region of text so here you can  
07:44 - see these double asterisks before and after the 
completed or open text which we just bolded as i  
07:52 - said this is attributed string stuff not important 
for this series i just wanted to include it to  
07:57 - make it look a tiny bit nicer since this is a very 
plain ui okay let's continue down so we already  
08:03 - have covered the navigation title it's just my 
to-do's and now the interesting part comes so  
08:09 - um for our to-do servers i have chosen to use 
the new script concurrency features if you want  
08:15 - to learn more about that there is also a series 
about such concurrency made by stuart lynch  
08:20 - um so it will probably also be linked down below 
you can go there after this video or if you have  
08:27 - any understanding issues then you can just 
go there and have a look at it but i think  
08:31 - it will be pretty straightforward basically what 
we're doing is we're attaching a task to the list  
08:38 - task is very similar to on appear 
so the code in here gets executed  
08:43 - the first time that the view appears but 
you can execute a synchronous code in here  
08:50 - so we will have a look at how that works in just 
a second but bear in mind so this task will get  
08:54 - executed one time at the beginning and everything 
in here is happening asynchronously in a  
09:00 - background thread or can happen in the background 
it can also happen in the main thread depending on  
09:06 - how it is scheduled internally and all that this 
task does in this case is call our to do service  
09:12 - dot get all to do's function which calls the json 
placeholder api gets back all of the to do data  
09:19 - and then puts it into our to do's state variable 
up here which will then be used inside of the list  
09:28 - okay and then the last modifier here i already 
told you about the sheet so i think this should  
09:33 - be pretty clear now let's move on into the data 
folder on the left hand side here so first of all  
09:40 - we have our struct to do it's important that 
this had this conforms to two protocols the  
09:45 - first one is decodable so we can decode it from 
json which you will see in a second in the to-do  
09:50 - service and the second protocol is identifiable 
so we can iterate over it in our swift ui list  
09:58 - this just has four very simple attributes the 
user id the id of the to do the title of the to do  
10:07 - and whether the to do is completed or not let's 
jump real quick into the json placeholder api and  
10:14 - let's go to the endpoint that we're using which 
is slash to do's and here you can see where this  
10:20 - data is coming from so this is just a json file 
sitting on the server and there you have um all  
10:27 - of the same fields that i just showed you in our 
to-do structs so you have the user id which is an  
10:31 - integer the id which is an integer the title which 
is a string and then completed which is a boolean
10:41 - okay and then the last file that i have prepared 
is the to do service here this is just a very  
10:47 - simple helper class to fetch all of the to-do's 
from the json placeholder api since there is no  
10:53 - need to instantiate a new to-do service every 
time that we use it i just added a static shared  
11:00 - instance here so we can always just say to do 
service dot shared instead of instantiating a  
11:05 - new to do service we have our base url which is 
just the address of jsonplaceholder.typeycode.com
11:14 - and then it gets a bit more interesting 
with these three functions here  
11:18 - the first one is a very generic networking 
function that you can use in any of your  
11:23 - projects really but the important thing is that 
it is built using the swift concurrency features  
11:30 - so let's have a brief look at how that works 
so inside of the function we first have  
11:36 - or we first construct our url so when we call this 
function we pass in an endpoint for example todos  
11:44 - and then the function will generate a url 
for us so in this case it would be https  
11:52 - colon jsonplaceholder.typeycode.com slash 
and then here it would be for example to do's  
12:01 - so this will be the endpoint we constructed here 
this can fail so if in case it fails we will just  
12:06 - throw a url error of that url once we 
have our url we can use the url session  
12:14 - dot shared dot data function which is similar 
to data task or data task publisher if you were  
12:20 - using combine previously this function 
just creates a or takes the shared url  
12:26 - session goes to the url that you uh handed over 
and then fetches all of the data from that url  
12:34 - this is an asynchronous task so you have to 
wait for the results to be coming in and this  
12:42 - can actually also fail or throw an error and hence 
we need to try to await the data from this url  
12:51 - this function actually gives back both data and 
a url response so in your app you might want to  
12:58 - check the url response for the status code 
or any info that the server gave back to you  
13:03 - in our case we don't care about that so we can 
just omit the second value of the tuple here  
13:08 - the url response by using the underscore and we 
will just unpack the tuple into our data variable  
13:16 - and then the last step is pretty straightforward 
we just construct a json decoder and then we  
13:22 - decode our to do in our case from the data now 
the interesting part here is and hence the name  
13:30 - generic helper function we have some 
generics here so we have a generic type t  
13:36 - which basically means that we could use this 
fetch function to fetch any type of data  
13:41 - we could also fetch some users or whatever as 
long as that struct is decodable as the generic  
13:49 - condition here says so let's see how that works 
i have two endpoint functions basically the  
13:55 - first one is to get all to do's from the json 
placeholder which once again is asynchronous  
14:02 - and can throw arrows but this one 
will return an array of type to do  
14:07 - and this will basically just call our fetch 
function up here from the to-do's endpoint  
14:14 - so basically just the one that i showed you in 
the browser a minute ago as you've already seen  
14:19 - the fetch function is asynchronous it can throw so 
we need to try to avoid the result of the function  
14:26 - since we are using generics here we need to 
explicitly specify the type that we want to  
14:32 - get back so in this case if we want to get all to 
do's we want an array of type to do and then we  
14:39 - just return the result of the fetch function 
and then very similar for the last function  
14:46 - which is called get to do with id we can use 
this one to get the data for a specific to do  
14:53 - which we're using for the sheet for example this 
function returns a single to do instead of an  
15:01 - array of to do's and it's basically the exact 
same from before so we need to specify the type  
15:07 - over here since we are dealing with generics 
and then the only thing that we're changing  
15:12 - is the end point so now we're not querying for 
all to do's recurring for todos slash our id  
15:18 - and if we look at that in the browser so 
here we have slash to do's and now we say  
15:23 - slash one for example this will give us just the 
first to-do item okay so now that you have seen  
15:30 - the sample app that i have already created for 
you let's do the last thing for this video which  
15:36 - is adding the widget extension to do that it's 
also very very simple since xcode does almost  
15:41 - everything for you you just go to file new 
target and then in here you can either scroll  
15:50 - through all of the extensions or you can just 
filter for widget extension double click it  
15:58 - then give it a name so in our case i 
will call it widget kit course widget  
16:08 - make sure to uncheck include configuration intent 
that is something that we're not doing in this  
16:13 - series configuration intent can basically be used 
for siri it can be used for the user to customize  
16:20 - your widget but this is not important for the 
series once you're done just hit the finish button
16:28 - and here you can say activate the scheme if you 
want to which what this does is basically it  
16:34 - changes the theme up here in xcode so once you 
have an extension you can select when you're  
16:40 - running your app which scheme you want 
to run so you can then either run your  
16:43 - main app in the simulator or just run 
the widget extension in your simulator  
16:49 - for now let's just say activate if 
you want to change this later on  
16:52 - you can just go up here and select either 
your main app or your widget extension  
16:59 - okay and then on the left hand side here 
you can see that a new folder was generated  
17:04 - which is called just what we entered 
into the text field if we open that up  
17:09 - there's just three files a basic info.plist 
file an asset catalog that you can use to  
17:15 - provide assets like images and then there is 
the widget kit course underscore widget file  
17:21 - this file contains all of the auto generated code 
from xcode let me go over the extension and tell  
17:28 - you a few words about each of the different 
types that got generated and actually let's  
17:33 - start at the bottom here so first of all same as 
in swift ui which i just closed there is also a  
17:40 - preview available for your widgets i'm closing 
this right now so we have a bit more space  
17:46 - by the way to open and close that canvas you 
can press command option enter and then there  
17:53 - is something that you're probably already familiar 
with if you have worked in swift ui before  
17:59 - because there is now this add main widget 
struct this is actually super similar to the  
18:06 - admain abstract in your normal app where you have 
a body in which you just present your content view  
18:13 - inside of a window group in this case but it also 
has the add main attribute which basically tells  
18:20 - the device this is the entry point to the app 
start here and then it's the exact same thing for  
18:26 - your widget this add main attribute will just tell 
the device this is the main starting point for the  
18:32 - widget called this and then you're good to go 
so of course this is not an app this is a widget  
18:39 - and it also has a body the body has the generic 
type of or the opaque type of widget configuration  
18:48 - you can have there are basically two different 
types of widget configurations the first one  
18:53 - is a static configuration which we are using in 
most widgets actually use a static configuration  
18:58 - and there is also an intent configuration which 
you can use if you want to let the user edit the  
19:04 - widget directly on the home screen not important 
for this series but just so you know there's two  
19:09 - different types of configurations and then into 
the configuration you just pass basically an  
19:15 - identifier of the widget which is defined up here 
by default this is just the name of your widget  
19:22 - extension target you can change this of course 
especially if you add multiple widgets to your  
19:28 - app later on and then into the configuration 
you also pass in a timeline provider we will  
19:34 - have a look at that in just a second inside of 
the configuration you then have your actual view  
19:39 - now this has a very long and complicated 
name we would change that also in a minute  
19:45 - and into that view you pass in your timeline 
entries if you recall in the beginning of this  
19:50 - lesson i talked to you about you can schedule a 
timeline with different timeline entries for set  
19:57 - dates which in turn contains some data that 
you can pass to your view and basically these  
20:03 - timeline entries here come from your timeline 
provider and get passed into your view over here  
20:11 - you will see this more concretely in just 
a second you can also customize your widget  
20:16 - configuration by for example giving it a display 
name which will then show up in the app library  
20:22 - and you can also give it a description 
okay let's scroll up a bit here  
20:28 - the next struct that got auto generated is the 
actual view this view gets passed in a timeline  
20:36 - entry which is that piece of data that's scheduled 
through your timeline and then this example widget  
20:43 - here that gets auto-generated just shows some text 
of the current date of the entry so nothing very  
20:50 - special here and then the entry actually doesn't 
contain any data right now we will customize this  
20:57 - in the next lesson the only important thing here 
is that your entry conforms to the timeline entry  
21:04 - protocol which requires the entry to have 
a date property and then up here the most  
21:12 - important and most interesting part of widgets 
is the timeline provider so all of this over here  
21:20 - the timeline provider is responsible for 
scheduling your timeline entries for your widget  
21:27 - over time for the next couple of hours for the 
next day or even weeks however long you want to  
21:32 - schedule it there are three main functions 
functions that you need to implement here  
21:38 - first of all the placeholder function this is 
used when the user is selecting your widget in  
21:44 - the widget gallery on their actual device then 
there is the get snapshot function which just  
21:51 - gets back the current version of the widget with 
just a simple timeline entry or just a single  
21:57 - timeline entry and then there is the get timeline 
function which you can use to schedule a timeline  
22:04 - for your widget including when it will refresh 
how often it will refresh and which data it will  
22:09 - show the very last thing for this video will be 
taking all of these different structs and moving  
22:17 - them into their own files to make it a bit easier 
to read and to understand what we're working with  
22:23 - so over here in our widget folder we will 
add a new file and call this one provider
22:32 - and now a very very crucial detail when you 
create this file is that it needs to be in the  
22:39 - widget target and not in the app target now 
you can hit create and in here let's import  
22:46 - widget kit and then let's move our provider 
our timeline provider from the generated file  
22:56 - into this new file and let's do the same 
for the simple entry and the view as well
23:05 - so create new file swift file let's 
call it simple entry make sure that the  
23:12 - widget extension is checked here hit create import 
widget kit and then copy over our simple entry
23:24 - just like this and then one last time for 
our view here so let's hit command n new file  
23:33 - let's call this widget view hit create here 
we need to import both widget kit and swift ui
23:44 - let's copy over this struct over 
here and move it into this new file  
23:53 - and then we can also command click on it and 
say rename and then rename this long name  
24:00 - to just widget view let's also remove this 
space here let's copy the name and make sure  
24:08 - that it was renamed everywhere so for example 
for some reason xcode didn't rename it over here  
24:14 - so let's get rid of these old names and 
replace them with the new shorter name  
24:20 - in this lesson you learned about what can be 
done with widgets and how they are internally  
24:24 - structured you saw that a widget is based 
on a timeline and timeline entries which  
24:30 - get displayed in a plain old swift ui view learn 
about different size classes building a widget  
24:37 - ui and deep linking into your app in this lesson 
hey code crew this is floor in the first lesson  
24:45 - of this widget kit course you learned about how 
widget kit works under the hood how widgets are  
24:50 - refreshed and everything that xcode automatically 
generates for you in lesson 2 we will have a look  
24:56 - at building uis for different size classes and 
deep linking into the main app from the widget  
25:03 - let's get right into it so we're starting in this 
lesson right where we left off in the last lesson  
25:10 - and actually we don't need the content view 
what we need is our widget definition here so  
25:16 - i already told you in the first lesson that there 
are different size classes that your widgets can  
25:20 - have so that's the first thing that we will 
have a look at in this lesson to have a look  
25:26 - at the size classes configure them and tell the 
system which size classes your widget supports  
25:31 - you can just go to your static or your intent 
configuration basically just widget configuration  
25:36 - and then there is a very simple modifier called 
supported families here you can just pass in an  
25:42 - array of all of the widget families that you 
want to support one note though is that the  
25:47 - system extra large family is only available for 
ipad apps since it cannot even fit on an iphone  
25:55 - for this lesson we will focus on system medium 
which is basically two rows of apps at full width  
26:03 - and also system large which is two which is 
four rows of app so almost the entire screen  
26:11 - taken up by that widget while we're added 
let's also change the configuration name  
26:17 - to my to-do's and let's also change the widget 
description both of these strings are shown in the  
26:26 - widget preview when the user wants 
to add a widget to their home screen  
26:29 - so for example here for a description we 
could we could say view your latest to-do's  
26:38 - just like this okay so now we have told the system 
that our widget supports both the system medium  
26:45 - and the system large widget family but now we have 
to actually implement both of these size classes  
26:52 - and what we will do is we will switch on the size 
classes that we can reach from the environment  
26:57 - and then provide different views to the widget 
based on which size class is currently selected  
27:02 - for that there is an environment value that 
we can read so just say add environment  
27:09 - and then the key path is widget family and this 
way we can basically read the size of the widget  
27:19 - and what we can now do is just switch over 
this because it's an enum you just saw us  
27:24 - set it up here in the supported families 
modifier just switch over it and then  
27:29 - present different views so here let's remove 
the text and let's say switch widget family
27:38 - and now we're only interested in two cases because 
we only support system medium and system large so  
27:44 - let's say dot system medium and let's also say 
dot system large and as always a switch must be  
27:53 - exhaustive in swift meaning that either we have to 
cover all of the cases individually or we need to  
27:59 - provide a default case in the end that should 
happen if none of the other cases holds true  
28:08 - in our case or in in a place like this the default 
case will never be executed because we told the  
28:16 - system that we only support medium and large but 
nevertheless we need to provide a default case  
28:22 - so let's just say not implemented here and then 
we can forget about this for the system medium  
28:29 - and the system large cases we will now 
implement widget uis so i will just hit  
28:36 - command n say new swift ui file and 
let's call the first one medium size view
28:46 - make sure that it's a member of the 
widget extension and not of the main app  
28:50 - hit create and then let's do 
the same with a large size view
29:01 - for both of these let's move them into a  
29:04 - group over here in the widget just so we can 
separate everything so let's call this group  
29:09 - views and in here let's move our widget view 
our large size view and our medium size view  
29:17 - okay let's close these and open them up again 
let's start with the medium size view first of all  
29:26 - we will want to receive a timeline entry the one 
that our widget view already got from the timeline  
29:34 - and we will want to forward 
that into our medium size view  
29:38 - so to work with timeline entries we need to import 
widget kit and then over here we just need to say  
29:46 - we want to take in an entry and we can either 
say provider dot entry or we can just directly  
29:52 - tell code to type which is simple entry let's 
do the exact same thing for the large size view  
29:59 - so import widget kit and then let's 
add a var entry of type simple entry  
30:10 - and actually since we're inside of widget kit we 
don't even need the previews here so we can just  
30:14 - scrap them from both of these views that 
way xcode won't complain about any issues  
30:20 - and now we can already start to add both of these 
views into our widget view so for the system  
30:26 - medium let's just say medium size view with our 
entry and then also large size view with our entry  
30:37 - okay for the medium size view we will now start 
to implement the ui and for that i want to show  
30:42 - you a pretty neat trick how to have at least 
a decently looking ui up pretty quick for  
30:48 - that we will use a group box with a label so a 
group box is basically just a wrapper around a  
30:55 - bunch of views that groups and up and puts them 
into a box with some sort of grayish background  
31:00 - and with the label initializer here we can pass 
in a label with a title and an image in our case  
31:09 - we will use a system image the title will be my 
to-do's and the system image will be list dot dash  
31:19 - and now inside of the group box we can put 
our actual ui so in our case we will have  
31:24 - an h stack here with first an image of a person 
for that we will use um the sf symbol for person  
31:34 - let's make that resizable let's make that scale to 
fit and let's also give that a foreground color of  
31:41 - secondary so um so a nice grayish touch then let's 
add a little divider so in case you didn't notice  
31:51 - you can place dividers in v6 but also in h 
stacks and if you place them in h6 then they  
31:56 - will be just a vertical line and then in here 
let's add a little v-stack where we can display  
32:05 - the contents of one of our to-do items 
let's give this a leading alignment
32:13 - like this and then in here we will have two 
text elements the first one with the to-do title  
32:20 - right now we will just have some placeholder 
content here because we will fill out the  
32:25 - timeline provider in the next lesson let's 
have this text as a headline font so give  
32:32 - this the font of dot headline and then below 
our title we will have whether it is completed  
32:39 - so here i will just say completed for now we 
will fill this with a tiny bit of logic in the  
32:44 - next lesson as well and then here we'll just say 
this is a sub headline like this at the end let's  
32:52 - also add a spacer so everything is aligned 
nicely and then let's also add some padding  
32:58 - to the edge stack so nothing cuddles with 
the edges of the widget i would say okay  
33:04 - that's the medium size view already done for this 
episode now let's move on to the large size view
33:11 - in here let's also remove the text 
and let's replace it with a v stack
33:19 - basically what we want is we want to have kind of 
like a notepad feel to this widget you already saw  
33:25 - it in the first lesson how it will look in the 
end and let's implement that right now first of  
33:29 - all there's this little header row at the top 
i will give that a spacing of 16. and in here  
33:38 - let's add a little title called my to-dos 
then let's add the current date so date.now  
33:48 - with the format of date time this is a very handy 
text initializer here where you can pass in a  
33:56 - date and then it will be formatted nicely and 
then let's push all of that to the leading edge  
34:03 - to format this a bit nicer let's give it eight 
points of padding let's give it a blue background  
34:12 - let's give it a white foreground color to 
have a nice contrast to our blue background  
34:18 - let's clip all of this so it's handled as a 
single view because now we will apply a shadow  
34:26 - with a radius of 5 points if we were to not apply 
the clip modifier like this then the shadow would  
34:34 - be applied to each individual sub view of our age 
stack but we only want the shadow once for the  
34:40 - entire hdac so we need to clip everything into a 
single view okay next up we want to display a list  
34:48 - of all of the currently open to do's or 
all of the currently available to do's  
34:54 - for that we will create a for each 
and for now we will just feed this  
34:59 - with random numbers we will not even use 
them we will just say underscore in because  
35:06 - we don't even care about these numbers 
in the for each let's create an h stack  
35:12 - with a circle this will basically be the 
indicator if the to-do is already completed or not  
35:18 - and here actually we don't need to say id we 
need to say self as the identifier we don't want  
35:24 - the full circle we only want to stroke its border 
so we will say stroke with a line width of two  
35:32 - let's scale this a little bit with 
a frame of 30 by 30. we don't care  
35:36 - about the alignment since it's just a single 
circle and then let's overlay something here  
35:45 - we want to overlay basically a little check mark 
if the to-do is already completed so we will say  
35:51 - if true for now since all of this is just mocked 
if true we will have an image with the system name  
35:59 - of check mark okay so that's the first part of 
our rows next we want to add the to-do title
36:08 - okay and then let's push everything 
to the leading edge with a spacer  
36:13 - let's give this whole thing 
a bit of horizontal padding
36:18 - and then also add a divider underneath
36:24 - okay now that we have implemented 
both the large and medium-sized view  
36:28 - let me run them on the simulator and show 
you how they look okay so the simulator is  
36:33 - now running and you can already see our medium 
size widget here so all of this is a group box  
36:40 - up here you can see our label that we added at the 
bottom here then there's this scaled system image  
36:47 - that to do title and that it is already completed 
and if we swipe over to the next side we see a  
36:53 - tiny bit of an issue with our large size 
view and that is because we have too many  
36:59 - lines or too many cells here so let's reduce 
that to six and run it again and have a look  
37:06 - okay this is already looking a lot better so we 
have our header here the only thing that i forgot  
37:10 - to do is to add a little spacer below or for each 
so we don't have that white space at the top there  
37:17 - so let's add the spacer here let's run this 
one last time okay and there you can see  
37:25 - now the ui looks exactly how we wanted it we 
have our header here with the blue background  
37:29 - and a tiny bit of shadow at the bottom here 
if you can even notice it then we have the  
37:34 - title of my to-do's and the current date then of 
course we have our rows of our different to-do  
37:40 - items as you know all of these are mocked 
right now okay in the second part of this  
37:45 - lesson we will have a look at deep links 
so basically we want the user to be able to  
37:50 - tap somewhere on the widget and then open up 
a specific piece of information inside of the  
37:55 - app to achieve that there are a few steps that 
we need to take first of all we need to set up  
38:01 - the target url in our widgets using either 
the widget url modifier on the entire ui  
38:08 - or using specific link views for example for our 
rows here inside of the for each and then we also  
38:16 - need to handle the on open url modifier inside of 
the main app that basically handles what the app  
38:22 - displays when it gets opened through a widget 
url or any kind of deep link for that matter  
38:28 - first of all we will have a look at the widget 
url modifier because it's a tiny bit easier to use  
38:34 - for that we just have to add it as the last thing 
in our medium size view so the widget url modifier  
38:43 - which needs a url and we will construct that 
right now from a string i will tell you about  
38:49 - this once we yeah basically parse the url in the 
main app then you will see how all of this works  
38:56 - basically what i usually do as the scheme i will 
just say the app name so just my app in this case  
39:04 - colon slash slash then the different routes 
basically so here we'll have slash to do slash and  
39:13 - then the identifier of a to do which we will later 
on get dynamically from our timeline provider  
39:20 - right now i will just hard code this to be one 
okay and that's already the widget url modifier  
39:26 - this is all we have to add to our widget to open 
a specific thing inside of our app or to at least  
39:32 - tell the episode because right now the app doesn't 
handle anything befo before we do that let's have  
39:37 - a look at the link view for our large size view 
for that we will grab our entire h stack here copy  
39:46 - it and embed it in a link with a destination url 
and then as the label we will just paste back in  
39:55 - the hdac and now you can already imagine this url 
is basically the exact exact same thing as before  
40:02 - but the main difference is in the widget url 
modifier you can pass in an optional url which is  
40:09 - uh happening here because the string initializer 
always gives back an optional url but in the link  
40:16 - view you will need to pass in a non-optional 
url so we will have to false unwrap this here  
40:23 - in a real application you might not want 
to do that you might want to construct a  
40:27 - url at a different place be sure that it 
exists and then pass it into your view  
40:33 - for now in here we can basically put the exact 
same url as we had in our medium size view  
40:41 - once again this identifier here is hard coded 
right now we will replace this with the identifier  
40:46 - of that specific to-do item later on all right 
that's already everything that we need to set up  
40:53 - in our two widget views so we can close those 
up now and we have to move into our main app in  
41:00 - our content view now we will now have to add the 
unopened url modifier at the end of our content  
41:07 - view here and this basically gives us a closure 
passing in the url that the app called when it  
41:14 - was opened from a url this is basically not called 
when the app is launched regularly this is only  
41:20 - called in our case if the app is launched through 
the widget so if the user tapped on the widget  
41:26 - then this closure here will get called and now 
our task is it to parse the url make sure that  
41:33 - it's in the correct format download the data that 
we want to display and then display that data  
41:40 - so first of all let's make sure that this url is 
correct so we will have to check if the scheme is  
41:47 - correct and the scheme in our case needs to be my 
app so if we um one last time we go back into one  
41:55 - of our views the scheme is basically this right 
here in a web url this would be https for example  
42:02 - next up we will have to check that the host is 
to do url.host equals to to do that's basically  
42:13 - this route that i mentioned before and then lastly 
we need to extract the identifier so let's say  
42:21 - that id equals an int from our urls path component 
number one so let's just say path components at  
42:33 - the position one and that will be the number here 
at the very end which we hard coded right now  
42:40 - but will then be filled in from our actual to-do's 
now that we have all of that um let's make sure  
42:48 - that in case any of this is um yeah is not working 
we will just return of the closure and do nothing  
42:57 - you can also print that there is an issue here 
in case you want to debug it somehow okay now  
43:04 - we have everything that we need basically that's 
just the id both of these are just arrow checks  
43:10 - now i've already told you about this in the first 
lesson we will use the get to do function of our  
43:17 - to-do servers i've told you that this is using 
the new switch concurrency features and that  
43:22 - it is an asynchronous function that can throw 
errors but in the end returns us a single to do  
43:28 - with that identifier that we pass into the 
function so let's use that and since we're  
43:34 - not in an asynchronous context context we need 
to first of all create a task i already told you  
43:41 - this function can fail so we need to wrap it in 
a do catch block and then for now we will just  
43:48 - print the error but in reality you should handle 
the error in an adequate way now let's get to the  
43:59 - meat so we want to download our to-do from our um 
yeah our service so let's say let to do equals try  
44:08 - to await all of this with concurrency stuff we 
already talked about this in the first lesson if  
44:13 - you want to learn more about this just check the 
source concurrency um lessons they will be linked  
44:18 - down below so we will try to await the to do 
service we have a shared instance here the get to  
44:25 - do function with the identifier that we extracted 
out of the url here so let's just pass in that id  
44:33 - once that finishes once the await is done 
basically we need to switch back to the main queue  
44:40 - because this can happen in any queue and now we 
want to update our ui so we need to be on the main  
44:47 - queue for that and if you remember from the first 
lesson we have this state of the selected to do  
44:54 - here and if we set that to a to do then a sheet 
will be shown with information about that to do  
45:01 - so we can just say selected to do equals our to-do 
that we just loaded with our get to do function  
45:10 - okay this was a lot of talking a lot of code 
let's run it in the simulator and see how it works  
45:16 - okay so first of all let's have 
a quick look at the widget kit  
45:20 - chorus app here okay everything still looks good 
now let's have a look at the medium size widget  
45:27 - remember we added the widget url modifier here so 
you can tap anywhere inside of the widget then the  
45:33 - app will open up and it will tell us all of the 
information about the to do with the identifier  
45:39 - one because that's what we always passed 
in here as a hard-coded identifier  
45:46 - and then if we close that 
again go to the home screen  
45:50 - and now over here in the large size widget you 
will have to have a very um yeah a sharp eye here  
45:58 - if you click on the individual cells then they 
will get highlighted a tiny bit like a button and  
46:04 - the app will get open so let me click on the third 
cell here you saw there was that little subtle  
46:08 - button button click animation now the app opened 
again and we once again see information about the  
46:14 - to do number one because that's just what we had 
coded okay so in this lesson you learned about  
46:19 - different size classes in widgets and how to show 
different ui components for those you also learned  
46:25 - about deep links using widget url link and on open 
url in the main app learn how to provide data to  
46:34 - a widget by reusing a service class from the main 
app and how to schedule that data in the timeline  
46:42 - hey code crew this is floor in this lesson we 
will finally fill up the widgets with some live  
46:48 - as we use the existing to-do service from the 
main app we will also fill out the timeline  
46:53 - provider and talk about different ways to schedule 
content for your widget so let's get right into it  
46:58 - before we can start filling out the timeline 
provider we need to do a few setup things as  
47:03 - i already mentioned we will want to reuse the to 
do service in order for us to be able to reuse the  
47:09 - to do service in our widget extension it needs 
to actually be a member of the widget target  
47:14 - right now let's open up the file inspector on the 
right hand side and then under target membership  
47:20 - you can see that the to do service is only a 
member of the main app target so let's also add  
47:25 - it to the widget extension this is one of the 
two files that we need to add the second one  
47:31 - is to do itself as you can see we will return 
arrays of to-do's and signal to do's in order  
47:37 - to do servers so we definitely also need to have 
the to-do struct inside of our widget extension  
47:43 - so let's go over to that file and make sure that 
it's also a member of the widget extension next up  
47:51 - we need to do one more setup step before we 
can implement the timeline provider and that is  
47:55 - adding the data to our timeline entry you already 
learned about the importance of the timeline entry  
48:02 - this is basically what is carried throughout the 
timeline and provided to your widget by the system  
48:07 - at the correct date with the correct information 
the date is already specified here which is a  
48:14 - requirement from the timeline entry protocol 
now let's also add the information and that's  
48:20 - the to do's that should be shown at a specific 
date in our widget so let's just add a to-do  
48:29 - array here to our simple entry now we can actually 
use this entry to schedule updates in our widget  
48:36 - using our timeline provider so we can close 
the simple entry here you can also close  
48:43 - the to-do over here as you can see now it 
doesn't compile anymore because we changed  
48:49 - the requirements for our simple entry it now needs 
a date but it also needs a to do so let's try to  
48:57 - fix all of these issues and at the same time i 
will explain you how each of these functions work  
49:03 - briefly let me explain to you the 
placeholder function and actually  
49:07 - let's not make me explain it to you let's just 
have a look at the definition oops the definition  
49:14 - of the timeline provider and then you can see 
there are very very long descriptions of each  
49:20 - of the functions for the placeholder function the 
getsnapshot function and the gettimeline function  
49:26 - the placeholder function provides a timeline entry 
representing a placeholder version of the widget  
49:32 - this is for example used when you display when 
your widget renders for the first time it can  
49:37 - also be used in a widget gallery but i think there 
they actually use the get snapshot function now so  
49:44 - basically we don't really need to care about what 
we return in the placeholder function as it's just  
49:49 - a placeholder while the actual widget is loading 
so let's add the to-do's here to our simple entry  
49:59 - and to make life easy for us let's create an 
extension on to do to create some preview or  
50:05 - some placeholder to do's with a given id so let's 
go back into the to do definition let's create an  
50:13 - extension of to do and in here let's create a 
function called placeholder that takes in an  
50:24 - id which is an integer and returns a to do 
for us and now we can use this in our um get  
50:31 - place or in our placeholder function and also in 
other places later on for example for previews  
50:37 - the function is really easy just construct a to-do 
here using any user id it's just a placeholder  
50:44 - really doesn't matter what's important is that 
the id is unique because the to-do is identifiable  
50:50 - we have a list iterating or for each iterating of 
all of the to do's in our large size widget so it  
50:58 - is important that the ids are unique and that's 
why we're passing in a id here in the placeholder  
51:03 - function let's just pass that right into the to 
do for the title let's just say placeholder and  
51:09 - for completed let's just say a random boolean so 
either one or two either true or false okay now  
51:18 - that we have this placeholder function back in our 
provider we can now use that placeholder function  
51:24 - here to fill out our list of to do's let's 
make one with the id 0 and one with the id 1  
51:31 - and then that should be good in our placeholder 
function here next up is the get snapshot function  
51:38 - here we also have to create a simple entry or 
one single entry but instead of returning it like  
51:46 - we're doing in the placeholder function we need 
to call the completion handler with this entry  
51:52 - so very similar but now this can actually 
be called on your actual widget so we cannot  
51:57 - use placeholder data here anymore instead we will 
use our to do service to get all to do's for that  
52:06 - let's remove everything that is auto-generated 
here and since our to-do service uses the new  
52:12 - async await pattern let's directly start off by 
constructing a task so we can use asynchronous  
52:19 - stuff and i can already spoil it to you we will 
also need to catch some errors so we can also  
52:25 - directly add a new catch block here now inside 
of the do block let's fetch the to-do's from our  
52:32 - to-do service so let's say let to do's equal 
try to await to do service dot shared dot get  
52:43 - all to do's you already know this we already used 
this or i already explained to you how this works  
52:51 - next up let's construct a simple entry so 
let's say let entry equals a simple entry  
52:59 - with the date of now and to do's of the to-do's 
that we just fetched here and then let's call the  
53:09 - completion handler with that timeline entry 
so let's just say completion with the entry
53:18 - in the catch case however we also want to call the 
completion block this case this time let's also  
53:26 - return some placeholder so let's just say  
53:30 - completion simple entry with the date 
of now and to do's we will just use
53:39 - placeholder zero now you can see here 
that the instance member placeholder  
53:46 - cannot be used and that's because we 
forgot to say that this is a static  
53:51 - function so we can directly call it on the type 
to do instead of a specific instantiated to do  
53:59 - now these errors should also go away 
okay awesome now the last part which  
54:05 - is also the most interesting and most 
important is the get timeline function  
54:10 - let me remove everything and then let's go through 
the function step by step so you understand how it  
54:16 - works similar to before we also have a completion 
handler but this time the completion handler  
54:22 - doesn't accept one entry it actually accepts a 
timeline of entries that timeline is a collection  
54:29 - of entries like an array but it also has a 
refresh policy that's the last thing that we will  
54:36 - handle when setting up this get timeline function 
first of all let's do the same setup as before we  
54:41 - know we're going to use the to do service so we 
will need a task we also need a do catch block  
54:49 - inside of the do block let's fetch all to do's 
once again so let's say let all to do's equal try  
54:57 - await our to do service dot shared dot get all 
to do's this is the exact same stuff as before
55:07 - then let's actually do a little trick here  
55:10 - if you remember in our widget ui we will show a 
bunch of different to-do's in our large size view  
55:17 - this ui is meant for small amounts of data not 
for large amounts of data the ui will break if  
55:24 - you pass in let's say 50 to do's because then 
the top bar will get pushed out of the screen  
55:31 - so we will just um use the first five to do's 
that we get from the service so let's say let  
55:41 - five to do's equal an array oops an array 
of our all to do's dot prefix of the length  
55:52 - five this will give us the first five 
entries of the all to do's array that is  
56:00 - not actually returning an array it's 
returning an array slice but we need an  
56:05 - array so we will construct a new one here 
next let's also create a timeline entry  
56:13 - so we will just create a new simple entry for 
the date of now with our five to-do's in it up  
56:22 - until now this is very similar to the get snapshot 
function and actually we should probably use this  
56:27 - prefix 5 approach in the get snapshot 
function as well so let me copy it over  
56:33 - and do it like this okay to make sure that the 
guest network function also doesn't break the ui  
56:41 - okay so now we have our to-do's we have our 
simple entry now what we need is a timeline  
56:47 - and there are a couple of different ways to 
do this now one way is to create a bunch of  
56:53 - different entries for example for right now in 
one hour in two hours and five hours and so on  
56:59 - and pass all of them into a timeline and 
tell the timeline timeline to refresh  
57:04 - once nothing is left in it anymore so in our 
case in five hours or what we are going to do  
57:11 - construct a timeline with a single entry and tell 
it to refresh after some specific date has passed  
57:18 - the idea is basically if you have content that you 
can already schedule right now throughout the day  
57:23 - for example if you already have the users calendar 
you can schedule the whole calendar widget for the  
57:29 - whole day but if you rely on live data that 
you download from the server which is what  
57:33 - we're doing in our to-do servers then it is 
always a good idea to only schedule one or  
57:41 - two maybe three timeline entries and then force 
the timeline to refresh that way you will always  
57:47 - have the most up-to-date information so we 
will do the later we will create a timeline
57:56 - and this will accept an array of entries so 
we will just create an array with our single  
58:02 - simple entry in it and then for the policy you can 
just hit dot as this is an enum very handy you can  
58:09 - see there are three different reload policies 
the first one is at end so the timeline would  
58:15 - reload when no more entry is left the second one 
is never i think this is very safe explanatory  
58:23 - this means that the app itself will never reload 
the timeline but however it will get reloaded  
58:28 - sometimes for example if the user restarts their 
phone adds or removes the widget things like that  
58:34 - the system decides when the timeline is really 
reloaded you only tell the system your preferences  
58:40 - basically as the developer and then the last one 
is after a specific date which is what we will use  
58:46 - and the date that we will use is now advanced 
by basically 60 seconds times 60 times 30 so  
58:59 - basically every 30 minutes this timeline should 
get refreshed in practice this will probably not  
59:07 - happen every 30 minutes since timelines only get 
refreshed when the user is actually on their home  
59:11 - screen so if the user has their device in standby 
for a few hours then the widget will never get  
59:16 - refreshed and will only get refreshed once they 
view the home screen again okay and now the last  
59:23 - thing let's call the completion handler with 
our timeline again okay now in the catch block  
59:30 - we will just have our placeholder data once 
again for that let's create some timeline entries  
59:37 - this is just an array of simple entry just 
uh one for now so let's say the date is now  
59:48 - and the to do's is dot placeholder with the id 0 
just one for now doesn't really matter hopefully  
59:56 - this catch block will never take place then let's 
also create a timeline which is just a timeline  
60:05 - with the entries array and with the reload 
policy we will just copy over the one from  
60:11 - up here basically what this would mean is that 
after 30 minutes try again to build a timeline  
60:18 - okay and then let's pass the timeline to the 
completion handler as well and with that our  
60:24 - timeline provider is already done now let's use 
all of these pieces of data that we pass into  
60:31 - the simple entries inside of our actual widget 
views to do that let's go to the medium size view  
60:39 - okay in our views previously we hard coded all of 
the data like the to do title and whether it was  
60:45 - completed but also the to do id down here in our 
deep link url in the medium size view we only want  
60:53 - to show one to do so to do that let's grab the v 
stack let's cut it out and in here let's say if  
61:02 - let to do equal our entry dot to do's dot first 
we will just access the first to do and let's  
61:10 - paste back in our v stack now in here instead 
of this hard coded string let's say to do dot  
61:17 - title instead of the completed let's say to do dot 
completed let's use the ternary operator here so  
61:26 - let's say if the to do is completed we want to say 
completed and else we want to say that it's open  
61:34 - as this is a unwrapping of the first object it 
might be nil so there might not be any to-do's in  
61:40 - the simple entry for example because we couldn't 
fetch any from the server because we succeeded  
61:45 - to fetch from the server but the server just 
returned an empty array in this case with the  
61:50 - json placeholder api this should never happen 
but in your main app you might want to put an  
61:57 - else block here as well and then display some 
error state you could for example say couldn't  
62:02 - load to do's try again later or something like 
that okay now let's also replace the hard coded  
62:09 - id here in our widget url for that let's say entry 
dot to do's dot first dot id this is optional but  
62:20 - we can't have an option in here so we will have to 
provide an alternative basically and we will just  
62:26 - null coalesce it with zero okay that's it for the 
medium size view let's jump into the large size  
62:33 - view as well okay in the large size view now if 
you remember we had this hard coded zero through  
62:41 - six range let's get rid of that and instead let's 
say entry dot to do's we don't need to provide  
62:49 - an identifier because we did mark our to-do as 
identifiable itself and does have the id property
62:59 - okay let's go top to bottom here so the first 
thing that we need to replace is the id in our  
63:04 - deep link for that we can just say to do dot 
id and we actually need to grab the to-do in in  
63:12 - our for each for that to work then we had our if 
true here this of course should mean if to do dot  
63:20 - completed only then we want to show 
that the check mark on top of the circle  
63:25 - and then i want to do the title also let's 
grab that one from the actual to do okay  
63:32 - that should be it let me spin up the simulator 
and let's have a look at if everything works  
63:37 - if we can see all of the to-do's and if the 
deep links still correctly link into the app  
63:43 - okay so as you can see it doesn't quite 
compile yet and that's because we still  
63:47 - have our preview down here which doesn't 
have the updated simple entry initializer  
63:53 - so we also have to pass in some to do's 
into our little swift ui preview here  
63:58 - and let's also just use the placeholder function 
for zero and then also another one for one  
64:05 - and i think this should be it now yep looks 
good let's compile now and see if it runs
64:18 - okay so the simulator just launched and i added 
all of the widgets first of all here you can see  
64:23 - the medium size view it fetched one of our to-do's 
and if we tap on it then the app will open up  
64:30 - and the little cheat will come up with some more 
detailed information about that to do and if we go  
64:36 - back to the home screen and move over then we can 
see our large size widget which also fetched the  
64:42 - last five to do's as we specified using the prefix 
operator and if we tap on any of these to do's  
64:50 - then the fitting section will also open up and 
show up in the sheet because we passed down the  
64:56 - correct id in the deep link this was the final 
lesson of the three-part widget kit course in this  
65:03 - series you learned all the basics about widget 
kit how it works the way updates are scheduled  
65:10 - multiple size classes reusing existing code and 
deep linking into your app use your existing  
65:17 - widget kit knowledge to create a lock screen 
widget for ios 16. hey code crew this is flow in  
65:24 - this lesson you will take your existing knowledge 
of widget kit and bring it to one of the biggest  
65:29 - io 16 features lock screen widgets you will learn 
about the new size classes that got introduced  
65:35 - and how widgets work on the lock screen and just 
a quick disclaimer right now i'm using the xcode  
65:41 - 14 beta version which you can find the download 
link of right below this lesson the actual full  
65:48 - version of xcode 14 will be out later this year i 
would guess that it will happen about in september  
65:54 - until then you will have to use the xcode 14 
beta because we are using ios 16 apis so of  
66:00 - course we need the ios 16 sdks as well which 
are part of the xcode 14 beta i think you got  
66:06 - that point so let's jump right into it first of 
all let's quickly recap how widget kit works and  
66:12 - what you have already learned in this course so 
a widget just like a swift ui app has an add main  
66:20 - annotated struct it's not an app it's a widget and 
in here you have a body of widget configurations  
66:28 - in this case we just have a static configuration 
with our specific view inside which is just  
66:34 - called a widget view this configuration 
always has a name which is just a string  
66:41 - or also called a kind and also a timeline 
provider which is our provider that we had created  
66:49 - so let's look into that next the provider is 
or conforms to the timeline provider protocol  
66:56 - which has to implement three different methods 
the placeholder method for the widget gallery  
67:02 - the get snapshot mesh method and the get 
timeline method we have already implemented  
67:09 - all of these in the previous episodes or in the 
previous lessons of this course so if you're  
67:15 - unsure about how any of this works just 
go back a few lessons and rewatch them
67:21 - the timeline provider basically schedules timeline 
entries for our widget view so next let's have a  
67:29 - quick look at our simple entry so we have a 
struct called simple entry that conforms to  
67:35 - the timeline entry protocol it always has to have 
a date associated with it so it can get scheduled  
67:40 - by the system and then in our case we also pass 
in some to-do's that we got from our to-do api  
67:49 - so let's look at a to-do there's also 
just an identifiable and decodable struct  
67:55 - it has a user id an id to make it identifiable a 
title and a flag whether it's completed yet or not  
68:06 - and now if we go back to our timeline provider you 
will see that we use our to do service dot share  
68:12 - dot get all to do's function that does something 
in the background doesn't really concern us in a  
68:17 - widget here and then we get back to do's and we 
only take the first five of them that means that  
68:24 - when a widget is shown to the screen it always has 
a entry associated with it and that entry always  
68:30 - has five to-do's associated with it as well and 
then all of that data is displayed via the widget  
68:38 - view which is just a plain old swift ui view 
it has the timeline entry so we had it here  
68:46 - specified via provider.entry but the actual 
type of this is let me add that as well aka  
68:53 - simple entry so the provider.entry that's 
basically a generic so the entry is a generic  
69:00 - type of the timeline provider which is then 
during compilation resolved to be a simple entry  
69:07 - um if we have a look at our provider then you will 
see we always return simple entry instead of just  
69:15 - any timeline entry so this is 
basically his associated type  
69:19 - doesn't really matter right now at all and then 
in addition to the simple entry we also grab the  
69:26 - widget family which is basically the size class 
from the switchoi environment and then display  
69:31 - different views depending on which size class 
this got passed to or is displayed in actually  
69:40 - so right now we only implemented the system 
medium and the system large size class in  
69:46 - our widget view and if we have a look back 
into our widget and you can see we have added  
69:51 - the supported families modifier and passed in 
the system medium and system large size class  
69:58 - let's start adding the lock screen widgets this is 
actually super simple and the only thing that you  
70:05 - basically have to do is to add three new supported 
families so let's get started by just hitting dot  
70:12 - and pressing a and then you will see that there 
are three new accessory families added there is  
70:17 - accessory inline which is the section above the 
time on the user's lock screen there is accessory  
70:25 - circular and there is accessory rectangular which 
are the small and the wider widget sections below  
70:33 - the user's time on their lock screen now xcode is 
yelling at me because let's expand this error here  
70:40 - the new accessory widget families are only 
available in application extensions for ios 16  
70:46 - or newer and that's because we haven't updated 
or we haven't set the deployment target to ios  
70:51 - 16. it's still at ios 15. so let's jump into our 
xcode project file select our target and for the  
71:00 - ios version let's scroll up to 16.0 and i think 
for the widget we also need to select that yeah  
71:07 - so select the widget extension and then scroll up 
to ios 16.0 and now that error should go away in  
71:13 - a second once xcode decides to re-evaluate it and 
there it goes it's away okay so all you had to do  
71:22 - to support a new widget was adding these three new 
supported families now if you if we jump back into  
71:28 - our widget view you will remember that we switched 
over the widget family and we only had two cases  
71:34 - for the medium and the large size class in any 
other case this default case would be run which is  
71:40 - a text saying not implemented that's of course not 
really nice so let's replace that and add some new  
71:47 - widget ui here so let me clear this up a bit let's 
add the new cases for the new accessory inline  
71:57 - accessory circular and the 
last one accessory rectangular  
72:03 - widget families now as i just said inline 
is the one that's still displayed above  
72:11 - the user's current time on the lock screen and 
circular and rectangular are displayed below the  
72:17 - current time for the inline one i would recommend 
you to only add text and i think that swift ui is  
72:24 - actually smart enough to remove anything from that 
widget that's not text so we will just add a text  
72:31 - of our entry dot to do's and we will grab 
the first one and just display its title  
72:40 - now first here is an optional so we will have 
to optionally unwrap that or a new coil as that  
72:47 - that's what the operator is called and just say 
no to do's if there is no first to do in that list  
72:55 - so that's super simple and then for 
accessory circular and accessory  
72:59 - rectangular i will actually use a new view 
that was also added in swift ui on the iphone  
73:05 - at least with ios 16 i think it already existed 
on the apple watch for complications and that's  
73:11 - the gauge so we will just for the circular we 
will just add a gauge with a value and a label  
73:20 - and as a value we can for example say the number 
of to-do's that were completed divided by the  
73:27 - number of to-do's that are not completed yet 
in those five that are in our timeline entry  
73:34 - you could calculate calculate that um an easy 
way to just try all of this out is to just set  
73:40 - any double value so 0.7 in that case a gauge 
always goes from zero to one so that's basically a  
73:48 - you know like a progress view you can imagine 
it to be like that but we will have a look at it  
73:53 - on the lock screen in just a second anyways 
so let's expand this um label closure here  
74:00 - and in here we can just put anything that we want 
and i will just put a text with our entry the date  
74:07 - and also let's format that a bit so let's say 
that date time and we just care for example  
74:14 - about the year and that we will have a gauge 
displaying 0.7 and then the label will be  
74:22 - the date of this timeline entry but only the year 
of that date and then for accessory rectangular  
74:30 - let's actually use the exact same thing as 
for accessory circular let's copy paste that  
74:39 - and then let's also um i had some god our gauge 
styling here so there are a few different gauge  
74:46 - styles that we can add and since we're currently 
an accessory circular let's just use the accessory  
74:51 - circular gauge style and then also the one for 
rectangular so accessory linear in this case okay  
75:04 - let's give this a run and have a look at how it 
works on the user's lock screen okay so the app  
75:11 - is now installed on the simulator so we can just 
press command l to lock the simulator and then  
75:16 - press this little house icon here again to go 
back to the lock screen just press and hold on  
75:21 - the lock screen and hit customize at the bottom 
then you will see that there are three different  
75:26 - sections that can be customized by the user the 
top section which has the accessory inline widgets  
75:33 - the center section which just has the time the 
user cannot really customize this they can only  
75:38 - change the font and the font color i think and 
then the bottom section for accessory circular  
75:43 - and accessory rectangular so let's start at 
the top let's press on the first section and  
75:49 - then we can scroll down until we are at the 
widget kit course app and let's select that  
75:55 - widget and then you can see this is probably 
the title of the first dummy to do that we had  
76:00 - in our yeah that we got from our api service and 
then let's do the same with the bottom section so  
76:08 - let's remove this calendar widget here and then 
if we scroll down to the widget course we can  
76:12 - select it and the user will be able to see all 
of the available lock screen widgets which in  
76:17 - this case is the accessory circular which is this 
gauge with a value of 0.7 so that's about right  
76:24 - and then as a label it has the current year 
because that's the the text that we added here  
76:33 - so let's select that first and then we also 
have the accessory rectangular and now a very  
76:37 - interesting thing is happening here the gauge 
looks completely different of course because  
76:42 - we gave it a different gauge style but it also 
does not show its label so we'll have to keep  
76:47 - that in mind when you're using the gauge view 
not entirely related to just widget kit and lock  
76:52 - screen widgets but just in general keep in mind 
how the gauge view works so let's also add that  
76:58 - and you will see the rectangular widget 
is a lot larger about twice the width of  
77:03 - the circular widget so let's exit out of all of 
this let's hit done and select this lock screen  
77:10 - and then you will see that we have all three of 
our widgets that we just created here right on  
77:16 - the user's lock screen so in this lesson you 
learned about io 16's new lock screen widgets

Cleaned transcript:

learn how to add a widget extension to an existing app including reusing service classes building uis for different size classes and scheduling widget updates through a timeline hey called crew this is floor i've been developing ios apps since 2016 and i've been working on many different widgets over the past few months so i'm super excited to teach you about widget kit in this series this is lesson one where i will show you examples for great widgets by apple the current project setup and the example app that i have prepared for you next we will add a widget extension and go through everything that xcode automatically generates for us let's get started with some examples of grade widgets so you understand how all of this works how the ecosystem works and how they are built up so there is this great article from the apple developer website which is linked in the description which just gives a brief introduction to widget kit and i just want to show you a few of the examples that they have on their website here they have the little calendar widget they have a weather widget news music also for the activity app and so on then there are a bit larger widgets for the ipad with photos and a bigger calendar view but one thing that unites all of them is that they have at a glance information so you for example in the calendar widget you only have the next two events showing so when you have a glance at the widget you immediately know what it wants to show you and what information is there same for the weather widget you just have a quick look at it and then you instantly know the temperature and the current weather conditions there are also some more widgets that i want to show you that i have personally worked on the first one is a food tracker app which is based around a medium sized widget that you can see in the screenshot in the middle here and the idea is basically that you can track your meals through a widget where you can just tap either on the healthy or on the junk side of the widget the app will open up and all of your meals will get locked that way so there's a tiny bit of interactivity here but i will tell you more about that in just a second and then there's also another widget that i made for a swift ui jam a few weeks ago which is an almost fully working calculator widget so we can watch the video here it looks just like the calculator app from your iphone but then you can tap on the numbers and on the operators the app will briefly open up close back down again and then you will see your calculation and the end result inside of the widget i think this is very cool obviously this is not what apple intended widgets to be but there you can just see what's possible with the technology so getting back to widget kit itself widgets are built entirely in swift ui so it is not not possible to pull the ui kit for example via ui view representables or your view controller representables currently you can only use swift ui to build out the ui side so what's displayed inside of the widget as i said the main idea is to provide at a glance information these are just tiny portions of the screen the widgets are based on a timeline so you the developer can provide a timeline scheduled with timeline entries that all have an associated date and some data associated as well so you can for example schedule a timeline over the next five hours where at every full hour there is a timeline entry and then ios or ipad os or even mac os whichever system your widget is running on will execute that timeline and refresh the widget by itself so you are not guaranteed to have the widget refresh at exactly the time in your timeline entries that you have specified but the system handles it and the system also has some limitations for example you cannot refresh your widget a few hundred times per day there are just certain restrictions there set by ios but most users will never notice this and for most users the widgets will always stay up to date we will have a look at the timeline the timeline entries and so on in partially in this but mainly in the next lesson and then one last very important thing when talking about widgets is that you understand that they are static ui so there are no animations there are no videos there is no navigation and there are also no buttons the only dynamic thing that a widget can do is link into your main app and pass in some data there we will have a look at that in the third lesson of this series but until then you can just assume that a widget is more or less a very static view okay to get us started a bit quicker i have already prepared a very simple example app this is a simple todo list app based on the json placeholder api you might have already seen the json placeholder api if you want to have a more specific look at it it will be linked down in the description it's a very generic api with some yeah as the name suggests placeholder json data for users for posts and so on but we're just using the to do's route which you will also see in just a second so the main app only has a single view which you can see here on the right hand side if i press play then all of the to do's will be loaded you will have a list here with the to do title on the left hand side and then the statues whether it's completed or not on the right hand side so some of these todo's are open some of them are already completed and if we tap on a todo item here a little sheet will come up telling us the id of the todo then once again the title and whether it's open or completed and then you can of course dismiss the sheet like always okay so let's briefly go over the content view here so you understand how this all was built and then we will have a look at our data class or to do and then also our service class so first of all as you can already see we have a navigation title here so we must also have a navigation view which surrounds everything in our content view here and then mainly we just have this single list here the rest of the code is just view modifiers but we mainly have the single list here iterating over all of the to do's which is a state variable here in the beginning this is an empty array of to do but later on i will show you how this gets filled and then inside of the list we just have a simple button for every row the button action is to set the selected to do which is another state variable to the to do of this current row so for example if i tap on the first one then that will will be the selected to do which is used for our sheet here at the bottom this has the item initializer where you can pass in an optional identifiable item in our case our selected to do state and if that is not nil so if there is some to do selected then the sheet will show up and show just a simple group box here i think this is not too important this is just for demonstration purposes if we dismiss the sheet again we have our list again and then inside of the list button there is just a simple attributed string which is brand new in ios 15 where you can use some parts of markdown to for example bold a region of text so here you can see these double asterisks before and after the completed or open text which we just bolded as i said this is attributed string stuff not important for this series i just wanted to include it to make it look a tiny bit nicer since this is a very plain ui okay let's continue down so we already have covered the navigation title it's just my todo's and now the interesting part comes so um for our todo servers i have chosen to use the new script concurrency features if you want to learn more about that there is also a series about such concurrency made by stuart lynch um so it will probably also be linked down below you can go there after this video or if you have any understanding issues then you can just go there and have a look at it but i think it will be pretty straightforward basically what we're doing is we're attaching a task to the list task is very similar to on appear so the code in here gets executed the first time that the view appears but you can execute a synchronous code in here so we will have a look at how that works in just a second but bear in mind so this task will get executed one time at the beginning and everything in here is happening asynchronously in a background thread or can happen in the background it can also happen in the main thread depending on how it is scheduled internally and all that this task does in this case is call our to do service dot get all to do's function which calls the json placeholder api gets back all of the to do data and then puts it into our to do's state variable up here which will then be used inside of the list okay and then the last modifier here i already told you about the sheet so i think this should be pretty clear now let's move on into the data folder on the left hand side here so first of all we have our struct to do it's important that this had this conforms to two protocols the first one is decodable so we can decode it from json which you will see in a second in the todo service and the second protocol is identifiable so we can iterate over it in our swift ui list this just has four very simple attributes the user id the id of the to do the title of the to do and whether the to do is completed or not let's jump real quick into the json placeholder api and let's go to the endpoint that we're using which is slash to do's and here you can see where this data is coming from so this is just a json file sitting on the server and there you have um all of the same fields that i just showed you in our todo structs so you have the user id which is an integer the id which is an integer the title which is a string and then completed which is a boolean okay and then the last file that i have prepared is the to do service here this is just a very simple helper class to fetch all of the todo's from the json placeholder api since there is no need to instantiate a new todo service every time that we use it i just added a static shared instance here so we can always just say to do service dot shared instead of instantiating a new to do service we have our base url which is just the address of jsonplaceholder.typeycode.com and then it gets a bit more interesting with these three functions here the first one is a very generic networking function that you can use in any of your projects really but the important thing is that it is built using the swift concurrency features so let's have a brief look at how that works so inside of the function we first have or we first construct our url so when we call this function we pass in an endpoint for example todos and then the function will generate a url for us so in this case it would be https colon jsonplaceholder.typeycode.com slash and then here it would be for example to do's so this will be the endpoint we constructed here this can fail so if in case it fails we will just throw a url error of that url once we have our url we can use the url session dot shared dot data function which is similar to data task or data task publisher if you were using combine previously this function just creates a or takes the shared url session goes to the url that you uh handed over and then fetches all of the data from that url this is an asynchronous task so you have to wait for the results to be coming in and this can actually also fail or throw an error and hence we need to try to await the data from this url this function actually gives back both data and a url response so in your app you might want to check the url response for the status code or any info that the server gave back to you in our case we don't care about that so we can just omit the second value of the tuple here the url response by using the underscore and we will just unpack the tuple into our data variable and then the last step is pretty straightforward we just construct a json decoder and then we decode our to do in our case from the data now the interesting part here is and hence the name generic helper function we have some generics here so we have a generic type t which basically means that we could use this fetch function to fetch any type of data we could also fetch some users or whatever as long as that struct is decodable as the generic condition here says so let's see how that works i have two endpoint functions basically the first one is to get all to do's from the json placeholder which once again is asynchronous and can throw arrows but this one will return an array of type to do and this will basically just call our fetch function up here from the todo's endpoint so basically just the one that i showed you in the browser a minute ago as you've already seen the fetch function is asynchronous it can throw so we need to try to avoid the result of the function since we are using generics here we need to explicitly specify the type that we want to get back so in this case if we want to get all to do's we want an array of type to do and then we just return the result of the fetch function and then very similar for the last function which is called get to do with id we can use this one to get the data for a specific to do which we're using for the sheet for example this function returns a single to do instead of an array of to do's and it's basically the exact same from before so we need to specify the type over here since we are dealing with generics and then the only thing that we're changing is the end point so now we're not querying for all to do's recurring for todos slash our id and if we look at that in the browser so here we have slash to do's and now we say slash one for example this will give us just the first todo item okay so now that you have seen the sample app that i have already created for you let's do the last thing for this video which is adding the widget extension to do that it's also very very simple since xcode does almost everything for you you just go to file new target and then in here you can either scroll through all of the extensions or you can just filter for widget extension double click it then give it a name so in our case i will call it widget kit course widget make sure to uncheck include configuration intent that is something that we're not doing in this series configuration intent can basically be used for siri it can be used for the user to customize your widget but this is not important for the series once you're done just hit the finish button and here you can say activate the scheme if you want to which what this does is basically it changes the theme up here in xcode so once you have an extension you can select when you're running your app which scheme you want to run so you can then either run your main app in the simulator or just run the widget extension in your simulator for now let's just say activate if you want to change this later on you can just go up here and select either your main app or your widget extension okay and then on the left hand side here you can see that a new folder was generated which is called just what we entered into the text field if we open that up there's just three files a basic info.plist file an asset catalog that you can use to provide assets like images and then there is the widget kit course underscore widget file this file contains all of the auto generated code from xcode let me go over the extension and tell you a few words about each of the different types that got generated and actually let's start at the bottom here so first of all same as in swift ui which i just closed there is also a preview available for your widgets i'm closing this right now so we have a bit more space by the way to open and close that canvas you can press command option enter and then there is something that you're probably already familiar with if you have worked in swift ui before because there is now this add main widget struct this is actually super similar to the admain abstract in your normal app where you have a body in which you just present your content view inside of a window group in this case but it also has the add main attribute which basically tells the device this is the entry point to the app start here and then it's the exact same thing for your widget this add main attribute will just tell the device this is the main starting point for the widget called this and then you're good to go so of course this is not an app this is a widget and it also has a body the body has the generic type of or the opaque type of widget configuration you can have there are basically two different types of widget configurations the first one is a static configuration which we are using in most widgets actually use a static configuration and there is also an intent configuration which you can use if you want to let the user edit the widget directly on the home screen not important for this series but just so you know there's two different types of configurations and then into the configuration you just pass basically an identifier of the widget which is defined up here by default this is just the name of your widget extension target you can change this of course especially if you add multiple widgets to your app later on and then into the configuration you also pass in a timeline provider we will have a look at that in just a second inside of the configuration you then have your actual view now this has a very long and complicated name we would change that also in a minute and into that view you pass in your timeline entries if you recall in the beginning of this lesson i talked to you about you can schedule a timeline with different timeline entries for set dates which in turn contains some data that you can pass to your view and basically these timeline entries here come from your timeline provider and get passed into your view over here you will see this more concretely in just a second you can also customize your widget configuration by for example giving it a display name which will then show up in the app library and you can also give it a description okay let's scroll up a bit here the next struct that got auto generated is the actual view this view gets passed in a timeline entry which is that piece of data that's scheduled through your timeline and then this example widget here that gets autogenerated just shows some text of the current date of the entry so nothing very special here and then the entry actually doesn't contain any data right now we will customize this in the next lesson the only important thing here is that your entry conforms to the timeline entry protocol which requires the entry to have a date property and then up here the most important and most interesting part of widgets is the timeline provider so all of this over here the timeline provider is responsible for scheduling your timeline entries for your widget over time for the next couple of hours for the next day or even weeks however long you want to schedule it there are three main functions functions that you need to implement here first of all the placeholder function this is used when the user is selecting your widget in the widget gallery on their actual device then there is the get snapshot function which just gets back the current version of the widget with just a simple timeline entry or just a single timeline entry and then there is the get timeline function which you can use to schedule a timeline for your widget including when it will refresh how often it will refresh and which data it will show the very last thing for this video will be taking all of these different structs and moving them into their own files to make it a bit easier to read and to understand what we're working with so over here in our widget folder we will add a new file and call this one provider and now a very very crucial detail when you create this file is that it needs to be in the widget target and not in the app target now you can hit create and in here let's import widget kit and then let's move our provider our timeline provider from the generated file into this new file and let's do the same for the simple entry and the view as well so create new file swift file let's call it simple entry make sure that the widget extension is checked here hit create import widget kit and then copy over our simple entry just like this and then one last time for our view here so let's hit command n new file let's call this widget view hit create here we need to import both widget kit and swift ui let's copy over this struct over here and move it into this new file and then we can also command click on it and say rename and then rename this long name to just widget view let's also remove this space here let's copy the name and make sure that it was renamed everywhere so for example for some reason xcode didn't rename it over here so let's get rid of these old names and replace them with the new shorter name in this lesson you learned about what can be done with widgets and how they are internally structured you saw that a widget is based on a timeline and timeline entries which get displayed in a plain old swift ui view learn about different size classes building a widget ui and deep linking into your app in this lesson hey code crew this is floor in the first lesson of this widget kit course you learned about how widget kit works under the hood how widgets are refreshed and everything that xcode automatically generates for you in lesson 2 we will have a look at building uis for different size classes and deep linking into the main app from the widget let's get right into it so we're starting in this lesson right where we left off in the last lesson and actually we don't need the content view what we need is our widget definition here so i already told you in the first lesson that there are different size classes that your widgets can have so that's the first thing that we will have a look at in this lesson to have a look at the size classes configure them and tell the system which size classes your widget supports you can just go to your static or your intent configuration basically just widget configuration and then there is a very simple modifier called supported families here you can just pass in an array of all of the widget families that you want to support one note though is that the system extra large family is only available for ipad apps since it cannot even fit on an iphone for this lesson we will focus on system medium which is basically two rows of apps at full width and also system large which is two which is four rows of app so almost the entire screen taken up by that widget while we're added let's also change the configuration name to my todo's and let's also change the widget description both of these strings are shown in the widget preview when the user wants to add a widget to their home screen so for example here for a description we could we could say view your latest todo's just like this okay so now we have told the system that our widget supports both the system medium and the system large widget family but now we have to actually implement both of these size classes and what we will do is we will switch on the size classes that we can reach from the environment and then provide different views to the widget based on which size class is currently selected for that there is an environment value that we can read so just say add environment and then the key path is widget family and this way we can basically read the size of the widget and what we can now do is just switch over this because it's an enum you just saw us set it up here in the supported families modifier just switch over it and then present different views so here let's remove the text and let's say switch widget family and now we're only interested in two cases because we only support system medium and system large so let's say dot system medium and let's also say dot system large and as always a switch must be exhaustive in swift meaning that either we have to cover all of the cases individually or we need to provide a default case in the end that should happen if none of the other cases holds true in our case or in in a place like this the default case will never be executed because we told the system that we only support medium and large but nevertheless we need to provide a default case so let's just say not implemented here and then we can forget about this for the system medium and the system large cases we will now implement widget uis so i will just hit command n say new swift ui file and let's call the first one medium size view make sure that it's a member of the widget extension and not of the main app hit create and then let's do the same with a large size view for both of these let's move them into a group over here in the widget just so we can separate everything so let's call this group views and in here let's move our widget view our large size view and our medium size view okay let's close these and open them up again let's start with the medium size view first of all we will want to receive a timeline entry the one that our widget view already got from the timeline and we will want to forward that into our medium size view so to work with timeline entries we need to import widget kit and then over here we just need to say we want to take in an entry and we can either say provider dot entry or we can just directly tell code to type which is simple entry let's do the exact same thing for the large size view so import widget kit and then let's add a var entry of type simple entry and actually since we're inside of widget kit we don't even need the previews here so we can just scrap them from both of these views that way xcode won't complain about any issues and now we can already start to add both of these views into our widget view so for the system medium let's just say medium size view with our entry and then also large size view with our entry okay for the medium size view we will now start to implement the ui and for that i want to show you a pretty neat trick how to have at least a decently looking ui up pretty quick for that we will use a group box with a label so a group box is basically just a wrapper around a bunch of views that groups and up and puts them into a box with some sort of grayish background and with the label initializer here we can pass in a label with a title and an image in our case we will use a system image the title will be my todo's and the system image will be list dot dash and now inside of the group box we can put our actual ui so in our case we will have an h stack here with first an image of a person for that we will use um the sf symbol for person let's make that resizable let's make that scale to fit and let's also give that a foreground color of secondary so um so a nice grayish touch then let's add a little divider so in case you didn't notice you can place dividers in v6 but also in h stacks and if you place them in h6 then they will be just a vertical line and then in here let's add a little vstack where we can display the contents of one of our todo items let's give this a leading alignment like this and then in here we will have two text elements the first one with the todo title right now we will just have some placeholder content here because we will fill out the timeline provider in the next lesson let's have this text as a headline font so give this the font of dot headline and then below our title we will have whether it is completed so here i will just say completed for now we will fill this with a tiny bit of logic in the next lesson as well and then here we'll just say this is a sub headline like this at the end let's also add a spacer so everything is aligned nicely and then let's also add some padding to the edge stack so nothing cuddles with the edges of the widget i would say okay that's the medium size view already done for this episode now let's move on to the large size view in here let's also remove the text and let's replace it with a v stack basically what we want is we want to have kind of like a notepad feel to this widget you already saw it in the first lesson how it will look in the end and let's implement that right now first of all there's this little header row at the top i will give that a spacing of 16. and in here let's add a little title called my todos then let's add the current date so date.now with the format of date time this is a very handy text initializer here where you can pass in a date and then it will be formatted nicely and then let's push all of that to the leading edge to format this a bit nicer let's give it eight points of padding let's give it a blue background let's give it a white foreground color to have a nice contrast to our blue background let's clip all of this so it's handled as a single view because now we will apply a shadow with a radius of 5 points if we were to not apply the clip modifier like this then the shadow would be applied to each individual sub view of our age stack but we only want the shadow once for the entire hdac so we need to clip everything into a single view okay next up we want to display a list of all of the currently open to do's or all of the currently available to do's for that we will create a for each and for now we will just feed this with random numbers we will not even use them we will just say underscore in because we don't even care about these numbers in the for each let's create an h stack with a circle this will basically be the indicator if the todo is already completed or not and here actually we don't need to say id we need to say self as the identifier we don't want the full circle we only want to stroke its border so we will say stroke with a line width of two let's scale this a little bit with a frame of 30 by 30. we don't care about the alignment since it's just a single circle and then let's overlay something here we want to overlay basically a little check mark if the todo is already completed so we will say if true for now since all of this is just mocked if true we will have an image with the system name of check mark okay so that's the first part of our rows next we want to add the todo title okay and then let's push everything to the leading edge with a spacer let's give this whole thing a bit of horizontal padding and then also add a divider underneath okay now that we have implemented both the large and mediumsized view let me run them on the simulator and show you how they look okay so the simulator is now running and you can already see our medium size widget here so all of this is a group box up here you can see our label that we added at the bottom here then there's this scaled system image that to do title and that it is already completed and if we swipe over to the next side we see a tiny bit of an issue with our large size view and that is because we have too many lines or too many cells here so let's reduce that to six and run it again and have a look okay this is already looking a lot better so we have our header here the only thing that i forgot to do is to add a little spacer below or for each so we don't have that white space at the top there so let's add the spacer here let's run this one last time okay and there you can see now the ui looks exactly how we wanted it we have our header here with the blue background and a tiny bit of shadow at the bottom here if you can even notice it then we have the title of my todo's and the current date then of course we have our rows of our different todo items as you know all of these are mocked right now okay in the second part of this lesson we will have a look at deep links so basically we want the user to be able to tap somewhere on the widget and then open up a specific piece of information inside of the app to achieve that there are a few steps that we need to take first of all we need to set up the target url in our widgets using either the widget url modifier on the entire ui or using specific link views for example for our rows here inside of the for each and then we also need to handle the on open url modifier inside of the main app that basically handles what the app displays when it gets opened through a widget url or any kind of deep link for that matter first of all we will have a look at the widget url modifier because it's a tiny bit easier to use for that we just have to add it as the last thing in our medium size view so the widget url modifier which needs a url and we will construct that right now from a string i will tell you about this once we yeah basically parse the url in the main app then you will see how all of this works basically what i usually do as the scheme i will just say the app name so just my app in this case colon slash slash then the different routes basically so here we'll have slash to do slash and then the identifier of a to do which we will later on get dynamically from our timeline provider right now i will just hard code this to be one okay and that's already the widget url modifier this is all we have to add to our widget to open a specific thing inside of our app or to at least tell the episode because right now the app doesn't handle anything befo before we do that let's have a look at the link view for our large size view for that we will grab our entire h stack here copy it and embed it in a link with a destination url and then as the label we will just paste back in the hdac and now you can already imagine this url is basically the exact exact same thing as before but the main difference is in the widget url modifier you can pass in an optional url which is uh happening here because the string initializer always gives back an optional url but in the link view you will need to pass in a nonoptional url so we will have to false unwrap this here in a real application you might not want to do that you might want to construct a url at a different place be sure that it exists and then pass it into your view for now in here we can basically put the exact same url as we had in our medium size view once again this identifier here is hard coded right now we will replace this with the identifier of that specific todo item later on all right that's already everything that we need to set up in our two widget views so we can close those up now and we have to move into our main app in our content view now we will now have to add the unopened url modifier at the end of our content view here and this basically gives us a closure passing in the url that the app called when it was opened from a url this is basically not called when the app is launched regularly this is only called in our case if the app is launched through the widget so if the user tapped on the widget then this closure here will get called and now our task is it to parse the url make sure that it's in the correct format download the data that we want to display and then display that data so first of all let's make sure that this url is correct so we will have to check if the scheme is correct and the scheme in our case needs to be my app so if we um one last time we go back into one of our views the scheme is basically this right here in a web url this would be https for example next up we will have to check that the host is to do url.host equals to to do that's basically this route that i mentioned before and then lastly we need to extract the identifier so let's say that id equals an int from our urls path component number one so let's just say path components at the position one and that will be the number here at the very end which we hard coded right now but will then be filled in from our actual todo's now that we have all of that um let's make sure that in case any of this is um yeah is not working we will just return of the closure and do nothing you can also print that there is an issue here in case you want to debug it somehow okay now we have everything that we need basically that's just the id both of these are just arrow checks now i've already told you about this in the first lesson we will use the get to do function of our todo servers i've told you that this is using the new switch concurrency features and that it is an asynchronous function that can throw errors but in the end returns us a single to do with that identifier that we pass into the function so let's use that and since we're not in an asynchronous context context we need to first of all create a task i already told you this function can fail so we need to wrap it in a do catch block and then for now we will just print the error but in reality you should handle the error in an adequate way now let's get to the meat so we want to download our todo from our um yeah our service so let's say let to do equals try to await all of this with concurrency stuff we already talked about this in the first lesson if you want to learn more about this just check the source concurrency um lessons they will be linked down below so we will try to await the to do service we have a shared instance here the get to do function with the identifier that we extracted out of the url here so let's just pass in that id once that finishes once the await is done basically we need to switch back to the main queue because this can happen in any queue and now we want to update our ui so we need to be on the main queue for that and if you remember from the first lesson we have this state of the selected to do here and if we set that to a to do then a sheet will be shown with information about that to do so we can just say selected to do equals our todo that we just loaded with our get to do function okay this was a lot of talking a lot of code let's run it in the simulator and see how it works okay so first of all let's have a quick look at the widget kit chorus app here okay everything still looks good now let's have a look at the medium size widget remember we added the widget url modifier here so you can tap anywhere inside of the widget then the app will open up and it will tell us all of the information about the to do with the identifier one because that's what we always passed in here as a hardcoded identifier and then if we close that again go to the home screen and now over here in the large size widget you will have to have a very um yeah a sharp eye here if you click on the individual cells then they will get highlighted a tiny bit like a button and the app will get open so let me click on the third cell here you saw there was that little subtle button button click animation now the app opened again and we once again see information about the to do number one because that's just what we had coded okay so in this lesson you learned about different size classes in widgets and how to show different ui components for those you also learned about deep links using widget url link and on open url in the main app learn how to provide data to a widget by reusing a service class from the main app and how to schedule that data in the timeline hey code crew this is floor in this lesson we will finally fill up the widgets with some live as we use the existing todo service from the main app we will also fill out the timeline provider and talk about different ways to schedule content for your widget so let's get right into it before we can start filling out the timeline provider we need to do a few setup things as i already mentioned we will want to reuse the to do service in order for us to be able to reuse the to do service in our widget extension it needs to actually be a member of the widget target right now let's open up the file inspector on the right hand side and then under target membership you can see that the to do service is only a member of the main app target so let's also add it to the widget extension this is one of the two files that we need to add the second one is to do itself as you can see we will return arrays of todo's and signal to do's in order to do servers so we definitely also need to have the todo struct inside of our widget extension so let's go over to that file and make sure that it's also a member of the widget extension next up we need to do one more setup step before we can implement the timeline provider and that is adding the data to our timeline entry you already learned about the importance of the timeline entry this is basically what is carried throughout the timeline and provided to your widget by the system at the correct date with the correct information the date is already specified here which is a requirement from the timeline entry protocol now let's also add the information and that's the to do's that should be shown at a specific date in our widget so let's just add a todo array here to our simple entry now we can actually use this entry to schedule updates in our widget using our timeline provider so we can close the simple entry here you can also close the todo over here as you can see now it doesn't compile anymore because we changed the requirements for our simple entry it now needs a date but it also needs a to do so let's try to fix all of these issues and at the same time i will explain you how each of these functions work briefly let me explain to you the placeholder function and actually let's not make me explain it to you let's just have a look at the definition oops the definition of the timeline provider and then you can see there are very very long descriptions of each of the functions for the placeholder function the getsnapshot function and the gettimeline function the placeholder function provides a timeline entry representing a placeholder version of the widget this is for example used when you display when your widget renders for the first time it can also be used in a widget gallery but i think there they actually use the get snapshot function now so basically we don't really need to care about what we return in the placeholder function as it's just a placeholder while the actual widget is loading so let's add the todo's here to our simple entry and to make life easy for us let's create an extension on to do to create some preview or some placeholder to do's with a given id so let's go back into the to do definition let's create an extension of to do and in here let's create a function called placeholder that takes in an id which is an integer and returns a to do for us and now we can use this in our um get place or in our placeholder function and also in other places later on for example for previews the function is really easy just construct a todo here using any user id it's just a placeholder really doesn't matter what's important is that the id is unique because the todo is identifiable we have a list iterating or for each iterating of all of the to do's in our large size widget so it is important that the ids are unique and that's why we're passing in a id here in the placeholder function let's just pass that right into the to do for the title let's just say placeholder and for completed let's just say a random boolean so either one or two either true or false okay now that we have this placeholder function back in our provider we can now use that placeholder function here to fill out our list of to do's let's make one with the id 0 and one with the id 1 and then that should be good in our placeholder function here next up is the get snapshot function here we also have to create a simple entry or one single entry but instead of returning it like we're doing in the placeholder function we need to call the completion handler with this entry so very similar but now this can actually be called on your actual widget so we cannot use placeholder data here anymore instead we will use our to do service to get all to do's for that let's remove everything that is autogenerated here and since our todo service uses the new async await pattern let's directly start off by constructing a task so we can use asynchronous stuff and i can already spoil it to you we will also need to catch some errors so we can also directly add a new catch block here now inside of the do block let's fetch the todo's from our todo service so let's say let to do's equal try to await to do service dot shared dot get all to do's you already know this we already used this or i already explained to you how this works next up let's construct a simple entry so let's say let entry equals a simple entry with the date of now and to do's of the todo's that we just fetched here and then let's call the completion handler with that timeline entry so let's just say completion with the entry in the catch case however we also want to call the completion block this case this time let's also return some placeholder so let's just say completion simple entry with the date of now and to do's we will just use placeholder zero now you can see here that the instance member placeholder cannot be used and that's because we forgot to say that this is a static function so we can directly call it on the type to do instead of a specific instantiated to do now these errors should also go away okay awesome now the last part which is also the most interesting and most important is the get timeline function let me remove everything and then let's go through the function step by step so you understand how it works similar to before we also have a completion handler but this time the completion handler doesn't accept one entry it actually accepts a timeline of entries that timeline is a collection of entries like an array but it also has a refresh policy that's the last thing that we will handle when setting up this get timeline function first of all let's do the same setup as before we know we're going to use the to do service so we will need a task we also need a do catch block inside of the do block let's fetch all to do's once again so let's say let all to do's equal try await our to do service dot shared dot get all to do's this is the exact same stuff as before then let's actually do a little trick here if you remember in our widget ui we will show a bunch of different todo's in our large size view this ui is meant for small amounts of data not for large amounts of data the ui will break if you pass in let's say 50 to do's because then the top bar will get pushed out of the screen so we will just um use the first five to do's that we get from the service so let's say let five to do's equal an array oops an array of our all to do's dot prefix of the length five this will give us the first five entries of the all to do's array that is not actually returning an array it's returning an array slice but we need an array so we will construct a new one here next let's also create a timeline entry so we will just create a new simple entry for the date of now with our five todo's in it up until now this is very similar to the get snapshot function and actually we should probably use this prefix 5 approach in the get snapshot function as well so let me copy it over and do it like this okay to make sure that the guest network function also doesn't break the ui okay so now we have our todo's we have our simple entry now what we need is a timeline and there are a couple of different ways to do this now one way is to create a bunch of different entries for example for right now in one hour in two hours and five hours and so on and pass all of them into a timeline and tell the timeline timeline to refresh once nothing is left in it anymore so in our case in five hours or what we are going to do construct a timeline with a single entry and tell it to refresh after some specific date has passed the idea is basically if you have content that you can already schedule right now throughout the day for example if you already have the users calendar you can schedule the whole calendar widget for the whole day but if you rely on live data that you download from the server which is what we're doing in our todo servers then it is always a good idea to only schedule one or two maybe three timeline entries and then force the timeline to refresh that way you will always have the most uptodate information so we will do the later we will create a timeline and this will accept an array of entries so we will just create an array with our single simple entry in it and then for the policy you can just hit dot as this is an enum very handy you can see there are three different reload policies the first one is at end so the timeline would reload when no more entry is left the second one is never i think this is very safe explanatory this means that the app itself will never reload the timeline but however it will get reloaded sometimes for example if the user restarts their phone adds or removes the widget things like that the system decides when the timeline is really reloaded you only tell the system your preferences basically as the developer and then the last one is after a specific date which is what we will use and the date that we will use is now advanced by basically 60 seconds times 60 times 30 so basically every 30 minutes this timeline should get refreshed in practice this will probably not happen every 30 minutes since timelines only get refreshed when the user is actually on their home screen so if the user has their device in standby for a few hours then the widget will never get refreshed and will only get refreshed once they view the home screen again okay and now the last thing let's call the completion handler with our timeline again okay now in the catch block we will just have our placeholder data once again for that let's create some timeline entries this is just an array of simple entry just uh one for now so let's say the date is now and the to do's is dot placeholder with the id 0 just one for now doesn't really matter hopefully this catch block will never take place then let's also create a timeline which is just a timeline with the entries array and with the reload policy we will just copy over the one from up here basically what this would mean is that after 30 minutes try again to build a timeline okay and then let's pass the timeline to the completion handler as well and with that our timeline provider is already done now let's use all of these pieces of data that we pass into the simple entries inside of our actual widget views to do that let's go to the medium size view okay in our views previously we hard coded all of the data like the to do title and whether it was completed but also the to do id down here in our deep link url in the medium size view we only want to show one to do so to do that let's grab the v stack let's cut it out and in here let's say if let to do equal our entry dot to do's dot first we will just access the first to do and let's paste back in our v stack now in here instead of this hard coded string let's say to do dot title instead of the completed let's say to do dot completed let's use the ternary operator here so let's say if the to do is completed we want to say completed and else we want to say that it's open as this is a unwrapping of the first object it might be nil so there might not be any todo's in the simple entry for example because we couldn't fetch any from the server because we succeeded to fetch from the server but the server just returned an empty array in this case with the json placeholder api this should never happen but in your main app you might want to put an else block here as well and then display some error state you could for example say couldn't load to do's try again later or something like that okay now let's also replace the hard coded id here in our widget url for that let's say entry dot to do's dot first dot id this is optional but we can't have an option in here so we will have to provide an alternative basically and we will just null coalesce it with zero okay that's it for the medium size view let's jump into the large size view as well okay in the large size view now if you remember we had this hard coded zero through six range let's get rid of that and instead let's say entry dot to do's we don't need to provide an identifier because we did mark our todo as identifiable itself and does have the id property okay let's go top to bottom here so the first thing that we need to replace is the id in our deep link for that we can just say to do dot id and we actually need to grab the todo in in our for each for that to work then we had our if true here this of course should mean if to do dot completed only then we want to show that the check mark on top of the circle and then i want to do the title also let's grab that one from the actual to do okay that should be it let me spin up the simulator and let's have a look at if everything works if we can see all of the todo's and if the deep links still correctly link into the app okay so as you can see it doesn't quite compile yet and that's because we still have our preview down here which doesn't have the updated simple entry initializer so we also have to pass in some to do's into our little swift ui preview here and let's also just use the placeholder function for zero and then also another one for one and i think this should be it now yep looks good let's compile now and see if it runs okay so the simulator just launched and i added all of the widgets first of all here you can see the medium size view it fetched one of our todo's and if we tap on it then the app will open up and the little cheat will come up with some more detailed information about that to do and if we go back to the home screen and move over then we can see our large size widget which also fetched the last five to do's as we specified using the prefix operator and if we tap on any of these to do's then the fitting section will also open up and show up in the sheet because we passed down the correct id in the deep link this was the final lesson of the threepart widget kit course in this series you learned all the basics about widget kit how it works the way updates are scheduled multiple size classes reusing existing code and deep linking into your app use your existing widget kit knowledge to create a lock screen widget for ios 16. hey code crew this is flow in this lesson you will take your existing knowledge of widget kit and bring it to one of the biggest io 16 features lock screen widgets you will learn about the new size classes that got introduced and how widgets work on the lock screen and just a quick disclaimer right now i'm using the xcode 14 beta version which you can find the download link of right below this lesson the actual full version of xcode 14 will be out later this year i would guess that it will happen about in september until then you will have to use the xcode 14 beta because we are using ios 16 apis so of course we need the ios 16 sdks as well which are part of the xcode 14 beta i think you got that point so let's jump right into it first of all let's quickly recap how widget kit works and what you have already learned in this course so a widget just like a swift ui app has an add main annotated struct it's not an app it's a widget and in here you have a body of widget configurations in this case we just have a static configuration with our specific view inside which is just called a widget view this configuration always has a name which is just a string or also called a kind and also a timeline provider which is our provider that we had created so let's look into that next the provider is or conforms to the timeline provider protocol which has to implement three different methods the placeholder method for the widget gallery the get snapshot mesh method and the get timeline method we have already implemented all of these in the previous episodes or in the previous lessons of this course so if you're unsure about how any of this works just go back a few lessons and rewatch them the timeline provider basically schedules timeline entries for our widget view so next let's have a quick look at our simple entry so we have a struct called simple entry that conforms to the timeline entry protocol it always has to have a date associated with it so it can get scheduled by the system and then in our case we also pass in some todo's that we got from our todo api so let's look at a todo there's also just an identifiable and decodable struct it has a user id an id to make it identifiable a title and a flag whether it's completed yet or not and now if we go back to our timeline provider you will see that we use our to do service dot share dot get all to do's function that does something in the background doesn't really concern us in a widget here and then we get back to do's and we only take the first five of them that means that when a widget is shown to the screen it always has a entry associated with it and that entry always has five todo's associated with it as well and then all of that data is displayed via the widget view which is just a plain old swift ui view it has the timeline entry so we had it here specified via provider.entry but the actual type of this is let me add that as well aka simple entry so the provider.entry that's basically a generic so the entry is a generic type of the timeline provider which is then during compilation resolved to be a simple entry um if we have a look at our provider then you will see we always return simple entry instead of just any timeline entry so this is basically his associated type doesn't really matter right now at all and then in addition to the simple entry we also grab the widget family which is basically the size class from the switchoi environment and then display different views depending on which size class this got passed to or is displayed in actually so right now we only implemented the system medium and the system large size class in our widget view and if we have a look back into our widget and you can see we have added the supported families modifier and passed in the system medium and system large size class let's start adding the lock screen widgets this is actually super simple and the only thing that you basically have to do is to add three new supported families so let's get started by just hitting dot and pressing a and then you will see that there are three new accessory families added there is accessory inline which is the section above the time on the user's lock screen there is accessory circular and there is accessory rectangular which are the small and the wider widget sections below the user's time on their lock screen now xcode is yelling at me because let's expand this error here the new accessory widget families are only available in application extensions for ios 16 or newer and that's because we haven't updated or we haven't set the deployment target to ios 16. it's still at ios 15. so let's jump into our xcode project file select our target and for the ios version let's scroll up to 16.0 and i think for the widget we also need to select that yeah so select the widget extension and then scroll up to ios 16.0 and now that error should go away in a second once xcode decides to reevaluate it and there it goes it's away okay so all you had to do to support a new widget was adding these three new supported families now if you if we jump back into our widget view you will remember that we switched over the widget family and we only had two cases for the medium and the large size class in any other case this default case would be run which is a text saying not implemented that's of course not really nice so let's replace that and add some new widget ui here so let me clear this up a bit let's add the new cases for the new accessory inline accessory circular and the last one accessory rectangular widget families now as i just said inline is the one that's still displayed above the user's current time on the lock screen and circular and rectangular are displayed below the current time for the inline one i would recommend you to only add text and i think that swift ui is actually smart enough to remove anything from that widget that's not text so we will just add a text of our entry dot to do's and we will grab the first one and just display its title now first here is an optional so we will have to optionally unwrap that or a new coil as that that's what the operator is called and just say no to do's if there is no first to do in that list so that's super simple and then for accessory circular and accessory rectangular i will actually use a new view that was also added in swift ui on the iphone at least with ios 16 i think it already existed on the apple watch for complications and that's the gauge so we will just for the circular we will just add a gauge with a value and a label and as a value we can for example say the number of todo's that were completed divided by the number of todo's that are not completed yet in those five that are in our timeline entry you could calculate calculate that um an easy way to just try all of this out is to just set any double value so 0.7 in that case a gauge always goes from zero to one so that's basically a you know like a progress view you can imagine it to be like that but we will have a look at it on the lock screen in just a second anyways so let's expand this um label closure here and in here we can just put anything that we want and i will just put a text with our entry the date and also let's format that a bit so let's say that date time and we just care for example about the year and that we will have a gauge displaying 0.7 and then the label will be the date of this timeline entry but only the year of that date and then for accessory rectangular let's actually use the exact same thing as for accessory circular let's copy paste that and then let's also um i had some god our gauge styling here so there are a few different gauge styles that we can add and since we're currently an accessory circular let's just use the accessory circular gauge style and then also the one for rectangular so accessory linear in this case okay let's give this a run and have a look at how it works on the user's lock screen okay so the app is now installed on the simulator so we can just press command l to lock the simulator and then press this little house icon here again to go back to the lock screen just press and hold on the lock screen and hit customize at the bottom then you will see that there are three different sections that can be customized by the user the top section which has the accessory inline widgets the center section which just has the time the user cannot really customize this they can only change the font and the font color i think and then the bottom section for accessory circular and accessory rectangular so let's start at the top let's press on the first section and then we can scroll down until we are at the widget kit course app and let's select that widget and then you can see this is probably the title of the first dummy to do that we had in our yeah that we got from our api service and then let's do the same with the bottom section so let's remove this calendar widget here and then if we scroll down to the widget course we can select it and the user will be able to see all of the available lock screen widgets which in this case is the accessory circular which is this gauge with a value of 0.7 so that's about right and then as a label it has the current year because that's the the text that we added here so let's select that first and then we also have the accessory rectangular and now a very interesting thing is happening here the gauge looks completely different of course because we gave it a different gauge style but it also does not show its label so we'll have to keep that in mind when you're using the gauge view not entirely related to just widget kit and lock screen widgets but just in general keep in mind how the gauge view works so let's also add that and you will see the rectangular widget is a lot larger about twice the width of the circular widget so let's exit out of all of this let's hit done and select this lock screen and then you will see that we have all three of our widgets that we just created here right on the user's lock screen so in this lesson you learned about io 16's new lock screen widgets
