With timestamps:

00:00 - hey cooker today you're going to learn
00:01 - how large iOS development teams work
00:04 - together to produce large and complex
00:06 - apps such as Instagram YouTube and
00:08 - Spotify now how do multiple developers
00:11 - work together on the same code base
00:12 - without overriding and destroying each
00:15 - other's code and how does a developer at
00:17 - his or her code without accidentally
00:19 - destroying some functionality in the app
00:21 - and finally how do you organize and keep
00:24 - tidy thousands of lines of code written
00:26 - by multiple developers while today I'm
00:28 - going to answer those questions and more
00:30 - so stay tuned
00:35 - hey there I'm Chris and welcome to code
00:38 - with Chris where we're going to teach
00:39 - you how to become a developer through
00:41 - building iOS apps now as a single in the
00:44 - iOS developer you can do some pretty
00:45 - cool things and there are a lot of
00:47 - successful indie apps in the App Store
00:49 - but on the other hand as a single
00:52 - developer you are limited by the scope
00:54 - and scale of the apps that you can build
00:56 - because at the end of the day we're all
00:58 - limited by the fact that we have 24
01:01 - hours in a day a lot of the mass
01:03 - audience large-scale apps in the App
01:05 - Store are built by teams of people
01:07 - testers developers designers product
01:10 - managers you name it now how do all of
01:12 - these people work together to produce a
01:15 - single app well today we're going to
01:16 - look at some of the unique problems that
01:18 - teams face and how they overcome them
01:21 - but before we dive in I just want to
01:23 - give a shout out to circle CI comm who
01:25 - has the sponsor of this video they
01:27 - enable large teams to work together
01:29 - efficiently to produce awesome apps
01:31 - through their continuous integration and
01:33 - delivery services now these two
01:35 - processes are something that is very
01:37 - important for large teams to collaborate
01:39 - through and we're going to touch upon
01:41 - them later on but for now let's take a
01:43 - look at large team problem number one so
01:46 - how do multiple developers work together
01:48 - on the same Xcode project
01:50 - the answer is source control and in this
01:53 - case source refers to source code now
01:56 - there are many different source control
01:58 - management systems out there but one of
02:00 - the most popular ones is git and github
02:03 - is a popular choice for git repositories
02:06 - in the cloud
02:07 - now here's a quick rundown of how it
02:09 - works the git repository or git repo for
02:12 - short contain
02:13 - the master copy of the code the repo
02:16 - also keeps track of versioning of the
02:18 - code let's say it's version 1 right now
02:19 - when you want to work on the project you
02:21 - check out a copy of the code it's kind
02:24 - of like checking out a library book in
02:26 - this case you've made a local copy of
02:27 - the code this is also known as pulling
02:30 - the code another developer let's call
02:32 - her developer B can also check out the
02:35 - code and make a local copy on their
02:36 - machine you're both working on your
02:39 - local copy of the project and maybe you
02:41 - finish your work first let's say you
02:43 - have to fix a bug in the project and you
02:44 - nailed it the next step is for you to
02:46 - commit your code back to the master repo
02:48 - you can and should attach a message to
02:51 - say what you changed and why you changed
02:53 - it when you send your changes back to
02:55 - the repo the message you wrote will be
02:57 - attached to that change now this is
03:00 - known as committing or pushing or
03:02 - checking in your code different people
03:04 - will like to use different terminology
03:06 - now let's say developer B has finished
03:08 - her change and she's ready to check in
03:11 - her changes back into the repo as well
03:13 - but there's a problem because after you
03:15 - checked in your code to the repo you've
03:17 - essentially changed the master copy of
03:19 - the code and now it's out of sync with
03:21 - her local copy that she checked out
03:23 - earlier now developer B doesn't have any
03:25 - of the new code that you checked in so
03:27 - if she were to blindly check in her
03:30 - version back to the repo she would
03:32 - essentially be overriding your code
03:34 - luckily source control would detect that
03:36 - the master copy has changed since
03:38 - developer B last checked out the code so
03:40 - it's not going to let her commit her
03:42 - code developer B has to do a merge which
03:45 - involves getting the latest copy of the
03:47 - code from the repo merging it with her
03:50 - local copy fixing any errors that may
03:52 - arise from your code conflicting with
03:54 - her code and then after resolving any
03:56 - issues to commit the merged code back to
03:59 - the repo if you and developer B happen
04:02 - to work on the same file and same lines
04:04 - of code then there might be a conflict
04:06 - in which developer B needs to manually
04:09 - decide how to merge your code with hers
04:11 - now as you can see this merge process
04:13 - can sometimes get pretty complicated and
04:16 - you're gonna have to be careful not to
04:17 - overwrite anyone elses changes when you
04:20 - merge their changes with yours now
04:23 - imagine a team of 10
04:25 - 20 or 30 developers all checking out and
04:27 - committing code a source control
04:29 - management system makes sure that
04:31 - everyone can work on the same code base
04:32 - without accidentally overwriting each
04:35 - other's changes but to have so many
04:37 - people writing code also means that it's
04:39 - hard for one person to know the whole
04:41 - project inside and out and as a result
04:43 - any one developer might accidentally
04:46 - write code that introduces bugs into the
04:48 - app and this brings us to large team
04:50 - problem number two when a developer
04:52 - commits his or her code to the master
04:55 - repo how do they make sure that
04:56 - something isn't broken large projects
04:59 - can be thousands of lines of code so
05:01 - it's only natural that bugs can crop up
05:03 - unintentionally and this is where unit
05:05 - testing comes in unit testing is a
05:08 - process by which you write code to test
05:10 - your other code here's how it works you
05:13 - break down the code in your app into
05:16 - units that make sense let's say you have
05:18 - a chunk of code that creates user
05:19 - accounts now typically this code gets
05:21 - run after the user enters in their info
05:24 - from a form in the app but since you
05:26 - want to wait to test this chunk of code
05:27 - at will you'll write a test case this
05:30 - test case called a unit test will
05:32 - attempt to create an account with some
05:33 - dummy data now you can run this unit
05:36 - test and if it suddenly fails then you
05:38 - know that the unit of code that creates
05:40 - accounts is not working now imagine you
05:42 - write these unit tests for every chunk
05:44 - of code that does something in your
05:46 - project you'll end up having a suite of
05:48 - these test cases that you can run
05:50 - anytime you want to see if something in
05:52 - your project isn't working now it won't
05:55 - catch every single bug but it acts like
05:57 - a baseline and it's your first line of
05:59 - defense and once you write all your test
06:01 - cases and it's all set up you'll have an
06:03 - easy way to test that baseline now when
06:06 - a developer checks in some code you can
06:08 - run these unit tests as an easy way to
06:10 - screen if some baseline functionality
06:13 - has been broken as a result of that new
06:15 - code all right so you've got source
06:18 - control management and unit testing as
06:20 - tools to help large teams work together
06:21 - but here's another problem
06:23 - now just like handwriting every
06:25 - developer will naturally have a slightly
06:27 - different coding style so won't the code
06:29 - file that is written by multiple
06:31 - developers be really hard to read and
06:33 - this brings us to a large team problem
06:35 - number three how do multiple developer
06:38 - maintain a consistent coating style well
06:41 - first the team establishes a set of
06:43 - coding conventions or a style guide now
06:46 - this can be as detailed as saying if the
06:48 - opening bracket of an if statement
06:50 - should be on the same line as the if
06:52 - keyword or on the next line and it can
06:54 - also say things like how many line
06:56 - breaks should be in between methods in a
06:59 - class the more detailed you can be the
07:01 - more consistent your code base will be
07:02 - now in order to enforce these coding
07:05 - conventions across a large team there
07:08 - are tools out there that can scan the
07:10 - code and then I can tell you any lines
07:12 - of code which are not adhering to the
07:14 - style guide or the coding conventions
07:16 - that you set forth these tools are
07:18 - commonly referred to as lint or lint or
07:21 - tools now there are a lot of free lint
07:24 - tools out there and simply using one
07:26 - will ensure that your code base is tidy
07:28 - and consistent now we've talked about a
07:31 - lot of different tools but ultimately
07:33 - who is in charge of running these tools
07:35 - and a team well in the ideal case each
07:38 - developer would a make sure that before
07:41 - they check in any code into the master
07:43 - repo that they pull down the latest
07:45 - version and they merge any changes
07:47 - properly and I say properly because
07:50 - merging isn't always a trivial process I
07:53 - mean you're trying to merge your code
07:54 - with someone else's code that you didn't
07:57 - write and you have to take the time to
07:59 - understand what they wrote what their
08:01 - intentions were and merge it with your
08:03 - code in a way that doesn't cause
08:05 - conflicts or unintended behavior and be
08:08 - before they check in their code they
08:10 - should make sure that all of the unit
08:12 - tests still pass just in case that the
08:15 - new code or the change that they wrote
08:17 - breaks something else and see before
08:20 - checking in their code they should run
08:22 - the lint tool and fix any code that
08:24 - doesn't conform to the style guidelines
08:25 - set forth by the team now even if a
08:29 - developer does all of this and has the
08:30 - best intentions we are all still human
08:33 - and mistakes will happen code will be
08:36 - improperly merged builds will break
08:38 - tests will fail and bugs will crop up it
08:41 - would be a full-time job for someone to
08:43 - continuously monitor the codebase and
08:46 - make sure it's in tip-top shape after
08:47 - each time a developer checks in code
08:50 - well fortunately we don't need
08:52 - to do this and this is where something
08:54 - called continuous integration or CI for
08:56 - short comes in real handy continuous
09:00 - integration is a system that monitors
09:02 - the master repo and runs various checks
09:05 - and balances to ensure that the master
09:07 - code base is in tip-top shape the CI
09:10 - process is highly configurable and it
09:12 - can automatically do things like build
09:14 - the project to make sure it runs run the
09:17 - test suite to ensure that all of the
09:18 - unit tests pass run a lint tool to check
09:21 - for code that doesn't adhere to coding
09:23 - conventions and it can even do more than
09:25 - that such as send a successful build to
09:28 - a QA environment or deliver it to iTunes
09:31 - for deployment into the App Store it can
09:34 - do all these things automatically by
09:36 - running on a specified schedule or
09:38 - running whenever someone checks in code
09:40 - if the CI process finds a problem the
09:43 - appropriate people can be notified
09:44 - immediately to fix the problem like
09:47 - maybe if the build is broken after the
09:49 - last code check in or a unit test no
09:52 - longer passes or maybe the newly checked
09:54 - in code fails the Lin tests knowing
09:58 - about any issues right away is crucial
10:00 - especially with a large team because so
10:02 - much code is being written per day that
10:04 - it can quickly pile up on an issue and
10:06 - it can take a long time to unravel the
10:08 - issue if it remains buried a continuous
10:11 - integration system lets the team work
10:13 - confidently and stay focused on coding
10:15 - because developers know that the CI
10:17 - process will catch any mistakes as soon
10:19 - as they happen continuous integration
10:21 - often goes hand-in-hand with continuous
10:24 - delivery which is a process that can
10:26 - automatically send builds to different
10:28 - environments such as sending the build
10:30 - to a test environment for the QA team to
10:33 - test out some new features circle CI is
10:35 - one of these platforms that can do all
10:37 - this and more now we're going to do a
10:39 - demo and I'm going to show you and put
10:41 - into practice everything we just talked
10:42 - about we're going to start a new Xcode
10:45 - project and we're going to commit it to
10:47 - a source control management system now
10:50 - git is a popular choice and it's a great
10:52 - one for us to use because there's tight
10:53 - integration for it within the Xcode IDE
10:56 - however we're going to use github so we
10:59 - can actually store our git repository on
11:01 - the cloud then I'm going to show you how
11:03 - to write us
11:03 - unit tests and I'll show you how to run
11:06 - it finally we're going to hook up our
11:08 - github repository to circle CI so that
11:10 - every time we push code from our
11:12 - computer to github circle CI is going to
11:15 - get the latest code from the master repo
11:17 - run our unit tests build the project and
11:20 - also used Swift lint to make sure that
11:22 - everything is okay all right so let's
11:25 - dive in all right so we're gonna start
11:28 - our brand-new Xcode project and I'll
11:30 - show you how to put it on github so our
11:32 - first step is to create our Xcode
11:34 - project so go ahead launch Xcode let's
11:37 - create a brand new Xcode project I'm
11:39 - going to choose a single view app here
11:41 - and for the product name I'm just gonna
11:43 - call it large project because that's
11:47 - what we're talking about right now the
11:49 - important thing is to include unit tests
11:52 - because I want to show you guys how to
11:54 - write a sample one and run it and go
11:58 - ahead click Next you can save it
12:00 - wherever you want I'm gonna put it on my
12:01 - desktop now what's also important is to
12:04 - check source control here it's gonna
12:07 - create a git repository on your Mac
12:09 - don't confuse this with github this is a
12:12 - local git repository it's still source
12:15 - control the only thing is that that repo
12:18 - is stored on your machine now as a
12:21 - single developer this might be fine but
12:23 - you do have to think about the risk of
12:25 - potentially your hard drive failing and
12:28 - then you'll lose your code so it's
12:30 - always a good idea to put that on github
12:32 - and I'll show you how to do that so go
12:34 - ahead and enable this for now click
12:37 - create and here we are we have our
12:40 - sample project the next thing we're
12:43 - going to do is to sign up for a github
12:44 - account if you don't have one already
12:46 - and the great thing is that private
12:48 - repositories are free now it used to be
12:51 - that only public ones who were free so
12:54 - all your code would be public but now
12:56 - even private repos are free as well so
12:59 - you don't have to pay anything so sign
13:01 - up for github go to github com if you
13:04 - haven't gotten an account if you do then
13:07 - you can move on to the next step which
13:09 - is hooking up Xcode with your github
13:13 - account and the way you do that is you
13:15 - go
13:15 - - Xcode preferences and you can see here
13:20 - I have my account hooked up if you don't
13:23 - have this go ahead click this plus icon
13:25 - here and just choose github from the
13:27 - list and it's going to ask you for your
13:30 - account and password so you want to go
13:32 - ahead and do that so that you can
13:34 - integrate X code with your github
13:37 - account and so you can push code and
13:39 - pull code back and forth very very
13:42 - easily so after you do that the next
13:45 - thing we're going to do is to put this
13:47 - large project into our github account
13:50 - and the way you can do that is you can
13:54 - go here this is where you can look at
13:56 - all of your source control Navigator
13:59 - this what it's called and you can
14:02 - actually go under branches if you're not
14:07 - aware you can have different branches or
14:09 - versions of your source code and you can
14:12 - choose which ones to pull from and which
14:16 - ones to send code to initially you're
14:19 - only gonna have master and we've only
14:20 - really talked about master but starting
14:23 - a separate branch might be good if you
14:25 - want to test out a new feature or you
14:27 - want to maybe tinker with something that
14:29 - you're not sure you want to put into the
14:32 - master just yet so at that point it
14:35 - could be helpful to create a separate
14:38 - branch or separate version of your code
14:40 - at that point tinker with that and then
14:43 - depending on if it fails or you want to
14:46 - add it to the master you can always
14:47 - merge it back into the master branch so
14:50 - usually we just have our master branch
14:53 - to start so in order to put this whole
14:56 - project on github you go to this node
14:58 - right here and you right click and say
15:01 - create large project remote and remote
15:03 - means just off of your computer into
15:06 - github
15:07 - you've choose the account so hopefully
15:09 - you've added your github account through
15:11 - your Xcode preferences you're gonna give
15:13 - that repository a name alright so you
15:15 - can see here that this is ultimately the
15:17 - URL where that repo will live you can
15:21 - give it a description you can always
15:22 - edit this after I'm gonna set it to
15:24 - private right and then I'm just going to
15:26 - create it
15:28 - and then you can see here this is
15:29 - pushing its pushing the code to github
15:32 - and then now we can just jump into
15:35 - github and this is my github account
15:38 - here so you can see that when i refresh
15:42 - the page there it is this little lock
15:45 - represents that it's a private
15:46 - repository so you can see here that's
15:48 - the initial commit I've got a bunch of
15:51 - files here this is my actual project
15:54 - this is my tests and you can see that it
15:57 - mirrors what I have here okay so that's
16:00 - really cool because now whenever we
16:01 - write new code we can push it to github
16:03 - and in case our hard drive gets fried
16:05 - our code is safe on github now what I
16:09 - want to do is just run through quickly
16:12 - at a high level unit testing how to run
16:15 - test cases for your project and we're
16:16 - not going to really dive deep into
16:18 - testing theory or writing a lot of
16:21 - meaningful tests because the point of
16:23 - this video is to show you the overall
16:24 - process alright so you'll notice that we
16:27 - have large project tests here and if you
16:30 - click into this file here you'll see
16:33 - that we have this class large project
16:36 - tests there are a couple of methods here
16:38 - set up teardown and here is a single
16:42 - test case sample so you can also run
16:46 - performance tests but in this case we
16:48 - are not going to do that I'm just going
16:50 - to show you how to do simple functional
16:52 - testing to test the functionality and
16:55 - correctness of your code so let's go
16:57 - ahead and erase this performance test
16:59 - and we are just going to focus on this
17:01 - test sample now what we've got here is
17:04 - we've got one test case and then we've
17:07 - got our setup and teardown methods so
17:09 - these two are going to be called before
17:12 - and after every single test case now
17:15 - they're basically there just in case you
17:17 - need to write a whole bunch of setup
17:19 - code just to get to the point where you
17:21 - are able to write some code to run your
17:24 - tests and teardown is going to be called
17:26 - after every single test case in case you
17:29 - need to deallocate memory or do any sort
17:31 - of cleanup or put things back in place
17:34 - essentially so what we're going to do
17:36 - here is write a very very trivial test
17:39 - case because our
17:40 - at this point doesn't really do anything
17:42 - but I still want to show you the process
17:43 - of running failing passing tests so I'm
17:48 - going to just create a simple simple
17:50 - variable here let's say let a equal zero
17:53 - and then you know you wouldn't put that
17:55 - there you would put whatever code you
17:57 - want it to test let's say of creating
17:59 - accounts we mentioned earlier you might
18:02 - test passing some dummy data into that
18:05 - code that creates accounts and then you
18:08 - would then want to assert a certain
18:11 - outcome that you expect so the way we do
18:13 - that is we use xct assert and there are
18:17 - different methods here you can check if
18:20 - the outcome is nil if it's true if it's
18:22 - false if that's equal to something but
18:25 - basically the idea is that you run some
18:27 - code right to test something and you
18:31 - have an expected outcome and you use
18:33 - this to assert that that is actually the
18:36 - outcome that you've got in our case I'm
18:39 - gonna write each reveal statement here
18:42 - we are going to assert that I is equal
18:45 - to zero and then if it's not this error
18:48 - message or this message is going to get
18:50 - displayed is you know so that's going to
18:56 - be the message that gets displayed if
18:57 - that isn't true now how do we run this
19:00 - simple unit test there are several
19:03 - different ways you're gonna see some
19:04 - diamonds in this line number column you
19:07 - can run this individual test case by
19:09 - hovering over it and pressing this so
19:12 - I'm just going to go ahead and do that
19:13 - and you're going to see something
19:15 - appeared down here in the console so you
19:19 - can see that it executed one test with
19:23 - zero failures you can eat then these
19:26 - turn to green checkmarks there is also
19:29 - this button here which you can run the
19:32 - differences that hitting this will run
19:33 - all the test cases in this test suite
19:37 - whereas this one will only run this
19:39 - single test case
19:41 - another way is within the test navigator
19:44 - this tab right here you can see that you
19:48 - have your individual test cases here and
19:50 - then another way is actually to hold
19:53 - your
19:54 - over here and instead of building and
19:56 - running your project you would run your
19:57 - tests by itself so those are a couple of
20:00 - different ways
20:01 - now before we check in our changes into
20:03 - github let me show you what its gonna
20:05 - look like if the test fails so let me do
20:08 - that and just change I equals to one
20:10 - this is definitely gonna fail so if I
20:13 - run this test case you're going to see
20:15 - that it's gonna build the project it's
20:18 - gonna fail the test right here so you
20:21 - can see that that statement is not true
20:23 - so I'm going to change it back to zero
20:25 - and then now we're going to push our
20:27 - changes to github so if you go back to
20:31 - the file navigator I want you to notice
20:32 - one thing remember when I said that
20:34 - there was tight integration with git
20:38 - take a look at this we modified this
20:41 - file by changing some of the code we got
20:43 - rid of one of the methods and you can
20:45 - see this M here beside that file that
20:48 - stands for modified and that basically
20:50 - tells you what's changed since the last
20:53 - time you pushed your code to github or
20:56 - your local git repository so if we
20:59 - wanted to commit this code and push it
21:02 - to github we would then right click go
21:05 - to source control and say commit large
21:08 - project tests thought swift when you do
21:13 - this you can fill in a message here to
21:15 - say what you changed why you changed it
21:18 - what it was for and then make sure if
21:21 - you actually want to push it to github
21:24 - the remote repository and not just your
21:27 - local repository you enable this you
21:30 - choose your branch you know what we
21:32 - talked about earlier and we can say
21:34 - added a revealed test case all right so
21:38 - we can commit that file and push it so
21:43 - technically committing is actually a
21:45 - little different from pushing even
21:47 - though a lot of people use them these
21:49 - terms interchangeably committing is
21:51 - saying that I'm done with these files
21:54 - and these changes are related to
21:59 - whatever message that you put whereas
22:02 - pushing is actually the physical action
22:05 - of putting your code into
22:07 - sending it to the repository so you can
22:10 - actually do a whole bunch of different
22:12 - commits locally before you push your
22:16 - code to the repository I know that might
22:19 - not make that much sense for now if
22:21 - you're kind of neat to source control
22:23 - but think of it like a commit is a
22:26 - particular change that you want to make
22:28 - and pushing is actually sending the code
22:32 - to the repo all right so let's go back
22:34 - to our github repository and let's just
22:37 - hit refresh and you can see here that
22:41 - this was our latest push right a minute
22:45 - go
22:45 - whereas our initial project push was 21
22:48 - minutes go in if you actually take a
22:49 - look at here you can see there were two
22:51 - commits right so this was the initial
22:53 - one for the whole project and here was
22:56 - our trivial test case Edition and each
23:00 - one has a version number right so this
23:03 - source control repository or management
23:05 - system knows exactly when something has
23:08 - changed if someone else had checked out
23:11 - the code earlier and they try to push
23:13 - their changes source control is going to
23:15 - say hey and we're at a new version now
23:17 - so you better pull down the latest
23:19 - changes and merge them before you push
23:22 - your code over so that our test case
23:24 - doesn't get overwritten
23:25 - so just to do a quick recap we've
23:27 - created a brand new Xcode project we've
23:30 - put it on github so now actually
23:32 - multiple developers can start working on
23:34 - this project and this source control
23:36 - management system is going to work
23:38 - beautifully
23:39 - however we are counting on each single
23:43 - developer to be diligent in running the
23:46 - test cases and also they have to write
23:48 - the test cases right to ensure that the
23:51 - code they add doesn't break the build
23:54 - and that our app still functionally
23:56 - works this cannot always be relied upon
24:01 - despite the best intentions of each
24:04 - developer and so what our next step is
24:07 - going to be is to hook up our github
24:09 - account or this specific repository with
24:14 - circle CI so that we can get a
24:16 - continuous integration process working
24:18 - so each time a developer
24:21 - pushes code to the master repo circle ci
24:24 - is going to detect at and automatically
24:26 - grab the latest code build it to make
24:28 - sure that it's still build successfully
24:30 - run all of our tests to make sure that
24:32 - they all pass and I'll show you also how
24:35 - to include a lint tool and have that run
24:39 - so that the code can be checked to
24:43 - adhere to the coding conventions of the
24:45 - team all right so let's go ahead and do
24:47 - that
24:47 - so visit the URL on the screen right now
24:50 - or click in the description for the link
24:52 - and you're going to get to the relevant
24:54 - page for building and testing Xcode
24:56 - projects on circle CI start building for
24:58 - free click on that and you're going to
25:00 - be able to sign up with your github
25:02 - account and doing this is going to be
25:05 - good because it's going to automatically
25:07 - give Circle CI access to your github
25:10 - repositories now you can control whether
25:13 - circle CI has access to your public and
25:16 - private repositories or only your public
25:18 - ones so on the next screen you're going
25:20 - to see that and then once you're signed
25:22 - up and you're into the dashboard you
25:24 - should see something that looks like
25:26 - this and you might not have any projects
25:30 - at first or you might see something here
25:32 - but go ahead into the add projects tab
25:35 - and you're going to then jump into the
25:38 - Mac OS tab here then you're going to be
25:40 - able to start two week free trial and
25:43 - there's no credit card entry or anything
25:45 - like that so feel free to give it a try
25:47 - click on start my free trial and then
25:49 - you're going to see your project here
25:51 - now I'm going to refresh the page so we
25:54 - can see what I have here so there we go
25:56 - that's the large project that we just
25:58 - added to our github account so go ahead
26:01 - and click on the blue button to setup
26:04 - your project and this should be
26:07 - automatically detected if it's not you
26:09 - can choose Mac OS and Swift right here
26:11 - and there is only really one thing that
26:14 - we need to do to set this up and get
26:16 - this going and that is to setup a
26:19 - configuration file that tells Circle CI
26:22 - what we want to build what we want to
26:25 - test
26:25 - you know what lint tool we want to use
26:27 - how we want to distribute to build
26:30 - - what environments and all that stuff
26:32 - and so I'm gonna
26:34 - show you what that configuration file
26:36 - looks like and a couple of different
26:38 - options for configuring it so what we're
26:41 - going to be doing now is following this
26:43 - documentation right here on testing iOS
26:45 - applications now I'm gonna put all of
26:48 - these links in the description below so
26:50 - you don't have to run around looking for
26:52 - these but let's take a quick look I'm
26:54 - not going to go through it in very much
26:57 - detail because I'm gonna demonstrate it
26:59 - for you
26:59 - so the basic setup involves making sure
27:03 - that circle see I can access the Xcode
27:06 - scheme that you want to use now if
27:08 - you're unfamiliar with what a scheme is
27:11 - let me show you inside Xcode and
27:13 - actually this is kind of bothering me
27:15 - the fact that there are these red X's
27:17 - there so I'm just gonna run the test
27:18 - case and pass it I really much rather
27:21 - see green checkmarks alright so let's
27:24 - talk about schemes this right here is a
27:27 - scheme and if you've never clicked on
27:30 - this before it's probably because you
27:32 - didn't have to when you create a new
27:34 - Xcode project you have a default scheme
27:36 - that is the same name as your project
27:38 - right here and a scheme it basically
27:41 - describes which targets you want to
27:43 - build what tests you want to run what
27:46 - configuration files and stuff like that
27:49 - do you want to use because an Xcode
27:51 - project can actually be comprised of
27:53 - many different projects and targets and
27:55 - the scheme will allow you to specify you
27:58 - know which of those projects and targets
28:00 - you want to use and which tests you want
28:02 - to run and so on and so forth it's
28:04 - basically like a plan so the only thing
28:06 - we need to make sure is that our default
28:08 - scheme right here large project is
28:10 - shared so click this go to manage
28:13 - schemes and just make sure that this is
28:15 - checked on and it should be so you can
28:18 - go ahead and close that and I don't
28:19 - think I don't know if we pushed our
28:22 - latest test here I believe we did
28:32 - actually this is probably something we
28:34 - have to do to is to put the scheme into
28:37 - github because that is one of the one of
28:40 - the instructions here after we make sure
28:43 - that our scheme is shared we have to put
28:45 - it on github so that circle CI can
28:47 - access it because circle CI can only
28:49 - grab what's in the github repository so
28:53 - once you edit that scheme and make sure
28:56 - that it's shared go ahead under source
28:59 - control go to commit it's going to show
29:01 - you a list of files which have been
29:03 - changed which haven't been committed and
29:06 - pushed to github yet and you can see
29:08 - here that there is this data right here
29:10 - so just let's just push that we're going
29:22 - to do that and we're going to commit
29:24 - this file and we're going to push it
29:28 - alright so there is that change right
29:34 - there
29:34 - alright so now going back to the
29:36 - documentation this is what that
29:39 - configuration file looks like now we
29:43 - need to create this file and we need to
29:46 - put it on github so let's take a look at
29:49 - what's involved it looks complicated but
29:50 - it's really not I've actually taken this
29:53 - sample and I've simplified it a little
29:55 - bit so that it's a lot easier for me to
29:57 - explain and to for you to understand so
30:00 - what you need to understand is there's
30:02 - this notion of a job and a job is
30:04 - something that you tell Circle CI to do
30:06 - each job has a series of steps so for
30:09 - example you can give your job a name
30:12 - like job one and then you can specify
30:14 - the steps that circle CI must do for
30:18 - example check out the code and then run
30:21 - some sort of command maybe run another
30:25 - command and you would of course I'm
30:27 - simplifying it here but you would write
30:29 - down two specific commands that you
30:31 - would want Circle C had to run and then
30:33 - maybe like save the output of that
30:35 - command somewhere save the results
30:37 - somewhere you can also specify what sort
30:40 - of you know environment or what sort of
30:42 - version of Xcode
30:44 - you want circle CI to use and then you
30:47 - could have multiple jobs you can have a
30:49 - second job to do something else and that
30:51 - would have its own steps and then you
30:53 - can have a third job so this is all
30:56 - listed under jobs and then you have
31:00 - something called workflows and workflows
31:02 - allow you to take and pick and choose
31:05 - different jobs that you want to run so
31:07 - you can have one workflow and then you
31:10 - can list out which jobs make up that
31:13 - workflow so for example maybe this one
31:16 - is testing the project maybe this one is
31:19 - going to be you know linting the project
31:23 - or the code and this one it might be to
31:25 - you know do something else and then
31:27 - within each workflow that you specify
31:29 - you can specify pick and choose
31:32 - different jobs that you want to run to
31:35 - make up that workflow so for example
31:38 - workflow one that I've specified here is
31:40 - made up of job one and three so when
31:43 - circle CI sees this it's going to run
31:45 - this workflow and then it's going to run
31:47 - job one and three so I hope that kind of
31:50 - makes sense just to sum it up you have a
31:53 - series of steps which make up a job and
31:55 - then you have different jobs that make
31:58 - up a workflow so if we go back to the
32:01 - sample config file that it has here now
32:05 - it kind of makes a little more sense
32:06 - right so let's go through this sample
32:09 - config file and let me explain it to you
32:11 - so here's the list of jobs this job is
32:14 - called build and test here is the
32:17 - environment and version of Xcode that we
32:19 - want Circle CI to use here we're
32:21 - specifying an output directory here are
32:24 - the steps for the build and test the job
32:26 - first that's going to check out the code
32:28 - from github then it's going to run and
32:33 - for this run command you can give it a
32:35 - label or a name it's going to fetch
32:38 - cocoa pod then it's going to run this
32:41 - command right here to install cocoa pods
32:44 - and to read the pod file just in case
32:46 - your Xcode project is using any
32:48 - third-party libraries via cocoa pods
32:50 - then it's going to go ahead and install
32:52 - all of those third-party libraries and
32:54 - then here it's going to run
32:56 - a fast lane skin command and fast lane
32:59 - is another automation tool you know if
33:03 - you haven't done a lot of development
33:05 - you might not have had the need to look
33:08 - into a tool like this but when projects
33:10 - get bigger and the deployment process
33:13 - gets bigger in you know you're running
33:15 - tests you're generating screenshots and
33:19 - you are deploying it to various
33:21 - environments it takes a lot of time to
33:24 - go through all of those steps every time
33:26 - you know there's a code change or a
33:28 - feature completion or something like
33:30 - that and you need to roll something out
33:32 - so fast lane helps you automate a lot of
33:34 - those tedious tasks and fast lane works
33:37 - with circle CI so that's that's really
33:41 - great you can see here some of the
33:42 - features that fast lane can help you
33:45 - with alright so going back to this
33:47 - config file running a fast lane scan in
33:50 - this case is basically going to run your
33:53 - scheme your Xcode scheme we're going to
33:57 - change this to our scheme that we have
33:59 - which is large project and it's going to
34:03 - run all of our unit tests and it's going
34:05 - to use this device or simulator here and
34:08 - then it's going to save those results
34:09 - somewhere and that's the job right there
34:12 - and here we specify workflows so this is
34:16 - the build and test workflow and the jobs
34:19 - that make up this workflow is the build
34:22 - and test job so I hope that makes sense
34:25 - what we're going to do now is we're
34:28 - going to take this sample config file
34:29 - we're going to modify it to our own
34:32 - needs and then we are going to put it
34:35 - into github so then we're going to be
34:36 - able to see circle CI in action so how
34:40 - do we go about creating this config file
34:41 - well the easiest way and actually from
34:46 - the set of instructions right here in
34:48 - the getting started the easiest way to
34:52 - create this config the siamo file
34:55 - essentially is to go to your github
34:58 - repository click on create new file and
35:01 - then we're going to specify the file
35:04 - here so it's got to live in this hidden
35:08 - folder called circle CI and you know
35:11 - it's hidden because there's a dot right
35:12 - in front of it if you don't have hidden
35:15 - files shown on your local system then
35:18 - you're not going to be able to see it
35:19 - but I'll I'll talk about that in a
35:22 - second so you paste that you're all
35:24 - there and it automatically detects that
35:26 - you want to put this file config yamo
35:28 - into this hidden folder circle ci and in
35:32 - here you put the contents of your config
35:35 - file so we're going to go ahead and we
35:38 - are going to just copy this and we are
35:42 - going to paste it in here but we're
35:44 - gonna have to make some changes so for
35:46 - example I want to use ten point two
35:49 - point one and if you go back into this
35:53 - document right here it tells you
35:55 - supported Xcode version so these are all
35:57 - of the different versions of Xcode that
35:59 - you can decide to use all right and I'm
36:04 - choosing this version simply because
36:05 - that's the version I'm currently using I
36:08 - don't need any cocoa pods for our sample
36:11 - project right now it's pretty simple we
36:13 - don't have any third-party libraries
36:14 - with cocoa pod so I'm gonna get rid of
36:16 - that and then it's gonna run Fastlane
36:18 - scan iPhone 8 is fine and our scheme is
36:22 - not web tests it's actually if I go
36:27 - manage schemes our scheme is called
36:29 - large project so that's what we're gonna
36:30 - have to put here large project and the
36:37 - rest should be fine so we're gonna go
36:38 - ahead and commit this new file into our
36:41 - github repository so let's call this
36:44 - creating the config file for circle CI
36:49 - right and when I commit directly to the
36:51 - master branch let's go ahead and do that
36:54 - all right so now let's go back to our
36:57 - root and you can see there is a hidden
36:59 - circle CI folder now if I navigate to my
37:04 - large project folder locally on my
37:07 - desktop I don't see that file there I
37:11 - don't see that configuration file I just
37:13 - added to github so what I've got to do
37:15 - is just go into my Xcode project and
37:18 - under source control let's do a pull so
37:20 - this is going to get the latest changes
37:22 - from our remote repository let's go
37:25 - ahead and do a pull and I'm gonna go
37:27 - ahead and pull from the master branch
37:29 - and if we check our directory now now we
37:34 - have that configuration file and like I
37:37 - said if you don't have hidden files
37:39 - shown on your computer then you're not
37:42 - gonna see these hidden folders and there
37:45 - is a way for you to enable and show
37:47 - these hidden folders just go ahead and
37:50 - google show hidden files on Mac OS or
37:53 - whatever version you're using and you're
37:55 - gonna see some simple instructions to
37:57 - enable this okay so now what we can do
38:01 - is we can go back to circle CI and we
38:04 - can start testing our project so this
38:05 - part is really exciting so we've done
38:08 - all of this we created the circle CI
38:09 - folder with the config Yama file we've
38:12 - populated it we've updated it push this
38:16 - change the github we've done that lo so
38:18 - let's hit this button to start building
38:19 - our project it's gonna grab the latest
38:23 - code from github and you can see here
38:26 - this is our workflow it's running it I'm
38:31 - just gonna have to wait
38:32 - [Music]
38:46 - all right so it's succeeded let's take a
38:49 - look at what's happened if you click
38:51 - into it you can see everything that it's
38:54 - done
38:54 - so go ahead here we go you can see that
38:58 - it's setting up the environment it's
39:00 - checking up the code and you can always
39:02 - go into here to see the exact commands
39:05 - it's running and the things that it's
39:06 - doing build and run tests so you can see
39:09 - here it's running Fastlane scan and it's
39:13 - running this scheme here large project
39:15 - for our Xcode project right there
39:17 - they're a whole bunch of different
39:21 - things that you can look at now why
39:24 - don't we do a cool test here why don't
39:25 - we go back to jobs and you can see that
39:29 - succeeded but let's go back to our Xcode
39:31 - project now and let's break our test so
39:33 - let's say that let y equals 1 and then
39:37 - I'm gonna run this and obviously it's
39:38 - gonna fail right but we are going to
39:41 - push this into github and see what
39:43 - happens so let's save the file let's go
39:46 - here you can see that it's modified
39:48 - let's go ahead and commit this so let's
39:52 - say I was a developer and I was
39:54 - committing some code and you know break
39:59 - the unit test let's commit and push all
40:06 - right you're going to see that circle CI
40:09 - is going to pick up the change and then
40:11 - it's going to automatically run try to
40:15 - build the project and then run the unit
40:17 - tests again and so that happens
40:19 - automatically you don't even have to do
40:21 - anything
40:22 - [Music]
40:26 - all right so circle CI has finished
40:29 - running our job took about a minute and
40:32 - a half and as expected its failed so
40:35 - let's click into it and see what's
40:36 - happened so you can see that checking
40:39 - out the code was successful but building
40:41 - and running tests failed and you can see
40:44 - if we just take a look at the output
40:47 - here that C is supposed to be zero this
40:51 - test failed test example' failed and so
40:57 - immediately what's going to happen is
41:00 - I'm gonna get an email workflow failed
41:06 - right so this latest code change whoever
41:11 - pushed this into the master repo has
41:15 - essentially broken some tests that
41:17 - failed so now someone can go in and
41:20 - address it right away whether that is
41:22 - the person who made the commit or
41:24 - someone else but the key thing is that
41:26 - we found out about it right now rather
41:29 - than you know several different commits
41:31 - later and the issue is buried and hard
41:34 - to figure out so now let me go ahead and
41:38 - change that back so that it's working
41:42 - let me say fixed unit test all right
41:48 - push that and so circle CI is going to
41:53 - detect that and it's going to do its
41:55 - thing now while that's happening let's
41:58 - take a look at linting so there is a
42:02 - free and awesome lint tool called swift
42:05 - lint and it is a tool to enforce Swift
42:09 - style and conventions loosely based on
42:11 - github swift style guide so it's kind of
42:15 - based on this one but all of these lint
42:17 - tools are very configurable and so you
42:21 - can you can change the rules to what you
42:24 - need and what you like the cool thing is
42:26 - that you don't really need to do much to
42:28 - lint your code through circle CI so
42:31 - let's take a look at how we can modify
42:33 - our config file to include linting
42:37 - we are going to use this right here so
42:44 - this is a lint job which we can copy
42:47 - this configuration for and we can add
42:50 - this to our configuration file so why
42:53 - don't we go ahead and copy these steps
42:54 - we are going to go into our config dot
42:59 - yeah mol file and just click Edit and
43:01 - we're going to change this a little bit
43:03 - so we've got our build and test job here
43:06 - I'm gonna add a new job it's basically
43:08 - the code that I took from here and this
43:11 - is going to be the Swift lint job and
43:14 - this is how it looks like it's going to
43:16 - check out the code and then run Swift
43:18 - lint and then store the results but in
43:20 - order to include this job into our
43:22 - workflow we actually have to modify our
43:25 - workflow here build test let's say lint
43:32 - build and test right so then we add with
43:37 - the wind right there and now let's let's
43:42 - check out our build here it's still
43:44 - running ok it should almost be done oh
43:47 - there it is succeeded so remember I
43:50 - fixed the test case right here it shows
43:52 - you the latest commit so that's kind of
43:54 - cool and then now I'm going to commit
43:57 - this so updated config circle CI config
44:03 - file to include linting and just commit
44:10 - that and take a look at what happens
44:14 - here alright so it's running now here's
44:19 - the workflow lint build and test and
44:21 - here is the job this one is testing the
44:24 - build and test job and this one is
44:26 - running the Swift lint job so it's gonna
44:29 - run and let's give it a little bit of
44:30 - time and see what happens
44:33 - alright so our new workflow has finished
44:35 - and the linting took about 22 seconds
44:38 - and building and testing took about a
44:40 - minute half same as before now this has
44:43 - succeeded as expected but our linting
44:45 - has failed so let's take a look at that
44:48 - we're gonna click into it
44:50 - and we are going to take a look at Swift
44:53 - lint reporting on all of these
44:55 - violations you can see here done linting
44:57 - found 15 violations three serious in
45:00 - three files now the only files we have
45:03 - essentially are in terms of Swift code
45:06 - right app delegate view controller and
45:09 - large project tests swift so let's take
45:11 - a look at what Swift Flint has to say
45:13 - about that
45:14 - here failure message files should have a
45:18 - single trailing newline and it tells you
45:22 - that this is in viewcontroller.swift it
45:25 - also tells you that inside
45:26 - viewcontroller.swift
45:28 - limit vertical whitespace to a single
45:30 - empty line so I'm not gonna go through
45:34 - all of these and fix all these for you
45:35 - now but I do want to fix a couple ones
45:37 - and show you what that looks like so
45:39 - files should have a single trailing
45:41 - newline if you take a look at here it's
45:45 - basically saying that I have two new
45:47 - lines after it and I should have one so
45:49 - you know it can get pretty detailed
45:52 - again in app delegate Swift I have two
45:55 - trailing new lines at the end and it
45:57 - should only be one and oddly enough
45:59 - large project I thought a large project
46:03 - tests the Swift only has one so now
46:06 - everything is consistent right other
46:09 - rules include that line should be 120
46:13 - characters or less you know this is
46:15 - saying that some of this code is going
46:17 - way too much into the right and so if
46:22 - people were to read it they'd have to
46:23 - scroll left and right too much right so
46:26 - there are some rules that say that your
46:28 - code should be written in a way or space
46:31 - in a way so that it's not too wide so
46:33 - all of these rules are really
46:34 - configurable but at the end of the day
46:36 - it's gonna help you maintain a very tidy
46:39 - and consistent code base so we've just
46:41 - made two changes right so let's commit
46:45 - these two changes fixing let's push the
46:50 - remote fixing new trailing newline
46:57 - violations
47:01 - how about line lint violations commit
47:06 - these two files and push now here's a
47:08 - very interesting I want interesting
47:11 - thing I want to tell you about so we've
47:13 - just pushed we fix two violations right
47:17 - so we should see this go from 15 to 13
47:19 - the next time we do this but if I go
47:22 - into jobs you can see that Circle CI
47:25 - hasn't triggered so why is that
47:27 - well if we go back to github and we
47:31 - refresh the page and we look at our
47:34 - number of commits we don't have we don't
47:41 - have the latest commit that we did my
47:43 - message was fixed trailing newline lint
47:47 - violations right I committed that but
47:48 - where did that go right the problem is
47:52 - that we changed our master repo from
47:56 - this web-based interface and so it's out
48:01 - of sync with our local copy right here
48:04 - so that's why I wasn't I wasn't able to
48:07 - push my those code changes into github
48:11 - instead what I have to do is first pull
48:13 - any changes or I pull them basically
48:19 - they were changes to the configurable
48:20 - file so now that I have all of the
48:23 - latest changes I need to merge any
48:25 - conflicts but there weren't any so now
48:27 - actually I can go in and push the code I
48:33 - can push my last commit so now it will
48:36 - actually succeed so if i refresh the
48:38 - page now you can see here that this
48:43 - contains my latest change fixed trailing
48:48 - fixed trailing newline lint violations
48:51 - and now circles see I will pick up that
48:54 - new commit and it's going to run the
48:58 - lint test again and it's going to build
49:01 - my project and run the unit tests as
49:05 - well all right so circle CI is finished
49:07 - linting our code and also building and
49:09 - testing our project so building and
49:12 - testing our project has succeed
49:13 - as expected but swiftlet has still
49:15 - failed and that's because we didn't fix
49:17 - all of the errors or violations right if
49:20 - we go down here now it's only found 13
49:23 - instead of 15 because we fixed two of
49:26 - them right so we're still in violation
49:28 - but I just wanted to show you that as an
49:33 - example so here we also get emails to
49:35 - notify us that swiftlet has failed
49:39 - someone has checked in some code that
49:41 - has violations and so you should go and
49:43 - address that right away so as you can
49:46 - see all of these tools help teams
49:49 - collaborate and work together
49:50 - efficiently and once you set it up it
49:53 - just works for you and you can focus on
49:55 - writing your code now there are two very
49:57 - important things I want to mention and
49:59 - number one is that these tools and
50:00 - processes are very common in the
50:02 - industry so if you have experience with
50:04 - them or you build the skills in using
50:06 - them it's going to give you a huge leg
50:09 - up in getting hired as an iOS developer
50:11 - if that's your goal and number two I've
50:14 - spoken about these tools in the context
50:16 - of large teams working together but I
50:19 - hope you can see how these things can
50:21 - even help a single indie developer
50:23 - building his or her app by offloading a
50:26 - lot of the tedious tasks and also
50:28 - automating the testing side of things
50:30 - it's gonna allow that developer to save
50:32 - time the precious 24 hours that he or
50:35 - she has and just focus on writing code
50:37 - now in the future I want to dive deeper
50:39 - into some of the topics that we had to
50:42 - gloss over such as configuring Swift Lin
50:44 - unit testing using fast lane if that's
50:47 - something that you want to see please
50:48 - drop me a comment below and let me know
50:50 - that's gonna give me a huge vote of
50:52 - confidence to move forward on these
50:53 - topics and finally I want to thank
50:55 - Circle CI so much for creating such a
50:58 - great product for developers to create
51:00 - awesome apps and also for sponsoring me
51:02 - and allowing me to create high-quality
51:04 - and free tutorials for you guys so
51:07 - there's start making continuous
51:08 - integration and delivery a part of your
51:10 - development process click the link below
51:12 - and sign up for a free account

Cleaned transcript:

hey cooker today you're going to learn how large iOS development teams work together to produce large and complex apps such as Instagram YouTube and Spotify now how do multiple developers work together on the same code base without overriding and destroying each other's code and how does a developer at his or her code without accidentally destroying some functionality in the app and finally how do you organize and keep tidy thousands of lines of code written by multiple developers while today I'm going to answer those questions and more so stay tuned hey there I'm Chris and welcome to code with Chris where we're going to teach you how to become a developer through building iOS apps now as a single in the iOS developer you can do some pretty cool things and there are a lot of successful indie apps in the App Store but on the other hand as a single developer you are limited by the scope and scale of the apps that you can build because at the end of the day we're all limited by the fact that we have 24 hours in a day a lot of the mass audience largescale apps in the App Store are built by teams of people testers developers designers product managers you name it now how do all of these people work together to produce a single app well today we're going to look at some of the unique problems that teams face and how they overcome them but before we dive in I just want to give a shout out to circle CI comm who has the sponsor of this video they enable large teams to work together efficiently to produce awesome apps through their continuous integration and delivery services now these two processes are something that is very important for large teams to collaborate through and we're going to touch upon them later on but for now let's take a look at large team problem number one so how do multiple developers work together on the same Xcode project the answer is source control and in this case source refers to source code now there are many different source control management systems out there but one of the most popular ones is git and github is a popular choice for git repositories in the cloud now here's a quick rundown of how it works the git repository or git repo for short contain the master copy of the code the repo also keeps track of versioning of the code let's say it's version 1 right now when you want to work on the project you check out a copy of the code it's kind of like checking out a library book in this case you've made a local copy of the code this is also known as pulling the code another developer let's call her developer B can also check out the code and make a local copy on their machine you're both working on your local copy of the project and maybe you finish your work first let's say you have to fix a bug in the project and you nailed it the next step is for you to commit your code back to the master repo you can and should attach a message to say what you changed and why you changed it when you send your changes back to the repo the message you wrote will be attached to that change now this is known as committing or pushing or checking in your code different people will like to use different terminology now let's say developer B has finished her change and she's ready to check in her changes back into the repo as well but there's a problem because after you checked in your code to the repo you've essentially changed the master copy of the code and now it's out of sync with her local copy that she checked out earlier now developer B doesn't have any of the new code that you checked in so if she were to blindly check in her version back to the repo she would essentially be overriding your code luckily source control would detect that the master copy has changed since developer B last checked out the code so it's not going to let her commit her code developer B has to do a merge which involves getting the latest copy of the code from the repo merging it with her local copy fixing any errors that may arise from your code conflicting with her code and then after resolving any issues to commit the merged code back to the repo if you and developer B happen to work on the same file and same lines of code then there might be a conflict in which developer B needs to manually decide how to merge your code with hers now as you can see this merge process can sometimes get pretty complicated and you're gonna have to be careful not to overwrite anyone elses changes when you merge their changes with yours now imagine a team of 10 20 or 30 developers all checking out and committing code a source control management system makes sure that everyone can work on the same code base without accidentally overwriting each other's changes but to have so many people writing code also means that it's hard for one person to know the whole project inside and out and as a result any one developer might accidentally write code that introduces bugs into the app and this brings us to large team problem number two when a developer commits his or her code to the master repo how do they make sure that something isn't broken large projects can be thousands of lines of code so it's only natural that bugs can crop up unintentionally and this is where unit testing comes in unit testing is a process by which you write code to test your other code here's how it works you break down the code in your app into units that make sense let's say you have a chunk of code that creates user accounts now typically this code gets run after the user enters in their info from a form in the app but since you want to wait to test this chunk of code at will you'll write a test case this test case called a unit test will attempt to create an account with some dummy data now you can run this unit test and if it suddenly fails then you know that the unit of code that creates accounts is not working now imagine you write these unit tests for every chunk of code that does something in your project you'll end up having a suite of these test cases that you can run anytime you want to see if something in your project isn't working now it won't catch every single bug but it acts like a baseline and it's your first line of defense and once you write all your test cases and it's all set up you'll have an easy way to test that baseline now when a developer checks in some code you can run these unit tests as an easy way to screen if some baseline functionality has been broken as a result of that new code all right so you've got source control management and unit testing as tools to help large teams work together but here's another problem now just like handwriting every developer will naturally have a slightly different coding style so won't the code file that is written by multiple developers be really hard to read and this brings us to a large team problem number three how do multiple developer maintain a consistent coating style well first the team establishes a set of coding conventions or a style guide now this can be as detailed as saying if the opening bracket of an if statement should be on the same line as the if keyword or on the next line and it can also say things like how many line breaks should be in between methods in a class the more detailed you can be the more consistent your code base will be now in order to enforce these coding conventions across a large team there are tools out there that can scan the code and then I can tell you any lines of code which are not adhering to the style guide or the coding conventions that you set forth these tools are commonly referred to as lint or lint or tools now there are a lot of free lint tools out there and simply using one will ensure that your code base is tidy and consistent now we've talked about a lot of different tools but ultimately who is in charge of running these tools and a team well in the ideal case each developer would a make sure that before they check in any code into the master repo that they pull down the latest version and they merge any changes properly and I say properly because merging isn't always a trivial process I mean you're trying to merge your code with someone else's code that you didn't write and you have to take the time to understand what they wrote what their intentions were and merge it with your code in a way that doesn't cause conflicts or unintended behavior and be before they check in their code they should make sure that all of the unit tests still pass just in case that the new code or the change that they wrote breaks something else and see before checking in their code they should run the lint tool and fix any code that doesn't conform to the style guidelines set forth by the team now even if a developer does all of this and has the best intentions we are all still human and mistakes will happen code will be improperly merged builds will break tests will fail and bugs will crop up it would be a fulltime job for someone to continuously monitor the codebase and make sure it's in tiptop shape after each time a developer checks in code well fortunately we don't need to do this and this is where something called continuous integration or CI for short comes in real handy continuous integration is a system that monitors the master repo and runs various checks and balances to ensure that the master code base is in tiptop shape the CI process is highly configurable and it can automatically do things like build the project to make sure it runs run the test suite to ensure that all of the unit tests pass run a lint tool to check for code that doesn't adhere to coding conventions and it can even do more than that such as send a successful build to a QA environment or deliver it to iTunes for deployment into the App Store it can do all these things automatically by running on a specified schedule or running whenever someone checks in code if the CI process finds a problem the appropriate people can be notified immediately to fix the problem like maybe if the build is broken after the last code check in or a unit test no longer passes or maybe the newly checked in code fails the Lin tests knowing about any issues right away is crucial especially with a large team because so much code is being written per day that it can quickly pile up on an issue and it can take a long time to unravel the issue if it remains buried a continuous integration system lets the team work confidently and stay focused on coding because developers know that the CI process will catch any mistakes as soon as they happen continuous integration often goes handinhand with continuous delivery which is a process that can automatically send builds to different environments such as sending the build to a test environment for the QA team to test out some new features circle CI is one of these platforms that can do all this and more now we're going to do a demo and I'm going to show you and put into practice everything we just talked about we're going to start a new Xcode project and we're going to commit it to a source control management system now git is a popular choice and it's a great one for us to use because there's tight integration for it within the Xcode IDE however we're going to use github so we can actually store our git repository on the cloud then I'm going to show you how to write us unit tests and I'll show you how to run it finally we're going to hook up our github repository to circle CI so that every time we push code from our computer to github circle CI is going to get the latest code from the master repo run our unit tests build the project and also used Swift lint to make sure that everything is okay all right so let's dive in all right so we're gonna start our brandnew Xcode project and I'll show you how to put it on github so our first step is to create our Xcode project so go ahead launch Xcode let's create a brand new Xcode project I'm going to choose a single view app here and for the product name I'm just gonna call it large project because that's what we're talking about right now the important thing is to include unit tests because I want to show you guys how to write a sample one and run it and go ahead click Next you can save it wherever you want I'm gonna put it on my desktop now what's also important is to check source control here it's gonna create a git repository on your Mac don't confuse this with github this is a local git repository it's still source control the only thing is that that repo is stored on your machine now as a single developer this might be fine but you do have to think about the risk of potentially your hard drive failing and then you'll lose your code so it's always a good idea to put that on github and I'll show you how to do that so go ahead and enable this for now click create and here we are we have our sample project the next thing we're going to do is to sign up for a github account if you don't have one already and the great thing is that private repositories are free now it used to be that only public ones who were free so all your code would be public but now even private repos are free as well so you don't have to pay anything so sign up for github go to github com if you haven't gotten an account if you do then you can move on to the next step which is hooking up Xcode with your github account and the way you do that is you go Xcode preferences and you can see here I have my account hooked up if you don't have this go ahead click this plus icon here and just choose github from the list and it's going to ask you for your account and password so you want to go ahead and do that so that you can integrate X code with your github account and so you can push code and pull code back and forth very very easily so after you do that the next thing we're going to do is to put this large project into our github account and the way you can do that is you can go here this is where you can look at all of your source control Navigator this what it's called and you can actually go under branches if you're not aware you can have different branches or versions of your source code and you can choose which ones to pull from and which ones to send code to initially you're only gonna have master and we've only really talked about master but starting a separate branch might be good if you want to test out a new feature or you want to maybe tinker with something that you're not sure you want to put into the master just yet so at that point it could be helpful to create a separate branch or separate version of your code at that point tinker with that and then depending on if it fails or you want to add it to the master you can always merge it back into the master branch so usually we just have our master branch to start so in order to put this whole project on github you go to this node right here and you right click and say create large project remote and remote means just off of your computer into github you've choose the account so hopefully you've added your github account through your Xcode preferences you're gonna give that repository a name alright so you can see here that this is ultimately the URL where that repo will live you can give it a description you can always edit this after I'm gonna set it to private right and then I'm just going to create it and then you can see here this is pushing its pushing the code to github and then now we can just jump into github and this is my github account here so you can see that when i refresh the page there it is this little lock represents that it's a private repository so you can see here that's the initial commit I've got a bunch of files here this is my actual project this is my tests and you can see that it mirrors what I have here okay so that's really cool because now whenever we write new code we can push it to github and in case our hard drive gets fried our code is safe on github now what I want to do is just run through quickly at a high level unit testing how to run test cases for your project and we're not going to really dive deep into testing theory or writing a lot of meaningful tests because the point of this video is to show you the overall process alright so you'll notice that we have large project tests here and if you click into this file here you'll see that we have this class large project tests there are a couple of methods here set up teardown and here is a single test case sample so you can also run performance tests but in this case we are not going to do that I'm just going to show you how to do simple functional testing to test the functionality and correctness of your code so let's go ahead and erase this performance test and we are just going to focus on this test sample now what we've got here is we've got one test case and then we've got our setup and teardown methods so these two are going to be called before and after every single test case now they're basically there just in case you need to write a whole bunch of setup code just to get to the point where you are able to write some code to run your tests and teardown is going to be called after every single test case in case you need to deallocate memory or do any sort of cleanup or put things back in place essentially so what we're going to do here is write a very very trivial test case because our at this point doesn't really do anything but I still want to show you the process of running failing passing tests so I'm going to just create a simple simple variable here let's say let a equal zero and then you know you wouldn't put that there you would put whatever code you want it to test let's say of creating accounts we mentioned earlier you might test passing some dummy data into that code that creates accounts and then you would then want to assert a certain outcome that you expect so the way we do that is we use xct assert and there are different methods here you can check if the outcome is nil if it's true if it's false if that's equal to something but basically the idea is that you run some code right to test something and you have an expected outcome and you use this to assert that that is actually the outcome that you've got in our case I'm gonna write each reveal statement here we are going to assert that I is equal to zero and then if it's not this error message or this message is going to get displayed is you know so that's going to be the message that gets displayed if that isn't true now how do we run this simple unit test there are several different ways you're gonna see some diamonds in this line number column you can run this individual test case by hovering over it and pressing this so I'm just going to go ahead and do that and you're going to see something appeared down here in the console so you can see that it executed one test with zero failures you can eat then these turn to green checkmarks there is also this button here which you can run the differences that hitting this will run all the test cases in this test suite whereas this one will only run this single test case another way is within the test navigator this tab right here you can see that you have your individual test cases here and then another way is actually to hold your over here and instead of building and running your project you would run your tests by itself so those are a couple of different ways now before we check in our changes into github let me show you what its gonna look like if the test fails so let me do that and just change I equals to one this is definitely gonna fail so if I run this test case you're going to see that it's gonna build the project it's gonna fail the test right here so you can see that that statement is not true so I'm going to change it back to zero and then now we're going to push our changes to github so if you go back to the file navigator I want you to notice one thing remember when I said that there was tight integration with git take a look at this we modified this file by changing some of the code we got rid of one of the methods and you can see this M here beside that file that stands for modified and that basically tells you what's changed since the last time you pushed your code to github or your local git repository so if we wanted to commit this code and push it to github we would then right click go to source control and say commit large project tests thought swift when you do this you can fill in a message here to say what you changed why you changed it what it was for and then make sure if you actually want to push it to github the remote repository and not just your local repository you enable this you choose your branch you know what we talked about earlier and we can say added a revealed test case all right so we can commit that file and push it so technically committing is actually a little different from pushing even though a lot of people use them these terms interchangeably committing is saying that I'm done with these files and these changes are related to whatever message that you put whereas pushing is actually the physical action of putting your code into sending it to the repository so you can actually do a whole bunch of different commits locally before you push your code to the repository I know that might not make that much sense for now if you're kind of neat to source control but think of it like a commit is a particular change that you want to make and pushing is actually sending the code to the repo all right so let's go back to our github repository and let's just hit refresh and you can see here that this was our latest push right a minute go whereas our initial project push was 21 minutes go in if you actually take a look at here you can see there were two commits right so this was the initial one for the whole project and here was our trivial test case Edition and each one has a version number right so this source control repository or management system knows exactly when something has changed if someone else had checked out the code earlier and they try to push their changes source control is going to say hey and we're at a new version now so you better pull down the latest changes and merge them before you push your code over so that our test case doesn't get overwritten so just to do a quick recap we've created a brand new Xcode project we've put it on github so now actually multiple developers can start working on this project and this source control management system is going to work beautifully however we are counting on each single developer to be diligent in running the test cases and also they have to write the test cases right to ensure that the code they add doesn't break the build and that our app still functionally works this cannot always be relied upon despite the best intentions of each developer and so what our next step is going to be is to hook up our github account or this specific repository with circle CI so that we can get a continuous integration process working so each time a developer pushes code to the master repo circle ci is going to detect at and automatically grab the latest code build it to make sure that it's still build successfully run all of our tests to make sure that they all pass and I'll show you also how to include a lint tool and have that run so that the code can be checked to adhere to the coding conventions of the team all right so let's go ahead and do that so visit the URL on the screen right now or click in the description for the link and you're going to get to the relevant page for building and testing Xcode projects on circle CI start building for free click on that and you're going to be able to sign up with your github account and doing this is going to be good because it's going to automatically give Circle CI access to your github repositories now you can control whether circle CI has access to your public and private repositories or only your public ones so on the next screen you're going to see that and then once you're signed up and you're into the dashboard you should see something that looks like this and you might not have any projects at first or you might see something here but go ahead into the add projects tab and you're going to then jump into the Mac OS tab here then you're going to be able to start two week free trial and there's no credit card entry or anything like that so feel free to give it a try click on start my free trial and then you're going to see your project here now I'm going to refresh the page so we can see what I have here so there we go that's the large project that we just added to our github account so go ahead and click on the blue button to setup your project and this should be automatically detected if it's not you can choose Mac OS and Swift right here and there is only really one thing that we need to do to set this up and get this going and that is to setup a configuration file that tells Circle CI what we want to build what we want to test you know what lint tool we want to use how we want to distribute to build what environments and all that stuff and so I'm gonna show you what that configuration file looks like and a couple of different options for configuring it so what we're going to be doing now is following this documentation right here on testing iOS applications now I'm gonna put all of these links in the description below so you don't have to run around looking for these but let's take a quick look I'm not going to go through it in very much detail because I'm gonna demonstrate it for you so the basic setup involves making sure that circle see I can access the Xcode scheme that you want to use now if you're unfamiliar with what a scheme is let me show you inside Xcode and actually this is kind of bothering me the fact that there are these red X's there so I'm just gonna run the test case and pass it I really much rather see green checkmarks alright so let's talk about schemes this right here is a scheme and if you've never clicked on this before it's probably because you didn't have to when you create a new Xcode project you have a default scheme that is the same name as your project right here and a scheme it basically describes which targets you want to build what tests you want to run what configuration files and stuff like that do you want to use because an Xcode project can actually be comprised of many different projects and targets and the scheme will allow you to specify you know which of those projects and targets you want to use and which tests you want to run and so on and so forth it's basically like a plan so the only thing we need to make sure is that our default scheme right here large project is shared so click this go to manage schemes and just make sure that this is checked on and it should be so you can go ahead and close that and I don't think I don't know if we pushed our latest test here I believe we did actually this is probably something we have to do to is to put the scheme into github because that is one of the one of the instructions here after we make sure that our scheme is shared we have to put it on github so that circle CI can access it because circle CI can only grab what's in the github repository so once you edit that scheme and make sure that it's shared go ahead under source control go to commit it's going to show you a list of files which have been changed which haven't been committed and pushed to github yet and you can see here that there is this data right here so just let's just push that we're going to do that and we're going to commit this file and we're going to push it alright so there is that change right there alright so now going back to the documentation this is what that configuration file looks like now we need to create this file and we need to put it on github so let's take a look at what's involved it looks complicated but it's really not I've actually taken this sample and I've simplified it a little bit so that it's a lot easier for me to explain and to for you to understand so what you need to understand is there's this notion of a job and a job is something that you tell Circle CI to do each job has a series of steps so for example you can give your job a name like job one and then you can specify the steps that circle CI must do for example check out the code and then run some sort of command maybe run another command and you would of course I'm simplifying it here but you would write down two specific commands that you would want Circle C had to run and then maybe like save the output of that command somewhere save the results somewhere you can also specify what sort of you know environment or what sort of version of Xcode you want circle CI to use and then you could have multiple jobs you can have a second job to do something else and that would have its own steps and then you can have a third job so this is all listed under jobs and then you have something called workflows and workflows allow you to take and pick and choose different jobs that you want to run so you can have one workflow and then you can list out which jobs make up that workflow so for example maybe this one is testing the project maybe this one is going to be you know linting the project or the code and this one it might be to you know do something else and then within each workflow that you specify you can specify pick and choose different jobs that you want to run to make up that workflow so for example workflow one that I've specified here is made up of job one and three so when circle CI sees this it's going to run this workflow and then it's going to run job one and three so I hope that kind of makes sense just to sum it up you have a series of steps which make up a job and then you have different jobs that make up a workflow so if we go back to the sample config file that it has here now it kind of makes a little more sense right so let's go through this sample config file and let me explain it to you so here's the list of jobs this job is called build and test here is the environment and version of Xcode that we want Circle CI to use here we're specifying an output directory here are the steps for the build and test the job first that's going to check out the code from github then it's going to run and for this run command you can give it a label or a name it's going to fetch cocoa pod then it's going to run this command right here to install cocoa pods and to read the pod file just in case your Xcode project is using any thirdparty libraries via cocoa pods then it's going to go ahead and install all of those thirdparty libraries and then here it's going to run a fast lane skin command and fast lane is another automation tool you know if you haven't done a lot of development you might not have had the need to look into a tool like this but when projects get bigger and the deployment process gets bigger in you know you're running tests you're generating screenshots and you are deploying it to various environments it takes a lot of time to go through all of those steps every time you know there's a code change or a feature completion or something like that and you need to roll something out so fast lane helps you automate a lot of those tedious tasks and fast lane works with circle CI so that's that's really great you can see here some of the features that fast lane can help you with alright so going back to this config file running a fast lane scan in this case is basically going to run your scheme your Xcode scheme we're going to change this to our scheme that we have which is large project and it's going to run all of our unit tests and it's going to use this device or simulator here and then it's going to save those results somewhere and that's the job right there and here we specify workflows so this is the build and test workflow and the jobs that make up this workflow is the build and test job so I hope that makes sense what we're going to do now is we're going to take this sample config file we're going to modify it to our own needs and then we are going to put it into github so then we're going to be able to see circle CI in action so how do we go about creating this config file well the easiest way and actually from the set of instructions right here in the getting started the easiest way to create this config the siamo file essentially is to go to your github repository click on create new file and then we're going to specify the file here so it's got to live in this hidden folder called circle CI and you know it's hidden because there's a dot right in front of it if you don't have hidden files shown on your local system then you're not going to be able to see it but I'll I'll talk about that in a second so you paste that you're all there and it automatically detects that you want to put this file config yamo into this hidden folder circle ci and in here you put the contents of your config file so we're going to go ahead and we are going to just copy this and we are going to paste it in here but we're gonna have to make some changes so for example I want to use ten point two point one and if you go back into this document right here it tells you supported Xcode version so these are all of the different versions of Xcode that you can decide to use all right and I'm choosing this version simply because that's the version I'm currently using I don't need any cocoa pods for our sample project right now it's pretty simple we don't have any thirdparty libraries with cocoa pod so I'm gonna get rid of that and then it's gonna run Fastlane scan iPhone 8 is fine and our scheme is not web tests it's actually if I go manage schemes our scheme is called large project so that's what we're gonna have to put here large project and the rest should be fine so we're gonna go ahead and commit this new file into our github repository so let's call this creating the config file for circle CI right and when I commit directly to the master branch let's go ahead and do that all right so now let's go back to our root and you can see there is a hidden circle CI folder now if I navigate to my large project folder locally on my desktop I don't see that file there I don't see that configuration file I just added to github so what I've got to do is just go into my Xcode project and under source control let's do a pull so this is going to get the latest changes from our remote repository let's go ahead and do a pull and I'm gonna go ahead and pull from the master branch and if we check our directory now now we have that configuration file and like I said if you don't have hidden files shown on your computer then you're not gonna see these hidden folders and there is a way for you to enable and show these hidden folders just go ahead and google show hidden files on Mac OS or whatever version you're using and you're gonna see some simple instructions to enable this okay so now what we can do is we can go back to circle CI and we can start testing our project so this part is really exciting so we've done all of this we created the circle CI folder with the config Yama file we've populated it we've updated it push this change the github we've done that lo so let's hit this button to start building our project it's gonna grab the latest code from github and you can see here this is our workflow it's running it I'm just gonna have to wait all right so it's succeeded let's take a look at what's happened if you click into it you can see everything that it's done so go ahead here we go you can see that it's setting up the environment it's checking up the code and you can always go into here to see the exact commands it's running and the things that it's doing build and run tests so you can see here it's running Fastlane scan and it's running this scheme here large project for our Xcode project right there they're a whole bunch of different things that you can look at now why don't we do a cool test here why don't we go back to jobs and you can see that succeeded but let's go back to our Xcode project now and let's break our test so let's say that let y equals 1 and then I'm gonna run this and obviously it's gonna fail right but we are going to push this into github and see what happens so let's save the file let's go here you can see that it's modified let's go ahead and commit this so let's say I was a developer and I was committing some code and you know break the unit test let's commit and push all right you're going to see that circle CI is going to pick up the change and then it's going to automatically run try to build the project and then run the unit tests again and so that happens automatically you don't even have to do anything all right so circle CI has finished running our job took about a minute and a half and as expected its failed so let's click into it and see what's happened so you can see that checking out the code was successful but building and running tests failed and you can see if we just take a look at the output here that C is supposed to be zero this test failed test example' failed and so immediately what's going to happen is I'm gonna get an email workflow failed right so this latest code change whoever pushed this into the master repo has essentially broken some tests that failed so now someone can go in and address it right away whether that is the person who made the commit or someone else but the key thing is that we found out about it right now rather than you know several different commits later and the issue is buried and hard to figure out so now let me go ahead and change that back so that it's working let me say fixed unit test all right push that and so circle CI is going to detect that and it's going to do its thing now while that's happening let's take a look at linting so there is a free and awesome lint tool called swift lint and it is a tool to enforce Swift style and conventions loosely based on github swift style guide so it's kind of based on this one but all of these lint tools are very configurable and so you can you can change the rules to what you need and what you like the cool thing is that you don't really need to do much to lint your code through circle CI so let's take a look at how we can modify our config file to include linting we are going to use this right here so this is a lint job which we can copy this configuration for and we can add this to our configuration file so why don't we go ahead and copy these steps we are going to go into our config dot yeah mol file and just click Edit and we're going to change this a little bit so we've got our build and test job here I'm gonna add a new job it's basically the code that I took from here and this is going to be the Swift lint job and this is how it looks like it's going to check out the code and then run Swift lint and then store the results but in order to include this job into our workflow we actually have to modify our workflow here build test let's say lint build and test right so then we add with the wind right there and now let's let's check out our build here it's still running ok it should almost be done oh there it is succeeded so remember I fixed the test case right here it shows you the latest commit so that's kind of cool and then now I'm going to commit this so updated config circle CI config file to include linting and just commit that and take a look at what happens here alright so it's running now here's the workflow lint build and test and here is the job this one is testing the build and test job and this one is running the Swift lint job so it's gonna run and let's give it a little bit of time and see what happens alright so our new workflow has finished and the linting took about 22 seconds and building and testing took about a minute half same as before now this has succeeded as expected but our linting has failed so let's take a look at that we're gonna click into it and we are going to take a look at Swift lint reporting on all of these violations you can see here done linting found 15 violations three serious in three files now the only files we have essentially are in terms of Swift code right app delegate view controller and large project tests swift so let's take a look at what Swift Flint has to say about that here failure message files should have a single trailing newline and it tells you that this is in viewcontroller.swift it also tells you that inside viewcontroller.swift limit vertical whitespace to a single empty line so I'm not gonna go through all of these and fix all these for you now but I do want to fix a couple ones and show you what that looks like so files should have a single trailing newline if you take a look at here it's basically saying that I have two new lines after it and I should have one so you know it can get pretty detailed again in app delegate Swift I have two trailing new lines at the end and it should only be one and oddly enough large project I thought a large project tests the Swift only has one so now everything is consistent right other rules include that line should be 120 characters or less you know this is saying that some of this code is going way too much into the right and so if people were to read it they'd have to scroll left and right too much right so there are some rules that say that your code should be written in a way or space in a way so that it's not too wide so all of these rules are really configurable but at the end of the day it's gonna help you maintain a very tidy and consistent code base so we've just made two changes right so let's commit these two changes fixing let's push the remote fixing new trailing newline violations how about line lint violations commit these two files and push now here's a very interesting I want interesting thing I want to tell you about so we've just pushed we fix two violations right so we should see this go from 15 to 13 the next time we do this but if I go into jobs you can see that Circle CI hasn't triggered so why is that well if we go back to github and we refresh the page and we look at our number of commits we don't have we don't have the latest commit that we did my message was fixed trailing newline lint violations right I committed that but where did that go right the problem is that we changed our master repo from this webbased interface and so it's out of sync with our local copy right here so that's why I wasn't I wasn't able to push my those code changes into github instead what I have to do is first pull any changes or I pull them basically they were changes to the configurable file so now that I have all of the latest changes I need to merge any conflicts but there weren't any so now actually I can go in and push the code I can push my last commit so now it will actually succeed so if i refresh the page now you can see here that this contains my latest change fixed trailing fixed trailing newline lint violations and now circles see I will pick up that new commit and it's going to run the lint test again and it's going to build my project and run the unit tests as well all right so circle CI is finished linting our code and also building and testing our project so building and testing our project has succeed as expected but swiftlet has still failed and that's because we didn't fix all of the errors or violations right if we go down here now it's only found 13 instead of 15 because we fixed two of them right so we're still in violation but I just wanted to show you that as an example so here we also get emails to notify us that swiftlet has failed someone has checked in some code that has violations and so you should go and address that right away so as you can see all of these tools help teams collaborate and work together efficiently and once you set it up it just works for you and you can focus on writing your code now there are two very important things I want to mention and number one is that these tools and processes are very common in the industry so if you have experience with them or you build the skills in using them it's going to give you a huge leg up in getting hired as an iOS developer if that's your goal and number two I've spoken about these tools in the context of large teams working together but I hope you can see how these things can even help a single indie developer building his or her app by offloading a lot of the tedious tasks and also automating the testing side of things it's gonna allow that developer to save time the precious 24 hours that he or she has and just focus on writing code now in the future I want to dive deeper into some of the topics that we had to gloss over such as configuring Swift Lin unit testing using fast lane if that's something that you want to see please drop me a comment below and let me know that's gonna give me a huge vote of confidence to move forward on these topics and finally I want to thank Circle CI so much for creating such a great product for developers to create awesome apps and also for sponsoring me and allowing me to create highquality and free tutorials for you guys so there's start making continuous integration and delivery a part of your development process click the link below and sign up for a free account
