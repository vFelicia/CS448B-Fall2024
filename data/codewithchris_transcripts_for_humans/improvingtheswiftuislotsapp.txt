With timestamps:

00:00 - hey code crew in the last Swift ey lesson 
you learned about composing complex views  
00:05 - using smaller single purpose views and you also 
learned about data flow using state and binding  
00:10 - properties well in this video we're going to take 
a look at the slots app that we built and we're  
00:16 - gonna see how we can apply these two principles to 
improve that app but before we dive in if this is  
00:26 - your first time here welcome to code with Chris 
where we can teach you how to make an app even  
00:30 - if you've never coded before and you might want to 
start from the beginning of this Swift UI series  
00:35 - playlist in the description below and if you've 
been following along and watching this Swift UI  
00:39 - series from the beginning thank you and please 
give this video a thumbs up and subscribe if you  
00:44 - haven't already alright let's dive in so here 
we have the slots UI app that we built together  
00:50 - a couple of lessons ago and again if you've 
missed that lesson you can definitely check  
00:55 - out the playlist in the link in the description 
below to follow the series from the start alright  
01:01 - so the first thing we're gonna take a look at is 
what makes sense to break out into its smaller  
01:07 - single purpose view and what I like to look for 
is anything that I tend to have to repeat in the  
01:15 - UI so if you've got the same sort of button in a 
couple of different places or maybe the same type  
01:22 - of image element like we do here I mean rather 
than having this code repeated three times like  
01:28 - we have right now we could abstract that card out 
into its own card view you know its own single  
01:34 - purpose of view and then create three instances 
of that instead just like in the last lesson when  
01:40 - we talked about the color sliders so here you 
can see the code for these three cards we've  
01:45 - got these three images they're virtually the same 
code except for you know what icon gets displayed  
01:54 - but we can always use the what we learned about 
dataflow right use state properties and bindings  
02:01 - and pass that data in and the other thing that's 
good about abstracting this into its a single view  
02:07 - is that you know if I wanted to change the look 
and feel of the cards you can see this code is  
02:12 - repeated three times if I wanted to change the 
corner radius or the background color a little  
02:17 - bit I'd have to change it three times but if 
I abstracted out into a single card view and  
02:24 - then just use it three times then I only have to 
change at one place so it makes maintenance easier  
02:29 - so let's go ahead and just do that first before we 
even talk about data flow so right click here I'm  
02:35 - going to add a new file and under iOS or under 
user interface we're gonna choose swift UI view  
02:42 - and I'm gonna call this the card view because that 
kind of makes sense I'm just gonna move this guy  
02:49 - up here and by default you get that text label 
saying hello world but we don't need that we're  
02:56 - gonna go into the content view again and I'm 
they're really just gonna copy this guy and I'm  
03:02 - gonna paste it into here at the body this piece 
of data we don't have inside this card view so I'm  
03:12 - just gonna hard code an image name for now just 
so we can see something on the right-hand side  
03:18 - so that's great this lets me know that this 
is working right and this preview is simply  
03:27 - creating an instance of the card view and that's 
what we see so we'll take that and we'll go back  
03:33 - here and I'm going to first remove this one let's 
do a little test and let's declare a new card view  
03:42 - element here you can see that changed I'm gonna do 
the same thing removing that middle card and same  
03:52 - for the last one and that you know just like that 
we have created a smaller single purpose view in  
04:04 - the car view and we've composed we've used it to 
compose this kind of like bigger more complex view  
04:11 - now for this simple swift UI slots app that that 
is the thing that makes sense to abstract out into  
04:18 - its view if we were to you know reuse these other 
elements in different places if it were a more  
04:25 - complex app then there probably more components 
that I could pull out and make into smaller views  
04:31 - but as it stands now I think that's all that 
makes sense now we run into the next problem  
04:39 - which is that these cart views have a hard-coded 
Apple icon in the carts so we need to somehow be  
04:49 - able to change those icons now the consideration 
for the data flow comes into play so who should  
04:56 - be the source of truth for these icons here just 
to remind you about how they get displayed you  
05:04 - know we have a we have an ax right here called 
symbols and there's an apple star and cherry  
05:10 - these represent the possible icon choices or 
the image names and we have another array called  
05:17 - numbers which indicates which icon that card slot 
should be so this first index of the numbers array  
05:28 - represents this card the middle one represents 
that card and the last index represents that card  
05:34 - so depending on what number this is it's gonna 
kind of result in a different icon here remember  
05:42 - in the last lesson we talked about source of truth 
you know the state properties so we definitely do  
05:48 - not want to keep a copy of the numbers here in 
the content view and keep a copy of you know  
05:57 - what individual index this card is also in the 
card view because that would be duplicating the  
06:05 - data right and so it makes sense for me that the 
content view should be the source of truth and  
06:12 - that it should be passing the bindings to these 
numbers to the card views itself because number  
06:20 - one the content view has the logic to check for 
matches right after they hit the spin button we  
06:27 - have some code right here just to check if the 
numbers you know if this one matches this one and  
06:34 - if this one matches this one if we made the card 
view instead kind of hold its own number right if  
06:42 - we had a state here and we said you know we made 
it hold its own number it would make it harder for  
06:53 - us to be able to match to see if this card matches 
the others so that's why at least my thinking is  
07:04 - that right here the content view should be the 
source of truth of this data and instead we should  
07:09 - pass the bindings into the card views so that's 
what I'm going to try to do here let's hop into  
07:15 - our card view and take a look at what we can do so 
this is the hard-coded string that represents the  
07:22 - image so I'm going to create a binding for it so 
that it can be passed into the card view when it  
07:28 - gets created instead of having a hard-coded string 
there so I'm gonna say binding we're going to say  
07:39 - let's just call it symbol it's gonna be of type 
string I'm not gonna set it to anything because  
07:47 - I want it to be passed in and then here instead of 
hard-coding the string I'm just gonna put symbol  
07:53 - and now this preview is broken because you can see 
here you can't just create a card view element and  
08:03 - expect it to be displayed because it needs to know 
which symbol to display right and it is expecting  
08:12 - a binding to be passed in so if you just get rid 
of those parentheses or brackets you can see that  
08:19 - you're supposed to pass in a string type binding 
so unfortunately we don't have any real binding to  
08:27 - pass in to this preview right here but what we 
can do is pass in a temporary binding value to  
08:36 - just for the purpose of the preview so that it can 
display something so the way you do that is you go  
08:44 - finding dot constant and then you can specify a 
value so it's got to be a string so let's let's  
08:52 - teach area so then it's still gonna allow you to 
you know pass this in as a parameter but it's not  
09:00 - a real binding you know it's just a constant value 
so unfortunately it's not building right now let's  
09:10 - just take a look at why here card view type is 
not convertible ah yeah so back in the content  
09:17 - view all of these are broken now as well so why 
don't I just do the same thing just so we can just  
09:26 - do one thing at a time so let me just show you 
that this this works and now we can actually see  
09:33 - something before we actually use real bindings yes 
okay so there is the parameter label right there  
09:45 - okay so if we go back to the card view now and 
we try to update the preview you can see that we  
09:54 - see cherry because that's what we put right here 
all right now let's go back to the content view  
09:59 - and take a look at how we're gonna pass in the 
bindings for the symbols alright so up here my  
10:13 - numbers this is already a state property I'm gonna 
change this to a state property as well now I'm  
10:21 - gonna go down and instead of passing in a binding 
constant for a cherry right here I can pass in a  
10:30 - real binding from the state properties up there 
that we declared up there so we have symbols and  
10:37 - then inside here I had I think I called him number 
right so this would be zero all right let's just  
10:47 - see if that is okay before before I do anything Oh 
numbers okay so it would help if I could remember  
10:55 - my property names all right so we're gonna do the 
same thing here as well numbers one and this would  
11:05 - be symbols numbers - okay so let's resume build 
succeeded and you can see that this reflects the  
11:18 - indexes that we have right here in numbers and if 
I build and run this did I forget anything let's  
11:28 - take a look alright so you can see everything 
is working perfectly here and we've successfully  
11:40 - abstracted the card view into its own single 
purpose smaller view and we've facilitated the  
11:48 - data flow where the content view is the source 
of truth for the symbols and what indexes those  
11:55 - cards should be and then passing that into the 
card view element as the binding alright now I  
12:03 - want to solve another issue here which is that 
it's really hard to detect when there is a match  
12:08 - like we just had if you can't you can't even see 
it unless you notice your credits going up but  
12:14 - the same time they're going down so it's always 
changing and this was just really hard to tell  
12:18 - when you get a match and so what I'd like to do 
is change the backgrounds to green when there  
12:24 - is a match and this is going to give us another 
opportunity to practice using state properties  
12:30 - and bindings so I'm gonna create a state property 
up here for the three background colors for the  
12:37 - cards just like we have here that represents you 
know which icons they are and then we're going  
12:42 - to pass that as a binding into the card view 
here and have the background change when there  
12:49 - is a match alright so first let's declare a new 
state property here I'm gonna call it backgrounds
13:00 - so I'm gonna default them to all white and all 
three slots and then let's go into the card view  
13:08 - and add a binding so instead of just using white 
by default we're going to have that value as a  
13:17 - binding and this is going to be of type color and 
again I'm not going to assign anything to it here  
13:24 - so that we are going to be forced to pass it in 
when we create the card view element and don't  
13:30 - forget instead of hard-coding white we're gonna 
use the binding alright so here this preview is  
13:38 - broken because now we have to pass in an extra 
binding so let's go ahead and just hit fix so it  
13:43 - adds that label for us and then we're gonna do a 
binding constant well this is gonna be a color so  
13:53 - let's just say green we'll save it and I'm pretty 
sure this preview is actually broken yeah because  
14:02 - the project is broken right now don't forget we 
just added another binding and inside content  
14:10 - view we create these three cards these are not 
valid instantiations of card view anymore so it  
14:18 - expects say another another binding to be passed 
in all right so let's add that parameter here  
14:24 - and we're gonna pass in the background color so 
backgrounds zero right this is a binding for the  
14:34 - state property that we have up here so that's 
where that's coming from and we're gonna do the  
14:40 - same thing with the second card view let's have 
that parameter and then backgrounds one this time
14:51 - backgrounds - okay so now everything's set 
up if we run the project now it's going to  
15:03 - be fine but however the backgrounds aren't 
going to change because we actually don't  
15:07 - have any code to update the backgrounds state 
property so we have to update that when there  
15:13 - is a match and we have to don't forget we 
have to set it back to white when the user  
15:19 - spins again so right here they won so 
we're gonna update the state property  
15:27 - update backgrounds to green so we're gonna 
say self-thought backgrounds equals color  
15:40 - green we're gonna do this for all three and 
I'm going to show you another way of writing  
15:45 - these three statements using a map function and 
just in a second but let me just do it this way  
15:52 - first that might be something you do know or 
something you don't know but it'll be helpful
15:59 - set backgrounds back to white here because 
this is where the user hits the spin button  
16:09 - before we actually spin anything all right so we 
have when the user taps on the button we set it  
16:18 - to white and then if there is a match we update 
it to green so let's run this project and watch  
16:26 - our code take effect so it's white did you see 
that there we go so that's pretty cool so now  
16:37 - let's talk about that map function I mentioned 
so the map function is something that you can do  
16:43 - with a race when you want to do something with 
every single element of the Ray and it's a more  
16:48 - concise way of writing it rather than repeating 
yourself three times like this and imagine if we  
16:54 - had even more backgrounds like nine backgrounds 
or something like that then this would be nine  
16:59 - lines of code so here is just another way to 
write this in case you don't know about them  
17:04 - function and I don't think I've really ever taught 
it in any of my other videos just yet so here's  
17:10 - how it goes so it is a function that you can use 
with an ax right so you go dot map right and you  
17:17 - pass in a closure and this is the code that you 
want to run on every single element of your right  
17:25 - so you can see that there is this is the element 
this parameter here represents the element that  
17:34 - is currently in that array slot or you know 
this is the element that you're transforming  
17:39 - because we don't want to transform the color 
white like we're not gonna do anything with  
17:45 - that color instead we want to replace it right 
we want to assign something new into that slot  
17:49 - so we actually don't need this parameter so we're 
just going to replace this with an underscore and  
17:56 - as for the code we simply write color dot white 
and that is essentially going to replace whatever  
18:06 - was there and look the result of the call to map 
is unused because this function basically returns  
18:14 - a new copy of your rate does it modify your old 
one so what we're going to do is we're going to  
18:20 - assign it back to self dot backgrounds just create 
a little more space here there we go and so this  
18:31 - although it's still three lines is a little more 
concise than writing this a little more elegant  
18:37 - but I do want you to keep in mind that this is 
perfectly fine this really comes in handy when  
18:43 - you have many elements in an array so I'm just 
gonna show you what it would look like we did  
18:51 - it like this right you could do this with the 
color green down here and then if you're really  
19:00 - observant you can also notice that we are running 
the same operation on every single element in the  
19:08 - numbers array as well so we can use a map here so 
self dot numbers equals self dot numbers dot map  
19:17 - alright let's open up that closure again it's 
gonna give me the integer currently which is  
19:25 - the element in that in that slot we don't need 
it so I'm going to put underscore because we  
19:32 - are assigning and we're just gonna run this code 
right here and it's basically basically going to  
19:42 - run this code for every element in the array 
and assign it to that slot so get rid of this  
19:50 - and that's that's an even bigger savings right 
like that made the code a lot more concise but  
19:56 - the thing is for a lot of the beginners who are 
watching this I don't want to start doing this  
20:02 - too much because it's kind of hard to know 
what's going on if you are just starting out  
20:07 - and my primary focus is making sure that you 
understand the code and you can follow along  
20:13 - in terms of the logic and understanding and so 
you know if if it's a lot of extra work like if  
20:20 - there were nine elements and I'm doing the same 
thing to every element that maybe I'll I'll just  
20:24 - mention and use the map again but for this 
I'm simply gonna do it the simplified not so
20:31 - not so concise way just so anybody who is reading 
this no matter kind of what the level even if  
20:41 - you're just starting out can easily understand 
what we're doing however now you know that this  
20:47 - map function that exists you can add it as a tool 
to your arsenal for your Swift development yeah  
20:54 - our slots app is progressing really nicely and if 
you're up for it I actually have a challenge for  
20:59 - you can you add two more rows one to the top and 
one to the bottom for a total of nine cards and  
21:05 - make it so that matches can occur horizontally 
on all three rows and also diagonally and for  
21:12 - extra bonus points can you add a second spin 
button so that the user can either tap one of  
21:19 - them that only checks the middle row for matches 
and the second button which costs five times as  
21:25 - more credits or whatever amount you want but that 
second button checks for just on all three rows  
21:31 - plus the diagonals so it's gonna cost more it's 
higher risk but a higher reward oh and I forgot  
21:37 - one quick tip for the challenge that is actually 
quite crucial so in any of these containers like  
21:44 - a Zed stack or z stack V stack or H stack any of 
these containers they can only contain a maximum  
21:52 - of ten elements inside but don't worry you can 
nest it so let me just give you a quick example  
21:58 - inside of this V stack we have a spacer that's 
one that's two that's three that's four that's  
22:07 - five that's six that's seven that's eight and 
that's nine so inside this V stack we have nine  
22:21 - elements already so you can put one more element 
and that would be ten and that would be completely  
22:28 - okay but if you try and put an eleventh element 
you're gonna see an error and the thing is the  
22:36 - error message isn't very helpful because it's 
just gonna point to something else at least in  
22:41 - this example it's not actually telling you what 
the real problem is and that is that our V stack  
22:47 - has 11 elements so how do you how do you combat 
this well you can let's say this is one solution  
22:55 - you can nest these two elements inside of their 
own V stack and although in this example it kind  
23:03 - of changes the way things look but that's just 
to get your thinking going so just keep in mind  
23:08 - that there is a ten element limit per layout 
container and that if you encounter a Swift UI  
23:16 - error in your preview won't work and you can't 
build your project and the error message doesn't  
23:22 - really make sense just remember that you can 
double check that and as a solution you can  
23:27 - nest these things together share a screenshot of 
your completed challenge with me on social media  
23:34 - and make sure to tag me so I can see it and if you 
also want to earn a special forum badge for your  
23:39 - achievement make sure you post your screenshot 
in my code crew for under this topic I'll link  
23:45 - to that forum thread in the description below and 
if you need help with this challenge the code crew  
23:50 - forum is going to be the place to go to get help 
from myself the team and other developers just  
23:55 - like yourself and as for the solution video I'm 
gonna give you some time to try out this challenge  
24:00 - for yourself first and then when I release that 
solution bail I'll remember to make sure to put a  
24:05 - link to it in the description below alright thanks 
for watching and I'll see you in the next lesson

Cleaned transcript:

hey code crew in the last Swift ey lesson you learned about composing complex views using smaller single purpose views and you also learned about data flow using state and binding properties well in this video we're going to take a look at the slots app that we built and we're gonna see how we can apply these two principles to improve that app but before we dive in if this is your first time here welcome to code with Chris where we can teach you how to make an app even if you've never coded before and you might want to start from the beginning of this Swift UI series playlist in the description below and if you've been following along and watching this Swift UI series from the beginning thank you and please give this video a thumbs up and subscribe if you haven't already alright let's dive in so here we have the slots UI app that we built together a couple of lessons ago and again if you've missed that lesson you can definitely check out the playlist in the link in the description below to follow the series from the start alright so the first thing we're gonna take a look at is what makes sense to break out into its smaller single purpose view and what I like to look for is anything that I tend to have to repeat in the UI so if you've got the same sort of button in a couple of different places or maybe the same type of image element like we do here I mean rather than having this code repeated three times like we have right now we could abstract that card out into its own card view you know its own single purpose of view and then create three instances of that instead just like in the last lesson when we talked about the color sliders so here you can see the code for these three cards we've got these three images they're virtually the same code except for you know what icon gets displayed but we can always use the what we learned about dataflow right use state properties and bindings and pass that data in and the other thing that's good about abstracting this into its a single view is that you know if I wanted to change the look and feel of the cards you can see this code is repeated three times if I wanted to change the corner radius or the background color a little bit I'd have to change it three times but if I abstracted out into a single card view and then just use it three times then I only have to change at one place so it makes maintenance easier so let's go ahead and just do that first before we even talk about data flow so right click here I'm going to add a new file and under iOS or under user interface we're gonna choose swift UI view and I'm gonna call this the card view because that kind of makes sense I'm just gonna move this guy up here and by default you get that text label saying hello world but we don't need that we're gonna go into the content view again and I'm they're really just gonna copy this guy and I'm gonna paste it into here at the body this piece of data we don't have inside this card view so I'm just gonna hard code an image name for now just so we can see something on the righthand side so that's great this lets me know that this is working right and this preview is simply creating an instance of the card view and that's what we see so we'll take that and we'll go back here and I'm going to first remove this one let's do a little test and let's declare a new card view element here you can see that changed I'm gonna do the same thing removing that middle card and same for the last one and that you know just like that we have created a smaller single purpose view in the car view and we've composed we've used it to compose this kind of like bigger more complex view now for this simple swift UI slots app that that is the thing that makes sense to abstract out into its view if we were to you know reuse these other elements in different places if it were a more complex app then there probably more components that I could pull out and make into smaller views but as it stands now I think that's all that makes sense now we run into the next problem which is that these cart views have a hardcoded Apple icon in the carts so we need to somehow be able to change those icons now the consideration for the data flow comes into play so who should be the source of truth for these icons here just to remind you about how they get displayed you know we have a we have an ax right here called symbols and there's an apple star and cherry these represent the possible icon choices or the image names and we have another array called numbers which indicates which icon that card slot should be so this first index of the numbers array represents this card the middle one represents that card and the last index represents that card so depending on what number this is it's gonna kind of result in a different icon here remember in the last lesson we talked about source of truth you know the state properties so we definitely do not want to keep a copy of the numbers here in the content view and keep a copy of you know what individual index this card is also in the card view because that would be duplicating the data right and so it makes sense for me that the content view should be the source of truth and that it should be passing the bindings to these numbers to the card views itself because number one the content view has the logic to check for matches right after they hit the spin button we have some code right here just to check if the numbers you know if this one matches this one and if this one matches this one if we made the card view instead kind of hold its own number right if we had a state here and we said you know we made it hold its own number it would make it harder for us to be able to match to see if this card matches the others so that's why at least my thinking is that right here the content view should be the source of truth of this data and instead we should pass the bindings into the card views so that's what I'm going to try to do here let's hop into our card view and take a look at what we can do so this is the hardcoded string that represents the image so I'm going to create a binding for it so that it can be passed into the card view when it gets created instead of having a hardcoded string there so I'm gonna say binding we're going to say let's just call it symbol it's gonna be of type string I'm not gonna set it to anything because I want it to be passed in and then here instead of hardcoding the string I'm just gonna put symbol and now this preview is broken because you can see here you can't just create a card view element and expect it to be displayed because it needs to know which symbol to display right and it is expecting a binding to be passed in so if you just get rid of those parentheses or brackets you can see that you're supposed to pass in a string type binding so unfortunately we don't have any real binding to pass in to this preview right here but what we can do is pass in a temporary binding value to just for the purpose of the preview so that it can display something so the way you do that is you go finding dot constant and then you can specify a value so it's got to be a string so let's let's teach area so then it's still gonna allow you to you know pass this in as a parameter but it's not a real binding you know it's just a constant value so unfortunately it's not building right now let's just take a look at why here card view type is not convertible ah yeah so back in the content view all of these are broken now as well so why don't I just do the same thing just so we can just do one thing at a time so let me just show you that this this works and now we can actually see something before we actually use real bindings yes okay so there is the parameter label right there okay so if we go back to the card view now and we try to update the preview you can see that we see cherry because that's what we put right here all right now let's go back to the content view and take a look at how we're gonna pass in the bindings for the symbols alright so up here my numbers this is already a state property I'm gonna change this to a state property as well now I'm gonna go down and instead of passing in a binding constant for a cherry right here I can pass in a real binding from the state properties up there that we declared up there so we have symbols and then inside here I had I think I called him number right so this would be zero all right let's just see if that is okay before before I do anything Oh numbers okay so it would help if I could remember my property names all right so we're gonna do the same thing here as well numbers one and this would be symbols numbers okay so let's resume build succeeded and you can see that this reflects the indexes that we have right here in numbers and if I build and run this did I forget anything let's take a look alright so you can see everything is working perfectly here and we've successfully abstracted the card view into its own single purpose smaller view and we've facilitated the data flow where the content view is the source of truth for the symbols and what indexes those cards should be and then passing that into the card view element as the binding alright now I want to solve another issue here which is that it's really hard to detect when there is a match like we just had if you can't you can't even see it unless you notice your credits going up but the same time they're going down so it's always changing and this was just really hard to tell when you get a match and so what I'd like to do is change the backgrounds to green when there is a match and this is going to give us another opportunity to practice using state properties and bindings so I'm gonna create a state property up here for the three background colors for the cards just like we have here that represents you know which icons they are and then we're going to pass that as a binding into the card view here and have the background change when there is a match alright so first let's declare a new state property here I'm gonna call it backgrounds so I'm gonna default them to all white and all three slots and then let's go into the card view and add a binding so instead of just using white by default we're going to have that value as a binding and this is going to be of type color and again I'm not going to assign anything to it here so that we are going to be forced to pass it in when we create the card view element and don't forget instead of hardcoding white we're gonna use the binding alright so here this preview is broken because now we have to pass in an extra binding so let's go ahead and just hit fix so it adds that label for us and then we're gonna do a binding constant well this is gonna be a color so let's just say green we'll save it and I'm pretty sure this preview is actually broken yeah because the project is broken right now don't forget we just added another binding and inside content view we create these three cards these are not valid instantiations of card view anymore so it expects say another another binding to be passed in all right so let's add that parameter here and we're gonna pass in the background color so backgrounds zero right this is a binding for the state property that we have up here so that's where that's coming from and we're gonna do the same thing with the second card view let's have that parameter and then backgrounds one this time backgrounds okay so now everything's set up if we run the project now it's going to be fine but however the backgrounds aren't going to change because we actually don't have any code to update the backgrounds state property so we have to update that when there is a match and we have to don't forget we have to set it back to white when the user spins again so right here they won so we're gonna update the state property update backgrounds to green so we're gonna say selfthought backgrounds equals color green we're gonna do this for all three and I'm going to show you another way of writing these three statements using a map function and just in a second but let me just do it this way first that might be something you do know or something you don't know but it'll be helpful set backgrounds back to white here because this is where the user hits the spin button before we actually spin anything all right so we have when the user taps on the button we set it to white and then if there is a match we update it to green so let's run this project and watch our code take effect so it's white did you see that there we go so that's pretty cool so now let's talk about that map function I mentioned so the map function is something that you can do with a race when you want to do something with every single element of the Ray and it's a more concise way of writing it rather than repeating yourself three times like this and imagine if we had even more backgrounds like nine backgrounds or something like that then this would be nine lines of code so here is just another way to write this in case you don't know about them function and I don't think I've really ever taught it in any of my other videos just yet so here's how it goes so it is a function that you can use with an ax right so you go dot map right and you pass in a closure and this is the code that you want to run on every single element of your right so you can see that there is this is the element this parameter here represents the element that is currently in that array slot or you know this is the element that you're transforming because we don't want to transform the color white like we're not gonna do anything with that color instead we want to replace it right we want to assign something new into that slot so we actually don't need this parameter so we're just going to replace this with an underscore and as for the code we simply write color dot white and that is essentially going to replace whatever was there and look the result of the call to map is unused because this function basically returns a new copy of your rate does it modify your old one so what we're going to do is we're going to assign it back to self dot backgrounds just create a little more space here there we go and so this although it's still three lines is a little more concise than writing this a little more elegant but I do want you to keep in mind that this is perfectly fine this really comes in handy when you have many elements in an array so I'm just gonna show you what it would look like we did it like this right you could do this with the color green down here and then if you're really observant you can also notice that we are running the same operation on every single element in the numbers array as well so we can use a map here so self dot numbers equals self dot numbers dot map alright let's open up that closure again it's gonna give me the integer currently which is the element in that in that slot we don't need it so I'm going to put underscore because we are assigning and we're just gonna run this code right here and it's basically basically going to run this code for every element in the array and assign it to that slot so get rid of this and that's that's an even bigger savings right like that made the code a lot more concise but the thing is for a lot of the beginners who are watching this I don't want to start doing this too much because it's kind of hard to know what's going on if you are just starting out and my primary focus is making sure that you understand the code and you can follow along in terms of the logic and understanding and so you know if if it's a lot of extra work like if there were nine elements and I'm doing the same thing to every element that maybe I'll I'll just mention and use the map again but for this I'm simply gonna do it the simplified not so not so concise way just so anybody who is reading this no matter kind of what the level even if you're just starting out can easily understand what we're doing however now you know that this map function that exists you can add it as a tool to your arsenal for your Swift development yeah our slots app is progressing really nicely and if you're up for it I actually have a challenge for you can you add two more rows one to the top and one to the bottom for a total of nine cards and make it so that matches can occur horizontally on all three rows and also diagonally and for extra bonus points can you add a second spin button so that the user can either tap one of them that only checks the middle row for matches and the second button which costs five times as more credits or whatever amount you want but that second button checks for just on all three rows plus the diagonals so it's gonna cost more it's higher risk but a higher reward oh and I forgot one quick tip for the challenge that is actually quite crucial so in any of these containers like a Zed stack or z stack V stack or H stack any of these containers they can only contain a maximum of ten elements inside but don't worry you can nest it so let me just give you a quick example inside of this V stack we have a spacer that's one that's two that's three that's four that's five that's six that's seven that's eight and that's nine so inside this V stack we have nine elements already so you can put one more element and that would be ten and that would be completely okay but if you try and put an eleventh element you're gonna see an error and the thing is the error message isn't very helpful because it's just gonna point to something else at least in this example it's not actually telling you what the real problem is and that is that our V stack has 11 elements so how do you how do you combat this well you can let's say this is one solution you can nest these two elements inside of their own V stack and although in this example it kind of changes the way things look but that's just to get your thinking going so just keep in mind that there is a ten element limit per layout container and that if you encounter a Swift UI error in your preview won't work and you can't build your project and the error message doesn't really make sense just remember that you can double check that and as a solution you can nest these things together share a screenshot of your completed challenge with me on social media and make sure to tag me so I can see it and if you also want to earn a special forum badge for your achievement make sure you post your screenshot in my code crew for under this topic I'll link to that forum thread in the description below and if you need help with this challenge the code crew forum is going to be the place to go to get help from myself the team and other developers just like yourself and as for the solution video I'm gonna give you some time to try out this challenge for yourself first and then when I release that solution bail I'll remember to make sure to put a link to it in the description below alright thanks for watching and I'll see you in the next lesson
