With timestamps:

00:00 - learn how to add a widget extension to 
an existing app including reusing service  
00:05 - classes building uis for different size classes 
and scheduling widget updates through a timeline  
00:13 - hey code crew this is floor i've been developing 
ios apps since 2016 and i've been working on many  
00:19 - different widgets over the past few months so 
i'm super excited to teach you about widget kit  
00:24 - in this series this is lesson one where i will 
show you examples for great widgets by apple  
00:30 - the current project setup and the example app 
that i have prepared for you next we will add a  
00:35 - widget extension and go through everything that 
xcode automatically generates for us let's get  
00:41 - started with some examples of grade widgets so you 
understand how all of this works how the ecosystem  
00:46 - works and how they are built up so there is this 
great article from the apple developer website  
00:52 - which is linked in the description which just 
gives a brief introduction to widget kit and i  
00:57 - just want to show you a few of the examples that 
they have on their website here they have the  
01:01 - little calendar widget they have a weather widget 
news music also for the activity app and so on  
01:12 - then there are a bit larger widgets for the 
ipad with photos and a bigger calendar view  
01:19 - but one thing that unites all of them is that they 
have at a glance information so you for example in  
01:26 - the calendar widget you only have the next two 
events showing so when you have a glance at the  
01:32 - widget you immediately know what it wants to show 
you and what information is there same for the  
01:37 - weather widget you just have a quick look at it 
and then you instantly know the temperature and  
01:42 - the current weather conditions there are also 
some more widgets that i want to show you that i  
01:46 - have personally worked on the first one is a food 
tracker app which is based around a medium sized  
01:53 - widget that you can see in the screenshot in the 
middle here and the idea is basically that you can  
01:59 - track your meals through a widget where you can 
just tap either on the healthy or on the junk  
02:04 - side of the widget the app will open up and all of 
your meals will get locked that way so there's a  
02:11 - tiny bit of interactivity here but i will tell you 
more about that in just a second and then there's  
02:16 - also another widget that i made for a swift ui jam 
a few weeks ago which is an almost fully working  
02:23 - calculator widget so we can watch the video here 
it looks just like the calculator app from your  
02:30 - iphone but then you can tap on the numbers and 
on the operators the app will briefly open up  
02:36 - close back down again and then you will see 
your calculation and the end result inside of  
02:41 - the widget i think this is very cool obviously 
this is not what apple intended widgets to be  
02:46 - but there you can just see what's possible 
with the technology so getting back to widget  
02:51 - kit itself widgets are built entirely in swift ui 
so it is not not possible to pull the ui kit for  
02:58 - example via ui view representables or your view 
controller representables currently you can only  
03:04 - use swift ui to build out the ui side so what's 
displayed inside of the widget as i said the main  
03:11 - idea is to provide at a glance information these 
are just tiny portions of the screen the widgets  
03:16 - are based on a timeline so you the developer can 
provide a timeline scheduled with timeline entries  
03:25 - that all have an associated date and some data 
associated as well so you can for example schedule  
03:32 - a timeline over the next five hours where 
at every full hour there is a timeline entry  
03:38 - and then ios or ipad os or even mac os whichever 
system your widget is running on will execute  
03:45 - that timeline and refresh the widget by itself so 
you're not guaranteed to have the widget refresh  
03:50 - at exactly the time in your timeline entries 
that you have specified but the system handles  
03:57 - it and the system also has some limitations 
for example you cannot refresh your widget  
04:03 - a few hundred times per day there are just certain 
restrictions there set by ios but most users will  
04:09 - never notice this and for most users the widgets 
will always stay up to date we will have a look  
04:14 - at the timeline the timeline entries and so on in 
partially in this but mainly in the next lesson  
04:20 - and then one last very important thing when 
talking about widgets is that you understand that  
04:26 - they are static ui so there are no animations 
there are no videos there is no navigation  
04:32 - and there are also no buttons the only dynamic 
thing that a widget can do is link into your  
04:40 - main app and pass in some data there we will have 
a look at that in the third lesson of this series  
04:47 - but until then you can just assume that a widget 
is more or less a very static view okay to get  
04:55 - us started a bit quicker i have already prepared 
a very simple example app this is a simple to-do  
05:01 - list app based on the json placeholder api you 
might have already seen the json placeholder api  
05:07 - if you want to have a more specific look at 
it it will be linked down in the description  
05:12 - it's a very generic api with some yeah as the 
name suggests placeholder json data for users for  
05:19 - posts and so on but we're just using the to do's 
route which you will also see in just a second  
05:24 - so the main app only has a single view which you 
can see here on the right hand side if i press  
05:29 - play then all of the to do's will be loaded you 
we will have a list here with the to do title  
05:37 - on the left hand side and then the statues whether 
it's completed or not on the right hand side so  
05:42 - some of these to-do's are open some of them are 
already completed and if we tap on a to-do item  
05:49 - here a little sheet will come up telling us 
the id of the to-do then once again the title  
05:55 - and whether it's open or completed and then you 
can of course dismiss the sheet like always okay  
06:01 - so let's briefly go over the content view here 
so you understand how this all was built and  
06:06 - then we will have a look at our data class or to 
do and then also our service class so first of all  
06:14 - as you can already see we have a navigation title 
here so we must also have a navigation view which  
06:19 - surrounds everything in our content view here and 
then mainly we just have this single list here  
06:26 - the rest of the code is just view modifiers but 
we mainly have the single list here iterating over  
06:33 - all of the to do's which is a state variable here 
in the beginning this is an empty array of to do  
06:40 - but later on i will show you how this gets filled 
and then inside of the list we just have a simple  
06:46 - button for every row the button action is to 
set the selected to do which is another state  
06:53 - variable to the to do of this current row so for 
example if i tap on the first one then that will  
06:59 - will be the selected to do which is used for 
our sheet here at the bottom this has the  
07:06 - item initializer where you can pass in an 
optional identifiable item in our case our  
07:13 - selected to do state and if that is not 
nil so if there is some to do selected  
07:19 - then the sheet will show up and show just a simple 
group box here i think this is not too important  
07:25 - this is just for demonstration purposes if we 
just miss the sheet again we have our list again  
07:31 - and then inside of the list button there is just 
a simple attributed string which is brand new in  
07:36 - ios 15 where you can use some parts of markdown to 
for example bold a region of text so here you can  
07:44 - see these double asterisks before and after the 
completed or open text which we just bolded as i  
07:52 - said this is attributed string stuff not important 
for this series i just wanted to include it to  
07:57 - make it look a tiny bit nicer since this is a very 
plain ui okay let's continue down so we already  
08:03 - have covered the navigation title it's just my 
to-do's and now the interesting part comes so  
08:09 - um for our to-do servers i have chosen to use 
the new script concurrency features if you want  
08:15 - to learn more about that there is also a series 
about such concurrency made by stuart lynch  
08:20 - um so it will probably also be linked down below 
you can go there after this video or if you have  
08:27 - any understanding issues then you can just 
go there and have a look at it but i think  
08:31 - it will be pretty straightforward basically what 
we're doing is we're attaching a task to the list  
08:38 - task is very similar to unappear so the code in 
here gets executed the first time that the view  
08:45 - appears but you can execute a synchronous code in 
here so we will have a look at how that works in  
08:52 - just a second but bear in mind so this task 
will get executed one time at the beginning  
08:56 - and everything in here is happening 
asynchronously in a background thread  
09:02 - or can happen in the background that can also 
happen in the main thread depending on how it  
09:06 - is scheduled internally and all that this task 
does in this case is call our to do service  
09:12 - dot get all to do's function which calls the json 
placeholder api gets back all of the to do data  
09:19 - and then puts it into our to do's state variable 
up here which will then be used inside of the list  
09:28 - okay and then the last modifier here i already 
told you about the sheet so i think this should  
09:33 - be pretty clear now let's move on into the data 
folder on the left hand side here so first of all  
09:40 - we have our struct to do it's important that 
this had this conforms to two protocols the  
09:45 - first one is decodable so we can decode it from 
json which you will see in a second in the to-do  
09:50 - service and the second protocol is identifiable 
so we can iterate over it in our swift ui list  
09:58 - this just has four very simple attributes the 
user id the id of the to do the title of the to do  
10:07 - and whether the to-do is completed or not let's 
jump real quick into the json placeholder api and  
10:14 - let's go to the endpoint that we're using which 
is slash to do's and here you can see where this  
10:20 - data is coming from so this is just a json file 
sitting on the server and there you have um all  
10:27 - of the same fields that i just showed you in our 
to-do structs so you have the user id which is an  
10:31 - integer the id which is an integer the title which 
is a string and then completed which is a boolean
10:41 - okay and then the last file that i have prepared 
is the to do service here this is just a very  
10:47 - simple helper class to fetch all of the to-do's 
from the json placeholder api since there is no  
10:53 - need to instantiate a new to-do service every 
time that we use it i just added a static shared  
11:00 - instance here so we can always just say to do 
service dot shared instead of instantiating a  
11:05 - new to do service we have our base url which is 
just the address of jsonplaceholder.typeycode.com
11:14 - and then it gets a bit more interesting 
with these three functions here  
11:18 - the first one is a very generic networking 
function that you can use in any of your  
11:23 - projects really but the important thing is that 
it is built using the swift concurrency features  
11:30 - so let's have a brief look at how that works 
so inside of the function we first have  
11:36 - or we first construct our url so when we call this 
function we pass in an endpoint for example todos  
11:44 - and then the function will generate a url for 
us so in this case it would be https colon  
11:53 - slash slash jsonplaceholder.typeycode.com slash 
and then here it would be for example to do's  
12:01 - so this will be the endpoint we constructed 
here this can fail so if in case it fails we  
12:06 - will just throw a url error of that url once 
we have our url we can use the url session  
12:14 - dot shared dot data function which is similar 
to data task or data task publisher if you were  
12:20 - using combine previously this function 
just creates a or takes the shared url  
12:26 - session goes to the url that you uh handed over 
and then fetches all of the data from that url  
12:34 - this is an asynchronous task so you have to 
wait for the results to be coming in and this  
12:42 - can actually also fail or throw an error and hence 
we need to try to await the data from this url  
12:51 - this function actually gives back both data and 
a url response so in your app you might want to  
12:58 - check the url response for the status code 
or any info that the server gave back to you  
13:03 - in our case we don't care about that so we can 
just omit the second value of the tuple here  
13:08 - the url response by using the underscore and we 
will just unpack the tuple into our data variable  
13:16 - and then the last step is pretty straightforward 
we just construct a json decoder and then we  
13:22 - decode our to do in our case from the data now 
the interesting part here is and hence the name  
13:30 - generic helper function we have some 
generics here so we have a generic type t  
13:36 - which basically means that we could use this 
fetch function to fetch any type of data  
13:41 - we could also fetch some users or whatever as 
long as that struct is decodable as the generic  
13:49 - condition here says so let's see how that works 
i have two endpoint functions basically the  
13:55 - first one is to get all to do's from the json 
placeholder which once again is asynchronous  
14:02 - and can throw arrows but this one 
will return an array of type to do  
14:07 - and this will basically just call our fetch 
function up here from the to-do's endpoint  
14:14 - so basically just the one that i showed you in 
the browser a minute ago as you've already seen  
14:19 - the fetch function is asynchronous it can throw so 
we need to try to avoid the result of the function  
14:26 - since we are using generics here we need to 
explicitly specify the type that we want to  
14:32 - get back so in this case if we want to get all to 
do's we want an array of type to do and then we  
14:39 - just return the result of the fetch function 
and then very similar for the last function  
14:46 - which is called get to do with id we can use 
this one to get the data for a specific to do  
14:53 - which we're using for the sheet for example this 
function returns a single to-do instead of an  
15:01 - array of to-do's and it's basically the exact 
same from before so we need to specify the type  
15:07 - over here since we are dealing with generics 
and then the only thing that we're changing  
15:12 - is the end point so now we're not querying for 
all to do's requiring for to do's slash our id  
15:18 - and if we look at that in the browser so 
here we have slash to do's and now we say  
15:23 - slash one for example this will give us just the 
first to-do item okay so now that you have seen  
15:30 - the sample app that i have already created for 
you let's do the last thing for this video which  
15:36 - is adding the widget extension to do that it's 
also very very simple since xcode does almost  
15:41 - everything for you you just go to file new 
target and then in here you can either scroll  
15:50 - through all of the extensions or you can just 
filter for widget extension double click it  
15:58 - then give it a name so in our case i 
will call it widget kit course widget  
16:08 - make sure to uncheck include configuration intent 
that is something that we're not doing in this  
16:13 - series configuration intent can basically be used 
for siri it can be used for the user to customize  
16:20 - your widget but this is not important for the 
series once you're done just hit the finish button
16:28 - and here you can say activate the scheme if you 
want to which what this does is basically it  
16:34 - changes the theme up here in xcode so once you 
have an extension you can select when you're  
16:40 - running your app which scheme you want 
to run so you can then either run your  
16:43 - main app in the simulator or just run 
the widget extension in your simulator  
16:49 - for now let's just say activate if 
you want to change this later on  
16:52 - you can just go up here and select either 
your main app or your widget extension  
16:59 - okay and then on the left hand side here 
you can see that a new folder was generated  
17:04 - which is called just what we entered 
into the text field if we open that up  
17:09 - there's just three files a basic info.plist 
file an asset catalog that you can use to  
17:15 - provide assets like images and then there is 
the widget kit course underscore widget file  
17:21 - this file contains all of the auto generated code 
from xcode let me go over the extension and tell  
17:28 - you a few words about each of the different 
types that got generated and actually let's  
17:33 - start at the bottom here so first of all same as 
in swift ui which i just closed there is also a  
17:40 - preview available for your widgets i'm closing 
this right now so we have a bit more space  
17:46 - by the way to open and close that canvas you 
can press command option enter and then there  
17:53 - is something that you're probably already familiar 
with if you have worked in swift ui before  
17:59 - because there is now this add main widget 
struct this is actually super similar to the  
18:06 - admain abstract in your normal app where you have 
a body in which you just present your content view  
18:13 - inside of a window group in this case but it also 
has the add main attribute which basically tells  
18:20 - the device this is the entry point to the app 
start here and then it's the exact same thing for  
18:26 - your widget this add main attribute will just tell 
the device this is the main starting point for the  
18:32 - widget called this and then you're good to go 
so of course this is not an app this is a widget  
18:39 - and it also has a body the body has the generic 
type of or the opaque type of widget configuration  
18:48 - you can have there are basically two different 
types of widget configurations the first one  
18:53 - is a static configuration which we are using in 
most widgets actually use a static configuration  
18:58 - and there is also an intent configuration which 
you can use if you want to let the user edit the  
19:04 - widget directly on the home screen not important 
for this series but just so you know there's two  
19:09 - different types of configurations and then into 
the configuration you just pass basically an  
19:15 - identifier of the widget which is defined up here 
by default this is just the name of your widget  
19:22 - extension target you can change this of course 
especially if you add multiple widgets to your  
19:28 - app later on and then into the configuration 
you also pass in a timeline provider we will  
19:34 - have a look at that in just a second inside of 
the configuration you then have your actual view  
19:39 - now this has a very long and complicated 
name we would change that also in a minute  
19:45 - and into that view you pass in your timeline 
entries if you recall in the beginning of this  
19:50 - lesson i talked to you about you can schedule a 
timeline with different timeline entries for set  
19:57 - dates which in turn contains some data that 
you can pass to your view and basically these  
20:03 - timeline entries here come from your timeline 
provider and get passed into your view over here  
20:11 - you will see this more concretely in just 
a second you can also customize your widget  
20:16 - configuration by for example giving it a display 
name which will then show up in the app library  
20:22 - and you can also give it a description 
okay let's scroll up a bit here  
20:28 - the next struct that got auto generated is the 
actual view this view gets passed in a timeline  
20:36 - entry which is that piece of data that's scheduled 
through your timeline and then this example widget  
20:43 - here that gets auto-generated just shows some text 
of the current date of the entry so nothing very  
20:50 - special here and then the entry actually doesn't 
contain any data right now we will customize this  
20:57 - in the next lesson the only important thing here 
is that your entry conforms to the timeline entry  
21:04 - protocol which requires the entry to have 
a date property and then up here the most  
21:12 - important and most interesting part of widgets 
is the timeline provider so all of this over here  
21:20 - the timeline provider is responsible for 
scheduling your timeline entries for your widget  
21:27 - over time for the next couple of hours for the 
next day or even weeks however long you want to  
21:32 - schedule it there are three main functions 
functions that you need to implement here  
21:38 - first of all the placeholder function this is 
used when the user is selecting your widget in  
21:44 - the widget gallery on their actual device then 
there is the get snapshot function which just  
21:51 - gets back the current version of the widget with 
just a simple timeline entry or just a single  
21:57 - timeline entry and then there's the get timeline 
function which you can use to schedule a timeline  
22:04 - for your widget including when it will refresh 
how often it will refresh and which data it will  
22:09 - show the very last thing for this video will be 
taking all of these different structs and moving  
22:17 - them into their own files to make it a bit easier 
to read and to understand what we're working with  
22:23 - so over here in our widget folder we will 
add a new file and call this one provider
22:32 - and now a very very crucial detail when you 
create this file is that it needs to be in the  
22:39 - widget target and not in the app target now 
you can hit create and in here let's import  
22:46 - widget kit and then let's move our provider 
our timeline provider from the generated file  
22:56 - into this new file and let's do the same 
for the simple entry and the view as well
23:05 - so create new file swift file let's 
call it simple entry make sure that the  
23:12 - widget extension is checked here hit create import 
widget kit and then copy over our simple entry
23:24 - just like this and then one last time for 
our view here so let's hit command n new file  
23:33 - let's call this widget view hit create here 
we need to import both widget kit and swift ui
23:44 - let's copy over this struct over 
here and move it into this new file  
23:53 - and then we can also command click on it and 
say rename and then rename this long name  
24:00 - to just widget view let's also remove this 
space here let's copy the name and make sure  
24:08 - that it was renamed everywhere so for example 
for some reason xcode didn't rename it over here  
24:14 - so let's get rid of these old names and replace 
them with the new shorter name in this lesson you  
24:21 - learned about what can be done with widgets and 
how they are internally structured you saw that a  
24:26 - widget is based on a timeline and timeline entries 
which get displayed in a plain old swift ui view

Cleaned transcript:

learn how to add a widget extension to an existing app including reusing service classes building uis for different size classes and scheduling widget updates through a timeline hey code crew this is floor i've been developing ios apps since 2016 and i've been working on many different widgets over the past few months so i'm super excited to teach you about widget kit in this series this is lesson one where i will show you examples for great widgets by apple the current project setup and the example app that i have prepared for you next we will add a widget extension and go through everything that xcode automatically generates for us let's get started with some examples of grade widgets so you understand how all of this works how the ecosystem works and how they are built up so there is this great article from the apple developer website which is linked in the description which just gives a brief introduction to widget kit and i just want to show you a few of the examples that they have on their website here they have the little calendar widget they have a weather widget news music also for the activity app and so on then there are a bit larger widgets for the ipad with photos and a bigger calendar view but one thing that unites all of them is that they have at a glance information so you for example in the calendar widget you only have the next two events showing so when you have a glance at the widget you immediately know what it wants to show you and what information is there same for the weather widget you just have a quick look at it and then you instantly know the temperature and the current weather conditions there are also some more widgets that i want to show you that i have personally worked on the first one is a food tracker app which is based around a medium sized widget that you can see in the screenshot in the middle here and the idea is basically that you can track your meals through a widget where you can just tap either on the healthy or on the junk side of the widget the app will open up and all of your meals will get locked that way so there's a tiny bit of interactivity here but i will tell you more about that in just a second and then there's also another widget that i made for a swift ui jam a few weeks ago which is an almost fully working calculator widget so we can watch the video here it looks just like the calculator app from your iphone but then you can tap on the numbers and on the operators the app will briefly open up close back down again and then you will see your calculation and the end result inside of the widget i think this is very cool obviously this is not what apple intended widgets to be but there you can just see what's possible with the technology so getting back to widget kit itself widgets are built entirely in swift ui so it is not not possible to pull the ui kit for example via ui view representables or your view controller representables currently you can only use swift ui to build out the ui side so what's displayed inside of the widget as i said the main idea is to provide at a glance information these are just tiny portions of the screen the widgets are based on a timeline so you the developer can provide a timeline scheduled with timeline entries that all have an associated date and some data associated as well so you can for example schedule a timeline over the next five hours where at every full hour there is a timeline entry and then ios or ipad os or even mac os whichever system your widget is running on will execute that timeline and refresh the widget by itself so you're not guaranteed to have the widget refresh at exactly the time in your timeline entries that you have specified but the system handles it and the system also has some limitations for example you cannot refresh your widget a few hundred times per day there are just certain restrictions there set by ios but most users will never notice this and for most users the widgets will always stay up to date we will have a look at the timeline the timeline entries and so on in partially in this but mainly in the next lesson and then one last very important thing when talking about widgets is that you understand that they are static ui so there are no animations there are no videos there is no navigation and there are also no buttons the only dynamic thing that a widget can do is link into your main app and pass in some data there we will have a look at that in the third lesson of this series but until then you can just assume that a widget is more or less a very static view okay to get us started a bit quicker i have already prepared a very simple example app this is a simple todo list app based on the json placeholder api you might have already seen the json placeholder api if you want to have a more specific look at it it will be linked down in the description it's a very generic api with some yeah as the name suggests placeholder json data for users for posts and so on but we're just using the to do's route which you will also see in just a second so the main app only has a single view which you can see here on the right hand side if i press play then all of the to do's will be loaded you we will have a list here with the to do title on the left hand side and then the statues whether it's completed or not on the right hand side so some of these todo's are open some of them are already completed and if we tap on a todo item here a little sheet will come up telling us the id of the todo then once again the title and whether it's open or completed and then you can of course dismiss the sheet like always okay so let's briefly go over the content view here so you understand how this all was built and then we will have a look at our data class or to do and then also our service class so first of all as you can already see we have a navigation title here so we must also have a navigation view which surrounds everything in our content view here and then mainly we just have this single list here the rest of the code is just view modifiers but we mainly have the single list here iterating over all of the to do's which is a state variable here in the beginning this is an empty array of to do but later on i will show you how this gets filled and then inside of the list we just have a simple button for every row the button action is to set the selected to do which is another state variable to the to do of this current row so for example if i tap on the first one then that will will be the selected to do which is used for our sheet here at the bottom this has the item initializer where you can pass in an optional identifiable item in our case our selected to do state and if that is not nil so if there is some to do selected then the sheet will show up and show just a simple group box here i think this is not too important this is just for demonstration purposes if we just miss the sheet again we have our list again and then inside of the list button there is just a simple attributed string which is brand new in ios 15 where you can use some parts of markdown to for example bold a region of text so here you can see these double asterisks before and after the completed or open text which we just bolded as i said this is attributed string stuff not important for this series i just wanted to include it to make it look a tiny bit nicer since this is a very plain ui okay let's continue down so we already have covered the navigation title it's just my todo's and now the interesting part comes so um for our todo servers i have chosen to use the new script concurrency features if you want to learn more about that there is also a series about such concurrency made by stuart lynch um so it will probably also be linked down below you can go there after this video or if you have any understanding issues then you can just go there and have a look at it but i think it will be pretty straightforward basically what we're doing is we're attaching a task to the list task is very similar to unappear so the code in here gets executed the first time that the view appears but you can execute a synchronous code in here so we will have a look at how that works in just a second but bear in mind so this task will get executed one time at the beginning and everything in here is happening asynchronously in a background thread or can happen in the background that can also happen in the main thread depending on how it is scheduled internally and all that this task does in this case is call our to do service dot get all to do's function which calls the json placeholder api gets back all of the to do data and then puts it into our to do's state variable up here which will then be used inside of the list okay and then the last modifier here i already told you about the sheet so i think this should be pretty clear now let's move on into the data folder on the left hand side here so first of all we have our struct to do it's important that this had this conforms to two protocols the first one is decodable so we can decode it from json which you will see in a second in the todo service and the second protocol is identifiable so we can iterate over it in our swift ui list this just has four very simple attributes the user id the id of the to do the title of the to do and whether the todo is completed or not let's jump real quick into the json placeholder api and let's go to the endpoint that we're using which is slash to do's and here you can see where this data is coming from so this is just a json file sitting on the server and there you have um all of the same fields that i just showed you in our todo structs so you have the user id which is an integer the id which is an integer the title which is a string and then completed which is a boolean okay and then the last file that i have prepared is the to do service here this is just a very simple helper class to fetch all of the todo's from the json placeholder api since there is no need to instantiate a new todo service every time that we use it i just added a static shared instance here so we can always just say to do service dot shared instead of instantiating a new to do service we have our base url which is just the address of jsonplaceholder.typeycode.com and then it gets a bit more interesting with these three functions here the first one is a very generic networking function that you can use in any of your projects really but the important thing is that it is built using the swift concurrency features so let's have a brief look at how that works so inside of the function we first have or we first construct our url so when we call this function we pass in an endpoint for example todos and then the function will generate a url for us so in this case it would be https colon slash slash jsonplaceholder.typeycode.com slash and then here it would be for example to do's so this will be the endpoint we constructed here this can fail so if in case it fails we will just throw a url error of that url once we have our url we can use the url session dot shared dot data function which is similar to data task or data task publisher if you were using combine previously this function just creates a or takes the shared url session goes to the url that you uh handed over and then fetches all of the data from that url this is an asynchronous task so you have to wait for the results to be coming in and this can actually also fail or throw an error and hence we need to try to await the data from this url this function actually gives back both data and a url response so in your app you might want to check the url response for the status code or any info that the server gave back to you in our case we don't care about that so we can just omit the second value of the tuple here the url response by using the underscore and we will just unpack the tuple into our data variable and then the last step is pretty straightforward we just construct a json decoder and then we decode our to do in our case from the data now the interesting part here is and hence the name generic helper function we have some generics here so we have a generic type t which basically means that we could use this fetch function to fetch any type of data we could also fetch some users or whatever as long as that struct is decodable as the generic condition here says so let's see how that works i have two endpoint functions basically the first one is to get all to do's from the json placeholder which once again is asynchronous and can throw arrows but this one will return an array of type to do and this will basically just call our fetch function up here from the todo's endpoint so basically just the one that i showed you in the browser a minute ago as you've already seen the fetch function is asynchronous it can throw so we need to try to avoid the result of the function since we are using generics here we need to explicitly specify the type that we want to get back so in this case if we want to get all to do's we want an array of type to do and then we just return the result of the fetch function and then very similar for the last function which is called get to do with id we can use this one to get the data for a specific to do which we're using for the sheet for example this function returns a single todo instead of an array of todo's and it's basically the exact same from before so we need to specify the type over here since we are dealing with generics and then the only thing that we're changing is the end point so now we're not querying for all to do's requiring for to do's slash our id and if we look at that in the browser so here we have slash to do's and now we say slash one for example this will give us just the first todo item okay so now that you have seen the sample app that i have already created for you let's do the last thing for this video which is adding the widget extension to do that it's also very very simple since xcode does almost everything for you you just go to file new target and then in here you can either scroll through all of the extensions or you can just filter for widget extension double click it then give it a name so in our case i will call it widget kit course widget make sure to uncheck include configuration intent that is something that we're not doing in this series configuration intent can basically be used for siri it can be used for the user to customize your widget but this is not important for the series once you're done just hit the finish button and here you can say activate the scheme if you want to which what this does is basically it changes the theme up here in xcode so once you have an extension you can select when you're running your app which scheme you want to run so you can then either run your main app in the simulator or just run the widget extension in your simulator for now let's just say activate if you want to change this later on you can just go up here and select either your main app or your widget extension okay and then on the left hand side here you can see that a new folder was generated which is called just what we entered into the text field if we open that up there's just three files a basic info.plist file an asset catalog that you can use to provide assets like images and then there is the widget kit course underscore widget file this file contains all of the auto generated code from xcode let me go over the extension and tell you a few words about each of the different types that got generated and actually let's start at the bottom here so first of all same as in swift ui which i just closed there is also a preview available for your widgets i'm closing this right now so we have a bit more space by the way to open and close that canvas you can press command option enter and then there is something that you're probably already familiar with if you have worked in swift ui before because there is now this add main widget struct this is actually super similar to the admain abstract in your normal app where you have a body in which you just present your content view inside of a window group in this case but it also has the add main attribute which basically tells the device this is the entry point to the app start here and then it's the exact same thing for your widget this add main attribute will just tell the device this is the main starting point for the widget called this and then you're good to go so of course this is not an app this is a widget and it also has a body the body has the generic type of or the opaque type of widget configuration you can have there are basically two different types of widget configurations the first one is a static configuration which we are using in most widgets actually use a static configuration and there is also an intent configuration which you can use if you want to let the user edit the widget directly on the home screen not important for this series but just so you know there's two different types of configurations and then into the configuration you just pass basically an identifier of the widget which is defined up here by default this is just the name of your widget extension target you can change this of course especially if you add multiple widgets to your app later on and then into the configuration you also pass in a timeline provider we will have a look at that in just a second inside of the configuration you then have your actual view now this has a very long and complicated name we would change that also in a minute and into that view you pass in your timeline entries if you recall in the beginning of this lesson i talked to you about you can schedule a timeline with different timeline entries for set dates which in turn contains some data that you can pass to your view and basically these timeline entries here come from your timeline provider and get passed into your view over here you will see this more concretely in just a second you can also customize your widget configuration by for example giving it a display name which will then show up in the app library and you can also give it a description okay let's scroll up a bit here the next struct that got auto generated is the actual view this view gets passed in a timeline entry which is that piece of data that's scheduled through your timeline and then this example widget here that gets autogenerated just shows some text of the current date of the entry so nothing very special here and then the entry actually doesn't contain any data right now we will customize this in the next lesson the only important thing here is that your entry conforms to the timeline entry protocol which requires the entry to have a date property and then up here the most important and most interesting part of widgets is the timeline provider so all of this over here the timeline provider is responsible for scheduling your timeline entries for your widget over time for the next couple of hours for the next day or even weeks however long you want to schedule it there are three main functions functions that you need to implement here first of all the placeholder function this is used when the user is selecting your widget in the widget gallery on their actual device then there is the get snapshot function which just gets back the current version of the widget with just a simple timeline entry or just a single timeline entry and then there's the get timeline function which you can use to schedule a timeline for your widget including when it will refresh how often it will refresh and which data it will show the very last thing for this video will be taking all of these different structs and moving them into their own files to make it a bit easier to read and to understand what we're working with so over here in our widget folder we will add a new file and call this one provider and now a very very crucial detail when you create this file is that it needs to be in the widget target and not in the app target now you can hit create and in here let's import widget kit and then let's move our provider our timeline provider from the generated file into this new file and let's do the same for the simple entry and the view as well so create new file swift file let's call it simple entry make sure that the widget extension is checked here hit create import widget kit and then copy over our simple entry just like this and then one last time for our view here so let's hit command n new file let's call this widget view hit create here we need to import both widget kit and swift ui let's copy over this struct over here and move it into this new file and then we can also command click on it and say rename and then rename this long name to just widget view let's also remove this space here let's copy the name and make sure that it was renamed everywhere so for example for some reason xcode didn't rename it over here so let's get rid of these old names and replace them with the new shorter name in this lesson you learned about what can be done with widgets and how they are internally structured you saw that a widget is based on a timeline and timeline entries which get displayed in a plain old swift ui view
