With timestamps:

00:00 - hi my name is stuart lynch and i'm very
00:02 - happy to be offering you this series on
00:04 - behalf of code with chris
00:07 - though the title of this series is ios
00:09 - concurrency it is much much more
00:12 - it's a six part series where i'll
00:14 - introduce you to json decoding
00:16 - and creating models from json building
00:19 - an api service to perform asynchronous
00:22 - network calls to fetch that json
00:25 - we'll go through the traditional
00:26 - completion handler-based url functions
00:29 - handling and reporting errors along the
00:31 - way
00:32 - there are a lot of topics covered as my
00:34 - intention is to provide you with methods
00:37 - and understanding that you'll be able to
00:38 - apply to your own projects both now and
00:41 - in the future
00:43 - in this first video we'll focus on
00:45 - creating our models from the json and an
00:48 - api service to handle the process
00:50 - we'll create a generic function to
00:52 - handle the different api endpoints and
00:54 - models and use a result based completion
00:57 - handler with our own designed api error
01:01 - if this is something you're interested
01:02 - in then let's get started
01:06 - first create a new xcode ios app project
01:10 - and make sure it's a swift ui project
01:12 - and name it something like ios
01:14 - concurrency
01:17 - now i always like to add an app icon and
01:20 - launch screen to my app so that they are
01:21 - easily recognizable in the simulator or
01:24 - on my phone if i install it there
01:26 - i provided you with some resources for
01:28 - this project with these two items
01:30 - already created
01:32 - you can find those in the link in the
01:34 - description below
01:38 - so go to the assets folder of your
01:40 - project
01:41 - and drag the launch screen image into
01:43 - that folder
01:47 - next select your app's target
01:51 - and then the info tab to see the new ios
01:54 - 15 info.plist
01:58 - drop down the disclosure icon on the
02:00 - launch screen
02:02 - then click on the plus icon and select
02:05 - image name
02:07 - make sure that you enter the image name
02:09 - with the lowercase l and uppercase s
02:12 - but don't enter the png extension
02:18 - next right click on the app icon in the
02:21 - assets folder and choose show in finder
02:28 - bring up that provided resources folder
02:30 - once more and move the app icon app icon
02:33 - set into that folder replacing the empty
02:36 - one
02:37 - we've just installed the icon and launch
02:40 - screen
02:44 - if you run your app now in the simulator
02:46 - when it launches you should see that
02:48 - launch screen
02:51 - if you exit the app or quit and check
02:53 - the simulator's home screen
02:55 - you'll see that icon on your app
03:00 - this project is going to be using the
03:02 - json placeholder api to fetch and decode
03:05 - json
03:09 - this api has a number of endpoints that
03:11 - you can use
03:13 - one of them is the user's endpoint where
03:15 - we can fetch json corresponding to 10
03:18 - different users
03:19 - as you can see from this json here
03:25 - let's take a look at the post endpoint
03:29 - users are able to create posts as you
03:31 - can see from this endpoints json
03:34 - and there are 100 of them corresponding
03:36 - to 10 for each of the 10 different users
03:40 - what we'll need to do is to create a
03:42 - struct that will model that json
03:45 - that's why we often call these structs
03:47 - that represent something a model
03:50 - i have created a couple of youtube
03:52 - videos on modeling data from json and
03:54 - there are a number of tools available to
03:56 - you to do that as
03:58 - well
04:00 - the tool that i use a lot is one called
04:02 - ducky model editor
04:05 - however many people are happy with a
04:07 - free web paste tool called quick type
04:12 - these tools are particularly useful if
04:13 - you want to model really complex objects
04:16 - that have nested json our two are
04:18 - relatively simple so i want to model
04:21 - them by hand
04:23 - so first let's create a new group called
04:26 - models
04:29 - next create a new swift file called user
04:36 - now i'm going to want to reference the
04:38 - user's endpoint so i'll need to go back
04:40 - and copy that url
04:43 - and then i can paste it as a comment at
04:45 - the top of my struct so that i have
04:47 - quick reference to it
04:49 - well now with that file created i'm
04:51 - going to create that struct and i'm
04:53 - going to call it the same name user
04:57 - now for the user i'm really only
04:59 - interested in modeling the id
05:02 - name
05:02 - username and email
05:05 - and since these are all top level keys
05:07 - in the key value pairs of this json we
05:10 - can simply create properties that use
05:12 - the same name
05:13 - and the id will be an int
05:16 - and the other three are strings
05:19 - now since we're only going to be reading
05:21 - this information and not modifying it we
05:23 - can create the properties as constants
05:25 - using let
05:29 - now in order to decode this json the
05:31 - model has to conform to the codable
05:33 - protocol
05:35 - and because each one of these properties
05:37 - are simple types that conform to the
05:39 - quotable protocol already the entire
05:42 - struct will too so we can mark it as
05:44 - conforming to codable protocol
05:48 - we're also going to want to present our
05:50 - users in a list view and it's much
05:52 - easier to do if the struct conforms to
05:54 - the identifiable protocol and the only
05:57 - requirement for that is that there is a
05:58 - unique property called id and we already
06:02 - have that
06:05 - so let's do the same now for the posts
06:08 - json endpoint
06:10 - first let me copy the endpoint for the
06:12 - post url so that i can use as a
06:14 - reference
06:19 - and then i want to create a new file
06:21 - called post
06:23 - and in that file i can paste that url as
06:26 - a reference for our new model struct
06:37 - now this url gets all of the posts
06:39 - but what i want to know as well is how
06:41 - do i get the post for just one user
06:44 - so let me return to the api
06:46 - documentation to find that endpoint
06:51 - here it is
06:53 - and this is the one that i want so let
06:54 - me copy and paste that url in as well
07:01 - now i can create a new struct using that
07:03 - same name
07:07 - for the posts i want to model all four
07:09 - properties here and they are all top
07:12 - level as well so fairly easy to do
07:15 - just creating our properties using the
07:17 - same names as the key values in our json
07:22 - and again since we'll be reading this
07:23 - information only and not modifying it
07:26 - we'll create it using lips as constants
07:30 - both the user id and id are ints while
07:34 - the title and body are strings
07:37 - the user id property corresponds to the
07:40 - id property in our user model
07:43 - and the id though is the unique property
07:46 - for this particular model and again in
07:49 - order to decal with the json the model
07:51 - has to conform to the equitable protocol
07:54 - and because each of these properties are
07:55 - simple types that conform to the
07:57 - quotable protocol the entire struct
07:59 - wheel too
08:03 - and with the id property being here we
08:05 - can conform the construct itself to the
08:08 - identifiable protocol
08:12 - now i have an entire series on json
08:15 - decoding
08:16 - and it covers this as well as how to
08:18 - decode and encode your data which we'll
08:20 - be going over soon
08:22 - i'll leave a link here in the notes
08:24 - below
08:29 - now i want to create a struct that i can
08:31 - use as a service
08:33 - that i can call from a variety of
08:34 - different views to fetch our data
08:37 - whether that be an array of user or an
08:39 - array of post
08:42 - now there are a number of ways to do
08:43 - this and you may have heard of a
08:45 - singleton
08:46 - but it gets a lot of bad press about not
08:48 - being able to test but we're not going
08:51 - to be running any unit tests on this
08:52 - project but let's start right now by
08:54 - creating good habits and anytime we want
08:57 - to access that service we'll create a
08:59 - new instance of the service
09:03 - so i'm going to create a group called
09:05 - services and even though there's only
09:06 - going to be one service that i create
09:09 - i want to keep my code organized
09:13 - inside that folder group i'll create a
09:16 - new file
09:17 - and i'll call it api service
09:22 - and inside there i'll create a struct
09:24 - using that same name
09:29 - now the struct will have one property
09:31 - that will be the url string
09:33 - representing the endpoint
09:35 - and we're going to have two different
09:37 - ones one for the users
09:40 - and one for the posts
09:41 - so each time that we create an instance
09:43 - of this struct we'll need to pass in a
09:46 - different string representing that
09:47 - endpoint
09:51 - next we'll create a function called get
09:54 - users
09:56 - now this function is going to have to
09:58 - return an array of users
10:00 - so my first inclination is to return an
10:03 - array of users like this
10:07 - unfortunately this won't work at least
10:09 - not yet
10:10 - later on in the series we'll be covering
10:12 - new concurrency models introduced in ios
10:15 - 15
10:16 - but as you are likely to see still for
10:19 - quite a while the older method of
10:20 - dealing with concurrency we're going to
10:22 - start there
10:23 - this will require using what is known as
10:25 - a completion handler
10:27 - and eventually we're going to be using a
10:29 - result type as our completion handler's
10:31 - argument
10:32 - but i'm getting ahead of myself
10:34 - if you are still confused after i finish
10:37 - this video i recommend that you watch
10:39 - the two videos i have on that topic
10:42 - and links are in the description below
10:47 - let's start easy now and build on this
10:50 - concept
10:52 - the reason we need a completion handler
10:53 - is because we have no idea how long it's
10:55 - going to take for that network call to
10:58 - fetch that data and since our code is
11:00 - inherently synchronous
11:02 - it would move on to the next line before
11:04 - we received our data
11:06 - and a completion handler is just a
11:08 - closure that we can pass in as an
11:10 - argument so that it will get executed
11:13 - when that data has been retrieved
11:15 - and we can give that closure a name
11:18 - and typically people call it something
11:19 - like completion or completion handler
11:24 - so when this function has completed
11:26 - and we'll either have successfully
11:28 - retrieved our json
11:31 - and decoded it
11:33 - or an error will have been produced
11:36 - so when we call this function we'll need
11:38 - to deal with either case but first i'm
11:40 - going to keep it simple and deal with
11:42 - the error right here within the function
11:44 - and only execute the closure if we
11:46 - successfully decoded the data
11:49 - so the closure function is going to have
11:52 - an argument which will be an array of
11:54 - user that we've returned
11:57 - and it's going to return nothing or void
12:02 - there will be another issue however
12:04 - as we'll be fetching that from a server
12:06 - and it's going to take some time the
12:09 - function itself will escape the scope
12:11 - before we're done
12:12 - so we'll need to specify that this
12:14 - completion handler is going to escape
12:18 - so we do that by marking the completion
12:20 - function as escaping
12:24 - well now we can get to work
12:28 - first we'll need to create a url from
12:30 - our string
12:31 - and we can use a guard check for this
12:34 - so we'll guard
12:37 - url equals the url
12:39 - string from
12:41 - url string
12:43 - else
12:44 - we'll just return from the function
12:49 - next we'll use the url sessions
12:52 - singleton datatask function
12:54 - with url
12:56 - and this also has a completion handler
12:58 - just like our function does
13:02 - so we'll pass in the url for the url
13:05 - and when we hit enter on the closure we
13:07 - see that we can assign variables for the
13:09 - three different
13:11 - objects that are coming back
13:13 - data response and error
13:16 - and all three of these properties are
13:18 - optional
13:23 - the most important thing that we have to
13:25 - do before we forget however is to make
13:27 - sure that this task gets initiated so
13:29 - we'll also need to call resume because
13:32 - it's initially in a suspended state
13:39 - so now we can check on those three
13:41 - optional items that we get back
13:44 - first we'll check the response to see if
13:46 - it has a status code of 200
13:49 - and that it's not nil
13:51 - so another guard check
13:54 - guard
13:55 - http response equal response as an http
13:59 - url response
14:01 - and also
14:02 - that the status code is equal to 200.
14:08 - else we'll just return
14:12 - we also only want to continue if there
14:15 - isn't an error
14:17 - so guard
14:19 - if error is equal to nil we can continue
14:22 - else we'll return from the function
14:27 - if we get this far then we'll need to
14:29 - check to see if we got data
14:32 - so another guard check
14:35 - guard but data equals data
14:37 - else return
14:40 - well now that we've got the data we can
14:43 - try to decode it
14:45 - and the key word here is try
14:48 - but first we'll need a decoder let
14:50 - decoder equals json decoder
14:53 - now because the decoding might fail and
14:56 - throw an error which means generate an
14:58 - error
14:59 - we have to create a do catch block to
15:02 - try and decode it
15:04 - and this is such a common construct the
15:06 - do catch block that i've created a code
15:09 - snippet for this so anytime you see me
15:12 - do dtc
15:14 - that stands for do try catch
15:17 - i have a code snippet that's going to
15:18 - generate that construct
15:21 - then we can let our decoded data be the
15:23 - result of trying to decode the array of
15:26 - user from that data
15:29 - and if it's successful
15:31 - we can just use that decoded data as the
15:33 - argument for our completion handler
15:35 - which is completion
15:38 - and it runs that function with that
15:40 - argument
15:42 - if it's not successful it fails
15:46 - so we'll just catch that error and then
15:48 - just print that there was an error
15:54 - now this will work
15:56 - but there are some severe limitations
15:57 - here and you'd not want to ship an app
15:59 - like this using this function
16:02 - when there is an error
16:03 - we're not giving any feedback to the
16:05 - user
16:06 - and it just exits the function
16:09 - the only time you do anything is when
16:10 - you print out that there was an error
16:13 - to the console but your user will never
16:15 - see that
16:17 - in a later video we're going to go over
16:19 - error handling in more detail but i want
16:21 - to set the stage here by changing this
16:23 - function to provide any errors to the
16:25 - caller so that eventually we can bubble
16:27 - that error up and provide an error to
16:30 - our users in the ui using an alert
16:34 - and this is where the result type comes
16:36 - in for our completion argument
16:39 - a result is simply an enum with two
16:41 - cases
16:42 - either a success case with an associated
16:45 - value
16:46 - and that associated value will be in our
16:48 - case the array of users the successful
16:51 - completion
16:52 - or a failure case
16:54 - where the result is a error type
16:58 - so instead of using simply an array of
17:01 - user in our completion handler i want to
17:04 - use a result type
17:05 - so we can change our completion
17:08 - argument
17:09 - to a result
17:10 - where the two cases are array of user
17:14 - or an error
17:17 - and then we'll need to fix that
17:19 - completion that we'd have in our
17:20 - function
17:21 - so that when we successfully decode the
17:23 - data
17:24 - the result success case dot success has
17:28 - an associated value and that associated
17:31 - value is our decoded data
17:34 - still with me
17:36 - well what about the failure case
17:39 - well it's going to fail every time we
17:41 - fail the guard check
17:43 - or in that do catch block
17:47 - we want to be more prescriptive so i'm
17:49 - going to create my own api error enum
17:52 - with all five of the cases where we
17:55 - could have possibly failed
17:57 - and the enum has to conform to the error
18:00 - protocol
18:01 - so there are five different cases
18:04 - in that first guard
18:06 - we have an invalid url so i'll set the
18:09 - case to be invalid url
18:11 - then we check the response status
18:14 - so my case is going to be invalid
18:16 - response status
18:18 - or perhaps the
18:19 - url session didn't work at all so it may
18:22 - be a dated task error
18:25 - perhaps the data was corrupt
18:28 - corrupt data
18:30 - and then finally once we get the data
18:32 - perhaps our model is incorrect so we'll
18:34 - get a decoding error
18:38 - so now when we fail we can do another
18:40 - completion using the failure case
18:45 - and that has an associated value that
18:47 - will just use our case
18:51 - so first we'll need to go back to where
18:52 - we define our result and say that we no
18:54 - longer want to have that error case just
18:58 - a generic error we want to be specific
19:00 - and say that it's going to be our api
19:02 - error
19:04 - and then each of those five cases we're
19:07 - going to now call our completion handler
19:10 - with the failure case
19:12 - and the associated value is going to be
19:15 - the corresponding
19:16 - case from our api error
19:21 - so first failure is an invalid url
19:28 - next an invalid response status
19:33 - then a data task error
19:38 - corrupt data
19:47 - and finally a decoding error
19:52 - now there are only two more things i
19:53 - want to do before i finish this video
19:56 - this function is looking pretty good but
19:58 - currently i can only use it for users
20:00 - and not post
20:02 - and when you look at this though the
20:03 - only time i use user is when i decode
20:06 - and define the associated value for the
20:08 - success case in our result type
20:11 - it could be easy just to copy and paste
20:14 - this function and change this to get
20:16 - posts and change user to post
20:19 - however there's a better way and that's
20:20 - using generics
20:22 - and i have a video on generics if you
20:24 - want to find out more information on
20:25 - that topic again a link will be in the
20:28 - description below
20:30 - the function will work for any decodable
20:32 - type object like our user and post
20:35 - objects
20:37 - and we can use that fact by specifying
20:39 - that the function should only work if
20:41 - that's what we're dealing with
20:43 - which is a decodable type
20:45 - so when we define our function we can
20:47 - specify that limitation
20:49 - and we can use a variable like t to
20:53 - represent that type
20:55 - and make sure that that type conforms to
20:57 - the decodable protocol
21:00 - and then everywhere where we see user we
21:02 - can replace it with the t placeholder
21:06 - now t
21:07 - is generic itself and it can represent
21:09 - either a single object or an array of
21:12 - objects
21:13 - so we don't really even need to specify
21:15 - array here we'll be able to specify that
21:18 - when we call the function
21:23 - and we're almost done and this is a
21:25 - service class that you can use in all of
21:27 - your projects but to make it even more
21:29 - inclusive
21:30 - and i go through this in my quotable
21:32 - series you may have a specific key
21:34 - decoding or date decoding strategy that
21:36 - you want to use
21:38 - so i'm going to create two more
21:40 - arguments
21:42 - here so before the closure let's add two
21:45 - more parameters for this function
21:49 - one is going to be a date decoding
21:51 - strategy
21:52 - which is a json decoder
21:55 - dot date decoding strategy
21:57 - and the second is a key decoding
21:59 - strategy which is a json decoder key
22:02 - decoding strategy
22:05 - now 99 of the time the defaults are just
22:08 - fine
22:09 - but since we are adding these two
22:11 - parameters when i call this function i'm
22:13 - going to be forced to enter in what
22:15 - would be my defaults
22:18 - when i create the instance of this
22:19 - getusers function
22:22 - so in order to make this optional for us
22:24 - i can assign the most common default
22:27 - values in the initializer for each
22:29 - parameter
22:36 - then after we create our decoder we can
22:38 - assign these properties to the decoder
22:44 - that's almost it
22:46 - but i forgot this function is still
22:48 - called get users when in fact it's going
22:50 - to be more generic
22:52 - so instead of calling it get users i'm
22:54 - going to change the name to get json
22:56 - instead
22:59 - well that's it we haven't tested it yet
23:01 - but we've created the groundwork for our
23:03 - app and the really good thing is that
23:05 - we've created a reusable api service
23:07 - class that you'll be able to use in your
23:09 - own projects in the future
23:12 - in the next video i'll show you how you
23:14 - can use this class
23:16 - and we'll also be improving on it when
23:18 - we start working on error handling
23:21 - hopefully this hasn't been too technical
23:23 - but it is worthwhile i think going
23:25 - through in some detail so that you
23:27 - understand why things are done this way
23:29 - when we start to use functions
23:32 - in a later video we'll be converting
23:33 - this to an alternative version that uses
23:36 - the new async and await concurrency
23:38 - model
23:40 - so in the next video of the series we'll
23:42 - be building out the ui
23:44 - and i'll introduce you to voodoo a
23:46 - modified mvvm design pattern
23:49 - and utilize xcode's source control
23:52 - features to ensure that our source code
23:54 - is protected
23:57 - hi my name is stuart lynch and this is
23:59 - the second of six videos in the ios
24:01 - concurrency series
24:03 - in the first video we began by creating
24:05 - our models and a service so that we
24:07 - could fetch and decode json from the
24:09 - json placeholder api
24:12 - in this video i'll introduce you to
24:14 - voodoo a modified mvvm design pattern so
24:18 - that we can create view models and views
24:20 - to display the content that we fetch
24:22 - from our api endpoints
24:25 - we'll also be seeing how we can use mock
24:27 - data so that we don't have to always
24:28 - make calls to the api when we design our
24:31 - apps and you'll be introduced to get
24:34 - source control using xcode
24:39 - i'm going to be using what mark markins
24:41 - from big mountain studio calls swift
24:43 - ui's vudu and this is a modified nvvm
24:47 - architecture
24:50 - there are three parts as you see a view
24:53 - the observable object
24:55 - and the data object now we've already
24:58 - created our data objects those are our
24:59 - models
25:01 - so i'll let you go through the post and
25:03 - i'm just going to start using it
25:05 - the first thing we have to do is to
25:07 - change the name of our opening view from
25:09 - content view to represent what our first
25:12 - view is going to be and that's going to
25:13 - be our users list view
25:16 - so we can do this by right clicking on
25:18 - the name
25:19 - and choosing refactor
25:23 - and when we type in our new name this
25:25 - not only renames the view but also the
25:28 - file name and any instances where it is
25:30 - referenced like in the app file
25:35 - the other thing you might want to do is
25:36 - to change the preview to users list view
25:39 - underscore preview
25:41 - and the header as well
25:46 - next we'll create a group called views
25:49 - and move that file into there
25:53 - i'm just going to adjust the order a
25:55 - little bit in my navigator
25:59 - i have my view here that i want to
26:00 - modify
26:02 - and i have data objects which are the
26:04 - user and post objects
26:07 - and now i need my observable object
26:09 - which i will call the users list view
26:12 - model
26:13 - so let's create a file
26:15 - in a new group
26:16 - called view models
26:22 - so inside that group
26:24 - i'll create a new file
26:26 - that i'll call users list view model
26:31 - and in there i'll create a new class
26:33 - with the same name
26:35 - but conforming to the observable object
26:37 - protocol
26:41 - now this class is going to have a single
26:43 - published property called users
26:46 - and that's going to be an array of user
26:49 - and i'll initialize it as an empty array
26:52 - so this is before we fetch our json
26:56 - it's also going to have a single
26:58 - function called fetch users
27:02 - so it's within this function then
27:05 - that we can call that function using our
27:07 - api service
27:10 - so first we'll need to create an
27:11 - instance of the api service
27:13 - and it requires a url string for the
27:16 - endpoint
27:17 - well we have that url string back in our
27:20 - model so we can copy that
27:23 - and we can then just paste it in here as
27:25 - the argument for the api service
27:27 - instance
27:32 - within the function then we can call the
27:34 - api services get json function
27:38 - and this provides us with a closing
27:39 - completion handler that is a result
27:42 - however this result type is generic so
27:45 - we'll need to specify which objects we
27:48 - expect to come back as the cases for the
27:52 - argument for that completion handler
27:54 - well we know that a result type has two
27:56 - cases
27:57 - and for this instance the first case the
28:00 - success case is going to be an array of
28:02 - users
28:04 - and the error is going to be of the type
28:06 - of our new api error
28:10 - and then we can switch on the result
28:13 - in an xcode 15 this nicely completes the
28:16 - case for me however i'm going to change
28:18 - the let's success to be let users
28:22 - and let failure to be let errors so
28:25 - users represents the users that we're
28:27 - getting back
28:29 - and error will represent any error that
28:31 - we might get
28:34 - now we know that that success type is
28:35 - that array of users so we can assign
28:37 - those users then to that published
28:39 - property of users
28:41 - but it's an asynchronous function that's
28:43 - executing on a background thread
28:46 - and we're going to be using this array
28:48 - of users to update our ui so we'll need
28:51 - to go back
28:52 - onto the main thread to do that using a
28:55 - dispatchq dot main dot async
28:58 - and just like i had a code snippet for
29:01 - my do catch block
29:03 - i have one for this dispatch queue as
29:05 - well
29:06 - all i have to do is enter dq
29:12 - so for the failure then i'll just print
29:15 - out the error at this time we'll deal
29:17 - with this a little bit later
29:18 - great
29:19 - now we can use this view model back in
29:22 - our users list view
29:25 - first we'll create a state object that
29:27 - i'll call vm
29:29 - that will be an instance of our user's
29:31 - view model
29:34 - next we'll replace the body with a
29:37 - navigation view
29:41 - and inside there let's create a list
29:45 - and then within the list we'll iterate
29:47 - over our view models users with a for
29:49 - each loop
29:51 - and then for each user in that array
29:54 - then we'll create a v-stack
29:57 - with an alignment that is leading
30:04 - and then for two textviews within that
30:07 - stack we'll first create one it's going
30:09 - to represent the
30:11 - user.name property
30:13 - we'll set the font to title
30:19 - and then the next one we're going to
30:21 - represent the user's email in a text
30:24 - view
30:29 - and then we'll set the navigation title
30:31 - to say users
30:36 - we'll also set the list view style to
30:38 - just plain using the new condensed way
30:40 - of applying a list style
30:43 - and then finally when this view appears
30:46 - we can call our view models fetch users
30:49 - function
30:50 - and thus update the view
30:54 - so if we resume our canvas all we see is
30:57 - the navigation bar we don't see the
30:59 - preview
31:00 - and this is because our preview provider
31:02 - hasn't fetched any of our users this is
31:05 - only happening if we go into preview
31:07 - mode so we'll have to enter preview mode
31:09 - to initiate the fetch and display that
31:12 - list of fetched users
31:14 - i'd really like to see what my view
31:16 - looks like without having to make that
31:17 - network call you may have noticed that
31:20 - xcode provides us with a preview content
31:22 - folder and this is where you can place
31:24 - content that you want to exclude from
31:26 - your release builds when you upload to
31:28 - the app store
31:30 - the content will be available to you
31:31 - during development or the debug stage so
31:34 - this is a great place to store that kind
31:36 - of information
31:38 - and the easiest way to do that in our
31:41 - case is to use a sample of the json that
31:43 - you'll actually get from your api
31:47 - now i recommend you use safari without
31:50 - any json extension enabled so that when
31:52 - we view our endpoints the json will be
31:54 - displayed as json text in the browser
31:57 - window
31:58 - so let's go get the 10 users json from
32:01 - the json placeholder api
32:04 - all i have to do is select and copy the
32:07 - text to my clipboard
32:11 - then within the preview content group
32:14 - i'm going to create a new file that i'll
32:16 - call users.json
32:19 - now make sure you specify json as the
32:22 - extension and then replace the entire
32:24 - content with what you copied from your
32:25 - clipboard
32:28 - now i want to repeat exactly the same
32:30 - process for the post because we're going
32:33 - to be building out the ui for a list of
32:35 - posts as well
32:37 - so we'll go to the post json endpoint
32:42 - we'll copy that json
32:46 - i'll return to xcode
32:48 - and create a new file
32:51 - that i'll call
32:54 - posts.json and paste the json into there
32:59 - this content is now located in your
33:01 - application bundle during debug mode
33:05 - so we'll need to somehow access that
33:08 - and i'm going to create an extension to
33:10 - bundle that will easily decode this data
33:13 - so as long as it is a decodable type
33:16 - which we know ours is
33:20 - i'm going to share with you an extension
33:22 - that i copied and modified from paul
33:24 - hudson from hacking with swift
33:27 - it uses generics just like we did in our
33:29 - api services get json function to decode
33:32 - decodable objects from files stored in
33:35 - your application bundle
33:37 - now i use this all the time so i've
33:39 - created a just where i can get access to
33:41 - it at any time
33:43 - and a link to this is provided in the
33:45 - description below
33:47 - the code should look actually pretty
33:48 - familiar to you
33:50 - it's just that we're getting our url
33:52 - from the bundle instead of an endpoint
33:55 - and instead of a result completion
33:57 - handler decoding from a file isn't
34:00 - asynchronous so we can simply just exit
34:02 - with a fatal error if something goes
34:04 - wrong
34:05 - and return the decoded data if we're
34:08 - successful
34:09 - now i suggest that you just copy this to
34:11 - your clipboard
34:15 - now returning to xcode i'm going to
34:17 - create a new group that i'll call
34:19 - extensions
34:21 - and inside that folder i'm going to
34:22 - create a new file that i'll call bundle
34:26 - plus extension
34:29 - now just below the import i'll just
34:32 - paste that extension it's ready to use
34:35 - so you feel free to use this in any of
34:37 - your projects it's a really handy
34:39 - extension
34:42 - next we'll create a file within the
34:44 - preview content folder that i'll call
34:47 - mock data
34:50 - first i'm going to create an extension
34:52 - to the user struct
34:54 - and within there i'm going to create two
34:56 - static computed properties
34:58 - one that will return an array of users
35:01 - and another that's going to return a
35:03 - single user that we can use for our
35:05 - previews
35:06 - the first we'll call mock users
35:10 - which is an array of user
35:12 - and what we're going to return is that
35:14 - array that we decode from our bundled
35:16 - file
35:18 - so we can simply use bundle dot main
35:21 - dot decode
35:23 - the array of user
35:25 - type self
35:27 - from the users.json file within quotes
35:32 - for the single user then we can just
35:34 - create another static computed property
35:36 - called mock single user
35:39 - of type user
35:41 - and we'll just return the first item
35:43 - from our mock users
35:45 - by accessing the static property on self
35:49 - at index 0.
35:54 - well we can do the same for our post
35:56 - so all we have to do is create a new
35:58 - extension for post
36:02 - and then i'll just copy from above
36:05 - and anywhere i had user i'll just change
36:08 - it to post
36:13 - now i'm also going to be needing a post
36:15 - for a single user
36:17 - so i'll create one more static property
36:20 - that i'll call mock single users post
36:23 - array it's a mouthful but it's
36:26 - descriptive
36:28 - and this will be an array of post
36:31 - but i'll filter it so that it's using a
36:34 - user id
36:36 - that matches
36:37 - the number one because i know that there
36:40 - is a user with an id of one in my mock
36:43 - users
36:46 - great
36:47 - so how do we use it
36:50 - now there's a problem with the fact that
36:52 - we're using a view model to fetch our
36:54 - users
36:55 - and there's no easy way to display mock
36:57 - data while developing your ui
36:59 - in this case because whenever your view
37:01 - model is instantiated we set the array
37:04 - of users to an empty array
37:06 - and then the view appears when we fetch
37:08 - users from the api
37:10 - now there are a couple of ways around
37:12 - this you could create an alternative
37:14 - initializer for the view model like this
37:19 - we create an extension on the user's
37:21 - view model
37:22 - and in there we'll create a convenience
37:25 - initializer with an additional parameter
37:27 - called for preview
37:29 - that's a boolean value
37:31 - that will default to false
37:36 - then we can call the self
37:38 - the parents initializer
37:40 - which sets users to an empty array
37:44 - and then if we specify that for preview
37:46 - has been true
37:48 - we'll set the users to be our users.mock
37:51 - users
37:56 - with this in place then we can go back
37:58 - to the users list view
38:00 - and anytime we want to show mock data in
38:03 - our initializer we can simply change it
38:06 - so that we have this convenience
38:08 - initializer where we'll set for preview
38:11 - true
38:15 - and we see then without making a call to
38:18 - the endpoint
38:20 - our preview provider will generate that
38:22 - preview on the canvas
38:24 - now the bad news is that we will either
38:27 - have to remove the argument or set it to
38:29 - false when we ship
38:31 - otherwise our users will get that mock
38:33 - data first even if it never makes a call
38:36 - to the api
38:38 - so for this reason i suggest that you
38:40 - place a warning above this state object
38:43 - to remind you that you need to remove
38:45 - that argument before you ship
38:52 - now the good news is that even if your
38:55 - argument is set to true whenever you run
38:57 - on the simulator
38:59 - or on a device the preview will be
39:02 - overridden by the fetch users call on
39:04 - the api
39:06 - so that the data will quickly be
39:07 - replaced but it's still not ideal so
39:10 - remember to remove that argument or not
39:12 - use it at all and just keep pressing
39:14 - preview
39:15 - however if you're paying for a service
39:17 - that charges for fetch requests you
39:19 - definitely don't want to do this
39:25 - now we're going to do a similar thing
39:26 - for our posts and we'll create a post
39:29 - list view model that conforms to the
39:31 - observable object
39:35 - like our users list view model we'll
39:37 - have a published property but this time
39:40 - it will be an array of post objects
39:46 - now the criteria for fetching posts for
39:48 - a user will be a user id
39:52 - and we won't know that user id until we
39:54 - specify it so let's make it optional
39:57 - and it will default as nil
40:01 - and then like in our other view model
40:04 - we'll want to fetch the posts
40:06 - but we won't do that until our user id
40:08 - has been specified so we can use an if
40:11 - let here to unwrap user id
40:15 - so first we'll need an endpoint for the
40:18 - single user post
40:20 - so we can copy that from the post model
40:22 - and then returning to our post list view
40:25 - model we can create a new instance of
40:27 - that api service passing in that string
40:30 - making sure that we replace the
40:32 - hard-coded one with the user id from our
40:35 - view model
40:36 - now inside that function we can use a
40:39 - similar api call as when fetching our
40:42 - users so let's just copy and paste that
40:45 - in here
40:46 - and adjust to fit
40:49 - for our result we're getting back an
40:52 - array of post not an array of user
40:57 - and when we're successful we get posts
41:00 - so we can set our published post to that
41:02 - decoded array
41:06 - to display the posts for the user we'll
41:08 - need a new swift ui view
41:11 - that uses this view model so let's
41:13 - create a new file within our views
41:16 - folder
41:17 - that we'll call posts list view
41:24 - and inside that struct will create a new
41:26 - state object for post list view model
41:32 - now we're going to be presenting this
41:34 - view from a navigation view so we don't
41:37 - need to add one in here it's already
41:39 - going to be here
41:40 - but we can create our list so let's just
41:43 - copy the code from the previous view and
41:45 - adjust to fit again
41:48 - first we'll change all references from
41:50 - users
41:51 - to posts or post
41:58 - for the first text view let's pick the
42:00 - post title
42:03 - but change the font to headline
42:08 - and for the second we'll use the post
42:10 - body
42:12 - but also set a font
42:14 - for call out
42:16 - and change the foreground color to
42:19 - secondary
42:25 - and then for the navigation title we'll
42:27 - change it to posts
42:33 - and change our navigation bar title
42:36 - display mode to be inline
42:44 - in the on appear then we can change this
42:46 - to fetch posts
42:49 - the errors are all gone now but our user
42:51 - id in our view model is still nil
42:54 - so we'll not be able to get any listings
42:56 - yet
42:57 - we'll have to be injecting the id when
43:00 - we tap on a row from our users list
43:02 - so let's create a property here
43:05 - that's not going to change once we've
43:07 - passed it in so it doesn't need to be a
43:08 - binding and it's going to be a user id
43:13 - we'll also need to pass in a user id to
43:15 - stop the preview from completing so let
43:17 - me just enter a 1 here
43:23 - and then in on appear before we fetch
43:26 - our posts
43:27 - we'll set the user id within our view
43:30 - model to be what was passed in
43:34 - and it will no longer be optional
43:36 - therefore we'll generate the list view
43:38 - that we can be presented in this view
43:42 - similarly we're not going to be seeing
43:43 - that navigation bar
43:46 - because our preview has no idea that our
43:48 - view is in a navigation view
43:50 - so we can surround our preview with a
43:53 - navigation view just so that we can see
43:55 - what it looks like in our canvas
43:59 - i'd also like to make sure that we have
44:00 - some mock data so that we can view the
44:03 - list of posts within our canvas without
44:06 - having to make a call to the api
44:09 - so we're going to have to do the similar
44:11 - thing that we did with our list view
44:13 - model
44:14 - so we'll go back to that one and then
44:16 - we'll just copy that extension
44:20 - and we'll change the extension to be a
44:22 - post-list view model extension
44:26 - and adjust it here where we display
44:28 - instead
44:29 - a mock single user's post array
44:35 - so back in our view then we can do the
44:36 - same thing by
44:38 - cautiously adding a preview argument
44:40 - when creating our view model
44:43 - then back in our list view in order to
44:45 - be directed to the post list view
44:48 - we'll need to create a navigation link
44:52 - and the navigation links destination is
44:54 - going to be our post list view
44:57 - passing in the selected user id
45:02 - and the label will be exactly what we
45:04 - have
45:18 - if i test this now it all just works
45:21 - perfect
45:24 - but one more thing though when i run
45:26 - this on the simulator i get these
45:28 - constraint warnings showing up in the
45:31 - console and this happens when you embed
45:33 - your views in an unstacked navigation
45:36 - view
45:36 - i think this has to be an xcode bug
45:38 - because i'm using swift ui and not ui
45:41 - kit and i have no idea how i can adjust
45:43 - constraints
45:44 - if you want to suppress these errors you
45:46 - can set a value for user defaults that
45:49 - can suppress the warning
45:51 - so when your user's list view is first
45:53 - instantiated at launch time in the app
45:56 - file
45:57 - we can assign this in the on appear
45:59 - function
46:01 - and i do this again so often that i have
46:03 - another code snippet for this
46:06 - and we set the user default standard
46:08 - value to false for the key
46:11 - which is in quotes
46:13 - this ui constraint based layout log
46:17 - unsatisfiable
46:23 - so you've seen now that i've used three
46:25 - different code snippets so far
46:27 - so if you're interested in code snippets
46:29 - they're very powerful i recommend that
46:31 - you watch this video that i created
46:33 - quite some time ago on creating your own
46:35 - code snippets
46:37 - well we've spent a lot of time so far on
46:39 - this project and we want to make sure
46:41 - that going forward as we make
46:42 - adjustments we can return to a point in
46:45 - time in the past in case we need to
46:46 - rework something
46:48 - and this is known as source control
46:51 - and the most common versioning system
46:53 - for developers is called git
46:55 - and xcode provides us with access to git
46:58 - right from its own source control menu
47:01 - i have an entire series on source
47:02 - control with git and xcode if you're
47:04 - interested in learning more
47:06 - i'll leave a link in the description
47:08 - below
47:10 - all we have to do is select commit from
47:13 - the source control menu
47:15 - and enter a comment as to what stage you
47:17 - are in your project and that's a
47:19 - reference
47:21 - we'll be exploring more source code
47:22 - features in future videos in this series
47:26 - in the next video in this series we'll
47:28 - be finishing up the first part of the
47:30 - series to provide better feedback to our
47:32 - users
47:33 - so that they'll know when our
47:34 - application is actually fetching data so
47:37 - they have to be patient
47:38 - and if there are any errors we can let
47:41 - them know to file a bug report with the
47:43 - developer
47:45 - hi my name is stuart lynch and this is
47:47 - the third of six videos in the ios
47:49 - concurrency series
47:51 - at the end of the second video we had a
47:53 - working application but the user
47:55 - experience was not optimal
47:57 - in this video we're going to improve the
47:59 - user experience by doing two things
48:01 - whenever our app is fetching and loading
48:03 - data we want to present a spinning
48:05 - progress view on top of our view to
48:08 - indicate that the data is loading
48:11 - if an error does occur then we want to
48:13 - know about it so instead of printing the
48:15 - error to the console or doing nothing at
48:17 - all
48:18 - we want to present an alert to our users
48:20 - with that error information and ask them
48:22 - to contact us with that information
48:26 - now if you're just jumping into the
48:27 - start of this series you can download
48:29 - the completed code from the second video
48:31 - in this series from the link in the
48:33 - description below
48:36 - sometimes our users might be on a slow
48:38 - connection so fetching data from a
48:40 - network call might take some time to be
48:42 - retrieved and decoded
48:44 - your user shouldn't be sitting there
48:46 - wondering what's going on you should
48:47 - give them some visual clue that
48:49 - something is happening
48:51 - and swift ui gives us a nice spinner
48:53 - called a progress view that we can use
48:54 - for this
48:56 - so in order to present the progress view
48:59 - we'll need to have some sort of a
49:00 - published property in our view model
49:03 - that we can toggle
49:04 - so in the users list view model create a
49:08 - published property
49:10 - that you can call is loading
49:12 - and set it equal to false that makes it
49:14 - a boolean property
49:17 - then as soon as we start to fetch that
49:20 - data we'll toggle it making it now true
49:25 - now a defer block is used for executing
49:28 - code just before transferring program
49:30 - control outside of the scope that the
49:32 - statement appears in
49:34 - and this means that when the function
49:36 - has completed
49:37 - so inside of our api service class we
49:40 - can create a defer block
49:42 - and the code inside there will be
49:44 - executed after the data is retrieved and
49:47 - processed
49:48 - so what do we want to do when that's
49:50 - done
49:50 - well we want to toggle that is loading
49:53 - again to set it back to false
49:56 - now since that's on a background thread
49:59 - and we are using a published property
50:02 - we'll need to make sure that we get it
50:04 - back onto the main thread and we'll do
50:06 - that again within a
50:09 - dispatchq.main.async block
50:15 - so to display the progress view while
50:17 - it's loading well we can return to the
50:20 - users list view
50:22 - and here we can create an overlay on the
50:25 - list view
50:26 - using the overlay function
50:29 - and the content will be a progress view
50:32 - but we only want to display the progress
50:34 - view if the view model is loading has
50:36 - been set to true
50:41 - if we test this now we'll first need to
50:43 - set our for preview to false to get a
50:45 - real test
50:48 - now i'm on a fast network and i can't
50:50 - really notice that progress view the
50:52 - data loads really quickly
50:58 - even when i try dark mode it's it's not
51:00 - obvious i really can't see it
51:02 - so we can simulate a slow connection
51:04 - here by surrounding our api service call
51:07 - within a dispatchq dot main
51:10 - dot async after block
51:14 - and we can set a delay of say one second
51:18 - so let's test once more
51:24 - now we can see it
51:28 - so let's repeat this then for the post
51:30 - list view model when we're fetching the
51:32 - posts
51:34 - first we'll need a published property
51:36 - called is loading
51:38 - and set it initially to false
51:43 - then we toggle it when we start to fetch
51:46 - our posts
51:50 - and then for our defer block we can just
51:52 - copy it from our user's list view model
51:54 - here and use it inside the get json
51:57 - function
52:03 - similarly we can reuse the code that we
52:05 - created for the users list view overlay
52:08 - here because we use the same property
52:10 - names for the view model and the is
52:12 - loading property
52:15 - so let's make sure that we commit our
52:16 - source code now
52:18 - it looks like some of my assets weren't
52:20 - committed from the last commit
52:22 - that question mark's an indication and
52:24 - i'm not sure what went wrong here but
52:26 - let's select them and make sure that the
52:28 - commit now works to commit those to our
52:31 - repository
52:43 - now we've structured our app so that it
52:44 - doesn't crash when fetching and decoding
52:46 - data
52:47 - it either prints out that decoding error
52:50 - or
52:51 - it just does nothing there's no
52:53 - indication that anything goes wrong and
52:55 - the user has no idea why they're not
52:57 - going to get the data
53:01 - for example let's go to our users list
53:03 - model and add another property
53:06 - one that's going to invalidate the
53:07 - decoding
53:08 - for example let test be string
53:11 - it'll be invalidated because there is no
53:13 - key value pair in the json to correspond
53:16 - to this
53:19 - so when we run this we'll see that case
53:21 - decoding error is printed on the console
53:24 - that's just the case name for our api
53:26 - error that's not any help to our users
53:29 - and it's not really much help to me
53:33 - we want to present something more
53:35 - descriptive for each of these user cases
53:38 - but before i do that let's take away
53:40 - that delay in our fetch request
53:43 - we just did that for testing
53:47 - now if the error was an actual ns error
53:49 - like what happens in our data task or in
53:52 - the decoding routine
53:53 - we can pass along the localized
53:55 - description that's part of that error
53:58 - along to the api error
54:01 - and we can do that by using an enums
54:03 - associated value
54:06 - now i have a whole video on associated
54:08 - values for enum if you're unfamiliar
54:10 - with that concept i recommend that you
54:12 - take a look at it
54:17 - and now that we have an associated value
54:18 - we've got some errors so we have to
54:21 - provide that associative value which is
54:24 - the localized description
54:26 - in the cases of our error here
54:31 - and in the case of this error
54:34 - we can safely unwrap it because it's not
54:37 - nil
54:38 - in the second case the catch block will
54:41 - generate an unwrapped error with its own
54:43 - localized description too
54:45 - so we can use it here
54:48 - but what about these other cases
54:51 - well we can provide our own localized
54:54 - description for each of these cases
54:56 - we've got our own error we can create
54:57 - our own description
54:59 - and the way that you do that is to make
55:01 - sure that your api error conforms to the
55:04 - localized error protocol
55:07 - and this now provides us with a new
55:09 - property called error description
55:12 - and it's an optional string
55:15 - and we can make that into a computed
55:17 - property and switch on self and then
55:20 - allow xcode again to generate the cases
55:23 - for us
55:27 - now for the three without an associated
55:29 - value we can return our own custom
55:32 - localized string
55:36 - we use ns localize string and this
55:39 - accepts a string and a comment
55:42 - now the string is what you want to have
55:44 - as the localized error
55:46 - and the comment is there for your
55:47 - translator should you actually be
55:49 - localizing your app to other languages
55:52 - and this would be another video series
55:54 - entirely i think
55:56 - so since we're not we can just enter a
55:58 - string that makes sense like this one
56:00 - and leave the comment as an empty string
56:05 - we can then copy and paste this into the
56:08 - remaining two cases
56:10 - and we can adjust the string as needed
56:12 - to represent the error
56:25 - for the two that have an associated
56:27 - value already we'll simply return that
56:29 - string which is the associated value
56:32 - that we passed in when we created the
56:33 - error
56:34 - and that's the errors actual localized
56:37 - description
56:38 - so now our error
56:40 - our api error has a localized
56:42 - description for all five cases
56:45 - well now we can use those strings as
56:47 - part of a message in an alert that we
56:49 - can present to the users whenever an
56:51 - error occurs
56:54 - so let's return to the users list view
56:56 - model and prepare for that
57:00 - to present an alert in our view we'll
57:02 - need to provide not only the boolean
57:04 - property to trigger the alert but also
57:06 - the message corresponding to the error
57:08 - that we can put in the alerts message so
57:12 - we'll create a new published property
57:14 - first called show alert
57:16 - and we'll set it initially to false
57:21 - we'll also need to have an optional
57:23 - string property that we can set with our
57:25 - error message when we have an error
57:28 - and this too has to be a published
57:30 - property
57:34 - now whenever we have an error we can set
57:37 - show alert to true
57:39 - and assign our localized error and
57:42 - further information as the alert error
57:44 - message
57:46 - and we need to do this on the main
57:47 - thread because we're changing a
57:49 - published property that will affect the
57:51 - ui so inside a dispatch
57:54 - dispatchqueue.main.async block
58:02 - in users list view then we can attach an
58:04 - alert to our list using the new ios 15
58:07 - alert type
58:08 - that will have a localized string as the
58:10 - title
58:12 - bound to a boolean for is presented
58:15 - with actions for buttons and a view for
58:18 - our message
58:20 - the title will just be application error
58:25 - is presented is going to be bound to our
58:27 - view model's show alert published
58:29 - property
58:31 - and the action is that button that has a
58:34 - label of ok
58:36 - but no action
58:38 - and when it's tapped swift ui will take
58:40 - care of dismissing the alert
58:44 - then for the message if it's no longer
58:47 - optional we can use the view model's
58:49 - error string as the string for the text
58:52 - view in our message
59:08 - if we test this now we see that our
59:09 - error is displayed
59:11 - great
59:13 - now before we forget let's fix that user
59:15 - model to remove that extra property
59:17 - because we've done a great job here
59:19 - we're not going to get any errors
59:21 - but just in case you do
59:23 - your users are going to see it
59:27 - now let's do the same thing for the post
59:29 - list view model and post list view
59:32 - we can simply copy the code from the two
59:35 - files that we've already done because
59:36 - they'll be identical
59:39 - first the two publish
59:44 - properties then the failure code to
59:47 - trigger the alert
59:52 - and then for the view itself we can copy
59:54 - the whole alert
59:56 - again because we use the same variable
59:58 - names the code will just work
60:16 - well before we forget let's update our
60:18 - source control by issuing a new commit
60:22 - it looks like i missed one of those
60:24 - assets the last time so let's make sure
60:25 - i do it here
60:28 - now all five of our files are updated
60:31 - and that's important because in the next
60:33 - video in this series we're going to
60:35 - branch off of this main branch
60:37 - that we've been working on so that we
60:39 - can take a look at the new concurrency
60:41 - model introduced in ios 15.
60:45 - we still need this branch though because
60:47 - we'll be checking it out again later
60:48 - though
60:49 - and will branch off in another direction
60:51 - when we change our deployment target
60:55 - hi my name is stuart lynch and this is
60:57 - the fourth of six videos in the ios
60:59 - concurrency series
61:01 - at the end of the third video we had our
61:03 - completed application and it was using a
61:06 - result based completion handler for our
61:08 - api services get json function
61:11 - in this video we're going to be
61:12 - implementing the new asynchronous
61:14 - methods introduced in ios 15.
61:18 - this will introduce you to new terms
61:20 - such as async and await
61:23 - main actor
61:24 - and an asynchronous unit of work called
61:27 - the task
61:28 - now if you're just jumping into the
61:29 - start of this series you can download
61:31 - the completed code from the third video
61:33 - in this series from the link in the
61:34 - description below
61:36 - the first thing we should do since we're
61:38 - going to be experimenting with a new
61:40 - feature is create a new branch for our
61:42 - project
61:43 - so that if things go awry we can always
61:45 - roll back to that one that we completed
61:46 - in the last video and that's a fully
61:49 - working app
61:51 - so switch to the source code navigator
61:54 - then select the repositories tab and
61:58 - expand the application
62:00 - you'll notice that the current branch is
62:02 - the one that's called main
62:04 - and if you expand the branches section
62:06 - you'll see it
62:08 - right click on main and choose new
62:10 - branch from main
62:12 - and call it async and await no spaces
62:17 - it should automatically
62:19 - check that branch out and switch to it
62:21 - but if it doesn't like mine doesn't i'll
62:23 - right click on the branch and choose
62:25 - checkout
62:27 - that means i'm leaving the old main
62:29 - branch behind and that code is safe and
62:32 - won't be touched and you'll always know
62:35 - what branch you're on because you'll see
62:37 - that in the title bar
62:40 - now within the api service struct i want
62:43 - to create a new function
62:45 - and i'm going to use the same name and
62:47 - this is going to allow because i'm going
62:49 - to be giving this function different
62:51 - parameters
62:52 - instead of providing a completion
62:54 - handler i'm going to do what i used to
62:56 - do when i knew nothing about
62:58 - asynchronous nature of network calls
63:00 - and in fact i was bitten by this when i
63:02 - first started coding
63:03 - i thought every line of code waited
63:05 - until the previous line of code
63:07 - completed before moving on
63:09 - so i would call get json and then just
63:12 - return my array of objects from the call
63:15 - so i can copy everything except the
63:17 - completion handler from this method
63:19 - then close it off
63:21 - and then return that decodable object
63:24 - which in our case is either an array of
63:26 - user or an array of post but we're using
63:29 - generics so it's just t
63:33 - now this means within my view model i
63:35 - expect to get my array of user or posts
63:38 - back immediately
63:40 - so that i can assign it to my published
63:41 - property
63:43 - and that's what i would have thought
63:46 - well let's try and fix this function up
63:48 - so that we can actually do that
63:51 - let me start the same way as before i'm
63:52 - going to copy the pasted code
63:55 - but since there's no completion handler
63:57 - let's just
63:58 - rule that out and just return
64:01 - now this isn't really good because
64:03 - remember we want to pass that error on
64:06 - up to our calling view so that we can
64:07 - present it to the user in an alert
64:11 - so we can designate this function as
64:13 - being a throwing function one that might
64:16 - throw an error or cause an error
64:18 - and we do that by typing throws before
64:21 - the return
64:23 - then you can throw the error rather than
64:25 - returning
64:28 - and what kind of error do we have
64:30 - we have an invalid url error
64:34 - so we can just throw the api errors
64:37 - invalid url case
64:41 - by designating a function as being a
64:43 - throwing function every time you call
64:45 - the function
64:46 - you're going to have to at some point
64:48 - catch the errors that were thrown by it
64:50 - so this means we'll be passing the error
64:52 - higher up the calling hierarchy
64:54 - this function could have been called by
64:56 - another function
64:57 - that was itself called by another one
65:00 - and at some point then you need to catch
65:02 - and deal with that error or maybe
65:05 - translate that error into a different
65:07 - type of error
65:08 - and that's where a do try catch block
65:12 - comes in
65:14 - and you'll see that in just a second
65:18 - so here's where i ran into a roadblock
65:21 - when i'm fetching from a network it's
65:23 - not asynchronous normally
65:25 - we have to wait until i get that
65:27 - response before i can move on to the
65:29 - decoding the data
65:32 - and this is the equivalent to a
65:33 - completion handler we wait for it to
65:35 - complete processing before we pass it
65:38 - back as the argument for our completion
65:41 - function
65:42 - now though instead of using our previous
65:44 - url sessions data task with url function
65:47 - we're going to use a different version
65:51 - when we start typing
65:52 - urlsession.shared.data
65:57 - i see that there are a number of options
65:59 - and i can scroll down and there are some
66:01 - grayed out ones
66:02 - and the one that i'm looking for is this
66:05 - one here
66:06 - and you'll see why it's grayed out in
66:09 - just a minute we see that it's marked
66:11 - with async throws
66:14 - the throws means what we've just
66:16 - experienced if we run into an error we
66:18 - can throw that error back to the caller
66:20 - but what about async
66:22 - well i'll get to that in just a minute
66:25 - we do see however that it will return
66:27 - both a data
66:29 - and a url response
66:32 - and this function itself has been
66:34 - designated as throwing so here's what i
66:37 - talked about somewhere on down the chain
66:39 - we have a throwing function and we're
66:41 - going to have to deal with it at some
66:43 - point so let's deal with it here and
66:46 - convert that error into our own api
66:48 - error
66:49 - so we'll catch that error
66:51 - and then pass it on up to our caller
66:55 - now the delegate is optional so we can
66:58 - remove that
66:59 - and the url is just our url so let's
67:02 - just use it
67:05 - remember that function does return data
67:07 - and response so we'll create a tuple of
67:10 - our own to assign those return values
67:14 - now xcode is going to help us here
67:17 - it generates an error and it says that
67:19 - this function can throw but it's not
67:21 - marked with try
67:23 - so anytime a function throws you have to
67:25 - use try
67:27 - so that url session function it was a
67:30 - throwing function
67:32 - so we'll have to try
67:34 - now this creates a new error which is
67:37 - the async call in a function does not
67:39 - support concurrency
67:41 - and that's when our function was
67:42 - designated as an async throwing function
67:46 - and this is new for us
67:47 - it means that that get json function
67:50 - needs to support concurrency
67:52 - so we'll need to have to go back up to
67:54 - where we define our function
67:56 - and make it an async throwing function
68:02 - now we're not out of the water yet
68:04 - though because we're told now that the
68:06 - expression is async but it's not marked
68:08 - with a weight
68:10 - and that's because the function is an
68:12 - asynchronous one and we have no idea how
68:15 - long it's going to take for our data and
68:16 - response to come back
68:18 - so we must wait for it before we move on
68:21 - in our code
68:22 - and we do this by specifying that we
68:24 - await for that tuple before assigning it
68:27 - to our constant
68:28 - and the order matters
68:30 - we first try
68:32 - and then we await for the result from
68:34 - our call
68:36 - now what if that data from the url
68:38 - function actually produces an error
68:41 - that try through an error
68:43 - well by using a simple try we're saying
68:46 - that we want the error to bubble up to
68:48 - whatever viewmodel is calling that
68:50 - function
68:51 - but i want to handle all my errors here
68:54 - in the same way right here in this
68:55 - function
68:56 - so i'm going to catch that error
68:59 - and change it to one of my ati error
69:01 - types and throw it
69:04 - so for this what i'll do is use a do
69:07 - catch block
69:08 - and in the catch block then
69:10 - i can throw our api services api error
69:14 - which is the data task error case
69:18 - and it needs an associated value
69:20 - which is the localized description of
69:22 - the error
69:24 - that that one level up through
69:27 - so now we have data and response so we
69:29 - can check exactly the same way as we did
69:31 - before
69:33 - first for the response we need to check
69:35 - that it's a code of 200 or throw
69:39 - so we can do this inside a do catch
69:42 - block just like we did before
69:44 - only we have a completion handler to
69:46 - pass our under error with
69:48 - we don't have one anymore so instead
69:51 - we're just going to throw an api error
69:53 - which is the case in valid response
69:55 - status
69:57 - still within the do block we have that
69:59 - data and the data task error will have
70:01 - thrown an error there been one so now we
70:04 - can decode and return the decoded data
70:08 - now unless there is an error decoding
70:10 - data in which case again no completion
70:12 - handler we'll need to throw the decoding
70:14 - error using that errors localized
70:17 - description as the associated value for
70:20 - our api error type
70:25 - well that's it
70:26 - we're done
70:31 - our app would still build and run
70:33 - because we're still calling that
70:35 - original function though i haven't
70:36 - deleted it at least not yet
70:39 - let's return now to our users list view
70:42 - model and change that call
70:45 - we'll still need that instance of api
70:47 - service and the is loading toggle
70:49 - function but this get json function
70:52 - needs to be commented out for now but
70:54 - i'll keep it here just for reference
70:57 - instead we can use our new api service
70:59 - get json function
71:01 - now we know that it's going to return
71:03 - our user so let's assign the return
71:05 - value to users and we'll
71:07 - call that function
71:09 - now notice there are two of them we want
71:12 - the async throws one
71:15 - now this generates an error call can
71:17 - throw but it's not marked with try and
71:19 - the error is not handled in fact the
71:22 - order in which the arrow occurs
71:24 - as there are going to be three of them
71:26 - may be different from you but
71:28 - the errors are the same as we saw
71:30 - earlier
71:32 - first we'll need a try
71:36 - and we'll need to designate that
71:38 - function as being asynchronous
71:42 - then we'll need to await the result
71:46 - but we're at the end of the line now if
71:48 - we encountered any errors we'll need to
71:51 - set our show alert
71:53 - to true and set the error message so
71:55 - that the localized description
71:57 - is used for the message body
72:00 - so we can do that do catch block right
72:03 - now to handle that
72:07 - well we're going to do it the same way
72:09 - that we did before by setting the show
72:11 - error alert to true and setting the
72:13 - error message to that errors localized
72:15 - description and we don't even need self
72:23 - we no longer need this commented out
72:25 - code here for reference so let's just
72:26 - delete it
72:29 - our is loading property has been toggled
72:31 - to true but we've never turned it off
72:34 - well since this entire function is
72:36 - asynchronous we can place our defer
72:38 - block right after it and it won't be
72:40 - toggled or called if the execution is
72:43 - going to be deferred until the function
72:45 - exits its scope
72:49 - so we can just use defer is loading
72:52 - toggle right after we assign it
72:54 - isn't this nice and clean
72:56 - so much easier to read and follow
72:59 - now users is a published property and
73:01 - this function is executing on a
73:03 - background thread
73:05 - so we'll get that severe warning if we
73:07 - don't do something to fix that and set
73:09 - it back on the main thread
73:12 - if i try to enclose this with a
73:15 - dispatchq.main.async block
73:17 - i get an error
73:21 - in swift 5.5 there is a new attribute
73:23 - called main actor that we can use to
73:25 - decorate the entire function
73:28 - and it will then dispatch this task onto
73:30 - the main thread
73:35 - when we build we get an error though in
73:37 - the users list view because it's now
73:39 - calling that new get users function
73:43 - and that's an asynchronous function
73:47 - so what we have to do is make sure that
73:49 - our on appear is asynchronous
73:52 - and so what we can do is we can within
73:55 - that on appear function create an
73:57 - asynchronous unit of work which we'll
74:00 - call a task
74:02 - and since that's asynchronous
74:04 - we need to await the result
74:08 - no try here though because we've caught
74:10 - any errors back in that fetch users
74:12 - function
74:15 - well in ios 15 we can go one step
74:17 - further than this we can combine both on
74:20 - appear and task
74:22 - into a new asynchronous task method that
74:25 - adds an asynchronous task to perform
74:28 - when this view appears
74:32 - this code is much easier to follow and
74:34 - work with
74:35 - when i make that call
74:37 - to fetch users i'm either going to be
74:39 - successful
74:40 - or it'll throw an error
74:43 - if successful we assign the decoded data
74:45 - to our published property
74:48 - since this is our calling point of our
74:50 - throwing functions we need to deal with
74:52 - any errors that were thrown earlier in
74:54 - the process and therefore the do catch
74:57 - block
74:58 - it all compiles properly now no errors
75:02 - but our posts are still using that old
75:04 - api service
75:06 - get json function
75:07 - so we want to fix that before we can
75:09 - remove it
75:11 - so let's do that let's return to the
75:13 - users list view model and we'll copy
75:16 - everything from the defer on down
75:21 - then in post list view in the fetch post
75:23 - function will replace the old get json
75:26 - function
75:27 - with this new code
75:29 - we just have to change our users to
75:31 - posts
75:34 - it's complaining however because it's an
75:36 - async call in a function that doesn't
75:39 - support concurrency remember anytime
75:41 - we've got concurrency we need to specify
75:44 - that our function is asynchronous
75:48 - and also don't forget that we need to
75:50 - dispatch that task back onto the main
75:53 - queue so we decorate the function with
75:55 - the main actor attribute
76:01 - this requires one more change in the
76:03 - post list view as well because we are
76:05 - now calling an asynchronous task
76:08 - so we'll need to create that unit of
76:09 - work
76:11 - which means we'll change appear to task
76:14 - and then await the return of our posts
76:19 - we can test now in the simulator
76:22 - and we'll see that it all works just as
76:24 - before
76:25 - but with much more readable code
76:34 - after having done all of that work we
76:36 - want to make sure that you commit the
76:38 - changes to your git repository
76:40 - this is so much cleaner now
76:45 - in the fifth video in this series we're
76:47 - going to take this even further we are
76:49 - currently fetching all of our users at
76:51 - once and then at one at a time we're
76:54 - fetching an individual user's post as
76:56 - needed
76:57 - and we'll do that every time that we
77:00 - click on one of the rows in our users
77:02 - list that's a lot of network calls if
77:04 - we're viewing a lot of different users
77:06 - posts
77:07 - so what we'll do in the next video is
77:09 - retrieve all of the users and all of the
77:12 - posts in parallel so that they're all in
77:14 - memory and then filter the posts for
77:16 - each individual user as we need them
77:19 - a maximum of two network calls anytime
77:22 - we launch our application
77:25 - hi my name is stuart 9chan this is the
77:27 - fifth of six videos in the ios
77:29 - concurrency series
77:31 - by the end of the fourth video we had
77:33 - converted our get json function into one
77:35 - that uses the new async and away
77:37 - concurrency method introduced in ios 15.
77:42 - in this video we're going to extend that
77:43 - even further by introducing you to
77:45 - parallel asynchronous concurrency using
77:48 - asynclet
77:50 - we'll create a new model to contain a
77:52 - user and all of that user's posts in an
77:55 - array and use that model after fetching
77:58 - all users and posts up front in two
77:59 - asynchronous calls in parallel when the
78:02 - user's list loads thus potentially
78:05 - reducing the number of network requests
78:08 - now if you're just jumping into the
78:09 - start of this series you can download
78:11 - the completed code from the fourth video
78:14 - of this series from the link in the
78:15 - description below
78:18 - now that we have much more easily
78:20 - readable code i want to show you where
78:22 - this really shines
78:24 - let's create a new experimental branch
78:26 - on this current branch
78:28 - so make sure you select the source
78:30 - control navigator
78:33 - then right click on async and await
78:36 - and create a new branch from here
78:38 - and call it parallel concurrency
78:42 - and make sure you check out that branch
78:43 - if it's not done automatically
78:47 - what i'd like to do now is to fetch all
78:49 - of our users and all the posts before
78:51 - presenting the list view and add a count
78:55 - of the number of posts per user
78:56 - alongside their name in the users list
78:59 - view
79:01 - then since i have all of the users posts
79:04 - i can pass them on to the post list view
79:07 - for that user instead of when i get
79:09 - there
79:10 - this should limit the number of server
79:11 - requests to 2 then no matter how many
79:14 - times i go from users to posts
79:18 - so to do this i'm going to need a new
79:20 - model that we can use to consolidate
79:22 - this information
79:25 - in the models folder create a new swift
79:27 - file called user and posts
79:30 - and in there create a struct with the
79:32 - same name
79:35 - i'm going to be using this in the users
79:37 - list view so i want to to conform to the
79:40 - identifiable protocol
79:45 - we'll need an id property to make sure
79:47 - that it does conform to that protocol so
79:50 - to make it easy let's just create one
79:52 - and we'll use the uuid
79:59 - now each object will contain a user and
80:01 - that user's posts
80:03 - so the user will be of type user and
80:06 - posts will be an array of post
80:11 - i do want one more thing though and that
80:12 - is the number of posts so that i can
80:14 - display it
80:15 - so i can create a computed property for
80:17 - this called number of posts
80:20 - and it will be an int that returns the
80:23 - post count
80:30 - in the users listview model right now we
80:32 - have a single function that fetches
80:34 - users
80:35 - what if after we fetch users then we
80:37 - fetch all of the posts and then run a
80:39 - loop through our users filtering the
80:41 - posts by id and then assigning them to
80:44 - that user
80:46 - so let's change this publish property
80:48 - here to no longer be an array of user
80:50 - but an array of user and posts
80:57 - of course this is going to break our
80:58 - code because we no longer have that
81:00 - published user property
81:02 - but we still have to keep track of them
81:04 - until we build our now empty user and
81:07 - posts array
81:08 - so let's just preface this with a let to
81:11 - create a constant users containing the
81:14 - array of fetched users
81:17 - but this is a new property and users
81:19 - won't know what it's expecting to
81:20 - retrieve so we'll need to specify that
81:22 - it expects an array of user
81:28 - this convenient init no longer uses any
81:31 - users and we've not set up any in our
81:33 - mock data for our new users and posts so
81:36 - let's just comment this out for now
81:42 - so how do we get all posts
81:45 - well the url for that can be found
81:48 - in the api documentation and we put that
81:51 - endpoint url as a comment at the top of
81:53 - our post struct
81:55 - so we'll
81:56 - copy that now and we'll create a new
81:59 - instance of the api service
82:02 - passing in that endpoint
82:08 - then we can asynchronously fetch all of
82:10 - the posts the same way that we fetched
82:12 - all of our users
82:14 - but this time for posts
82:16 - and it's an array of post
82:23 - now if we had to do this with our old
82:25 - callback method we'd be in a little bit
82:27 - of trouble since we would need to have
82:29 - nested these requests within an api
82:31 - service get json callback function with
82:34 - a completion handler
82:36 - here the power of async and await really
82:39 - shines
82:40 - this fetch post request won't be
82:42 - executed until the above one has
82:44 - completed
82:46 - so it looks almost synchronous
82:49 - well now that we have both users and
82:51 - posts we can loop on users
82:55 - and then we can determine that
82:57 - particular user's post by filtering the
82:59 - posts array
83:01 - where the user id is equal to the user
83:04 - id
83:06 - and we can use the array filter
83:08 - operation for this
83:10 - and using a higher order function really
83:13 - condenses your code and if you're
83:15 - familiar with the syntax it's quite easy
83:16 - to read
83:18 - if you are unfamiliar with this you can
83:20 - check out my video on higher order
83:21 - functions
83:23 - and this one here in particular includes
83:25 - the filter function
83:28 - well now that we have a user in all of
83:30 - her posts we can create a new user and
83:33 - posts
83:35 - so we can pass in the user and all of
83:37 - our posts
83:39 - and then we can append it to our users
83:41 - in posts publish property
83:46 - users in list view of course is broken
83:49 - because we no longer have an array of
83:50 - users we have an array of user and posts
83:54 - so in the navigation link we no longer
83:57 - are going to pass in the user id
84:00 - we want to pass the entire array
84:03 - so we'll just have to fix the post list
84:05 - view
84:06 - as well in a minute so for now let's
84:08 - just change this to
84:10 - post list view
84:11 - posts
84:12 - being user and posts dot posts
84:17 - for the label we'll need to change this
84:19 - to user and post dot user to access the
84:22 - user's name and the user's email
84:24 - properties
84:29 - i also mentioned we want to display the
84:31 - number of posts so we can do that right
84:32 - here by embedding the name text view in
84:35 - an h stack
84:38 - and then after the name we'll add a
84:40 - spacer
84:42 - and then present another text view with
84:44 - the computed property of the number of
84:46 - posts from our model
84:48 - and use string interpolation to surround
84:50 - the number with brackets
85:02 - all we have to do now is fix up that
85:04 - post list view
85:07 - now instead of having to create a view
85:09 - model i can remove this state object
85:11 - altogether
85:14 - we're not expecting a user id anymore
85:16 - we're expecting an array of post
85:20 - since our posts are no longer in a view
85:22 - model we can remove the vm
85:26 - there will no longer be a need for the
85:28 - alert here because we're not going to be
85:30 - fetching anything here
85:32 - and we can also remove the overlay
85:35 - and the task
85:38 - now our preview is complaining here so
85:40 - we'll need to fix that which means that
85:41 - we'll need more mock data but we'll come
85:44 - back to that
85:45 - for the moment let's just comment the
85:47 - preview out here
85:49 - i'm still getting an error when i want
85:50 - to build
85:52 - uh yeah i see i forgot that i commented
85:54 - out that convenience initializer
85:56 - so it no longer exists so i need to
85:59 - remove it here when we initialize
86:04 - if we test this in the simulator now it
86:06 - works
86:07 - and we see the number of posts besides
86:09 - each user
86:11 - it just so happens that this api
86:13 - actually has 10 posts per user but trust
86:16 - me if the count were different per user
86:18 - this would still work
86:21 - so let's fix that mock data for our
86:23 - preview
86:27 - we can create a new extension in our
86:29 - mock data file for user and posts
86:33 - and then create a static computed
86:35 - property that's called users and posts
86:37 - that is an array of our new user and
86:40 - posts object
86:44 - so we then repeat the same process that
86:46 - we did when we are in our users view
86:48 - model
86:52 - we'll create an empty array of new user
86:55 - and posts
86:57 - and then we'll loop through our
86:59 - mock users from the user
87:02 - model will create a new user and post
87:07 - filtering the post mock posts
87:10 - to get just the posts for that
87:12 - particular user
87:26 - and then we'll append it to that new
87:28 - user and post array
87:30 - and once the loop is completed we can
87:33 - return the new users and posts
87:41 - back then to the users list view model
87:44 - we can fix that extension
87:46 - so that users and posts is user and
87:49 - posts mock users and posts
87:56 - and then in the post list view then we
87:58 - can uncomment the preview to change that
88:01 - argument to posts
88:02 - and pass in the post mock single users
88:05 - post array
88:10 - and then back in the user's list view we
88:12 - could add back that convenience
88:14 - initializer because we have it again
88:16 - and whether we are in the preview mode
88:18 - or not we can decide if we want to see
88:21 - that mock data in the canvas when it's
88:23 - set to true
88:26 - if it's set to false it disappears
88:32 - if we go back and check out our code and
88:34 - however there is something that can be
88:36 - improved on even more
88:39 - we're fetching all of our users and then
88:41 - waiting until they're all fetched before
88:43 - we fetch all of the posts
88:45 - the fetching of the posts is not reliant
88:48 - on the fetching of users in fact we
88:50 - could be doing this in parallel
88:53 - well welcome to asynclet
88:56 - we can simply preface each of our api
88:59 - service calls with async
89:03 - so that it now reads async lat
89:07 - now this creates errors in our for loop
89:09 - because we'll need to wait for them to
89:11 - have finished first before carrying on
89:13 - before we can access both the users and
89:15 - posts
89:16 - so we'll need to try and await for both
89:19 - and we can do that by assigning them to
89:21 - a new variable but as i said we'll have
89:24 - to await for both of them so let fetched
89:28 - users
89:29 - fetch posts in the tuple
89:31 - await for the users and posts
89:35 - but as i said these are failing because
89:37 - we'll have to try for each of them
89:44 - then all we need to do in our loop is to
89:47 - change user to fetch users
89:51 - and posts to fetch posts
89:55 - we're now
89:56 - getting both the users and posts at the
89:59 - same time
90:01 - and then we can then run our loop
90:04 - testing now we see that it all works
90:06 - nicely
90:07 - and we're now saving on costly network
90:10 - calls
90:15 - let's finish now then by committing this
90:17 - branch to our git repository
90:27 - in the final video of this series we'll
90:29 - be checking out that old main branch
90:31 - again and branching off of it to change
90:34 - our target back to ios 14
90:37 - and see if we can use these new
90:38 - asynchronous functions in an earlier ios
90:42 - this is what's promised in xcode
90:46 - 13.2 hi my name is stuart lynch and this
90:49 - is the sixth and final video in the ios
90:52 - swift concurrency series
90:55 - in this video we're going to see if we
90:56 - can apply the new ios asynchronous
90:58 - concurrency methods to an xcode project
91:01 - with a target of ios 14.
91:04 - this will require xcode 13.2 or later
91:07 - and it wasn't until xcode 13.2 that
91:10 - apple back-ported some of these features
91:12 - to targets of ios 13 or earlier
91:16 - if you're just jumping into the start of
91:18 - this series you can download the
91:20 - completed code from the fifth video in
91:22 - this series from the link in the
91:24 - description below
91:27 - with xcode 13.2 some of the new
91:29 - concurrency features have been
91:31 - backported to ios 13. and this is great
91:34 - news because perhaps we realize that by
91:36 - setting our target to ios 15 only we're
91:39 - missing out on a lot of users who have
91:41 - not upgraded their phones
91:44 - we're currently using some ios 15
91:46 - specific apis that we'll no longer be
91:48 - able to use
91:49 - but i would really like to use this new
91:51 - asynchronous concurrency model
91:54 - as we're testing again let's create a
91:56 - new branch
91:57 - by now this should be familiar to you
92:00 - select the source code navigator and
92:03 - then
92:04 - right click on the main branch to check
92:06 - it out
92:09 - notice that it is now the active branch
92:12 - and we're going to branch off of this
92:14 - one right here so we'll right click and
92:17 - create a new branch
92:19 - and i'll call it back port
92:24 - this time
92:25 - it created the branch and it checked it
92:27 - out all at the same time so now it's my
92:29 - current active branch that i can work on
92:35 - now this get json function in our api
92:37 - service is the completion handler
92:39 - version of our function
92:41 - and it doesn't use the new async and
92:43 - await concurrency methods that were
92:44 - introduced in ios 15.
92:47 - in videos four and five of this series
92:49 - we changed that to use these new methods
92:52 - now if you've updated your xcode to
92:54 - version 13.2 you should now be able to
92:57 - take advantage of those new features and
92:59 - projects for targeting earlier versions
93:01 - of ios
93:03 - and this is one of the terms target
93:05 - applies
93:07 - switch the application and you'll see
93:09 - both project and target
93:12 - the target in this sense means which of
93:14 - the apple sdks am i developing for is it
93:17 - mac os ios
93:19 - ipad os
93:21 - is it a widget kit application or one of
93:23 - many others
93:25 - if you click on the target and then on
93:28 - the general tab
93:29 - there is a deployment info section
93:32 - and here you get to see what the ios
93:34 - deployment target is
93:36 - and in my case here it's set to ios 15.2
93:41 - this means that in order to install and
93:43 - run this application on your device it
93:45 - has to be running ios version 15.2 or
93:48 - higher
93:49 - and those who haven't upgraded yet can't
93:52 - run your application
93:54 - as i said you potentially may be losing
93:56 - out on a lot of customers
93:58 - in most cases the swift ui going back to
94:01 - ios 14 from ios 15
94:04 - requires only minor changes depending on
94:06 - what apis you've implemented and we'll
94:08 - see that shortly
94:10 - going back to ios 13 is a little bit
94:12 - more problematic because there are more
94:15 - deprecated methods
94:17 - so i'm going to take the less
94:18 - troublesome path and change my target
94:20 - back to ios 14
94:22 - and see what happens and what's going to
94:24 - be required
94:29 - when we build
94:30 - we get several errors
94:33 - and these errors are all saying that a
94:35 - particular api that we're using is only
94:38 - available in ios 15 and newer
94:43 - the overlay and alert apis we use in our
94:46 - code have changed since ios 14.
94:49 - so we're going to have to revert back to
94:51 - the deprecated versions that were
94:53 - available to us then
94:55 - it's important to note that deprecated
94:57 - doesn't mean that we are playing with
94:59 - fire there are many deprecated apis that
95:02 - have been around for many many years so
95:04 - there's no need to panic
95:06 - at some point however in the future
95:08 - though
95:08 - when you change your target back to ios
95:10 - 15 or higher you should change the code
95:13 - again to remove the deprecated versions
95:17 - if i click on one of the overlay errors
95:19 - it takes us to that culprit
95:23 - if you option click in the overlay error
95:25 - in users list view we get the quick help
95:28 - and if we scroll down further we see
95:30 - open in documentation
95:33 - so let's do that
95:35 - and we'll see that it's available from
95:37 - ios 15 on
95:41 - i know that there's an ios 14 version
95:43 - however because i use it
95:48 - and it doesn't put our view into this
95:49 - trailing closure
95:51 - rather overlay didn't use a closure at
95:53 - all
95:54 - so let's remove it
95:57 - now the error here is hard to decipher
95:59 - but if we enclose
96:01 - our clause here in a group
96:04 - the error goes away
96:08 - but we can repeat that in the post list
96:10 - view too
96:11 - so we'll do the same thing we'll remove
96:13 - the closure
96:14 - and embed it within a group
96:21 - let's check out the alert and option
96:23 - click and then drill down into the
96:25 - documentation
96:29 - i can see that it too is ios 15 on only
96:34 - now if i search through the
96:35 - documentation
96:37 - and click on the alert that's found i'm
96:39 - taken to another alert
96:41 - and i see that it's been available since
96:44 - ios 13
96:46 - but that has been deprecated
96:48 - it may take several releases for it to
96:50 - actually disappear and by that time
96:53 - hopefully you've updated your code to
96:55 - use the more modern apis
96:59 - we can see that this documentation is
97:01 - within a section called deprecated views
97:04 - and controls
97:06 - scrolling down we can see the different
97:07 - initializers that were available to us
97:13 - if we remove this code now we can start
97:15 - typing dot alert
97:19 - and if we take a look at the options we
97:21 - can scroll down and we'll see the two
97:23 - earlier versions and they are marked in
97:25 - gray that's an indication that they're
97:28 - deprecated or not available to us
97:31 - however we can make them available to us
97:33 - let's choose the is presented version
97:37 - and it needs to be bound to something
97:39 - which is our view models show error
97:42 - alert
97:45 - inside the content closure we'll need to
97:47 - use what is known as an alert object
97:51 - and there are a number of options here
97:53 - the one we want is the one with title
97:56 - message
97:57 - both being text views
97:59 - and an optional dismiss button
98:04 - for the title we can use a text view
98:07 - and we'll just say application error
98:12 - for the message we can use another text
98:13 - view with our view models error message
98:19 - but it's optional
98:20 - so we'll no coalesce it with an empty
98:23 - string
98:25 - and we don't need the dismiss button
98:26 - because as i mentioned it's optional so
98:28 - we can just remove it
98:32 - we can repeat this process for the
98:34 - user's list view and i happen to know
98:36 - that the ad alert is exactly the same so
98:38 - we'll just copy it here
98:41 - and
98:42 - paste it or replace it with the same
98:44 - version
98:46 - if we build now there are no errors
98:49 - great
98:49 - but we really haven't gained anything
98:53 - what you have now is a project that you
98:54 - could have originally coded using xcode
98:57 - 12 under ios 14.
99:01 - if you want to go back to ios 13 you'd
99:03 - have to do more things like changing the
99:05 - navigation title to a navigation bar
99:08 - title
99:09 - you couldn't use state object and
99:11 - there's probably a host of others so i'm
99:13 - going to stop here but you can go back
99:15 - as far as ios 13 with swift ui
99:19 - the observant of you will notice that
99:21 - the list style is not complaining about
99:23 - my using dot plane instead of using the
99:26 - full instance of plane list style struct
99:29 - that we had to do in xcode 12
99:32 - and it appears that the new style
99:33 - options have been backboarded so we
99:36 - don't need to do anything to change them
99:40 - well with xcode 13.2 we learned that the
99:43 - new concurrency methods have been
99:45 - backboarded as far back as ios 13.
99:49 - so if we want to update your api fetches
99:51 - to use this new asynchronous version of
99:53 - the url session data method
99:56 - we're going to have to implement those
99:58 - new features
100:00 - and this should greatly clean up our
100:01 - code
100:03 - well it turns out that although swift
100:05 - 5.5 new concurrency system is becoming
100:08 - backward compatible in xcode 13.2
100:11 - some of the built-in apis that make use
100:14 - of these concurrency features are still
100:15 - only available on ios 15.
100:19 - mac os monterey
100:21 - and the rest of apple's 2021 operating
100:24 - systems
100:25 - the good news however is that we are
100:27 - provided with another method that we
100:29 - haven't looked at yet and it's a
100:31 - continuation mechanism that lets us
100:33 - retrofit existing code with async await
100:37 - support
100:39 - and what also is good news is that xcode
100:41 - gives us some assistance here
100:44 - if you command click on the function
100:46 - name for our existing completion handler
100:49 - version of get json
100:50 - you get three different options for
100:52 - converting this function to an
100:54 - asynchronous version
100:56 - and all three will work but we really
100:58 - would like to understand this so i can
101:00 - code in the future from the get-go
101:03 - so let's explore the options and we'll
101:05 - start from the bottom up
101:08 - if i choose this method it simply
101:10 - creates a new function that has the same
101:12 - first two parameters but instead of a
101:14 - completion handler it's an asynchronous
101:17 - throwing function
101:18 - just like our new one that we created in
101:20 - videos four and five
101:23 - no error then calling the new function
101:26 - yet json because as we saw in video four
101:29 - we can have two functions with the same
101:31 - name so long as the function parameters
101:33 - are different
101:34 - what this does use is the with checked
101:38 - throwing continuation that calls our old
101:41 - completion handler function
101:43 - and then essentially maps the
101:44 - continuation into an asynchronous one
101:48 - that's pretty cool but now i have two
101:50 - functions to clutter my code
101:52 - and our viewmodels are still calling the
101:54 - older version with the completion
101:56 - handler and not this version
101:58 - so let's just undo this and take a look
102:00 - at our second one
102:05 - if we choose this one it basically does
102:07 - the same thing as we saw in the previous
102:09 - example
102:10 - but it makes all of the same changes in
102:13 - line in the asynchronous version of our
102:15 - function
102:17 - with the use of the checked throwing
102:19 - continuation block
102:21 - and adds continuation resume for each of
102:23 - the result enum cases
102:27 - now the errors we're getting here are
102:29 - all related to the function now not
102:30 - recognizing the api error case since
102:33 - it's not specified in our function
102:35 - parameters
102:36 - and we can fix that by
102:38 - prepending all of the cases with api
102:41 - error
102:42 - and by removing any unnecessary returns
102:56 - still i have two functions to deal with
102:58 - and our viewmodels are still calling
103:00 - this older version with the completion
103:02 - handler and not this version so let's
103:05 - undo once
103:08 - more let's go all in now then and
103:11 - convert our function completely so that
103:13 - we only have a single function to deal
103:15 - with and that's what this first
103:18 - option will do for us
103:22 - well we'll need to fix those return and
103:24 - errors for not knowing what type the
103:26 - error is still just like we did in the
103:28 - last version
103:34 - the errors in this file all go away now
103:36 - but when i build i get four errors well
103:39 - why is that
103:40 - well it's because now i'm trying to call
103:42 - that old completion handler version that
103:44 - we had before
103:47 - and it's no longer here
103:49 - so let's fix that
103:50 - and this will be a repeat of what we
103:52 - basically did in video 4 when we created
103:55 - the async function from scratch in ios
103:58 - 15.
104:00 - in users list view model then let's
104:02 - remove from the fetch users function
104:05 - everything except the first two lines
104:07 - because we are going to need an instance
104:09 - of the api service and we want to set is
104:12 - loading to true
104:15 - but remember
104:16 - we can now use a defer block right
104:19 - within our function so after is loading
104:21 - dot toggle we'll add the defer block
104:28 - then we can simply create a do catch
104:30 - block
104:31 - and then within the do block we can try
104:34 - and await the return from the api
104:36 - service get json function and assign it
104:38 - to our users
104:42 - and we can fix the error because we need
104:44 - to specify that our function get json is
104:47 - now an asynchronous function
104:51 - in the catch block we can set show error
104:55 - to true
104:58 - and then set our error message with the
105:01 - errors localized description
105:03 - and that contact information
105:13 - and then we have to decorate the
105:15 - function with app main actor to ensure
105:17 - that the function is dispatched back on
105:19 - the main cube
105:26 - well we can copy everything from defer
105:28 - on down here
105:31 - and then go to the post list view model
105:33 - and replace the corresponding part of
105:35 - the get post function with this same
105:38 - content
105:40 - updating of course users to posts
105:44 - specifying that the fetch post function
105:46 - is asynchronous
105:49 - and adding the app main actor to make
105:52 - sure that we get executed on the main
105:54 - thread again
105:59 - we have a couple of errors left though
106:01 - and those are in our views
106:05 - and that's because in on appear
106:08 - we're trying to call a asynchronous
106:10 - function
106:12 - well we can't use dot task as we did in
106:15 - ios 15. it's one of those things that
106:18 - didn't get backboarded
106:19 - however you may recall that there's
106:22 - another option
106:23 - we can use a unit of asynchronous work
106:26 - called a task
106:28 - so we can embed within the on appear our
106:31 - content inside a task
106:34 - and await the fetching of the json
106:40 - finally then we can go to the post list
106:43 - view and do exactly the same thing for
106:46 - on appear
106:47 - we can enclose our actions in an
106:50 - asynchronous task
106:53 - and then await the fetching of the posts
106:57 - we can build and run now
107:00 - and all errors will disappear
107:02 - and our application runs
107:14 - we have successfully backported our
107:17 - application to run under ios 14
107:20 - using the new asynchronous methods
107:24 - before we ship the app though make sure
107:26 - that you'll check any warnings the app
107:28 - is giving you
107:29 - like this one here that we left for
107:31 - ourself to make sure that the four
107:34 - previews is set to false
107:37 - now the last thing i'm going to do is
107:39 - commit any changes to our local git
107:42 - repository
107:48 - well that's it
107:50 - thanks for joining me on this six part
107:52 - journey and i hope that you've learned
107:53 - some useful and transferable skills
107:56 - i want to thank chris for inviting me to
107:58 - add content to his channel and i look
108:01 - forward to being able to contribute more
108:02 - in the future thanks for watching

Cleaned transcript:

hi my name is stuart lynch and i'm very happy to be offering you this series on behalf of code with chris though the title of this series is ios concurrency it is much much more it's a six part series where i'll introduce you to json decoding and creating models from json building an api service to perform asynchronous network calls to fetch that json we'll go through the traditional completion handlerbased url functions handling and reporting errors along the way there are a lot of topics covered as my intention is to provide you with methods and understanding that you'll be able to apply to your own projects both now and in the future in this first video we'll focus on creating our models from the json and an api service to handle the process we'll create a generic function to handle the different api endpoints and models and use a result based completion handler with our own designed api error if this is something you're interested in then let's get started first create a new xcode ios app project and make sure it's a swift ui project and name it something like ios concurrency now i always like to add an app icon and launch screen to my app so that they are easily recognizable in the simulator or on my phone if i install it there i provided you with some resources for this project with these two items already created you can find those in the link in the description below so go to the assets folder of your project and drag the launch screen image into that folder next select your app's target and then the info tab to see the new ios 15 info.plist drop down the disclosure icon on the launch screen then click on the plus icon and select image name make sure that you enter the image name with the lowercase l and uppercase s but don't enter the png extension next right click on the app icon in the assets folder and choose show in finder bring up that provided resources folder once more and move the app icon app icon set into that folder replacing the empty one we've just installed the icon and launch screen if you run your app now in the simulator when it launches you should see that launch screen if you exit the app or quit and check the simulator's home screen you'll see that icon on your app this project is going to be using the json placeholder api to fetch and decode json this api has a number of endpoints that you can use one of them is the user's endpoint where we can fetch json corresponding to 10 different users as you can see from this json here let's take a look at the post endpoint users are able to create posts as you can see from this endpoints json and there are 100 of them corresponding to 10 for each of the 10 different users what we'll need to do is to create a struct that will model that json that's why we often call these structs that represent something a model i have created a couple of youtube videos on modeling data from json and there are a number of tools available to you to do that as well the tool that i use a lot is one called ducky model editor however many people are happy with a free web paste tool called quick type these tools are particularly useful if you want to model really complex objects that have nested json our two are relatively simple so i want to model them by hand so first let's create a new group called models next create a new swift file called user now i'm going to want to reference the user's endpoint so i'll need to go back and copy that url and then i can paste it as a comment at the top of my struct so that i have quick reference to it well now with that file created i'm going to create that struct and i'm going to call it the same name user now for the user i'm really only interested in modeling the id name username and email and since these are all top level keys in the key value pairs of this json we can simply create properties that use the same name and the id will be an int and the other three are strings now since we're only going to be reading this information and not modifying it we can create the properties as constants using let now in order to decode this json the model has to conform to the codable protocol and because each one of these properties are simple types that conform to the quotable protocol already the entire struct will too so we can mark it as conforming to codable protocol we're also going to want to present our users in a list view and it's much easier to do if the struct conforms to the identifiable protocol and the only requirement for that is that there is a unique property called id and we already have that so let's do the same now for the posts json endpoint first let me copy the endpoint for the post url so that i can use as a reference and then i want to create a new file called post and in that file i can paste that url as a reference for our new model struct now this url gets all of the posts but what i want to know as well is how do i get the post for just one user so let me return to the api documentation to find that endpoint here it is and this is the one that i want so let me copy and paste that url in as well now i can create a new struct using that same name for the posts i want to model all four properties here and they are all top level as well so fairly easy to do just creating our properties using the same names as the key values in our json and again since we'll be reading this information only and not modifying it we'll create it using lips as constants both the user id and id are ints while the title and body are strings the user id property corresponds to the id property in our user model and the id though is the unique property for this particular model and again in order to decal with the json the model has to conform to the equitable protocol and because each of these properties are simple types that conform to the quotable protocol the entire struct wheel too and with the id property being here we can conform the construct itself to the identifiable protocol now i have an entire series on json decoding and it covers this as well as how to decode and encode your data which we'll be going over soon i'll leave a link here in the notes below now i want to create a struct that i can use as a service that i can call from a variety of different views to fetch our data whether that be an array of user or an array of post now there are a number of ways to do this and you may have heard of a singleton but it gets a lot of bad press about not being able to test but we're not going to be running any unit tests on this project but let's start right now by creating good habits and anytime we want to access that service we'll create a new instance of the service so i'm going to create a group called services and even though there's only going to be one service that i create i want to keep my code organized inside that folder group i'll create a new file and i'll call it api service and inside there i'll create a struct using that same name now the struct will have one property that will be the url string representing the endpoint and we're going to have two different ones one for the users and one for the posts so each time that we create an instance of this struct we'll need to pass in a different string representing that endpoint next we'll create a function called get users now this function is going to have to return an array of users so my first inclination is to return an array of users like this unfortunately this won't work at least not yet later on in the series we'll be covering new concurrency models introduced in ios 15 but as you are likely to see still for quite a while the older method of dealing with concurrency we're going to start there this will require using what is known as a completion handler and eventually we're going to be using a result type as our completion handler's argument but i'm getting ahead of myself if you are still confused after i finish this video i recommend that you watch the two videos i have on that topic and links are in the description below let's start easy now and build on this concept the reason we need a completion handler is because we have no idea how long it's going to take for that network call to fetch that data and since our code is inherently synchronous it would move on to the next line before we received our data and a completion handler is just a closure that we can pass in as an argument so that it will get executed when that data has been retrieved and we can give that closure a name and typically people call it something like completion or completion handler so when this function has completed and we'll either have successfully retrieved our json and decoded it or an error will have been produced so when we call this function we'll need to deal with either case but first i'm going to keep it simple and deal with the error right here within the function and only execute the closure if we successfully decoded the data so the closure function is going to have an argument which will be an array of user that we've returned and it's going to return nothing or void there will be another issue however as we'll be fetching that from a server and it's going to take some time the function itself will escape the scope before we're done so we'll need to specify that this completion handler is going to escape so we do that by marking the completion function as escaping well now we can get to work first we'll need to create a url from our string and we can use a guard check for this so we'll guard url equals the url string from url string else we'll just return from the function next we'll use the url sessions singleton datatask function with url and this also has a completion handler just like our function does so we'll pass in the url for the url and when we hit enter on the closure we see that we can assign variables for the three different objects that are coming back data response and error and all three of these properties are optional the most important thing that we have to do before we forget however is to make sure that this task gets initiated so we'll also need to call resume because it's initially in a suspended state so now we can check on those three optional items that we get back first we'll check the response to see if it has a status code of 200 and that it's not nil so another guard check guard http response equal response as an http url response and also that the status code is equal to 200. else we'll just return we also only want to continue if there isn't an error so guard if error is equal to nil we can continue else we'll return from the function if we get this far then we'll need to check to see if we got data so another guard check guard but data equals data else return well now that we've got the data we can try to decode it and the key word here is try but first we'll need a decoder let decoder equals json decoder now because the decoding might fail and throw an error which means generate an error we have to create a do catch block to try and decode it and this is such a common construct the do catch block that i've created a code snippet for this so anytime you see me do dtc that stands for do try catch i have a code snippet that's going to generate that construct then we can let our decoded data be the result of trying to decode the array of user from that data and if it's successful we can just use that decoded data as the argument for our completion handler which is completion and it runs that function with that argument if it's not successful it fails so we'll just catch that error and then just print that there was an error now this will work but there are some severe limitations here and you'd not want to ship an app like this using this function when there is an error we're not giving any feedback to the user and it just exits the function the only time you do anything is when you print out that there was an error to the console but your user will never see that in a later video we're going to go over error handling in more detail but i want to set the stage here by changing this function to provide any errors to the caller so that eventually we can bubble that error up and provide an error to our users in the ui using an alert and this is where the result type comes in for our completion argument a result is simply an enum with two cases either a success case with an associated value and that associated value will be in our case the array of users the successful completion or a failure case where the result is a error type so instead of using simply an array of user in our completion handler i want to use a result type so we can change our completion argument to a result where the two cases are array of user or an error and then we'll need to fix that completion that we'd have in our function so that when we successfully decode the data the result success case dot success has an associated value and that associated value is our decoded data still with me well what about the failure case well it's going to fail every time we fail the guard check or in that do catch block we want to be more prescriptive so i'm going to create my own api error enum with all five of the cases where we could have possibly failed and the enum has to conform to the error protocol so there are five different cases in that first guard we have an invalid url so i'll set the case to be invalid url then we check the response status so my case is going to be invalid response status or perhaps the url session didn't work at all so it may be a dated task error perhaps the data was corrupt corrupt data and then finally once we get the data perhaps our model is incorrect so we'll get a decoding error so now when we fail we can do another completion using the failure case and that has an associated value that will just use our case so first we'll need to go back to where we define our result and say that we no longer want to have that error case just a generic error we want to be specific and say that it's going to be our api error and then each of those five cases we're going to now call our completion handler with the failure case and the associated value is going to be the corresponding case from our api error so first failure is an invalid url next an invalid response status then a data task error corrupt data and finally a decoding error now there are only two more things i want to do before i finish this video this function is looking pretty good but currently i can only use it for users and not post and when you look at this though the only time i use user is when i decode and define the associated value for the success case in our result type it could be easy just to copy and paste this function and change this to get posts and change user to post however there's a better way and that's using generics and i have a video on generics if you want to find out more information on that topic again a link will be in the description below the function will work for any decodable type object like our user and post objects and we can use that fact by specifying that the function should only work if that's what we're dealing with which is a decodable type so when we define our function we can specify that limitation and we can use a variable like t to represent that type and make sure that that type conforms to the decodable protocol and then everywhere where we see user we can replace it with the t placeholder now t is generic itself and it can represent either a single object or an array of objects so we don't really even need to specify array here we'll be able to specify that when we call the function and we're almost done and this is a service class that you can use in all of your projects but to make it even more inclusive and i go through this in my quotable series you may have a specific key decoding or date decoding strategy that you want to use so i'm going to create two more arguments here so before the closure let's add two more parameters for this function one is going to be a date decoding strategy which is a json decoder dot date decoding strategy and the second is a key decoding strategy which is a json decoder key decoding strategy now 99 of the time the defaults are just fine but since we are adding these two parameters when i call this function i'm going to be forced to enter in what would be my defaults when i create the instance of this getusers function so in order to make this optional for us i can assign the most common default values in the initializer for each parameter then after we create our decoder we can assign these properties to the decoder that's almost it but i forgot this function is still called get users when in fact it's going to be more generic so instead of calling it get users i'm going to change the name to get json instead well that's it we haven't tested it yet but we've created the groundwork for our app and the really good thing is that we've created a reusable api service class that you'll be able to use in your own projects in the future in the next video i'll show you how you can use this class and we'll also be improving on it when we start working on error handling hopefully this hasn't been too technical but it is worthwhile i think going through in some detail so that you understand why things are done this way when we start to use functions in a later video we'll be converting this to an alternative version that uses the new async and await concurrency model so in the next video of the series we'll be building out the ui and i'll introduce you to voodoo a modified mvvm design pattern and utilize xcode's source control features to ensure that our source code is protected hi my name is stuart lynch and this is the second of six videos in the ios concurrency series in the first video we began by creating our models and a service so that we could fetch and decode json from the json placeholder api in this video i'll introduce you to voodoo a modified mvvm design pattern so that we can create view models and views to display the content that we fetch from our api endpoints we'll also be seeing how we can use mock data so that we don't have to always make calls to the api when we design our apps and you'll be introduced to get source control using xcode i'm going to be using what mark markins from big mountain studio calls swift ui's vudu and this is a modified nvvm architecture there are three parts as you see a view the observable object and the data object now we've already created our data objects those are our models so i'll let you go through the post and i'm just going to start using it the first thing we have to do is to change the name of our opening view from content view to represent what our first view is going to be and that's going to be our users list view so we can do this by right clicking on the name and choosing refactor and when we type in our new name this not only renames the view but also the file name and any instances where it is referenced like in the app file the other thing you might want to do is to change the preview to users list view underscore preview and the header as well next we'll create a group called views and move that file into there i'm just going to adjust the order a little bit in my navigator i have my view here that i want to modify and i have data objects which are the user and post objects and now i need my observable object which i will call the users list view model so let's create a file in a new group called view models so inside that group i'll create a new file that i'll call users list view model and in there i'll create a new class with the same name but conforming to the observable object protocol now this class is going to have a single published property called users and that's going to be an array of user and i'll initialize it as an empty array so this is before we fetch our json it's also going to have a single function called fetch users so it's within this function then that we can call that function using our api service so first we'll need to create an instance of the api service and it requires a url string for the endpoint well we have that url string back in our model so we can copy that and we can then just paste it in here as the argument for the api service instance within the function then we can call the api services get json function and this provides us with a closing completion handler that is a result however this result type is generic so we'll need to specify which objects we expect to come back as the cases for the argument for that completion handler well we know that a result type has two cases and for this instance the first case the success case is going to be an array of users and the error is going to be of the type of our new api error and then we can switch on the result in an xcode 15 this nicely completes the case for me however i'm going to change the let's success to be let users and let failure to be let errors so users represents the users that we're getting back and error will represent any error that we might get now we know that that success type is that array of users so we can assign those users then to that published property of users but it's an asynchronous function that's executing on a background thread and we're going to be using this array of users to update our ui so we'll need to go back onto the main thread to do that using a dispatchq dot main dot async and just like i had a code snippet for my do catch block i have one for this dispatch queue as well all i have to do is enter dq so for the failure then i'll just print out the error at this time we'll deal with this a little bit later great now we can use this view model back in our users list view first we'll create a state object that i'll call vm that will be an instance of our user's view model next we'll replace the body with a navigation view and inside there let's create a list and then within the list we'll iterate over our view models users with a for each loop and then for each user in that array then we'll create a vstack with an alignment that is leading and then for two textviews within that stack we'll first create one it's going to represent the user.name property we'll set the font to title and then the next one we're going to represent the user's email in a text view and then we'll set the navigation title to say users we'll also set the list view style to just plain using the new condensed way of applying a list style and then finally when this view appears we can call our view models fetch users function and thus update the view so if we resume our canvas all we see is the navigation bar we don't see the preview and this is because our preview provider hasn't fetched any of our users this is only happening if we go into preview mode so we'll have to enter preview mode to initiate the fetch and display that list of fetched users i'd really like to see what my view looks like without having to make that network call you may have noticed that xcode provides us with a preview content folder and this is where you can place content that you want to exclude from your release builds when you upload to the app store the content will be available to you during development or the debug stage so this is a great place to store that kind of information and the easiest way to do that in our case is to use a sample of the json that you'll actually get from your api now i recommend you use safari without any json extension enabled so that when we view our endpoints the json will be displayed as json text in the browser window so let's go get the 10 users json from the json placeholder api all i have to do is select and copy the text to my clipboard then within the preview content group i'm going to create a new file that i'll call users.json now make sure you specify json as the extension and then replace the entire content with what you copied from your clipboard now i want to repeat exactly the same process for the post because we're going to be building out the ui for a list of posts as well so we'll go to the post json endpoint we'll copy that json i'll return to xcode and create a new file that i'll call posts.json and paste the json into there this content is now located in your application bundle during debug mode so we'll need to somehow access that and i'm going to create an extension to bundle that will easily decode this data so as long as it is a decodable type which we know ours is i'm going to share with you an extension that i copied and modified from paul hudson from hacking with swift it uses generics just like we did in our api services get json function to decode decodable objects from files stored in your application bundle now i use this all the time so i've created a just where i can get access to it at any time and a link to this is provided in the description below the code should look actually pretty familiar to you it's just that we're getting our url from the bundle instead of an endpoint and instead of a result completion handler decoding from a file isn't asynchronous so we can simply just exit with a fatal error if something goes wrong and return the decoded data if we're successful now i suggest that you just copy this to your clipboard now returning to xcode i'm going to create a new group that i'll call extensions and inside that folder i'm going to create a new file that i'll call bundle plus extension now just below the import i'll just paste that extension it's ready to use so you feel free to use this in any of your projects it's a really handy extension next we'll create a file within the preview content folder that i'll call mock data first i'm going to create an extension to the user struct and within there i'm going to create two static computed properties one that will return an array of users and another that's going to return a single user that we can use for our previews the first we'll call mock users which is an array of user and what we're going to return is that array that we decode from our bundled file so we can simply use bundle dot main dot decode the array of user type self from the users.json file within quotes for the single user then we can just create another static computed property called mock single user of type user and we'll just return the first item from our mock users by accessing the static property on self at index 0. well we can do the same for our post so all we have to do is create a new extension for post and then i'll just copy from above and anywhere i had user i'll just change it to post now i'm also going to be needing a post for a single user so i'll create one more static property that i'll call mock single users post array it's a mouthful but it's descriptive and this will be an array of post but i'll filter it so that it's using a user id that matches the number one because i know that there is a user with an id of one in my mock users great so how do we use it now there's a problem with the fact that we're using a view model to fetch our users and there's no easy way to display mock data while developing your ui in this case because whenever your view model is instantiated we set the array of users to an empty array and then the view appears when we fetch users from the api now there are a couple of ways around this you could create an alternative initializer for the view model like this we create an extension on the user's view model and in there we'll create a convenience initializer with an additional parameter called for preview that's a boolean value that will default to false then we can call the self the parents initializer which sets users to an empty array and then if we specify that for preview has been true we'll set the users to be our users.mock users with this in place then we can go back to the users list view and anytime we want to show mock data in our initializer we can simply change it so that we have this convenience initializer where we'll set for preview true and we see then without making a call to the endpoint our preview provider will generate that preview on the canvas now the bad news is that we will either have to remove the argument or set it to false when we ship otherwise our users will get that mock data first even if it never makes a call to the api so for this reason i suggest that you place a warning above this state object to remind you that you need to remove that argument before you ship now the good news is that even if your argument is set to true whenever you run on the simulator or on a device the preview will be overridden by the fetch users call on the api so that the data will quickly be replaced but it's still not ideal so remember to remove that argument or not use it at all and just keep pressing preview however if you're paying for a service that charges for fetch requests you definitely don't want to do this now we're going to do a similar thing for our posts and we'll create a post list view model that conforms to the observable object like our users list view model we'll have a published property but this time it will be an array of post objects now the criteria for fetching posts for a user will be a user id and we won't know that user id until we specify it so let's make it optional and it will default as nil and then like in our other view model we'll want to fetch the posts but we won't do that until our user id has been specified so we can use an if let here to unwrap user id so first we'll need an endpoint for the single user post so we can copy that from the post model and then returning to our post list view model we can create a new instance of that api service passing in that string making sure that we replace the hardcoded one with the user id from our view model now inside that function we can use a similar api call as when fetching our users so let's just copy and paste that in here and adjust to fit for our result we're getting back an array of post not an array of user and when we're successful we get posts so we can set our published post to that decoded array to display the posts for the user we'll need a new swift ui view that uses this view model so let's create a new file within our views folder that we'll call posts list view and inside that struct will create a new state object for post list view model now we're going to be presenting this view from a navigation view so we don't need to add one in here it's already going to be here but we can create our list so let's just copy the code from the previous view and adjust to fit again first we'll change all references from users to posts or post for the first text view let's pick the post title but change the font to headline and for the second we'll use the post body but also set a font for call out and change the foreground color to secondary and then for the navigation title we'll change it to posts and change our navigation bar title display mode to be inline in the on appear then we can change this to fetch posts the errors are all gone now but our user id in our view model is still nil so we'll not be able to get any listings yet we'll have to be injecting the id when we tap on a row from our users list so let's create a property here that's not going to change once we've passed it in so it doesn't need to be a binding and it's going to be a user id we'll also need to pass in a user id to stop the preview from completing so let me just enter a 1 here and then in on appear before we fetch our posts we'll set the user id within our view model to be what was passed in and it will no longer be optional therefore we'll generate the list view that we can be presented in this view similarly we're not going to be seeing that navigation bar because our preview has no idea that our view is in a navigation view so we can surround our preview with a navigation view just so that we can see what it looks like in our canvas i'd also like to make sure that we have some mock data so that we can view the list of posts within our canvas without having to make a call to the api so we're going to have to do the similar thing that we did with our list view model so we'll go back to that one and then we'll just copy that extension and we'll change the extension to be a postlist view model extension and adjust it here where we display instead a mock single user's post array so back in our view then we can do the same thing by cautiously adding a preview argument when creating our view model then back in our list view in order to be directed to the post list view we'll need to create a navigation link and the navigation links destination is going to be our post list view passing in the selected user id and the label will be exactly what we have if i test this now it all just works perfect but one more thing though when i run this on the simulator i get these constraint warnings showing up in the console and this happens when you embed your views in an unstacked navigation view i think this has to be an xcode bug because i'm using swift ui and not ui kit and i have no idea how i can adjust constraints if you want to suppress these errors you can set a value for user defaults that can suppress the warning so when your user's list view is first instantiated at launch time in the app file we can assign this in the on appear function and i do this again so often that i have another code snippet for this and we set the user default standard value to false for the key which is in quotes this ui constraint based layout log unsatisfiable so you've seen now that i've used three different code snippets so far so if you're interested in code snippets they're very powerful i recommend that you watch this video that i created quite some time ago on creating your own code snippets well we've spent a lot of time so far on this project and we want to make sure that going forward as we make adjustments we can return to a point in time in the past in case we need to rework something and this is known as source control and the most common versioning system for developers is called git and xcode provides us with access to git right from its own source control menu i have an entire series on source control with git and xcode if you're interested in learning more i'll leave a link in the description below all we have to do is select commit from the source control menu and enter a comment as to what stage you are in your project and that's a reference we'll be exploring more source code features in future videos in this series in the next video in this series we'll be finishing up the first part of the series to provide better feedback to our users so that they'll know when our application is actually fetching data so they have to be patient and if there are any errors we can let them know to file a bug report with the developer hi my name is stuart lynch and this is the third of six videos in the ios concurrency series at the end of the second video we had a working application but the user experience was not optimal in this video we're going to improve the user experience by doing two things whenever our app is fetching and loading data we want to present a spinning progress view on top of our view to indicate that the data is loading if an error does occur then we want to know about it so instead of printing the error to the console or doing nothing at all we want to present an alert to our users with that error information and ask them to contact us with that information now if you're just jumping into the start of this series you can download the completed code from the second video in this series from the link in the description below sometimes our users might be on a slow connection so fetching data from a network call might take some time to be retrieved and decoded your user shouldn't be sitting there wondering what's going on you should give them some visual clue that something is happening and swift ui gives us a nice spinner called a progress view that we can use for this so in order to present the progress view we'll need to have some sort of a published property in our view model that we can toggle so in the users list view model create a published property that you can call is loading and set it equal to false that makes it a boolean property then as soon as we start to fetch that data we'll toggle it making it now true now a defer block is used for executing code just before transferring program control outside of the scope that the statement appears in and this means that when the function has completed so inside of our api service class we can create a defer block and the code inside there will be executed after the data is retrieved and processed so what do we want to do when that's done well we want to toggle that is loading again to set it back to false now since that's on a background thread and we are using a published property we'll need to make sure that we get it back onto the main thread and we'll do that again within a dispatchq.main.async block so to display the progress view while it's loading well we can return to the users list view and here we can create an overlay on the list view using the overlay function and the content will be a progress view but we only want to display the progress view if the view model is loading has been set to true if we test this now we'll first need to set our for preview to false to get a real test now i'm on a fast network and i can't really notice that progress view the data loads really quickly even when i try dark mode it's it's not obvious i really can't see it so we can simulate a slow connection here by surrounding our api service call within a dispatchq dot main dot async after block and we can set a delay of say one second so let's test once more now we can see it so let's repeat this then for the post list view model when we're fetching the posts first we'll need a published property called is loading and set it initially to false then we toggle it when we start to fetch our posts and then for our defer block we can just copy it from our user's list view model here and use it inside the get json function similarly we can reuse the code that we created for the users list view overlay here because we use the same property names for the view model and the is loading property so let's make sure that we commit our source code now it looks like some of my assets weren't committed from the last commit that question mark's an indication and i'm not sure what went wrong here but let's select them and make sure that the commit now works to commit those to our repository now we've structured our app so that it doesn't crash when fetching and decoding data it either prints out that decoding error or it just does nothing there's no indication that anything goes wrong and the user has no idea why they're not going to get the data for example let's go to our users list model and add another property one that's going to invalidate the decoding for example let test be string it'll be invalidated because there is no key value pair in the json to correspond to this so when we run this we'll see that case decoding error is printed on the console that's just the case name for our api error that's not any help to our users and it's not really much help to me we want to present something more descriptive for each of these user cases but before i do that let's take away that delay in our fetch request we just did that for testing now if the error was an actual ns error like what happens in our data task or in the decoding routine we can pass along the localized description that's part of that error along to the api error and we can do that by using an enums associated value now i have a whole video on associated values for enum if you're unfamiliar with that concept i recommend that you take a look at it and now that we have an associated value we've got some errors so we have to provide that associative value which is the localized description in the cases of our error here and in the case of this error we can safely unwrap it because it's not nil in the second case the catch block will generate an unwrapped error with its own localized description too so we can use it here but what about these other cases well we can provide our own localized description for each of these cases we've got our own error we can create our own description and the way that you do that is to make sure that your api error conforms to the localized error protocol and this now provides us with a new property called error description and it's an optional string and we can make that into a computed property and switch on self and then allow xcode again to generate the cases for us now for the three without an associated value we can return our own custom localized string we use ns localize string and this accepts a string and a comment now the string is what you want to have as the localized error and the comment is there for your translator should you actually be localizing your app to other languages and this would be another video series entirely i think so since we're not we can just enter a string that makes sense like this one and leave the comment as an empty string we can then copy and paste this into the remaining two cases and we can adjust the string as needed to represent the error for the two that have an associated value already we'll simply return that string which is the associated value that we passed in when we created the error and that's the errors actual localized description so now our error our api error has a localized description for all five cases well now we can use those strings as part of a message in an alert that we can present to the users whenever an error occurs so let's return to the users list view model and prepare for that to present an alert in our view we'll need to provide not only the boolean property to trigger the alert but also the message corresponding to the error that we can put in the alerts message so we'll create a new published property first called show alert and we'll set it initially to false we'll also need to have an optional string property that we can set with our error message when we have an error and this too has to be a published property now whenever we have an error we can set show alert to true and assign our localized error and further information as the alert error message and we need to do this on the main thread because we're changing a published property that will affect the ui so inside a dispatch dispatchqueue.main.async block in users list view then we can attach an alert to our list using the new ios 15 alert type that will have a localized string as the title bound to a boolean for is presented with actions for buttons and a view for our message the title will just be application error is presented is going to be bound to our view model's show alert published property and the action is that button that has a label of ok but no action and when it's tapped swift ui will take care of dismissing the alert then for the message if it's no longer optional we can use the view model's error string as the string for the text view in our message if we test this now we see that our error is displayed great now before we forget let's fix that user model to remove that extra property because we've done a great job here we're not going to get any errors but just in case you do your users are going to see it now let's do the same thing for the post list view model and post list view we can simply copy the code from the two files that we've already done because they'll be identical first the two publish properties then the failure code to trigger the alert and then for the view itself we can copy the whole alert again because we use the same variable names the code will just work well before we forget let's update our source control by issuing a new commit it looks like i missed one of those assets the last time so let's make sure i do it here now all five of our files are updated and that's important because in the next video in this series we're going to branch off of this main branch that we've been working on so that we can take a look at the new concurrency model introduced in ios 15. we still need this branch though because we'll be checking it out again later though and will branch off in another direction when we change our deployment target hi my name is stuart lynch and this is the fourth of six videos in the ios concurrency series at the end of the third video we had our completed application and it was using a result based completion handler for our api services get json function in this video we're going to be implementing the new asynchronous methods introduced in ios 15. this will introduce you to new terms such as async and await main actor and an asynchronous unit of work called the task now if you're just jumping into the start of this series you can download the completed code from the third video in this series from the link in the description below the first thing we should do since we're going to be experimenting with a new feature is create a new branch for our project so that if things go awry we can always roll back to that one that we completed in the last video and that's a fully working app so switch to the source code navigator then select the repositories tab and expand the application you'll notice that the current branch is the one that's called main and if you expand the branches section you'll see it right click on main and choose new branch from main and call it async and await no spaces it should automatically check that branch out and switch to it but if it doesn't like mine doesn't i'll right click on the branch and choose checkout that means i'm leaving the old main branch behind and that code is safe and won't be touched and you'll always know what branch you're on because you'll see that in the title bar now within the api service struct i want to create a new function and i'm going to use the same name and this is going to allow because i'm going to be giving this function different parameters instead of providing a completion handler i'm going to do what i used to do when i knew nothing about asynchronous nature of network calls and in fact i was bitten by this when i first started coding i thought every line of code waited until the previous line of code completed before moving on so i would call get json and then just return my array of objects from the call so i can copy everything except the completion handler from this method then close it off and then return that decodable object which in our case is either an array of user or an array of post but we're using generics so it's just t now this means within my view model i expect to get my array of user or posts back immediately so that i can assign it to my published property and that's what i would have thought well let's try and fix this function up so that we can actually do that let me start the same way as before i'm going to copy the pasted code but since there's no completion handler let's just rule that out and just return now this isn't really good because remember we want to pass that error on up to our calling view so that we can present it to the user in an alert so we can designate this function as being a throwing function one that might throw an error or cause an error and we do that by typing throws before the return then you can throw the error rather than returning and what kind of error do we have we have an invalid url error so we can just throw the api errors invalid url case by designating a function as being a throwing function every time you call the function you're going to have to at some point catch the errors that were thrown by it so this means we'll be passing the error higher up the calling hierarchy this function could have been called by another function that was itself called by another one and at some point then you need to catch and deal with that error or maybe translate that error into a different type of error and that's where a do try catch block comes in and you'll see that in just a second so here's where i ran into a roadblock when i'm fetching from a network it's not asynchronous normally we have to wait until i get that response before i can move on to the decoding the data and this is the equivalent to a completion handler we wait for it to complete processing before we pass it back as the argument for our completion function now though instead of using our previous url sessions data task with url function we're going to use a different version when we start typing urlsession.shared.data i see that there are a number of options and i can scroll down and there are some grayed out ones and the one that i'm looking for is this one here and you'll see why it's grayed out in just a minute we see that it's marked with async throws the throws means what we've just experienced if we run into an error we can throw that error back to the caller but what about async well i'll get to that in just a minute we do see however that it will return both a data and a url response and this function itself has been designated as throwing so here's what i talked about somewhere on down the chain we have a throwing function and we're going to have to deal with it at some point so let's deal with it here and convert that error into our own api error so we'll catch that error and then pass it on up to our caller now the delegate is optional so we can remove that and the url is just our url so let's just use it remember that function does return data and response so we'll create a tuple of our own to assign those return values now xcode is going to help us here it generates an error and it says that this function can throw but it's not marked with try so anytime a function throws you have to use try so that url session function it was a throwing function so we'll have to try now this creates a new error which is the async call in a function does not support concurrency and that's when our function was designated as an async throwing function and this is new for us it means that that get json function needs to support concurrency so we'll need to have to go back up to where we define our function and make it an async throwing function now we're not out of the water yet though because we're told now that the expression is async but it's not marked with a weight and that's because the function is an asynchronous one and we have no idea how long it's going to take for our data and response to come back so we must wait for it before we move on in our code and we do this by specifying that we await for that tuple before assigning it to our constant and the order matters we first try and then we await for the result from our call now what if that data from the url function actually produces an error that try through an error well by using a simple try we're saying that we want the error to bubble up to whatever viewmodel is calling that function but i want to handle all my errors here in the same way right here in this function so i'm going to catch that error and change it to one of my ati error types and throw it so for this what i'll do is use a do catch block and in the catch block then i can throw our api services api error which is the data task error case and it needs an associated value which is the localized description of the error that that one level up through so now we have data and response so we can check exactly the same way as we did before first for the response we need to check that it's a code of 200 or throw so we can do this inside a do catch block just like we did before only we have a completion handler to pass our under error with we don't have one anymore so instead we're just going to throw an api error which is the case in valid response status still within the do block we have that data and the data task error will have thrown an error there been one so now we can decode and return the decoded data now unless there is an error decoding data in which case again no completion handler we'll need to throw the decoding error using that errors localized description as the associated value for our api error type well that's it we're done our app would still build and run because we're still calling that original function though i haven't deleted it at least not yet let's return now to our users list view model and change that call we'll still need that instance of api service and the is loading toggle function but this get json function needs to be commented out for now but i'll keep it here just for reference instead we can use our new api service get json function now we know that it's going to return our user so let's assign the return value to users and we'll call that function now notice there are two of them we want the async throws one now this generates an error call can throw but it's not marked with try and the error is not handled in fact the order in which the arrow occurs as there are going to be three of them may be different from you but the errors are the same as we saw earlier first we'll need a try and we'll need to designate that function as being asynchronous then we'll need to await the result but we're at the end of the line now if we encountered any errors we'll need to set our show alert to true and set the error message so that the localized description is used for the message body so we can do that do catch block right now to handle that well we're going to do it the same way that we did before by setting the show error alert to true and setting the error message to that errors localized description and we don't even need self we no longer need this commented out code here for reference so let's just delete it our is loading property has been toggled to true but we've never turned it off well since this entire function is asynchronous we can place our defer block right after it and it won't be toggled or called if the execution is going to be deferred until the function exits its scope so we can just use defer is loading toggle right after we assign it isn't this nice and clean so much easier to read and follow now users is a published property and this function is executing on a background thread so we'll get that severe warning if we don't do something to fix that and set it back on the main thread if i try to enclose this with a dispatchq.main.async block i get an error in swift 5.5 there is a new attribute called main actor that we can use to decorate the entire function and it will then dispatch this task onto the main thread when we build we get an error though in the users list view because it's now calling that new get users function and that's an asynchronous function so what we have to do is make sure that our on appear is asynchronous and so what we can do is we can within that on appear function create an asynchronous unit of work which we'll call a task and since that's asynchronous we need to await the result no try here though because we've caught any errors back in that fetch users function well in ios 15 we can go one step further than this we can combine both on appear and task into a new asynchronous task method that adds an asynchronous task to perform when this view appears this code is much easier to follow and work with when i make that call to fetch users i'm either going to be successful or it'll throw an error if successful we assign the decoded data to our published property since this is our calling point of our throwing functions we need to deal with any errors that were thrown earlier in the process and therefore the do catch block it all compiles properly now no errors but our posts are still using that old api service get json function so we want to fix that before we can remove it so let's do that let's return to the users list view model and we'll copy everything from the defer on down then in post list view in the fetch post function will replace the old get json function with this new code we just have to change our users to posts it's complaining however because it's an async call in a function that doesn't support concurrency remember anytime we've got concurrency we need to specify that our function is asynchronous and also don't forget that we need to dispatch that task back onto the main queue so we decorate the function with the main actor attribute this requires one more change in the post list view as well because we are now calling an asynchronous task so we'll need to create that unit of work which means we'll change appear to task and then await the return of our posts we can test now in the simulator and we'll see that it all works just as before but with much more readable code after having done all of that work we want to make sure that you commit the changes to your git repository this is so much cleaner now in the fifth video in this series we're going to take this even further we are currently fetching all of our users at once and then at one at a time we're fetching an individual user's post as needed and we'll do that every time that we click on one of the rows in our users list that's a lot of network calls if we're viewing a lot of different users posts so what we'll do in the next video is retrieve all of the users and all of the posts in parallel so that they're all in memory and then filter the posts for each individual user as we need them a maximum of two network calls anytime we launch our application hi my name is stuart 9chan this is the fifth of six videos in the ios concurrency series by the end of the fourth video we had converted our get json function into one that uses the new async and away concurrency method introduced in ios 15. in this video we're going to extend that even further by introducing you to parallel asynchronous concurrency using asynclet we'll create a new model to contain a user and all of that user's posts in an array and use that model after fetching all users and posts up front in two asynchronous calls in parallel when the user's list loads thus potentially reducing the number of network requests now if you're just jumping into the start of this series you can download the completed code from the fourth video of this series from the link in the description below now that we have much more easily readable code i want to show you where this really shines let's create a new experimental branch on this current branch so make sure you select the source control navigator then right click on async and await and create a new branch from here and call it parallel concurrency and make sure you check out that branch if it's not done automatically what i'd like to do now is to fetch all of our users and all the posts before presenting the list view and add a count of the number of posts per user alongside their name in the users list view then since i have all of the users posts i can pass them on to the post list view for that user instead of when i get there this should limit the number of server requests to 2 then no matter how many times i go from users to posts so to do this i'm going to need a new model that we can use to consolidate this information in the models folder create a new swift file called user and posts and in there create a struct with the same name i'm going to be using this in the users list view so i want to to conform to the identifiable protocol we'll need an id property to make sure that it does conform to that protocol so to make it easy let's just create one and we'll use the uuid now each object will contain a user and that user's posts so the user will be of type user and posts will be an array of post i do want one more thing though and that is the number of posts so that i can display it so i can create a computed property for this called number of posts and it will be an int that returns the post count in the users listview model right now we have a single function that fetches users what if after we fetch users then we fetch all of the posts and then run a loop through our users filtering the posts by id and then assigning them to that user so let's change this publish property here to no longer be an array of user but an array of user and posts of course this is going to break our code because we no longer have that published user property but we still have to keep track of them until we build our now empty user and posts array so let's just preface this with a let to create a constant users containing the array of fetched users but this is a new property and users won't know what it's expecting to retrieve so we'll need to specify that it expects an array of user this convenient init no longer uses any users and we've not set up any in our mock data for our new users and posts so let's just comment this out for now so how do we get all posts well the url for that can be found in the api documentation and we put that endpoint url as a comment at the top of our post struct so we'll copy that now and we'll create a new instance of the api service passing in that endpoint then we can asynchronously fetch all of the posts the same way that we fetched all of our users but this time for posts and it's an array of post now if we had to do this with our old callback method we'd be in a little bit of trouble since we would need to have nested these requests within an api service get json callback function with a completion handler here the power of async and await really shines this fetch post request won't be executed until the above one has completed so it looks almost synchronous well now that we have both users and posts we can loop on users and then we can determine that particular user's post by filtering the posts array where the user id is equal to the user id and we can use the array filter operation for this and using a higher order function really condenses your code and if you're familiar with the syntax it's quite easy to read if you are unfamiliar with this you can check out my video on higher order functions and this one here in particular includes the filter function well now that we have a user in all of her posts we can create a new user and posts so we can pass in the user and all of our posts and then we can append it to our users in posts publish property users in list view of course is broken because we no longer have an array of users we have an array of user and posts so in the navigation link we no longer are going to pass in the user id we want to pass the entire array so we'll just have to fix the post list view as well in a minute so for now let's just change this to post list view posts being user and posts dot posts for the label we'll need to change this to user and post dot user to access the user's name and the user's email properties i also mentioned we want to display the number of posts so we can do that right here by embedding the name text view in an h stack and then after the name we'll add a spacer and then present another text view with the computed property of the number of posts from our model and use string interpolation to surround the number with brackets all we have to do now is fix up that post list view now instead of having to create a view model i can remove this state object altogether we're not expecting a user id anymore we're expecting an array of post since our posts are no longer in a view model we can remove the vm there will no longer be a need for the alert here because we're not going to be fetching anything here and we can also remove the overlay and the task now our preview is complaining here so we'll need to fix that which means that we'll need more mock data but we'll come back to that for the moment let's just comment the preview out here i'm still getting an error when i want to build uh yeah i see i forgot that i commented out that convenience initializer so it no longer exists so i need to remove it here when we initialize if we test this in the simulator now it works and we see the number of posts besides each user it just so happens that this api actually has 10 posts per user but trust me if the count were different per user this would still work so let's fix that mock data for our preview we can create a new extension in our mock data file for user and posts and then create a static computed property that's called users and posts that is an array of our new user and posts object so we then repeat the same process that we did when we are in our users view model we'll create an empty array of new user and posts and then we'll loop through our mock users from the user model will create a new user and post filtering the post mock posts to get just the posts for that particular user and then we'll append it to that new user and post array and once the loop is completed we can return the new users and posts back then to the users list view model we can fix that extension so that users and posts is user and posts mock users and posts and then in the post list view then we can uncomment the preview to change that argument to posts and pass in the post mock single users post array and then back in the user's list view we could add back that convenience initializer because we have it again and whether we are in the preview mode or not we can decide if we want to see that mock data in the canvas when it's set to true if it's set to false it disappears if we go back and check out our code and however there is something that can be improved on even more we're fetching all of our users and then waiting until they're all fetched before we fetch all of the posts the fetching of the posts is not reliant on the fetching of users in fact we could be doing this in parallel well welcome to asynclet we can simply preface each of our api service calls with async so that it now reads async lat now this creates errors in our for loop because we'll need to wait for them to have finished first before carrying on before we can access both the users and posts so we'll need to try and await for both and we can do that by assigning them to a new variable but as i said we'll have to await for both of them so let fetched users fetch posts in the tuple await for the users and posts but as i said these are failing because we'll have to try for each of them then all we need to do in our loop is to change user to fetch users and posts to fetch posts we're now getting both the users and posts at the same time and then we can then run our loop testing now we see that it all works nicely and we're now saving on costly network calls let's finish now then by committing this branch to our git repository in the final video of this series we'll be checking out that old main branch again and branching off of it to change our target back to ios 14 and see if we can use these new asynchronous functions in an earlier ios this is what's promised in xcode 13.2 hi my name is stuart lynch and this is the sixth and final video in the ios swift concurrency series in this video we're going to see if we can apply the new ios asynchronous concurrency methods to an xcode project with a target of ios 14. this will require xcode 13.2 or later and it wasn't until xcode 13.2 that apple backported some of these features to targets of ios 13 or earlier if you're just jumping into the start of this series you can download the completed code from the fifth video in this series from the link in the description below with xcode 13.2 some of the new concurrency features have been backported to ios 13. and this is great news because perhaps we realize that by setting our target to ios 15 only we're missing out on a lot of users who have not upgraded their phones we're currently using some ios 15 specific apis that we'll no longer be able to use but i would really like to use this new asynchronous concurrency model as we're testing again let's create a new branch by now this should be familiar to you select the source code navigator and then right click on the main branch to check it out notice that it is now the active branch and we're going to branch off of this one right here so we'll right click and create a new branch and i'll call it back port this time it created the branch and it checked it out all at the same time so now it's my current active branch that i can work on now this get json function in our api service is the completion handler version of our function and it doesn't use the new async and await concurrency methods that were introduced in ios 15. in videos four and five of this series we changed that to use these new methods now if you've updated your xcode to version 13.2 you should now be able to take advantage of those new features and projects for targeting earlier versions of ios and this is one of the terms target applies switch the application and you'll see both project and target the target in this sense means which of the apple sdks am i developing for is it mac os ios ipad os is it a widget kit application or one of many others if you click on the target and then on the general tab there is a deployment info section and here you get to see what the ios deployment target is and in my case here it's set to ios 15.2 this means that in order to install and run this application on your device it has to be running ios version 15.2 or higher and those who haven't upgraded yet can't run your application as i said you potentially may be losing out on a lot of customers in most cases the swift ui going back to ios 14 from ios 15 requires only minor changes depending on what apis you've implemented and we'll see that shortly going back to ios 13 is a little bit more problematic because there are more deprecated methods so i'm going to take the less troublesome path and change my target back to ios 14 and see what happens and what's going to be required when we build we get several errors and these errors are all saying that a particular api that we're using is only available in ios 15 and newer the overlay and alert apis we use in our code have changed since ios 14. so we're going to have to revert back to the deprecated versions that were available to us then it's important to note that deprecated doesn't mean that we are playing with fire there are many deprecated apis that have been around for many many years so there's no need to panic at some point however in the future though when you change your target back to ios 15 or higher you should change the code again to remove the deprecated versions if i click on one of the overlay errors it takes us to that culprit if you option click in the overlay error in users list view we get the quick help and if we scroll down further we see open in documentation so let's do that and we'll see that it's available from ios 15 on i know that there's an ios 14 version however because i use it and it doesn't put our view into this trailing closure rather overlay didn't use a closure at all so let's remove it now the error here is hard to decipher but if we enclose our clause here in a group the error goes away but we can repeat that in the post list view too so we'll do the same thing we'll remove the closure and embed it within a group let's check out the alert and option click and then drill down into the documentation i can see that it too is ios 15 on only now if i search through the documentation and click on the alert that's found i'm taken to another alert and i see that it's been available since ios 13 but that has been deprecated it may take several releases for it to actually disappear and by that time hopefully you've updated your code to use the more modern apis we can see that this documentation is within a section called deprecated views and controls scrolling down we can see the different initializers that were available to us if we remove this code now we can start typing dot alert and if we take a look at the options we can scroll down and we'll see the two earlier versions and they are marked in gray that's an indication that they're deprecated or not available to us however we can make them available to us let's choose the is presented version and it needs to be bound to something which is our view models show error alert inside the content closure we'll need to use what is known as an alert object and there are a number of options here the one we want is the one with title message both being text views and an optional dismiss button for the title we can use a text view and we'll just say application error for the message we can use another text view with our view models error message but it's optional so we'll no coalesce it with an empty string and we don't need the dismiss button because as i mentioned it's optional so we can just remove it we can repeat this process for the user's list view and i happen to know that the ad alert is exactly the same so we'll just copy it here and paste it or replace it with the same version if we build now there are no errors great but we really haven't gained anything what you have now is a project that you could have originally coded using xcode 12 under ios 14. if you want to go back to ios 13 you'd have to do more things like changing the navigation title to a navigation bar title you couldn't use state object and there's probably a host of others so i'm going to stop here but you can go back as far as ios 13 with swift ui the observant of you will notice that the list style is not complaining about my using dot plane instead of using the full instance of plane list style struct that we had to do in xcode 12 and it appears that the new style options have been backboarded so we don't need to do anything to change them well with xcode 13.2 we learned that the new concurrency methods have been backboarded as far back as ios 13. so if we want to update your api fetches to use this new asynchronous version of the url session data method we're going to have to implement those new features and this should greatly clean up our code well it turns out that although swift 5.5 new concurrency system is becoming backward compatible in xcode 13.2 some of the builtin apis that make use of these concurrency features are still only available on ios 15. mac os monterey and the rest of apple's 2021 operating systems the good news however is that we are provided with another method that we haven't looked at yet and it's a continuation mechanism that lets us retrofit existing code with async await support and what also is good news is that xcode gives us some assistance here if you command click on the function name for our existing completion handler version of get json you get three different options for converting this function to an asynchronous version and all three will work but we really would like to understand this so i can code in the future from the getgo so let's explore the options and we'll start from the bottom up if i choose this method it simply creates a new function that has the same first two parameters but instead of a completion handler it's an asynchronous throwing function just like our new one that we created in videos four and five no error then calling the new function yet json because as we saw in video four we can have two functions with the same name so long as the function parameters are different what this does use is the with checked throwing continuation that calls our old completion handler function and then essentially maps the continuation into an asynchronous one that's pretty cool but now i have two functions to clutter my code and our viewmodels are still calling the older version with the completion handler and not this version so let's just undo this and take a look at our second one if we choose this one it basically does the same thing as we saw in the previous example but it makes all of the same changes in line in the asynchronous version of our function with the use of the checked throwing continuation block and adds continuation resume for each of the result enum cases now the errors we're getting here are all related to the function now not recognizing the api error case since it's not specified in our function parameters and we can fix that by prepending all of the cases with api error and by removing any unnecessary returns still i have two functions to deal with and our viewmodels are still calling this older version with the completion handler and not this version so let's undo once more let's go all in now then and convert our function completely so that we only have a single function to deal with and that's what this first option will do for us well we'll need to fix those return and errors for not knowing what type the error is still just like we did in the last version the errors in this file all go away now but when i build i get four errors well why is that well it's because now i'm trying to call that old completion handler version that we had before and it's no longer here so let's fix that and this will be a repeat of what we basically did in video 4 when we created the async function from scratch in ios 15. in users list view model then let's remove from the fetch users function everything except the first two lines because we are going to need an instance of the api service and we want to set is loading to true but remember we can now use a defer block right within our function so after is loading dot toggle we'll add the defer block then we can simply create a do catch block and then within the do block we can try and await the return from the api service get json function and assign it to our users and we can fix the error because we need to specify that our function get json is now an asynchronous function in the catch block we can set show error to true and then set our error message with the errors localized description and that contact information and then we have to decorate the function with app main actor to ensure that the function is dispatched back on the main cube well we can copy everything from defer on down here and then go to the post list view model and replace the corresponding part of the get post function with this same content updating of course users to posts specifying that the fetch post function is asynchronous and adding the app main actor to make sure that we get executed on the main thread again we have a couple of errors left though and those are in our views and that's because in on appear we're trying to call a asynchronous function well we can't use dot task as we did in ios 15. it's one of those things that didn't get backboarded however you may recall that there's another option we can use a unit of asynchronous work called a task so we can embed within the on appear our content inside a task and await the fetching of the json finally then we can go to the post list view and do exactly the same thing for on appear we can enclose our actions in an asynchronous task and then await the fetching of the posts we can build and run now and all errors will disappear and our application runs we have successfully backported our application to run under ios 14 using the new asynchronous methods before we ship the app though make sure that you'll check any warnings the app is giving you like this one here that we left for ourself to make sure that the four previews is set to false now the last thing i'm going to do is commit any changes to our local git repository well that's it thanks for joining me on this six part journey and i hope that you've learned some useful and transferable skills i want to thank chris for inviting me to add content to his channel and i look forward to being able to contribute more in the future thanks for watching
