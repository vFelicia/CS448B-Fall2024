With timestamps:

00:00 - In this video, I'll show you how to read
and write data to your Cloud Firestore
00:04 - database by now, you should have set up
your Firebase Project, your Xcode project,
00:08 - and added the Firebase SDK
to your Xcode project.
00:12 - And if you haven't done that already,
don't worry, because that's what we
00:15 - covered in the last week's video,
which you can find right over there.
00:18 - Hey, Code crew, my name is Chris,
and if you're new here, welcome.
00:21 - I've been teaching Beginners how
to code and build app since 2013.
00:25 - So if that's what you want to do,
you're in the right place.
00:27 - If you're just starting out and check out
00:29 - our 14 day Beginner
challenge right over here.
00:31 - We have a community full of people
going through the same thing right now.
00:35 - All right, with that said,
let's dive in today's topic.
00:39 - All right.
00:40 - So here we're looking at our
empty Cloud Firestore database.
00:44 - In the last lesson we had set up this
00:46 - Firebase project,
initialize this database,
00:48 - and we have picked the server location
where this database is going to be stored.
00:53 - And essentially, that's where we left off.
00:56 - So before we can dive into reading
00:58 - and writing data updating and deleting
and all that fun stuff,
01:01 - we have to first understand how our data
is being stored inside this database.
01:05 - In order to understand that there are only
01:07 - two terms which you really need
to understand document and collection.
01:12 - So the data that you want to store
is organized into documents.
01:15 - And then a collection is simply
a collection of documents.
01:20 - And then finally, inside each document is
01:23 - where your actual pieces of data are
stored, and the format that that data is
01:28 - stored in inside
a document goes like this.
01:31 - Each piece of data has a label,
01:33 - it has a data type, and it has the value,
which is the actual piece of data.
01:38 - So perhaps the easiest way to understand
it is visually by starting to do it.
01:43 - So let's go ahead and click
this Start collection button.
01:47 - Essentially, we are creating a folder,
name or folder to contain documents.
01:53 - So let's give this collection an ID
01:56 - in the demo for this video, we are doing
a sample sort of like a small todo list.
02:02 - Each document is going
to represent a Todo item.
02:05 - So I'm going to give this collection
02:08 - I'm going to call it to do because it's
going to contain all the to do documents.
02:15 - So I'm going to call that.
02:16 - Let's click on next.
02:17 - The example that they give here is,
for example, if people can create user
02:21 - accounts in your app,
you might have a user's collection.
02:25 - And inside that collection,
each document would represent a user.
02:29 - And then inside each user document would
02:31 - contain all of the individual
pieces of data for that user.
02:36 - So let's click on next.
02:38 - And here we are going to add the first
document within the troduce.
02:42 - You can either manually specify the ID.
02:46 - Keep in mind, this has to be unique.
02:48 - So I'm just going to hit auto ID.
02:49 - It's going to generate that for us.
02:51 - And within this document right here
02:54 - these are going to be
the actual pieces of data.
02:57 - Remember what I said before?
02:59 - Each piece of data contains three parts,
03:02 - the label, the data type
and the actual value.
03:05 - So for this
document that represents a todo item,
03:09 - I might put maybe the task or
maybe let's just call it name.
03:15 - And this is probably what
the user would type in.
03:17 - Go buy groceries.
03:20 - And this is the data type
for the value that you want to store.
03:24 - String is text.
03:26 - And there's different types you can put.
03:28 - Now you can have one field,
you can have multiple.
03:31 - So I'm going to hit add field again to add
03:33 - a second one and this one I'll call it
notes, because maybe when we let the user
03:38 - add to item, we'll also let them put
in some notes here I'll say maybe
03:45 - go with ten or something
like that I had saved.
03:52 - There you go.
We have our first collection.
03:55 - And within this collection we have
03:57 - a single document
inside that single document.
04:00 - We have the actual pieces of data so you
can see the field name or the label,
04:06 - whatever you want to call it
along with its associated data.
04:09 - Let's go ahead and try a second document.
04:12 - Let's go hit add document and this is
04:14 - going to be added inside
our two Duce collection.
04:17 - Go auto ID again.
04:19 - And here's the interesting thing.
04:21 - I don't have to put the same fields
as I did for the earlier document.
04:25 - I could have completely different fields,
04:27 - completely different data types,
completely different data.
04:30 - It's just going to make it a little
tougher when you retrieve that data.
04:33 - If each document is completely different,
04:37 - then you're going to have to add
the appropriate logic in your app
04:41 - to identify that and to react
accordingly to keep things organized.
04:46 - I'm going to have the same fields.
04:48 - So I'll have the name string and this
one maybe like go to the gym.
04:54 - And again we add another one
and we'll keep it simple.
05:00 - Maybe
05:01 - this one leg workout.
Save it.
05:03 - Alright.
So now we have two documents.
05:06 - You can see that the data is inside each
05:08 - document and these documents are
inside the troduce collection.
05:13 - So here's a simple data structure
05:17 - with some sample data which we can start
05:19 - working with inside Xcode
before we leave here.
05:23 - I
05:24 - do want to note that inside each document
you have the ability to start
05:29 - subcollections, which can contain
sub documents or just documents.
05:35 - But essentially this chain can go on.
05:38 - So you can have a collection of documents.
05:41 - A document can have, you know,
05:43 - a sub collection within that document
which could contain documents,
05:47 - and those documents could have
subcollections inside them.
05:52 - And the chain can go on.
05:54 - So this is how the information is
organized in your cloud Firestore.
05:58 - These are your root
collections right here.
06:01 - So we're going to leave it
at this level right now.
06:04 - We're not going to do any subcollections
06:06 - and go, well, fancy, this will
be enough for our demonstration.
06:10 - And now let's jump into Xcode and see
how we can work with this data.
06:14 - All right.
06:15 - So let's take a quick walk through
of this demo Xcode project that I set up.
06:19 - And actually we started setting this up
06:21 - in the previous lesson in part one,
where we set up Firestore.
06:25 - We had created this Xcode project
and imported the Firebase SDK.
06:31 - Now what I've added since
then is simply a view model.
06:37 - And this view model is
an observable object.
06:41 - And so far it contains a list of strings.
06:45 - It's just an array of three string items.
06:48 - And what's happening in the view right
06:50 - here is I've got a list element,
and it is.
06:55 - It is observing
06:57 - the list property of the model,
and it's reading that and it's displaying
07:03 - each of the items in that array
in a list component.
07:07 - Now, what we're going to attempt to do
07:09 - instead of using these hard coded items
is to fetch the data from our database.
07:16 - So instead of Apple,
banana and Orange or whatever I had,
07:20 - we want to say go to the gym
and go buy groceries.
07:23 - Essentially want to list
the names of these two two items.
07:27 - First of all, though, we need to create
some sort of data model inside of our
07:32 - Xcode to represent these data items,
because as it stands right now,
07:39 - even if we fetch that data from Firestore
database, how would we represent them?
07:45 - How would we organize that data?
07:47 - So what we're going to do
is create a struct.
07:50 - So I already organized these things to
07:53 - create a couple of folders for views,
view models and models.
07:56 - This would be a data model to represent
07:58 - the data or to model the data
that we want to display.
08:02 - Let's go new file,
08:04 - choose under iOS, choose Swift
and we're going to call this a to do.
08:09 - So this is going to like an instance
08:12 - of this struct is going
to represent a single to do.
08:15 - And typically what you want to do
08:18 - is just mimic to mirror the properties
that you have inside your database.
08:25 - So for each to do item,
you can see we have a name and we have
08:29 - a note and the data type
for these or strings.
08:32 - So I'm just going to mirror it here.
08:35 - Name is a string
and also notes is a string.
08:42 - The other thing that we want to capture is
08:45 - the document ID,
because when we go to let's say update
08:50 - the data in this document or to delete it,
even we're going to need that ID.
08:55 - So we're actually going to capture
it in the property up here.
08:59 - And that's also strong.
09:01 - And because we're going to want to display
09:07 - a list of these to do items
inside a Swift UI list component like
09:13 - this, what we can do to make our lives
easier is have this conform
09:18 - to identifiable, and that means
you just need an ID property here.
09:24 - And then when we display
that list of to do,
09:28 - we're not going to have to specify
that ID parameter, but we'll get to that.
09:32 - Okay.
So what we've done here is we've created
09:36 - a struct to do that represents our
documents to do documents right here.
09:43 - Next, what we're going to do is go back
to the View model and change this list
09:49 - right here instead of an
array of these strings.
09:53 - I want this to be an array of our
to do items, and I'm going to create
09:58 - an empty array that is
going to contain that.
10:02 - Because what we're going to do now is
10:04 - create a function or write a function
that is going to go and fetch the data
10:10 - items when it comes back
to then store on this list.
10:14 - And because this is a published property,
it's going to the View code that we have
10:22 - here in Content View is going to pick up
that change, and it's going to then update
10:27 - visually what you see
in the user interface.
10:32 - So let's go back to the View model.
10:34 - Let's write a function.
10:36 - We'll call it Get data,
10:40 - and let's take a look
at how we can do this.
10:42 - First thing you want to do is import
10:45 - Firebase so you can use those Firebase
libraries in the Firebase SDK.
10:50 - I want to get a reference to the
database and read the documents
11:00 - at a specificAPI.
11:06 - So this part is easy.
11:07 - We're gonna create a constant called DB,
and then the Firestore class actually has
11:14 - a static method called Firestore,
which returns
11:18 - the instance to us or the reference
to that object that we're going to use
11:23 - to interact with our database right
now that you have a reference to it.
11:28 - Let's use it.
So DBT collection and this lets you
11:33 - specify which collection
you want to access for us.
11:36 - It's going to be to do so
11:38 - that's what we're going to put
right here as a string.
11:42 - And then next you could do several
different things from here.
11:45 - You could create a new document
within that collection.
11:48 - You can remove a specific document.
11:51 - But what we want to do is fetch all
11:53 - the documents inside this collection,
and there is a method to do just that.
11:57 - It's called Get documents.
12:00 - We're going to use this one right
here with a completion handler.
12:04 - And if we double click this,
it's going to open up that closure
12:08 - that gets executed when
the database call comes back.
12:13 - So this is going to perform that query,
12:16 - grab all the documents
from the Todo's collection.
12:19 - It's going to come back and run this block
of code right here,
12:22 - which you can customize note these two
parameters, which are optional parameters.
12:29 - These could be nil.
12:31 - Any errors that happened will be stored
in this parameter,
12:35 - and the actual documents
that come back from this query are going
12:40 - to be stored in this snapshot parameter
in a property called documents.
12:45 - So let's go ahead and try that out.
First.
12:47 - Of all, I'm going to give
these two parameters a name,
12:52 - snapshot and error.
12:55 - We're going to want
to check for error first.
13:00 - And this way, if there is an error,
we probably want to show that in the UI
13:03 - tell the user didn't work,
try it again later or handle it some way.
13:08 - So if error is
13:12 - no, that means there are no errors, right.
13:16 - Errors
13:18 - or otherwise,
you're going to want to handle the error.
13:24 - Okay.
13:27 - So if there are no errors,
what we're going to want to do next is
13:30 - make sure that snapshot isn't
mill because this was optional.
13:33 - Right.
13:33 - So we're going to say
if that snapshot equals snapshot,
13:39 - that's going to let us use
the same parameter name.
13:42 - And while making sure that that isn't
mill, we're going to want to get all
13:47 - the documents and create to do to do
essentially instances of this struct.
13:57 - Okay.
So like I mentioned inside snapshot,
14:01 - there is a documents property, and this
is an array of all of the documents.
14:08 - This is going to be a dictionary where
14:12 - the keys are the fields right here
in the values are this right here.
14:18 - So I'll show you how to extract that data
14:20 - out from each document and put it
into an instance of it to do
14:25 - so, one way you could do this
is you can use a for loop.
14:28 - You can say for document in snapshot,
documents and side here you can
14:35 - create each to do,
but you can also do it this way.
14:40 - So snapshot do
14:42 - documents, dot map, and then let's
open that up into a closure.
14:50 - And then here you can put let's see.
14:56 - Maybe you put D for document and here
14:59 - essentially gives you a chance to
transform each document into to do so.
15:06 - This map function
15:08 - basically iterates through that array,
and it performs this Xcode on each of the
15:16 - items, and then return that result
to you in a collection.
15:20 - So for each document inside documents,
15:23 - we are going to instead return a new to do
if that's what we want to change it to.
15:28 - Right.
And in order to create it to do,
15:31 - we need to supply three pieces
of information, the ID,
15:34 - which is going to be the document ID,
the name and the notes.
15:38 - So let's go ahead and put do document ID.
15:42 - So this is a special property
15:45 - of the document, and that is going
to be that document ID right there.
15:50 - But for these pieces of data inside
15:53 - the document, we need to use
it as a dictionary to extract that.
15:58 - So it's going to be and we're
going to specify the field name.
16:04 - So in this case it is a name.
16:07 - It doesn't know what data type it is.
16:09 - So we have to cast it.
16:11 - So we're going to say cast it as a string.
16:14 - If, for example, it's missing,
maybe it's Nill.
16:17 - We are going to use the no coalescing
operator, the double question Mark here.
16:22 - So if it can find this,
16:26 - if I can't find this this key value,
16:30 - pair this field and value it is going
to put an empty string instead.
16:36 - So for notes, we're going
to do the same thing.
16:39 - No, we're going to try
to turn that into a string.
16:42 - If that doesn't work, we're going
to put empty strings like that.
16:47 - So essentially for each document,
16:50 - it is going to return a todo item
with the information from that document.
16:57 - And then here because it's going
to return an array of information.
17:02 - Right.
17:02 - We are just going to assign the result
to list right there.
17:06 - Okay.
So self dot list
17:10 - equals that list right there.
17:13 - Right.
17:14 - So yeah, doing that is going to update
17:19 - this publish property,
which is going to cause the code in here
17:23 - to detect that change in model list,
and it's going to change the UI.
17:29 - But do note that this is
happening in a background thread.
17:33 - So when you send out that request
to the server or the database to get
17:37 - that data back, it's happening in the
background and when from the background.
17:42 - When we run this code,
it's going to cause a UI change.
17:46 - Whenever that happens, we don't want to do
that sort of work in a background thread.
17:50 - We want to do the it foreground.
17:52 - And so since at the time of this recording
17:55 - we're still using Iowa 14,
we are going to use the dispatch queue
18:00 - to put this back on the main thread.
18:03 - So dispatch Q dot main dot async
18:14 - update the property, the main thread
since it causes UI changes, and then
18:24 - create a todo item for each
document returned.
18:31 - Alright.
18:32 - So let's give this a try.
18:34 - We're going to go back to Content view,
and then we're going
18:40 - on the initialization of this view.
18:44 - We are going to say model dot get data.
18:48 - Okay.
18:49 - And since
18:51 - this list property is now an array of to
18:55 - do items, we have to display the name,
19:03 - item name and we can get rid of this ID
19:06 - property since the two
destructive identifiable.
19:11 - And let's run this in the simulator.
19:16 - See what happens now.
19:18 - There are a couple of things
I'm glossing over.
19:20 - If you know, keywords like identifiable is
19:23 - is foreign to you,
then you definitely want to check out our
19:27 - Beginner series and maybe even
our Swift UI foundation course.
19:31 - Alright.
Perfect.
19:33 - So from here you can see that it
hit our Firestore database.
19:37 - It's fetched the two documents and it has
put them into the list right here.
19:45 - And our View has captured that and updated
what is visible to the user.
19:52 - Next, let's take a look at adding
items into the database.
19:57 - So we're going to add a couple of text
fields down here with a button to just
20:01 - insert some todo items
into this to do collection.
20:05 - So first of all, go into the View model
20:11 - and I'll show you what the code looks like
before we even get to modifying the UI.
20:16 - So up here let's say
20:20 - add data and we're going to pass in two
pieces of information,
20:26 - the name of the to do and also any
potential notes for them to do so.
20:31 - I'm going to say
20:33 - name, string, note, string.
20:38 - And then once again,
we get a reference to the database.
20:45 - And then we add a document
to a collection.
20:50 - So this is just like we
did before Firestore,
20:57 - Firestore, Firestore.
21:00 - And then down here we use
that reference DV DT.
21:04 - Well, first of all, specify the collection
21:06 - so that we can indicate which collection
we want to add a new document to.
21:10 - This is going to be to do.
21:12 - And we're going to say add document.
21:15 - Now there are two different ones.
21:16 - This one is just add the document and you
don't really care about what happens next.
21:23 - And the other one which we're going to use
21:26 - has an extra parameter that executes when
the call comes back from the server.
21:34 - So this parameter is the data that we are
21:37 - putting into the document, and this one is
the code that we want to run afterwards.
21:43 - So first of all, let's take a look
at what data we want to send.
21:46 - We're not going to have to worry about
21:48 - the ID here because that's
automatically going to be generated.
21:52 - This dictionary
21:54 - is going to be representing
the data inside the document.
21:59 - Right.
So we're going to specify a name key,
22:02 - passing the data there and in notes,
key and passing the notes data.
22:07 - So again, this is going
to be a dictionary.
22:10 - And first of all, we're going to put name
and followed by the value.
22:16 - This is how you specify a key value pair
for a dictionary and we're going to pass
22:20 - in name, which is what is what we're
going to pass into this method.
22:25 - Okay.
22:27 - The next key value pair notes
22:32 - followed by that parameter notes.
22:34 - And then for this completion, Hamo,
double click it to open closure.
22:38 - And it only has one
parameter called error.
22:42 - And this is to let us know if there was
22:45 - any error in creating
that document and adding the data.
22:48 - So here let's
22:51 - check for errors if error is nil, right.
22:56 - No errors.
22:59 - So this shouldn't be a comment.
23:03 - Handle the error in here.
23:06 - This is going to be
if there are no errors,
23:09 - we want to fetch the data again so
that we grab that latest to do item.
23:15 - So I'm just going to call
23:17 - self dot get data from here.
23:27 - And this is going to cause this to run,
23:30 - which is then going to grab all
the documents in the deduce collection,
23:34 - and it's going to dispatch the result
into the main thread to update the UI.
23:43 - Alright.
23:44 - And that's how simple it is to add a new
document into a collection and the UI.
23:51 - We're going to want to
add some text fields.
23:54 - So first of all, we're going to have two
23:57 - text fields, one to write the name of them
to do, and the other to write the notes
24:01 - for this to do so, and to specify
two state properties here.
24:04 - So we can capture that data from the user
24:08 - or
24:10 - name or notes.
24:13 - And what we're going to do is we're
going to put this list into a stack.
24:24 - Alright.
24:25 - And then we're going
to have a divider here
24:29 - followed by another V SDK,
but two text field field name
24:40 - and we're going to bind it to this
state property here.
24:44 - So whatever the user types in, it's
going to be captured in that property.
24:48 - So in order to specify binding,
we use the dollar sign.
24:52 - I have another text field
24:57 - notes.
25:02 - Right.
25:03 - But these text fields by default,
25:06 - the style for them is
it doesn't have an outline.
25:09 - So I'm going to specify a text field style
25:11 - as a rounded border text field style
and do that for both text fields.
25:18 - And I'm going to have a button down here.
25:25 - The button is
25:28 - add to do
25:31 - item and the action is
25:34 - call add data.
25:36 - Well like to add the to do item.
25:38 - So model do add data.
25:40 - We're going to pass in this
information and this information
25:49 - and then after that we're
going to do the text field.
25:58 - So
26:00 - let's take a look at how that looks.
26:02 - I think we might have to have
some padding, actually.
26:06 - So
26:09 - why don't we
26:10 - specify group and put
26:19 - actually, I'm going to make this a stack
26:23 - spacing of let's say five and put these
26:25 - three in it on V stack because
I have some special padding.
26:33 - Alright.
26:34 - So let's take a look at how that looks
26:35 - and see if we can actually add some
data to our Firestore database.
26:40 - Alright.
26:41 - So we've got our thing here.
26:43 - Let's add a clean
26:53 - the kitchen,
26:56 - take the garbage.
26:58 - Okay.
26:59 - Let's add that.
27:01 - And you can see that instantly.
27:03 - We have our list updated.
27:05 - That must mean that it
did go into the database.
27:08 - There it is.
Alright.
27:11 - That's how easy it is to add items
into our cloud Firestore database.
27:15 - Next, let's take a look
at deleting deleting.
27:19 - Is it's pretty easy as well?
27:21 - So what we're going to do is go
27:23 - into the View model and add a new
function called delete data,
27:29 - and we're going to expect
a todo item to be passed in.
27:34 - Maybe we'll call it to do to delete.
27:40 - Okay.
27:41 - And again, get a reference
to the database,
27:47 - specify the document to delete.
27:54 - So let B equals Firestore Firestore.
27:59 - And then here B.
28:02 - You could have to specify the path to
that document along with the document ID.
28:08 - Let's say we wanted to delete this
one that we just added right here.
28:13 - Right.
So we're going to have to specify the path
28:15 - to do and then the document
ID right there.
28:19 - Right.
So it would be document path.
28:24 - And here we specify
the specific document ID.
28:29 - However, we are passing that into
the method right to do to delete ID
28:39 - and then delete.
28:40 - So you can either just call
that method and be done with it.
28:43 - You don't care if it
actually got deleted or not,
28:47 - or you can call delete with completion,
28:49 - which again just like when you add data,
this closure gets called after the request
28:58 - returns so you can check if it
actually deleted successfully.
29:08 - All right.
29:09 - No errors.
29:10 - We
29:12 - probably want to immediately remove it
from the UI we want to it was successful.
29:18 - There were no errors
in deleting that document.
29:21 - Then we probably want to remove
that document from this list right here.
29:26 - So in that sense we can say
29:31 - list dot remove
29:37 - repo all were so we can specify condition.
29:41 - So remove all instances
where let's open this up.
29:47 - We're gonna
29:50 - check for the to remove.
29:54 - So return to do is equal to we're
going to check against the IDs.
30:03 - So to do ID equals to do to delete
30:09 - dot ID.
30:13 - Okay.
30:14 - So
30:16 - self list remove all.
30:19 - And because this is modifying this list,
30:23 - which is going to affect the view code
and then have it reflected from the UI.
30:27 - We want to make sure we do that in the
main thread dispatchqueue main async
30:34 - so move this right there.
30:39 - Update the UI from the main thread
30:43 - to do that was just deleted.
30:49 - So if so, it's going to go through this
list of tides and if and for each to do
30:56 - it's going to check it against the ID
of the one that we wanted to delete.
31:00 - And if it's a match,
it's going to remove it.
31:05 - Okay.
31:06 - Now from the UI we need to call that.
31:09 - How are we going to call that?
31:12 - I'll probably add a little X right there.
31:14 - When I was 15.
31:16 - Releases will be able to really easily
31:18 - swipe to delete a probably what
I'll be doing in the future.
31:24 - So I'm going to actually use an H stack
31:26 - here instead of just
displaying that you do.
31:29 - I'm going to do a spacer
31:31 - followed by a button.
31:37 - And for the action it's going to be
for the action is going to be calling
31:42 - model delete data and we're going
to pass in the to do to delete it
31:51 - and then for the label.
31:54 - Let's do an image.
31:56 - I'm going to use SF symbols here.
32:01 - Symbols.
32:03 - This still in beta.
32:06 - I don't know because this one
hasn't updated this in a long time,
32:09 - so I don't know if it's still in beta,
but I think there's an X there minus
32:17 - circle.
So we'll do that copy name.
32:24 - Okay.
32:26 - Let's run it now.
32:27 - Take a look.
32:31 - Okay.
32:32 - So I'm going to tap on clean the kitchen.
Boom.
32:36 - It's gone
32:38 - and it's gone from here as well.
32:40 - Awesome.
32:41 - Last but not least, let's take
a look at how to update data.
32:44 - Now.
I don't have a let's see.
32:49 - I
32:52 - think I'm going to make
this simple because I
32:57 - don't want to create additional new UI
to do it, because the actual code
33:02 - to update data is
very similar to adding data.
33:09 - Right.
33:10 - So
33:15 - let's put in to do here to do to update.
33:24 - Let's start with a reference
33:34 - equals Firestore Firestore, and then for
this one, it's going to be DB collection.
33:42 - Again.
We're always specifying the path
33:46 - and this is going to be we're going
to specify a specific document, right.
33:50 - Because we want to update.
33:52 - Like if we want to update a piece of data,
33:54 - we need to know which
document we're updating.
33:57 - So we're going to specify here to do
33:59 - to update ID, and then we're
going to say set data in here.
34:04 - There are a couple of options
34:07 - at the core level you're
passing in a dictionary.
34:11 - Now that dictionary containing all the key
value pairs and things like that,
34:17 - you can either replace
you overwrite everything that's existing
34:22 - in that document
or you can choose to merge.
34:26 - So if you just specify
set data and then you go
34:33 - to update name
34:38 - and then
34:40 - I'm just going to do
a trivial example here like
34:45 - updated to do name
34:51 - hard code some stuff here.
34:54 - Okay.
34:55 - So when you run this,
what is going to happen is whatever
35:00 - document ID you specify here,
whatever you reference,
35:05 - it's going to replace any existing data is
essentially going to blow away whatever
35:10 - data is in that document and replace
it with what you have here.
35:13 - I
35:14 - could have three fields.
35:15 - I could have multiple fields.
35:17 - I could even have one field.
35:18 - Let's say I just specified this
just a name and updated to do name.
35:24 - And let's say I targeted this specific ID.
35:27 - It would blow this away.
35:30 - It would get rid of these two pieces
35:32 - of data and just replace it
with that one piece of data.
35:36 - So
35:38 - essentially it's overriding
rather than updating.
35:41 - However, there is an extra
parameter called merge.
35:45 - And when you hit merge and you say it's
true, you want to merge,
35:51 - that means instead of overriding,
it's going to combine.
35:56 - So let's do an example.
36:03 - Let me just
36:06 - inside here
36:09 - space or delete.
36:12 - Maybe I'll just add another button here.
36:20 - Essentially, I'll copy this.
36:24 - And instead of calling delete data,
36:27 - I'll call update data to delete.
36:32 - This was to do to update.
36:34 - And instead of minus circle,
let's give it a plus
36:44 - like an edit the pencil pencil.
36:53 - Okay, so that's going
to be our update button.
36:57 - Let's run this right now.
37:00 - Take a look at what happens
when we actually tap on it.
37:04 - Okay, so go to the gym.
37:06 - I'm going to tap the pencil.
37:08 - And this is going to call
this method right here.
37:12 - And it's going to target that to
37:16 - do document and it's going to set name
to updated to do name merge is true.
37:22 - Wait.
37:23 - So that just disappeared
37:26 - inside the database is gone too.
Tonight.
37:30 - Delete it by accident.
37:31 - What happened here on.
37:37 - Alright, so after some quick Googling,
I figured out what was wrong.
37:41 - It turns out that these Swift UI buttons,
when put inside a list row,
37:46 - sort of behaves in a special way where
37:49 - tapping on the row itself will trigger
any and all buttons in there.
37:55 - So one way to work around this is to set
a different style for this button.
38:01 - I know it's kind of weird, but we
38:04 - set this to a borderless button style.
38:08 - Then it's not going to get
triggered when we tap on the row.
38:12 - It's not going to trigger both of these
38:14 - buttons, because that was why
when I was tapping on the pencil.
38:17 - It was also triggering delete.
38:19 - So we weren't really seeing
what we wanted to see.
38:22 - All right, so now let's launch it
in the simulator and we are going to read
38:27 - some data because I got
rid of all my to do.
38:30 - I don't have any right now let's add
38:33 - over the gym,
38:36 - blah blah
38:39 - and take out the garbage.
38:44 - Hello.
38:47 - And we can see these buttons here.
38:49 - Now, before I just realized
before we try hitting update,
38:57 - I actually want to do
a different one here.
39:00 - I want to make sure that it is successful.
39:03 - So set data.
39:04 - We're going to do the one with
39:06 - the document data and the merge
and the completion.
39:10 - So for the document data,
just change the name
39:16 - updated.
39:21 - Maybe we'll
39:24 - keep we'll keep the old name,
but we're going to add updated to it.
39:31 - Merge is true.
39:32 - So I'm not going
to override it completely.
39:35 - And completion when it returns.
39:37 - We want to just refresh the data.
39:40 - So I'm going to give it
a parameter name there.
39:44 - Check for errors just like before.
39:46 - If error is nil,
39:50 - then we're going to say
39:54 - get the new data.
39:57 - Self get data.
39:59 - So now let's see what we have.
40:02 - If we take a look at the database right.
40:04 - We have take out the garbage.
40:06 - Hello and we have go to the gym.
40:07 - Blah blah.
40:09 - Alright, so I'm going to hit edit on,
40:13 - take out the garbage or
actually let's do hit edit on.
40:16 - Go to the gym so we can
see what happens here.
40:19 - Oops Breakpoint.
40:21 - Alright,
40:24 - now it's changed to update.
40:26 - Go to gym in the database.
40:28 - Updated College, but you can see it
didn't it didn't blow this away.
40:33 - However, if we didn't specify merch equals
true, it would have blown everything away
40:40 - and then replaced it with only
this new updated name.
40:44 - So
40:46 - that's how you update data.
40:48 - All right, now you've got the basics
40:51 - of how to work with cloud
Firestore in a Swift UI app.
40:55 - If you want to take this further
and actually use Firestore in a real app,
41:00 - check out our Swift UI databases
course where we do just that.
41:03 - And if there's something else you would
like to explore on the Firebase platform.
41:07 - Do let us know.
41:08 - Go to roadmap code with Chris.
Com.
41:11 - Click over to the ideas tab in there.
41:13 - You can suggest new video topics
and vote on existing ones.
41:17 - We review regularly and we
take video topics from there.
41:20 - And lastly, if you enjoyed this video,
please give it a thumbs up.
41:24 - Consider subscribing to the channel.
41:25 - I appreciate that you watched it so far.
41:27 - Thank you for watching.
41:28 - I'll see you in the next one.

Cleaned transcript:

In this video, I'll show you how to read and write data to your Cloud Firestore database by now, you should have set up your Firebase Project, your Xcode project, and added the Firebase SDK to your Xcode project. And if you haven't done that already, don't worry, because that's what we covered in the last week's video, which you can find right over there. Hey, Code crew, my name is Chris, and if you're new here, welcome. I've been teaching Beginners how to code and build app since 2013. So if that's what you want to do, you're in the right place. If you're just starting out and check out our 14 day Beginner challenge right over here. We have a community full of people going through the same thing right now. All right, with that said, let's dive in today's topic. All right. So here we're looking at our empty Cloud Firestore database. In the last lesson we had set up this Firebase project, initialize this database, and we have picked the server location where this database is going to be stored. And essentially, that's where we left off. So before we can dive into reading and writing data updating and deleting and all that fun stuff, we have to first understand how our data is being stored inside this database. In order to understand that there are only two terms which you really need to understand document and collection. So the data that you want to store is organized into documents. And then a collection is simply a collection of documents. And then finally, inside each document is where your actual pieces of data are stored, and the format that that data is stored in inside a document goes like this. Each piece of data has a label, it has a data type, and it has the value, which is the actual piece of data. So perhaps the easiest way to understand it is visually by starting to do it. So let's go ahead and click this Start collection button. Essentially, we are creating a folder, name or folder to contain documents. So let's give this collection an ID in the demo for this video, we are doing a sample sort of like a small todo list. Each document is going to represent a Todo item. So I'm going to give this collection I'm going to call it to do because it's going to contain all the to do documents. So I'm going to call that. Let's click on next. The example that they give here is, for example, if people can create user accounts in your app, you might have a user's collection. And inside that collection, each document would represent a user. And then inside each user document would contain all of the individual pieces of data for that user. So let's click on next. And here we are going to add the first document within the troduce. You can either manually specify the ID. Keep in mind, this has to be unique. So I'm just going to hit auto ID. It's going to generate that for us. And within this document right here these are going to be the actual pieces of data. Remember what I said before? Each piece of data contains three parts, the label, the data type and the actual value. So for this document that represents a todo item, I might put maybe the task or maybe let's just call it name. And this is probably what the user would type in. Go buy groceries. And this is the data type for the value that you want to store. String is text. And there's different types you can put. Now you can have one field, you can have multiple. So I'm going to hit add field again to add a second one and this one I'll call it notes, because maybe when we let the user add to item, we'll also let them put in some notes here I'll say maybe go with ten or something like that I had saved. There you go. We have our first collection. And within this collection we have a single document inside that single document. We have the actual pieces of data so you can see the field name or the label, whatever you want to call it along with its associated data. Let's go ahead and try a second document. Let's go hit add document and this is going to be added inside our two Duce collection. Go auto ID again. And here's the interesting thing. I don't have to put the same fields as I did for the earlier document. I could have completely different fields, completely different data types, completely different data. It's just going to make it a little tougher when you retrieve that data. If each document is completely different, then you're going to have to add the appropriate logic in your app to identify that and to react accordingly to keep things organized. I'm going to have the same fields. So I'll have the name string and this one maybe like go to the gym. And again we add another one and we'll keep it simple. Maybe this one leg workout. Save it. Alright. So now we have two documents. You can see that the data is inside each document and these documents are inside the troduce collection. So here's a simple data structure with some sample data which we can start working with inside Xcode before we leave here. I do want to note that inside each document you have the ability to start subcollections, which can contain sub documents or just documents. But essentially this chain can go on. So you can have a collection of documents. A document can have, you know, a sub collection within that document which could contain documents, and those documents could have subcollections inside them. And the chain can go on. So this is how the information is organized in your cloud Firestore. These are your root collections right here. So we're going to leave it at this level right now. We're not going to do any subcollections and go, well, fancy, this will be enough for our demonstration. And now let's jump into Xcode and see how we can work with this data. All right. So let's take a quick walk through of this demo Xcode project that I set up. And actually we started setting this up in the previous lesson in part one, where we set up Firestore. We had created this Xcode project and imported the Firebase SDK. Now what I've added since then is simply a view model. And this view model is an observable object. And so far it contains a list of strings. It's just an array of three string items. And what's happening in the view right here is I've got a list element, and it is. It is observing the list property of the model, and it's reading that and it's displaying each of the items in that array in a list component. Now, what we're going to attempt to do instead of using these hard coded items is to fetch the data from our database. So instead of Apple, banana and Orange or whatever I had, we want to say go to the gym and go buy groceries. Essentially want to list the names of these two two items. First of all, though, we need to create some sort of data model inside of our Xcode to represent these data items, because as it stands right now, even if we fetch that data from Firestore database, how would we represent them? How would we organize that data? So what we're going to do is create a struct. So I already organized these things to create a couple of folders for views, view models and models. This would be a data model to represent the data or to model the data that we want to display. Let's go new file, choose under iOS, choose Swift and we're going to call this a to do. So this is going to like an instance of this struct is going to represent a single to do. And typically what you want to do is just mimic to mirror the properties that you have inside your database. So for each to do item, you can see we have a name and we have a note and the data type for these or strings. So I'm just going to mirror it here. Name is a string and also notes is a string. The other thing that we want to capture is the document ID, because when we go to let's say update the data in this document or to delete it, even we're going to need that ID. So we're actually going to capture it in the property up here. And that's also strong. And because we're going to want to display a list of these to do items inside a Swift UI list component like this, what we can do to make our lives easier is have this conform to identifiable, and that means you just need an ID property here. And then when we display that list of to do, we're not going to have to specify that ID parameter, but we'll get to that. Okay. So what we've done here is we've created a struct to do that represents our documents to do documents right here. Next, what we're going to do is go back to the View model and change this list right here instead of an array of these strings. I want this to be an array of our to do items, and I'm going to create an empty array that is going to contain that. Because what we're going to do now is create a function or write a function that is going to go and fetch the data items when it comes back to then store on this list. And because this is a published property, it's going to the View code that we have here in Content View is going to pick up that change, and it's going to then update visually what you see in the user interface. So let's go back to the View model. Let's write a function. We'll call it Get data, and let's take a look at how we can do this. First thing you want to do is import Firebase so you can use those Firebase libraries in the Firebase SDK. I want to get a reference to the database and read the documents at a specificAPI. So this part is easy. We're gonna create a constant called DB, and then the Firestore class actually has a static method called Firestore, which returns the instance to us or the reference to that object that we're going to use to interact with our database right now that you have a reference to it. Let's use it. So DBT collection and this lets you specify which collection you want to access for us. It's going to be to do so that's what we're going to put right here as a string. And then next you could do several different things from here. You could create a new document within that collection. You can remove a specific document. But what we want to do is fetch all the documents inside this collection, and there is a method to do just that. It's called Get documents. We're going to use this one right here with a completion handler. And if we double click this, it's going to open up that closure that gets executed when the database call comes back. So this is going to perform that query, grab all the documents from the Todo's collection. It's going to come back and run this block of code right here, which you can customize note these two parameters, which are optional parameters. These could be nil. Any errors that happened will be stored in this parameter, and the actual documents that come back from this query are going to be stored in this snapshot parameter in a property called documents. So let's go ahead and try that out. First. Of all, I'm going to give these two parameters a name, snapshot and error. We're going to want to check for error first. And this way, if there is an error, we probably want to show that in the UI tell the user didn't work, try it again later or handle it some way. So if error is no, that means there are no errors, right. Errors or otherwise, you're going to want to handle the error. Okay. So if there are no errors, what we're going to want to do next is make sure that snapshot isn't mill because this was optional. Right. So we're going to say if that snapshot equals snapshot, that's going to let us use the same parameter name. And while making sure that that isn't mill, we're going to want to get all the documents and create to do to do essentially instances of this struct. Okay. So like I mentioned inside snapshot, there is a documents property, and this is an array of all of the documents. This is going to be a dictionary where the keys are the fields right here in the values are this right here. So I'll show you how to extract that data out from each document and put it into an instance of it to do so, one way you could do this is you can use a for loop. You can say for document in snapshot, documents and side here you can create each to do, but you can also do it this way. So snapshot do documents, dot map, and then let's open that up into a closure. And then here you can put let's see. Maybe you put D for document and here essentially gives you a chance to transform each document into to do so. This map function basically iterates through that array, and it performs this Xcode on each of the items, and then return that result to you in a collection. So for each document inside documents, we are going to instead return a new to do if that's what we want to change it to. Right. And in order to create it to do, we need to supply three pieces of information, the ID, which is going to be the document ID, the name and the notes. So let's go ahead and put do document ID. So this is a special property of the document, and that is going to be that document ID right there. But for these pieces of data inside the document, we need to use it as a dictionary to extract that. So it's going to be and we're going to specify the field name. So in this case it is a name. It doesn't know what data type it is. So we have to cast it. So we're going to say cast it as a string. If, for example, it's missing, maybe it's Nill. We are going to use the no coalescing operator, the double question Mark here. So if it can find this, if I can't find this this key value, pair this field and value it is going to put an empty string instead. So for notes, we're going to do the same thing. No, we're going to try to turn that into a string. If that doesn't work, we're going to put empty strings like that. So essentially for each document, it is going to return a todo item with the information from that document. And then here because it's going to return an array of information. Right. We are just going to assign the result to list right there. Okay. So self dot list equals that list right there. Right. So yeah, doing that is going to update this publish property, which is going to cause the code in here to detect that change in model list, and it's going to change the UI. But do note that this is happening in a background thread. So when you send out that request to the server or the database to get that data back, it's happening in the background and when from the background. When we run this code, it's going to cause a UI change. Whenever that happens, we don't want to do that sort of work in a background thread. We want to do the it foreground. And so since at the time of this recording we're still using Iowa 14, we are going to use the dispatch queue to put this back on the main thread. So dispatch Q dot main dot async update the property, the main thread since it causes UI changes, and then create a todo item for each document returned. Alright. So let's give this a try. We're going to go back to Content view, and then we're going on the initialization of this view. We are going to say model dot get data. Okay. And since this list property is now an array of to do items, we have to display the name, item name and we can get rid of this ID property since the two destructive identifiable. And let's run this in the simulator. See what happens now. There are a couple of things I'm glossing over. If you know, keywords like identifiable is is foreign to you, then you definitely want to check out our Beginner series and maybe even our Swift UI foundation course. Alright. Perfect. So from here you can see that it hit our Firestore database. It's fetched the two documents and it has put them into the list right here. And our View has captured that and updated what is visible to the user. Next, let's take a look at adding items into the database. So we're going to add a couple of text fields down here with a button to just insert some todo items into this to do collection. So first of all, go into the View model and I'll show you what the code looks like before we even get to modifying the UI. So up here let's say add data and we're going to pass in two pieces of information, the name of the to do and also any potential notes for them to do so. I'm going to say name, string, note, string. And then once again, we get a reference to the database. And then we add a document to a collection. So this is just like we did before Firestore, Firestore, Firestore. And then down here we use that reference DV DT. Well, first of all, specify the collection so that we can indicate which collection we want to add a new document to. This is going to be to do. And we're going to say add document. Now there are two different ones. This one is just add the document and you don't really care about what happens next. And the other one which we're going to use has an extra parameter that executes when the call comes back from the server. So this parameter is the data that we are putting into the document, and this one is the code that we want to run afterwards. So first of all, let's take a look at what data we want to send. We're not going to have to worry about the ID here because that's automatically going to be generated. This dictionary is going to be representing the data inside the document. Right. So we're going to specify a name key, passing the data there and in notes, key and passing the notes data. So again, this is going to be a dictionary. And first of all, we're going to put name and followed by the value. This is how you specify a key value pair for a dictionary and we're going to pass in name, which is what is what we're going to pass into this method. Okay. The next key value pair notes followed by that parameter notes. And then for this completion, Hamo, double click it to open closure. And it only has one parameter called error. And this is to let us know if there was any error in creating that document and adding the data. So here let's check for errors if error is nil, right. No errors. So this shouldn't be a comment. Handle the error in here. This is going to be if there are no errors, we want to fetch the data again so that we grab that latest to do item. So I'm just going to call self dot get data from here. And this is going to cause this to run, which is then going to grab all the documents in the deduce collection, and it's going to dispatch the result into the main thread to update the UI. Alright. And that's how simple it is to add a new document into a collection and the UI. We're going to want to add some text fields. So first of all, we're going to have two text fields, one to write the name of them to do, and the other to write the notes for this to do so, and to specify two state properties here. So we can capture that data from the user or name or notes. And what we're going to do is we're going to put this list into a stack. Alright. And then we're going to have a divider here followed by another V SDK, but two text field field name and we're going to bind it to this state property here. So whatever the user types in, it's going to be captured in that property. So in order to specify binding, we use the dollar sign. I have another text field notes. Right. But these text fields by default, the style for them is it doesn't have an outline. So I'm going to specify a text field style as a rounded border text field style and do that for both text fields. And I'm going to have a button down here. The button is add to do item and the action is call add data. Well like to add the to do item. So model do add data. We're going to pass in this information and this information and then after that we're going to do the text field. So let's take a look at how that looks. I think we might have to have some padding, actually. So why don't we specify group and put actually, I'm going to make this a stack spacing of let's say five and put these three in it on V stack because I have some special padding. Alright. So let's take a look at how that looks and see if we can actually add some data to our Firestore database. Alright. So we've got our thing here. Let's add a clean the kitchen, take the garbage. Okay. Let's add that. And you can see that instantly. We have our list updated. That must mean that it did go into the database. There it is. Alright. That's how easy it is to add items into our cloud Firestore database. Next, let's take a look at deleting deleting. Is it's pretty easy as well? So what we're going to do is go into the View model and add a new function called delete data, and we're going to expect a todo item to be passed in. Maybe we'll call it to do to delete. Okay. And again, get a reference to the database, specify the document to delete. So let B equals Firestore Firestore. And then here B. You could have to specify the path to that document along with the document ID. Let's say we wanted to delete this one that we just added right here. Right. So we're going to have to specify the path to do and then the document ID right there. Right. So it would be document path. And here we specify the specific document ID. However, we are passing that into the method right to do to delete ID and then delete. So you can either just call that method and be done with it. You don't care if it actually got deleted or not, or you can call delete with completion, which again just like when you add data, this closure gets called after the request returns so you can check if it actually deleted successfully. All right. No errors. We probably want to immediately remove it from the UI we want to it was successful. There were no errors in deleting that document. Then we probably want to remove that document from this list right here. So in that sense we can say list dot remove repo all were so we can specify condition. So remove all instances where let's open this up. We're gonna check for the to remove. So return to do is equal to we're going to check against the IDs. So to do ID equals to do to delete dot ID. Okay. So self list remove all. And because this is modifying this list, which is going to affect the view code and then have it reflected from the UI. We want to make sure we do that in the main thread dispatchqueue main async so move this right there. Update the UI from the main thread to do that was just deleted. So if so, it's going to go through this list of tides and if and for each to do it's going to check it against the ID of the one that we wanted to delete. And if it's a match, it's going to remove it. Okay. Now from the UI we need to call that. How are we going to call that? I'll probably add a little X right there. When I was 15. Releases will be able to really easily swipe to delete a probably what I'll be doing in the future. So I'm going to actually use an H stack here instead of just displaying that you do. I'm going to do a spacer followed by a button. And for the action it's going to be for the action is going to be calling model delete data and we're going to pass in the to do to delete it and then for the label. Let's do an image. I'm going to use SF symbols here. Symbols. This still in beta. I don't know because this one hasn't updated this in a long time, so I don't know if it's still in beta, but I think there's an X there minus circle. So we'll do that copy name. Okay. Let's run it now. Take a look. Okay. So I'm going to tap on clean the kitchen. Boom. It's gone and it's gone from here as well. Awesome. Last but not least, let's take a look at how to update data. Now. I don't have a let's see. I think I'm going to make this simple because I don't want to create additional new UI to do it, because the actual code to update data is very similar to adding data. Right. So let's put in to do here to do to update. Let's start with a reference equals Firestore Firestore, and then for this one, it's going to be DB collection. Again. We're always specifying the path and this is going to be we're going to specify a specific document, right. Because we want to update. Like if we want to update a piece of data, we need to know which document we're updating. So we're going to specify here to do to update ID, and then we're going to say set data in here. There are a couple of options at the core level you're passing in a dictionary. Now that dictionary containing all the key value pairs and things like that, you can either replace you overwrite everything that's existing in that document or you can choose to merge. So if you just specify set data and then you go to update name and then I'm just going to do a trivial example here like updated to do name hard code some stuff here. Okay. So when you run this, what is going to happen is whatever document ID you specify here, whatever you reference, it's going to replace any existing data is essentially going to blow away whatever data is in that document and replace it with what you have here. I could have three fields. I could have multiple fields. I could even have one field. Let's say I just specified this just a name and updated to do name. And let's say I targeted this specific ID. It would blow this away. It would get rid of these two pieces of data and just replace it with that one piece of data. So essentially it's overriding rather than updating. However, there is an extra parameter called merge. And when you hit merge and you say it's true, you want to merge, that means instead of overriding, it's going to combine. So let's do an example. Let me just inside here space or delete. Maybe I'll just add another button here. Essentially, I'll copy this. And instead of calling delete data, I'll call update data to delete. This was to do to update. And instead of minus circle, let's give it a plus like an edit the pencil pencil. Okay, so that's going to be our update button. Let's run this right now. Take a look at what happens when we actually tap on it. Okay, so go to the gym. I'm going to tap the pencil. And this is going to call this method right here. And it's going to target that to do document and it's going to set name to updated to do name merge is true. Wait. So that just disappeared inside the database is gone too. Tonight. Delete it by accident. What happened here on. Alright, so after some quick Googling, I figured out what was wrong. It turns out that these Swift UI buttons, when put inside a list row, sort of behaves in a special way where tapping on the row itself will trigger any and all buttons in there. So one way to work around this is to set a different style for this button. I know it's kind of weird, but we set this to a borderless button style. Then it's not going to get triggered when we tap on the row. It's not going to trigger both of these buttons, because that was why when I was tapping on the pencil. It was also triggering delete. So we weren't really seeing what we wanted to see. All right, so now let's launch it in the simulator and we are going to read some data because I got rid of all my to do. I don't have any right now let's add over the gym, blah blah and take out the garbage. Hello. And we can see these buttons here. Now, before I just realized before we try hitting update, I actually want to do a different one here. I want to make sure that it is successful. So set data. We're going to do the one with the document data and the merge and the completion. So for the document data, just change the name updated. Maybe we'll keep we'll keep the old name, but we're going to add updated to it. Merge is true. So I'm not going to override it completely. And completion when it returns. We want to just refresh the data. So I'm going to give it a parameter name there. Check for errors just like before. If error is nil, then we're going to say get the new data. Self get data. So now let's see what we have. If we take a look at the database right. We have take out the garbage. Hello and we have go to the gym. Blah blah. Alright, so I'm going to hit edit on, take out the garbage or actually let's do hit edit on. Go to the gym so we can see what happens here. Oops Breakpoint. Alright, now it's changed to update. Go to gym in the database. Updated College, but you can see it didn't it didn't blow this away. However, if we didn't specify merch equals true, it would have blown everything away and then replaced it with only this new updated name. So that's how you update data. All right, now you've got the basics of how to work with cloud Firestore in a Swift UI app. If you want to take this further and actually use Firestore in a real app, check out our Swift UI databases course where we do just that. And if there's something else you would like to explore on the Firebase platform. Do let us know. Go to roadmap code with Chris. Com. Click over to the ideas tab in there. You can suggest new video topics and vote on existing ones. We review regularly and we take video topics from there. And lastly, if you enjoyed this video, please give it a thumbs up. Consider subscribing to the channel. I appreciate that you watched it so far. Thank you for watching. I'll see you in the next one.
