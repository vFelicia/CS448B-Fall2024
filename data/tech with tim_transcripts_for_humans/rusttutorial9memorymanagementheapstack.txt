With timestamps:

00:02 - [Music]
00:08 - hello everybody and welcome to video 9
00:10 - in this rust programming tutorial series
00:13 - in this video i'm going to be talking to
00:15 - you about memory management in rust
00:17 - specifically discussing the stack and
00:19 - the heap now this is going to be a
00:21 - general introduction to memory
00:23 - management in the next video i'm going
00:24 - to talk about ownership and then we'll
00:26 - move on and talk about references
00:28 - pointers arrays slices and all of those
00:30 - other things but before we can do that
00:32 - of course we need to understand the
00:33 - stack and the heap i'll also say that if
00:35 - you are getting confused here i will
00:37 - recommend that you read the official
00:39 - rust documentation it is a little bit
00:41 - difficult if you don't understand some
00:43 - of these concepts already but it may
00:44 - clear some things up if this video is
00:46 - giving you you know a good understanding
00:48 - but you just want some more detail so
00:50 - i'll link that in the description and
00:52 - with that said we can dive in here now i
00:54 - do of course need to remind you to check
00:56 - out programming programmingexpert.io
00:57 - from the link in the description we
00:59 - teach all kinds of advanced programming
01:00 - concepts stuff similar to this as well
01:03 - just for other programming languages
01:04 - like go and python with that said though
01:07 - we can get in here so on my screen you
01:09 - can see that i have a stack i have a
01:11 - heap and i'm kind of indicating that
01:13 - these are all part of ram which is
01:15 - random access memory i also am going to
01:17 - have a few photos on the left hand side
01:18 - of my screen which will be examples that
01:20 - we'll walk through as we go through this
01:22 - video
01:23 - now the first thing to talk about here
01:25 - is what i mean by memory management and
01:27 - some of the considerations or concerns
01:29 - you may have when it comes to writing
01:32 - information to ram and reading
01:33 - information from ram as well so whenever
01:35 - we run a program or executing that on
01:38 - our machine we need some space in ram
01:41 - where we're going to store the data
01:42 - associated with our program so we have a
01:44 - very basic program over here but in this
01:46 - case we would need some location in ram
01:48 - where we can store the value of the
01:50 - variable x right
01:52 - now in most programming languages we
01:54 - don't really consider what happens when
01:56 - we write a statement like this we just
01:58 - know that okay this data is going to get
01:59 - stored somewhere i can then retrieve it
02:01 - later on by using the variable name x
02:03 - and you don't really care beyond that
02:05 - now in rust this will be handled for us
02:07 - automatically as well but we do kind of
02:09 - want to understand what's going on a bit
02:11 - more just because this is a systems
02:13 - programming language and we have some
02:15 - more lower level control here in rust
02:18 - than we would in a language like python
02:20 - or javascript or something along those
02:22 - lines so we just want to know kind of
02:24 - what's going on
02:25 - when we actually do something like let x
02:27 - equals two how that's getting allocated
02:29 - in ram
02:30 - and how we're retrieving that
02:32 - information and all of that kind of
02:33 - stuff so when it comes to doing this
02:35 - right storing information and ram
02:36 - there's a few concerns the first concern
02:38 - is that wherever we store this
02:40 - information we want it to be easily
02:42 - accessible we want to be able to find it
02:43 - very quickly we don't want to be
02:45 - searching in ram and spending a lot of
02:47 - time trying to find this data the second
02:49 - thing is we don't want to be duplicating
02:51 - this data or taking up any more space in
02:53 - ram than we have to so for example here
02:55 - i wouldn't want to have multiple you
02:57 - know x equals 2 in my ram because we're
03:00 - using up more space than we have to be
03:02 - we also want to make sure that we only
03:04 - have this data in ram when we need to be
03:06 - using this data if i'm never going to be
03:08 - using this variable let x equals 2 or
03:11 - i've already used this data and i'm no
03:12 - longer going to be using it in the
03:13 - program i probably want to remove it
03:16 - from ram and we need to have a way to do
03:18 - that now that concern specifically is
03:20 - something that is dealt with in a
03:22 - different way in many different
03:23 - programming languages for example in
03:25 - java we have something called a garbage
03:27 - collector which will automatically
03:28 - delete data from ram when it's no longer
03:31 - referenced in the program
03:33 - other languages implement different
03:34 - styles or different types of doing this
03:36 - and in rust we have kind of a unique way
03:38 - as well which i'll talk about a bit in a
03:40 - second okay so hopefully that gave a
03:42 - general introduction here but as you can
03:45 - see in rust we have two different
03:47 - sections of ram
03:49 - now that's going to be our stack and our
03:51 - heap now the stack works similarly to a
03:53 - stack you would have learned about in
03:54 - your data structures and algorithms
03:56 - course where the last piece of
03:58 - information in is the first piece of
04:00 - information out so you can think of like
04:02 - a stack of plates where if i have three
04:04 - plates like this the plate that i put on
04:06 - the top that was the most recent plate
04:08 - to be added will be the first plate to
04:10 - come off of the stack because it's at
04:11 - the top now this also has an official
04:14 - name that is lifo
04:16 - or philo
04:18 - now lifo stands for last in first out
04:21 - and philo is first in last out so you
04:24 - can apply whichever one you'd like there
04:26 - to try to remember this concept but keep
04:28 - that in mind the last piece of
04:29 - information in is the first piece of
04:31 - information out when we use a stack
04:34 - now we have the heap now the heap is not
04:36 - really at all similar to the heap data
04:38 - structure that you'd be familiar with
04:40 - from a data structures and algorithms
04:42 - class so for now just understand we have
04:43 - kind of a separate section here called
04:45 - the heap but don't try to visualize it
04:48 - like you would kind of a traditional
04:50 - heap that you would have seen in in data
04:51 - structures and algorithms okay so we
04:53 - have these two pieces of information or
04:55 - sorry two kind of sections of ram and
04:57 - they're used for different purposes now
04:59 - the fastest piece of ram or thing that
05:02 - we have in rust here is the stack so
05:04 - ideally we want to put everything that
05:06 - we possibly can onto the stack and then
05:08 - we use the heap when we need to use the
05:10 - heap for kind of a dynamically sized
05:13 - object which i'll talk about in a minute
05:15 - for now they'll understand that the
05:16 - stack is the fastest and we want to
05:18 - prioritize using the stack when possible
05:21 - however sometimes we need to defer the
05:23 - heap and use that and again i'll go
05:24 - through all those details just trying to
05:26 - give you a general introduction here
05:28 - so now that we have that understood
05:30 - let's kind of ignore the heap for right
05:32 - now let's just look at the stack and
05:34 - let's see what happens when we run a
05:36 - basic program like this in terms of
05:38 - storing information on the stack and
05:40 - again remember the stack is a part of
05:41 - our random access memory
05:43 - so what we can see in the stack here is
05:45 - that we have kind of these little boxes
05:47 - right now this is just my visualization
05:49 - this is not exactly what a stack is
05:51 - going to look like but we will have some
05:53 - address associated with every kind of
05:56 - box or space in our ram or in our stack
05:59 - now this address is how we'll access
06:01 - different information and each piece of
06:04 - information will have its unique address
06:05 - right so just kind of keep that in mind
06:07 - the addresses will be much longer than
06:09 - this i'm just going with very basic ones
06:10 - again for the video and the explanation
06:13 - so we have this program here we say
06:14 - function main and we say let x equals
06:16 - two now when we have let x equals 2 we
06:19 - need to store this in ram so what we do
06:22 - is we go to the stack we place a name x
06:24 - here and then we place a value 2 and we
06:26 - put this on the top of the stack now the
06:29 - top of the stack will just represent the
06:31 - most recent piece of information that
06:33 - we've added to the stack right and then
06:34 - when we add more we'd add like this and
06:36 - when we removed from the stack we'd
06:38 - remove whatever the most recent piece
06:39 - was and keep going kind of
06:42 - down the stack if that makes sense
06:44 - for now though we have x equals two
06:46 - that's been added onto the stack
06:48 - so now that we've placed this here if we
06:50 - use x later on in our program like we
06:52 - print it out we can just access it
06:54 - directly from ram and use it
06:56 - however what happens when this function
06:58 - is finished executing
07:00 - what do we do with x equals 2 on our
07:03 - stack
07:04 - well we need to remove it and the way
07:05 - that this works is that x here is within
07:08 - a scope now the scope is the function
07:11 - that is defined inside of or the block
07:12 - that is defined inside of so in this
07:14 - case we have function main
07:16 - and that means that x since it's defined
07:18 - inside of these curly braces here is a
07:20 - part of this main scope so that means
07:22 - that once this scope is finished
07:24 - executing or we're outside of the scope
07:26 - outside of the main function we need to
07:28 - remove x from ram and russ will do that
07:31 - automatically for us so let's say you
07:33 - know we execute x here we do whatever we
07:35 - want with it then we get to this line
07:37 - right here kind of where i put this
07:39 - double slash although i could have i
07:40 - guess just put an arrow then what we're
07:42 - going to do is remove x from ram
07:45 - so we remove it like that and there you
07:47 - go we've kind of garbage collected or
07:49 - got rid of information and ram that
07:51 - we're no longer using now i know this
07:53 - seems extremely basic right now we're
07:55 - going to go into some more advanced
07:56 - examples but this is the basic concept
07:59 - right we go through a function we see a
08:01 - statement like this let x equals 2 we
08:03 - then add x into ram and then as soon as
08:05 - we're outside of the scope where this
08:07 - information is being used we
08:08 - automatically remove it from ram or from
08:11 - our stack so i've just placed another
08:12 - example on the screen here and we're
08:14 - going to go through this in a second but
08:15 - i do want to mention that the stack is
08:17 - only capable of holding information that
08:20 - has a known and fixed size now that
08:22 - essentially means that we can't store
08:24 - anything on the stack that could change
08:26 - size later on and then we can add stuff
08:29 - to delete stuff too we can't store for
08:32 - example a dynamically sized array on the
08:34 - stack or a dynamically sized string you
08:36 - can only store anything that has a fixed
08:38 - size and for now a fixed size would be
08:40 - something like 2 or 3 or the
08:43 - value true right like a boolean or a
08:45 - float all of those are fixed size
08:47 - they're not going to change throughout
08:49 - the program whereas we could have some
08:51 - data structures that we haven't yet
08:52 - looked at that can change size and
08:54 - that's where the heap comes in and where
08:56 - we need to store those
08:57 - hopefully that gives a bit of clarity uh
08:59 - but that is kind of why we can't just
09:01 - use the stack for everything although
09:03 - for now with the examples we have we
09:05 - will just be using the stack
09:06 - okay anyways we have two lines of code
09:08 - now in this main function and i just
09:10 - want to show you again what happens here
09:11 - when we run through the code so we're
09:13 - first gonna create a space here on the
09:14 - stack where we have x equals two then
09:17 - we're gonna create another space on the
09:18 - stack where we have y and we're gonna
09:20 - copy the value from x here directly into
09:23 - this box and we're going to have 2 as
09:24 - well
09:25 - now we do this because this is an
09:27 - immutable value which means i just make
09:29 - a copy of it so i have the copy right
09:31 - there so now i have x and y on my stack
09:34 - notice i placed x first and then i
09:36 - placed y because that's the order in
09:38 - which i saw them here as i was reading
09:40 - through these lines of code
09:42 - so now let's imagine that we get to the
09:44 - end of this main function here we are no
09:46 - longer in the scope in which these two
09:48 - things are defined and so we need to
09:50 - remove them from ram so how do we do
09:52 - this well we need to essentially pop off
09:55 - the stack so we're going to start by
09:57 - popping this element off which is the
09:59 - top of the stack the most recent element
10:01 - that was added and then we're going to
10:02 - pop this one off so i can just delete
10:04 - these i'm gonna delete that we pop the
10:06 - first element off and then i'll delete
10:08 - this we pop the second element off and
10:10 - there you go that's all that's involved
10:12 - in adding kind of these integer values
10:14 - onto our stack
10:15 - now let's do a more advanced example
10:17 - where we have multiple functions and see
10:19 - what happens there with those stacks all
10:21 - right so i've just placed another
10:22 - example on my screen here where now we
10:24 - have a function call and let's look at
10:26 - what happens with the stack i can go
10:28 - relatively fast because we've already
10:29 - looked at kind of this main example so
10:31 - we start by defining x and y they're
10:33 - both going to have the value 2 here on
10:36 - our stack then we call this example
10:38 - function and when we call this example
10:40 - function we're going to go inside of
10:41 - here and start executing the code and
10:43 - just like we added information onto the
10:45 - stack from the main function we're going
10:46 - to do the exam the same for example so
10:49 - we're going to have a here and that's
10:50 - going to be equal to true excuse my
10:52 - messy handwriting and then we're going
10:54 - to have b here and that's going to be
10:55 - equal to false and again notice that i'm
10:58 - adding them kind of in order in which
11:00 - i'm viewing them on the stack so now
11:02 - this element here b is the top of the
11:05 - stack and if i start removing things
11:06 - from the stack or popping them off this
11:08 - will be the first thing to be removed so
11:11 - now i'm in example right i've executed
11:13 - this code let's go back to white here
11:15 - and i reach the end of this scope so now
11:17 - i'm outside of this scope so that means
11:19 - i need to pop all the elements off of
11:21 - the stack that were a part of this scope
11:23 - so a and b i'm no longer using them i
11:26 - need to pop them off so i do that right
11:28 - we pop one at a time we pop b this comes
11:30 - off the stack then we pop a that comes
11:33 - off the stack and now we return back to
11:36 - where this function was called and we
11:39 - see that we still have x and y and we
11:41 - still have them here because this
11:42 - function is not yet done x and y are
11:45 - still within the current scope hopefully
11:47 - that's making a bit of sense we have not
11:49 - yet popped x and y because this function
11:51 - is not yet finished execute so now let's
11:54 - say example is done we now reach this
11:57 - line right here now we're going to pop y
12:00 - and x off the stack again in this order
12:02 - because we're now out of the scope so
12:04 - there you go that's the basics on adding
12:06 - item to the stack now if i go back to
12:08 - where we had all of our items on the
12:10 - stack let's just note here that the
12:12 - reason why a stack is very quick is
12:14 - because all of the information
12:15 - associated with the current scope that
12:17 - we're in is simply at the top of the
12:19 - stack we don't really need to search for
12:21 - this information we just know that it's
12:23 - at whatever the top of the current stack
12:25 - is so i'm inside of the example function
12:27 - right now at this point in time and if i
12:29 - need to access a or b i know they're
12:31 - going to be at the top of the stack i
12:33 - may need to look a few elements down to
12:35 - find it but i know that they're here
12:37 - because the information with the current
12:39 - scope is at the top of the stack that's
12:41 - what makes this extremely efficient is
12:43 - this kind of stack data structure and
12:45 - then of course when we finish this
12:47 - function call right here we remove this
12:49 - information from the stack now we're
12:51 - back into this scope and now if i want
12:53 - to access the information in the main
12:54 - function well again i just look at the
12:56 - top of the stack i look at x and y so
12:58 - hopefully that gives you a bit of an
13:00 - illustration of why a stack is a very
13:02 - fast data structure and why we're using
13:04 - that here for managing the memory of
13:07 - kind of our basic variables or basic
13:09 - data types
13:10 - now that we understand the stack though
13:12 - let's have a look at an example where we
13:14 - actually need to use the heap or before
13:17 - we do that we can look at a more
13:18 - advanced function example where we have
13:20 - say parameters all right so i've just
13:22 - pasted another example here on the
13:24 - screen excuse the kind of modification
13:26 - that i've made but you can see that i
13:27 - have this add function it has two
13:29 - parameters x and y and conveniently
13:31 - those shadow the names x and y from the
13:34 - main scope and then i'm calling this add
13:36 - function x y again sorry that it's a
13:38 - little bit janky here but i think you
13:39 - get the idea so on the stack i've
13:41 - already placed x and y and i'm imagining
13:43 - here that we're at this add line so when
13:46 - we come to add here now i want to ask
13:48 - you what happens what's happening with
13:50 - the parameters in this function and how
13:53 - do those get added to the stack or not
13:55 - added to the stack how do we deal with
13:57 - that
13:57 - well whenever we're passing immutable
13:59 - values to a function they're just going
14:01 - to be copied into the parameters so
14:04 - what's actually going to happen here is
14:05 - we're going to add to the stack x and y
14:08 - again and they're going to have the same
14:09 - values of 2 and 2.
14:11 - now the function knows to use this x and
14:14 - y as opposed to using this x and y even
14:17 - though it doesn't matter because they're
14:18 - the same value because it's looking at
14:20 - the top of the stack for variables named
14:23 - x and y when i'm referencing them inside
14:26 - of this function
14:27 - hopefully that makes a bit of sense but
14:29 - that's kind of how the stack works and
14:30 - deals with this name shadowing it's
14:33 - looking for essentially the most recent
14:35 - value on the stack that matches the name
14:38 - that it's looking for so in this case
14:40 - when i try to do something like x plus y
14:42 - nothing has to happen on the stack but
14:44 - we retrieve x and we retrieve y from the
14:48 - top of the stack as opposed to later
14:50 - down and then we see that these are
14:52 - equal to two we use them and then we're
14:54 - going to return a value back here to
14:57 - this add function now i'm not really
14:59 - going to describe exactly how that works
15:00 - in relation to the stack but once this
15:03 - scope is finished then again we're going
15:04 - to pop off x and y now we're back to
15:08 - this main scope where now we have x and
15:10 - y equal to these two values even though
15:11 - again they were the same
15:13 - then once we finished the scope we would
15:15 - pop those off and we would continue okay
15:17 - i just want to show you a quick example
15:18 - there with parameters and kind of the
15:20 - name shadowing now that we've done that
15:22 - i'll drag in one more example that has
15:24 - to do with the heap and we'll see when
15:26 - we would use the heap and why
15:28 - the heap can be slower than using the
15:30 - stack so i've just placed another
15:31 - example on the screen here i apologize
15:33 - that it's a bit small but in this
15:35 - example we're using something called a
15:37 - string now i know we've looked at
15:39 - strings already but there is an
15:40 - important distinction to make here
15:42 - between what this is a string literal
15:44 - that has double quotation marks and the
15:47 - string from now the double quotation
15:49 - mark string is immutable it cannot
15:52 - change in size it's a fixed size and we
15:54 - can store that on the stack
15:56 - however when we use this special kind of
15:59 - string syntax here so string colon colon
16:01 - from this actually creates a dynamically
16:04 - sized string which we can add characters
16:06 - to remove characters from we can change
16:09 - the size of it it becomes a dynamic size
16:11 - so since we're using this string from
16:13 - something we haven't yet seen before we
16:16 - need to store this on the heap we can't
16:17 - store this on the stack because we can
16:19 - only store something that's a fixed size
16:21 - on the stack so again if it was just
16:22 - this double quotation mark string we
16:24 - could put it on the stack but since it's
16:26 - not it's this special string object here
16:28 - a special string type we need to instead
16:31 - store it on the heap so you can see i've
16:32 - already kind of skipped step one here
16:34 - where we have x is equal to two and i
16:36 - put that on the stack but now we have
16:39 - this string and we need to store this
16:41 - string on the heap so what actually
16:43 - happens when we want to store something
16:44 - on the heap is we need to refer to or
16:47 - use something called the memory
16:48 - allocator which is going to find space
16:51 - on the heap for us where we can store
16:53 - this string
16:55 - so just keep in mind this is an
16:56 - important distinction on the stack when
16:58 - we add something we just add it at the
17:00 - top of the stack right if this was
17:02 - another immutable value or something
17:04 - that was a dynamic size i just put one
17:07 - y2 for example like we've seen before
17:09 - and we're good we just add it at the top
17:11 - of the stack however with the heap we
17:13 - actually need to search through the heap
17:16 - and look for a location that's large
17:18 - enough to hold what it is that we want
17:19 - to store so we're allocating space we're
17:23 - looking for space on the heap now this
17:25 - is much more time consuming than the
17:26 - stack because we actually have to look
17:28 - through the heap right there's something
17:29 - we have to do to be able to place
17:31 - something on it whereas on the stack we
17:33 - just immediately place it on the top so
17:35 - we go to the memory allocator it then
17:37 - kind of gives us a location on the heap
17:39 - where we're able to store this and then
17:41 - we place that string onto the heap now
17:44 - in terms of the name here this is kind
17:45 - of irrelevant when it comes to the heap
17:47 - i'm just going to put the value here as
17:50 - hello if i can get that in okay so that
17:52 - fits in nicely
17:54 - and now what happens is we actually get
17:56 - what's known as a pointer to the value
17:59 - on the heap so let me just write this
18:00 - out and then i'll explain this we're now
18:02 - going to have string that's the name of
18:04 - our variable that's going to go on the
18:05 - stack and instead of storing hello
18:08 - inside of here we're instead going to
18:10 - have a pointer that's going to point to
18:12 - the location of this string in the heap
18:16 - again we're just pointing to where it is
18:18 - in the heat so now if i actually want to
18:20 - access the value of the string i need to
18:23 - find the address or the location in the
18:25 - heap where the string is stored i then
18:27 - need to go to the heap i need to
18:29 - retrieve the value
18:31 - and then i can use it or i can modify it
18:33 - or do whatever i want with it whereas if
18:35 - i'm just getting something directly from
18:37 - the stack
18:38 - all i have to do is grab the value
18:40 - whereas here there's kind of a little
18:42 - road map or it's giving us an address or
18:44 - a pointer to where this information is
18:46 - actually stored we're going to look at
18:48 - this more in detail later on but that's
18:50 - what happens with the heat the heap is
18:52 - not as organized as the stack and it's
18:54 - just essentially mapping values to an
18:56 - address and then we use that address to
18:59 - access the value from the stack so we
19:01 - store the name of the variable here it
19:03 - has the pointer this actually stores the
19:05 - value and again the reason we need it on
19:07 - the heap is because we need to have kind
19:09 - of a dynamic sizing or a space that's
19:12 - large enough to fit the value which we
19:14 - had to search through in the heap to
19:16 - find so in summary here storing
19:18 - something on the heap is slower than
19:20 - storing something on the stack because
19:22 - we need to search for space to be able
19:23 - to store it it's also slower to access
19:26 - something on the heap than on the stack
19:28 - because we need to follow a pointer to
19:30 - find that information
19:31 - and contemporary processors like the
19:34 - standard processors we use today are
19:36 - much faster at accessing data that's
19:38 - close together in kind of an organized
19:40 - block than to potentially be randomly
19:42 - kind of jumping around a heap looking
19:44 - for data so that's why i've been putting
19:47 - a ton of emphasis here on the stack and
19:48 - the speed of the stack as opposed to the
19:50 - heap now you cannot always use the stack
19:52 - of course in this situation we needed
19:54 - the heap but the point of knowing this
19:56 - is that you want to optimize your
19:57 - programs to use the stack as much as
19:59 - possible and avoid using the heap where
20:01 - you can or understand the performance
20:04 - kind of hits you're going to have by
20:05 - using the heap now with all of that said
20:07 - russ is a very fast programming language
20:09 - there's not really a problem with using
20:11 - the heap you can do that and we're going
20:12 - to be doing that many times you just
20:14 - want to understand where your
20:16 - information is is it on the stack is it
20:18 - on the heap how do i retrieve that what
20:20 - is a pointer and kind of the basics of
20:22 - how information gets cleaned up or data
20:24 - gets cleaned up from random access
20:26 - memory either being on the heap or being
20:28 - on the stack
20:30 - now with all of that said i think i'm
20:31 - going to start wrapping up the video
20:33 - here in the next video i'm going to
20:35 - discuss something with you called
20:36 - ownership which is going to bring all of
20:38 - this full circle and talk to you about
20:40 - why it was important to actually
20:41 - understand the difference between the
20:42 - stack and the heat for now all you need
20:45 - to know is you store fixed size data on
20:47 - the stack you store dynamically sized
20:50 - data
20:51 - on the heap and then when you need to
20:52 - access data on the heap what you do is
20:54 - you have essentially a reference to it
20:56 - on the stack so i have my string
20:58 - variable and this is a pointer that is
21:01 - pointing towards the heap and that's how
21:03 - i actually access that data again making
21:05 - it much slower to access and use data on
21:07 - the heap than when it is directly on the
21:09 - stack
21:10 - with that said i will wrap it up here i
21:12 - hope you found this helpful if you did
21:14 - make sure to leave a like subscribe to
21:15 - the channel and i will see you in
21:17 - another one
21:20 - [Music]

Cleaned transcript:

hello everybody and welcome to video 9 in this rust programming tutorial series in this video i'm going to be talking to you about memory management in rust specifically discussing the stack and the heap now this is going to be a general introduction to memory management in the next video i'm going to talk about ownership and then we'll move on and talk about references pointers arrays slices and all of those other things but before we can do that of course we need to understand the stack and the heap i'll also say that if you are getting confused here i will recommend that you read the official rust documentation it is a little bit difficult if you don't understand some of these concepts already but it may clear some things up if this video is giving you you know a good understanding but you just want some more detail so i'll link that in the description and with that said we can dive in here now i do of course need to remind you to check out programming programmingexpert.io from the link in the description we teach all kinds of advanced programming concepts stuff similar to this as well just for other programming languages like go and python with that said though we can get in here so on my screen you can see that i have a stack i have a heap and i'm kind of indicating that these are all part of ram which is random access memory i also am going to have a few photos on the left hand side of my screen which will be examples that we'll walk through as we go through this video now the first thing to talk about here is what i mean by memory management and some of the considerations or concerns you may have when it comes to writing information to ram and reading information from ram as well so whenever we run a program or executing that on our machine we need some space in ram where we're going to store the data associated with our program so we have a very basic program over here but in this case we would need some location in ram where we can store the value of the variable x right now in most programming languages we don't really consider what happens when we write a statement like this we just know that okay this data is going to get stored somewhere i can then retrieve it later on by using the variable name x and you don't really care beyond that now in rust this will be handled for us automatically as well but we do kind of want to understand what's going on a bit more just because this is a systems programming language and we have some more lower level control here in rust than we would in a language like python or javascript or something along those lines so we just want to know kind of what's going on when we actually do something like let x equals two how that's getting allocated in ram and how we're retrieving that information and all of that kind of stuff so when it comes to doing this right storing information and ram there's a few concerns the first concern is that wherever we store this information we want it to be easily accessible we want to be able to find it very quickly we don't want to be searching in ram and spending a lot of time trying to find this data the second thing is we don't want to be duplicating this data or taking up any more space in ram than we have to so for example here i wouldn't want to have multiple you know x equals 2 in my ram because we're using up more space than we have to be we also want to make sure that we only have this data in ram when we need to be using this data if i'm never going to be using this variable let x equals 2 or i've already used this data and i'm no longer going to be using it in the program i probably want to remove it from ram and we need to have a way to do that now that concern specifically is something that is dealt with in a different way in many different programming languages for example in java we have something called a garbage collector which will automatically delete data from ram when it's no longer referenced in the program other languages implement different styles or different types of doing this and in rust we have kind of a unique way as well which i'll talk about a bit in a second okay so hopefully that gave a general introduction here but as you can see in rust we have two different sections of ram now that's going to be our stack and our heap now the stack works similarly to a stack you would have learned about in your data structures and algorithms course where the last piece of information in is the first piece of information out so you can think of like a stack of plates where if i have three plates like this the plate that i put on the top that was the most recent plate to be added will be the first plate to come off of the stack because it's at the top now this also has an official name that is lifo or philo now lifo stands for last in first out and philo is first in last out so you can apply whichever one you'd like there to try to remember this concept but keep that in mind the last piece of information in is the first piece of information out when we use a stack now we have the heap now the heap is not really at all similar to the heap data structure that you'd be familiar with from a data structures and algorithms class so for now just understand we have kind of a separate section here called the heap but don't try to visualize it like you would kind of a traditional heap that you would have seen in in data structures and algorithms okay so we have these two pieces of information or sorry two kind of sections of ram and they're used for different purposes now the fastest piece of ram or thing that we have in rust here is the stack so ideally we want to put everything that we possibly can onto the stack and then we use the heap when we need to use the heap for kind of a dynamically sized object which i'll talk about in a minute for now they'll understand that the stack is the fastest and we want to prioritize using the stack when possible however sometimes we need to defer the heap and use that and again i'll go through all those details just trying to give you a general introduction here so now that we have that understood let's kind of ignore the heap for right now let's just look at the stack and let's see what happens when we run a basic program like this in terms of storing information on the stack and again remember the stack is a part of our random access memory so what we can see in the stack here is that we have kind of these little boxes right now this is just my visualization this is not exactly what a stack is going to look like but we will have some address associated with every kind of box or space in our ram or in our stack now this address is how we'll access different information and each piece of information will have its unique address right so just kind of keep that in mind the addresses will be much longer than this i'm just going with very basic ones again for the video and the explanation so we have this program here we say function main and we say let x equals two now when we have let x equals 2 we need to store this in ram so what we do is we go to the stack we place a name x here and then we place a value 2 and we put this on the top of the stack now the top of the stack will just represent the most recent piece of information that we've added to the stack right and then when we add more we'd add like this and when we removed from the stack we'd remove whatever the most recent piece was and keep going kind of down the stack if that makes sense for now though we have x equals two that's been added onto the stack so now that we've placed this here if we use x later on in our program like we print it out we can just access it directly from ram and use it however what happens when this function is finished executing what do we do with x equals 2 on our stack well we need to remove it and the way that this works is that x here is within a scope now the scope is the function that is defined inside of or the block that is defined inside of so in this case we have function main and that means that x since it's defined inside of these curly braces here is a part of this main scope so that means that once this scope is finished executing or we're outside of the scope outside of the main function we need to remove x from ram and russ will do that automatically for us so let's say you know we execute x here we do whatever we want with it then we get to this line right here kind of where i put this double slash although i could have i guess just put an arrow then what we're going to do is remove x from ram so we remove it like that and there you go we've kind of garbage collected or got rid of information and ram that we're no longer using now i know this seems extremely basic right now we're going to go into some more advanced examples but this is the basic concept right we go through a function we see a statement like this let x equals 2 we then add x into ram and then as soon as we're outside of the scope where this information is being used we automatically remove it from ram or from our stack so i've just placed another example on the screen here and we're going to go through this in a second but i do want to mention that the stack is only capable of holding information that has a known and fixed size now that essentially means that we can't store anything on the stack that could change size later on and then we can add stuff to delete stuff too we can't store for example a dynamically sized array on the stack or a dynamically sized string you can only store anything that has a fixed size and for now a fixed size would be something like 2 or 3 or the value true right like a boolean or a float all of those are fixed size they're not going to change throughout the program whereas we could have some data structures that we haven't yet looked at that can change size and that's where the heap comes in and where we need to store those hopefully that gives a bit of clarity uh but that is kind of why we can't just use the stack for everything although for now with the examples we have we will just be using the stack okay anyways we have two lines of code now in this main function and i just want to show you again what happens here when we run through the code so we're first gonna create a space here on the stack where we have x equals two then we're gonna create another space on the stack where we have y and we're gonna copy the value from x here directly into this box and we're going to have 2 as well now we do this because this is an immutable value which means i just make a copy of it so i have the copy right there so now i have x and y on my stack notice i placed x first and then i placed y because that's the order in which i saw them here as i was reading through these lines of code so now let's imagine that we get to the end of this main function here we are no longer in the scope in which these two things are defined and so we need to remove them from ram so how do we do this well we need to essentially pop off the stack so we're going to start by popping this element off which is the top of the stack the most recent element that was added and then we're going to pop this one off so i can just delete these i'm gonna delete that we pop the first element off and then i'll delete this we pop the second element off and there you go that's all that's involved in adding kind of these integer values onto our stack now let's do a more advanced example where we have multiple functions and see what happens there with those stacks all right so i've just placed another example on my screen here where now we have a function call and let's look at what happens with the stack i can go relatively fast because we've already looked at kind of this main example so we start by defining x and y they're both going to have the value 2 here on our stack then we call this example function and when we call this example function we're going to go inside of here and start executing the code and just like we added information onto the stack from the main function we're going to do the exam the same for example so we're going to have a here and that's going to be equal to true excuse my messy handwriting and then we're going to have b here and that's going to be equal to false and again notice that i'm adding them kind of in order in which i'm viewing them on the stack so now this element here b is the top of the stack and if i start removing things from the stack or popping them off this will be the first thing to be removed so now i'm in example right i've executed this code let's go back to white here and i reach the end of this scope so now i'm outside of this scope so that means i need to pop all the elements off of the stack that were a part of this scope so a and b i'm no longer using them i need to pop them off so i do that right we pop one at a time we pop b this comes off the stack then we pop a that comes off the stack and now we return back to where this function was called and we see that we still have x and y and we still have them here because this function is not yet done x and y are still within the current scope hopefully that's making a bit of sense we have not yet popped x and y because this function is not yet finished execute so now let's say example is done we now reach this line right here now we're going to pop y and x off the stack again in this order because we're now out of the scope so there you go that's the basics on adding item to the stack now if i go back to where we had all of our items on the stack let's just note here that the reason why a stack is very quick is because all of the information associated with the current scope that we're in is simply at the top of the stack we don't really need to search for this information we just know that it's at whatever the top of the current stack is so i'm inside of the example function right now at this point in time and if i need to access a or b i know they're going to be at the top of the stack i may need to look a few elements down to find it but i know that they're here because the information with the current scope is at the top of the stack that's what makes this extremely efficient is this kind of stack data structure and then of course when we finish this function call right here we remove this information from the stack now we're back into this scope and now if i want to access the information in the main function well again i just look at the top of the stack i look at x and y so hopefully that gives you a bit of an illustration of why a stack is a very fast data structure and why we're using that here for managing the memory of kind of our basic variables or basic data types now that we understand the stack though let's have a look at an example where we actually need to use the heap or before we do that we can look at a more advanced function example where we have say parameters all right so i've just pasted another example here on the screen excuse the kind of modification that i've made but you can see that i have this add function it has two parameters x and y and conveniently those shadow the names x and y from the main scope and then i'm calling this add function x y again sorry that it's a little bit janky here but i think you get the idea so on the stack i've already placed x and y and i'm imagining here that we're at this add line so when we come to add here now i want to ask you what happens what's happening with the parameters in this function and how do those get added to the stack or not added to the stack how do we deal with that well whenever we're passing immutable values to a function they're just going to be copied into the parameters so what's actually going to happen here is we're going to add to the stack x and y again and they're going to have the same values of 2 and 2. now the function knows to use this x and y as opposed to using this x and y even though it doesn't matter because they're the same value because it's looking at the top of the stack for variables named x and y when i'm referencing them inside of this function hopefully that makes a bit of sense but that's kind of how the stack works and deals with this name shadowing it's looking for essentially the most recent value on the stack that matches the name that it's looking for so in this case when i try to do something like x plus y nothing has to happen on the stack but we retrieve x and we retrieve y from the top of the stack as opposed to later down and then we see that these are equal to two we use them and then we're going to return a value back here to this add function now i'm not really going to describe exactly how that works in relation to the stack but once this scope is finished then again we're going to pop off x and y now we're back to this main scope where now we have x and y equal to these two values even though again they were the same then once we finished the scope we would pop those off and we would continue okay i just want to show you a quick example there with parameters and kind of the name shadowing now that we've done that i'll drag in one more example that has to do with the heap and we'll see when we would use the heap and why the heap can be slower than using the stack so i've just placed another example on the screen here i apologize that it's a bit small but in this example we're using something called a string now i know we've looked at strings already but there is an important distinction to make here between what this is a string literal that has double quotation marks and the string from now the double quotation mark string is immutable it cannot change in size it's a fixed size and we can store that on the stack however when we use this special kind of string syntax here so string colon colon from this actually creates a dynamically sized string which we can add characters to remove characters from we can change the size of it it becomes a dynamic size so since we're using this string from something we haven't yet seen before we need to store this on the heap we can't store this on the stack because we can only store something that's a fixed size on the stack so again if it was just this double quotation mark string we could put it on the stack but since it's not it's this special string object here a special string type we need to instead store it on the heap so you can see i've already kind of skipped step one here where we have x is equal to two and i put that on the stack but now we have this string and we need to store this string on the heap so what actually happens when we want to store something on the heap is we need to refer to or use something called the memory allocator which is going to find space on the heap for us where we can store this string so just keep in mind this is an important distinction on the stack when we add something we just add it at the top of the stack right if this was another immutable value or something that was a dynamic size i just put one y2 for example like we've seen before and we're good we just add it at the top of the stack however with the heap we actually need to search through the heap and look for a location that's large enough to hold what it is that we want to store so we're allocating space we're looking for space on the heap now this is much more time consuming than the stack because we actually have to look through the heap right there's something we have to do to be able to place something on it whereas on the stack we just immediately place it on the top so we go to the memory allocator it then kind of gives us a location on the heap where we're able to store this and then we place that string onto the heap now in terms of the name here this is kind of irrelevant when it comes to the heap i'm just going to put the value here as hello if i can get that in okay so that fits in nicely and now what happens is we actually get what's known as a pointer to the value on the heap so let me just write this out and then i'll explain this we're now going to have string that's the name of our variable that's going to go on the stack and instead of storing hello inside of here we're instead going to have a pointer that's going to point to the location of this string in the heap again we're just pointing to where it is in the heat so now if i actually want to access the value of the string i need to find the address or the location in the heap where the string is stored i then need to go to the heap i need to retrieve the value and then i can use it or i can modify it or do whatever i want with it whereas if i'm just getting something directly from the stack all i have to do is grab the value whereas here there's kind of a little road map or it's giving us an address or a pointer to where this information is actually stored we're going to look at this more in detail later on but that's what happens with the heat the heap is not as organized as the stack and it's just essentially mapping values to an address and then we use that address to access the value from the stack so we store the name of the variable here it has the pointer this actually stores the value and again the reason we need it on the heap is because we need to have kind of a dynamic sizing or a space that's large enough to fit the value which we had to search through in the heap to find so in summary here storing something on the heap is slower than storing something on the stack because we need to search for space to be able to store it it's also slower to access something on the heap than on the stack because we need to follow a pointer to find that information and contemporary processors like the standard processors we use today are much faster at accessing data that's close together in kind of an organized block than to potentially be randomly kind of jumping around a heap looking for data so that's why i've been putting a ton of emphasis here on the stack and the speed of the stack as opposed to the heap now you cannot always use the stack of course in this situation we needed the heap but the point of knowing this is that you want to optimize your programs to use the stack as much as possible and avoid using the heap where you can or understand the performance kind of hits you're going to have by using the heap now with all of that said russ is a very fast programming language there's not really a problem with using the heap you can do that and we're going to be doing that many times you just want to understand where your information is is it on the stack is it on the heap how do i retrieve that what is a pointer and kind of the basics of how information gets cleaned up or data gets cleaned up from random access memory either being on the heap or being on the stack now with all of that said i think i'm going to start wrapping up the video here in the next video i'm going to discuss something with you called ownership which is going to bring all of this full circle and talk to you about why it was important to actually understand the difference between the stack and the heat for now all you need to know is you store fixed size data on the stack you store dynamically sized data on the heap and then when you need to access data on the heap what you do is you have essentially a reference to it on the stack so i have my string variable and this is a pointer that is pointing towards the heap and that's how i actually access that data again making it much slower to access and use data on the heap than when it is directly on the stack with that said i will wrap it up here i hope you found this helpful if you did make sure to leave a like subscribe to the channel and i will see you in another one
