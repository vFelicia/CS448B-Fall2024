With timestamps:

00:00 - hello everybody and welcome to python as
00:03 - fast as possible
00:04 - in this video i'm going to be trying to
00:06 - teach you python as quickly as i
00:08 - possibly can
00:09 - that means i am going to go over things
00:11 - quite quickly i'm going to talk very
00:13 - fast
00:13 - and i will note that this is not for
00:15 - absolute beginners if you are looking
00:17 - for a beginner level tutorial series i
00:19 - have many on my channel
00:20 - i will link a ton of resources down
00:22 - below and if you feel that i missed
00:24 - anything or made any mistakes please do
00:26 - leave a comment with that being said
00:28 - let's go ahead and get started and get
00:29 - into python as fast as possible
00:34 - [Music]
00:40 - to get started we need to download and
00:42 - install python please download the most
00:44 - recent version of python from the python
00:46 - website which will be linked in the
00:48 - description
00:48 - if you're using any version of python
00:50 - which is below 3.6 that will not be
00:52 - compatible with this tutorial
00:54 - when downloading please check the box
00:56 - that says add python
00:58 - to path this will make your life easier
01:00 - in the future now python
01:01 - automatically comes with its own
01:03 - environment to write code in this is
01:05 - idle
01:05 - you can use this to write your code if
01:07 - you'd like but i prefer to use visual
01:09 - studio code which is a text editor
01:11 - to download that you can go to the link
01:12 - in the description and just download the
01:14 - stable build for whatever operating
01:15 - system you're on
01:16 - now if you're using vs code there is one
01:18 - little bit of setup we need to do to get
01:20 - started here
01:21 - we simply need to install the python
01:22 - extension go to the extension tab here
01:25 - this will bring us to the vs code
01:26 - marketplace
01:27 - we can type python and then we can see
01:29 - the python extension and simply press
01:31 - install you can see for myself i already
01:33 - have it installed
01:35 - so before we get started i thought it
01:36 - would be a good idea to talk to you
01:38 - about some of the things that python is
01:39 - used for
01:40 - here i am on my channel in the playlist
01:42 - tab and you can see a bunch of different
01:43 - playlists just giving you an idea
01:45 - of some of the things that i've created
01:46 - with python and taught on this channel
01:49 - python is a general purpose programming
01:51 - language it is very easy to learn
01:53 - versatile and really easy to write in
01:56 - the core advantage of python is
01:57 - typically how simple it is
01:59 - how easy the syntax is to read and just
02:01 - how fast development is
02:02 - with it that being said python is mostly
02:05 - used on the web and in machine learning
02:07 - artificial
02:08 - intelligence and data science related
02:10 - tasks now the sponsor of our video knows
02:12 - a ton about that and that is
02:14 - simply life i need to thank simply learn
02:16 - for sponsoring this video and giving you
02:18 - all a discount on their data scientist
02:19 - master program that was co-developed
02:21 - with ibm
02:22 - this program is comprised of six unique
02:24 - courses that implement a unique
02:26 - blended learning experience in a high
02:28 - engagement online classroom environment
02:30 - during this program you will master 30
02:32 - plus in-demand skills and work with
02:34 - tools and languages like r sas
02:36 - python tableau hadoop and spark you'll
02:39 - master these skills through 15 real life
02:41 - projects
02:42 - and one capstone project during this 12
02:44 - month
02:45 - comprehensive course you'll also be
02:47 - given 1200 usd worth of ibm cloud
02:49 - credits
02:50 - to use during your 24 7 access to the
02:52 - ibm watson platform
02:54 - after completion of this course you'll
02:55 - be given certificates from ibm and
02:57 - simply learn to testify to your skills
02:59 - as an expert in data science
03:01 - get started by hitting the link in the
03:02 - description i want to start by covering
03:04 - the core data types in python
03:07 - these are int float string and bool and
03:09 - otherwise known as
03:10 - integer now an integer or int is simply
03:13 - any whole number
03:14 - that does not have a decimal point on it
03:16 - so two three seven
03:17 - three seven that was going to be an int
03:19 - negative nine that's an inch negative
03:21 - some random large number is an int so
03:24 - long as it does not have a decimal point
03:26 - on it
03:27 - we consider it an int a float is almost
03:29 - the opposite of that
03:30 - it is simply any number that has a
03:32 - decimal point on it so something like
03:35 - 272.00 this is a float even though you
03:37 - can would consider this a whole number
03:39 - the point zero adds a level of precision
03:41 - to this which makes it a float
03:43 - of course something like 9.7 would be a
03:45 - float whenever you see a decimal point
03:47 - that means the number is a float
03:50 - next we have string a string is simply
03:52 - anything surrounded by single or double
03:54 - quotation marks
03:55 - typically we consider this a sequence of
03:57 - characters or
03:59 - numbers so if i type something like
04:00 - hello and i type something like hello
04:03 - these two strings are actually
04:04 - completely equivalent it does not matter
04:06 - whether you use single or
04:08 - double quotation marks there is no
04:10 - difference i will note that if you want
04:12 - to embed
04:12 - a double quotation mark or a single
04:14 - quotation mark in the actual string
04:16 - itself
04:16 - then you would usually wrap the string
04:18 - with the opposite type of quotation mark
04:20 - so in this case i want to have this
04:21 - double quotation mark inside the string
04:23 - so i wrap the string with single
04:25 - quotation marks now just to note here if
04:27 - i do something like 4.6
04:29 - even though you might consider this a
04:30 - float this is a string
04:32 - again because it is surrounded by single
04:34 - or double quotation marks
04:35 - remember the definition anything defined
04:38 - or surrounded sorry by single or double
04:40 - quotation marks
04:41 - next we have boolean this is one of two
04:43 - values
04:44 - we have true or we have false some
04:47 - people may consider this one and
04:48 - consider this zero we're going to look
04:50 - at these later on and you'll see why
04:51 - that's important
04:52 - but that is a boolean value and these
04:54 - are the four core data types in python
04:57 - the next topic i'd like to cover is
04:58 - output and printing this is very
05:00 - important and we will be doing this a
05:02 - lot in this video
05:03 - in python there is a simple function
05:05 - called print this is how you output
05:07 - something to the console when you run
05:08 - your program
05:09 - typically when you print something
05:11 - you'll put it in strings so i want to
05:12 - print say hello world
05:14 - so i will print the string hello world
05:15 - like that and if i run my program by
05:17 - pressing this run button
05:19 - you can see down here in the console we
05:20 - get hello world now notice that if i
05:22 - just type hello world like this and i
05:24 - don't put it inside of a string
05:26 - and i run my program i will get an error
05:28 - this is because i cannot simply print
05:30 - something like this the program does not
05:32 - know how to interpret hello world
05:34 - if it is not wrapped in strings that is
05:36 - because this is not one of the core data
05:38 - types and we have no variable or
05:40 - anything that denotes what hello world
05:42 - is that being said if i want to print a
05:44 - number say like 4.5
05:46 - python knows what 4.5 is because it is a
05:48 - float you can see when i highlight it it
05:50 - says float
05:51 - if i run this it will print 4.5 out and
05:54 - there will be
05:54 - no problems now if you want to print
05:57 - multiple things what you can do is
05:58 - separate them by commas
06:00 - so say i'd like to print 4.5 and then i
06:02 - would like to print hello
06:03 - when i do this it will automatically add
06:05 - a space between the two things
06:07 - let's just put another string here just
06:08 - to show you what i mean so 4.5 hello
06:11 - notice it adds that space in between now
06:14 - we will talk about how you can print
06:15 - things without the space in between
06:17 - later on but that is the basics of a
06:19 - print if i want to print many things on
06:21 - the same line i can go hello
06:23 - i could say end i can say 87
06:26 - i can say false and i can run this
06:30 - and this will all work hello and 87
06:32 - false now there's a few arguments that
06:34 - you can pass
06:35 - into the print function if you do a
06:37 - comma and then type
06:38 - end equals you can denote what you want
06:40 - the end of this print statement to be
06:42 - by default the end here is a carriage
06:44 - return which is backslash n
06:46 - what that means is go to the next line
06:49 - after this line is printed
06:51 - now notice if i don't add this backslash
06:52 - enter in fact let me just show you what
06:54 - happens
06:54 - by default so let's say i have hello and
06:57 - 87
06:58 - i'm going to get rid of this and i print
07:00 - both these things out we get these on
07:02 - two
07:02 - separate lines that is the default
07:04 - behavior of the print statement and
07:05 - prints on a new line
07:07 - now notice if i add end e end equals
07:10 - and instead of a backslash n let's say
07:12 - uh this pipe like that and i run this
07:15 - now at the end of the print statement it
07:17 - simply prints a pipe
07:18 - it does not add the carriage return
07:20 - which means we do not move on to the
07:21 - next line
07:22 - that's a little bit more advanced but
07:23 - essentially the carriage return is that
07:24 - backslash n
07:25 - and again that means just move down to
07:27 - the next line
07:28 - that is the basics of printing and
07:30 - output and now let's move on
07:33 - next let's move on to variables
07:35 - variables are an important part of any
07:36 - program
07:37 - in python they are quite easy to create
07:40 - when you create a variable in python
07:42 - you simply type a variable name a space
07:44 - an equal sign
07:45 - and then assign it to some value this
07:47 - value is going to be some
07:49 - data type some function something else
07:51 - that we'll talk about
07:52 - later on to give you a basic example i'm
07:54 - going to set the variable hello equal to
07:56 - the value 10.
07:58 - think of a variable like a bucket that
08:00 - stores some data or stores some type
08:02 - now if i want to access the value that
08:05 - is stored in hello
08:06 - what i can do is i can simply say print
08:08 - hello
08:09 - what this will do is it will say okay
08:11 - this is a variable
08:12 - i know it's a variable because i saw it
08:14 - earlier on the program
08:15 - let me see what its value is and i will
08:18 - print that value
08:19 - so now i'm going to run and you can see
08:21 - that we get tim
08:23 - let's make another variable let's call
08:24 - this world let's actually set this equal
08:26 - to the value world
08:28 - now let's print hello comma world and
08:30 - let's see what we get
08:31 - we get tim and then space world
08:34 - variables are somewhat complex
08:36 - you can make them equal to other
08:37 - variables if i decide to change the
08:39 - value
08:40 - of world to actually be equal to the
08:42 - variable hello what's going to happen is
08:44 - it's going to say okay hello is a
08:45 - variable
08:46 - what is a low equal to hello is equal to
08:48 - tim so i will print
08:50 - tim now watch what we're going to get we
08:52 - get tim tim
08:53 - now what happens if i come here and i
08:55 - change hello to be equal to
08:57 - no if i do this what's going to happen
09:00 - is world will not change because world
09:02 - was set equal to the value of hello
09:04 - at this line at this point in time line
09:07 - three
09:07 - because our program reads from top to
09:09 - bottom
09:10 - the value of hello was tim so world gets
09:14 - set to tim
09:15 - then hello gets set to no that does not
09:17 - change the value of world so what you're
09:18 - going to see is we're going to have
09:20 - tim and then we're going to have no so
09:22 - let's have a look here and sorry other
09:24 - way around we get no
09:25 - tim my bad though we printed a hello
09:27 - first and then world i have that mixed
09:29 - up
09:29 - that is the basics of variables there's
09:31 - many other things that we can do with
09:32 - them
09:33 - but let me just tell you about the
09:34 - naming conventions for them
09:36 - so in a variable you are not allowed to
09:37 - have any special characters and you
09:39 - cannot start with a number
09:41 - so you are allowed to have an underscore
09:42 - that is the only exception in terms of
09:44 - special characters
09:45 - usually you will use that when you are
09:47 - denoting a space and in python the
09:49 - convention is typically to separate
09:50 - things using an underscore
09:52 - in other languages you may see something
09:53 - like hello world if you wanted to make a
09:55 - variable
09:56 - uh that has multiple words in it but in
09:58 - python stick with snake case which is
10:00 - what this is known as the other one is
10:02 - camelcase and use underscores to
10:04 - separate your variables just to give you
10:06 - an example of what i mean you cannot
10:07 - start a variable with a number so
10:09 - 9 hello notice i'm getting the red line
10:11 - popping up here
10:12 - and i could not do something like hello
10:14 - 9 that does not work but
10:15 - if i want to hello world 32 that is
10:18 - totally fine that is a valid
10:19 - variable name the next topic i want to
10:21 - talk about is getting user input just
10:23 - like printing something is very simple
10:25 - getting input is simple as well
10:26 - what we do is we simply use the input
10:28 - function we have our open and close
10:30 - parentheses and then we type what's
10:31 - known as a prompt
10:32 - inside of these brackets like this now
10:35 - this does need to be in a string
10:36 - unlike the print statement we cannot do
10:38 - something like 4.5 in here that will not
10:40 - work
10:41 - we do need a string so what i'm going to
10:43 - do is i'm going to add a prompt
10:44 - say i want the user to type their name
10:45 - then i will say name i'll do a colon and
10:48 - then i will add a space between the
10:50 - colon and the end of the string
10:51 - the reason for this is that the user
10:53 - will be able to start typing
10:55 - on this line right after the prompt so
10:57 - if i don't have a space then what's
10:58 - going to happen is the user will start
10:59 - typing
11:00 - right where the colon is which of course
11:02 - is not going to be good so let's go
11:03 - ahead and run this and have a look at
11:04 - what happens we can say name
11:06 - colon space and now i'm going to type
11:08 - tim that's great but how do we actually
11:10 - get the value how do we store what the
11:12 - user typed in so we can use
11:14 - it later well we need to assign this
11:16 - input to a variable
11:17 - so what i'm going to do is i'm going to
11:18 - say name is equal to input
11:21 - i just want to note because i forgot to
11:22 - say this previously we could have
11:23 - capitals in
11:24 - our variable name if we want that would
11:26 - be fine but i'm not going to do that
11:28 - and now what will happen is whatever we
11:29 - type in will be returned to us
11:32 - in this statement as a string and it
11:34 - will be assigned to this variable name
11:36 - so if i go ahead and print the value of
11:38 - name what's going to happen is whatever
11:39 - we type in here
11:40 - will be printed out so let's have a look
11:42 - at this name let's type tim
11:44 - and we see that tim is printed out below
11:47 - there
11:47 - now we of course can get multiple user
11:49 - input so i can say something like age
11:50 - equals
11:51 - input age colon and now let's see what
11:54 - happens
11:55 - when i run this so we go name tim age
11:58 - 20 and we could put print those out if
12:00 - we want but i'm not going to
12:02 - actually you know what let me show you
12:03 - one example where i print them out let's
12:04 - say
12:05 - hello and then let's go comma name
12:08 - and then you are comma
12:12 - age years old so this is a way that we
12:15 - can combine variables and strings so
12:17 - that we print out a meaningful response
12:18 - that says hello whatever the name is
12:20 - you are whatever the age is years old so
12:22 - in this case i'll say
12:23 - name tim age let's go 12 and says hello
12:26 - tim you are 12 years old
12:28 - all right so that is it for input now
12:30 - we're going to move on and talk about
12:31 - how we can actually convert
12:32 - say numeric input into a integer or
12:35 - float because it default comes back as
12:38 - a string all right so the next topic i
12:39 - want to cover is arithmetic operators
12:42 - these essentially are like plus minus
12:44 - multiplication exponent how you perform
12:45 - mathematical operations in python
12:48 - now just something to keep in mind when
12:49 - we're performing and using arithmetic
12:51 - operators
12:52 - we have to make sure that the data types
12:54 - on the left and right hand side of these
12:56 - operators otherwise known as the
12:57 - operands are the same data type or are
12:59 - both
13:00 - numbers what i mean by this is if i have
13:02 - something like hello and i try to add
13:04 - 9 to it well that just does not make any
13:07 - sense and we are going to get a
13:09 - error and something's going to be wrong
13:10 - with our program so just keep that in
13:12 - mind i cannot do hello minus 9.
13:14 - you cannot do hello divided by 9. you
13:16 - actually can use the multiplication you
13:18 - can take a guess at what that's going to
13:19 - do
13:20 - but i will show you that later alright
13:22 - so let's go through the basic operators
13:23 - the first one is the plus sign very
13:25 - straightforward
13:25 - we can add 9 plus 3 or in this case i
13:28 - could add
13:29 - x plus y so x is 9 y is 3. we can add
13:32 - those two values together
13:33 - ignore the squiggly when i save that
13:34 - goes away now something to keep in mind
13:36 - if i make this 3.5 this works totally
13:39 - fine
13:39 - even though these are different data
13:40 - types since they are both numbers i can
13:42 - add them together
13:44 - of course i can do the subtraction let's
13:45 - run that i can do the multiplication
13:47 - which is an asterisk
13:49 - and i can do the division
13:52 - we do the division we get some crazy
13:54 - number just keep in mind that the
13:55 - maximum precision in python i believe is
13:57 - 13 decimal points
13:59 - there is ways to get beyond that but
14:00 - that is kind of too advanced i'm not
14:01 - going to cover that right here and when
14:03 - you ever do division or you're dealing
14:05 - with rounding and all of that
14:06 - that's always a problem in computers so
14:08 - just keep that in mind you're not going
14:09 - to get the most precise answers with
14:11 - division like this
14:13 - if this is a non-terminating decimal
14:15 - point
14:16 - anyways hopefully that makes sense now i
14:18 - just want to point something out if i
14:19 - actually have
14:19 - say 9 over 3 of course you know that
14:22 - that answer is 3 and that is a whole
14:24 - number right 3 is a whole number
14:25 - but this is actually returning to us a
14:27 - float not in int
14:29 - even though neither of these data types
14:30 - are afloat the reason for that
14:32 - is because whenever we use the division
14:34 - operator it returns a float
14:36 - because it does not know if it's going
14:38 - to need to represent a floating point or
14:40 - it's going to have to represent some
14:41 - level of precision
14:42 - so just keep that in mind if for some
14:44 - reason you don't want this to be a float
14:46 - of course you can convert the result to
14:47 - an int by just doing int
14:49 - like that okay so those are some of the
14:52 - basic
14:52 - arithmetic operators next we have
14:54 - exponent so that's two asterisks like
14:56 - that
14:57 - this will raise x to the power y so we
14:59 - can see that
15:00 - gives us 729 and then next we have floor
15:03 - division so what i'm going to do here is
15:05 - actually make this a 10
15:06 - have a guess at what you think this is
15:08 - going to give but this gives us 3.
15:10 - the reason it gives us 3 is because this
15:12 - will give us the integer result of
15:13 - whatever the division is
15:15 - imagine this was like 9.333 or whatever
15:18 - it may be
15:18 - it just simply removes all of the
15:20 - decimal points and just gives or sorry
15:22 - to be 3.333
15:24 - removes all the decimal points and just
15:25 - gives us whatever that integer result
15:27 - is next is mod this is the percent sign
15:30 - this returns to us the remainder after a
15:32 - division
15:33 - in this case 10 mod 3 is going to be
15:36 - well the answer is 9 and then remainder
15:38 - 1
15:38 - right so that is why we get 1 from this
15:40 - here
15:41 - i think that's it for those operators
15:44 - now i will simply show you how we can do
15:46 - say order of operations so if we want to
15:48 - order of operations we can use brackets
15:50 - or if we want to
15:51 - evaluate things in a specific order this
15:53 - does follow the simple order of
15:55 - operations which the acronym i know for
15:57 - it is bed mass which is b
15:58 - e d and i hate this autocomplete it's
16:03 - making it very hard to do this
16:04 - m a s okay so what this stands for
16:08 - is brackets exponents division
16:10 - multiplication
16:11 - addition subtraction python does follow
16:13 - those standard order of operations if
16:15 - you just write an expression
16:16 - but of course it's always easier to use
16:18 - brackets and spread things out so i can
16:19 - say something like x
16:21 - mod y and then i can multiply that by
16:23 - two
16:24 - since i didn't say it the integer
16:25 - division and mod operators are in the
16:27 - lowest order of order of operations so
16:29 - if you use mod that is going to be below
16:31 - addition and subtraction
16:33 - pretty sure that's correct but someone
16:34 - can correct me from the in the comments
16:36 - if i'm wrong about that
16:36 - but anyways you get the point you can
16:38 - use brackets and that is how you can
16:40 - perform and do arithmetic in a certain
16:42 - way all right next thing i need to cover
16:44 - here
16:45 - is simply just an example using input so
16:47 - what i'm going to say is
16:48 - num equals input and we'll just say
16:53 - number colon like that and what i want
16:55 - to do is simply print the result
16:56 - of num minus five so i want to take
16:59 - whatever number they type in and i want
17:00 - to subtract five from it and print that
17:02 - to the screen so let's try it num equals
17:04 - five
17:05 - notice that it says unsupported operand
17:06 - types for minus are
17:08 - four sorry yeah minus string and int so
17:11 - what that's saying is that num
17:12 - is a string even though it looks like an
17:14 - into us i'll explain why in a second
17:16 - and we cannot subtract the number 5 from
17:18 - it that just doesn't make any sense the
17:20 - program doesn't know what to do with
17:21 - that
17:22 - so think about this why is num a string
17:24 - we typed in 5
17:26 - this should be an int value from what we
17:28 - understand about our data types
17:29 - well this input automatically returns to
17:32 - us whatever we type in
17:33 - in a string so just imagine that
17:35 - whatever we do here it's going to give
17:36 - us a string
17:37 - and that means that if we want this to
17:39 - actually be a numer numeric value and be
17:41 - able to perform arithmetic on it we need
17:43 - to convert it to an int
17:44 - so there is this fancy function called
17:45 - ins in python
17:47 - this will take some string assuming that
17:49 - there is an int inside of that string
17:51 - and it will convert it into its integer
17:53 - representation
17:54 - let's have a look now when i type a
17:55 - number let's say 10 of course we get the
17:57 - value 5
17:58 - it took num which was 10 so the string
18:01 - 10 you know i'll type it
18:02 - out like here we have the string 10 and
18:05 - it simply converted that to the actual
18:06 - integer value 10. now you can imagine we
18:08 - have other functions in python that do
18:09 - this as well
18:10 - we have say float that's going to take
18:12 - whatever we have here and convert
18:14 - it into a float now notice what happens
18:16 - when i do this if i do float 10
18:18 - we get 5.0 whenever you have at least
18:20 - one float in your arithmetic it's going
18:22 - to automatically return to you a float
18:24 - it needs to keep the level of precision
18:26 - that was in the original you know
18:28 - operation or in the original value so
18:29 - just that's something to keep in mind
18:31 - whenever you're doing you know plus
18:32 - minus multiplication if there is one
18:34 - float as the operand so on the left or
18:36 - right hand side of the operator
18:38 - then you are going to get a float result
18:40 - back all right that is all i wanted to
18:42 - show for this now let's move on
18:44 - so the next thing i want to cover is
18:45 - something called string methods
18:47 - before i do that though i need to define
18:49 - what a method is
18:50 - so let's create a variable let's make
18:51 - this equal to hello and we can just say
18:53 - hello equals the string hello
18:55 - i want to show you this function called
18:57 - type which will tell us the type of a
18:58 - variable
18:59 - so if i print the type of hello well you
19:02 - can imagine what type this is going to
19:03 - be it's simply its data type let's have
19:05 - a look here we get
19:06 - class string you can ignore the angle
19:08 - brackets in the class if you're more
19:09 - advanced you probably already know what
19:11 - this means but essentially what this is
19:12 - saying
19:13 - is that this string or this variable
19:15 - here hello is an
19:16 - instance of the class string again big
19:19 - words you don't have to know what those
19:20 - mean but for anyone more advanced
19:21 - hopefully that makes sense to you
19:23 - all right so how do we use a method on a
19:25 - string and what is a method
19:27 - well a method simply is something with a
19:29 - dot operator so we have dot
19:31 - we have sum and name whatever the method
19:33 - name is in this case it's going to be
19:35 - upper and then we have an open and close
19:37 - bracket or parentheses whatever you want
19:38 - to call them now i just want to show you
19:40 - what these methods do so if i say hello
19:42 - dot upper this is a method that we can
19:44 - call only on strings
19:46 - so since this is a string i can use this
19:48 - dot upper method
19:50 - on it and imagine what this is going to
19:52 - do what this actually does is it upper
19:54 - cases or
19:55 - puts the entire string in completely
19:57 - uppercase so if i have a look now at
19:58 - hello
20:00 - and we print it out we can see we get
20:02 - hello in all capitals
20:04 - now i don't need to call it like this i
20:05 - also can do hello
20:08 - dot upper now the reason this is going
20:09 - to give me the same thing is because
20:11 - well this is storing the value of the
20:13 - string which is hello
20:14 - and then it was just making an uppercase
20:16 - right here now what happens it says okay
20:18 - well what is hello equal to oh well
20:20 - hello is equal to the string hello
20:22 - so you can think of it as a substitution
20:23 - this string just goes where that is
20:25 - makes it upper and then prints it out
20:27 - there we go upper now let's have a look
20:29 - at what dot
20:30 - lower does you can probably imagine
20:32 - already but it simply makes the entire
20:34 - string lower case
20:36 - these are useful when you're getting
20:37 - user input and you want to validate and
20:38 - check if it's equal to something which
20:40 - we will do
20:40 - later on so a few other methods we have
20:42 - dot capitalize
20:44 - you can imagine what this does it simply
20:45 - capitalizes the first letter in the
20:47 - string and then makes the rest of it so
20:49 - it looks good right so i've had a
20:50 - sentence and i said like hello
20:52 - world like that let's have a look at
20:54 - this it's going to give me hello world
20:56 - properly and if i added
20:57 - a capital w like that it removes that
21:00 - and it just kind of formats it as if a
21:02 - sentence would
21:03 - next we have this method called count
21:05 - what count does is it will count
21:07 - a specific string within the string so
21:10 - it looks for a substring in the string
21:11 - and how many times that occurs
21:13 - let's see i wanted to see how many
21:14 - double l's were inside of this string
21:16 - well i can say hello.count double l and
21:19 - then that will count and tell me how
21:20 - many are in here
21:21 - now have a look and guess how many you
21:23 - think are in here well there's actually
21:25 - zero the reason they're zero is because
21:27 - these are capital l's and this was
21:28 - looking for lowercase l's
21:30 - so that's why it's very important to
21:31 - make sure you're differentiating between
21:33 - capitals and lowercases
21:34 - because two lowercase l's are not the
21:37 - same as two uppercase l's
21:38 - but if i wanted to fix this problem i
21:40 - could make the entire string lowercase
21:41 - so i could say hello dot lower
21:43 - and then i could count all of the double
21:46 - l's in the lowercase string
21:47 - so now let's look at this in this case
21:48 - we get the value one let's make this a
21:50 - little bit better and let's look for all
21:52 - of
21:52 - the is there any other ones that we can
21:54 - look for i guess we can look for how
21:55 - many o's there are
21:57 - all right in that case we get two o's so
21:59 - those are a few basic string methods
22:01 - there are some more but i just want to
22:02 - show you how you use these
22:04 - and the fact that you can chain them on
22:06 - each other because what happens is this
22:07 - will return a string
22:08 - you can imagine that the substitution of
22:10 - this just looks like um you know
22:12 - hello world and then it's going to count
22:14 - all the o's inside of hello world and
22:16 - return to us that value which in this
22:18 - case was
22:18 - 2. all right so now we're going to move
22:20 - on to conditions and conditional
22:22 - operators
22:22 - now before i mention that i just want to
22:24 - go over something that i forgot in one
22:25 - of the previous sections this is simply
22:27 - string multiplication and string
22:29 - addition
22:30 - this is important so i'm just going to
22:31 - cover it quickly but essentially let's
22:33 - say i have a variable and that's equal
22:34 - to
22:35 - hello so x equals to a low i have
22:37 - another variable and this is equal to
22:38 - actually we can say 3.
22:40 - well there's this cool thing in python
22:42 - but what i can actually do is multiply a
22:44 - string by an integer
22:45 - and that will simply repeat the string
22:47 - the integer number times
22:48 - so if i say x multiplied by y even
22:51 - though these aren't the same data type
22:53 - which i said before
22:54 - might cause problems since it's a string
22:56 - and it's an integer and the string is on
22:58 - the left hand side
22:59 - we can do this so i can say how this
23:01 - gives us hello
23:02 - because we multiplied the string by the
23:04 - integer so just something to keep in
23:06 - mind
23:06 - that we also can add two strings
23:08 - together because that actually makes
23:10 - sense so if i say hello and then i say
23:11 - yes
23:12 - well i can add these two together this
23:14 - is known as a concatenation so let's
23:16 - have a look at this
23:17 - and i get hello and then yes so you can
23:20 - do that you can add two strings together
23:22 - and you can multiply a string by an
23:23 - integer just need to throw that in there
23:26 - because that obviously is something
23:27 - that's important to understand
23:29 - all right next we're going to talk about
23:31 - conditions and conditional operators
23:33 - so a condition is simply something in
23:35 - python that evaluates or compares two
23:37 - variables or data types
23:38 - and returns to us either a true or false
23:41 - value based on the comparison
23:43 - so to you know give you an example of a
23:45 - comparison is x
23:46 - equal to y is x less than y those are
23:48 - comparisons and the answer to that is
23:50 - either yes or no or in our case true or
23:52 - false
23:53 - so we have that true and we have these
23:55 - false
23:56 - this is boolean so the result of a
23:58 - comparison is simply a boolean value
24:01 - all right so let's look at what these
24:02 - operators are we have two equal signs
24:04 - which checks for equality
24:05 - is the left-hand side equal to the
24:07 - right-hand side we have not equal to
24:09 - which checks for inequality
24:11 - so is the left-hand side not equal to
24:13 - the right-hand side
24:14 - we have less than or equal to greater
24:16 - than or equal to less than and
24:18 - greater than now there's a few other
24:19 - random ones we're not going to go
24:20 - through those but these are the core
24:22 - conditional operators and let me show
24:23 - you an example of condition let's say i
24:25 - have x
24:25 - equals hello and
24:29 - y equals hello i want to check for the
24:31 - comparison so i might do something like
24:32 - print
24:33 - x equals equals y are these two things
24:36 - the same
24:36 - let's see yes they are we get the value
24:39 - true now let's do the not equal to sign
24:41 - are these things not the same no they're
24:43 - not so we get false that is the basics
24:45 - of checking for
24:46 - equality now what if i add a capital l
24:49 - inside of this string well we know that
24:50 - lowercase and capital l's are different
24:52 - so if i do this
24:53 - we get true which means no these two
24:55 - strings are not the same they are
24:56 - different
24:57 - if i do double equal sign then we get
24:59 - false now interesting thing with strings
25:01 - we can actually compare them using the
25:02 - greater than sign
25:03 - and less than sign now it's not super
25:05 - intuitive so i have to kind of show some
25:07 - more primitive examples here to give you
25:09 - an illustration of how this works but if
25:10 - i have something like a
25:12 - and i say is a greater than let's
25:14 - actually go with capital z
25:16 - what do you think the answer to that is
25:18 - well that's actually true
25:20 - now the reason for that is every single
25:21 - character inside of python is
25:23 - represented by what's known as an ascii
25:25 - code
25:26 - we actually have a look at what this
25:27 - ascii code is by looking at what's
25:28 - called the ordinal value of a character
25:31 - so if i print out the ordinal of z we
25:32 - can actually see that that's 90.
25:34 - if i print out the ordinal of a we can
25:36 - actually see that that's 97.
25:37 - so what that's telling us essentially is
25:39 - that this uppercase z
25:41 - is actually represented by the number 90
25:44 - and the uppercase or sorry the lowercase
25:46 - a is
25:47 - represented by 97. so what we do is we
25:49 - would compare the two ordinal values of
25:51 - these character
25:52 - characters and see that well actually a
25:54 - is greater than z
25:56 - now if we do this so i say a greater
25:59 - than b then that's going to be false
26:00 - because b
26:01 - is actually represented by 98 there is
26:03 - some logical ordering for these
26:05 - characters
26:06 - but i just want you to understand that
26:07 - we can compare strings using greater
26:09 - than less than
26:09 - equal to all of those but just
26:11 - understand that we're comparing the
26:12 - ordinal value of the strings now let's
26:14 - say we have something like a b
26:16 - what we're going to do is simply just go
26:17 - from left to right and compare
26:19 - all of the characters so we would say
26:20 - okay is a greater than b
26:23 - yes it is imagine these two are the same
26:25 - so we had a and then we had d
26:26 - like that if these were the same then we
26:29 - would go on and compare the next
26:30 - character which would be
26:31 - b in this case we get false because
26:33 - obviously the d is greater
26:35 - all right so that is how that works now
26:38 - let's just show a few examples of
26:39 - numbers
26:40 - let's just say 7.5 equals equals 7.
26:44 - is that true obviously that's false
26:46 - let's say 7.5 greater than 7.
26:48 - obviously that's going to be true and
26:50 - what about 7.0
26:52 - equals equals 7. have a look at that we
26:54 - get true
26:55 - all right that is the basics on the
26:57 - conditional operators and
26:59 - conditions of course you can store these
27:00 - things in variables i can say result
27:02 - equals 6 equals equals 6.
27:04 - and print result
27:08 - like that and we get the value true okay
27:11 - let's move on now to chained
27:12 - conditionals
27:13 - so a chained conditional is essentially
27:15 - combining multiple conditions together
27:18 - to create one
27:19 - larger condition what i have right here
27:21 - is a basic example
27:22 - i have three conditions right i have
27:24 - result one result two and result three
27:26 - result one says is x
27:27 - equal to y result two says is y greater
27:29 - than x and this one said
27:31 - is z less than x plus two you can
27:33 - imagine that these have brackets around
27:35 - it it works the same
27:37 - so all of our conditional operators have
27:39 - a lower precedence than all of the
27:41 - arithmetic operators so if i do
27:43 - something like z minus two
27:45 - less than x plus two well that's not
27:48 - going to say z
27:48 - and then negative 2 less than that it
27:50 - will evaluate on the left hand side and
27:52 - it will evaluate on the right hand side
27:53 - and then it will combine
27:55 - and use sorry this conditional operator
27:58 - so hopefully that makes sense
28:00 - but just keep that in mind that you can
28:01 - actually write expressions on each side
28:03 - of
28:04 - a conditional operator okay so now that
28:06 - we have that
28:07 - essentially what i want to do is say
28:08 - okay how can i make a condition that
28:10 - uses result 1 result 2 and result 3.
28:13 - so obviously all of these are equal to
28:14 - true false true false
28:16 - they're equal to something like that so
28:17 - what i can actually do is use
28:19 - three separate keywords so and or
28:22 - oops and not so these three words are
28:25 - what i can use to chain conditionals
28:27 - together and create larger
28:28 - larger conditions from specific
28:31 - conditions themselves
28:32 - so what i can do is do something like
28:33 - this i can say result 4
28:35 - equals result 1 or result 2.
28:39 - now what does the or operator do well
28:41 - the left hand side and the right hand
28:43 - side of or have to be a true or false
28:45 - value which they are because these
28:46 - evaluate to true or false
28:48 - what or will do is it will look at the
28:49 - left hand side and right hand side it
28:51 - will say okay
28:52 - if the left hand side is true or the
28:54 - right hand side is true
28:56 - this whole condition is true of course
28:58 - if they're both false that's the only
29:00 - situation
29:01 - where this whole condition here is going
29:02 - to be false so in three scenarios
29:04 - because there's four possible scenarios
29:06 - here
29:06 - it's going to be true and the other
29:07 - scenario it will be false so if both of
29:09 - these are true
29:10 - obviously at least one of them was true
29:11 - so that evaluates to true so let's
29:13 - actually just print
29:15 - result 4 and have a look at it great we
29:18 - get true
29:18 - now what we can do is we can add another
29:20 - or if we want and we can say result 3.
29:23 - now what this says is ok if result 1 or
29:26 - result 2 or result 3 is true this whole
29:28 - thing is true which of course it is
29:31 - now let's see how we can combine other
29:32 - stuff into this we can actually use this
29:34 - not keyword what this does is it takes
29:36 - whatever
29:37 - is on the right hand side of it so in
29:39 - this case it's going to be a true or
29:40 - false value
29:41 - and just flips it so in this case if if
29:44 - result 2
29:44 - is true which it is it's just
29:46 - automatically going to become false
29:48 - so if i actually i can show you on a
29:50 - more basic level
29:52 - if i just print a instead of result 4 i
29:54 - print
29:55 - not true like that this will print the
29:58 - value false which you can see down there
30:00 - and if i print not false then
30:03 - this will print true now what i can do
30:05 - is do something like this i can say not
30:08 - false or true so let's have a look at
30:11 - that
30:11 - and there we go we get false so it takes
30:13 - whatever this is which is true
30:14 - and then it just reverses it and makes
30:16 - it with the not now those are two that
30:18 - we've talked about so or and not now
30:20 - what about and
30:21 - so and essentially says okay is what's
30:23 - on the left hand side
30:24 - and the right hand side true if both of
30:26 - it is true
30:27 - they are true the whole condition sorry
30:29 - is true otherwise it is false so only in
30:32 - one scenario out of the
30:33 - four possible scenarios here with two
30:35 - variables or two values on the left and
30:37 - right hand side
30:38 - is this going to be true so let's have a
30:39 - look at this and we get true because
30:41 - obviously this is false
30:42 - then we nod it and that turns to true
30:44 - now of course we can do a combination of
30:46 - and and or now when we use these
30:49 - combination of different things right so
30:50 - not and or we have to know which is
30:53 - going to come before what so kind of in
30:54 - the order of operations
30:56 - now the way it actually goes is not is
30:58 - first and
30:59 - is second and or is last so just keep
31:02 - that in mind because that will be
31:03 - important based on the way that you
31:04 - write your expression so essentially if
31:05 - i say false and true or true
31:08 - then what we're going to actually do is
31:09 - evaluate the false and true
31:11 - first and then we will evaluate the or
31:14 - of whatever this is
31:15 - and then that so in this case this would
31:17 - be false so then we would get false or
31:19 - true and then this would turn
31:20 - into true then we would have the not
31:23 - and that would turn that into the false
31:26 - so now we're moving on to the fun stuff
31:28 - which in my opinion is the if else if
31:30 - and
31:30 - else statement now this essentially
31:32 - allows us to actually check
31:34 - if something occurs or if a condition is
31:37 - true
31:37 - and if that is true we can do something
31:39 - specific
31:40 - otherwise we might not do anything or we
31:42 - might do something differently so for
31:44 - the example i'm going to do here i want
31:45 - someone to type in their name
31:47 - and i want to say if their name is equal
31:49 - to in this case tim
31:51 - i will tell them they are good at python
31:53 - i don't know something random
31:54 - so in this case to do that what i will
31:56 - start doing is writing an if statement
31:58 - so the syntax of an if statement is if
32:00 - condition like that i know that's
32:03 - spelled wrong but that's fine condition
32:05 - colon indented block whatever i want to
32:08 - happen in the indented block and then
32:10 - that is
32:10 - the basic syntax of the if statement so
32:12 - for here if i want to check if
32:14 - x is equal to tim i will say if x equal
32:17 - equal to and then the string tim with
32:19 - the capital t
32:20 - i will simply print you are
32:24 - great so now what will happen is if and
32:28 - only if x is equal to tim will i print
32:30 - you are great
32:31 - now in any situation so regardless of if
32:34 - the name is equal to tim or not i will
32:35 - always do this so i will print that
32:37 - statement
32:38 - hopefully that's self-explanatory so
32:39 - let's go ahead and do tim we can see you
32:41 - are great always do this
32:42 - now let's do another name let's go with
32:44 - joe and it says always do this it did
32:46 - not
32:47 - print this statement now the addition to
32:49 - the if statement is of course i can add
32:51 - more stuff
32:52 - underneath this indented block so i do
32:54 - another print statement and that would
32:56 - add a space so let me actually just show
32:57 - you how this works if i do
32:59 - tim now you see we get that space by
33:01 - just printing an empty
33:03 - print statement essentially okay now
33:05 - what we can do though is we can say okay
33:07 - how about i only want to print you are
33:10 - great
33:10 - or i want to print some other message i
33:12 - don't want to print two things
33:13 - well what i can do is i can print i can
33:15 - add this else this else
33:17 - must come after an if statement and
33:19 - essentially what it allows me to do is
33:20 - say okay
33:21 - if this isn't true do this so it's an if
33:24 - else right if true
33:26 - do this otherwise do this never will i
33:29 - do both
33:29 - so in this case i'll just print no you
33:32 - know not very
33:33 - intuitive or it doesn't really make much
33:34 - sense but that's fine so now
33:36 - i'll go ahead and i'll say name tim
33:39 - it says you are great and let's actually
33:41 - just go with no and then
33:43 - it prints out no all right so that's the
33:46 - basics on the if
33:47 - else now let's say we actually want to
33:49 - check multiple things so maybe we want
33:51 - to check
33:52 - a bunch of different names and if the
33:54 - name is joe maybe we want to say
33:56 - you know thanks joe i don't know
33:57 - something random right well what we can
33:59 - do is use this elif
34:00 - statement the l if statement can be used
34:02 - as many times as we want
34:04 - but it must come after an if and it must
34:07 - be before
34:08 - any elses so i can't just go ahead and
34:10 - start writing these random elifs
34:11 - everywhere
34:12 - it only is going to come after an if
34:13 - statement so there's only ever
34:15 - one if only ever one else but as many
34:18 - lifts as we want and you'll see how this
34:19 - works in a second
34:20 - so the l of syntax is the exact same
34:22 - except it starts with the el
34:24 - so i'm going to say l if x equals equals
34:26 - joe
34:27 - and i'm going to print by
34:31 - joe why not so now let's run this let me
34:34 - just show you what happens when i go
34:35 - with joe
34:36 - it says buy joe and let's just print
34:38 - something random it gives
34:39 - us no now of course i don't need this
34:42 - else statement
34:42 - i can use an life without the else
34:44 - statement that's totally valid
34:46 - in this situation if i do something
34:47 - random just nothing will happen but if i
34:49 - put tim or joe then it will give me the
34:51 - valid response
34:52 - now let's add another lf let's say lfx
34:55 - equals equals i don't know let's go with
34:56 - sarah
34:57 - we can print random okay
35:01 - and now let's try this out and that
35:04 - works now of course we could add the
35:05 - else at the end but that is the basics
35:07 - for the if
35:08 - l if and else now of course you can
35:09 - chain and add stuff inside of another if
35:12 - statement i could put another if
35:13 - statement inside of this
35:14 - but just make sure you keep the
35:15 - indentation correct because that how it
35:17 - that is how it determines what we are
35:19 - going to be printing and what we are
35:21 - doing
35:22 - if this statement is true so in these
35:24 - next few sections i'm going to be
35:25 - talking about collections how we deal
35:27 - with collections looping over
35:28 - collections and all
35:30 - of that fun stuff but what is a
35:32 - collection well collection is simply an
35:33 - unordered or ordered group
35:35 - of elements now the two collections i'm
35:37 - going to discuss here in this section
35:39 - is list and tuples so if we have a list
35:41 - a list looks something like this it is
35:42 - simply square brackets
35:44 - now inside of the square brackets we can
35:45 - have a series of elements elements are
35:47 - simply some
35:48 - data type so i could have the integer 4
35:51 - i could have the value
35:52 - true i could have some string high and
35:55 - these
35:56 - elements do not need to be the same type
35:58 - like in many other languages so this is
36:00 - a
36:00 - list and the way that the list works is
36:02 - that it can store a bunch of different
36:04 - elements and a list is an
36:05 - ordered collection which means the order
36:07 - in which we enter things into the
36:09 - collection matters and is maintained in
36:11 - fact it's
36:12 - very important in the list so how do i
36:15 - actually access elements in the list how
36:16 - do i deal with the list what are some
36:18 - things we can do with it
36:19 - well of course i can define a list by
36:21 - simply opening up some square brackets
36:22 - and then defining some elements inside
36:24 - i also can just leave square brackets
36:26 - like this empty that would give me an
36:28 - empty list
36:29 - the first thing to look at on a list is
36:30 - this function called len
36:32 - len will tell us the length of the list
36:34 - this also works on strings and a few
36:36 - other things as well
36:37 - but if i look at the len of x that tells
36:39 - me 3. now just to kind of show you here
36:41 - if i say
36:42 - y equals high and i were to look at the
36:45 - len of y after i look at the line of x
36:48 - we obviously get 2. so len is a function
36:50 - in python that we can use to look at the
36:52 - lengths of stuff
36:53 - all right so that is one of the things
36:54 - we can do on a list what we can also do
36:56 - is we can append things to it
36:58 - what a pen does is add to the end of the
37:00 - list so if i want to add say the element
37:02 - hello
37:02 - i can say x dot append now i can print
37:05 - out x and if we have a look we get four
37:07 - true
37:07 - high hello of course we added this
37:09 - element to the end of the list
37:11 - i can also extend the list by another
37:13 - list so let's say i have a list here
37:15 - and inside of this list i have 4 5 and
37:18 - just a bunch of other stuff
37:20 - well when i extend it what that will do
37:22 - is take all of the elements from this
37:23 - list and simply append each of them to
37:25 - the end of the list
37:26 - so you can imagine extend its internal
37:28 - implementation just loops through all of
37:30 - this and
37:30 - appends all of those elements to this
37:33 - list now what about removing something
37:35 - or popping something off of the list
37:37 - well i kind of already gave away what
37:38 - one of these things is but what pop does
37:40 - is remove
37:41 - and return the last element in the list
37:44 - so if i actually go ahead
37:46 - and print x dot pop what this will do is
37:49 - it will print high
37:50 - and it will remove high from the list
37:52 - and you can see that when we print x
37:54 - again so we get high and now our list
37:56 - has high remove because we popped it off
37:58 - of the end
37:59 - now another argument for pop is actually
38:02 - the index
38:03 - of what we want to remove when we look
38:05 - at a list every single element in the
38:07 - list
38:07 - is identified by a number that number is
38:09 - known as its index otherwise known as
38:11 - its position in the list
38:13 - when we start looking at indexes in a
38:14 - list we start counting at zero
38:17 - so the first position in the list is 0
38:19 - the next is 1 and the last is
38:21 - 2. if we want to know the last index in
38:23 - a list we look at the length of the list
38:25 - and subtract 1. in this case we have 3
38:27 - elements the last index would be 2 the
38:29 - first is 0.
38:30 - so if i go ahead and say x dot pop 0
38:32 - what that's going to do is remove the
38:33 - first element from the list which is 4.
38:35 - so now we remove that and all of a
38:37 - sudden if we look at this new list the
38:38 - first element at position 0
38:40 - index 0 is going to be true now if we
38:42 - simply want to access elements of the
38:44 - list maybe we don't want to remove them
38:45 - we just want to look at them
38:46 - we can say x put these square brackets
38:49 - which means we're going to access
38:50 - something
38:51 - and we can put the index of the element
38:53 - that we want to access in this case
38:55 - we'll access true
38:57 - there we go we print true and that is
38:59 - the basics
39:00 - now what i can also do is do something
39:02 - like x 0 equals
39:03 - and change its value to say hello now
39:06 - when i print x we'll get hello true hi
39:08 - let's have a look and there we go the
39:11 - reason i can do this is because lists
39:13 - are what's known as
39:13 - mutable this means this x right here
39:17 - does not actually store a copy to the
39:19 - list it stores what's known as a
39:20 - reference to the list
39:22 - and the actual items itself are stored
39:24 - somewhere else
39:25 - so for people that are more advanced and
39:26 - understand that i'm hoping if you guys
39:28 - have come from another programming
39:29 - language that makes sense
39:30 - but lists are mutable which means they
39:32 - can be changed i can change all of these
39:35 - elements
39:35 - and if i do something like y equals x
39:38 - i go ahead and i make that change to x
39:41 - but i don't make it to y you're going to
39:42 - notice that x and y will be the exact
39:44 - same
39:45 - so i have hello true high hello true
39:47 - high making a modification to x
39:49 - made a modification to y because x and y
39:52 - are storing a reference to this list not
39:54 - a copy of this list if i wanted to copy
39:56 - the list i would have to do this
39:58 - i would have to do two square brackets a
39:59 - colon inside we'll talk about how this
40:01 - works
40:02 - later but now notice if i made this copy
40:04 - that change does not apply to the other
40:06 - list
40:06 - there's a lot of other stuff that you
40:08 - can do with lists but those are the
40:09 - basics and
40:10 - hopefully that makes sense next i'm
40:12 - going to talk about tuples
40:13 - so tuples are similar to lists except
40:15 - they are immutable
40:16 - so a tuple uses round brackets instead
40:18 - of square brackets
40:20 - and it works pretty much the exact same
40:22 - except we cannot append we cannot remove
40:24 - and we cannot change
40:26 - elements so a tuple is really an
40:28 - immutable list you can think of it like
40:29 - that it means it cannot be changed once
40:31 - it has been defined
40:32 - if we want to change it we actually have
40:34 - to redefine it so what i can do is i can
40:36 - print out say x0
40:38 - and that's fine that will give me the
40:39 - correct answer so that will give me zero
40:41 - but if i go ahead and do something like
40:44 - x 0 equals 5 and i try to do that
40:47 - you're going to notice we get an error
40:48 - because the tuple object does not
40:50 - support item assignment
40:52 - reason for that is because again it is
40:54 - immutable i also cannot do something
40:56 - like x dot append
40:57 - i can try but you're going to notice
40:59 - that again we'll get another error
41:00 - tuple object has no attribute append so
41:03 - this is a tuple
41:04 - they're not used a ton although they are
41:06 - used sometimes and just to note here you
41:08 - can have
41:09 - lists inside of lists so i can say
41:10 - something like you know i could have a
41:12 - tuple inside of a list i could have
41:14 - a list inside of a list inside of a list
41:16 - and i could have elements inside of this
41:18 - they don't need to be uniform size
41:20 - sometimes in other programming languages
41:22 - when you're looking at a raise
41:23 - if you have embedded lists every element
41:25 - has to be another list
41:26 - stuff like that just wanted to point out
41:28 - that you can do something like that
41:30 - and i think that's all i'm going to
41:30 - cover right now for lists and tuples all
41:32 - right the next topic i have for you
41:34 - is for loops now a for loop if you've
41:36 - learned in other programming languages
41:38 - allow us
41:38 - allows us to iterate a set number of
41:41 - times
41:42 - so we will be talking about a while loop
41:44 - the main difference between a while loop
41:45 - and a for loop is a while loop is
41:47 - running
41:47 - an indefined amount of times we don't
41:49 - know we're going based off of a
41:50 - condition which we'll see shortly
41:52 - a for loop we know how many times we're
41:54 - going to loop at least relatively
41:56 - so what i'm going to do is i'm actually
41:57 - going to show you how we can just create
41:58 - a basic for loop to print the numbers at
42:00 - from 1 to 10.
42:01 - say 4i in range and then inside of here
42:03 - we simply put 10. i'll talk about what
42:05 - this range function does in a second
42:06 - but let me just show you how the for
42:08 - loop actually operates so now i can show
42:10 - you that this prints
42:11 - 0 1 2 3 4 5 6 7 8 9
42:14 - does not include 10. so the way we set
42:16 - up a basic for loop if we're just going
42:18 - to be iterating through account
42:19 - is we say for i or for some variable
42:22 - this is going to be our iterator or a
42:24 - counter variable whatever you'd like to
42:25 - call it
42:26 - in this is a keyword we always have for
42:28 - i in
42:29 - and then some word here in this case
42:31 - we're going to put range
42:32 - range is a function that actually
42:35 - creates a collection
42:36 - of numbers based on the input that we
42:38 - give it the input to range
42:40 - is the following start
42:43 - stop step so we're allowed to put up to
42:46 - three
42:46 - um and we can have less than three
42:48 - arguments inside of this range function
42:51 - essentially start stop step is saying
42:52 - okay what number do we want to start at
42:54 - what number do we stop at what number do
42:55 - we step
42:56 - at now if we only have one
42:59 - argument so we only pass one number by
43:01 - default that is the stop argument
43:03 - we usually start at zero so by default
43:05 - our range will start at zero
43:07 - and we will go to whatever number we put
43:09 - here most of the times you're just going
43:10 - to put one number and this defines the
43:12 - ending range so in this case it says
43:14 - okay we're going to start at 0
43:15 - and we're going to go up to 10 but not
43:18 - include 10. notice we didn't print 10.
43:20 - now if we had two arguments that's going
43:21 - to be default start stop so we'll say
43:23 - okay
43:24 - we will start here at 1 and we'll stop
43:26 - at 10 but not include 10.
43:28 - if we add 3 we'll include a step and
43:30 - that tells us how much we should
43:31 - increment every single time by default
43:33 - we increment by
43:34 - 1 but we can increment by 2 and we can
43:36 - increment by a negative number as well
43:38 - let's actually say that we want to start
43:41 - at 10
43:42 - and we want it to go to negative 1 and
43:44 - we want to step by negative 1.
43:46 - well let's have a look at what this
43:47 - looks like and just
43:49 - test it out okay so running you see we
43:51 - started at 10
43:52 - right there and then we went all the way
43:54 - down to zero and of course we could
43:56 - start at negative 10
43:57 - and watch what will happen here we do
43:59 - nothing the reason for that is we
44:00 - started at negative 10
44:02 - we were going to negative 1 and we're
44:04 - stepping by negative 1. but since we
44:05 - were already past
44:06 - negative one we aren't going to go there
44:08 - obviously
44:09 - and we just immediately stop so that is
44:11 - kind of how the range function works so
44:13 - for i in range again start stop step by
44:16 - default if you just put one argument
44:18 - that's going to be the stop if you put
44:19 - two that's start stop
44:21 - you can mess around with that and see
44:22 - how it works but i think that's enough
44:23 - of an explanation
44:25 - the next thing we can do is actually
44:26 - loop through a list so let's say we have
44:27 - 4i
44:28 - in and now instead of range we'll simply
44:30 - just put a list we'll say 4i in range
44:32 - and we can do 3 4 and just a bunch of
44:34 - numbers here
44:35 - now if we print i it will simply print
44:37 - all of the numbers in that collection or
44:39 - in that list it will step through one at
44:40 - a time
44:41 - and print all of them now let's say that
44:43 - maybe we didn't want to do that
44:45 - maybe we actually wanted to keep track
44:46 - of what index we were at we could say x
44:48 - equals the list we'd say 4i
44:50 - in x and then um well sorry that
44:53 - actually would not be the right way to
44:54 - do we could say 4i in range
44:56 - the len of x and then instead of just
44:58 - printing i we could print
45:00 - x square brackets i let's have a look at
45:02 - this here you see how that works the way
45:04 - this works is we're going to go up to
45:05 - but not including the last index of
45:07 - x or the length of x sorry so in this
45:10 - case 1 2
45:11 - 3 4 5 6. so this right here will say 6.
45:14 - so for i in range 6 that means the
45:16 - maximum value of i is going to be 5.
45:18 - so we say x 0 x 1 x 2 3 4
45:21 - 5 and print all of the values out now
45:24 - there is another fancy thing that we can
45:25 - do if we want to avoid using that it's
45:27 - called enumerate
45:29 - what enumerate will do is create indexes
45:31 - and values for all of the
45:33 - elements in our list so we'd say 4i
45:35 - comma element
45:36 - in enumerate x and then what i can do is
45:39 - i
45:39 - comma element and you'll see how this
45:41 - works what we do is we get 0 1 2 3 4 5
45:44 - and then all of the elements so this
45:46 - works kind of like a combination of the
45:48 - two for loop styles i just showed you
45:49 - where we actually have a range so we go
45:51 - from zero up to five those are all the
45:53 - indexes in the list
45:55 - and then we print all of the elements
45:57 - for each of those indexes
45:58 - in the list and we just have two
46:00 - variables here that denote that
46:02 - so the next topic to discuss is while
46:04 - loops now while loops are pretty
46:05 - straightforward essentially what they
46:06 - are is while
46:08 - condition equals equals true go ahead
46:11 - and do something so we're going to have
46:13 - some condition
46:14 - here before this colon and then after
46:16 - the colon there's going to be an
46:17 - indented block and whatever's in that
46:18 - indented block will run inside of the
46:20 - loop
46:21 - while that condition is true to
46:22 - illustrate this i will say i
46:24 - equals zero say while i is less than
46:27 - 10 we'll say print run
46:30 - and then we'll say i plus equals one
46:33 - this is another way that you can add one
46:35 - two variables so you could say i equals
46:37 - i plus one or you can do i plus equals
46:39 - one
46:40 - you can also do something like i
46:42 - multiplied equal by 1 or divided equal
46:45 - by 1. so
46:46 - multiplied by equal 2 what that's going
46:47 - to do is say okay multiply i
46:49 - by 2. we could do something like that if
46:51 - we wanted as well just showing you
46:53 - some more syntax for some interesting
46:54 - things that we can do in python
46:56 - but that's the basics of a while loop if
46:58 - i go ahead and run this
46:59 - we can see that this is going to run 10
47:01 - times and there isn't really much more
47:03 - to talk about for the while if other
47:05 - than the fact that we can implement a
47:06 - break statement
47:07 - so we could also write the same code
47:09 - like this while true
47:11 - i plus equals 1 and then if i equals
47:14 - equals 10 break and that will simply
47:17 - break out of whatever the closest
47:19 - loop is to us imagine we had another
47:21 - while loop like this and we said while
47:22 - true
47:23 - inside of here then this would break
47:27 - this while loop not the other while loop
47:30 - hopefully that's making sense
47:31 - anyways let's move on to the slice
47:33 - operator so the slice operator is
47:35 - personally my favorite part of python
47:38 - there is implementations in other
47:39 - languages but none of them are as nice
47:41 - as python in my opinion
47:43 - and what this allows us to do
47:44 - essentially is to take a slice of a
47:46 - collection like a string or a list or a
47:49 - tuple
47:50 - and do something with it so let me just
47:51 - show you what i mean
47:53 - the slice operator is simply the square
47:55 - brackets like this with a sequence of
47:57 - colons and numbers within it
47:59 - the way that it works is we have a start
48:01 - a stop
48:02 - and a step just like the range function
48:04 - that we looked at before
48:05 - so if i put something like x here and
48:08 - then i go start stop step
48:10 - what i can do is say okay i want to
48:11 - start at zero i want to
48:13 - stop at index these are all indexes that
48:15 - we're putting in here three
48:16 - and i want to step by two now actually
48:19 - let me just stop at index 4 just so we
48:20 - get some more values in here but let me
48:22 - show you what this looks like
48:23 - we get the value 0 2 when i have 0 4 2
48:26 - in my slice
48:27 - what this is saying again is start at
48:29 - the first index which is 0
48:31 - go to the fourth index but do not
48:33 - include it which means stop as soon as
48:35 - we hit this and step by two
48:36 - so we're gonna start at zero then we're
48:38 - gonna go to two and then we're gonna go
48:39 - to four but since four is the stop here
48:41 - we're not going to include that in our
48:43 - slice
48:44 - now when we do the slice operator we
48:45 - don't have to include all of these
48:47 - different things as
48:48 - arguments in fact what we can do is just
48:50 - include a stop just include a start and
48:52 - all of that so just like the range
48:54 - function if we don't include
48:55 - anything so we just sorry we just
48:57 - include a colon like that and then we
48:59 - put something on the right hand side
49:01 - that is saying stop at whatever index we
49:03 - put here so if we do this it says start
49:05 - at the beginning and stop at the end now
49:07 - if we do something like
49:09 - 2 colon that says start at 2 and stop
49:12 - at the end so whenever we leave a blank
49:14 - we're assuming it's either the end or
49:15 - the beginning or one in the case of a
49:17 - step so if i did two colon colon
49:19 - maybe i did two colon four colon this is
49:22 - saying okay
49:23 - start at two stop at four and then step
49:26 - by one
49:26 - but i don't even need to include that i
49:28 - could just do two colon 4
49:30 - but now let's say i wanted to go 4 and
49:31 - then colon 2 colon negative 1
49:34 - what this is saying is okay start at 4
49:36 - go to 2 and step by negative 1. so now
49:38 - what this is going to do is start at 4
49:39 - which is actually this
49:40 - and it's going to give us 4 and then
49:43 - three and then it's not going to include
49:44 - two or any of the other ones so that's
49:46 - what we'll get in fact let's look at
49:47 - this we see we get
49:48 - four three now one of my favorite things
49:50 - with a slice operator is to reverse a
49:52 - list all we have to do is colon colon
49:54 - negative one
49:54 - this means start at the beginning stop
49:56 - at the end and then step by
49:58 - negative one so this will actually start
49:59 - stepping backwards which is kind of
50:01 - interesting
50:01 - so when we look at that we get eight
50:02 - seven six five four three two one zero
50:04 - that is an easy way to reverse a list in
50:07 - python
50:07 - now of course all this works on a string
50:09 - as well let me show you that with s
50:11 - you see we can reverse the string like
50:12 - that and we can also just do
50:15 - the standard arguments that we would
50:16 - typically do let maybe we'll just step
50:18 - by two so start at the beginning stop
50:20 - at the end and step by two we get hlo
50:24 - so that's the basics of the slice
50:26 - operator there's a bit more stuff that
50:27 - we can do with this but
50:28 - that is kind of how it works and i
50:30 - believe this works on tuples as well
50:33 - we can just try it out to make sure that
50:34 - i'm not lying to you guys but if i do
50:36 - that you can see
50:37 - that that does indeed work and we can
50:39 - use the slice on kind of any collection
50:41 - of elements all right so now we are
50:43 - moving on to sets which are an
50:45 - underrated but extremely useful data
50:47 - type in python
50:48 - now a set is simply an unordered unique
50:50 - collection of
50:51 - elements what that means is there is no
50:53 - duplicate elements we do not keep track
50:54 - of order or frequency of elements
50:57 - all we care about is if something is
50:58 - there or if something is
51:00 - not there the reason we do this is
51:02 - because a set is extremely fast to do
51:04 - what's called lookups removals or
51:06 - additions when we're talking about a
51:07 - list let's say we have something that
51:08 - you know has a bunch of elements in it
51:10 - if we want to say remove the first
51:11 - element from the list that actually
51:13 - involves shifting the position of all of
51:14 - the other elements because we're keeping
51:16 - track of the positions of these elements
51:18 - with the set since there is no notion of
51:20 - position adding and removing something
51:21 - is as simple as just
51:22 - adding or removing that element there's
51:24 - no other operations that need to be done
51:26 - which mean it's very fast to use so
51:28 - think about a set to be used
51:29 - only in a situation where you care if
51:31 - something exists or doesn't exist
51:33 - not about the frequency or order in
51:35 - which that item exists
51:37 - so to create a set is pretty
51:38 - straightforward we can say x equals set
51:40 - and we use the open bracket and close
51:42 - bracket
51:43 - now the reason we don't actually write
51:45 - something like say s
51:46 - equals and then this which is really the
51:48 - representation for a set
51:49 - is because what this will do is create a
51:51 - dictionary
51:52 - now technically if we want to create a
51:54 - set we can do something like this
51:56 - and this will create a set for us that
51:57 - initially has the elements 4 32
51:59 - and 2 inside of it this is what's known
52:01 - as a set literal
52:03 - if you're not going to be creating an
52:04 - empty set it's totally fine to do it
52:06 - like this so long as you add an element
52:07 - inside
52:08 - but if you are creating an empty set
52:09 - then you need to use this constructor
52:11 - otherwise you're going to end up
52:12 - creating a dictionary which is not what
52:13 - you want
52:14 - to prove the simple point to you i will
52:16 - print out the type of just an empty
52:18 - you know set representation and you'll
52:20 - see that it gives me dict like that
52:22 - of course that's not what we want
52:23 - anyways let's have a look at this set
52:25 - and i'll just show you what i mean by
52:26 - unique unordered collection of elements
52:28 - so 4322
52:30 - if we print that out we get 32 to 4 so
52:32 - obviously a different order than how we
52:34 - added in there
52:35 - and notice that the duplicate twos were
52:36 - removed now the set operations are
52:38 - pretty straightforward we can add
52:39 - something to a set with
52:40 - s dot add our set dot add i'll put five
52:43 - and
52:44 - inside of here and let's just keep
52:46 - printing out s there we go we can see we
52:48 - added in there
52:48 - we can also do s dot remove 5
52:52 - and that will well since there's nothing
52:54 - in there give us a key error now if
52:56 - there is the element in there so we can
52:58 - do it like this it will remove that
52:59 - element for us and then there's a few
53:01 - other things that we can do as well for
53:02 - a set
53:03 - one of the good ones is actually
53:04 - checking if something is in a set
53:06 - what i can do is say 4 in s what this
53:09 - will do is simply check if the element 4
53:11 - is in the set and give me a true or
53:13 - false in this case it is true
53:15 - and remember this happens in what's
53:16 - known as constant time which means it's
53:17 - just extremely fast to do this
53:19 - as opposed to a list so we could say 33
53:22 - in s that's going to give me false
53:24 - now the parallel i want to make here is
53:25 - if i had s
53:27 - equals to 4 32 2 2
53:31 - like that so actually let's go s2 and i
53:34 - said print
53:35 - and let's just go 2 in s2
53:39 - this operation the one that's actually
53:40 - in the set is going to happen
53:42 - much much much much much faster than
53:45 - this one
53:45 - of course this isn't a big deal right
53:46 - now because these collections are quite
53:48 - small but as these get
53:50 - extremely large just understand that
53:52 - using a set is very beneficial when it
53:53 - comes to looking things up
53:55 - checking if something's in there
53:56 - removing and deleting there's a few
53:57 - other operations we can do on sets
53:59 - let me just define s2 and i'll just
54:01 - quickly show you a few of them
54:03 - we can do for example the intersection
54:05 - or the union of these sets so i can say
54:07 - s dot union s2
54:09 - and we'll go ahead and have a look here
54:10 - and we can see we get the union of these
54:11 - two sets essentially adding them
54:13 - together
54:13 - we can do the difference of the two sets
54:16 - if we want
54:17 - we can do the intersection and we can do
54:19 - the symmetric difference and all that
54:21 - other fun stuff that you can do
54:22 - with sets now i'm not going to get into
54:24 - all that stuff just know that these are
54:26 - sets and that's some of the stuff that
54:27 - you can do with them
54:28 - so now i'm going to talk about
54:30 - dictionaries now if you're from another
54:31 - language what may be familiar to you
54:33 - here is a hash table or a map
54:35 - something like that they're very similar
54:36 - to dictionaries but a dictionary is
54:37 - essentially a key value pair
54:39 - you have some key you have a colon and
54:41 - then you have some value that it
54:42 - corresponds to now of course that value
54:44 - has to actually be a valid data type
54:46 - but it could be something like a list it
54:48 - could be a single value like that
54:50 - and the way that you access and create
54:52 - new key value pairs is
54:54 - something like this i can print out say
54:57 - x and then the key inside of here in
54:59 - this case it's actually called key
55:00 - and what that will give me if you look
55:02 - down here is simply the value 4 because
55:04 - well that's what corresponds
55:06 - to this key so you have keys and you
55:08 - have values now to add a new key is
55:10 - pretty straightforward what you can do
55:11 - is you can say x
55:12 - inside of square brackets you can define
55:14 - whatever key you like it can already
55:16 - exist if you want
55:17 - we can say something like key2 and we
55:18 - can make that equal to 5.
55:20 - now note that these keys do not need to
55:22 - be the same
55:24 - sorry same data type so i don't have to
55:25 - have two string keys i can have integer
55:27 - keys i can have whatever keys i want
55:29 - do something like x2 equals 8 and there
55:33 - we go you see that works perfectly fine
55:35 - in fact i can make this a list just to
55:37 - prove to you that the values don't have
55:38 - to be the same either and
55:40 - there you go now just like a set this
55:42 - actually works using a hash which means
55:44 - this is very fast
55:45 - to retrieve add and modify values within
55:48 - the dictionary
55:49 - in fact it's so fast you can kind of
55:51 - assume that it's in constant time
55:52 - although there is a chance there will be
55:54 - something known as hash collisions
55:56 - although i'm not going to talk about
55:57 - that because that's probably a little
55:58 - bit more advanced than what most of you
56:00 - know
56:00 - anyways what we can do here in terms of
56:02 - operations on the dictionaries we can
56:04 - check if something is in the dictionary
56:06 - so i can say okay is some key in the
56:07 - dictionary
56:08 - key in x there we go print that out and
56:11 - that says true
56:13 - a few other useful things that we can do
56:14 - is we can get all the values from the
56:15 - dictionary
56:16 - so we can say x dot values print that
56:18 - out and it says addict values and it
56:20 - gives us a list of four
56:22 - usually when you do this you're going to
56:23 - want to actually create a list out of
56:25 - this because that is a different data
56:27 - type that's returning to us
56:28 - and there you go we get the value 4. now
56:30 - similarly we can do
56:32 - dick.keys so x dot keys and there we go
56:35 - we get a list that has all of the keys
56:38 - in terms of iterating over or deleting
56:40 - values i'll first show you how you
56:41 - delete something to delete something we
56:43 - can say
56:43 - x and then the key that we want to
56:45 - remove in this case it will remove
56:47 - this key so let's go ahead and do that
56:49 - and well i guess
56:51 - it didn't really show you that it was
56:52 - deleted let's just print it out to prove
56:53 - that
56:54 - there you go and we get an empty
56:56 - dictionary of course
56:57 - like i showed you before we can use that
56:58 - in operator and to loop over it there's
57:00 - actually a few interesting ways that we
57:02 - can do this so i can say
57:03 - for a key value
57:06 - in x dot items and then what this will
57:09 - do is simply return to me all the keys
57:11 - and values
57:12 - so i can print key value and you'll see
57:14 - we'll get key
57:16 - four so if i want to loop through all
57:18 - the keys and all of the values i can use
57:19 - dot items if i don't want to do that i
57:21 - can just say four key and then i can say
57:23 - in x
57:24 - what this will do is simply just give me
57:25 - all the keys in x and if i want to
57:27 - access the value of course i could say
57:29 - x key like that and that will give me
57:31 - the value and we get the same thing
57:33 - popping up there
57:34 - that's kind of the basics for the
57:35 - dictionaries there's a few other methods
57:36 - as well but i'm not going to talk about
57:38 - those um that is a dictionary
57:40 - and this next one is a fun one this is
57:43 - comprehensions
57:44 - now as far as i know python is one of
57:45 - the only programming languages that
57:47 - actually has this a lot of people
57:48 - absolutely hate it but i personally love
57:51 - it
57:51 - and if you learn to love it you can use
57:53 - it quite well now to do a comprehension
57:55 - essentially what that is is a one
57:57 - line initialization of a list of a tuple
58:00 - of a dictionary of many other things so
58:02 - let me just show you what i mean i can
58:03 - do something like
58:04 - x equals a list and then i can say x for
58:06 - x
58:07 - in range five now if i go ahead and i
58:10 - print the value of x you're going to see
58:13 - what we get here
58:15 - let's run it like that we get zero one
58:17 - two three four
58:18 - the way this works is essentially we can
58:20 - actually define a for loop inside of
58:22 - this list and what it will do is say
58:24 - okay we're going to loop through as if
58:25 - we normally would
58:26 - and whatever we have on the left hand
58:28 - side here is actually the element that
58:30 - we're going to add into the list
58:31 - so i could do something like x plus 5
58:33 - for x in range
58:35 - five and there we go we get five six
58:36 - seven eight nine ten i can also do
58:38 - something like you know x
58:40 - mod two and or x mod five there we go
58:43 - i can also you know grab something else
58:45 - i could say zero for x in range five
58:47 - that would give me a list of all zeros
58:49 - you can see how this might actually be
58:50 - useful
58:51 - now if we want to go into a more complex
58:53 - example i could do a list and then
58:55 - inside this list i could say
58:57 - 0 for x in range
59:00 - 100 for x in
59:04 - range five now what that's going to give
59:06 - us is five of these lists that each have
59:08 - a hundred zeros inside of them you can
59:10 - see that's quite large
59:12 - but that is kind of how that works now
59:14 - we can also go ahead and add some more
59:15 - complex stuff to this too
59:17 - we and say 0 for or i can say
59:20 - i for i in range 100
59:25 - if i mod 5 equals equals 0. so
59:28 - essentially if
59:29 - if i is divisible by five then what we
59:32 - can do is actually add it into the list
59:33 - let's have a look at that and there we
59:34 - go we get all the increments of five
59:37 - so you can play around with that and see
59:38 - how that works but this also works for
59:39 - dictionaries in fact let's just do the
59:41 - same thing here let's make it a
59:42 - dictionary
59:43 - and now we'll just go i colon zero so we
59:46 - have all these keys that are initialized
59:47 - at zero
59:48 - we go there and have a look we can see
59:49 - that dictionary works and of course we
59:51 - could
59:52 - do the same thing for a set we can just
59:54 - say i for i in range blah blah
59:56 - and there we go now we get a set so we
59:58 - can actually do this for tuples as well
59:59 - except we're not going to do it in the
60:00 - way that you might assume
60:02 - if you just go ahead and do this this
60:04 - actually returns to us what's known as a
60:05 - generator object
60:06 - it's a bit more advanced for this kind
60:08 - of video so i'm not going to talk about
60:09 - that but what we can do if we want to
60:10 - make this work for tuple is we actually
60:12 - type tuple we can use the tuple
60:14 - constructor which is simply this and
60:15 - then do the comprehension inside of
60:17 - there now that will return to us the
60:18 - tuple you can see i tried to do it the
60:20 - other way before and that returned to me
60:21 - the generator object
60:23 - anyways that is comprehension these can
60:24 - be used in a whack of different things
60:26 - they're definitely interesting and good
60:28 - to know and one of the best features of
60:29 - python that is not in
60:31 - many other languages so now i'm going to
60:32 - start talking about functions so to
60:34 - define a function in python you simply
60:35 - use the def keyword this means define
60:38 - then you pick your function name in this
60:39 - case i'm going to pick func the function
60:40 - names are the same as variable
60:42 - names in terms of how you name them you
60:43 - can put some positional
60:45 - parameters inside of here if you want or
60:46 - you can leave it empty you add a colon
60:48 - indented block
60:49 - then anything inside of the indent will
60:51 - run when you run the function so let's
60:52 - go ahead and actually just run this
60:54 - and show you the basics of this so that
60:56 - is pretty much how you run and define a
60:58 - function
60:58 - of course you can define multiple
61:00 - functions you can actually define
61:01 - functions
61:02 - inside of functions if you wanted to
61:04 - this is totally valid
61:06 - if i wanted to do something like this
61:08 - and
61:09 - then i could call funk like that now of
61:10 - course this is a more advanced use case
61:12 - but just showing that you can do that
61:13 - because of the way that python works
61:15 - in fact functions are actually objects
61:17 - which means you can technically return
61:18 - them i'll show that in a second but
61:20 - let me talk about arguments first so
61:22 - let's say i want to add the argument x y
61:24 - inside of here of course that means now
61:26 - when i call the function i need to add
61:27 - some value for
61:28 - x and for y so let's go five six and now
61:31 - if i
61:32 - after run want to print those i can
61:33 - print x and i can print y
61:35 - let's have a quick look we get run 5 6.
61:38 - of course we can return something from a
61:39 - function as well maybe i'll return
61:41 - x multiplied by y now if we actually go
61:43 - ahead and print
61:44 - the value of this function what will
61:46 - happen is it will evaluate what is here
61:48 - return that to us and print that out we
61:50 - get the value 30. now note that when you
61:52 - return multiple things from a function
61:54 - which you can do i can return x
61:56 - multiplied by y and maybe x divided by y
61:58 - as well this will return the value to us
62:00 - in
62:01 - a tuple so if you look here we get
62:03 - actually two values we have i guess the
62:04 - x y value here
62:06 - and that's inside of a tuple now if we
62:08 - want to unpack this tuple and say
62:10 - separate this out into different
62:11 - variables
62:12 - we could of course index at zero and
62:14 - index at one but a much cleaner and
62:15 - faster way to do this
62:17 - is to do something like r1 comma r2
62:20 - equals func 5
62:21 - 6. what this is going to do is take
62:22 - these two values here and simply
62:24 - separate them into the r1 and r2
62:26 - variable
62:27 - now if i go ahead and i print r1 r2 and
62:29 - i have a look here you can see that we
62:31 - get 30 and then 0.83334
62:34 - that is the basis for a function if you
62:36 - want to do a
62:37 - optional parameter you can do something
62:38 - like z equals you can set a default
62:40 - value i usually set it as
62:42 - none and what this means is that you do
62:43 - not have to pass that in but if you want
62:45 - to you may
62:46 - and it will override the optional value
62:48 - that you have here so let's just start
62:50 - by actually printing out zed
62:51 - i'm not going to call it with zed to
62:53 - start you can see
62:55 - that oops let's run that for a second we
62:58 - get run five six
62:59 - none and now if i add a z so let's just
63:01 - add seven there we see that instead of
63:03 - none we are going to get seven printing
63:05 - out right there
63:06 - that is the basics of a function and now
63:08 - we're going to move on to some other
63:09 - more advanced aspects of it
63:12 - all right so i'm going to talk about
63:13 - something that's really cool called the
63:14 - unpack operator and then i'm going to
63:15 - talk about star args and star star
63:17 - quarks but i first want to show you an
63:19 - advanced example of a function
63:20 - so if i say define func like this and
63:22 - then maybe i'll say take x and i define
63:24 - func 2 inside of here this is totally
63:26 - valid by the way you can put a function
63:28 - inside of another function
63:29 - and then inside of here what i'm
63:30 - actually going to do is say this
63:31 - function is going to print x
63:33 - and i'm going to return func 2 but
63:35 - notice i don't call it
63:37 - now this is just to prove to you that
63:38 - functions are objects hence they can be
63:39 - passed around just like variables
63:41 - so what i can actually do here is i can
63:42 - go ahead and i can say print
63:44 - or sorry not print but i can call func 4
63:47 - or func 3 and then i can actually call
63:49 - it like this what this is doing
63:51 - essentially is saying okay i'm going to
63:52 - call this function here with the value
63:54 - 3.
63:54 - what this function does is it returns to
63:56 - me another function
63:58 - so it gives me func 2. notice it's not
64:00 - calling the function it's simply
64:01 - returning it
64:02 - now i'll actually just show you what i
64:03 - mean first before confusing anyone let's
64:05 - print this out before i do the call
64:07 - statement on it
64:08 - but you can see that this actually tells
64:09 - me this is a function object it's a
64:11 - func.local's func 2. so it's pretty much
64:13 - saying that
64:13 - funct2 is defined within func now if i
64:16 - actually call this because that's just
64:17 - the function
64:18 - reference or object it's not actually
64:20 - you know being evaluated if i call it
64:22 - like that
64:23 - we can go ahead and we get 3 and then we
64:25 - get none of course the print statement
64:27 - is going to print none because
64:28 - there is no there's nothing to print
64:30 - from the return of func
64:31 - 2 but just have a look here we get 3.
64:34 - now this is equivalent if i did
64:35 - something like this i said you know
64:36 - x equals func and then on the next line
64:40 - i just called x
64:41 - since x is equal to a function func two
64:43 - i can call it just like i showed you
64:44 - before and there we go we get three
64:46 - anyways that's the advanced aspect i
64:48 - wanted to show now what i want to do is
64:49 - show you about star args and star star
64:50 - quarks
64:51 - uh so i'm going to put in like this all
64:54 - right so before i define what this does
64:56 - what i'm going to do is just show you
64:57 - what the unpack operator is in python so
64:59 - let's say i have a list maybe we'll call
65:00 - it x
65:01 - and we just have a bunch oops of
65:04 - random numbers in this list so what the
65:07 - unpack operator does is actually
65:09 - separate all of the elements from a list
65:11 - or from a collection into individual
65:12 - elements
65:13 - the best example of this is the print
65:14 - statement if i print asterisk x which
65:16 - means unpack
65:17 - x what this is going to do is take all
65:19 - of these elements out so separate them
65:21 - by individual elements and pass them
65:22 - into the print statement as arguments
65:24 - so instead of just printing you know say
65:26 - the entire list what it's actually gonna
65:28 - look like is print
65:29 - one comma two three comma two three six
65:32 - blah blah you get the point
65:34 - that is what this is going to do so just
65:36 - have a look at what happens when i print
65:37 - that
65:37 - i get all of these things separated by
65:39 - spaces like what happened if i just pass
65:41 - them in individually not being in the
65:42 - list
65:43 - now look what happens when i just print
65:44 - x let's have a look
65:46 - see it actually prints the list out so
65:49 - what this does is
65:50 - unpack whatever we have in a tuple or a
65:52 - list or some kind of collection
65:54 - and sends it through as arguments to a
65:56 - function so that's where star
65:57 - args and star star quarks come in
65:59 - although you'll see that in one second
66:01 - so let's say i have
66:02 - you know x y that we need inside of a
66:04 - function we got to pass x
66:05 - y what this will do is simply print
66:10 - x and then print y now let's say i
66:12 - actually have
66:13 - maybe a bunch of pairs that i want to
66:14 - pass this function so maybe i say pairs
66:17 - equals and then i have like one two
66:20 - three four well what i'm going to do is
66:21 - do a for looping and say four pair
66:23 - in pairs and what i want to do is call
66:25 - this function with those pairs
66:27 - now the naive way to do this would be to
66:28 - go func okay pair
66:31 - and then pair 1. great that would work
66:34 - but that is not
66:35 - the pythonic way to do this what we can
66:37 - actually do is do asterix pair
66:38 - and what this will do is take 1 2 and
66:41 - take 3 4 unpack them separate them and
66:43 - pass them as arguments to funk
66:44 - so if you have a look at that that
66:45 - actually works and that is why the
66:47 - unpack operator is really useful
66:48 - you can also use this actually on
66:50 - dictionaries as well and i'll show you
66:52 - how it works with dictionaries a little
66:53 - bit more complicated it involves two
66:55 - asterisks
66:55 - what this does is if i have keys i can
66:57 - say x representing obviously the
66:59 - argument
67:00 - x and then make that equal to 2 and then
67:02 - i can say y and this could represent the
67:03 - argument y
67:05 - and i'll make that equal to 5. now if i
67:06 - run this this works fine i needed two
67:08 - asterisks because this was a dictionary
67:10 - and that is kind of how this works um
67:13 - yeah i don't
67:14 - i guess i really need the for loop
67:15 - anymore to illustrate this
67:17 - but the double asterisk is used for
67:19 - dictionaries the single asterisk is used
67:20 - for a tuple or for a list
67:22 - now i just want to make the point here
67:23 - that let's say these are not in the
67:25 - correct order so it's
67:26 - y and then x this will still work and
67:29 - that's actually why this is really
67:30 - useful because you don't have to have it
67:31 - in the correct order
67:32 - so long as you name the arguments as the
67:34 - keys so now hopefully that will explain
67:36 - to us how star args and star quarks work
67:39 - so star args and star star quarks
67:42 - essentially imagine you have a function
67:43 - you don't know how many arguments
67:45 - positional or keyword arguments you want
67:47 - to accept that's what quark stands for
67:48 - keyword arguments
67:50 - well what you can do is you can use star
67:51 - args and star star quarks
67:53 - and what that will do is allow you to
67:55 - pass in an unlimited amount of regular
67:56 - arguments and keyword arguments
67:58 - so if i actually go ahead and go funk
68:01 - and then i pass like one two three four
68:03 - five
68:04 - and maybe i'll pass some keyword
68:05 - arguments like you know one
68:07 - equals zero two equals 1. i know this
68:10 - doesn't really make any sense but you
68:11 - get the idea
68:12 - now if i actually run this and print it
68:14 - out you can see that when i print args
68:15 - and print quarks
68:16 - we're getting a tuple that has all of
68:18 - the positional arguments which are these
68:20 - and all of the keyword arguments which
68:22 - are 1 and two
68:23 - now if i wanted to actually use any of
68:26 - these what i can do is i can unpack them
68:28 - so first of all i can unpack args and
68:30 - what this does if we have a look here is
68:32 - it will print out one two three four
68:33 - five
68:34 - i could try to unpack quarks but you're
68:36 - going to see what happens when i do this
68:38 - and hopefully if you remember the last
68:39 - example you'll realize why this is not
68:41 - going to work
68:41 - it says 1 is an invalid keyword argument
68:43 - for print so what this is going to do
68:45 - when i unpack quarks
68:47 - is it's going to take all my keyword
68:48 - arguments and it's going to say 1 equals
68:51 - 0 and it's going to say 2 equals 1 and
68:53 - pass that to the print statement
68:55 - now obviously 1 and 2 well those are not
68:57 - valid arguments for the print statement
68:58 - so we're going to get an error
69:00 - anyways that is args and that is quarks
69:02 - you're going to have to look into this
69:03 - on your own and kind of learn about how
69:04 - it works but that is the basics and i
69:06 - just wanted to show that to you
69:08 - so that you're aware that you can do
69:09 - these cool fancy things in python
69:11 - this next one is going to be very fast
69:12 - but this is just defining scope and
69:14 - global so when we look at a function
69:16 - like this
69:17 - there is a notion of a scope so we have
69:18 - x equals tim we have defined func
69:21 - and then we have name as a parameter and
69:22 - what we're doing is we're saying okay
69:23 - we're going to change
69:24 - x to be equal to name so essentially if
69:26 - i was naive and i didn't know any better
69:28 - i would assume that what's going to
69:29 - happen is while this variable up here
69:30 - would change
69:31 - when i pass this name to this function
69:34 - any of you that program before probably
69:35 - know that's not going to work but if you
69:36 - have a look here
69:37 - you can see that x does not change
69:38 - before or after when i call func with
69:40 - the string changed
69:42 - the reason for that is that this x
69:43 - variable is local it is within the scope
69:46 - of this function
69:47 - which means it cannot be used access
69:49 - change from with from outside
69:51 - the same thing here with this x this one
69:53 - is actually global this is on you know
69:55 - not not defined within any scope other
69:57 - than this file which means well i can't
69:59 - just directly change it from this
70:00 - function
70:01 - i could however access it from this
70:03 - function i could print it here but i
70:04 - can't actually change its value because
70:06 - if i do that what's going to happen is
70:07 - i'm going to create a new x inside of
70:09 - here
70:09 - which is equal to name and it will be
70:11 - local to this function it will not
70:12 - modify this
70:13 - however there is one interesting thing
70:14 - we can do in python which is the global
70:16 - keyword
70:17 - if i global x now you're going to notice
70:19 - that the expected behavior will occur
70:22 - now we get tim and we get change what
70:24 - that is saying is okay i want to use
70:25 - x as a global variable so i want to
70:27 - reference x in the global scope never
70:30 - use this this is
70:31 - never good to use and if i ever see a
70:32 - python program that has it i always get
70:34 - upset
70:35 - but this is something that you can use
70:37 - and i feel obligated to show you because
70:38 - there is some very
70:39 - very rare situations where you may need
70:41 - to use that all right so now i'm going
70:42 - to spend about 10 seconds showing you
70:44 - how to actually raise an exception in
70:46 - python
70:46 - there's a keyword called raise maybe in
70:48 - java you've seen something like throw
70:50 - and raise can raise an exception if you
70:51 - wanted to do that so i could raise
70:52 - exception
70:53 - and then inside of here i could just say
70:55 - bad you know whatever i want now if i
70:57 - run the program as soon as we hit that
70:58 - line
70:59 - immediately i'm going to get an
71:00 - exception and it says raised exception
71:01 - bad
71:02 - exception bad of course that is the
71:04 - basics there is more arguments and
71:06 - things you can do with this this is a
71:07 - base class which means you can extend it
71:09 - when you get to object oriented
71:10 - programming
71:11 - make your own exceptions and make all
71:12 - that fancy stuff
71:14 - for our cases that's all we really need
71:15 - to know i could raise say like a file
71:17 - exists error any other kind of error
71:19 - that i want and then again add some
71:21 - description for it by just putting a
71:22 - string
71:23 - inside of the brackets but that's enough
71:25 - for that now let's show how we can
71:26 - actually handle exceptions
71:28 - all right so now that we know how to
71:29 - raise exceptions it makes sense to learn
71:31 - how to handle them so in python rather
71:33 - than having like a try catch
71:34 - we actually have a try except finally
71:37 - block
71:37 - so what i can do is do something like
71:39 - try that means i'm going to try to
71:40 - perform whatever code is inside of here
71:42 - maybe i'm going to get an integer
71:43 - division by zero error so i can do you
71:45 - know
71:45 - 7 over 0 that's going to raise an error
71:48 - then i can create an except block i can
71:49 - accept an exception as
71:51 - e what this is going to do is mean
71:52 - whatever the exception is will be stored
71:54 - in the variable e and then so i could
71:55 - print out that exception and we can
71:57 - continue running the program
71:58 - this is the basic try except block you
72:00 - don't actually need to define something
72:01 - here i can just say try accept like that
72:03 - if i want
72:04 - and also accept a specific exception so
72:06 - i don't have to just put exception
72:08 - this is general this means any exception
72:10 - that occurs i will actually catch
72:11 - you can only catch specific exceptions
72:13 - if you want but again that's up to you
72:15 - so in this case you see we get division
72:17 - by zero it's just printing out but it
72:18 - didn't actually raise or
72:19 - you know show us that error so it did
72:21 - raise it but we didn't actually see it
72:23 - now if i go ahead and just do this what
72:26 - we can do is we can say oh well that is
72:28 - the actual problem and now our program
72:30 - is going to crash and
72:31 - not work but if we have this except
72:33 - block like this of course we're good to
72:34 - go
72:35 - now there also is a notion of a finally
72:36 - block the final block will run
72:38 - no matter what usually you put clean up
72:40 - type operations inside of here
72:42 - maybe you're trying to write to a file
72:43 - some exception occurs and then no matter
72:45 - if this
72:46 - was successful or not you want to close
72:47 - the file after you would put that inside
72:48 - of finally
72:49 - so i could say print finally like that
72:53 - have a look here and you can see we get
72:55 - finally i'm not going to go through this
72:56 - too much i assume if you're going to be
72:57 - using this you understand how try
72:59 - accept and finally work but that is the
73:01 - implementation in python
73:02 - and that is the basics for raising and
73:05 - catching an error
73:06 - and now we're going to discuss the
73:07 - lambdas so lambdas are actually a really
73:09 - cool aspect of python i'm pretty sure
73:10 - they have them in many other programming
73:12 - languages as well but it looks something
73:13 - like
73:14 - this essentially a lambda is a one-line
73:17 - anonymous function what that means is
73:19 - not really a named function
73:21 - you don't define a lambda using the def
73:23 - keyword what you can do is something
73:24 - like x
73:24 - equals lambda x and then x plus five
73:28 - what this means is this lambda is going
73:30 - to take one argument which is x
73:32 - and it's going to return x plus 5 not
73:34 - multiplied by x do i mean to do that
73:36 - that means if i call x like this and i
73:38 - go i don't know x2 and we print
73:40 - this let's just go ahead and have a look
73:42 - at this here
73:44 - oops again did not mean to do that we
73:47 - see that we get the value 7. now i will
73:49 - note that this is not the advised way to
73:51 - use a lambda we're going to see how to
73:52 - use it in just a second in the next
73:54 - section
73:55 - but this is the basics of how it works
73:56 - it's just a one-line anonymous function
73:58 - so i can do something like x
73:59 - y as well and then i can do something
74:01 - like x plus y
74:03 - not capital y and if i go ahead and call
74:05 - x with i don't know 2
74:06 - 3 or 232 sure that's fine let's have a
74:09 - look here we get the value 34.
74:11 - so hopefully that makes sense on how the
74:13 - lambda works it looks intimidating but
74:14 - it's really not that complicated and
74:16 - in the next one you'll see why these are
74:18 - useful and now i'm going to talk to you
74:20 - about map
74:20 - and filter which are two useful
74:22 - functions in python which make use of
74:24 - the lambda functions
74:25 - now you don't necessarily need to use
74:26 - lambda function but a lot of times it
74:28 - comes in handy so let me show you what i
74:30 - mean
74:30 - let's make a list let's add oops i
74:33 - wanted to do a few more commas than that
74:35 - let's add a bunch of elements inside of
74:37 - here to make it kind of nice and long so
74:38 - we get some interesting output
74:40 - and now what i'm going to do is i'm
74:41 - simply going to show you how we use map
74:43 - so what map will do is we'll take all of
74:45 - the elements of a list
74:47 - and use a function to map them into a
74:49 - new list so if i say something like mp
74:50 - standing for you know map
74:52 - i can say map which is the actual
74:53 - function now what i do is i put a
74:56 - function inside of here that i want to
74:57 - use for the map
74:59 - so this will make sense in a second but
75:00 - i'm going to say lambda x
75:02 - x plus 2. so this is essentially saying
75:04 - add 2 to every single one of these
75:06 - elements or add 2 to x in this case
75:08 - and then what i do is simply pass x now
75:10 - i know x is kind of confusing so maybe
75:12 - we'll just change this to i so that's
75:13 - easier to differentiate
75:15 - but what this is going to do is say okay
75:16 - we're going to map all of the elements
75:19 - inside of x so in this list x to this
75:21 - lambda function which means take this
75:23 - lambda function and apply it on every
75:25 - single element of x and then put that
75:26 - into a new list
75:28 - now what i'm going to do is i'm going to
75:29 - print the list representation of
75:31 - mp map actually returns to us a map
75:33 - object
75:34 - we can use that if we're going to
75:35 - iterate over it but it's usually more
75:36 - useful just to convert it right into a
75:38 - list
75:38 - so let's have a look at what this does
75:40 - and there we go now we get three four
75:42 - six
75:42 - and you can see all these elements have
75:43 - been added by two now we can do a more
75:46 - complicated one maybe we can multiply by
75:47 - two
75:48 - you'll see more of a difference and
75:50 - there we go now the next function i want
75:52 - to show you is
75:52 - filter so hopefully you get the idea of
75:54 - how map works but filter
75:56 - i don't want to say it the opposite but
75:57 - it does something a little bit different
75:59 - so this function here which is lambda
76:00 - what it's going to do is instead of
76:01 - actually returning
76:03 - some value it's going to return true or
76:05 - false and it's going to tell us
76:06 - whether or not we should include the
76:08 - item in our final filtered list or
76:11 - filtered object
76:12 - so essentially this lambda function or
76:14 - whatever function we put inside of here
76:15 - has to return true or false based on the
76:17 - value of an item so what i could do is
76:19 - say something like
76:20 - i is i mod 2 equals equals 0. so this
76:23 - means you know only return it if it's
76:24 - even
76:25 - so this is the function take some value
76:27 - i tells us
76:28 - if it's equal to or sorry divisible by 0
76:30 - and if it is we'll include it so let's
76:32 - have a look now
76:33 - and you can see that we only get all of
76:34 - the even elements in our list
76:36 - now of course what we can do is also
76:38 - define a more complicated function so we
76:39 - can say define func
76:41 - take some value let's go with i and we
76:43 - can do the same thing here we could say
76:44 - return i
76:45 - mod 2 equals equals 0 but we could also
76:48 - say you know i
76:48 - equals i multiplied by 3 so
76:52 - we can do that and then we can say i mod
76:54 - 2 equals equals 0.
76:55 - then instead of using a lambda here we
76:57 - could simply just write func
76:58 - that's totally fine so we just put the
77:00 - name of the function that we want to use
77:01 - and then we run this and it works fine
77:03 - but this is why
77:04 - lambda is useful because a lot of times
77:05 - you don't want to define your own
77:06 - function up here
77:07 - you just want to define it right inside
77:09 - of the map statement or the filter
77:10 - statement so that's
77:11 - kind of where you would use this there's
77:14 - another few use cases for it but this is
77:15 - kind of the most common and where you'll
77:17 - often see it so anyways that
77:19 - is map and filter and for our last
77:22 - and final topic i'm going to be covering
77:24 - something called f strings
77:25 - now f strings are new in python 3.6 if
77:28 - you have any version lower than that you
77:29 - are not going to be able to use
77:31 - f strings but they're a really cool way
77:32 - to actually just manipulate and create
77:34 - strings so what i can do is do something
77:36 - like x equals i can do an
77:37 - uh lowercase f or a capital f it doesn't
77:39 - matter and then a string
77:41 - notice that this will highlight or maybe
77:43 - it'll be a towel size depending on what
77:44 - editor you're using
77:45 - and well what you can do is type a
77:47 - string as you normally would except now
77:49 - if you want to embed an expression what
77:50 - you can do is do that inside of curly
77:52 - brackets so i can do hello and then i
77:54 - could say like you know
77:55 - six plus eight and this will actually be
77:58 - evaluated and now when i print this out
77:59 - it will give me the answer 14. so this
78:02 - is great because if you have some
78:03 - variables say like i have you know
78:05 - i don't know tim equals 89 or something
78:07 - and i want to embed that in the string
78:08 - without having to concatenate it and
78:10 - convert it into a string with str
78:12 - i can simply just use the f string and
78:13 - just embed it with all the formatting
78:15 - uh by putting it inside of these curly
78:17 - braid braces so that is kind of how
78:19 - that works you can go ahead and mess
78:20 - around with this if you want to really
78:22 - see how it works but essentially you
78:23 - just put an expression inside of these
78:25 - curly braces
78:26 - it will be evaluated and then it will
78:27 - turn into a string really great easy way
78:29 - to work with strings of course you can
78:31 - print an f string as well i could print
78:33 - hello
78:34 - and then we can do that and in fact
78:36 - let's run this and just see what we get
78:38 - and there we go we see we get hello 89
78:40 - so that is f strings
78:42 - so with that being said i'm going to
78:44 - conclude the video here i
78:45 - am officially out of breath i went very
78:48 - fast through this tutorial
78:49 - with the purpose of making it as quick
78:51 - as possible and not wasting any of your
78:53 - time if you guys appreciate this effort
78:55 - please do leave a like
78:56 - subscribe to the channel and of course
78:58 - let me know what you want to see next i
78:59 - will quickly mention that i did miss a
79:01 - few things in this video
79:03 - specifically object oriented programming
79:05 - and advanced language features
79:07 - if you would like to know about those
79:08 - two things i have a ton of resources
79:09 - related to them i will leave them in the
79:11 - description
79:12 - the first is a about an hour long video
79:14 - on object oriented programming in python
79:16 - that covers kind of all the fundamentals
79:18 - and everything you need to know
79:19 - the next one is a whole series on expert
79:21 - level features in python i believe
79:23 - that's about six videos and covers
79:24 - things like meta classes context
79:26 - managers generators all of that
79:28 - anyways as i said i hope you enjoy leave
79:30 - a like subscribe i will see you in the
79:32 - next one
79:36 - [Music]
79:40 - you

Cleaned transcript:

hello everybody and welcome to python as fast as possible in this video i'm going to be trying to teach you python as quickly as i possibly can that means i am going to go over things quite quickly i'm going to talk very fast and i will note that this is not for absolute beginners if you are looking for a beginner level tutorial series i have many on my channel i will link a ton of resources down below and if you feel that i missed anything or made any mistakes please do leave a comment with that being said let's go ahead and get started and get into python as fast as possible to get started we need to download and install python please download the most recent version of python from the python website which will be linked in the description if you're using any version of python which is below 3.6 that will not be compatible with this tutorial when downloading please check the box that says add python to path this will make your life easier in the future now python automatically comes with its own environment to write code in this is idle you can use this to write your code if you'd like but i prefer to use visual studio code which is a text editor to download that you can go to the link in the description and just download the stable build for whatever operating system you're on now if you're using vs code there is one little bit of setup we need to do to get started here we simply need to install the python extension go to the extension tab here this will bring us to the vs code marketplace we can type python and then we can see the python extension and simply press install you can see for myself i already have it installed so before we get started i thought it would be a good idea to talk to you about some of the things that python is used for here i am on my channel in the playlist tab and you can see a bunch of different playlists just giving you an idea of some of the things that i've created with python and taught on this channel python is a general purpose programming language it is very easy to learn versatile and really easy to write in the core advantage of python is typically how simple it is how easy the syntax is to read and just how fast development is with it that being said python is mostly used on the web and in machine learning artificial intelligence and data science related tasks now the sponsor of our video knows a ton about that and that is simply life i need to thank simply learn for sponsoring this video and giving you all a discount on their data scientist master program that was codeveloped with ibm this program is comprised of six unique courses that implement a unique blended learning experience in a high engagement online classroom environment during this program you will master 30 plus indemand skills and work with tools and languages like r sas python tableau hadoop and spark you'll master these skills through 15 real life projects and one capstone project during this 12 month comprehensive course you'll also be given 1200 usd worth of ibm cloud credits to use during your 24 7 access to the ibm watson platform after completion of this course you'll be given certificates from ibm and simply learn to testify to your skills as an expert in data science get started by hitting the link in the description i want to start by covering the core data types in python these are int float string and bool and otherwise known as integer now an integer or int is simply any whole number that does not have a decimal point on it so two three seven three seven that was going to be an int negative nine that's an inch negative some random large number is an int so long as it does not have a decimal point on it we consider it an int a float is almost the opposite of that it is simply any number that has a decimal point on it so something like 272.00 this is a float even though you can would consider this a whole number the point zero adds a level of precision to this which makes it a float of course something like 9.7 would be a float whenever you see a decimal point that means the number is a float next we have string a string is simply anything surrounded by single or double quotation marks typically we consider this a sequence of characters or numbers so if i type something like hello and i type something like hello these two strings are actually completely equivalent it does not matter whether you use single or double quotation marks there is no difference i will note that if you want to embed a double quotation mark or a single quotation mark in the actual string itself then you would usually wrap the string with the opposite type of quotation mark so in this case i want to have this double quotation mark inside the string so i wrap the string with single quotation marks now just to note here if i do something like 4.6 even though you might consider this a float this is a string again because it is surrounded by single or double quotation marks remember the definition anything defined or surrounded sorry by single or double quotation marks next we have boolean this is one of two values we have true or we have false some people may consider this one and consider this zero we're going to look at these later on and you'll see why that's important but that is a boolean value and these are the four core data types in python the next topic i'd like to cover is output and printing this is very important and we will be doing this a lot in this video in python there is a simple function called print this is how you output something to the console when you run your program typically when you print something you'll put it in strings so i want to print say hello world so i will print the string hello world like that and if i run my program by pressing this run button you can see down here in the console we get hello world now notice that if i just type hello world like this and i don't put it inside of a string and i run my program i will get an error this is because i cannot simply print something like this the program does not know how to interpret hello world if it is not wrapped in strings that is because this is not one of the core data types and we have no variable or anything that denotes what hello world is that being said if i want to print a number say like 4.5 python knows what 4.5 is because it is a float you can see when i highlight it it says float if i run this it will print 4.5 out and there will be no problems now if you want to print multiple things what you can do is separate them by commas so say i'd like to print 4.5 and then i would like to print hello when i do this it will automatically add a space between the two things let's just put another string here just to show you what i mean so 4.5 hello notice it adds that space in between now we will talk about how you can print things without the space in between later on but that is the basics of a print if i want to print many things on the same line i can go hello i could say end i can say 87 i can say false and i can run this and this will all work hello and 87 false now there's a few arguments that you can pass into the print function if you do a comma and then type end equals you can denote what you want the end of this print statement to be by default the end here is a carriage return which is backslash n what that means is go to the next line after this line is printed now notice if i don't add this backslash enter in fact let me just show you what happens by default so let's say i have hello and 87 i'm going to get rid of this and i print both these things out we get these on two separate lines that is the default behavior of the print statement and prints on a new line now notice if i add end e end equals and instead of a backslash n let's say uh this pipe like that and i run this now at the end of the print statement it simply prints a pipe it does not add the carriage return which means we do not move on to the next line that's a little bit more advanced but essentially the carriage return is that backslash n and again that means just move down to the next line that is the basics of printing and output and now let's move on next let's move on to variables variables are an important part of any program in python they are quite easy to create when you create a variable in python you simply type a variable name a space an equal sign and then assign it to some value this value is going to be some data type some function something else that we'll talk about later on to give you a basic example i'm going to set the variable hello equal to the value 10. think of a variable like a bucket that stores some data or stores some type now if i want to access the value that is stored in hello what i can do is i can simply say print hello what this will do is it will say okay this is a variable i know it's a variable because i saw it earlier on the program let me see what its value is and i will print that value so now i'm going to run and you can see that we get tim let's make another variable let's call this world let's actually set this equal to the value world now let's print hello comma world and let's see what we get we get tim and then space world variables are somewhat complex you can make them equal to other variables if i decide to change the value of world to actually be equal to the variable hello what's going to happen is it's going to say okay hello is a variable what is a low equal to hello is equal to tim so i will print tim now watch what we're going to get we get tim tim now what happens if i come here and i change hello to be equal to no if i do this what's going to happen is world will not change because world was set equal to the value of hello at this line at this point in time line three because our program reads from top to bottom the value of hello was tim so world gets set to tim then hello gets set to no that does not change the value of world so what you're going to see is we're going to have tim and then we're going to have no so let's have a look here and sorry other way around we get no tim my bad though we printed a hello first and then world i have that mixed up that is the basics of variables there's many other things that we can do with them but let me just tell you about the naming conventions for them so in a variable you are not allowed to have any special characters and you cannot start with a number so you are allowed to have an underscore that is the only exception in terms of special characters usually you will use that when you are denoting a space and in python the convention is typically to separate things using an underscore in other languages you may see something like hello world if you wanted to make a variable uh that has multiple words in it but in python stick with snake case which is what this is known as the other one is camelcase and use underscores to separate your variables just to give you an example of what i mean you cannot start a variable with a number so 9 hello notice i'm getting the red line popping up here and i could not do something like hello 9 that does not work but if i want to hello world 32 that is totally fine that is a valid variable name the next topic i want to talk about is getting user input just like printing something is very simple getting input is simple as well what we do is we simply use the input function we have our open and close parentheses and then we type what's known as a prompt inside of these brackets like this now this does need to be in a string unlike the print statement we cannot do something like 4.5 in here that will not work we do need a string so what i'm going to do is i'm going to add a prompt say i want the user to type their name then i will say name i'll do a colon and then i will add a space between the colon and the end of the string the reason for this is that the user will be able to start typing on this line right after the prompt so if i don't have a space then what's going to happen is the user will start typing right where the colon is which of course is not going to be good so let's go ahead and run this and have a look at what happens we can say name colon space and now i'm going to type tim that's great but how do we actually get the value how do we store what the user typed in so we can use it later well we need to assign this input to a variable so what i'm going to do is i'm going to say name is equal to input i just want to note because i forgot to say this previously we could have capitals in our variable name if we want that would be fine but i'm not going to do that and now what will happen is whatever we type in will be returned to us in this statement as a string and it will be assigned to this variable name so if i go ahead and print the value of name what's going to happen is whatever we type in here will be printed out so let's have a look at this name let's type tim and we see that tim is printed out below there now we of course can get multiple user input so i can say something like age equals input age colon and now let's see what happens when i run this so we go name tim age 20 and we could put print those out if we want but i'm not going to actually you know what let me show you one example where i print them out let's say hello and then let's go comma name and then you are comma age years old so this is a way that we can combine variables and strings so that we print out a meaningful response that says hello whatever the name is you are whatever the age is years old so in this case i'll say name tim age let's go 12 and says hello tim you are 12 years old all right so that is it for input now we're going to move on and talk about how we can actually convert say numeric input into a integer or float because it default comes back as a string all right so the next topic i want to cover is arithmetic operators these essentially are like plus minus multiplication exponent how you perform mathematical operations in python now just something to keep in mind when we're performing and using arithmetic operators we have to make sure that the data types on the left and right hand side of these operators otherwise known as the operands are the same data type or are both numbers what i mean by this is if i have something like hello and i try to add 9 to it well that just does not make any sense and we are going to get a error and something's going to be wrong with our program so just keep that in mind i cannot do hello minus 9. you cannot do hello divided by 9. you actually can use the multiplication you can take a guess at what that's going to do but i will show you that later alright so let's go through the basic operators the first one is the plus sign very straightforward we can add 9 plus 3 or in this case i could add x plus y so x is 9 y is 3. we can add those two values together ignore the squiggly when i save that goes away now something to keep in mind if i make this 3.5 this works totally fine even though these are different data types since they are both numbers i can add them together of course i can do the subtraction let's run that i can do the multiplication which is an asterisk and i can do the division we do the division we get some crazy number just keep in mind that the maximum precision in python i believe is 13 decimal points there is ways to get beyond that but that is kind of too advanced i'm not going to cover that right here and when you ever do division or you're dealing with rounding and all of that that's always a problem in computers so just keep that in mind you're not going to get the most precise answers with division like this if this is a nonterminating decimal point anyways hopefully that makes sense now i just want to point something out if i actually have say 9 over 3 of course you know that that answer is 3 and that is a whole number right 3 is a whole number but this is actually returning to us a float not in int even though neither of these data types are afloat the reason for that is because whenever we use the division operator it returns a float because it does not know if it's going to need to represent a floating point or it's going to have to represent some level of precision so just keep that in mind if for some reason you don't want this to be a float of course you can convert the result to an int by just doing int like that okay so those are some of the basic arithmetic operators next we have exponent so that's two asterisks like that this will raise x to the power y so we can see that gives us 729 and then next we have floor division so what i'm going to do here is actually make this a 10 have a guess at what you think this is going to give but this gives us 3. the reason it gives us 3 is because this will give us the integer result of whatever the division is imagine this was like 9.333 or whatever it may be it just simply removes all of the decimal points and just gives or sorry to be 3.333 removes all the decimal points and just gives us whatever that integer result is next is mod this is the percent sign this returns to us the remainder after a division in this case 10 mod 3 is going to be well the answer is 9 and then remainder 1 right so that is why we get 1 from this here i think that's it for those operators now i will simply show you how we can do say order of operations so if we want to order of operations we can use brackets or if we want to evaluate things in a specific order this does follow the simple order of operations which the acronym i know for it is bed mass which is b e d and i hate this autocomplete it's making it very hard to do this m a s okay so what this stands for is brackets exponents division multiplication addition subtraction python does follow those standard order of operations if you just write an expression but of course it's always easier to use brackets and spread things out so i can say something like x mod y and then i can multiply that by two since i didn't say it the integer division and mod operators are in the lowest order of order of operations so if you use mod that is going to be below addition and subtraction pretty sure that's correct but someone can correct me from the in the comments if i'm wrong about that but anyways you get the point you can use brackets and that is how you can perform and do arithmetic in a certain way all right next thing i need to cover here is simply just an example using input so what i'm going to say is num equals input and we'll just say number colon like that and what i want to do is simply print the result of num minus five so i want to take whatever number they type in and i want to subtract five from it and print that to the screen so let's try it num equals five notice that it says unsupported operand types for minus are four sorry yeah minus string and int so what that's saying is that num is a string even though it looks like an into us i'll explain why in a second and we cannot subtract the number 5 from it that just doesn't make any sense the program doesn't know what to do with that so think about this why is num a string we typed in 5 this should be an int value from what we understand about our data types well this input automatically returns to us whatever we type in in a string so just imagine that whatever we do here it's going to give us a string and that means that if we want this to actually be a numer numeric value and be able to perform arithmetic on it we need to convert it to an int so there is this fancy function called ins in python this will take some string assuming that there is an int inside of that string and it will convert it into its integer representation let's have a look now when i type a number let's say 10 of course we get the value 5 it took num which was 10 so the string 10 you know i'll type it out like here we have the string 10 and it simply converted that to the actual integer value 10. now you can imagine we have other functions in python that do this as well we have say float that's going to take whatever we have here and convert it into a float now notice what happens when i do this if i do float 10 we get 5.0 whenever you have at least one float in your arithmetic it's going to automatically return to you a float it needs to keep the level of precision that was in the original you know operation or in the original value so just that's something to keep in mind whenever you're doing you know plus minus multiplication if there is one float as the operand so on the left or right hand side of the operator then you are going to get a float result back all right that is all i wanted to show for this now let's move on so the next thing i want to cover is something called string methods before i do that though i need to define what a method is so let's create a variable let's make this equal to hello and we can just say hello equals the string hello i want to show you this function called type which will tell us the type of a variable so if i print the type of hello well you can imagine what type this is going to be it's simply its data type let's have a look here we get class string you can ignore the angle brackets in the class if you're more advanced you probably already know what this means but essentially what this is saying is that this string or this variable here hello is an instance of the class string again big words you don't have to know what those mean but for anyone more advanced hopefully that makes sense to you all right so how do we use a method on a string and what is a method well a method simply is something with a dot operator so we have dot we have sum and name whatever the method name is in this case it's going to be upper and then we have an open and close bracket or parentheses whatever you want to call them now i just want to show you what these methods do so if i say hello dot upper this is a method that we can call only on strings so since this is a string i can use this dot upper method on it and imagine what this is going to do what this actually does is it upper cases or puts the entire string in completely uppercase so if i have a look now at hello and we print it out we can see we get hello in all capitals now i don't need to call it like this i also can do hello dot upper now the reason this is going to give me the same thing is because well this is storing the value of the string which is hello and then it was just making an uppercase right here now what happens it says okay well what is hello equal to oh well hello is equal to the string hello so you can think of it as a substitution this string just goes where that is makes it upper and then prints it out there we go upper now let's have a look at what dot lower does you can probably imagine already but it simply makes the entire string lower case these are useful when you're getting user input and you want to validate and check if it's equal to something which we will do later on so a few other methods we have dot capitalize you can imagine what this does it simply capitalizes the first letter in the string and then makes the rest of it so it looks good right so i've had a sentence and i said like hello world like that let's have a look at this it's going to give me hello world properly and if i added a capital w like that it removes that and it just kind of formats it as if a sentence would next we have this method called count what count does is it will count a specific string within the string so it looks for a substring in the string and how many times that occurs let's see i wanted to see how many double l's were inside of this string well i can say hello.count double l and then that will count and tell me how many are in here now have a look and guess how many you think are in here well there's actually zero the reason they're zero is because these are capital l's and this was looking for lowercase l's so that's why it's very important to make sure you're differentiating between capitals and lowercases because two lowercase l's are not the same as two uppercase l's but if i wanted to fix this problem i could make the entire string lowercase so i could say hello dot lower and then i could count all of the double l's in the lowercase string so now let's look at this in this case we get the value one let's make this a little bit better and let's look for all of the is there any other ones that we can look for i guess we can look for how many o's there are all right in that case we get two o's so those are a few basic string methods there are some more but i just want to show you how you use these and the fact that you can chain them on each other because what happens is this will return a string you can imagine that the substitution of this just looks like um you know hello world and then it's going to count all the o's inside of hello world and return to us that value which in this case was 2. all right so now we're going to move on to conditions and conditional operators now before i mention that i just want to go over something that i forgot in one of the previous sections this is simply string multiplication and string addition this is important so i'm just going to cover it quickly but essentially let's say i have a variable and that's equal to hello so x equals to a low i have another variable and this is equal to actually we can say 3. well there's this cool thing in python but what i can actually do is multiply a string by an integer and that will simply repeat the string the integer number times so if i say x multiplied by y even though these aren't the same data type which i said before might cause problems since it's a string and it's an integer and the string is on the left hand side we can do this so i can say how this gives us hello because we multiplied the string by the integer so just something to keep in mind that we also can add two strings together because that actually makes sense so if i say hello and then i say yes well i can add these two together this is known as a concatenation so let's have a look at this and i get hello and then yes so you can do that you can add two strings together and you can multiply a string by an integer just need to throw that in there because that obviously is something that's important to understand all right next we're going to talk about conditions and conditional operators so a condition is simply something in python that evaluates or compares two variables or data types and returns to us either a true or false value based on the comparison so to you know give you an example of a comparison is x equal to y is x less than y those are comparisons and the answer to that is either yes or no or in our case true or false so we have that true and we have these false this is boolean so the result of a comparison is simply a boolean value all right so let's look at what these operators are we have two equal signs which checks for equality is the lefthand side equal to the righthand side we have not equal to which checks for inequality so is the lefthand side not equal to the righthand side we have less than or equal to greater than or equal to less than and greater than now there's a few other random ones we're not going to go through those but these are the core conditional operators and let me show you an example of condition let's say i have x equals hello and y equals hello i want to check for the comparison so i might do something like print x equals equals y are these two things the same let's see yes they are we get the value true now let's do the not equal to sign are these things not the same no they're not so we get false that is the basics of checking for equality now what if i add a capital l inside of this string well we know that lowercase and capital l's are different so if i do this we get true which means no these two strings are not the same they are different if i do double equal sign then we get false now interesting thing with strings we can actually compare them using the greater than sign and less than sign now it's not super intuitive so i have to kind of show some more primitive examples here to give you an illustration of how this works but if i have something like a and i say is a greater than let's actually go with capital z what do you think the answer to that is well that's actually true now the reason for that is every single character inside of python is represented by what's known as an ascii code we actually have a look at what this ascii code is by looking at what's called the ordinal value of a character so if i print out the ordinal of z we can actually see that that's 90. if i print out the ordinal of a we can actually see that that's 97. so what that's telling us essentially is that this uppercase z is actually represented by the number 90 and the uppercase or sorry the lowercase a is represented by 97. so what we do is we would compare the two ordinal values of these character characters and see that well actually a is greater than z now if we do this so i say a greater than b then that's going to be false because b is actually represented by 98 there is some logical ordering for these characters but i just want you to understand that we can compare strings using greater than less than equal to all of those but just understand that we're comparing the ordinal value of the strings now let's say we have something like a b what we're going to do is simply just go from left to right and compare all of the characters so we would say okay is a greater than b yes it is imagine these two are the same so we had a and then we had d like that if these were the same then we would go on and compare the next character which would be b in this case we get false because obviously the d is greater all right so that is how that works now let's just show a few examples of numbers let's just say 7.5 equals equals 7. is that true obviously that's false let's say 7.5 greater than 7. obviously that's going to be true and what about 7.0 equals equals 7. have a look at that we get true all right that is the basics on the conditional operators and conditions of course you can store these things in variables i can say result equals 6 equals equals 6. and print result like that and we get the value true okay let's move on now to chained conditionals so a chained conditional is essentially combining multiple conditions together to create one larger condition what i have right here is a basic example i have three conditions right i have result one result two and result three result one says is x equal to y result two says is y greater than x and this one said is z less than x plus two you can imagine that these have brackets around it it works the same so all of our conditional operators have a lower precedence than all of the arithmetic operators so if i do something like z minus two less than x plus two well that's not going to say z and then negative 2 less than that it will evaluate on the left hand side and it will evaluate on the right hand side and then it will combine and use sorry this conditional operator so hopefully that makes sense but just keep that in mind that you can actually write expressions on each side of a conditional operator okay so now that we have that essentially what i want to do is say okay how can i make a condition that uses result 1 result 2 and result 3. so obviously all of these are equal to true false true false they're equal to something like that so what i can actually do is use three separate keywords so and or oops and not so these three words are what i can use to chain conditionals together and create larger larger conditions from specific conditions themselves so what i can do is do something like this i can say result 4 equals result 1 or result 2. now what does the or operator do well the left hand side and the right hand side of or have to be a true or false value which they are because these evaluate to true or false what or will do is it will look at the left hand side and right hand side it will say okay if the left hand side is true or the right hand side is true this whole condition is true of course if they're both false that's the only situation where this whole condition here is going to be false so in three scenarios because there's four possible scenarios here it's going to be true and the other scenario it will be false so if both of these are true obviously at least one of them was true so that evaluates to true so let's actually just print result 4 and have a look at it great we get true now what we can do is we can add another or if we want and we can say result 3. now what this says is ok if result 1 or result 2 or result 3 is true this whole thing is true which of course it is now let's see how we can combine other stuff into this we can actually use this not keyword what this does is it takes whatever is on the right hand side of it so in this case it's going to be a true or false value and just flips it so in this case if if result 2 is true which it is it's just automatically going to become false so if i actually i can show you on a more basic level if i just print a instead of result 4 i print not true like that this will print the value false which you can see down there and if i print not false then this will print true now what i can do is do something like this i can say not false or true so let's have a look at that and there we go we get false so it takes whatever this is which is true and then it just reverses it and makes it with the not now those are two that we've talked about so or and not now what about and so and essentially says okay is what's on the left hand side and the right hand side true if both of it is true they are true the whole condition sorry is true otherwise it is false so only in one scenario out of the four possible scenarios here with two variables or two values on the left and right hand side is this going to be true so let's have a look at this and we get true because obviously this is false then we nod it and that turns to true now of course we can do a combination of and and or now when we use these combination of different things right so not and or we have to know which is going to come before what so kind of in the order of operations now the way it actually goes is not is first and is second and or is last so just keep that in mind because that will be important based on the way that you write your expression so essentially if i say false and true or true then what we're going to actually do is evaluate the false and true first and then we will evaluate the or of whatever this is and then that so in this case this would be false so then we would get false or true and then this would turn into true then we would have the not and that would turn that into the false so now we're moving on to the fun stuff which in my opinion is the if else if and else statement now this essentially allows us to actually check if something occurs or if a condition is true and if that is true we can do something specific otherwise we might not do anything or we might do something differently so for the example i'm going to do here i want someone to type in their name and i want to say if their name is equal to in this case tim i will tell them they are good at python i don't know something random so in this case to do that what i will start doing is writing an if statement so the syntax of an if statement is if condition like that i know that's spelled wrong but that's fine condition colon indented block whatever i want to happen in the indented block and then that is the basic syntax of the if statement so for here if i want to check if x is equal to tim i will say if x equal equal to and then the string tim with the capital t i will simply print you are great so now what will happen is if and only if x is equal to tim will i print you are great now in any situation so regardless of if the name is equal to tim or not i will always do this so i will print that statement hopefully that's selfexplanatory so let's go ahead and do tim we can see you are great always do this now let's do another name let's go with joe and it says always do this it did not print this statement now the addition to the if statement is of course i can add more stuff underneath this indented block so i do another print statement and that would add a space so let me actually just show you how this works if i do tim now you see we get that space by just printing an empty print statement essentially okay now what we can do though is we can say okay how about i only want to print you are great or i want to print some other message i don't want to print two things well what i can do is i can print i can add this else this else must come after an if statement and essentially what it allows me to do is say okay if this isn't true do this so it's an if else right if true do this otherwise do this never will i do both so in this case i'll just print no you know not very intuitive or it doesn't really make much sense but that's fine so now i'll go ahead and i'll say name tim it says you are great and let's actually just go with no and then it prints out no all right so that's the basics on the if else now let's say we actually want to check multiple things so maybe we want to check a bunch of different names and if the name is joe maybe we want to say you know thanks joe i don't know something random right well what we can do is use this elif statement the l if statement can be used as many times as we want but it must come after an if and it must be before any elses so i can't just go ahead and start writing these random elifs everywhere it only is going to come after an if statement so there's only ever one if only ever one else but as many lifts as we want and you'll see how this works in a second so the l of syntax is the exact same except it starts with the el so i'm going to say l if x equals equals joe and i'm going to print by joe why not so now let's run this let me just show you what happens when i go with joe it says buy joe and let's just print something random it gives us no now of course i don't need this else statement i can use an life without the else statement that's totally valid in this situation if i do something random just nothing will happen but if i put tim or joe then it will give me the valid response now let's add another lf let's say lfx equals equals i don't know let's go with sarah we can print random okay and now let's try this out and that works now of course we could add the else at the end but that is the basics for the if l if and else now of course you can chain and add stuff inside of another if statement i could put another if statement inside of this but just make sure you keep the indentation correct because that how it that is how it determines what we are going to be printing and what we are doing if this statement is true so in these next few sections i'm going to be talking about collections how we deal with collections looping over collections and all of that fun stuff but what is a collection well collection is simply an unordered or ordered group of elements now the two collections i'm going to discuss here in this section is list and tuples so if we have a list a list looks something like this it is simply square brackets now inside of the square brackets we can have a series of elements elements are simply some data type so i could have the integer 4 i could have the value true i could have some string high and these elements do not need to be the same type like in many other languages so this is a list and the way that the list works is that it can store a bunch of different elements and a list is an ordered collection which means the order in which we enter things into the collection matters and is maintained in fact it's very important in the list so how do i actually access elements in the list how do i deal with the list what are some things we can do with it well of course i can define a list by simply opening up some square brackets and then defining some elements inside i also can just leave square brackets like this empty that would give me an empty list the first thing to look at on a list is this function called len len will tell us the length of the list this also works on strings and a few other things as well but if i look at the len of x that tells me 3. now just to kind of show you here if i say y equals high and i were to look at the len of y after i look at the line of x we obviously get 2. so len is a function in python that we can use to look at the lengths of stuff all right so that is one of the things we can do on a list what we can also do is we can append things to it what a pen does is add to the end of the list so if i want to add say the element hello i can say x dot append now i can print out x and if we have a look we get four true high hello of course we added this element to the end of the list i can also extend the list by another list so let's say i have a list here and inside of this list i have 4 5 and just a bunch of other stuff well when i extend it what that will do is take all of the elements from this list and simply append each of them to the end of the list so you can imagine extend its internal implementation just loops through all of this and appends all of those elements to this list now what about removing something or popping something off of the list well i kind of already gave away what one of these things is but what pop does is remove and return the last element in the list so if i actually go ahead and print x dot pop what this will do is it will print high and it will remove high from the list and you can see that when we print x again so we get high and now our list has high remove because we popped it off of the end now another argument for pop is actually the index of what we want to remove when we look at a list every single element in the list is identified by a number that number is known as its index otherwise known as its position in the list when we start looking at indexes in a list we start counting at zero so the first position in the list is 0 the next is 1 and the last is 2. if we want to know the last index in a list we look at the length of the list and subtract 1. in this case we have 3 elements the last index would be 2 the first is 0. so if i go ahead and say x dot pop 0 what that's going to do is remove the first element from the list which is 4. so now we remove that and all of a sudden if we look at this new list the first element at position 0 index 0 is going to be true now if we simply want to access elements of the list maybe we don't want to remove them we just want to look at them we can say x put these square brackets which means we're going to access something and we can put the index of the element that we want to access in this case we'll access true there we go we print true and that is the basics now what i can also do is do something like x 0 equals and change its value to say hello now when i print x we'll get hello true hi let's have a look and there we go the reason i can do this is because lists are what's known as mutable this means this x right here does not actually store a copy to the list it stores what's known as a reference to the list and the actual items itself are stored somewhere else so for people that are more advanced and understand that i'm hoping if you guys have come from another programming language that makes sense but lists are mutable which means they can be changed i can change all of these elements and if i do something like y equals x i go ahead and i make that change to x but i don't make it to y you're going to notice that x and y will be the exact same so i have hello true high hello true high making a modification to x made a modification to y because x and y are storing a reference to this list not a copy of this list if i wanted to copy the list i would have to do this i would have to do two square brackets a colon inside we'll talk about how this works later but now notice if i made this copy that change does not apply to the other list there's a lot of other stuff that you can do with lists but those are the basics and hopefully that makes sense next i'm going to talk about tuples so tuples are similar to lists except they are immutable so a tuple uses round brackets instead of square brackets and it works pretty much the exact same except we cannot append we cannot remove and we cannot change elements so a tuple is really an immutable list you can think of it like that it means it cannot be changed once it has been defined if we want to change it we actually have to redefine it so what i can do is i can print out say x0 and that's fine that will give me the correct answer so that will give me zero but if i go ahead and do something like x 0 equals 5 and i try to do that you're going to notice we get an error because the tuple object does not support item assignment reason for that is because again it is immutable i also cannot do something like x dot append i can try but you're going to notice that again we'll get another error tuple object has no attribute append so this is a tuple they're not used a ton although they are used sometimes and just to note here you can have lists inside of lists so i can say something like you know i could have a tuple inside of a list i could have a list inside of a list inside of a list and i could have elements inside of this they don't need to be uniform size sometimes in other programming languages when you're looking at a raise if you have embedded lists every element has to be another list stuff like that just wanted to point out that you can do something like that and i think that's all i'm going to cover right now for lists and tuples all right the next topic i have for you is for loops now a for loop if you've learned in other programming languages allow us allows us to iterate a set number of times so we will be talking about a while loop the main difference between a while loop and a for loop is a while loop is running an indefined amount of times we don't know we're going based off of a condition which we'll see shortly a for loop we know how many times we're going to loop at least relatively so what i'm going to do is i'm actually going to show you how we can just create a basic for loop to print the numbers at from 1 to 10. say 4i in range and then inside of here we simply put 10. i'll talk about what this range function does in a second but let me just show you how the for loop actually operates so now i can show you that this prints 0 1 2 3 4 5 6 7 8 9 does not include 10. so the way we set up a basic for loop if we're just going to be iterating through account is we say for i or for some variable this is going to be our iterator or a counter variable whatever you'd like to call it in this is a keyword we always have for i in and then some word here in this case we're going to put range range is a function that actually creates a collection of numbers based on the input that we give it the input to range is the following start stop step so we're allowed to put up to three um and we can have less than three arguments inside of this range function essentially start stop step is saying okay what number do we want to start at what number do we stop at what number do we step at now if we only have one argument so we only pass one number by default that is the stop argument we usually start at zero so by default our range will start at zero and we will go to whatever number we put here most of the times you're just going to put one number and this defines the ending range so in this case it says okay we're going to start at 0 and we're going to go up to 10 but not include 10. notice we didn't print 10. now if we had two arguments that's going to be default start stop so we'll say okay we will start here at 1 and we'll stop at 10 but not include 10. if we add 3 we'll include a step and that tells us how much we should increment every single time by default we increment by 1 but we can increment by 2 and we can increment by a negative number as well let's actually say that we want to start at 10 and we want it to go to negative 1 and we want to step by negative 1. well let's have a look at what this looks like and just test it out okay so running you see we started at 10 right there and then we went all the way down to zero and of course we could start at negative 10 and watch what will happen here we do nothing the reason for that is we started at negative 10 we were going to negative 1 and we're stepping by negative 1. but since we were already past negative one we aren't going to go there obviously and we just immediately stop so that is kind of how the range function works so for i in range again start stop step by default if you just put one argument that's going to be the stop if you put two that's start stop you can mess around with that and see how it works but i think that's enough of an explanation the next thing we can do is actually loop through a list so let's say we have 4i in and now instead of range we'll simply just put a list we'll say 4i in range and we can do 3 4 and just a bunch of numbers here now if we print i it will simply print all of the numbers in that collection or in that list it will step through one at a time and print all of them now let's say that maybe we didn't want to do that maybe we actually wanted to keep track of what index we were at we could say x equals the list we'd say 4i in x and then um well sorry that actually would not be the right way to do we could say 4i in range the len of x and then instead of just printing i we could print x square brackets i let's have a look at this here you see how that works the way this works is we're going to go up to but not including the last index of x or the length of x sorry so in this case 1 2 3 4 5 6. so this right here will say 6. so for i in range 6 that means the maximum value of i is going to be 5. so we say x 0 x 1 x 2 3 4 5 and print all of the values out now there is another fancy thing that we can do if we want to avoid using that it's called enumerate what enumerate will do is create indexes and values for all of the elements in our list so we'd say 4i comma element in enumerate x and then what i can do is i comma element and you'll see how this works what we do is we get 0 1 2 3 4 5 and then all of the elements so this works kind of like a combination of the two for loop styles i just showed you where we actually have a range so we go from zero up to five those are all the indexes in the list and then we print all of the elements for each of those indexes in the list and we just have two variables here that denote that so the next topic to discuss is while loops now while loops are pretty straightforward essentially what they are is while condition equals equals true go ahead and do something so we're going to have some condition here before this colon and then after the colon there's going to be an indented block and whatever's in that indented block will run inside of the loop while that condition is true to illustrate this i will say i equals zero say while i is less than 10 we'll say print run and then we'll say i plus equals one this is another way that you can add one two variables so you could say i equals i plus one or you can do i plus equals one you can also do something like i multiplied equal by 1 or divided equal by 1. so multiplied by equal 2 what that's going to do is say okay multiply i by 2. we could do something like that if we wanted as well just showing you some more syntax for some interesting things that we can do in python but that's the basics of a while loop if i go ahead and run this we can see that this is going to run 10 times and there isn't really much more to talk about for the while if other than the fact that we can implement a break statement so we could also write the same code like this while true i plus equals 1 and then if i equals equals 10 break and that will simply break out of whatever the closest loop is to us imagine we had another while loop like this and we said while true inside of here then this would break this while loop not the other while loop hopefully that's making sense anyways let's move on to the slice operator so the slice operator is personally my favorite part of python there is implementations in other languages but none of them are as nice as python in my opinion and what this allows us to do essentially is to take a slice of a collection like a string or a list or a tuple and do something with it so let me just show you what i mean the slice operator is simply the square brackets like this with a sequence of colons and numbers within it the way that it works is we have a start a stop and a step just like the range function that we looked at before so if i put something like x here and then i go start stop step what i can do is say okay i want to start at zero i want to stop at index these are all indexes that we're putting in here three and i want to step by two now actually let me just stop at index 4 just so we get some more values in here but let me show you what this looks like we get the value 0 2 when i have 0 4 2 in my slice what this is saying again is start at the first index which is 0 go to the fourth index but do not include it which means stop as soon as we hit this and step by two so we're gonna start at zero then we're gonna go to two and then we're gonna go to four but since four is the stop here we're not going to include that in our slice now when we do the slice operator we don't have to include all of these different things as arguments in fact what we can do is just include a stop just include a start and all of that so just like the range function if we don't include anything so we just sorry we just include a colon like that and then we put something on the right hand side that is saying stop at whatever index we put here so if we do this it says start at the beginning and stop at the end now if we do something like 2 colon that says start at 2 and stop at the end so whenever we leave a blank we're assuming it's either the end or the beginning or one in the case of a step so if i did two colon colon maybe i did two colon four colon this is saying okay start at two stop at four and then step by one but i don't even need to include that i could just do two colon 4 but now let's say i wanted to go 4 and then colon 2 colon negative 1 what this is saying is okay start at 4 go to 2 and step by negative 1. so now what this is going to do is start at 4 which is actually this and it's going to give us 4 and then three and then it's not going to include two or any of the other ones so that's what we'll get in fact let's look at this we see we get four three now one of my favorite things with a slice operator is to reverse a list all we have to do is colon colon negative one this means start at the beginning stop at the end and then step by negative one so this will actually start stepping backwards which is kind of interesting so when we look at that we get eight seven six five four three two one zero that is an easy way to reverse a list in python now of course all this works on a string as well let me show you that with s you see we can reverse the string like that and we can also just do the standard arguments that we would typically do let maybe we'll just step by two so start at the beginning stop at the end and step by two we get hlo so that's the basics of the slice operator there's a bit more stuff that we can do with this but that is kind of how it works and i believe this works on tuples as well we can just try it out to make sure that i'm not lying to you guys but if i do that you can see that that does indeed work and we can use the slice on kind of any collection of elements all right so now we are moving on to sets which are an underrated but extremely useful data type in python now a set is simply an unordered unique collection of elements what that means is there is no duplicate elements we do not keep track of order or frequency of elements all we care about is if something is there or if something is not there the reason we do this is because a set is extremely fast to do what's called lookups removals or additions when we're talking about a list let's say we have something that you know has a bunch of elements in it if we want to say remove the first element from the list that actually involves shifting the position of all of the other elements because we're keeping track of the positions of these elements with the set since there is no notion of position adding and removing something is as simple as just adding or removing that element there's no other operations that need to be done which mean it's very fast to use so think about a set to be used only in a situation where you care if something exists or doesn't exist not about the frequency or order in which that item exists so to create a set is pretty straightforward we can say x equals set and we use the open bracket and close bracket now the reason we don't actually write something like say s equals and then this which is really the representation for a set is because what this will do is create a dictionary now technically if we want to create a set we can do something like this and this will create a set for us that initially has the elements 4 32 and 2 inside of it this is what's known as a set literal if you're not going to be creating an empty set it's totally fine to do it like this so long as you add an element inside but if you are creating an empty set then you need to use this constructor otherwise you're going to end up creating a dictionary which is not what you want to prove the simple point to you i will print out the type of just an empty you know set representation and you'll see that it gives me dict like that of course that's not what we want anyways let's have a look at this set and i'll just show you what i mean by unique unordered collection of elements so 4322 if we print that out we get 32 to 4 so obviously a different order than how we added in there and notice that the duplicate twos were removed now the set operations are pretty straightforward we can add something to a set with s dot add our set dot add i'll put five and inside of here and let's just keep printing out s there we go we can see we added in there we can also do s dot remove 5 and that will well since there's nothing in there give us a key error now if there is the element in there so we can do it like this it will remove that element for us and then there's a few other things that we can do as well for a set one of the good ones is actually checking if something is in a set what i can do is say 4 in s what this will do is simply check if the element 4 is in the set and give me a true or false in this case it is true and remember this happens in what's known as constant time which means it's just extremely fast to do this as opposed to a list so we could say 33 in s that's going to give me false now the parallel i want to make here is if i had s equals to 4 32 2 2 like that so actually let's go s2 and i said print and let's just go 2 in s2 this operation the one that's actually in the set is going to happen much much much much much faster than this one of course this isn't a big deal right now because these collections are quite small but as these get extremely large just understand that using a set is very beneficial when it comes to looking things up checking if something's in there removing and deleting there's a few other operations we can do on sets let me just define s2 and i'll just quickly show you a few of them we can do for example the intersection or the union of these sets so i can say s dot union s2 and we'll go ahead and have a look here and we can see we get the union of these two sets essentially adding them together we can do the difference of the two sets if we want we can do the intersection and we can do the symmetric difference and all that other fun stuff that you can do with sets now i'm not going to get into all that stuff just know that these are sets and that's some of the stuff that you can do with them so now i'm going to talk about dictionaries now if you're from another language what may be familiar to you here is a hash table or a map something like that they're very similar to dictionaries but a dictionary is essentially a key value pair you have some key you have a colon and then you have some value that it corresponds to now of course that value has to actually be a valid data type but it could be something like a list it could be a single value like that and the way that you access and create new key value pairs is something like this i can print out say x and then the key inside of here in this case it's actually called key and what that will give me if you look down here is simply the value 4 because well that's what corresponds to this key so you have keys and you have values now to add a new key is pretty straightforward what you can do is you can say x inside of square brackets you can define whatever key you like it can already exist if you want we can say something like key2 and we can make that equal to 5. now note that these keys do not need to be the same sorry same data type so i don't have to have two string keys i can have integer keys i can have whatever keys i want do something like x2 equals 8 and there we go you see that works perfectly fine in fact i can make this a list just to prove to you that the values don't have to be the same either and there you go now just like a set this actually works using a hash which means this is very fast to retrieve add and modify values within the dictionary in fact it's so fast you can kind of assume that it's in constant time although there is a chance there will be something known as hash collisions although i'm not going to talk about that because that's probably a little bit more advanced than what most of you know anyways what we can do here in terms of operations on the dictionaries we can check if something is in the dictionary so i can say okay is some key in the dictionary key in x there we go print that out and that says true a few other useful things that we can do is we can get all the values from the dictionary so we can say x dot values print that out and it says addict values and it gives us a list of four usually when you do this you're going to want to actually create a list out of this because that is a different data type that's returning to us and there you go we get the value 4. now similarly we can do dick.keys so x dot keys and there we go we get a list that has all of the keys in terms of iterating over or deleting values i'll first show you how you delete something to delete something we can say x and then the key that we want to remove in this case it will remove this key so let's go ahead and do that and well i guess it didn't really show you that it was deleted let's just print it out to prove that there you go and we get an empty dictionary of course like i showed you before we can use that in operator and to loop over it there's actually a few interesting ways that we can do this so i can say for a key value in x dot items and then what this will do is simply return to me all the keys and values so i can print key value and you'll see we'll get key four so if i want to loop through all the keys and all of the values i can use dot items if i don't want to do that i can just say four key and then i can say in x what this will do is simply just give me all the keys in x and if i want to access the value of course i could say x key like that and that will give me the value and we get the same thing popping up there that's kind of the basics for the dictionaries there's a few other methods as well but i'm not going to talk about those um that is a dictionary and this next one is a fun one this is comprehensions now as far as i know python is one of the only programming languages that actually has this a lot of people absolutely hate it but i personally love it and if you learn to love it you can use it quite well now to do a comprehension essentially what that is is a one line initialization of a list of a tuple of a dictionary of many other things so let me just show you what i mean i can do something like x equals a list and then i can say x for x in range five now if i go ahead and i print the value of x you're going to see what we get here let's run it like that we get zero one two three four the way this works is essentially we can actually define a for loop inside of this list and what it will do is say okay we're going to loop through as if we normally would and whatever we have on the left hand side here is actually the element that we're going to add into the list so i could do something like x plus 5 for x in range five and there we go we get five six seven eight nine ten i can also do something like you know x mod two and or x mod five there we go i can also you know grab something else i could say zero for x in range five that would give me a list of all zeros you can see how this might actually be useful now if we want to go into a more complex example i could do a list and then inside this list i could say 0 for x in range 100 for x in range five now what that's going to give us is five of these lists that each have a hundred zeros inside of them you can see that's quite large but that is kind of how that works now we can also go ahead and add some more complex stuff to this too we and say 0 for or i can say i for i in range 100 if i mod 5 equals equals 0. so essentially if if i is divisible by five then what we can do is actually add it into the list let's have a look at that and there we go we get all the increments of five so you can play around with that and see how that works but this also works for dictionaries in fact let's just do the same thing here let's make it a dictionary and now we'll just go i colon zero so we have all these keys that are initialized at zero we go there and have a look we can see that dictionary works and of course we could do the same thing for a set we can just say i for i in range blah blah and there we go now we get a set so we can actually do this for tuples as well except we're not going to do it in the way that you might assume if you just go ahead and do this this actually returns to us what's known as a generator object it's a bit more advanced for this kind of video so i'm not going to talk about that but what we can do if we want to make this work for tuple is we actually type tuple we can use the tuple constructor which is simply this and then do the comprehension inside of there now that will return to us the tuple you can see i tried to do it the other way before and that returned to me the generator object anyways that is comprehension these can be used in a whack of different things they're definitely interesting and good to know and one of the best features of python that is not in many other languages so now i'm going to start talking about functions so to define a function in python you simply use the def keyword this means define then you pick your function name in this case i'm going to pick func the function names are the same as variable names in terms of how you name them you can put some positional parameters inside of here if you want or you can leave it empty you add a colon indented block then anything inside of the indent will run when you run the function so let's go ahead and actually just run this and show you the basics of this so that is pretty much how you run and define a function of course you can define multiple functions you can actually define functions inside of functions if you wanted to this is totally valid if i wanted to do something like this and then i could call funk like that now of course this is a more advanced use case but just showing that you can do that because of the way that python works in fact functions are actually objects which means you can technically return them i'll show that in a second but let me talk about arguments first so let's say i want to add the argument x y inside of here of course that means now when i call the function i need to add some value for x and for y so let's go five six and now if i after run want to print those i can print x and i can print y let's have a quick look we get run 5 6. of course we can return something from a function as well maybe i'll return x multiplied by y now if we actually go ahead and print the value of this function what will happen is it will evaluate what is here return that to us and print that out we get the value 30. now note that when you return multiple things from a function which you can do i can return x multiplied by y and maybe x divided by y as well this will return the value to us in a tuple so if you look here we get actually two values we have i guess the x y value here and that's inside of a tuple now if we want to unpack this tuple and say separate this out into different variables we could of course index at zero and index at one but a much cleaner and faster way to do this is to do something like r1 comma r2 equals func 5 6. what this is going to do is take these two values here and simply separate them into the r1 and r2 variable now if i go ahead and i print r1 r2 and i have a look here you can see that we get 30 and then 0.83334 that is the basis for a function if you want to do a optional parameter you can do something like z equals you can set a default value i usually set it as none and what this means is that you do not have to pass that in but if you want to you may and it will override the optional value that you have here so let's just start by actually printing out zed i'm not going to call it with zed to start you can see that oops let's run that for a second we get run five six none and now if i add a z so let's just add seven there we see that instead of none we are going to get seven printing out right there that is the basics of a function and now we're going to move on to some other more advanced aspects of it all right so i'm going to talk about something that's really cool called the unpack operator and then i'm going to talk about star args and star star quarks but i first want to show you an advanced example of a function so if i say define func like this and then maybe i'll say take x and i define func 2 inside of here this is totally valid by the way you can put a function inside of another function and then inside of here what i'm actually going to do is say this function is going to print x and i'm going to return func 2 but notice i don't call it now this is just to prove to you that functions are objects hence they can be passed around just like variables so what i can actually do here is i can go ahead and i can say print or sorry not print but i can call func 4 or func 3 and then i can actually call it like this what this is doing essentially is saying okay i'm going to call this function here with the value 3. what this function does is it returns to me another function so it gives me func 2. notice it's not calling the function it's simply returning it now i'll actually just show you what i mean first before confusing anyone let's print this out before i do the call statement on it but you can see that this actually tells me this is a function object it's a func.local's func 2. so it's pretty much saying that funct2 is defined within func now if i actually call this because that's just the function reference or object it's not actually you know being evaluated if i call it like that we can go ahead and we get 3 and then we get none of course the print statement is going to print none because there is no there's nothing to print from the return of func 2 but just have a look here we get 3. now this is equivalent if i did something like this i said you know x equals func and then on the next line i just called x since x is equal to a function func two i can call it just like i showed you before and there we go we get three anyways that's the advanced aspect i wanted to show now what i want to do is show you about star args and star star quarks uh so i'm going to put in like this all right so before i define what this does what i'm going to do is just show you what the unpack operator is in python so let's say i have a list maybe we'll call it x and we just have a bunch oops of random numbers in this list so what the unpack operator does is actually separate all of the elements from a list or from a collection into individual elements the best example of this is the print statement if i print asterisk x which means unpack x what this is going to do is take all of these elements out so separate them by individual elements and pass them into the print statement as arguments so instead of just printing you know say the entire list what it's actually gonna look like is print one comma two three comma two three six blah blah you get the point that is what this is going to do so just have a look at what happens when i print that i get all of these things separated by spaces like what happened if i just pass them in individually not being in the list now look what happens when i just print x let's have a look see it actually prints the list out so what this does is unpack whatever we have in a tuple or a list or some kind of collection and sends it through as arguments to a function so that's where star args and star star quarks come in although you'll see that in one second so let's say i have you know x y that we need inside of a function we got to pass x y what this will do is simply print x and then print y now let's say i actually have maybe a bunch of pairs that i want to pass this function so maybe i say pairs equals and then i have like one two three four well what i'm going to do is do a for looping and say four pair in pairs and what i want to do is call this function with those pairs now the naive way to do this would be to go func okay pair and then pair 1. great that would work but that is not the pythonic way to do this what we can actually do is do asterix pair and what this will do is take 1 2 and take 3 4 unpack them separate them and pass them as arguments to funk so if you have a look at that that actually works and that is why the unpack operator is really useful you can also use this actually on dictionaries as well and i'll show you how it works with dictionaries a little bit more complicated it involves two asterisks what this does is if i have keys i can say x representing obviously the argument x and then make that equal to 2 and then i can say y and this could represent the argument y and i'll make that equal to 5. now if i run this this works fine i needed two asterisks because this was a dictionary and that is kind of how this works um yeah i don't i guess i really need the for loop anymore to illustrate this but the double asterisk is used for dictionaries the single asterisk is used for a tuple or for a list now i just want to make the point here that let's say these are not in the correct order so it's y and then x this will still work and that's actually why this is really useful because you don't have to have it in the correct order so long as you name the arguments as the keys so now hopefully that will explain to us how star args and star quarks work so star args and star star quarks essentially imagine you have a function you don't know how many arguments positional or keyword arguments you want to accept that's what quark stands for keyword arguments well what you can do is you can use star args and star star quarks and what that will do is allow you to pass in an unlimited amount of regular arguments and keyword arguments so if i actually go ahead and go funk and then i pass like one two three four five and maybe i'll pass some keyword arguments like you know one equals zero two equals 1. i know this doesn't really make any sense but you get the idea now if i actually run this and print it out you can see that when i print args and print quarks we're getting a tuple that has all of the positional arguments which are these and all of the keyword arguments which are 1 and two now if i wanted to actually use any of these what i can do is i can unpack them so first of all i can unpack args and what this does if we have a look here is it will print out one two three four five i could try to unpack quarks but you're going to see what happens when i do this and hopefully if you remember the last example you'll realize why this is not going to work it says 1 is an invalid keyword argument for print so what this is going to do when i unpack quarks is it's going to take all my keyword arguments and it's going to say 1 equals 0 and it's going to say 2 equals 1 and pass that to the print statement now obviously 1 and 2 well those are not valid arguments for the print statement so we're going to get an error anyways that is args and that is quarks you're going to have to look into this on your own and kind of learn about how it works but that is the basics and i just wanted to show that to you so that you're aware that you can do these cool fancy things in python this next one is going to be very fast but this is just defining scope and global so when we look at a function like this there is a notion of a scope so we have x equals tim we have defined func and then we have name as a parameter and what we're doing is we're saying okay we're going to change x to be equal to name so essentially if i was naive and i didn't know any better i would assume that what's going to happen is while this variable up here would change when i pass this name to this function any of you that program before probably know that's not going to work but if you have a look here you can see that x does not change before or after when i call func with the string changed the reason for that is that this x variable is local it is within the scope of this function which means it cannot be used access change from with from outside the same thing here with this x this one is actually global this is on you know not not defined within any scope other than this file which means well i can't just directly change it from this function i could however access it from this function i could print it here but i can't actually change its value because if i do that what's going to happen is i'm going to create a new x inside of here which is equal to name and it will be local to this function it will not modify this however there is one interesting thing we can do in python which is the global keyword if i global x now you're going to notice that the expected behavior will occur now we get tim and we get change what that is saying is okay i want to use x as a global variable so i want to reference x in the global scope never use this this is never good to use and if i ever see a python program that has it i always get upset but this is something that you can use and i feel obligated to show you because there is some very very rare situations where you may need to use that all right so now i'm going to spend about 10 seconds showing you how to actually raise an exception in python there's a keyword called raise maybe in java you've seen something like throw and raise can raise an exception if you wanted to do that so i could raise exception and then inside of here i could just say bad you know whatever i want now if i run the program as soon as we hit that line immediately i'm going to get an exception and it says raised exception bad exception bad of course that is the basics there is more arguments and things you can do with this this is a base class which means you can extend it when you get to object oriented programming make your own exceptions and make all that fancy stuff for our cases that's all we really need to know i could raise say like a file exists error any other kind of error that i want and then again add some description for it by just putting a string inside of the brackets but that's enough for that now let's show how we can actually handle exceptions all right so now that we know how to raise exceptions it makes sense to learn how to handle them so in python rather than having like a try catch we actually have a try except finally block so what i can do is do something like try that means i'm going to try to perform whatever code is inside of here maybe i'm going to get an integer division by zero error so i can do you know 7 over 0 that's going to raise an error then i can create an except block i can accept an exception as e what this is going to do is mean whatever the exception is will be stored in the variable e and then so i could print out that exception and we can continue running the program this is the basic try except block you don't actually need to define something here i can just say try accept like that if i want and also accept a specific exception so i don't have to just put exception this is general this means any exception that occurs i will actually catch you can only catch specific exceptions if you want but again that's up to you so in this case you see we get division by zero it's just printing out but it didn't actually raise or you know show us that error so it did raise it but we didn't actually see it now if i go ahead and just do this what we can do is we can say oh well that is the actual problem and now our program is going to crash and not work but if we have this except block like this of course we're good to go now there also is a notion of a finally block the final block will run no matter what usually you put clean up type operations inside of here maybe you're trying to write to a file some exception occurs and then no matter if this was successful or not you want to close the file after you would put that inside of finally so i could say print finally like that have a look here and you can see we get finally i'm not going to go through this too much i assume if you're going to be using this you understand how try accept and finally work but that is the implementation in python and that is the basics for raising and catching an error and now we're going to discuss the lambdas so lambdas are actually a really cool aspect of python i'm pretty sure they have them in many other programming languages as well but it looks something like this essentially a lambda is a oneline anonymous function what that means is not really a named function you don't define a lambda using the def keyword what you can do is something like x equals lambda x and then x plus five what this means is this lambda is going to take one argument which is x and it's going to return x plus 5 not multiplied by x do i mean to do that that means if i call x like this and i go i don't know x2 and we print this let's just go ahead and have a look at this here oops again did not mean to do that we see that we get the value 7. now i will note that this is not the advised way to use a lambda we're going to see how to use it in just a second in the next section but this is the basics of how it works it's just a oneline anonymous function so i can do something like x y as well and then i can do something like x plus y not capital y and if i go ahead and call x with i don't know 2 3 or 232 sure that's fine let's have a look here we get the value 34. so hopefully that makes sense on how the lambda works it looks intimidating but it's really not that complicated and in the next one you'll see why these are useful and now i'm going to talk to you about map and filter which are two useful functions in python which make use of the lambda functions now you don't necessarily need to use lambda function but a lot of times it comes in handy so let me show you what i mean let's make a list let's add oops i wanted to do a few more commas than that let's add a bunch of elements inside of here to make it kind of nice and long so we get some interesting output and now what i'm going to do is i'm simply going to show you how we use map so what map will do is we'll take all of the elements of a list and use a function to map them into a new list so if i say something like mp standing for you know map i can say map which is the actual function now what i do is i put a function inside of here that i want to use for the map so this will make sense in a second but i'm going to say lambda x x plus 2. so this is essentially saying add 2 to every single one of these elements or add 2 to x in this case and then what i do is simply pass x now i know x is kind of confusing so maybe we'll just change this to i so that's easier to differentiate but what this is going to do is say okay we're going to map all of the elements inside of x so in this list x to this lambda function which means take this lambda function and apply it on every single element of x and then put that into a new list now what i'm going to do is i'm going to print the list representation of mp map actually returns to us a map object we can use that if we're going to iterate over it but it's usually more useful just to convert it right into a list so let's have a look at what this does and there we go now we get three four six and you can see all these elements have been added by two now we can do a more complicated one maybe we can multiply by two you'll see more of a difference and there we go now the next function i want to show you is filter so hopefully you get the idea of how map works but filter i don't want to say it the opposite but it does something a little bit different so this function here which is lambda what it's going to do is instead of actually returning some value it's going to return true or false and it's going to tell us whether or not we should include the item in our final filtered list or filtered object so essentially this lambda function or whatever function we put inside of here has to return true or false based on the value of an item so what i could do is say something like i is i mod 2 equals equals 0. so this means you know only return it if it's even so this is the function take some value i tells us if it's equal to or sorry divisible by 0 and if it is we'll include it so let's have a look now and you can see that we only get all of the even elements in our list now of course what we can do is also define a more complicated function so we can say define func take some value let's go with i and we can do the same thing here we could say return i mod 2 equals equals 0 but we could also say you know i equals i multiplied by 3 so we can do that and then we can say i mod 2 equals equals 0. then instead of using a lambda here we could simply just write func that's totally fine so we just put the name of the function that we want to use and then we run this and it works fine but this is why lambda is useful because a lot of times you don't want to define your own function up here you just want to define it right inside of the map statement or the filter statement so that's kind of where you would use this there's another few use cases for it but this is kind of the most common and where you'll often see it so anyways that is map and filter and for our last and final topic i'm going to be covering something called f strings now f strings are new in python 3.6 if you have any version lower than that you are not going to be able to use f strings but they're a really cool way to actually just manipulate and create strings so what i can do is do something like x equals i can do an uh lowercase f or a capital f it doesn't matter and then a string notice that this will highlight or maybe it'll be a towel size depending on what editor you're using and well what you can do is type a string as you normally would except now if you want to embed an expression what you can do is do that inside of curly brackets so i can do hello and then i could say like you know six plus eight and this will actually be evaluated and now when i print this out it will give me the answer 14. so this is great because if you have some variables say like i have you know i don't know tim equals 89 or something and i want to embed that in the string without having to concatenate it and convert it into a string with str i can simply just use the f string and just embed it with all the formatting uh by putting it inside of these curly braid braces so that is kind of how that works you can go ahead and mess around with this if you want to really see how it works but essentially you just put an expression inside of these curly braces it will be evaluated and then it will turn into a string really great easy way to work with strings of course you can print an f string as well i could print hello and then we can do that and in fact let's run this and just see what we get and there we go we see we get hello 89 so that is f strings so with that being said i'm going to conclude the video here i am officially out of breath i went very fast through this tutorial with the purpose of making it as quick as possible and not wasting any of your time if you guys appreciate this effort please do leave a like subscribe to the channel and of course let me know what you want to see next i will quickly mention that i did miss a few things in this video specifically object oriented programming and advanced language features if you would like to know about those two things i have a ton of resources related to them i will leave them in the description the first is a about an hour long video on object oriented programming in python that covers kind of all the fundamentals and everything you need to know the next one is a whole series on expert level features in python i believe that's about six videos and covers things like meta classes context managers generators all of that anyways as i said i hope you enjoy leave a like subscribe i will see you in the next one you
