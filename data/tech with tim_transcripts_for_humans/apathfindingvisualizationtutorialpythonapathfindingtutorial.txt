With timestamps:

00:02 - [Music]
00:07 - hello everybody and
00:08 - welcome back to their python tutorial so
00:11 - in this video what we're going to be
00:12 - doing is learning about the a star
00:14 - path finding algorithm and then actually
00:16 - implementing that into a visualization
00:18 - tool
00:19 - so this is a really cool video because
00:20 - this project is just really fun
00:22 - in my opinion to actually see how a
00:24 - computer kind of goes down the process
00:26 - of finding the shortest path between two
00:28 - points
00:28 - and a visualization tool like this
00:30 - although it is kind of simple this isn't
00:31 - going to be a super complicated program
00:34 - looks really great on a resume and is a
00:35 - really great thing you can point someone
00:37 - to and say hey
00:38 - you know not only do i know how to use
00:40 - algorithms but i also can implement them
00:42 - into this cool visualization tool
00:44 - and you can now watch these you know
00:46 - this computer figure out the shortest
00:47 - path between two points
00:49 - so anyways this has really fascinated me
00:50 - let me give you guys a quick demo of
00:52 - what it is we're going to be creating
00:53 - and then i'll talk more about how this
00:54 - tutorial series is going to look or how
00:56 - this tutorial is going to look
00:58 - and kind of what you can expect from it
00:59 - so you can see here this is the basics
01:01 - we have
01:02 - just the visualization of finding the
01:04 - shortest path
01:05 - now since a star is actually an informed
01:08 - search algorithm which we'll talk more
01:09 - about later
01:10 - this means we can avoid doing a ton of
01:12 - unnecessary searches that we don't need
01:14 - to do
01:15 - so for example in an uninformed search
01:17 - algorithm they may potentially consider
01:18 - some of the nodes over here where i'm
01:20 - kind of drawing and erasing these
01:21 - barriers
01:23 - and the reason they might do that is
01:24 - because it's just somewhat of a brute
01:26 - force
01:26 - approach they're just checking every
01:28 - single possible path they're not
01:29 - actually moving in a direction that kind
01:31 - of makes sense
01:32 - whereas this algorithm here you can see
01:33 - was always kind of moving in the right
01:35 - direction
01:36 - it might have gone off a little bit
01:37 - maybe it goes down some roads that
01:39 - aren't necessarily
01:40 - correct but it always is moving in the
01:42 - correct direction and that is kind of
01:43 - what's guiding the algorithm and making
01:45 - it much more efficient
01:46 - now of course these gains are way bigger
01:48 - when you have a huge map and a much
01:51 - larger network of nodes connected
01:52 - together but in this case
01:54 - on a 50 by 50 grid which i have it
01:56 - happens pretty much
01:57 - instantly and if i omitted actually
01:58 - doing the drawing aspect where we draw
02:00 - the green and red squares
02:02 - then this would happen pretty well
02:03 - instantaneously so with that being said
02:05 - i will quickly say that this is not a
02:07 - beginner tutorial series although it's
02:09 - not going to be super complicated
02:11 - we are going to be using some data
02:12 - structures and algorithms we're going to
02:13 - be talking about this algorithm which is
02:15 - not trivial by any means
02:17 - and well if you're you don't have any
02:18 - experience with python this might be a
02:20 - little bit overwhelming so i just want
02:21 - to warn you right now
02:22 - so that being said let's go ahead and
02:24 - start talking about the a star path
02:25 - finding algorithm
02:26 - after a quick word from our sponsor i
02:29 - need to thank simplylearn for sponsoring
02:30 - this video
02:31 - and introduce you all to their data
02:33 - scientist master program that was
02:34 - co-developed with ibm
02:36 - this program is comprised of six unique
02:38 - courses that implement a unique
02:40 - blended learning experience in a high
02:42 - engagement online classroom environment
02:44 - during this program you will master 30
02:46 - plus in-demand skills and work with
02:47 - tools and languages like r
02:49 - sas python tableau hadoop and spark
02:52 - you'll master these skills through 15
02:54 - real life projects and one
02:56 - capstone project during this 12 month
02:58 - comprehensive course
03:00 - you'll also be given 1200 usd worth of
03:02 - ibm cloud credits
03:04 - to use during your 24 7 access to the
03:06 - ibm watson platform
03:08 - after completion of this course you'll
03:09 - be given certificates from ibm and
03:11 - simply learn to testify to your skills
03:13 - as an expert in data science
03:14 - get started by hitting the link in the
03:16 - description all right so now it's time
03:18 - to understand the a-star pathfinding
03:20 - algorithm
03:20 - so before i go into all the kind of
03:22 - explanations and definitions i'm going
03:24 - to quickly define
03:25 - what a few terms mean so when i say node
03:28 - i'm talking about a letter okay i'm
03:30 - talking about a
03:30 - b c d this is a node a node is anything
03:34 - in a graph that you can visit you can
03:35 - think of this as a vertex
03:37 - right say we have a triangle you can
03:38 - think of the nodes of a triangle if
03:40 - you're
03:41 - treating this as a graph as the three
03:42 - vertexes and the edges
03:44 - are going to be all the lines that
03:46 - connect those so we have nodes and we
03:48 - have edges just understand edges connect
03:50 - nodes nodes are usually represented as a
03:53 - circle
03:53 - or something that you could visit if we
03:56 - look at a grid for example
03:57 - and we have like a 2x2 grid then really
04:00 - you can draw this grid in kind of a
04:02 - graph format
04:03 - like this where all of these are the
04:06 - nodes
04:07 - and then the edges are the connections
04:09 - between these nodes which could just
04:10 - mean
04:11 - you know what it means like go from that
04:13 - node to this node
04:14 - that's all i'm saying just hopefully
04:16 - that makes sense and last thing here to
04:18 - explain
04:19 - is when we have an edge we can have a
04:20 - wedge an edge that is a weighted edge or
04:23 - an unweighted edge
04:24 - if it's a weighted edge what that means
04:27 - is that it
04:28 - takes a certain amount or it is a
04:29 - certain length so obviously
04:31 - weight one is a shorter edge than weight
04:34 - two
04:34 - so obviously this is not drawn to scale
04:37 - if you're talking about the weights of
04:38 - these edges
04:39 - but i've drawn them just with different
04:40 - weights so that for this algorithm
04:42 - it makes sense so we can actually do
04:44 - something that's meaningful but in our
04:46 - example
04:46 - we do the a-star path finding and we're
04:48 - using the grid none of the edges are
04:50 - going to be weighted they're all just
04:51 - going to be
04:52 - known as like 1. we'll just give them
04:53 - all weight 1 because we're just
04:55 - assumed they're all the same distance
04:57 - essentially okay hopefully that makes
04:59 - sense
04:59 - now let's get into the algorithm so uh
05:02 - how does this work what is the a-star
05:03 - path finding algorithm
05:05 - well the goal of this algorithm is to
05:06 - find the shortest path from point a
05:08 - to point b in a graph using the edges
05:11 - that are
05:11 - in that graph right and anything can
05:13 - kind of be represented as a graph
05:14 - just like we've been drawing over here
05:16 - and i've been showing you
05:18 - so how do we do that well this is an
05:19 - informed search algorithm which means we
05:22 - don't only just brute force and attempt
05:24 - every single path
05:25 - we actually have what's known as a
05:27 - heuristic function that helps guide us
05:29 - and figure out the correct path to go
05:31 - down
05:31 - essentially as you'll see as we go
05:33 - through this algorithm we only consider
05:35 - paths that we know
05:36 - are optimal we don't consider things
05:38 - that you know have a huge distance to
05:40 - get to them already or that look like
05:42 - they're going to be really far apart
05:43 - we may consider those but that's the
05:45 - least priority and hopefully we don't
05:47 - even have to
05:48 - we end up finding a shortest path before
05:50 - we even consider those nodes so that's
05:52 - kind of the point of this algorithm as
05:54 - you're going to see
05:54 - but i think the best way to explain this
05:56 - to you is really just to go through an
05:57 - example and just kind of slowly go
05:59 - through it as we go
06:00 - so what we need to do to start is we
06:02 - need to take our start node which in
06:03 - this case is going to be a
06:05 - we need to put this inside of our open
06:07 - set so we have this open set
06:09 - this is going to be represented by a
06:11 - priority queue when we actually do this
06:12 - implementation don't worry if you don't
06:14 - know what that is we'll talk about it
06:15 - later
06:16 - and essentially the open set keeps track
06:18 - of the nodes that we want to look at
06:20 - next you can think of it almost just as
06:22 - a queue it's the next things that we
06:24 - want to consider
06:25 - so we always start by putting our start
06:27 - node in the open set
06:28 - and we put it in the open set along with
06:30 - the distance to that node
06:32 - which we're going to say is our our f
06:35 - score
06:35 - now i need to define what this f g and h
06:38 - scores stand for because these are going
06:40 - to be very important as we go through
06:41 - this algorithm so let's do that quickly
06:43 - so h score which is of just simply a
06:45 - function h n
06:46 - so h of n gives us an estimate
06:50 - of the distance from node n to the end
06:53 - node essentially we just pass it a node
06:55 - and it looks at the end node and says
06:57 - okay
06:57 - you know i don't really know how far
06:58 - away you are but like if we're just
07:00 - doing
07:00 - absolute distance so literally from the
07:02 - center of say a
07:04 - to d even if an edge doesn't exist here
07:06 - i'm going to assume your you know
07:08 - x blocks away just based on that
07:10 - absolute distance
07:11 - that's what this function does there's
07:12 - many different distance formulas you can
07:14 - use in here i think euclidean distance
07:16 - is popular
07:17 - some people use manhattan distance
07:19 - that's what we're going to use here
07:20 - lots of different distances anyways this
07:22 - is just some function that gives us the
07:24 - distance from node n
07:25 - to the end node there we go and again
07:28 - this is not like a super correct
07:30 - distance this is just a guess at what
07:32 - that distance is based on some formula
07:34 - that we've implemented in there
07:36 - awesome that's the h score your g score
07:39 - is the
07:39 - um the current shortest distance to get
07:42 - from the start node
07:44 - to this node so we're talking about the
07:46 - g-score of
07:47 - c then whatever the shortest distance
07:49 - from start from point a which is our
07:51 - start node
07:52 - to point c that we've currently taken
07:54 - that we've currently found
07:55 - will be this g-score and the f score is
07:58 - simply the addition of the g
07:59 - score and the h score so if you
08:01 - understand that and i wrote the kind of
08:03 - formula down here so we can remember
08:04 - what makes everything up the f score is
08:08 - pretty much trying to give us an
08:09 - estimate say okay we've already taken
08:11 - two blocks to get to this node and from
08:14 - this node we think it's going to take
08:15 - like five blocks to get to the end node
08:17 - so we have a total score of
08:19 - seven okay should we start looking at
08:21 - this one first or should we consider
08:23 - this next node that has a lower f score
08:26 - right because maybe a lower f score
08:28 - means that this is actually closer
08:30 - and we should take that node over the
08:32 - other node that's the way that we
08:33 - prioritize which nodes we consider
08:35 - is by using the f score and the f score
08:37 - is made up of the g score and the
08:39 - h-score
08:39 - so again g-score is the exact distance
08:42 - the shortest distance that we
08:44 - found currently to get from the start
08:46 - node
08:47 - to whatever node we're talking about if
08:48 - we're talking about node d whatever the
08:50 - distance is whatever shortest path we've
08:52 - currently found to node d
08:54 - that's the distance we're going to have
08:55 - for our g score the age score is the
08:57 - heuristic which is just the guess
08:58 - at how far away we are from the end and
09:00 - the f score is the addition of those two
09:02 - scores to give us an estimate of how far
09:04 - away
09:05 - this node is from the end node uh or
09:08 - like
09:08 - what that finalized path would look like
09:10 - so that is
09:11 - these scores and they're going to be
09:13 - very important as we go through here
09:15 - so let's actually start this we have
09:16 - open set we have zero
09:18 - a so of course a is g score uh f score
09:21 - and h score is going to be zero
09:23 - because well it's itself right at our
09:26 - start node
09:27 - we can't have an f g and h score that's
09:29 - higher than zero because
09:30 - we're just already at our our same note
09:32 - hopefully that makes sense
09:33 - now the rest of these scores though
09:35 - we're going to start them at infinity
09:37 - and you're going to see why
09:38 - but just imagine the age score is not
09:40 - really relevant
09:42 - right now for these ones but just
09:43 - they're all infinity to start
09:45 - okay so we start them off at affinity
09:47 - because currently we have
09:48 - no idea we have not found any path these
09:50 - nodes we haven't considered anything
09:52 - from the start node so we just assume it
09:54 - takes infinity to get there
09:56 - that's just our main assumption and
09:57 - these might actually stay infinity
09:59 - because we may never actually even
10:01 - consider them so we have
10:02 - zero a and we pull zero a out of the
10:05 - open set we've just set everything up
10:07 - we've you know initialized our table
10:08 - we pull it out so we delete it from the
10:10 - open set and we start looking at it
10:12 - so okay we're on node a now we're
10:15 - considering node a i think i'm just
10:16 - gonna underline
10:17 - what node we're currently looking at so
10:19 - i'll just underline it like that
10:21 - we're looking at node a and the first
10:23 - step is to look at the neighbors
10:25 - of node a so in this case the only
10:27 - neighbor of node a
10:28 - is c and there's only two ways to get to
10:30 - node c there's two edges so we have the
10:32 - two edge and the one edge
10:34 - so we start by just looking at any edge
10:35 - there's no order we take
10:37 - in looking at it so we say okay to get
10:40 - to node c
10:41 - we have edge one right so we have this
10:43 - edge here
10:44 - so what we're gonna do is we're going to
10:45 - say okay is this edge
10:47 - that we've currently taken like the
10:49 - current path to node c that we're on
10:52 - how long is this path what is the
10:54 - current path well
10:55 - the current path is distance one so we
10:57 - compare that now
10:58 - to the g-score of node c and we say okay
11:02 - is the current score that we're looking
11:03 - at score one shorter than
11:05 - the current g-score of node c so we
11:08 - compare it to infinity which is right
11:09 - here and we say which is shorter
11:11 - well of course distance one is shorter
11:13 - than infinity or smaller than infinity
11:15 - so we go ahead and we update the g-score
11:17 - and make it one
11:18 - and we say okay now currently the best
11:21 - path we know
11:22 - the best we've found to get to node c is
11:24 - from node a to node c
11:26 - taking edge one right taking the edge
11:28 - with weight one so we update that score
11:30 - then we go ahead and we update the h
11:32 - score so we say okay
11:34 - since we're considering this node c now
11:35 - we found a better path
11:37 - we're not skipping over it this is the
11:38 - correct way to go what is the h
11:40 - score the tentative distance from node c
11:42 - to node d what is our guess for that
11:44 - well our guess for that we can just kind
11:46 - of make that up i'll just say oh we
11:48 - think that's going to take
11:49 - you know one distance point to get there
11:50 - so i'll just write 1 here
11:52 - of course obviously it's 2 but we don't
11:54 - know that we're just taking an
11:55 - absolute distance guess so we take we
11:58 - take a guess of one
11:59 - and then we update our f score and we
12:00 - say okay well the f score now is going
12:03 - to be
12:04 - two because of course the g score and
12:06 - the a score added together
12:07 - is two and once we update the g score we
12:09 - update the h score and then we update
12:11 - the f score accordingly
12:12 - so hopefully this is all making sense
12:14 - but this is the basics of it
12:16 - so 2 1 1 those are our scores and then
12:18 - we go ahead and we update this
12:20 - last which tells us where we came from
12:22 - to get these scores so we came
12:24 - from node a to get to node c there we go
12:27 - that just tells us
12:28 - what node was the last node we came from
12:30 - awesome
12:31 - now i'm actually just going to delete
12:32 - this other edge because for our example
12:34 - we're not going to do anything with
12:35 - multiple edges so i think it'll just
12:36 - make more sense to do this
12:38 - so let's go ahead and do that so now
12:40 - once we've considered this node
12:42 - and we said okay you know this was the
12:43 - shortest path what we do is we take that
12:45 - node and i'm just going to erase some of
12:46 - this stuff now to clean it up
12:48 - and we add it into the open set so we
12:50 - say okay we've considered node a
12:52 - now we just looked at node c as a
12:54 - neighbor so let's throw that into the
12:56 - open set so we're going to say okay
12:58 - what's the f score of node c that's two
13:01 - let's add that to the open set so we say
13:03 - two c
13:03 - say the current choice distance um in
13:06 - the open set is two
13:07 - c now we look in the open set and we say
13:10 - okay
13:10 - give me the node that has the shortest f
13:12 - square well there's only one thing in
13:13 - the open set
13:14 - so we have to use this one so we take it
13:17 - out and i guess i can just
13:18 - move it like this if i really wanted to
13:20 - oops i forgot a bracket let's
13:22 - move that there so we take this and we
13:24 - move it out of the open set and we start
13:25 - considering node c
13:27 - so double underline and now we do the
13:29 - same thing we look at the neighbors of
13:31 - node c
13:32 - so let's start by going to node b let's
13:35 - look at node b
13:36 - and we go okay so what is the current
13:38 - distance that it takes us
13:39 - to get from node c to node b well we got
13:43 - to know
13:43 - go from a to c that's one and then from
13:46 - c to b
13:46 - that's four so our current kind of
13:49 - tentative g score right now is
13:50 - four so we say all right if we're using
13:52 - node c to get to know b
13:54 - we're gonna have a g score of four so we
13:55 - take four right and we compare it to the
13:58 - g
13:58 - score of b and we say okay is that
14:00 - larger or smaller
14:01 - well that is going to be smaller so we
14:03 - update the g score of b
14:05 - and then we go ahead and we update the h
14:06 - score and the f score
14:08 - so what's the h score from node b to
14:10 - node d let's just say that that's a
14:12 - distance of
14:13 - let's give it 2 that's going to be our
14:15 - guess so we'll say okay that's going to
14:17 - be 2.
14:18 - so now our f score is 6. now we've
14:21 - looked at node b
14:22 - we've considered the neighbor so we add
14:23 - node b into the open set
14:26 - with its current f score so we say 6
14:29 - b and that's now inside of the open set
14:32 - so let me just erase this now to clean
14:33 - this stuff up
14:34 - and then we'll move forward and we'll do
14:36 - the next neighbor so of course the next
14:38 - neighbor is d
14:39 - which so happens to be our node but
14:40 - don't worry we're not done the algorithm
14:42 - yet
14:43 - so we go from c to d and we say okay
14:45 - what is the tentative g-score that we've
14:47 - kind of just calculated here
14:48 - between node c and node d from the start
14:52 - node well that's of course going to be
14:53 - three
14:54 - so we go here to the g-score we say okay
14:57 - well
14:57 - is that less than infinity yes it is so
14:59 - we update that
15:00 - that becomes three what do we do next we
15:02 - update the h score and we update the f
15:04 - score
15:05 - so let's say that our guess from node d
15:08 - to d
15:08 - well that's obviously going to be zero
15:10 - so we'll put zero right there
15:12 - and then what about the f score well
15:14 - that's just going to be
15:15 - 3 right so there we go so now we go into
15:17 - the open set and we put inside of here
15:19 - 3 d like that boom so now we've
15:23 - considered c
15:24 - we're done with c we can erase this
15:26 - right here and let me just
15:27 - fix this this bubble uh we can erase
15:30 - this four
15:31 - and now we go into our open set and we
15:33 - say okay give me
15:34 - the node in here that has the shortest f
15:37 - score or the lowest f score well of
15:38 - course that's 3d
15:40 - so we pop 3d out of here and as soon as
15:42 - we do this as soon as we take
15:44 - the end node out of the open set we
15:46 - immediately finish the algorithm and we
15:48 - know that the shortest path
15:50 - now has to be from a oops
15:53 - it was not supposed to be an eraser from
15:55 - a
15:57 - to c to d now the reason we know that
16:00 - and let me just actually fill some of
16:01 - these things and i forgot to fill in the
16:03 - last column from d
16:04 - that was c from b that was
16:08 - c and from a the last would have just
16:10 - been nothing but anyways this is what
16:12 - our last column would look like so the
16:13 - node that we came from
16:14 - and essentially what we do is okay we
16:16 - found d we know this must be the
16:18 - shortest path
16:19 - because if d was in here anywhere else
16:22 - we would have picked it out and it would
16:23 - have had
16:23 - a shorter f score right because we
16:25 - picked out the smallest f score
16:26 - so we reached d we took out the last
16:28 - node and now the algorithm is complete
16:30 - it's finished
16:31 - and all we have to do is find the path
16:34 - now the way we find the path is we just
16:35 - backtrack we say okay
16:37 - d came from c c came from a
16:40 - so that must be our path right there and
16:43 - that is our path and it so happens to be
16:44 - the shortest path
16:45 - just by following that formula now of
16:48 - course things can get a little bit more
16:49 - complicated
16:50 - and there's more edge cases and things
16:52 - to consider but that is the basics of
16:54 - this algorithm you have this h score
16:56 - and this f score and this g score that
16:58 - help show us
16:59 - where we should be going what direction
17:01 - we need to move in and what nodes we
17:03 - consider
17:04 - next so let's just imagine for a second
17:06 - though that maybe we didn't just
17:08 - immediately consider this this end node
17:11 - right maybe we didn't hit the endnode
17:12 - let's just imagine that actually d maybe
17:15 - isn't necessarily the endnote
17:17 - maybe there's another node here that is
17:19 - the end node and that's our new end
17:21 - then what we would do is we would simply
17:23 - since d was already in here we'd pop it
17:25 - out we'd consider the neighbors of d
17:27 - so we considered c we consider b and we
17:29 - consider e
17:30 - and remember if i'm considering b what i
17:33 - would be thinking about is okay so to
17:34 - get from a
17:35 - to c to d to b what is the distance
17:39 - going to be
17:40 - and of course that distance is going to
17:41 - be larger than whatever the current
17:43 - distance was the current g-score to get
17:46 - to b so actually
17:47 - one two one um is going to be the same
17:50 - but since it's the same
17:51 - we don't bother updating it we just say
17:53 - okay we don't need to update that
17:54 - because obviously the current
17:56 - distance to get from a to c to d to b
17:59 - well that's four
18:00 - the distance that we have as the g score
18:03 - that's four
18:04 - so since that's not smaller we just
18:05 - don't do anything we just
18:07 - skip over b and we say okay we don't
18:09 - need to look at that anymore we're not
18:10 - adding it back in the set
18:12 - we're just moving past it and then we go
18:14 - and we consider d
18:15 - all right we consider c and we consider
18:17 - e so we do e our c
18:19 - we determine that well to get to c is
18:22 - obviously not shorter to go
18:23 - ac dc than it is to just go ac so we
18:25 - don't update that
18:27 - and then we consider e we'd update e in
18:30 - here with whatever the values are
18:32 - we'd add e to the open set the distance
18:34 - for e would
18:35 - almost likely be larger than the
18:38 - distance for b
18:39 - we would take out b we would consider
18:40 - that and and that's how we would keep
18:42 - going so i know i'm kind of just
18:43 - fast forwarding through the rest of the
18:45 - algorithm it does take a long time to
18:46 - walk through
18:47 - but that is the basics and of course as
18:49 - we go through this it's going to start
18:50 - to make a lot more sense
18:52 - but that is how the f g and h score work
18:54 - and hopefully you understand how we're
18:56 - considering
18:57 - nodes that are closer first with that
18:59 - estimate of that h score
19:00 - um that g score that's telling us the
19:02 - actual distance and that f score that's
19:04 - the combination
19:05 - in between so anyways that is going to
19:07 - be my explanation if you don't
19:09 - understand that i'm going to recommend
19:10 - you head to wikipedia
19:11 - maybe re-watch this see if you can do
19:14 - this yourself on it on your own graph
19:16 - maybe do it on a piece of pencil and
19:17 - paper
19:18 - but once you feel comfortable let's move
19:19 - forward and let's actually start coding
19:21 - this out
19:22 - okay so sorry for that long explanation
19:23 - but i really do try
19:25 - and try my best to make sure you guys
19:26 - really can understand everything
19:28 - so that i'm not just blindly going
19:30 - through and showing you that even if you
19:31 - don't understand
19:32 - completely i will be re-explaining as we
19:34 - get to the implementation part
19:36 - but now let's actually start working on
19:38 - this visualization tool and more of the
19:39 - fun stuff
19:40 - so the only real prerequisite for this
19:42 - is to install pygame
19:43 - so pi game is a 2d graphics module in
19:46 - python
19:47 - really easy to use i'll explain all the
19:48 - stuff that we do here
19:50 - but to install that go to your command
19:51 - prompt or terminal and you're gonna type
19:53 - pip
19:53 - install pi game now you might if you're
19:56 - on mac
19:57 - be able to use pip three so just try pip
20:00 - install pi game if that doesn't work for
20:02 - you
20:02 - i'll leave a card to a video that
20:04 - explains how to install pygame
20:06 - and i'll leave a link in the description
20:08 - as well if you're on mac just replace
20:10 - uh pip with pip 3 and that should
20:13 - hopefully be able to install it
20:14 - and then i think you can also try python
20:17 - hyphen
20:18 - m and then pip install
20:21 - and then pie game as well now these are
20:23 - all just different options you can try
20:25 - so i'm just giving you a bunch of
20:26 - commands but in your terminal or in your
20:28 - command prompt
20:29 - pip install pi game pip 3 install pi
20:31 - game
20:32 - python hyphen m pip install pi game or
20:34 - python 3
20:35 - hyphen m pip install pi game if none of
20:38 - those work or you get like pip is not
20:39 - recognized as an internal external
20:41 - command
20:42 - watch the video it should hopefully help
20:43 - you do that anyways once we've
20:45 - done that i'm going to be working in
20:47 - subline text for this video you guys can
20:49 - work in whatever editor you want
20:50 - we're going to start by doing some
20:52 - imports so we're just going to import
20:53 - pygame
20:54 - i've already made a python file here
20:56 - we're going to import
20:58 - math like that and we're going to say
21:01 - from q
21:02 - import priority queue now we'll be using
21:05 - this later i'll explain how that works
21:07 - it's going to be for the algorithm but
21:08 - you don't need to install this this
21:09 - should be built into the python standard
21:11 - library
21:12 - now next i'm going to define the width
21:15 - of my window so i'm going to make
21:16 - everything
21:17 - square so i'm not going to have a height
21:18 - i'm just going to have a width and i
21:20 - think i'm going to make that
21:21 - 800. so width 800 and then i'm going to
21:24 - say win
21:25 - and then in this case that's going to be
21:26 - equal to pygame.display.set underscore
21:30 - mode and inside of a set of brackets i'm
21:32 - going to go width
21:33 - width so this what this does is just set
21:35 - up why is this not working
21:37 - with i'm hitting enter it's literally
21:39 - canceling what i'm typing okay anyways
21:41 - width like that hopefully that's fine if
21:44 - i could
21:44 - get the right character okay so width
21:46 - sorry about that
21:47 - but regardless what we're doing here is
21:49 - we're just setting up the display so
21:51 - we're essentially saying
21:52 - this is how big the display is going to
21:53 - be this is the dimensions i'm making it
21:55 - width by width just so it's a square
21:57 - and then i don't have to deal with any
21:58 - height variables later which is going to
22:00 - make things a little bit nicer
22:01 - next what we're going to do is we're
22:02 - going to set a caption for the display
22:04 - so not in capitals we're going to say pi
22:06 - game
22:07 - dot display dot set underscore caption
22:10 - and for the caption what we're going to
22:11 - do is just put whatever we want but i'm
22:13 - going to put
22:13 - a star like that and i guess i don't
22:16 - need to say star
22:17 - a star path finding
22:20 - algorithm this mic is really in my face
22:23 - kind of in the way of the keyboard so
22:24 - that's why i'm getting all these typos
22:26 - because i usually look down a little bit
22:27 - just pre-warning there anyways we have
22:30 - that now so widthwindpygame.display.set
22:33 - underscore caption
22:35 - and now if we actually go ahead and run
22:37 - the program we should see that a window
22:39 - pops up and then it just immediately
22:40 - disappears
22:41 - so that's how you can test to make sure
22:42 - that this is working you're not going to
22:44 - see anything right now it's just going
22:45 - to go away
22:46 - pretty much instantly but if that's
22:48 - working good
22:50 - okay so next we're going to define a
22:51 - bunch of colors now i'm actually just
22:53 - going to copy these in
22:54 - you guys can pause the video if you want
22:56 - to copy them out but all this code will
22:57 - be in the description if you want to
22:58 - copy and paste
22:59 - different aspects of it but i want to
23:01 - have all these color codes here because
23:03 - we're going to need to be using them
23:04 - for actually making the path and making
23:07 - the different squares and changing the
23:08 - color of things and all that
23:10 - so we have red this is a red green blue
23:12 - color code green blue yellow white black
23:14 - purple orange gray turquoise
23:16 - feel free to change all of these colors
23:18 - to whatever you want but just define
23:19 - them in all capital letters as constants
23:22 - and have them here so we can use them
23:23 - throughout the program now the next
23:25 - thing that i'm going to do
23:26 - is i'm going to define a class called
23:28 - spot now remember we're building a
23:30 - visualizing tool
23:31 - so i actually have to build kind of the
23:33 - main visualization tool
23:34 - before i can implement the algorithm
23:36 - because the algorithm is going to be
23:37 - dependent on what our tool looks like
23:39 - right
23:40 - so we need to figure out essentially how
23:42 - are we going to keep track of all of
23:44 - these different nodes that are in our
23:45 - grid
23:46 - because remember we're going to do this
23:47 - huge grid this grid is actually going to
23:50 - be
23:50 - a 50 by 50 grid and we can change the
23:52 - dimensions of that if we want
23:54 - and in that grid we're going to have a
23:56 - bunch of spots or a bunch of cubes or
23:58 - whatever you want to call them
23:59 - i like to call them spots but you can
24:01 - call them whatever you want you can even
24:02 - call this a node that might even make
24:04 - more sense but i'm going to go with spot
24:07 - and this spot is going to need to hold a
24:09 - bunch of different values
24:10 - so it's going to need to keep track of
24:12 - where it is so what row column position
24:14 - it is
24:15 - in the grid because this will just be
24:16 - one of those little cubes it's going to
24:18 - need to know what the width of itself is
24:20 - so it knows how to draw itself right
24:22 - if it is wrong itself although i don't
24:24 - think we actually
24:25 - actually we will need to draw these
24:26 - spots because they're going to be
24:27 - different colors
24:29 - and then it's going to need to keep
24:30 - track of all of its neighbors that's
24:31 - something that's important
24:33 - and a few other things as well so it's
24:34 - color will be the main thing because it
24:36 - needs to know
24:37 - okay am i a red node am i a green node
24:39 - am i a barrier am i the start node am i
24:41 - the end node which will all be
24:43 - represented by different colors if you
24:44 - remember the example that i did
24:46 - and so on and in fact let me just run
24:48 - the example so you can kind of see what
24:49 - i mean
24:50 - so we have like all these different
24:52 - spots right so when i click on one of
24:54 - them it changes colors and that's what
24:55 - the job of this spot class is going to
24:57 - be
24:58 - is to keep track of the color of all of
25:00 - these spots and know what location it's
25:02 - in right so then when i press space you
25:04 - can see there's red and there's green
25:06 - and then of course there's purple as
25:07 - well that represents the path
25:09 - so hopefully that makes sense uh i just
25:11 - wanted to show you that's what it is
25:13 - okay so class spot so we're going to
25:15 - define an init in here so we're going to
25:16 - say define a knit
25:17 - we're going to say self we're going to
25:19 - say row call
25:22 - width which is just going to be you know
25:23 - how wide is this spot and then rows
25:26 - now i'm just going to call this total
25:27 - underscore rows now the reason i'm doing
25:30 - that is because we need to keep track of
25:31 - how many total rows there are here
25:33 - you'll see why in just a second but this
25:35 - spot does need to know that
25:37 - and i want to avoid any global variables
25:39 - so i'm just going to throw it right into
25:40 - the instance
25:41 - so i'm going to say self.row equals row
25:43 - i'm going to say self.call
25:45 - equals call i'm going to say self.x
25:47 - equals row
25:49 - times self dot width actually this is
25:52 - just going to be width
25:53 - i'm going to say self.y equals
25:56 - call times width as well
26:00 - now the reason i'm doing this is because
26:01 - i need to keep track of the x y
26:03 - like the actual coordinate position on
26:06 - my screen
26:07 - because when i draw things in pi game i
26:09 - can't just say okay draw it at you know
26:11 - five
26:11 - five i need to draw the actual cube
26:13 - which is going to have some kind of
26:14 - width
26:15 - it's going to be sitting in some
26:16 - position so i need to know what position
26:18 - that is
26:18 - and i can determine that because let's
26:20 - say i have 50 total cubes
26:22 - and the size of my screen is 800 well
26:24 - then i go
26:25 - 800 divided by 50 which i think is like
26:27 - 16 or something like that
26:29 - and that will be the width of each of my
26:31 - cubes so i can figure out where the
26:32 - starting x and y position is by taking
26:34 - the row that i'm at
26:35 - and multiplying that by the width of all
26:38 - of these cubes
26:40 - that's the idea there we're going to say
26:42 - next self.color
26:43 - equals white so to start we're going to
26:45 - have all white cubes
26:46 - this will again change as we go through
26:48 - i'm going to say self.
26:51 - oops if i could type here equals a blank
26:54 - list and then i'm going to say
26:55 - self.width
26:56 - equals width and self dot
27:01 - total underscore rows equals total
27:04 - underscore rows
27:05 - next what i'm going to do is i'm going
27:07 - to make a get underscore pause method
27:08 - and we're actually going to have a bunch
27:09 - of methods in this class and this is
27:11 - just simply going to return
27:13 - self.x or notself.x self.call
27:17 - and self.row and sorry it's going to be
27:20 - the other way around actually self.row
27:22 - then self.call so for this specific
27:25 - program
27:26 - i'm going to be indexing things using
27:28 - row columns so
27:30 - that's just what we're doing for the
27:31 - grid right if you look at grid of course
27:33 - we have
27:34 - a bunch of rows like that and we have a
27:35 - bunch of columns down so you know
27:37 - something like here could be indexed
27:39 - with i don't know like 6
27:40 - 3 or 6 4 or whatever it may be but we
27:43 - start by calling the row out so whatever
27:45 - y coordinate and then i call the x may
27:48 - seem counter
27:50 - counterintuitive or counterproductive
27:51 - but the way we're going to represent the
27:52 - data this this makes sense later
27:55 - okay so we have get pause so now we're
27:56 - going to define is underscore closed
27:59 - so is closed essentially like have we
28:01 - already looked at you
28:02 - have we already considered you those are
28:04 - the red squares so in this case
28:06 - we're going to say okay what makes a
28:09 - spot
28:10 - closed what would mean that this spot is
28:12 - in the closed set so we're not
28:14 - looking at it anymore what makes it red
28:16 - well
28:17 - i pretty much told you that we're just
28:19 - going to return
28:21 - self.color equals equals rep
28:24 - so the idea behind all of these methods
28:26 - here is we're just going to have a bunch
28:28 - of methods that
28:29 - essentially tell us the state of this
28:31 - spot
28:32 - and we're going to have a bunch of
28:33 - methods that allow us to update the
28:34 - state of this spot as well
28:36 - so they're just going to be changing the
28:37 - color and if this color is white
28:39 - well then this is a square that we've
28:40 - not yet looked at we could visit it if
28:42 - it's red we've already looked at it
28:45 - if it's black it's a barrier that's
28:47 - something we have to avoid that the
28:48 - algorithm can't use as a node to visit
28:51 - if it's orange it's the start node if
28:52 - it's purple it's the path right if you
28:54 - get the point
28:55 - so this might not be the best way to do
28:56 - it but this is what i've gone with for
28:58 - this tutorial and i think it makes it
28:59 - pretty easy to understand
29:01 - so we'll say is open so is open is just
29:03 - going to be return
29:05 - self dot color equals equals green
29:08 - so essentially are you in the open set
29:10 - now i don't know if we
29:11 - are even going to use that method but
29:12 - i'm just defining all of the different
29:14 - states just so it's consistent
29:16 - so next we're going to say is barrier so
29:18 - are you an obstacle
29:19 - well what makes this an obstacle that's
29:21 - if the color is equal to
29:23 - black right so if it's black because
29:25 - we're going to punch it in and we're
29:26 - going to draw
29:27 - all the obstacles then this is a barrier
29:29 - so that's what we're doing
29:30 - next we're going to say is underscore
29:34 - oops is underscore start i'm going to
29:37 - say self and we're going to say
29:38 - return self.color
29:42 - equals equals and for the start color
29:44 - we'll just go with orange but you're
29:45 - welcome to change any of these colors of
29:47 - course if you'd like
29:48 - and then finally we go is end actually
29:51 - there should be one more
29:52 - and we'll return self.color
29:56 - equals equals and i think i went with
29:58 - purple for the color
30:00 - finally i'm going to add another method
30:01 - and this one's going to be called reset
30:03 - and this is simply going to change the
30:05 - color back to white so define reset and
30:07 - we'll just say self.color
30:10 - equals equals white like that okay
30:13 - now you thought i was done with all the
30:15 - methods but we actually have more this
30:16 - is like the longest class that's just
30:18 - the most simple thing in the world but
30:20 - i'm going to say make
30:21 - underscore color and
30:25 - what am i saying make color i'm going to
30:26 - say make open make closed
30:28 - and pretty much duplicate all of these
30:30 - methods here
30:31 - with just a make in front of them so
30:33 - when you call this it will
30:35 - make this cube whatever it is that i'm
30:37 - saying here so in this case
30:38 - uh we'll start with closed just so it
30:40 - stays consistent so make
30:41 - closed self and i believe make closed
30:45 - was what color were we going with
30:47 - i think that was red right so we're
30:48 - going to say self.color
30:51 - equals rep so this time instead of just
30:54 - giving them
30:54 - back like are you red are you green are
30:57 - you this is going to actually
30:58 - change the color so make close we'll say
31:00 - make open this is going to be self and
31:02 - we'll say self
31:04 - dot color oops equals
31:08 - green like that we have more oh that's
31:10 - nice of that one away so to make
31:12 - open uh what else do we have make
31:14 - barrier make underscore
31:16 - barrier this is going to be self
31:20 - and then we'll go self dot color equals
31:24 - black okay and define
31:27 - make underscore end this is going to be
31:31 - self let me self dot color
31:35 - equals and what was the end color that
31:37 - was i'm going to go with
31:38 - turquoise actually for the end color and
31:40 - instead of purple i'm going to change
31:42 - this to turquoise my bad on the end
31:44 - color guys i want that want that one to
31:45 - be turquoise
31:46 - and then we'll say define make
31:49 - underscore
31:50 - path self self.color
31:54 - equals purple so purple will be the path
31:57 - turquoise will be the end color
31:58 - and then finally we need to add two more
32:00 - methods so define
32:02 - draw so this is going to be the method
32:04 - we call we actually want to draw this
32:06 - cube on the screen so we're going to say
32:08 - self
32:09 - wind so this is actually going to be
32:11 - this window so essentially
32:12 - where do we want to draw this that's
32:14 - what this argument is saying right here
32:16 - so self win and i think that's all i
32:19 - need and then to draw a cube in pi game
32:21 - go pygame.draw.rectangle so rect
32:26 - like that you put the window you put the
32:29 - color
32:30 - so that's self.color like that and then
32:31 - you put a rectangle that you want to
32:33 - draw
32:33 - so you give it an x y width and height
32:36 - and you can see it's saying surface
32:37 - color rect width
32:39 - that's just telling us how do you want
32:41 - to draw this rectangle where do we want
32:42 - to put it what position
32:44 - that's how pi game works so the way pie
32:46 - game works actually let me just run this
32:47 - example here
32:49 - is you start drawing things from the top
32:51 - left hand side of the screen
32:53 - so 0 0 is actually where i just put this
32:55 - start dot so technically i
32:56 - shouldn't be able to do that but that's
32:58 - fine if that happens see where this
33:00 - orange cube is
33:00 - uh or let's put it there where the
33:03 - orange cube is
33:04 - this is actually the zero zero so this
33:07 - is zero zero not
33:08 - down here like where you would normally
33:09 - think and as you move to the right
33:11 - x increases as you move down y increases
33:14 - so over here in the very corner where
33:16 - the turquoise dot is
33:18 - that would be 800 800 if this was 800 by
33:21 - 800 which it is
33:22 - so that's the idea with the x y when i
33:24 - start drawing something i always start
33:25 - drawing from the top left hand corner
33:27 - so if i say like i'm strong at 50 50 and
33:30 - the width is 16
33:31 - then you're actually going to extend to
33:33 - like 66 66
33:35 - so you go from 50 to 66 50 to 66 if
33:38 - you're talking about the lines
33:39 - hopefully that makes sense but i'm just
33:41 - trying to kind of illustrate to you
33:43 - how that works okay so we're going to go
33:45 - pi game.draw.rect we're going to say
33:47 - self
33:47 - and in this case not row and call but
33:49 - self.x because that's the actual
33:51 - coordinate
33:52 - position i want to draw at and then
33:54 - self.width
33:55 - and self dot not height width again
33:59 - so since we're not doing a height
34:00 - everything's square we can just pass in
34:02 - width twice
34:03 - and i'll just make it a rectangle and
34:04 - then finally we're going to say define
34:06 - update underscore neighbors
34:09 - if i could spell neighbors correctly
34:13 - like that this is going to take self and
34:15 - this is going to take a grid
34:16 - and we'll do this one later because this
34:18 - one is kind of a big function and then
34:20 - lastly i'm just going to say define
34:22 - underscore underscore lt
34:24 - underscore underscore just so i don't
34:25 - forget to do this we'll talk about what
34:27 - this does in a second
34:28 - other and we're just going to return
34:30 - false now for any of you that don't know
34:32 - what this lt
34:33 - is it's stands for less than and
34:35 - essentially this is how we handle
34:37 - what happens if we compare two spots
34:40 - together
34:40 - so now what i'm saying is essentially if
34:42 - we compared this spot
34:44 - and some other spot so two spot objects
34:47 - i'm just always going to say that the
34:48 - other spot is greater than
34:51 - this spot or yes i think that's
34:54 - actually maybe it's the other way around
34:56 - but regardless don't worry about this
34:57 - right now we'll talk about it when we
34:59 - use it but i just don't want to forget
35:00 - so i'm putting it there right now
35:02 - okay so the next thing i'm going to do
35:03 - just because this one's really easy is
35:05 - i'm going to define the heuristic
35:07 - function
35:07 - that we're going to use for our for our
35:10 - algorithm right so we need
35:12 - we need that h function we actually need
35:14 - to make that heuristic function so let's
35:16 - code that out we're going to say define
35:17 - i'm just going to call this h actually
35:19 - i'm just going to put p1
35:21 - p2 here and p1 and p2 are going to be
35:23 - 0.1.2
35:25 - so i'm expecting point 1 and point 2 to
35:27 - look like x y
35:28 - right or to be like row column or
35:31 - something like that
35:32 - so we have to figure out the distance
35:34 - between point one and point two
35:36 - and return that so the way we do this
35:38 - because we're gonna use manhattan
35:39 - distance which essentially is
35:41 - l distance so i'll show you how that
35:43 - works on the grid right here
35:45 - is we just do a very basic formula but
35:47 - essentially l distance or like manhattan
35:49 - distances say i have like these two
35:51 - cubes
35:52 - the distance i'm going to calculate
35:53 - between them is going to look
35:55 - like this it's just going to be whatever
35:57 - the quickest l
35:58 - is to get here this is going to be my
36:00 - guessing distance
36:01 - because we can't move on diagonals right
36:04 - and even if you could so if we can move
36:06 - on diagonals like that that's still
36:07 - going to be the same distance as just
36:09 - going in an l like that
36:10 - so that's what manhattan distance is
36:13 - it's sometimes called taxi cab distance
36:14 - as well because it's like if you're
36:16 - going in a straight line and you're
36:17 - moving around and all that
36:19 - but hopefully that makes sense that's
36:20 - the distance we're calculating so to do
36:22 - that i'm just going to say x1 y1
36:24 - equals p1 i'm going to say x2 y2
36:28 - equals p2 this is because this is going
36:30 - to be a component right so if i have
36:32 - like
36:33 - like p2 is going to be made up of
36:35 - something like you know
36:36 - 1 9 so i can split it into the variable
36:38 - x1 y1 where
36:40 - x1 would be 1 y1 would be 9 by just
36:43 - doing that it's a short
36:44 - cut in python and i'm going to return
36:46 - the absolute distance
36:47 - abs this is a built-in function of x1
36:50 - minus x2 plus the absolute distance of
36:54 - y1 minus y2 it doesn't matter if you
36:58 - swap
36:58 - x2 and x1 so long as you swap y2 and y1
37:01 - as well
37:01 - because that's the h function that's our
37:04 - heuristic
37:05 - now what i need to do is i need to
37:06 - actually come up with a way to make a
37:08 - grid
37:09 - so i need some data structure that can
37:11 - hold all of these spots
37:13 - so that i can actually manipulate them i
37:15 - can use them i can traverse the grid
37:17 - right i need
37:17 - this list that's going to hold all of
37:19 - the spots that i have
37:21 - in my grid so what i'm going to do is
37:22 - i'm going to say define make underscore
37:24 - grid like that and inside of here i'm
37:26 - just going to take the rows
37:27 - and the width so i'm essentially saying
37:29 - okay how many rows do you want in your
37:32 - grid because we're just going to have
37:33 - the same amount of rows as we do have
37:35 - columns and what do you want the width
37:37 - of this grid to be
37:38 - so that's what we're doing so i'm going
37:39 - to say grid equals a blank list and i'm
37:42 - going to say
37:42 - gap equals width integer division
37:46 - by rows so width of course be the width
37:49 - of our entire grid
37:51 - and rows will be how many rows we have
37:53 - doing an integer division will just give
37:55 - us what the gap should be
37:56 - between each of these rows or in other
37:59 - words what the width of each of these
38:00 - cubes
38:01 - should be so hopefully that makes sense
38:03 - and now we're just going to go ahead and
38:04 - actually create this i'm going to say 4i
38:06 - in range and i guess it's going to be
38:08 - rows we're going to say
38:10 - 4j in range rows
38:13 - up here we're going to say grid dot
38:16 - append
38:17 - an empty list we're going to make a 2d
38:19 - list that looks something
38:20 - like this with a bunch of different
38:24 - rows in their own list that all have
38:26 - spot objects inside of them
38:28 - so we say grid we have the gap and we
38:31 - have grid dot append for j
38:32 - in row range now we're going to say spot
38:36 - equals a new spot so we're going to use
38:38 - this class that we just defined up here
38:40 - we need to pass it its row its column
38:43 - its width
38:43 - and the total amount of rows in the grid
38:46 - and then there it'll be able to figure
38:47 - out
38:48 - where it should actually be sitting so
38:49 - we're going to say i
38:51 - j for row column because this is going
38:54 - to be our row
38:55 - this is going to be our column so we
38:56 - pass it i j we're going to pass it the
38:58 - gap
38:58 - that's going to be its width and we're
39:00 - going to pass it rows
39:02 - so now we have this spot object that
39:04 - we've created and what we need to do is
39:06 - we need to append it
39:07 - into the grid so we can say grid.append
39:10 - spot like that and that should actually
39:13 - be
39:14 - sorry grid i believe it's
39:17 - grid i dot append spot so what this is
39:19 - going to do is say okay
39:20 - in grid row i which is the row we just
39:24 - created here
39:24 - we're going to append the spot into it
39:26 - so we have a bunch of
39:28 - lists inside of lists that all store
39:31 - spots
39:32 - then at the very end of this we're going
39:34 - to return
39:36 - oops if i could hit the t key we're
39:38 - going to return the grid
39:40 - awesome so now we have the actual grid
39:43 - being able to be created and i'm just
39:44 - going function through function because
39:46 - i think it's easy to just code out
39:47 - these small parts that all do separate
39:49 - things and then kind of combine them
39:50 - together at the end
39:51 - so we have make grid and now we need a
39:53 - way to draw the grit
39:55 - so we have all these cubes but remember
39:57 - all these cubes are just
39:59 - like white cubes or black cubes we don't
40:01 - actually have any grid lines
40:03 - so if you look at this right you can see
40:04 - these gray grid lines
40:06 - and like all my cubes you can really
40:07 - clearly see kind of where they are and
40:09 - you know where they're defined so we
40:11 - need a way to draw these um these grid
40:13 - lines that we have
40:14 - that's what i'm going to do here so i'm
40:16 - going to say define draw
40:18 - underscore grid like that we're going to
40:20 - take inside of here
40:22 - the win the rows and
40:25 - the width so this is not actually going
40:27 - to draw every one of the cubes that are
40:30 - inside of the grid it's just going to
40:31 - draw those grid lines so this is pretty
40:33 - easy to do actually i'm going to say
40:35 - gap equals width integer division rows
40:38 - again that's going to be the exact same
40:40 - thing as
40:40 - up here i could have made this all
40:42 - capitals in fact to stay consistent
40:44 - let's make this lowercase
40:46 - like that and we're going to say 4 i
40:49 - in range rows like that
40:52 - and then here we're going to draw lines
40:54 - so for every row
40:55 - we're going to draw a i believe
40:56 - horizontal line first
40:58 - so pygame.draw.line
41:01 - in this case and what we're going to
41:03 - draw is a yeah horizontal
41:06 - line for each one of these rows so to do
41:09 - that
41:09 - we need to pass the win we need to pass
41:11 - the color which is gray
41:13 - and then we need to pass two positions
41:14 - so two xy positions where we want the
41:16 - start of the line to be
41:18 - where we want the end of the line to be
41:20 - so the start of the line we want to be
41:22 - at
41:23 - x position 0 and we want the y position
41:26 - to be i
41:27 - multiplied by gap like that
41:30 - and then for here we want this one to be
41:33 - width and then i
41:34 - multiplied by gap the reason we want
41:37 - that is because we're going to multiply
41:39 - whatever the current index of the row
41:40 - that we're on
41:41 - by the gap and what that will do is it
41:44 - will essentially tell us
41:46 - where we should be drawing the grid line
41:48 - so if we start at zero width we know
41:49 - we're going to be all the way on the two
41:51 - borders of the screen and we're just
41:53 - going to move those down
41:54 - constantly and draw a bunch of
41:55 - horizontal lines now we'll do the exact
41:57 - same thing i'm really going to copy this
41:59 - for loop
42:00 - and i'm just going to change the
42:01 - variable to be j so for
42:03 - j in range so now we're going to do the
42:05 - vertical lines
42:06 - and what we can do is just leave j times
42:09 - gap
42:10 - but leave that as the x and then as the
42:12 - y
42:13 - we're going to go zero and width
42:18 - like that so tap that in i'll explain
42:20 - this quickly essentially this is the
42:21 - exact same thing as the horizontal lines
42:23 - except i'm flipping the coordinates
42:25 - so now we're always going to be at the
42:26 - top and bottom and we're going to shift
42:28 - along the x-axis and draw all of those
42:31 - vertical lines so i think let me just
42:33 - make sure yeah that's it for doing that
42:36 - and next we're going to actually make
42:38 - the main draw function
42:40 - which is going to draw everything so i'm
42:42 - going to say define draw
42:44 - and inside of draw we're going to take
42:46 - win grid
42:48 - so we need an actual grid that's being
42:49 - passed here we need the amount of rows
42:51 - and we need the
42:52 - width of the screen so we have win
42:55 - grid rows width and then here we're
42:57 - going to say wind.fill
42:59 - so this just fills the entire screen
43:01 - with one color
43:03 - you do this at the beginning of every
43:05 - frame so we're going to run like you
43:07 - know
43:07 - 100 frames per second or 50 frames per
43:09 - second or whatever it is
43:10 - and at the beginning of every frame
43:11 - we're going to paint over everything
43:13 - that was on the canvas
43:15 - and we're going to redraw everything in
43:16 - its current state it's not the most
43:18 - efficient way to go about doing things
43:19 - when you talk about
43:20 - drawing things on the screen but for our
43:22 - purposes totally fine and this is common
43:24 - practice in pie game
43:26 - so we're going to fill everything with
43:27 - white and then what we're going to do is
43:29 - we're going to say
43:30 - 4 in lower cases for row
43:33 - in grid so for all those rows and we're
43:35 - going to say 4 spot
43:38 - in the row because remember this grid is
43:41 - going to be whatever
43:42 - this creates so it's going to be a 2d
43:45 - array or a 2d list and we're going to
43:46 - say
43:46 - spot dot draw and we're going to pass
43:49 - the win
43:50 - so essentially if we go back to
43:51 - spot.draw you can see this just draws
43:54 - its own color on its x y and whatever
43:58 - the width it is so it just draws a cube
44:00 - with whatever color
44:01 - this spot is right that's all it does so
44:03 - now we just need to call that method on
44:05 - all our spots which are going to be
44:07 - stored
44:07 - in our grid which are stored in the rows
44:10 - so we loop through all of it go through
44:11 - all the rows and then draw all of the
44:12 - spots
44:14 - next we draw the grid so we say we're
44:16 - going to draw the grid lines now on top
44:18 - of that because this will be drawn first
44:20 - so we fill the screen we draw all the
44:22 - colors we draw the grid lines on top
44:24 - and then we'll be good and we've drawn
44:26 - everything we need to draw so we
44:27 - do draw grid we need to pass that win
44:31 - rows and width like that and then
44:33 - finally we do pie game
44:36 - dot display dot update now there's
44:39 - nothing that needs to go in here
44:40 - all this is tells us is hey pie game
44:42 - take whatever we've just drawn
44:44 - and update that on the display awesome
44:47 - so next what we need to do is we need to
44:50 - write a few
44:51 - more functions so the next function i'm
44:53 - going to write is a function that can
44:54 - take a
44:55 - mouse position uh position sorry and
44:57 - figure out
44:58 - what grid uh or what i don't even know
45:01 - describe it what cube or what spot we
45:03 - actually
45:04 - clicked on so if you imagine let me just
45:06 - boot this up here for one second
45:08 - i have to be able to figure out which
45:10 - one of these spots to change colors when
45:12 - i click the mouse right
45:13 - now this is pretty easy math but
45:15 - essentially i have to figure out based
45:17 - on where my mouse position is
45:18 - in this screen because right here it's
45:20 - at 0 0.
45:22 - in the bottom right hand corner it's at
45:24 - what do you call it 800 800
45:26 - i got to figure out based on whatever
45:27 - position it is what cube i'm clicking
45:29 - inside of
45:30 - that's what this function is going to do
45:32 - given a mouse position
45:33 - is going to translate that into a row
45:35 - column position
45:37 - representing the cube that i actually
45:38 - clicked on so i can do things like
45:40 - draw a maze and all that fun stuff so
45:43 - let's figure out how we do that
45:45 - so we're going to say define get
45:48 - underscore clicked underscore position
45:51 - so this is just telling me you know
45:52 - where do we click so get clicked
45:54 - position
45:55 - we're going to take a mouse oops if i
45:57 - could get inside of here
45:58 - we're going to take a pause which will
46:00 - be the mouse position and we're going to
46:01 - take the
46:02 - rows and the width so first thing we
46:05 - need to do is we need to define the gap
46:06 - so we're going to say the gap
46:08 - is equal to the width over over
46:11 - the rows so integer division and then
46:13 - we're going to say
46:14 - i comma j equals position
46:18 - so essentially we're going to say okay
46:19 - you know like the x y
46:21 - we could actually do this maybe this
46:22 - will be easier let's go the y
46:24 - x is going to be equal to position and
46:27 - we can say rho
46:28 - is equal to i over over gap
46:32 - and call is equal to not i sorry this is
46:35 - y oops 2x
46:38 - over over gap so the reason this works
46:41 - is we're
46:42 - figuring out uh we're pretty much just
46:44 - taking whatever the position is in the x
46:45 - and wherever the position is in the y
46:47 - and dividing it by the width of each of
46:49 - the cubes so that'll give us
46:51 - where we are and what cube we've clicked
46:53 - on i i can't really explain that much
46:54 - more and then we'll just return
46:56 - row call like that so we'll be getting
46:59 - the row column
47:00 - that whatever person clicked on and this
47:02 - is just a helper function that is you
47:03 - know nice and easy to use
47:05 - and now we're off to the main function
47:08 - where we're actually going to start
47:09 - setting up some of these events
47:10 - and start drawing some things on the
47:12 - screen and seeing how all this works
47:14 - so we're going to say define main this
47:16 - is going to take a window
47:17 - and a width like that this is going to
47:20 - be our main
47:20 - loop this is kind of the usually you
47:23 - start with this but i just wanted to get
47:24 - all kind of the easy stuff out of the
47:25 - way all these you know basic functions
47:27 - and this class and the more tedious
47:29 - stuff before we did this so we didn't
47:30 - have to keep going back and changing
47:32 - this our main loop and this is going to
47:34 - determine essentially
47:35 - all of the you know checks that we're
47:37 - doing so all the collision checks all of
47:39 - the oh when you press
47:40 - space start the algorithm oh when you
47:42 - press on this cube change the barrier
47:44 - that's what we're doing inside of here
47:45 - so maybe a little bit more complicated
47:46 - but shouldn't be crazy
47:48 - so i'm going to start by defining the
47:50 - amount of rows we want to use so i want
47:52 - 50 rows
47:53 - the way i'm going to do this you can
47:55 - quite easily change this number to
47:56 - whatever you want
47:57 - and it'll just make a grid that has more
48:00 - cubes
48:00 - in fact i have my other example up let
48:02 - me show you what i mean
48:04 - now you know i have a hundred cubes and
48:06 - we can quite easily run the algorithm on
48:08 - this
48:08 - it's just gonna take a little bit longer
48:10 - because there's a lot more cubes
48:11 - so i'm setting it up in a dynamic
48:13 - fashion such that you know everything is
48:15 - completely changeable
48:16 - and that's why this might take a little
48:18 - bit longer but it's nice because
48:20 - you can make it as big or as small as
48:21 - you want so we're going to say rows
48:23 - equals 50
48:24 - we're going to say grid equals
48:27 - make grid oops if we go like that what
48:30 - we need to pass to make grid is the rows
48:32 - and the width so we have rows like that
48:34 - and we have the width
48:35 - so now make grid which we just defined
48:38 - up here
48:38 - is going to actually generate the grid
48:41 - and give us that 2d array of spots
48:44 - or a 2d list whatever you want to call
48:45 - it next i'm going to define the start
48:48 - position
48:49 - and the end position which to start are
48:50 - going to be none we need to decide those
48:53 - and then i'm going to say run equals
48:56 - true
48:57 - and started equals false so essentially
49:00 - just some variables to keep track of the
49:02 - start and end position
49:03 - if we're running the main loop or not
49:05 - and if we've actually started the
49:06 - algorithm or not
49:07 - so now we're going to say well run so
49:09 - while this run variable is true
49:11 - i'm going to say for event in
49:14 - pygame.event
49:17 - like that and what this essentially is
49:19 - saying okay at the beginning of each of
49:21 - this while loop
49:22 - let's loop through all the events that
49:23 - have happened and let's check what they
49:25 - are
49:26 - so an event could be someone pressed
49:28 - down on the mouse so they press the
49:29 - keyboard button
49:30 - or a timer went off whatever events
49:32 - happen in pi game we're looping through
49:34 - them
49:35 - and now i'm going to check them so i'm
49:36 - going to say if event
49:39 - dot type equals equals pie game
49:42 - dot quit in all capitals this is always
49:45 - the first one you should check
49:46 - and what i'm going to do is i'm going to
49:47 - say run equals false like that
49:50 - and what this is essentially saying is
49:52 - okay if we press that
49:53 - x button at the top right hand corner of
49:55 - the screen then stop running the game
49:58 - and at the very bottom of this while
49:59 - loop i'm going to say pie game dot quit
50:03 - oops so pie game dot quit and what this
50:05 - does is it just
50:06 - exits the pie game window so and
50:08 - whenever we hit this line which will
50:10 - only happen when the while loop stops
50:12 - running
50:13 - do we quit now the next thing i'm going
50:15 - to say is if
50:16 - started continue now the reason i'm
50:19 - putting this here is because
50:21 - once we start the algorithm i don't want
50:24 - the user
50:25 - to be able to press anything other than
50:27 - the quit button
50:28 - so this uh while loop will be running
50:30 - when the algorithm is running right
50:32 - but if the algorithm has started they
50:34 - shouldn't be able to like press anything
50:37 - they shouldn't be able to change the
50:38 - obstacles like that'll mess stuff up if
50:40 - they do that
50:41 - so that's why we're saying if started
50:42 - continue now the next thing to check and
50:44 - this is really
50:45 - some of the only commands we need to do
50:47 - here is if the user pressed down on the
50:49 - mouse so if the user pressed on the
50:51 - mouse
50:52 - we need to potentially draw a barrier we
50:54 - need to do the start position we need to
50:55 - the end position
50:56 - there's a bunch of different things we
50:57 - need to check right because if you see
50:59 - the way that this works
51:00 - uh it's a little bit small now i
51:01 - apologize when i press the first and
51:03 - second time
51:04 - that does the start and end position and
51:06 - then i can do the barriers right
51:08 - and if i right click somewhere i can
51:10 - remove the start position
51:11 - and i can put it back to wherever i want
51:13 - and if i right click on any of this
51:15 - stuff it deletes it so we need to check
51:17 - that and there's a few checks to do here
51:19 - to make sure that like after i
51:20 - right click the start or the end
51:22 - position i can place it kind of wherever
51:24 - i want right
51:25 - so that is what i'm talking about and
51:26 - now you can see that the reason i did
51:28 - if started is so i can't just draw a
51:30 - bunch of barriers like i'm pressing down
51:32 - here
51:33 - and i can't delete the color on these
51:34 - squares it just happens right and
51:37 - actually we'll
51:37 - let this run just because i find it so
51:39 - fascinating to see this thing just go
51:40 - and
51:41 - figure itself out like look at that but
51:43 - hopefully that illustrates to you what
51:45 - we're doing here
51:46 - so now we need to check the mouse
51:47 - position so we're going to say if
51:48 - pygame.
51:51 - dot get underscore position then what
51:53 - we're going to do sorry not get position
51:55 - get pressed get position will be next
51:58 - and then
51:58 - 0 and what this stands for is what mouse
52:01 - button we pressed so essentially we're
52:03 - saying
52:03 - if the pie game mouse was pressed
52:06 - and we pressed on the left mouse button
52:09 - so like your common mouse button you're
52:10 - clicking mouse button
52:12 - then do something otherwise so we're
52:14 - gonna say elif
52:17 - game dot mouse dot get underscore
52:20 - pressed
52:21 - one sorry not one two which is actually
52:24 - the
52:25 - right mouse button i believe then we're
52:27 - going to do something else
52:28 - so if they press the left mouse button
52:29 - do something otherwise
52:31 - if they press the right mouse button do
52:33 - something and if you wanted the middle
52:34 - mouse button you would do it with one
52:36 - right so 0 1
52:37 - 2 left center right if you're thinking
52:40 - about that so that's what this says this
52:42 - is
52:42 - we'll do a comment left and
52:45 - this is right okay so now inside of here
52:49 - if they do that we're going to say
52:50 - position equals pie game
52:52 - dot mouse dot get underscore position so
52:56 - pos like that with a set of brackets
52:58 - this simply gives us the position of the
53:00 - pi game mouse on the screen so what x y
53:02 - coordinate it's at now we're going to
53:04 - say row column equals
53:06 - and guess what we're going to use this
53:07 - helper function that we used
53:09 - that we just made so we're going to say
53:11 - get underscore clicked position
53:13 - we're going to pass the position and
53:15 - then what else do we need the rows
53:17 - and we needed the width like that so
53:20 - there we go so now this is going to give
53:21 - us the row
53:22 - and column that we clicked on so this is
53:24 - what actual
53:25 - spot in our 2d list did we click on so
53:28 - now we can actually access that
53:29 - so we can say spot equals in this case
53:32 - grid and oops i've just butchered that
53:36 - we go grid and we go row call
53:39 - so we can index the row column in the
53:41 - grid and now
53:43 - you know we can do whatever we want with
53:44 - it so the first thing we're going to say
53:45 - is okay
53:46 - if we have not yet placed the start
53:49 - position we're going to need to do that
53:50 - right so we always do start
53:52 - and end position first if the start and
53:54 - end position aren't down when you click
53:56 - you're either
53:56 - you're setting the start or the end
53:58 - position that's just the basic rule if
54:00 - start and end
54:00 - are not there if they're if we haven't
54:03 - pressed them then
54:04 - make them whenever we press next so
54:06 - we're going to say start
54:07 - equals spots that's why i have this
54:09 - start variable up here
54:10 - and then we're going to say start dot
54:12 - make underscore
54:14 - do i not have a make underscore start i
54:17 - thought i did okay well let's go back
54:19 - up to our thing here and let's make make
54:22 - start because i don't think i added that
54:24 - yeah i can't just completely forgot that
54:26 - so define make underscore start i'm
54:29 - gonna go
54:29 - self i'm gonna go self.color equals and
54:33 - i think we were going with orange for
54:34 - start
54:35 - uh yeah i think so so sorry guys add
54:38 - that method
54:38 - make start uh and then we should be good
54:41 - to do this so now we're gonna say start
54:42 - equals make start
54:44 - and then we'll say an l if and we'll say
54:46 - l if not
54:47 - end and we'll do the exact same thing
54:49 - for end we'll say end
54:51 - equals spot and
54:54 - dot make underscore end so hopefully
54:57 - this makes sense
54:58 - we're saying we press the left mouse
54:59 - button and the start or end one is not
55:01 - yet pressed then let's make that the
55:04 - start or make that the
55:06 - end and we'll always start by doing the
55:07 - start and we'll after the start we do
55:09 - the end
55:10 - now otherwise so in another situation
55:13 - where
55:13 - the start was actually defined we've
55:15 - already done it the end we've already
55:16 - defined we've already clicked it
55:18 - if we're clicking and we're not clicking
55:20 - on the start or we're not clicking on
55:22 - the end so
55:23 - l if spot does not equal end
55:26 - and spot does not equal
55:29 - oops does not equal start then whatever
55:32 - spot we clicked on is just some
55:34 - random spot we need to make it a barrier
55:36 - so we'll say spot
55:37 - dot make underscore barrier like that
55:40 - and that's as easy as this left mouse
55:42 - button press is so now
55:44 - let me run this for you so i'm going to
55:46 - call this function down here
55:48 - and let me show you what we've actually
55:50 - done so far
55:51 - so let's run this i'm like confident
55:53 - that i'm probably going to get an
55:55 - error and my thing is lagging so i'll be
55:58 - right back
56:00 - okay so i had a small error here i don't
56:02 - know something crashed something
56:03 - happened
56:03 - but i also just realized that we just
56:05 - got to fill in a pass here just so i can
56:07 - actually test this right now because i
56:08 - haven't i don't have an indented block
56:10 - for this other mouse position
56:11 - and we're probably going to run into a
56:12 - few errors that we have to fix just
56:14 - because i've been coding for a while so
56:16 - we'll go through these together so main
56:18 - is missing two
56:19 - required positional arguments win and
56:21 - width so here
56:23 - let's pass it to it win which i think
56:25 - was in all capitals
56:26 - and then width as well okay so win and
56:29 - width
56:30 - um i don't remember if i made it in all
56:32 - capitals yes i did so win with
56:35 - we're going to pass that to our main
56:36 - function and hopefully now this will
56:38 - work
56:39 - okay uh so we're getting a black screen
56:42 - and the reason we're getting a black
56:43 - screen is guess what
56:44 - because we never called the draw
56:45 - function we never actually called draw
56:48 - which will then draw the grid and draw
56:50 - everything else that we need to do
56:51 - so what we're going to do is right at
56:52 - the top of our while loop we're going to
56:54 - call draw
56:55 - we're going to give it that win we're
56:57 - going to give it the grid we're going to
56:59 - give it the rows which is all capitals
57:00 - and we're going to give it the width
57:02 - so now we'll call draw every loop and
57:05 - this will just keep drawing everything
57:06 - so let's try this
57:08 - and there we go we get a nice solid grid
57:10 - and look i can even go ahead and i can
57:12 - make
57:13 - all this stuff so of course i can't
57:15 - delete anything now because
57:17 - we don't have the right mouse button set
57:19 - but you can see that i can press and i
57:21 - can do it again and
57:22 - let's run this one more time and i can
57:24 - make my start and end position
57:26 - and all is well and all is good so i
57:29 - think
57:30 - um that's about it now what i'm just
57:32 - going to do here is i'm just going to
57:33 - fix
57:34 - this because let's look at this for one
57:36 - second if i press
57:37 - so that's my start position right i can
57:40 - press my end position right on top of
57:42 - that
57:43 - that's no good that means the start and
57:45 - the end are the same
57:46 - and we can't let that happen so we need
57:48 - to handle that case so now
57:50 - before we actually assign the start we
57:52 - need to make sure
57:54 - that spot does not equal end and before
57:57 - we
57:58 - do the end we need to make sure that end
58:00 - does not
58:01 - our i guess spot does not equal
58:04 - start so that we can't override each
58:06 - other so let's just try it now
58:08 - you can see that's the changing code
58:10 - right there and now
58:11 - see it won't actually let me press it on
58:13 - top of each other i was trying to and
58:15 - you just can't actually press the spot
58:17 - on top of each other
58:18 - which is exactly what we wanted and now
58:19 - we can draw our barriers and obstacles
58:21 - and all that
58:22 - fun stuff so now let's do the left mouse
58:24 - button which is a little bit easier
58:26 - so we're going to say position equals
58:29 - and we're actually just going to copy
58:30 - these first three rows
58:31 - kind of counter-intuitive to do it but
58:33 - that's fine we'll just
58:35 - copy all of them we don't really need to
58:37 - worry about that too much and we're just
58:38 - going to say spot.reset now
58:41 - so essentially we have position row call
58:43 - and spot which i've already discussed
58:45 - and if you press on this spot with your
58:46 - right mouse button i'm assuming that you
58:48 - just want to reset it to be white so
58:50 - we'll say spot.reset and we'll say if
58:52 - spot equals equal start
58:55 - then start equals end and
58:58 - if spot equals equals end
59:02 - and equals none and i mean we can make
59:04 - this an l if it doesn't really matter
59:06 - it's going to be the same thing anyways
59:08 - just to make sure that we reset oh not
59:09 - start equals n
59:10 - start equals none sorry so we reset the
59:13 - start and end
59:14 - if you press on those ones because those
59:15 - are the two variables that we're storing
59:17 - so now let's run this and see what we
59:19 - get so i can you know right
59:20 - press and i can left press hey my left
59:23 - click
59:23 - is not working for some reason so i'm
59:26 - going to have to see whoa
59:27 - there's a bunch of stuff going wrong
59:29 - okay give me a sec guys i'm going to
59:30 - have a look here
59:31 - looks like my something's happening with
59:33 - this update
59:34 - where something's kind of working but
59:37 - it's not really working properly so i'm
59:39 - just going to have a look at this bug
59:40 - and see what's going wrong so looks like
59:43 - inside of my reset we had two equal sign
59:45 - instead of one so that would make sense
59:47 - why it wasn't actually updating the
59:48 - color properly
59:49 - so that would be the mistake there so
59:51 - let's rerun this because before it just
59:53 - wasn't actually erasing anything and now
59:55 - uh when i right click
59:56 - beautiful it actually is working
59:57 - properly so it looks like we've got kind
59:59 - of the main obstacle stuff
60:01 - almost out of the way here and now the
60:02 - next thing to do is really actually just
60:05 - start writing the algorithm which of
60:06 - course is the toughest part but the
60:08 - visualization tool itself is kind of
60:10 - ready to go and
60:10 - everything's set up and handled so the
60:13 - last thing we're going to do here is
60:14 - we're just going to add
60:15 - a event we're going to say if pygame
60:19 - dot event dot type actually sorry not pi
60:22 - game just if event
60:24 - dot type equals equals
60:27 - pie game dot key down and now what we're
60:30 - just going to say is if
60:32 - event so this is essentially telling us
60:33 - did we press a key on the keyboard down
60:36 - if event dot key equals equals pie game
60:39 - dot k underscore space and
60:43 - started equals false
60:46 - sorry not started equals false and not
60:49 - started
60:50 - then what we're going to do is we're
60:51 - actually going to go ahead and we're
60:52 - going to start running the algorithm
60:54 - so the first thing we need to do in here
60:57 - is we need to
60:57 - now go back to the spot class and we
60:59 - need to update all of the neighbors
61:01 - of the spot class so remember that what
61:04 - i was saying before when we were talking
61:05 - about how this algorithm works we need
61:07 - to actually have
61:09 - neighbors for all of these spots so
61:11 - these spots we need to set this up as a
61:13 - graph
61:13 - so every single node which are all these
61:15 - great squares need to have a neighbor
61:17 - beside them so they need to have
61:18 - something to left something to the right
61:20 - up down and that needs to be handled so
61:22 - what we need to do is
61:23 - make this update neighbors method inside
61:26 - of spot
61:26 - which we'll add into this list here the
61:29 - neighbors list
61:30 - all of the valid squares that could be
61:32 - its neighbor so let's run this and i
61:33 - just want to show you
61:34 - something's crashing let me just add a
61:37 - pass inside of here for right now
61:40 - and let me show you what i mean so like
61:41 - this orange square for example
61:43 - has this this neighbor this neighbor
61:45 - this neighbor this neighbor let me just
61:46 - move that over there these four
61:48 - neighbors are these orange squares
61:49 - neighbors right
61:50 - but right now they're actually not
61:53 - because these are barriers so we can't
61:55 - use a barrier
61:56 - as an edge which technically means right
61:58 - now there's no way for this orange
62:00 - square to connect with this green square
62:01 - because
62:02 - it's completely covered it has no
62:03 - neighbors so the point is that
62:05 - every single one of these white squares
62:07 - we need to determine
62:09 - all of its actual neighbors uh that
62:11 - aren't these barriers right so we can't
62:13 - add these barriers as its neighbors
62:14 - because really like say i do this
62:16 - these circles here all the white squares
62:18 - inside of these circles are now useless
62:20 - we can no longer use them and we need to
62:22 - make sure that we know the
62:24 - neighbors of like this white square and
62:26 - that we don't add this black square in
62:28 - there so we don't
62:29 - traverse through any of the barriers
62:31 - right that's kind of what we have to do
62:33 - right now it's not very
62:34 - it's not super difficult to do but i
62:35 - just want to illustrate to you what
62:37 - this is so let's go into
62:41 - uh the update neighbors and let's write
62:43 - this code so essentially what we're
62:44 - going to do is just check
62:45 - up down left right and see if those are
62:48 - barriers or not and if they're not
62:49 - barriers we'll add them
62:50 - into the uh the neighbors list so let me
62:54 - just go
62:54 - have my reference code here to make sure
62:56 - i don't mess this up because this is a
62:57 - fair amount of code we're going to start
62:59 - by saying self.neighbors equals
63:02 - a blank list and we're going to say
63:05 - if self dot row because we do have this
63:08 - it's one of the attributes is less than
63:10 - self.total rows
63:12 - minus one and not
63:15 - grid self dot
63:19 - row minus one
63:23 - self dot call dot is underscore
63:26 - barrier then what we'll do is we'll say
63:29 - self
63:30 - dot neighbors dot append
63:34 - and we will append this so we'll append
63:38 - grid
63:38 - self.row minus one uh and self.call now
63:41 - i know this seems like what the heck did
63:43 - you just do tim but this is i'm checking
63:45 - if the row that we're at
63:46 - is less than the total rows minus one
63:49 - the reason i'm checking that i'm sorry
63:50 - this should be a plus one
63:52 - not minus one is because i want to add
63:54 - one to the row i'm on right now to go
63:56 - down a row so this is going down right
63:59 - we're moving down a row because we start
64:01 - zero
64:02 - one two three four so on like that so
64:04 - we're moving down so i need to check if
64:06 - i can move down because if i'm on
64:07 - like square 49 i'm on square 50 and i
64:10 - try to go to square 51 and that doesn't
64:12 - exist i'm going to crash my program
64:14 - so that's the check right here and we
64:16 - say and not
64:17 - grid self.row plus one
64:20 - self.call.isbarrier
64:22 - then self.neighbors.append blah blah
64:24 - blah append the next row down
64:27 - that's what i'm doing i'm saying we'll
64:28 - use the same column but we'll add one to
64:30 - the row
64:30 - if we can add that to the neighbor now
64:33 - let's copy this exact same thing
64:35 - and we'll actually copy it four times
64:38 - we'll just update what these values are
64:40 - oops let's just copy that if statement
64:44 - okay so now we're gonna go down up is
64:47 - gonna be the next one
64:48 - it's good to comment these just so
64:49 - sometimes you can read them pretty
64:51 - quickly so
64:52 - down up left right so for up we're just
64:55 - going to change
64:55 - all the signs so this is going to be
64:57 - negative now that's going to be
64:59 - oops this isn't going to be self.total
65:01 - rows this is actually going to be
65:03 - a 0 and we're going to say if self.row
65:05 - is greater than 0
65:06 - and not self.row plus one
65:09 - self.uh call is barrier then we'll say
65:12 - self.neighbors.pen grid self.row plus
65:15 - one
65:15 - uh and self.call now i realize i must i
65:19 - mess something up here
65:20 - this is a plus one and this is a minus
65:23 - one sorry guys so let me
65:24 - space these out so we can actually read
65:25 - this okay
65:27 - space like that so this one sorry if
65:30 - self.row is greater than zero so if
65:32 - we're not at row zero
65:33 - and grid self.row minus one because
65:35 - we're going up now not down i was mixing
65:37 - that up
65:38 - and this isn't a barrier then what we'll
65:39 - do is say self.neighbors.append
65:41 - the grid of self.row minus one so the
65:43 - one above us at the same column
65:45 - awesome that's all we need now instead
65:47 - of call we're going to say if self
65:49 - and said row we're going to say if
65:50 - self.call is less than self.total rows
65:52 - minus one
65:54 - then if not self.row
65:57 - so grid self.row self.column
66:01 - plus 1 is barrier then what we add is
66:04 - instead of
66:04 - row plus one we're going to do column
66:06 - plus one so now we're moving to the left
66:10 - this is actually going to be to the
66:12 - right and this one's going to be
66:13 - to the left i'm just butchering these so
66:16 - badly this is why i want to leave it to
66:17 - the end
66:18 - but this is going to the right so if we
66:19 - go to the right we're just checking one
66:20 - square to the right so we need to make
66:22 - sure that that's valid
66:23 - uh if it is append it into the neighbors
66:25 - hopefully i'm making enough sense to you
66:26 - guys
66:27 - and then here we're gonna do the same
66:28 - thing as row so if self.column
66:31 - is greater than zero and self.grid
66:35 - and not grid self.row leave it like that
66:39 - self.call minus1 right
66:42 - then minus1 we'll go there
66:46 - actually it will go right there okay so
66:49 - let me just make this clear
66:50 - make sure i didn't mess anything up i
66:52 - think this is good essentially you just
66:53 - have to make sure if you're greater than
66:54 - zero
66:55 - if you're greater than zero then you can
66:56 - subtract one without going into the
66:58 - negative numbers so that's fine
67:00 - and then we if that one that we're
67:02 - checking is not a barrier we can add
67:04 - that to the neighbors list
67:05 - so we don't need to return anything from
67:07 - this that's fine that's enough for
67:08 - updating the neighbors
67:10 - again i just butchered that so horribly
67:12 - but hopefully that
67:13 - is enough that makes sense we're just
67:14 - adding the neighbors to all of those
67:16 - things and here again
67:17 - is the code if you need to copy it down
67:19 - and pause the video or anything like
67:20 - that
67:21 - okay so now that we have that let me
67:23 - just go down here
67:25 - and we're going to call that for all of
67:27 - our spots so we're
67:28 - essentially going to say for row
67:31 - in grid and then for
67:34 - grid in row or not grid and row
67:37 - for spot in row spot
67:42 - dot update neighbors so this
67:45 - whenever we actually press that space
67:47 - key down so this is saying you know if
67:49 - we press the key down
67:51 - if the key is the space bar and we've
67:53 - not yet started the algorithm
67:54 - then for row and grid for all the spots
67:56 - in that row update all of their
67:58 - neighbors so call that method that we
68:00 - just created
68:01 - after we do that what we need to do is
68:03 - just call the algorithm so we're just
68:05 - going to say
68:05 - algorithm like that i'm going to pass in
68:08 - the arguments that we have already just
68:10 - because we're going to be using them
68:11 - inside of there
68:13 - and then we should be good to go so i'm
68:14 - going to say lambda which i'll explain
68:16 - in a second because this is a confusing
68:18 - thing
68:18 - i'm going to say draw and i'm literally
68:20 - just going to actually copy this
68:22 - right here i'm going to say draw like
68:25 - that
68:25 - i'll again explain why i'm passing this
68:27 - in a second i'm going to pass the grid
68:29 - and pass the start position and the end
68:31 - position so i've not yet made this
68:32 - function we're going to code that out in
68:34 - a second
68:34 - but what i'm saying is that okay once we
68:37 - start we're going to call this algorithm
68:39 - function
68:40 - we're going to pass a function that is
68:42 - equal to a function
68:43 - call so i'll explain lambda and then
68:45 - grid
68:46 - start and end so what lambda is
68:50 - is an anonymous function so if i go
68:52 - lambda x
68:53 - like that if i said like x
68:56 - equals lambda and then i say print
69:00 - inside here and i go print hello
69:03 - calling x will call this print function
69:07 - the way this the way this works
69:08 - essentially is like you can imagine that
69:09 - i'm just saying like
69:11 - function like if i go like def func
69:14 - and then it's like that so i say like x
69:17 - is equal to define function print hello
69:19 - if i call x which is just another name
69:22 - for this function
69:23 - then that's calling hello it's hard to
69:26 - describe this but it's just known as an
69:27 - anonymous function
69:28 - because you don't need to give it a name
69:29 - you can just kind of put it on a line
69:31 - and this is great because this means i
69:33 - can pass this draw function
69:35 - as an actual argument to another
69:37 - function and then inside of there
69:39 - i can just call this directly so again
69:42 - it might be a little bit confusing but
69:44 - just imagine that it's i'm just calling
69:46 - this draw function whatever whenever i
69:48 - call whatever is represented by this
69:50 - lambda
69:50 - lambda okay mouthful let's now go and
69:54 - code out the algorithm
69:55 - and then we're going to be pretty close
69:57 - to done so underneath h i'm going to
69:58 - define
70:00 - algorithm i'm gonna say draw
70:03 - and then i figure out what else i had
70:05 - here i'm gonna have to go look at this
70:06 - to make sure we don't butcher this
70:08 - so this is draw grid
70:12 - start and end awesome
70:15 - so essentially what i'm saying is i'm
70:16 - taking a argument here which is draw
70:19 - this is a
70:19 - function that i'm going to call so i'm
70:21 - going to call draw like that
70:23 - and the reason i can do that is because
70:24 - lambda
70:26 - was like you know lambda let's just say
70:29 - print
70:30 - hello if i said like draw equals lambda
70:34 - print hello
70:35 - this is a function that calls that
70:36 - function so if i call
70:38 - this draw function it will do whatever
70:40 - is here which is print hello
70:42 - so in this case draw as a function so i
70:43 - can just call the function
70:45 - and it will do whatever draw is
70:47 - hopefully that's kind of making sense
70:50 - but anyways that's the best i can do
70:52 - okay so
70:53 - next what i'm going to do is i'm just
70:54 - going to find some variables and this is
70:56 - where we're actually going to start
70:57 - coding the algorithm
70:58 - and there's going to be a lot of
70:59 - explanation so i'm going to say count
71:01 - equals 0
71:02 - open set equals priority queue
71:06 - which we'll talk about in a second
71:07 - remember we imported that way at the
71:08 - beginning at the very top
71:10 - of our program from cue import priority
71:13 - queue
71:14 - let's move this down by the way say open
71:16 - set equals priority queue
71:18 - we're going to say open underscore set
71:20 - dot
71:21 - put now this is put instead of push or
71:23 - append it's just what the api is for
71:25 - priority queue
71:27 - and this just means add to the priority
71:29 - queue remember what the first step of
71:30 - our algorithm was
71:32 - it's to add the start node with its
71:34 - original f score
71:36 - which is going to be just zero right so
71:37 - we add the start node with its f score
71:40 - into the open set that's the first steps
71:42 - that's what i'm doing right now
71:44 - i'm going to say okay open set.put and
71:46 - we're going to put the f score which is
71:48 - zero
71:49 - we're going to put count which is zero
71:51 - and the reason i'm putting count
71:52 - is just to keep track of when we
71:54 - inserted these items into the queue
71:56 - that is so we can break ties if we have
71:59 - and if i spell count correctly here
72:00 - so we can break ties if we have two
72:02 - values that have the same
72:04 - um what do you want to call it or not
72:06 - values if we have
72:07 - two things inside of the queue that have
72:09 - the same f score we can just go based on
72:11 - which was inserted first
72:12 - on which one to consider so we have a
72:15 - tie breaker essentially
72:16 - so zero count and then start that's what
72:19 - i'm putting here
72:20 - okay so this is the actual node itself
72:22 - or the spot
72:23 - this is some number it's going to be
72:24 - zero to start and that's the f score
72:26 - which is zero so open
72:27 - uh set.put we're gonna say came from
72:30 - which is pretty much keeping track of
72:32 - where we came from right so what node
72:35 - did this
72:36 - node come from remember like i had you
72:38 - know node b
72:39 - came from node c node c came from node d
72:41 - and that's how we keep track of the path
72:43 - that's what this dictionary is going to
72:45 - do and that'll be more clear as we go
72:47 - next we're going to have our g score so
72:49 - we're going to make a
72:50 - table here that's going to store all of
72:52 - the g-scores so i'm going to say spot
72:55 - float in so essentially we're going to
72:58 - have a key
72:58 - for every spot inside of our g-score
73:02 - it's going to start at float infinity
73:04 - right so this just gives us
73:05 - infinity that's how you do infinity in
73:07 - python we're going to say four row
73:09 - in grid for spot oops
73:13 - in row so this is just a list
73:15 - comprehension this is the same as
73:16 - writing
73:17 - like four row in grid for spot in row uh
73:19 - g-score
73:20 - spot equals float imp uh if we just do
73:23 - like a long drawn out way but since
73:24 - we're going to do this twice
73:25 - i'm just doing it in a list
73:27 - comprehension or a dictionary
73:28 - comprehension
73:29 - and then we're going to originally set
73:30 - the g-score of our start node
73:32 - right so g-score of start is going to be
73:34 - equal to zero
73:36 - because of course the g-score of the
73:37 - start node is just zero
73:39 - now we're going to copy this exact same
73:41 - thing and we're just going to replace g
73:42 - with
73:43 - f because we need the same set up for f
73:45 - and same
73:46 - f score is going to be 0 for our start
73:48 - node
73:49 - and actually sorry the f score of our
73:52 - start node
73:52 - will actually just be the heuristics so
73:55 - it's not actually going to be 0. i miss
73:56 - explaining this is going to be the
73:58 - distance which is going to be the
73:59 - heuristic from
74:00 - h of our start dot get position
74:04 - so get underscore pause and our end dot
74:08 - get underscore pause so sorry this was a
74:11 - mistake on my part the
74:12 - g score and the f score are the g score
74:16 - is set to zero
74:17 - the f score will just be the heuristic
74:19 - because
74:20 - we want to estimate approximately how
74:22 - far away this end node is
74:24 - from the start node and just give that h
74:26 - score already
74:28 - so that'll be the f score for our um
74:32 - our end node the reason we do this is to
74:34 - make sure
74:35 - that we don't when we reach the end node
74:38 - uh we don't automatically assume
74:40 - that it's the best path i hope that kind
74:43 - of makes sense but just imagine that
74:44 - like
74:44 - we start the f score of our start node
74:47 - at
74:48 - infinity so sorry i miss explain this
74:50 - but essentially the reason the f score
74:52 - is just equal to
74:53 - the heuristic is because we do actually
74:55 - want to make an estimate of how far away
74:57 - this start node is from the end node
74:59 - when we begin
75:01 - it's not a huge deal it's not going to
75:02 - be super important but the reason we
75:04 - have that is to make sure that if we say
75:06 - circle all the way around back to the
75:08 - start node we don't take that as the
75:10 - shortest path
75:11 - because it was infinity beforehand we
75:13 - just take whatever
75:14 - we think is going to be the shortest
75:16 - distance which is just the heuristic
75:18 - again it's not huge deal if you
75:20 - understand that or don't understand that
75:21 - but just make this equal to our
75:23 - heuristic which is this h function right
75:25 - here
75:25 - we should be good to go next i'm going
75:27 - to make open underscore
75:29 - set underscore hash equal to
75:32 - a set of start now the reason i'm making
75:36 - a set here is because
75:38 - this priority queue doesn't actually
75:40 - have anything to tell us
75:41 - if a node is in the queue or not and we
75:44 - need to check
75:45 - in some sense if there's something in
75:47 - the queue or not so
75:48 - if we have a value in the queue or if
75:49 - we've removed a value from the queue or
75:51 - whatever it is so we need to have open
75:52 - set hash
75:53 - that is just going to keep track of all
75:55 - the items that are in the priority queue
75:57 - and all the items that aren't in the
75:59 - priority queue so i can remove an item
76:01 - from the priority queue
76:02 - but i can't check if something is in the
76:04 - priority queue where here i can check if
76:06 - anything is in it because this will just
76:08 - be a hash
76:09 - that just stores all the same things
76:10 - that this priority queue stores
76:12 - but just doesn't have the same kind of
76:14 - data structure
76:15 - implementation to give us the smallest
76:18 - item if that
76:19 - makes any sense again this is getting a
76:21 - little bit into some complex data
76:22 - structure stuff but
76:24 - don't worry about it too much hopefully
76:25 - this will make sense as we continue
76:27 - so we're going to say while not open
76:29 - underscore set
76:31 - dot empty so essentially the algorithm
76:33 - runs until the
76:34 - open set is empty or not so if the open
76:37 - set is empty then that means that we've
76:39 - considered every single possible node
76:41 - that we're going to
76:42 - and if we've not found the path yet a
76:44 - path doesn't exist that's what that says
76:46 - and we're going to say just here quickly
76:48 - for event
76:50 - in pygame.event.get now since we have a
76:53 - while loop
76:54 - i need to make a way that people can
76:56 - exit this while loop
76:57 - so if i say i need to just have this
76:58 - event thing here to let them
77:00 - hit that x button if they want to quit
77:02 - so i'll say if event.type
77:04 - equals equals pygame.quit in all
77:07 - capitals
77:08 - then what we'll say is pygame.quit
77:11 - so this again is like we already have
77:13 - this down in the lower section but since
77:15 - this algorithm here takes over and has
77:17 - its own loop inside
77:19 - i need a way to exit this loop just in
77:21 - case
77:22 - you know something goes wrong we can
77:23 - quit or if it's taking too long or
77:25 - whatever it may be we need a way to quit
77:27 - now after we do that we're going to say
77:29 - current equals
77:31 - open set dot and i believe i can just
77:34 - say
77:34 - get and i'm going to index at 2. now the
77:36 - reason i'm indexing at 2 is because our
77:38 - open set is going to store
77:39 - the f score the count and the node now i
77:43 - want just the node
77:44 - so i'm going to start at the very
77:45 - beginning of all of these loops by
77:47 - popping
77:48 - the lowest value f score from my open
77:51 - set now if there's two things that have
77:52 - the same f score
77:54 - we'll look at the count and whatever was
77:55 - inserted first will be what i take so
77:58 - that's what current is saying this is
77:59 - the current node we're looking at
78:01 - so remember same example here if we're
78:03 - starting at the very beginning current
78:04 - will start as the start
78:06 - node because that is the only thing
78:08 - that's in the open set to start
78:10 - so then what we're going to say is open
78:12 - underscore set
78:13 - underscore hash dot remove i think it's
78:16 - remove yeah
78:17 - dot remove current so we're going to
78:20 - take
78:20 - whatever node that we just popped out of
78:22 - the priority queue and we're going to
78:23 - synchronize it with the open set hash by
78:25 - just removing it from that
78:27 - to make sure that we don't have any
78:28 - duplicates or anything out of sync and
78:30 - messing us up
78:31 - next we're going to say if the current
78:32 - is equal to the end so if this
78:34 - node that we just pulled out is the end
78:36 - node we found the shortest path
78:38 - so we need to reconstruct the path and
78:41 - we need to draw that path
78:42 - so for now i'm just going to say pass
78:44 - and we'll deal with this after but this
78:45 - is going to be
78:46 - make path like that
78:49 - and we're just going to return the value
78:51 - true and just say okay we've found a
78:53 - path we're going to exit out of there
78:55 - so i actually don't need the pass but we
78:57 - are going to have to continue this after
78:58 - and and we'll do that later okay so if
79:00 - current equals n boom that's it
79:02 - and now next what we need to do is need
79:04 - to consider all of the neighbors of the
79:05 - current node
79:06 - so we're going to say for neighbor in
79:10 - in this case we're going to say current
79:12 - dot neighbors
79:14 - like that so if the neighbor is in our
79:17 - current dot neighbors right so for all
79:18 - of them
79:19 - we're going to say the temp
79:22 - underscore g underscore score is going
79:24 - to be equal to
79:26 - the g score of whatever the current
79:29 - score is plus 1. now the reason for this
79:33 - is because
79:34 - we can assume that all of the edges are
79:35 - one right so if we want to figure out
79:37 - what the temporary g-score of this
79:39 - neighbor would be
79:40 - assuming we go to this neighbor from
79:42 - whatever current
79:43 - node we're at then we take whatever the
79:45 - distance is this current node
79:47 - the the currently known shortest
79:49 - distance and we add one to it
79:51 - because we're going one more node over
79:53 - which is a neighbor of this node
79:55 - we know it only takes one value so
79:57 - that's totally fine and valid to do so
79:59 - we add one to whatever
80:00 - the current score is for the shortest
80:02 - path to this current node
80:04 - then what we say is we say if temp
80:06 - underscore g-score
80:08 - is less than the g-score of the neighbor
80:11 - so essentially in other words if we
80:13 - found a better way to reach this
80:15 - neighbor than what we had found before
80:17 - update this way update this path store
80:19 - it and make sure we keep track of that
80:21 - that's what we're doing right we're
80:22 - trying to determine the best path to get
80:25 - to every single node
80:26 - and from there we can really easily kind
80:28 - of target ourselves towards the end node
80:31 - and find the optimal path and that's
80:32 - what we're doing so we're saying if the
80:34 - g-score that we're getting by using this
80:36 - neighbor
80:36 - is less than the g-score of what we had
80:38 - on the other neighbor so the actual
80:40 - value
80:41 - then go ahead and change things around
80:43 - update the value say this is a better
80:45 - path so we're going to say first
80:47 - came from so the came from for the
80:49 - neighbor needs to be updated
80:51 - to equal whatever node we're on right
80:54 - now so came from neighbor equals current
80:55 - because it's a neighbor of the current
80:57 - we came from that
80:58 - we're going to say g-score of current
81:02 - is going to be equal to the temp g-score
81:05 - that we just have right there and then
81:07 - we're going to say
81:08 - the f-score like that
81:11 - oops f score is going to be equal to
81:15 - so the f square of current oh sorry what
81:17 - am i saying current this is this should
81:18 - be neighbor
81:20 - my bad guys sorry this this is neighbor
81:21 - i don't know why i was typing current so
81:23 - the g
81:23 - score of neighbor equals the temp g
81:24 - score of course that makes sense
81:26 - the f score of neighbor equals the temp
81:29 - g-score
81:30 - plus the h of in this case it's going to
81:33 - be
81:33 - the neighbor like that dot get
81:36 - underscore position because remember we
81:38 - need the row column position not just
81:40 - the spot itself and not neighbors it's
81:42 - going to be neighbor
81:44 - and then this is going to be end dot get
81:46 - underscore position
81:47 - so let me just assure that i typed that
81:49 - correctly yes i think i did
81:52 - essentially get pause remember is that
81:54 - method we wrote all at the beginning
81:55 - right here that gives us the row
81:57 - and gives us the column so we need to
81:59 - pass that in because the method that
82:01 - does
82:01 - the h if you look right here expects two
82:04 - positions not to spot objects
82:06 - so that's how that works we update the f
82:08 - score and now we say if the
82:10 - neighbor is not in
82:13 - the open set hash so this is why we're
82:16 - using the open set hash so that we can
82:18 - check
82:18 - if the neighbor is in the open set or
82:20 - not so it's not in
82:21 - increment the count because now we're
82:23 - adding something in so if it's not in we
82:25 - add it into the set
82:27 - so count plus equals one and we're going
82:28 - to say open set
82:30 - dot push or is it push or is it put
82:33 - sorry it's
82:34 - put and now we're going to put in this
82:36 - new neighbor right because we're now
82:38 - going to consider this neighbor because
82:39 - it has a better path than what we found
82:41 - before
82:42 - so we're going to put in the f score so
82:43 - we're going to say f score
82:45 - of neighbor needs to go in here we're
82:47 - going to put in whatever the count is we
82:49 - just added 1 to it
82:51 - and then we're going to put in the
82:52 - actual spot object itself which is going
82:54 - to be
82:54 - the neighbor so that goes into the open
82:56 - set and then the open set hash gets the
82:58 - same thing
82:59 - so open set hash dot add
83:02 - neighbor just because we're just going
83:03 - to store the spot in there we don't care
83:05 - about the f score and the count
83:07 - and then we're going to say neighbor dot
83:09 - make
83:10 - underscore closed so this is essentially
83:13 - saying okay we're going to make
83:14 - this current neighbor that we just put
83:16 - here closed
83:17 - so that we know we've already considered
83:19 - this neighbor and that's making me look
83:21 - for
83:22 - or sorry not closed this is going to be
83:24 - open my bad because we just put this
83:26 - into the open set of course it's not
83:28 - closed it's going to be open it's green
83:30 - we put it in the open set
83:31 - and then finally after this what we're
83:34 - going to do is we're going to tab out
83:35 - so outside of the for loop we're going
83:37 - to call draw i'm going to say if
83:39 - current does not equal start
83:42 - then we're going to say current dot make
83:46 - underscore closed like that
83:49 - so what this is going to do is
83:50 - essentially say i mean i just went
83:52 - faster but we've pretty much
83:54 - finished this entire algorithm so i can
83:55 - show you how it works in a second
83:57 - if current is not the start node make it
84:00 - closed
84:01 - so that's saying that if the node that
84:03 - we just considered and we just looked at
84:05 - is not the start node we just make it
84:07 - red and just close it off because we've
84:09 - already considered it and it's not going
84:10 - to be added back into the open set
84:13 - if it is it will be made open and we'll
84:14 - see that right so that's the idea behind
84:17 - this now of course we need to
84:18 - reconstruct the path there's a few small
84:20 - things we need to add
84:21 - but this is pretty much it and at the
84:22 - very end here i'm just going to return
84:25 - none or return false to say hey we did
84:28 - not find a path
84:29 - so that is this entire algorithm so let
84:31 - me go through a quick summary
84:33 - and then we'll actually run this and
84:34 - make sure it works so we have a count
84:36 - we have an open set we start by putting
84:38 - the start node in the open set
84:40 - we have came from this keeps track of
84:42 - where we came from so what nodes came
84:44 - from where
84:45 - so we can find the best path at the end
84:47 - g-score
84:48 - keeps track of again the current
84:51 - shortest distance to get
84:52 - from the start node to this node we
84:55 - initialize them all at
84:56 - infinity to start and then we set the g
84:59 - score of start to be zero
85:00 - f score this keeps track of our
85:03 - predicted distance from this
85:04 - node to the um what do you call it to
85:07 - the end node so going through this path
85:09 - so following this path with this node
85:11 - how long do we think it's going to take
85:13 - or what do we think the distance is
85:14 - going to be to get to the endnote
85:16 - and then we set the initial um so these
85:18 - are start at
85:19 - infinity just like g-score and f-score
85:21 - we start the
85:22 - initial f-score of start to just be the
85:24 - heuristic so whatever our guess is from
85:25 - the start note to the endnote
85:27 - which makes sense because right now it's
85:29 - gonna cost us zero to get from start to
85:31 - start
85:31 - so the only distance we need to go is
85:33 - whatever our heuristic distance
85:35 - is right and then open set hash this is
85:38 - just gonna help us see if something's in
85:39 - the open set
85:41 - and then we have our while loop that
85:42 - says okay while the open set's empty
85:45 - make sure that we're not quitting the
85:46 - game if we are let's quit get out of
85:48 - this
85:49 - current equals open set dot get two
85:52 - so what that does essentially and in
85:54 - fact i can actually just return from
85:56 - this if i wanted to uh let's leave it
85:58 - pie game quit
85:58 - so current equals openset.get2 the open
86:01 - set is a priority queue
86:02 - the priority queue is just an efficient
86:04 - way to get the smallest element
86:06 - every time out of it it has uses a keep
86:10 - sort algorithm i believe to do that
86:11 - actually
86:12 - and you don't have to know what that is
86:13 - but essentially it's just a very
86:14 - efficient way to get the minimum
86:16 - element from this queue so it gives us
86:18 - the minimum element whatever the minimum
86:20 - f score is we get the actual
86:22 - node associated with that or the spot
86:25 - object
86:25 - we remove that from current or from the
86:27 - open set hash sorry remove current from
86:29 - the open set hash
86:30 - we say if we're at the end we found the
86:32 - path we finished boom we're done
86:34 - otherwise consider all the neighbors of
86:37 - the current node
86:38 - to calculate their tentative g-score
86:40 - their temp g-score
86:41 - if that's less than whatever their
86:42 - g-score is in the table
86:44 - then update that because we found a
86:46 - better path and then add them
86:48 - into the open set hash if they're not
86:50 - already in there and that
86:51 - is the very very basics of how this
86:54 - works
86:55 - so now what i'm going to do is go ahead
86:57 - and run this and show you the
86:59 - visualization so i won't be surprised if
87:00 - we made a few minor mistakes and we need
87:02 - to rerun some stuff but let's just go
87:04 - ahead and do this and press space
87:06 - and what is the problem we're getting
87:08 - here so let's see what's happening
87:10 - update neighbors missing one required
87:11 - positional argument grid
87:13 - okay so it makes perfect sense we need
87:15 - to go down here to where we're calling
87:17 - update neighbors and just pass grid into
87:19 - there
87:20 - and hopefully we should be good now so
87:22 - self.spot.updatenavers grid
87:24 - let's run this and see what we get okay
87:28 - and there we go this is actually working
87:30 - and we have
87:31 - the visualization going now of course we
87:33 - don't have the path being reconstructed
87:35 - yet that's the last thing to do
87:36 - but we can see it hit that endnote and
87:38 - boom perfect
87:39 - it found it right and it went and we can
87:41 - see that it didn't consider every single
87:43 - node
87:43 - it actually just went you know pretty
87:45 - much right to the node and had a pretty
87:47 - efficient path to find that
87:48 - so now let's reconstruct the path which
87:50 - is actually going to be really easy to
87:51 - do
87:52 - and then we will be done so now inside
87:54 - of here i'm going to say
87:55 - re construct underscore path
87:59 - i'm going to pass came from and i'm
88:02 - going to pass
88:02 - the current node which is actually just
88:05 - going to be the end so we can just pass
88:07 - end and i'm going to pass draw now draw
88:10 - again is that same function they passed
88:12 - in
88:13 - let's make another function up here and
88:14 - let's say reconstruct
88:17 - underscore path let's take
88:22 - came from and and
88:25 - i was just draw okay now inside of here
88:29 - all we're going to do is we're going to
88:30 - say wow
88:32 - current is in came from so while it's in
88:36 - that list
88:37 - what we're going to do is not current
88:39 - actually yeah let's rename this current
88:40 - so instead of end this is going to be
88:42 - called current
88:43 - so while current is in came from which
88:45 - is that table that stores
88:47 - um you know a came from b b came from c
88:50 - c came from d so on so forth
88:52 - then what we're going to do is we're
88:53 - going to say current
88:56 - equals came from of what
88:59 - is this going to be current and then
89:02 - we're going to say
89:02 - current dot make underscore path
89:08 - and we are going to at the end of here
89:10 - draw
89:11 - okay so i'll explain this really quickly
89:13 - but this is pretty basic we're saying
89:15 - okay the current node starts at the end
89:16 - node we're going to traverse from the
89:17 - end node back to the start node
89:19 - the start node is not in came from it's
89:21 - not in there so
89:22 - that's fine right we don't put anything
89:24 - in came from for the start node
89:26 - so once we get to the start node we're
89:27 - done but essentially
89:29 - current will be equal to whatever we
89:31 - came from from the last node so from the
89:33 - end node
89:34 - what do we come from some node that's
89:36 - current make that part of the path
89:38 - draw it and then keep doing that and
89:41 - then once we get to the point where
89:42 - we're at the node
89:43 - that came from the start node and we hit
89:45 - the start node it will stop and it will
89:47 - stop reconstructing the path
89:49 - so that should be it let's run this
89:52 - and i'm just going to actually say end
89:55 - dot make end here just because
89:59 - if you don't do this essentially what
90:00 - will happen is it's going to draw
90:02 - purple on top of the end node and i'd
90:04 - rather just have us be able to see
90:06 - start end and then the path in between
90:09 - so anyways that'll make sense but
90:10 - let's run this and see if this works now
90:12 - so i'm just going to literally press
90:13 - space you can see boom that's the path
90:15 - that we discovered
90:16 - and there we go now one more thing that
90:19 - we should do is first of all let's run
90:20 - this and see if we can get a more
90:21 - complex example that
90:23 - works a little bit better i want to make
90:25 - a way to like reset this and clear the
90:27 - screen
90:28 - and by the way don't feel bad if yours
90:30 - is running a lot slower than this i'm on
90:32 - a very fast computer right now
90:34 - but let's go to a way to reset this so
90:37 - that we can just run this as many times
90:38 - as we want without having to close the
90:40 - program
90:41 - so this is going to be pretty easy i'm
90:42 - just going to make another command
90:44 - inside of here so unders
90:46 - underneath this if statement and say if
90:48 - event
90:49 - dot type equals equals pi game dot
90:53 - and should actually just be indented one
90:55 - more so not event dot type will say if
90:57 - event dot key
90:58 - equals equals pi game dot k underscore
91:02 - lowercase c then we're gonna clear so
91:04 - what this will do is it just clear the
91:06 - entire screen just make
91:07 - everything white so then we'll be good
91:10 - to go and good to start again so i'm
91:12 - just gonna make sure
91:13 - i'm not messing this up but i think we
91:14 - can just say start equals none
91:18 - end equals none and grid
91:22 - equals make grid and we need to pass
91:25 - what for that
91:25 - rows and wait
91:29 - okay so that should be it for clearing
91:31 - the way this works is we'll just reset
91:33 - start endnote just remake the entire
91:34 - grid which means that
91:36 - everything will just get reset
91:37 - automatically and then we should be good
91:39 - to go
91:40 - um and yeah i think that should
91:42 - literally be all we
91:44 - need to do um yeah so i think that's
91:48 - good i'm just going to add one more
91:49 - thing to this case space thing i don't
91:51 - think i need this started thing actually
91:53 - i haven't even used it so i'm going to
91:55 - say if event dot key equals
91:56 - python.counter space and start
91:59 - and end to make sure hey we have an end
92:01 - and a start node before we do this
92:03 - because if we don't that's going to
92:04 - crash
92:04 - so of course we need that first that's a
92:06 - necessary thing here i should have had
92:08 - before
92:09 - if we have a start and end node then
92:10 - we're good to go and i can remove
92:12 - this if started thing because we're not
92:14 - even going to use that so we can get rid
92:15 - of started
92:17 - okay so now we should be good let's run
92:19 - this
92:20 - and let's see what happens if i press c
92:23 - so c
92:23 - clears everything resets it
92:26 - let's run this and let's press c you can
92:29 - see it resets and then we can go
92:31 - as many times as we want so this is the
92:34 - pathfinding algorithm
92:36 - this video has taken a tremendous amount
92:38 - of time to make this is not an easy
92:40 - thing but a lot of you guys asked for it
92:41 - i think it's really cool and i wanted to
92:43 - make something that was just
92:44 - awesome that you guys could really
92:45 - appreciate you can mess with and i just
92:47 - i love these programs they're so cool
92:49 - they're really what got me into
92:50 - programming when i was a kid so i hope
92:52 - you guys enjoyed
92:53 - if you did make sure you leave a like
92:54 - please subscribe to the channel leave a
92:56 - comment let me know what you thought of
92:58 - the video
92:58 - and of course i will see you guys in
93:00 - another youtube video

Cleaned transcript:

hello everybody and welcome back to their python tutorial so in this video what we're going to be doing is learning about the a star path finding algorithm and then actually implementing that into a visualization tool so this is a really cool video because this project is just really fun in my opinion to actually see how a computer kind of goes down the process of finding the shortest path between two points and a visualization tool like this although it is kind of simple this isn't going to be a super complicated program looks really great on a resume and is a really great thing you can point someone to and say hey you know not only do i know how to use algorithms but i also can implement them into this cool visualization tool and you can now watch these you know this computer figure out the shortest path between two points so anyways this has really fascinated me let me give you guys a quick demo of what it is we're going to be creating and then i'll talk more about how this tutorial series is going to look or how this tutorial is going to look and kind of what you can expect from it so you can see here this is the basics we have just the visualization of finding the shortest path now since a star is actually an informed search algorithm which we'll talk more about later this means we can avoid doing a ton of unnecessary searches that we don't need to do so for example in an uninformed search algorithm they may potentially consider some of the nodes over here where i'm kind of drawing and erasing these barriers and the reason they might do that is because it's just somewhat of a brute force approach they're just checking every single possible path they're not actually moving in a direction that kind of makes sense whereas this algorithm here you can see was always kind of moving in the right direction it might have gone off a little bit maybe it goes down some roads that aren't necessarily correct but it always is moving in the correct direction and that is kind of what's guiding the algorithm and making it much more efficient now of course these gains are way bigger when you have a huge map and a much larger network of nodes connected together but in this case on a 50 by 50 grid which i have it happens pretty much instantly and if i omitted actually doing the drawing aspect where we draw the green and red squares then this would happen pretty well instantaneously so with that being said i will quickly say that this is not a beginner tutorial series although it's not going to be super complicated we are going to be using some data structures and algorithms we're going to be talking about this algorithm which is not trivial by any means and well if you're you don't have any experience with python this might be a little bit overwhelming so i just want to warn you right now so that being said let's go ahead and start talking about the a star path finding algorithm after a quick word from our sponsor i need to thank simplylearn for sponsoring this video and introduce you all to their data scientist master program that was codeveloped with ibm this program is comprised of six unique courses that implement a unique blended learning experience in a high engagement online classroom environment during this program you will master 30 plus indemand skills and work with tools and languages like r sas python tableau hadoop and spark you'll master these skills through 15 real life projects and one capstone project during this 12 month comprehensive course you'll also be given 1200 usd worth of ibm cloud credits to use during your 24 7 access to the ibm watson platform after completion of this course you'll be given certificates from ibm and simply learn to testify to your skills as an expert in data science get started by hitting the link in the description all right so now it's time to understand the astar pathfinding algorithm so before i go into all the kind of explanations and definitions i'm going to quickly define what a few terms mean so when i say node i'm talking about a letter okay i'm talking about a b c d this is a node a node is anything in a graph that you can visit you can think of this as a vertex right say we have a triangle you can think of the nodes of a triangle if you're treating this as a graph as the three vertexes and the edges are going to be all the lines that connect those so we have nodes and we have edges just understand edges connect nodes nodes are usually represented as a circle or something that you could visit if we look at a grid for example and we have like a 2x2 grid then really you can draw this grid in kind of a graph format like this where all of these are the nodes and then the edges are the connections between these nodes which could just mean you know what it means like go from that node to this node that's all i'm saying just hopefully that makes sense and last thing here to explain is when we have an edge we can have a wedge an edge that is a weighted edge or an unweighted edge if it's a weighted edge what that means is that it takes a certain amount or it is a certain length so obviously weight one is a shorter edge than weight two so obviously this is not drawn to scale if you're talking about the weights of these edges but i've drawn them just with different weights so that for this algorithm it makes sense so we can actually do something that's meaningful but in our example we do the astar path finding and we're using the grid none of the edges are going to be weighted they're all just going to be known as like 1. we'll just give them all weight 1 because we're just assumed they're all the same distance essentially okay hopefully that makes sense now let's get into the algorithm so uh how does this work what is the astar path finding algorithm well the goal of this algorithm is to find the shortest path from point a to point b in a graph using the edges that are in that graph right and anything can kind of be represented as a graph just like we've been drawing over here and i've been showing you so how do we do that well this is an informed search algorithm which means we don't only just brute force and attempt every single path we actually have what's known as a heuristic function that helps guide us and figure out the correct path to go down essentially as you'll see as we go through this algorithm we only consider paths that we know are optimal we don't consider things that you know have a huge distance to get to them already or that look like they're going to be really far apart we may consider those but that's the least priority and hopefully we don't even have to we end up finding a shortest path before we even consider those nodes so that's kind of the point of this algorithm as you're going to see but i think the best way to explain this to you is really just to go through an example and just kind of slowly go through it as we go so what we need to do to start is we need to take our start node which in this case is going to be a we need to put this inside of our open set so we have this open set this is going to be represented by a priority queue when we actually do this implementation don't worry if you don't know what that is we'll talk about it later and essentially the open set keeps track of the nodes that we want to look at next you can think of it almost just as a queue it's the next things that we want to consider so we always start by putting our start node in the open set and we put it in the open set along with the distance to that node which we're going to say is our our f score now i need to define what this f g and h scores stand for because these are going to be very important as we go through this algorithm so let's do that quickly so h score which is of just simply a function h n so h of n gives us an estimate of the distance from node n to the end node essentially we just pass it a node and it looks at the end node and says okay you know i don't really know how far away you are but like if we're just doing absolute distance so literally from the center of say a to d even if an edge doesn't exist here i'm going to assume your you know x blocks away just based on that absolute distance that's what this function does there's many different distance formulas you can use in here i think euclidean distance is popular some people use manhattan distance that's what we're going to use here lots of different distances anyways this is just some function that gives us the distance from node n to the end node there we go and again this is not like a super correct distance this is just a guess at what that distance is based on some formula that we've implemented in there awesome that's the h score your g score is the um the current shortest distance to get from the start node to this node so we're talking about the gscore of c then whatever the shortest distance from start from point a which is our start node to point c that we've currently taken that we've currently found will be this gscore and the f score is simply the addition of the g score and the h score so if you understand that and i wrote the kind of formula down here so we can remember what makes everything up the f score is pretty much trying to give us an estimate say okay we've already taken two blocks to get to this node and from this node we think it's going to take like five blocks to get to the end node so we have a total score of seven okay should we start looking at this one first or should we consider this next node that has a lower f score right because maybe a lower f score means that this is actually closer and we should take that node over the other node that's the way that we prioritize which nodes we consider is by using the f score and the f score is made up of the g score and the hscore so again gscore is the exact distance the shortest distance that we found currently to get from the start node to whatever node we're talking about if we're talking about node d whatever the distance is whatever shortest path we've currently found to node d that's the distance we're going to have for our g score the age score is the heuristic which is just the guess at how far away we are from the end and the f score is the addition of those two scores to give us an estimate of how far away this node is from the end node uh or like what that finalized path would look like so that is these scores and they're going to be very important as we go through here so let's actually start this we have open set we have zero a so of course a is g score uh f score and h score is going to be zero because well it's itself right at our start node we can't have an f g and h score that's higher than zero because we're just already at our our same note hopefully that makes sense now the rest of these scores though we're going to start them at infinity and you're going to see why but just imagine the age score is not really relevant right now for these ones but just they're all infinity to start okay so we start them off at affinity because currently we have no idea we have not found any path these nodes we haven't considered anything from the start node so we just assume it takes infinity to get there that's just our main assumption and these might actually stay infinity because we may never actually even consider them so we have zero a and we pull zero a out of the open set we've just set everything up we've you know initialized our table we pull it out so we delete it from the open set and we start looking at it so okay we're on node a now we're considering node a i think i'm just gonna underline what node we're currently looking at so i'll just underline it like that we're looking at node a and the first step is to look at the neighbors of node a so in this case the only neighbor of node a is c and there's only two ways to get to node c there's two edges so we have the two edge and the one edge so we start by just looking at any edge there's no order we take in looking at it so we say okay to get to node c we have edge one right so we have this edge here so what we're gonna do is we're going to say okay is this edge that we've currently taken like the current path to node c that we're on how long is this path what is the current path well the current path is distance one so we compare that now to the gscore of node c and we say okay is the current score that we're looking at score one shorter than the current gscore of node c so we compare it to infinity which is right here and we say which is shorter well of course distance one is shorter than infinity or smaller than infinity so we go ahead and we update the gscore and make it one and we say okay now currently the best path we know the best we've found to get to node c is from node a to node c taking edge one right taking the edge with weight one so we update that score then we go ahead and we update the h score so we say okay since we're considering this node c now we found a better path we're not skipping over it this is the correct way to go what is the h score the tentative distance from node c to node d what is our guess for that well our guess for that we can just kind of make that up i'll just say oh we think that's going to take you know one distance point to get there so i'll just write 1 here of course obviously it's 2 but we don't know that we're just taking an absolute distance guess so we take we take a guess of one and then we update our f score and we say okay well the f score now is going to be two because of course the g score and the a score added together is two and once we update the g score we update the h score and then we update the f score accordingly so hopefully this is all making sense but this is the basics of it so 2 1 1 those are our scores and then we go ahead and we update this last which tells us where we came from to get these scores so we came from node a to get to node c there we go that just tells us what node was the last node we came from awesome now i'm actually just going to delete this other edge because for our example we're not going to do anything with multiple edges so i think it'll just make more sense to do this so let's go ahead and do that so now once we've considered this node and we said okay you know this was the shortest path what we do is we take that node and i'm just going to erase some of this stuff now to clean it up and we add it into the open set so we say okay we've considered node a now we just looked at node c as a neighbor so let's throw that into the open set so we're going to say okay what's the f score of node c that's two let's add that to the open set so we say two c say the current choice distance um in the open set is two c now we look in the open set and we say okay give me the node that has the shortest f square well there's only one thing in the open set so we have to use this one so we take it out and i guess i can just move it like this if i really wanted to oops i forgot a bracket let's move that there so we take this and we move it out of the open set and we start considering node c so double underline and now we do the same thing we look at the neighbors of node c so let's start by going to node b let's look at node b and we go okay so what is the current distance that it takes us to get from node c to node b well we got to know go from a to c that's one and then from c to b that's four so our current kind of tentative g score right now is four so we say all right if we're using node c to get to know b we're gonna have a g score of four so we take four right and we compare it to the g score of b and we say okay is that larger or smaller well that is going to be smaller so we update the g score of b and then we go ahead and we update the h score and the f score so what's the h score from node b to node d let's just say that that's a distance of let's give it 2 that's going to be our guess so we'll say okay that's going to be 2. so now our f score is 6. now we've looked at node b we've considered the neighbor so we add node b into the open set with its current f score so we say 6 b and that's now inside of the open set so let me just erase this now to clean this stuff up and then we'll move forward and we'll do the next neighbor so of course the next neighbor is d which so happens to be our node but don't worry we're not done the algorithm yet so we go from c to d and we say okay what is the tentative gscore that we've kind of just calculated here between node c and node d from the start node well that's of course going to be three so we go here to the gscore we say okay well is that less than infinity yes it is so we update that that becomes three what do we do next we update the h score and we update the f score so let's say that our guess from node d to d well that's obviously going to be zero so we'll put zero right there and then what about the f score well that's just going to be 3 right so there we go so now we go into the open set and we put inside of here 3 d like that boom so now we've considered c we're done with c we can erase this right here and let me just fix this this bubble uh we can erase this four and now we go into our open set and we say okay give me the node in here that has the shortest f score or the lowest f score well of course that's 3d so we pop 3d out of here and as soon as we do this as soon as we take the end node out of the open set we immediately finish the algorithm and we know that the shortest path now has to be from a oops it was not supposed to be an eraser from a to c to d now the reason we know that and let me just actually fill some of these things and i forgot to fill in the last column from d that was c from b that was c and from a the last would have just been nothing but anyways this is what our last column would look like so the node that we came from and essentially what we do is okay we found d we know this must be the shortest path because if d was in here anywhere else we would have picked it out and it would have had a shorter f score right because we picked out the smallest f score so we reached d we took out the last node and now the algorithm is complete it's finished and all we have to do is find the path now the way we find the path is we just backtrack we say okay d came from c c came from a so that must be our path right there and that is our path and it so happens to be the shortest path just by following that formula now of course things can get a little bit more complicated and there's more edge cases and things to consider but that is the basics of this algorithm you have this h score and this f score and this g score that help show us where we should be going what direction we need to move in and what nodes we consider next so let's just imagine for a second though that maybe we didn't just immediately consider this this end node right maybe we didn't hit the endnode let's just imagine that actually d maybe isn't necessarily the endnote maybe there's another node here that is the end node and that's our new end then what we would do is we would simply since d was already in here we'd pop it out we'd consider the neighbors of d so we considered c we consider b and we consider e and remember if i'm considering b what i would be thinking about is okay so to get from a to c to d to b what is the distance going to be and of course that distance is going to be larger than whatever the current distance was the current gscore to get to b so actually one two one um is going to be the same but since it's the same we don't bother updating it we just say okay we don't need to update that because obviously the current distance to get from a to c to d to b well that's four the distance that we have as the g score that's four so since that's not smaller we just don't do anything we just skip over b and we say okay we don't need to look at that anymore we're not adding it back in the set we're just moving past it and then we go and we consider d all right we consider c and we consider e so we do e our c we determine that well to get to c is obviously not shorter to go ac dc than it is to just go ac so we don't update that and then we consider e we'd update e in here with whatever the values are we'd add e to the open set the distance for e would almost likely be larger than the distance for b we would take out b we would consider that and and that's how we would keep going so i know i'm kind of just fast forwarding through the rest of the algorithm it does take a long time to walk through but that is the basics and of course as we go through this it's going to start to make a lot more sense but that is how the f g and h score work and hopefully you understand how we're considering nodes that are closer first with that estimate of that h score um that g score that's telling us the actual distance and that f score that's the combination in between so anyways that is going to be my explanation if you don't understand that i'm going to recommend you head to wikipedia maybe rewatch this see if you can do this yourself on it on your own graph maybe do it on a piece of pencil and paper but once you feel comfortable let's move forward and let's actually start coding this out okay so sorry for that long explanation but i really do try and try my best to make sure you guys really can understand everything so that i'm not just blindly going through and showing you that even if you don't understand completely i will be reexplaining as we get to the implementation part but now let's actually start working on this visualization tool and more of the fun stuff so the only real prerequisite for this is to install pygame so pi game is a 2d graphics module in python really easy to use i'll explain all the stuff that we do here but to install that go to your command prompt or terminal and you're gonna type pip install pi game now you might if you're on mac be able to use pip three so just try pip install pi game if that doesn't work for you i'll leave a card to a video that explains how to install pygame and i'll leave a link in the description as well if you're on mac just replace uh pip with pip 3 and that should hopefully be able to install it and then i think you can also try python hyphen m and then pip install and then pie game as well now these are all just different options you can try so i'm just giving you a bunch of commands but in your terminal or in your command prompt pip install pi game pip 3 install pi game python hyphen m pip install pi game or python 3 hyphen m pip install pi game if none of those work or you get like pip is not recognized as an internal external command watch the video it should hopefully help you do that anyways once we've done that i'm going to be working in subline text for this video you guys can work in whatever editor you want we're going to start by doing some imports so we're just going to import pygame i've already made a python file here we're going to import math like that and we're going to say from q import priority queue now we'll be using this later i'll explain how that works it's going to be for the algorithm but you don't need to install this this should be built into the python standard library now next i'm going to define the width of my window so i'm going to make everything square so i'm not going to have a height i'm just going to have a width and i think i'm going to make that 800. so width 800 and then i'm going to say win and then in this case that's going to be equal to pygame.display.set underscore mode and inside of a set of brackets i'm going to go width width so this what this does is just set up why is this not working with i'm hitting enter it's literally canceling what i'm typing okay anyways width like that hopefully that's fine if i could get the right character okay so width sorry about that but regardless what we're doing here is we're just setting up the display so we're essentially saying this is how big the display is going to be this is the dimensions i'm making it width by width just so it's a square and then i don't have to deal with any height variables later which is going to make things a little bit nicer next what we're going to do is we're going to set a caption for the display so not in capitals we're going to say pi game dot display dot set underscore caption and for the caption what we're going to do is just put whatever we want but i'm going to put a star like that and i guess i don't need to say star a star path finding algorithm this mic is really in my face kind of in the way of the keyboard so that's why i'm getting all these typos because i usually look down a little bit just prewarning there anyways we have that now so widthwindpygame.display.set underscore caption and now if we actually go ahead and run the program we should see that a window pops up and then it just immediately disappears so that's how you can test to make sure that this is working you're not going to see anything right now it's just going to go away pretty much instantly but if that's working good okay so next we're going to define a bunch of colors now i'm actually just going to copy these in you guys can pause the video if you want to copy them out but all this code will be in the description if you want to copy and paste different aspects of it but i want to have all these color codes here because we're going to need to be using them for actually making the path and making the different squares and changing the color of things and all that so we have red this is a red green blue color code green blue yellow white black purple orange gray turquoise feel free to change all of these colors to whatever you want but just define them in all capital letters as constants and have them here so we can use them throughout the program now the next thing that i'm going to do is i'm going to define a class called spot now remember we're building a visualizing tool so i actually have to build kind of the main visualization tool before i can implement the algorithm because the algorithm is going to be dependent on what our tool looks like right so we need to figure out essentially how are we going to keep track of all of these different nodes that are in our grid because remember we're going to do this huge grid this grid is actually going to be a 50 by 50 grid and we can change the dimensions of that if we want and in that grid we're going to have a bunch of spots or a bunch of cubes or whatever you want to call them i like to call them spots but you can call them whatever you want you can even call this a node that might even make more sense but i'm going to go with spot and this spot is going to need to hold a bunch of different values so it's going to need to keep track of where it is so what row column position it is in the grid because this will just be one of those little cubes it's going to need to know what the width of itself is so it knows how to draw itself right if it is wrong itself although i don't think we actually actually we will need to draw these spots because they're going to be different colors and then it's going to need to keep track of all of its neighbors that's something that's important and a few other things as well so it's color will be the main thing because it needs to know okay am i a red node am i a green node am i a barrier am i the start node am i the end node which will all be represented by different colors if you remember the example that i did and so on and in fact let me just run the example so you can kind of see what i mean so we have like all these different spots right so when i click on one of them it changes colors and that's what the job of this spot class is going to be is to keep track of the color of all of these spots and know what location it's in right so then when i press space you can see there's red and there's green and then of course there's purple as well that represents the path so hopefully that makes sense uh i just wanted to show you that's what it is okay so class spot so we're going to define an init in here so we're going to say define a knit we're going to say self we're going to say row call width which is just going to be you know how wide is this spot and then rows now i'm just going to call this total underscore rows now the reason i'm doing that is because we need to keep track of how many total rows there are here you'll see why in just a second but this spot does need to know that and i want to avoid any global variables so i'm just going to throw it right into the instance so i'm going to say self.row equals row i'm going to say self.call equals call i'm going to say self.x equals row times self dot width actually this is just going to be width i'm going to say self.y equals call times width as well now the reason i'm doing this is because i need to keep track of the x y like the actual coordinate position on my screen because when i draw things in pi game i can't just say okay draw it at you know five five i need to draw the actual cube which is going to have some kind of width it's going to be sitting in some position so i need to know what position that is and i can determine that because let's say i have 50 total cubes and the size of my screen is 800 well then i go 800 divided by 50 which i think is like 16 or something like that and that will be the width of each of my cubes so i can figure out where the starting x and y position is by taking the row that i'm at and multiplying that by the width of all of these cubes that's the idea there we're going to say next self.color equals white so to start we're going to have all white cubes this will again change as we go through i'm going to say self. oops if i could type here equals a blank list and then i'm going to say self.width equals width and self dot total underscore rows equals total underscore rows next what i'm going to do is i'm going to make a get underscore pause method and we're actually going to have a bunch of methods in this class and this is just simply going to return self.x or notself.x self.call and self.row and sorry it's going to be the other way around actually self.row then self.call so for this specific program i'm going to be indexing things using row columns so that's just what we're doing for the grid right if you look at grid of course we have a bunch of rows like that and we have a bunch of columns down so you know something like here could be indexed with i don't know like 6 3 or 6 4 or whatever it may be but we start by calling the row out so whatever y coordinate and then i call the x may seem counter counterintuitive or counterproductive but the way we're going to represent the data this this makes sense later okay so we have get pause so now we're going to define is underscore closed so is closed essentially like have we already looked at you have we already considered you those are the red squares so in this case we're going to say okay what makes a spot closed what would mean that this spot is in the closed set so we're not looking at it anymore what makes it red well i pretty much told you that we're just going to return self.color equals equals rep so the idea behind all of these methods here is we're just going to have a bunch of methods that essentially tell us the state of this spot and we're going to have a bunch of methods that allow us to update the state of this spot as well so they're just going to be changing the color and if this color is white well then this is a square that we've not yet looked at we could visit it if it's red we've already looked at it if it's black it's a barrier that's something we have to avoid that the algorithm can't use as a node to visit if it's orange it's the start node if it's purple it's the path right if you get the point so this might not be the best way to do it but this is what i've gone with for this tutorial and i think it makes it pretty easy to understand so we'll say is open so is open is just going to be return self dot color equals equals green so essentially are you in the open set now i don't know if we are even going to use that method but i'm just defining all of the different states just so it's consistent so next we're going to say is barrier so are you an obstacle well what makes this an obstacle that's if the color is equal to black right so if it's black because we're going to punch it in and we're going to draw all the obstacles then this is a barrier so that's what we're doing next we're going to say is underscore oops is underscore start i'm going to say self and we're going to say return self.color equals equals and for the start color we'll just go with orange but you're welcome to change any of these colors of course if you'd like and then finally we go is end actually there should be one more and we'll return self.color equals equals and i think i went with purple for the color finally i'm going to add another method and this one's going to be called reset and this is simply going to change the color back to white so define reset and we'll just say self.color equals equals white like that okay now you thought i was done with all the methods but we actually have more this is like the longest class that's just the most simple thing in the world but i'm going to say make underscore color and what am i saying make color i'm going to say make open make closed and pretty much duplicate all of these methods here with just a make in front of them so when you call this it will make this cube whatever it is that i'm saying here so in this case uh we'll start with closed just so it stays consistent so make closed self and i believe make closed was what color were we going with i think that was red right so we're going to say self.color equals rep so this time instead of just giving them back like are you red are you green are you this is going to actually change the color so make close we'll say make open this is going to be self and we'll say self dot color oops equals green like that we have more oh that's nice of that one away so to make open uh what else do we have make barrier make underscore barrier this is going to be self and then we'll go self dot color equals black okay and define make underscore end this is going to be self let me self dot color equals and what was the end color that was i'm going to go with turquoise actually for the end color and instead of purple i'm going to change this to turquoise my bad on the end color guys i want that want that one to be turquoise and then we'll say define make underscore path self self.color equals purple so purple will be the path turquoise will be the end color and then finally we need to add two more methods so define draw so this is going to be the method we call we actually want to draw this cube on the screen so we're going to say self wind so this is actually going to be this window so essentially where do we want to draw this that's what this argument is saying right here so self win and i think that's all i need and then to draw a cube in pi game go pygame.draw.rectangle so rect like that you put the window you put the color so that's self.color like that and then you put a rectangle that you want to draw so you give it an x y width and height and you can see it's saying surface color rect width that's just telling us how do you want to draw this rectangle where do we want to put it what position that's how pi game works so the way pie game works actually let me just run this example here is you start drawing things from the top left hand side of the screen so 0 0 is actually where i just put this start dot so technically i shouldn't be able to do that but that's fine if that happens see where this orange cube is uh or let's put it there where the orange cube is this is actually the zero zero so this is zero zero not down here like where you would normally think and as you move to the right x increases as you move down y increases so over here in the very corner where the turquoise dot is that would be 800 800 if this was 800 by 800 which it is so that's the idea with the x y when i start drawing something i always start drawing from the top left hand corner so if i say like i'm strong at 50 50 and the width is 16 then you're actually going to extend to like 66 66 so you go from 50 to 66 50 to 66 if you're talking about the lines hopefully that makes sense but i'm just trying to kind of illustrate to you how that works okay so we're going to go pi game.draw.rect we're going to say self and in this case not row and call but self.x because that's the actual coordinate position i want to draw at and then self.width and self dot not height width again so since we're not doing a height everything's square we can just pass in width twice and i'll just make it a rectangle and then finally we're going to say define update underscore neighbors if i could spell neighbors correctly like that this is going to take self and this is going to take a grid and we'll do this one later because this one is kind of a big function and then lastly i'm just going to say define underscore underscore lt underscore underscore just so i don't forget to do this we'll talk about what this does in a second other and we're just going to return false now for any of you that don't know what this lt is it's stands for less than and essentially this is how we handle what happens if we compare two spots together so now what i'm saying is essentially if we compared this spot and some other spot so two spot objects i'm just always going to say that the other spot is greater than this spot or yes i think that's actually maybe it's the other way around but regardless don't worry about this right now we'll talk about it when we use it but i just don't want to forget so i'm putting it there right now okay so the next thing i'm going to do just because this one's really easy is i'm going to define the heuristic function that we're going to use for our for our algorithm right so we need we need that h function we actually need to make that heuristic function so let's code that out we're going to say define i'm just going to call this h actually i'm just going to put p1 p2 here and p1 and p2 are going to be 0.1.2 so i'm expecting point 1 and point 2 to look like x y right or to be like row column or something like that so we have to figure out the distance between point one and point two and return that so the way we do this because we're gonna use manhattan distance which essentially is l distance so i'll show you how that works on the grid right here is we just do a very basic formula but essentially l distance or like manhattan distances say i have like these two cubes the distance i'm going to calculate between them is going to look like this it's just going to be whatever the quickest l is to get here this is going to be my guessing distance because we can't move on diagonals right and even if you could so if we can move on diagonals like that that's still going to be the same distance as just going in an l like that so that's what manhattan distance is it's sometimes called taxi cab distance as well because it's like if you're going in a straight line and you're moving around and all that but hopefully that makes sense that's the distance we're calculating so to do that i'm just going to say x1 y1 equals p1 i'm going to say x2 y2 equals p2 this is because this is going to be a component right so if i have like like p2 is going to be made up of something like you know 1 9 so i can split it into the variable x1 y1 where x1 would be 1 y1 would be 9 by just doing that it's a short cut in python and i'm going to return the absolute distance abs this is a builtin function of x1 minus x2 plus the absolute distance of y1 minus y2 it doesn't matter if you swap x2 and x1 so long as you swap y2 and y1 as well because that's the h function that's our heuristic now what i need to do is i need to actually come up with a way to make a grid so i need some data structure that can hold all of these spots so that i can actually manipulate them i can use them i can traverse the grid right i need this list that's going to hold all of the spots that i have in my grid so what i'm going to do is i'm going to say define make underscore grid like that and inside of here i'm just going to take the rows and the width so i'm essentially saying okay how many rows do you want in your grid because we're just going to have the same amount of rows as we do have columns and what do you want the width of this grid to be so that's what we're doing so i'm going to say grid equals a blank list and i'm going to say gap equals width integer division by rows so width of course be the width of our entire grid and rows will be how many rows we have doing an integer division will just give us what the gap should be between each of these rows or in other words what the width of each of these cubes should be so hopefully that makes sense and now we're just going to go ahead and actually create this i'm going to say 4i in range and i guess it's going to be rows we're going to say 4j in range rows up here we're going to say grid dot append an empty list we're going to make a 2d list that looks something like this with a bunch of different rows in their own list that all have spot objects inside of them so we say grid we have the gap and we have grid dot append for j in row range now we're going to say spot equals a new spot so we're going to use this class that we just defined up here we need to pass it its row its column its width and the total amount of rows in the grid and then there it'll be able to figure out where it should actually be sitting so we're going to say i j for row column because this is going to be our row this is going to be our column so we pass it i j we're going to pass it the gap that's going to be its width and we're going to pass it rows so now we have this spot object that we've created and what we need to do is we need to append it into the grid so we can say grid.append spot like that and that should actually be sorry grid i believe it's grid i dot append spot so what this is going to do is say okay in grid row i which is the row we just created here we're going to append the spot into it so we have a bunch of lists inside of lists that all store spots then at the very end of this we're going to return oops if i could hit the t key we're going to return the grid awesome so now we have the actual grid being able to be created and i'm just going function through function because i think it's easy to just code out these small parts that all do separate things and then kind of combine them together at the end so we have make grid and now we need a way to draw the grit so we have all these cubes but remember all these cubes are just like white cubes or black cubes we don't actually have any grid lines so if you look at this right you can see these gray grid lines and like all my cubes you can really clearly see kind of where they are and you know where they're defined so we need a way to draw these um these grid lines that we have that's what i'm going to do here so i'm going to say define draw underscore grid like that we're going to take inside of here the win the rows and the width so this is not actually going to draw every one of the cubes that are inside of the grid it's just going to draw those grid lines so this is pretty easy to do actually i'm going to say gap equals width integer division rows again that's going to be the exact same thing as up here i could have made this all capitals in fact to stay consistent let's make this lowercase like that and we're going to say 4 i in range rows like that and then here we're going to draw lines so for every row we're going to draw a i believe horizontal line first so pygame.draw.line in this case and what we're going to draw is a yeah horizontal line for each one of these rows so to do that we need to pass the win we need to pass the color which is gray and then we need to pass two positions so two xy positions where we want the start of the line to be where we want the end of the line to be so the start of the line we want to be at x position 0 and we want the y position to be i multiplied by gap like that and then for here we want this one to be width and then i multiplied by gap the reason we want that is because we're going to multiply whatever the current index of the row that we're on by the gap and what that will do is it will essentially tell us where we should be drawing the grid line so if we start at zero width we know we're going to be all the way on the two borders of the screen and we're just going to move those down constantly and draw a bunch of horizontal lines now we'll do the exact same thing i'm really going to copy this for loop and i'm just going to change the variable to be j so for j in range so now we're going to do the vertical lines and what we can do is just leave j times gap but leave that as the x and then as the y we're going to go zero and width like that so tap that in i'll explain this quickly essentially this is the exact same thing as the horizontal lines except i'm flipping the coordinates so now we're always going to be at the top and bottom and we're going to shift along the xaxis and draw all of those vertical lines so i think let me just make sure yeah that's it for doing that and next we're going to actually make the main draw function which is going to draw everything so i'm going to say define draw and inside of draw we're going to take win grid so we need an actual grid that's being passed here we need the amount of rows and we need the width of the screen so we have win grid rows width and then here we're going to say wind.fill so this just fills the entire screen with one color you do this at the beginning of every frame so we're going to run like you know 100 frames per second or 50 frames per second or whatever it is and at the beginning of every frame we're going to paint over everything that was on the canvas and we're going to redraw everything in its current state it's not the most efficient way to go about doing things when you talk about drawing things on the screen but for our purposes totally fine and this is common practice in pie game so we're going to fill everything with white and then what we're going to do is we're going to say 4 in lower cases for row in grid so for all those rows and we're going to say 4 spot in the row because remember this grid is going to be whatever this creates so it's going to be a 2d array or a 2d list and we're going to say spot dot draw and we're going to pass the win so essentially if we go back to spot.draw you can see this just draws its own color on its x y and whatever the width it is so it just draws a cube with whatever color this spot is right that's all it does so now we just need to call that method on all our spots which are going to be stored in our grid which are stored in the rows so we loop through all of it go through all the rows and then draw all of the spots next we draw the grid so we say we're going to draw the grid lines now on top of that because this will be drawn first so we fill the screen we draw all the colors we draw the grid lines on top and then we'll be good and we've drawn everything we need to draw so we do draw grid we need to pass that win rows and width like that and then finally we do pie game dot display dot update now there's nothing that needs to go in here all this is tells us is hey pie game take whatever we've just drawn and update that on the display awesome so next what we need to do is we need to write a few more functions so the next function i'm going to write is a function that can take a mouse position uh position sorry and figure out what grid uh or what i don't even know describe it what cube or what spot we actually clicked on so if you imagine let me just boot this up here for one second i have to be able to figure out which one of these spots to change colors when i click the mouse right now this is pretty easy math but essentially i have to figure out based on where my mouse position is in this screen because right here it's at 0 0. in the bottom right hand corner it's at what do you call it 800 800 i got to figure out based on whatever position it is what cube i'm clicking inside of that's what this function is going to do given a mouse position is going to translate that into a row column position representing the cube that i actually clicked on so i can do things like draw a maze and all that fun stuff so let's figure out how we do that so we're going to say define get underscore clicked underscore position so this is just telling me you know where do we click so get clicked position we're going to take a mouse oops if i could get inside of here we're going to take a pause which will be the mouse position and we're going to take the rows and the width so first thing we need to do is we need to define the gap so we're going to say the gap is equal to the width over over the rows so integer division and then we're going to say i comma j equals position so essentially we're going to say okay you know like the x y we could actually do this maybe this will be easier let's go the y x is going to be equal to position and we can say rho is equal to i over over gap and call is equal to not i sorry this is y oops 2x over over gap so the reason this works is we're figuring out uh we're pretty much just taking whatever the position is in the x and wherever the position is in the y and dividing it by the width of each of the cubes so that'll give us where we are and what cube we've clicked on i i can't really explain that much more and then we'll just return row call like that so we'll be getting the row column that whatever person clicked on and this is just a helper function that is you know nice and easy to use and now we're off to the main function where we're actually going to start setting up some of these events and start drawing some things on the screen and seeing how all this works so we're going to say define main this is going to take a window and a width like that this is going to be our main loop this is kind of the usually you start with this but i just wanted to get all kind of the easy stuff out of the way all these you know basic functions and this class and the more tedious stuff before we did this so we didn't have to keep going back and changing this our main loop and this is going to determine essentially all of the you know checks that we're doing so all the collision checks all of the oh when you press space start the algorithm oh when you press on this cube change the barrier that's what we're doing inside of here so maybe a little bit more complicated but shouldn't be crazy so i'm going to start by defining the amount of rows we want to use so i want 50 rows the way i'm going to do this you can quite easily change this number to whatever you want and it'll just make a grid that has more cubes in fact i have my other example up let me show you what i mean now you know i have a hundred cubes and we can quite easily run the algorithm on this it's just gonna take a little bit longer because there's a lot more cubes so i'm setting it up in a dynamic fashion such that you know everything is completely changeable and that's why this might take a little bit longer but it's nice because you can make it as big or as small as you want so we're going to say rows equals 50 we're going to say grid equals make grid oops if we go like that what we need to pass to make grid is the rows and the width so we have rows like that and we have the width so now make grid which we just defined up here is going to actually generate the grid and give us that 2d array of spots or a 2d list whatever you want to call it next i'm going to define the start position and the end position which to start are going to be none we need to decide those and then i'm going to say run equals true and started equals false so essentially just some variables to keep track of the start and end position if we're running the main loop or not and if we've actually started the algorithm or not so now we're going to say well run so while this run variable is true i'm going to say for event in pygame.event like that and what this essentially is saying okay at the beginning of each of this while loop let's loop through all the events that have happened and let's check what they are so an event could be someone pressed down on the mouse so they press the keyboard button or a timer went off whatever events happen in pi game we're looping through them and now i'm going to check them so i'm going to say if event dot type equals equals pie game dot quit in all capitals this is always the first one you should check and what i'm going to do is i'm going to say run equals false like that and what this is essentially saying is okay if we press that x button at the top right hand corner of the screen then stop running the game and at the very bottom of this while loop i'm going to say pie game dot quit oops so pie game dot quit and what this does is it just exits the pie game window so and whenever we hit this line which will only happen when the while loop stops running do we quit now the next thing i'm going to say is if started continue now the reason i'm putting this here is because once we start the algorithm i don't want the user to be able to press anything other than the quit button so this uh while loop will be running when the algorithm is running right but if the algorithm has started they shouldn't be able to like press anything they shouldn't be able to change the obstacles like that'll mess stuff up if they do that so that's why we're saying if started continue now the next thing to check and this is really some of the only commands we need to do here is if the user pressed down on the mouse so if the user pressed on the mouse we need to potentially draw a barrier we need to do the start position we need to the end position there's a bunch of different things we need to check right because if you see the way that this works uh it's a little bit small now i apologize when i press the first and second time that does the start and end position and then i can do the barriers right and if i right click somewhere i can remove the start position and i can put it back to wherever i want and if i right click on any of this stuff it deletes it so we need to check that and there's a few checks to do here to make sure that like after i right click the start or the end position i can place it kind of wherever i want right so that is what i'm talking about and now you can see that the reason i did if started is so i can't just draw a bunch of barriers like i'm pressing down here and i can't delete the color on these squares it just happens right and actually we'll let this run just because i find it so fascinating to see this thing just go and figure itself out like look at that but hopefully that illustrates to you what we're doing here so now we need to check the mouse position so we're going to say if pygame. dot get underscore position then what we're going to do sorry not get position get pressed get position will be next and then 0 and what this stands for is what mouse button we pressed so essentially we're saying if the pie game mouse was pressed and we pressed on the left mouse button so like your common mouse button you're clicking mouse button then do something otherwise so we're gonna say elif game dot mouse dot get underscore pressed one sorry not one two which is actually the right mouse button i believe then we're going to do something else so if they press the left mouse button do something otherwise if they press the right mouse button do something and if you wanted the middle mouse button you would do it with one right so 0 1 2 left center right if you're thinking about that so that's what this says this is we'll do a comment left and this is right okay so now inside of here if they do that we're going to say position equals pie game dot mouse dot get underscore position so pos like that with a set of brackets this simply gives us the position of the pi game mouse on the screen so what x y coordinate it's at now we're going to say row column equals and guess what we're going to use this helper function that we used that we just made so we're going to say get underscore clicked position we're going to pass the position and then what else do we need the rows and we needed the width like that so there we go so now this is going to give us the row and column that we clicked on so this is what actual spot in our 2d list did we click on so now we can actually access that so we can say spot equals in this case grid and oops i've just butchered that we go grid and we go row call so we can index the row column in the grid and now you know we can do whatever we want with it so the first thing we're going to say is okay if we have not yet placed the start position we're going to need to do that right so we always do start and end position first if the start and end position aren't down when you click you're either you're setting the start or the end position that's just the basic rule if start and end are not there if they're if we haven't pressed them then make them whenever we press next so we're going to say start equals spots that's why i have this start variable up here and then we're going to say start dot make underscore do i not have a make underscore start i thought i did okay well let's go back up to our thing here and let's make make start because i don't think i added that yeah i can't just completely forgot that so define make underscore start i'm gonna go self i'm gonna go self.color equals and i think we were going with orange for start uh yeah i think so so sorry guys add that method make start uh and then we should be good to do this so now we're gonna say start equals make start and then we'll say an l if and we'll say l if not end and we'll do the exact same thing for end we'll say end equals spot and dot make underscore end so hopefully this makes sense we're saying we press the left mouse button and the start or end one is not yet pressed then let's make that the start or make that the end and we'll always start by doing the start and we'll after the start we do the end now otherwise so in another situation where the start was actually defined we've already done it the end we've already defined we've already clicked it if we're clicking and we're not clicking on the start or we're not clicking on the end so l if spot does not equal end and spot does not equal oops does not equal start then whatever spot we clicked on is just some random spot we need to make it a barrier so we'll say spot dot make underscore barrier like that and that's as easy as this left mouse button press is so now let me run this for you so i'm going to call this function down here and let me show you what we've actually done so far so let's run this i'm like confident that i'm probably going to get an error and my thing is lagging so i'll be right back okay so i had a small error here i don't know something crashed something happened but i also just realized that we just got to fill in a pass here just so i can actually test this right now because i haven't i don't have an indented block for this other mouse position and we're probably going to run into a few errors that we have to fix just because i've been coding for a while so we'll go through these together so main is missing two required positional arguments win and width so here let's pass it to it win which i think was in all capitals and then width as well okay so win and width um i don't remember if i made it in all capitals yes i did so win with we're going to pass that to our main function and hopefully now this will work okay uh so we're getting a black screen and the reason we're getting a black screen is guess what because we never called the draw function we never actually called draw which will then draw the grid and draw everything else that we need to do so what we're going to do is right at the top of our while loop we're going to call draw we're going to give it that win we're going to give it the grid we're going to give it the rows which is all capitals and we're going to give it the width so now we'll call draw every loop and this will just keep drawing everything so let's try this and there we go we get a nice solid grid and look i can even go ahead and i can make all this stuff so of course i can't delete anything now because we don't have the right mouse button set but you can see that i can press and i can do it again and let's run this one more time and i can make my start and end position and all is well and all is good so i think um that's about it now what i'm just going to do here is i'm just going to fix this because let's look at this for one second if i press so that's my start position right i can press my end position right on top of that that's no good that means the start and the end are the same and we can't let that happen so we need to handle that case so now before we actually assign the start we need to make sure that spot does not equal end and before we do the end we need to make sure that end does not our i guess spot does not equal start so that we can't override each other so let's just try it now you can see that's the changing code right there and now see it won't actually let me press it on top of each other i was trying to and you just can't actually press the spot on top of each other which is exactly what we wanted and now we can draw our barriers and obstacles and all that fun stuff so now let's do the left mouse button which is a little bit easier so we're going to say position equals and we're actually just going to copy these first three rows kind of counterintuitive to do it but that's fine we'll just copy all of them we don't really need to worry about that too much and we're just going to say spot.reset now so essentially we have position row call and spot which i've already discussed and if you press on this spot with your right mouse button i'm assuming that you just want to reset it to be white so we'll say spot.reset and we'll say if spot equals equal start then start equals end and if spot equals equals end and equals none and i mean we can make this an l if it doesn't really matter it's going to be the same thing anyways just to make sure that we reset oh not start equals n start equals none sorry so we reset the start and end if you press on those ones because those are the two variables that we're storing so now let's run this and see what we get so i can you know right press and i can left press hey my left click is not working for some reason so i'm going to have to see whoa there's a bunch of stuff going wrong okay give me a sec guys i'm going to have a look here looks like my something's happening with this update where something's kind of working but it's not really working properly so i'm just going to have a look at this bug and see what's going wrong so looks like inside of my reset we had two equal sign instead of one so that would make sense why it wasn't actually updating the color properly so that would be the mistake there so let's rerun this because before it just wasn't actually erasing anything and now uh when i right click beautiful it actually is working properly so it looks like we've got kind of the main obstacle stuff almost out of the way here and now the next thing to do is really actually just start writing the algorithm which of course is the toughest part but the visualization tool itself is kind of ready to go and everything's set up and handled so the last thing we're going to do here is we're just going to add a event we're going to say if pygame dot event dot type actually sorry not pi game just if event dot type equals equals pie game dot key down and now what we're just going to say is if event so this is essentially telling us did we press a key on the keyboard down if event dot key equals equals pie game dot k underscore space and started equals false sorry not started equals false and not started then what we're going to do is we're actually going to go ahead and we're going to start running the algorithm so the first thing we need to do in here is we need to now go back to the spot class and we need to update all of the neighbors of the spot class so remember that what i was saying before when we were talking about how this algorithm works we need to actually have neighbors for all of these spots so these spots we need to set this up as a graph so every single node which are all these great squares need to have a neighbor beside them so they need to have something to left something to the right up down and that needs to be handled so what we need to do is make this update neighbors method inside of spot which we'll add into this list here the neighbors list all of the valid squares that could be its neighbor so let's run this and i just want to show you something's crashing let me just add a pass inside of here for right now and let me show you what i mean so like this orange square for example has this this neighbor this neighbor this neighbor this neighbor let me just move that over there these four neighbors are these orange squares neighbors right but right now they're actually not because these are barriers so we can't use a barrier as an edge which technically means right now there's no way for this orange square to connect with this green square because it's completely covered it has no neighbors so the point is that every single one of these white squares we need to determine all of its actual neighbors uh that aren't these barriers right so we can't add these barriers as its neighbors because really like say i do this these circles here all the white squares inside of these circles are now useless we can no longer use them and we need to make sure that we know the neighbors of like this white square and that we don't add this black square in there so we don't traverse through any of the barriers right that's kind of what we have to do right now it's not very it's not super difficult to do but i just want to illustrate to you what this is so let's go into uh the update neighbors and let's write this code so essentially what we're going to do is just check up down left right and see if those are barriers or not and if they're not barriers we'll add them into the uh the neighbors list so let me just go have my reference code here to make sure i don't mess this up because this is a fair amount of code we're going to start by saying self.neighbors equals a blank list and we're going to say if self dot row because we do have this it's one of the attributes is less than self.total rows minus one and not grid self dot row minus one self dot call dot is underscore barrier then what we'll do is we'll say self dot neighbors dot append and we will append this so we'll append grid self.row minus one uh and self.call now i know this seems like what the heck did you just do tim but this is i'm checking if the row that we're at is less than the total rows minus one the reason i'm checking that i'm sorry this should be a plus one not minus one is because i want to add one to the row i'm on right now to go down a row so this is going down right we're moving down a row because we start zero one two three four so on like that so we're moving down so i need to check if i can move down because if i'm on like square 49 i'm on square 50 and i try to go to square 51 and that doesn't exist i'm going to crash my program so that's the check right here and we say and not grid self.row plus one self.call.isbarrier then self.neighbors.append blah blah blah append the next row down that's what i'm doing i'm saying we'll use the same column but we'll add one to the row if we can add that to the neighbor now let's copy this exact same thing and we'll actually copy it four times we'll just update what these values are oops let's just copy that if statement okay so now we're gonna go down up is gonna be the next one it's good to comment these just so sometimes you can read them pretty quickly so down up left right so for up we're just going to change all the signs so this is going to be negative now that's going to be oops this isn't going to be self.total rows this is actually going to be a 0 and we're going to say if self.row is greater than 0 and not self.row plus one self.uh call is barrier then we'll say self.neighbors.pen grid self.row plus one uh and self.call now i realize i must i mess something up here this is a plus one and this is a minus one sorry guys so let me space these out so we can actually read this okay space like that so this one sorry if self.row is greater than zero so if we're not at row zero and grid self.row minus one because we're going up now not down i was mixing that up and this isn't a barrier then what we'll do is say self.neighbors.append the grid of self.row minus one so the one above us at the same column awesome that's all we need now instead of call we're going to say if self and said row we're going to say if self.call is less than self.total rows minus one then if not self.row so grid self.row self.column plus 1 is barrier then what we add is instead of row plus one we're going to do column plus one so now we're moving to the left this is actually going to be to the right and this one's going to be to the left i'm just butchering these so badly this is why i want to leave it to the end but this is going to the right so if we go to the right we're just checking one square to the right so we need to make sure that that's valid uh if it is append it into the neighbors hopefully i'm making enough sense to you guys and then here we're gonna do the same thing as row so if self.column is greater than zero and self.grid and not grid self.row leave it like that self.call minus1 right then minus1 we'll go there actually it will go right there okay so let me just make this clear make sure i didn't mess anything up i think this is good essentially you just have to make sure if you're greater than zero if you're greater than zero then you can subtract one without going into the negative numbers so that's fine and then we if that one that we're checking is not a barrier we can add that to the neighbors list so we don't need to return anything from this that's fine that's enough for updating the neighbors again i just butchered that so horribly but hopefully that is enough that makes sense we're just adding the neighbors to all of those things and here again is the code if you need to copy it down and pause the video or anything like that okay so now that we have that let me just go down here and we're going to call that for all of our spots so we're essentially going to say for row in grid and then for grid in row or not grid and row for spot in row spot dot update neighbors so this whenever we actually press that space key down so this is saying you know if we press the key down if the key is the space bar and we've not yet started the algorithm then for row and grid for all the spots in that row update all of their neighbors so call that method that we just created after we do that what we need to do is just call the algorithm so we're just going to say algorithm like that i'm going to pass in the arguments that we have already just because we're going to be using them inside of there and then we should be good to go so i'm going to say lambda which i'll explain in a second because this is a confusing thing i'm going to say draw and i'm literally just going to actually copy this right here i'm going to say draw like that i'll again explain why i'm passing this in a second i'm going to pass the grid and pass the start position and the end position so i've not yet made this function we're going to code that out in a second but what i'm saying is that okay once we start we're going to call this algorithm function we're going to pass a function that is equal to a function call so i'll explain lambda and then grid start and end so what lambda is is an anonymous function so if i go lambda x like that if i said like x equals lambda and then i say print inside here and i go print hello calling x will call this print function the way this the way this works essentially is like you can imagine that i'm just saying like function like if i go like def func and then it's like that so i say like x is equal to define function print hello if i call x which is just another name for this function then that's calling hello it's hard to describe this but it's just known as an anonymous function because you don't need to give it a name you can just kind of put it on a line and this is great because this means i can pass this draw function as an actual argument to another function and then inside of there i can just call this directly so again it might be a little bit confusing but just imagine that it's i'm just calling this draw function whatever whenever i call whatever is represented by this lambda lambda okay mouthful let's now go and code out the algorithm and then we're going to be pretty close to done so underneath h i'm going to define algorithm i'm gonna say draw and then i figure out what else i had here i'm gonna have to go look at this to make sure we don't butcher this so this is draw grid start and end awesome so essentially what i'm saying is i'm taking a argument here which is draw this is a function that i'm going to call so i'm going to call draw like that and the reason i can do that is because lambda was like you know lambda let's just say print hello if i said like draw equals lambda print hello this is a function that calls that function so if i call this draw function it will do whatever is here which is print hello so in this case draw as a function so i can just call the function and it will do whatever draw is hopefully that's kind of making sense but anyways that's the best i can do okay so next what i'm going to do is i'm just going to find some variables and this is where we're actually going to start coding the algorithm and there's going to be a lot of explanation so i'm going to say count equals 0 open set equals priority queue which we'll talk about in a second remember we imported that way at the beginning at the very top of our program from cue import priority queue let's move this down by the way say open set equals priority queue we're going to say open underscore set dot put now this is put instead of push or append it's just what the api is for priority queue and this just means add to the priority queue remember what the first step of our algorithm was it's to add the start node with its original f score which is going to be just zero right so we add the start node with its f score into the open set that's the first steps that's what i'm doing right now i'm going to say okay open set.put and we're going to put the f score which is zero we're going to put count which is zero and the reason i'm putting count is just to keep track of when we inserted these items into the queue that is so we can break ties if we have and if i spell count correctly here so we can break ties if we have two values that have the same um what do you want to call it or not values if we have two things inside of the queue that have the same f score we can just go based on which was inserted first on which one to consider so we have a tie breaker essentially so zero count and then start that's what i'm putting here okay so this is the actual node itself or the spot this is some number it's going to be zero to start and that's the f score which is zero so open uh set.put we're gonna say came from which is pretty much keeping track of where we came from right so what node did this node come from remember like i had you know node b came from node c node c came from node d and that's how we keep track of the path that's what this dictionary is going to do and that'll be more clear as we go next we're going to have our g score so we're going to make a table here that's going to store all of the gscores so i'm going to say spot float in so essentially we're going to have a key for every spot inside of our gscore it's going to start at float infinity right so this just gives us infinity that's how you do infinity in python we're going to say four row in grid for spot oops in row so this is just a list comprehension this is the same as writing like four row in grid for spot in row uh gscore spot equals float imp uh if we just do like a long drawn out way but since we're going to do this twice i'm just doing it in a list comprehension or a dictionary comprehension and then we're going to originally set the gscore of our start node right so gscore of start is going to be equal to zero because of course the gscore of the start node is just zero now we're going to copy this exact same thing and we're just going to replace g with f because we need the same set up for f and same f score is going to be 0 for our start node and actually sorry the f score of our start node will actually just be the heuristics so it's not actually going to be 0. i miss explaining this is going to be the distance which is going to be the heuristic from h of our start dot get position so get underscore pause and our end dot get underscore pause so sorry this was a mistake on my part the g score and the f score are the g score is set to zero the f score will just be the heuristic because we want to estimate approximately how far away this end node is from the start node and just give that h score already so that'll be the f score for our um our end node the reason we do this is to make sure that we don't when we reach the end node uh we don't automatically assume that it's the best path i hope that kind of makes sense but just imagine that like we start the f score of our start node at infinity so sorry i miss explain this but essentially the reason the f score is just equal to the heuristic is because we do actually want to make an estimate of how far away this start node is from the end node when we begin it's not a huge deal it's not going to be super important but the reason we have that is to make sure that if we say circle all the way around back to the start node we don't take that as the shortest path because it was infinity beforehand we just take whatever we think is going to be the shortest distance which is just the heuristic again it's not huge deal if you understand that or don't understand that but just make this equal to our heuristic which is this h function right here we should be good to go next i'm going to make open underscore set underscore hash equal to a set of start now the reason i'm making a set here is because this priority queue doesn't actually have anything to tell us if a node is in the queue or not and we need to check in some sense if there's something in the queue or not so if we have a value in the queue or if we've removed a value from the queue or whatever it is so we need to have open set hash that is just going to keep track of all the items that are in the priority queue and all the items that aren't in the priority queue so i can remove an item from the priority queue but i can't check if something is in the priority queue where here i can check if anything is in it because this will just be a hash that just stores all the same things that this priority queue stores but just doesn't have the same kind of data structure implementation to give us the smallest item if that makes any sense again this is getting a little bit into some complex data structure stuff but don't worry about it too much hopefully this will make sense as we continue so we're going to say while not open underscore set dot empty so essentially the algorithm runs until the open set is empty or not so if the open set is empty then that means that we've considered every single possible node that we're going to and if we've not found the path yet a path doesn't exist that's what that says and we're going to say just here quickly for event in pygame.event.get now since we have a while loop i need to make a way that people can exit this while loop so if i say i need to just have this event thing here to let them hit that x button if they want to quit so i'll say if event.type equals equals pygame.quit in all capitals then what we'll say is pygame.quit so this again is like we already have this down in the lower section but since this algorithm here takes over and has its own loop inside i need a way to exit this loop just in case you know something goes wrong we can quit or if it's taking too long or whatever it may be we need a way to quit now after we do that we're going to say current equals open set dot and i believe i can just say get and i'm going to index at 2. now the reason i'm indexing at 2 is because our open set is going to store the f score the count and the node now i want just the node so i'm going to start at the very beginning of all of these loops by popping the lowest value f score from my open set now if there's two things that have the same f score we'll look at the count and whatever was inserted first will be what i take so that's what current is saying this is the current node we're looking at so remember same example here if we're starting at the very beginning current will start as the start node because that is the only thing that's in the open set to start so then what we're going to say is open underscore set underscore hash dot remove i think it's remove yeah dot remove current so we're going to take whatever node that we just popped out of the priority queue and we're going to synchronize it with the open set hash by just removing it from that to make sure that we don't have any duplicates or anything out of sync and messing us up next we're going to say if the current is equal to the end so if this node that we just pulled out is the end node we found the shortest path so we need to reconstruct the path and we need to draw that path so for now i'm just going to say pass and we'll deal with this after but this is going to be make path like that and we're just going to return the value true and just say okay we've found a path we're going to exit out of there so i actually don't need the pass but we are going to have to continue this after and and we'll do that later okay so if current equals n boom that's it and now next what we need to do is need to consider all of the neighbors of the current node so we're going to say for neighbor in in this case we're going to say current dot neighbors like that so if the neighbor is in our current dot neighbors right so for all of them we're going to say the temp underscore g underscore score is going to be equal to the g score of whatever the current score is plus 1. now the reason for this is because we can assume that all of the edges are one right so if we want to figure out what the temporary gscore of this neighbor would be assuming we go to this neighbor from whatever current node we're at then we take whatever the distance is this current node the the currently known shortest distance and we add one to it because we're going one more node over which is a neighbor of this node we know it only takes one value so that's totally fine and valid to do so we add one to whatever the current score is for the shortest path to this current node then what we say is we say if temp underscore gscore is less than the gscore of the neighbor so essentially in other words if we found a better way to reach this neighbor than what we had found before update this way update this path store it and make sure we keep track of that that's what we're doing right we're trying to determine the best path to get to every single node and from there we can really easily kind of target ourselves towards the end node and find the optimal path and that's what we're doing so we're saying if the gscore that we're getting by using this neighbor is less than the gscore of what we had on the other neighbor so the actual value then go ahead and change things around update the value say this is a better path so we're going to say first came from so the came from for the neighbor needs to be updated to equal whatever node we're on right now so came from neighbor equals current because it's a neighbor of the current we came from that we're going to say gscore of current is going to be equal to the temp gscore that we just have right there and then we're going to say the fscore like that oops f score is going to be equal to so the f square of current oh sorry what am i saying current this is this should be neighbor my bad guys sorry this this is neighbor i don't know why i was typing current so the g score of neighbor equals the temp g score of course that makes sense the f score of neighbor equals the temp gscore plus the h of in this case it's going to be the neighbor like that dot get underscore position because remember we need the row column position not just the spot itself and not neighbors it's going to be neighbor and then this is going to be end dot get underscore position so let me just assure that i typed that correctly yes i think i did essentially get pause remember is that method we wrote all at the beginning right here that gives us the row and gives us the column so we need to pass that in because the method that does the h if you look right here expects two positions not to spot objects so that's how that works we update the f score and now we say if the neighbor is not in the open set hash so this is why we're using the open set hash so that we can check if the neighbor is in the open set or not so it's not in increment the count because now we're adding something in so if it's not in we add it into the set so count plus equals one and we're going to say open set dot push or is it push or is it put sorry it's put and now we're going to put in this new neighbor right because we're now going to consider this neighbor because it has a better path than what we found before so we're going to put in the f score so we're going to say f score of neighbor needs to go in here we're going to put in whatever the count is we just added 1 to it and then we're going to put in the actual spot object itself which is going to be the neighbor so that goes into the open set and then the open set hash gets the same thing so open set hash dot add neighbor just because we're just going to store the spot in there we don't care about the f score and the count and then we're going to say neighbor dot make underscore closed so this is essentially saying okay we're going to make this current neighbor that we just put here closed so that we know we've already considered this neighbor and that's making me look for or sorry not closed this is going to be open my bad because we just put this into the open set of course it's not closed it's going to be open it's green we put it in the open set and then finally after this what we're going to do is we're going to tab out so outside of the for loop we're going to call draw i'm going to say if current does not equal start then we're going to say current dot make underscore closed like that so what this is going to do is essentially say i mean i just went faster but we've pretty much finished this entire algorithm so i can show you how it works in a second if current is not the start node make it closed so that's saying that if the node that we just considered and we just looked at is not the start node we just make it red and just close it off because we've already considered it and it's not going to be added back into the open set if it is it will be made open and we'll see that right so that's the idea behind this now of course we need to reconstruct the path there's a few small things we need to add but this is pretty much it and at the very end here i'm just going to return none or return false to say hey we did not find a path so that is this entire algorithm so let me go through a quick summary and then we'll actually run this and make sure it works so we have a count we have an open set we start by putting the start node in the open set we have came from this keeps track of where we came from so what nodes came from where so we can find the best path at the end gscore keeps track of again the current shortest distance to get from the start node to this node we initialize them all at infinity to start and then we set the g score of start to be zero f score this keeps track of our predicted distance from this node to the um what do you call it to the end node so going through this path so following this path with this node how long do we think it's going to take or what do we think the distance is going to be to get to the endnote and then we set the initial um so these are start at infinity just like gscore and fscore we start the initial fscore of start to just be the heuristic so whatever our guess is from the start note to the endnote which makes sense because right now it's gonna cost us zero to get from start to start so the only distance we need to go is whatever our heuristic distance is right and then open set hash this is just gonna help us see if something's in the open set and then we have our while loop that says okay while the open set's empty make sure that we're not quitting the game if we are let's quit get out of this current equals open set dot get two so what that does essentially and in fact i can actually just return from this if i wanted to uh let's leave it pie game quit so current equals openset.get2 the open set is a priority queue the priority queue is just an efficient way to get the smallest element every time out of it it has uses a keep sort algorithm i believe to do that actually and you don't have to know what that is but essentially it's just a very efficient way to get the minimum element from this queue so it gives us the minimum element whatever the minimum f score is we get the actual node associated with that or the spot object we remove that from current or from the open set hash sorry remove current from the open set hash we say if we're at the end we found the path we finished boom we're done otherwise consider all the neighbors of the current node to calculate their tentative gscore their temp gscore if that's less than whatever their gscore is in the table then update that because we found a better path and then add them into the open set hash if they're not already in there and that is the very very basics of how this works so now what i'm going to do is go ahead and run this and show you the visualization so i won't be surprised if we made a few minor mistakes and we need to rerun some stuff but let's just go ahead and do this and press space and what is the problem we're getting here so let's see what's happening update neighbors missing one required positional argument grid okay so it makes perfect sense we need to go down here to where we're calling update neighbors and just pass grid into there and hopefully we should be good now so self.spot.updatenavers grid let's run this and see what we get okay and there we go this is actually working and we have the visualization going now of course we don't have the path being reconstructed yet that's the last thing to do but we can see it hit that endnote and boom perfect it found it right and it went and we can see that it didn't consider every single node it actually just went you know pretty much right to the node and had a pretty efficient path to find that so now let's reconstruct the path which is actually going to be really easy to do and then we will be done so now inside of here i'm going to say re construct underscore path i'm going to pass came from and i'm going to pass the current node which is actually just going to be the end so we can just pass end and i'm going to pass draw now draw again is that same function they passed in let's make another function up here and let's say reconstruct underscore path let's take came from and and i was just draw okay now inside of here all we're going to do is we're going to say wow current is in came from so while it's in that list what we're going to do is not current actually yeah let's rename this current so instead of end this is going to be called current so while current is in came from which is that table that stores um you know a came from b b came from c c came from d so on so forth then what we're going to do is we're going to say current equals came from of what is this going to be current and then we're going to say current dot make underscore path and we are going to at the end of here draw okay so i'll explain this really quickly but this is pretty basic we're saying okay the current node starts at the end node we're going to traverse from the end node back to the start node the start node is not in came from it's not in there so that's fine right we don't put anything in came from for the start node so once we get to the start node we're done but essentially current will be equal to whatever we came from from the last node so from the end node what do we come from some node that's current make that part of the path draw it and then keep doing that and then once we get to the point where we're at the node that came from the start node and we hit the start node it will stop and it will stop reconstructing the path so that should be it let's run this and i'm just going to actually say end dot make end here just because if you don't do this essentially what will happen is it's going to draw purple on top of the end node and i'd rather just have us be able to see start end and then the path in between so anyways that'll make sense but let's run this and see if this works now so i'm just going to literally press space you can see boom that's the path that we discovered and there we go now one more thing that we should do is first of all let's run this and see if we can get a more complex example that works a little bit better i want to make a way to like reset this and clear the screen and by the way don't feel bad if yours is running a lot slower than this i'm on a very fast computer right now but let's go to a way to reset this so that we can just run this as many times as we want without having to close the program so this is going to be pretty easy i'm just going to make another command inside of here so unders underneath this if statement and say if event dot type equals equals pi game dot and should actually just be indented one more so not event dot type will say if event dot key equals equals pi game dot k underscore lowercase c then we're gonna clear so what this will do is it just clear the entire screen just make everything white so then we'll be good to go and good to start again so i'm just gonna make sure i'm not messing this up but i think we can just say start equals none end equals none and grid equals make grid and we need to pass what for that rows and wait okay so that should be it for clearing the way this works is we'll just reset start endnote just remake the entire grid which means that everything will just get reset automatically and then we should be good to go um and yeah i think that should literally be all we need to do um yeah so i think that's good i'm just going to add one more thing to this case space thing i don't think i need this started thing actually i haven't even used it so i'm going to say if event dot key equals python.counter space and start and end to make sure hey we have an end and a start node before we do this because if we don't that's going to crash so of course we need that first that's a necessary thing here i should have had before if we have a start and end node then we're good to go and i can remove this if started thing because we're not even going to use that so we can get rid of started okay so now we should be good let's run this and let's see what happens if i press c so c clears everything resets it let's run this and let's press c you can see it resets and then we can go as many times as we want so this is the pathfinding algorithm this video has taken a tremendous amount of time to make this is not an easy thing but a lot of you guys asked for it i think it's really cool and i wanted to make something that was just awesome that you guys could really appreciate you can mess with and i just i love these programs they're so cool they're really what got me into programming when i was a kid so i hope you guys enjoyed if you did make sure you leave a like please subscribe to the channel leave a comment let me know what you thought of the video and of course i will see you guys in another youtube video
