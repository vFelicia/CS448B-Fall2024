With timestamps:

00:00 - hello everybody and welcome to a brand
00:02 - new tutorial series on this channel
00:04 - where i will be showing you how to make
00:06 - a car racing game in python using pygame
00:10 - now pygame is one of my favorite modules
00:12 - in python it's been a while since i've
00:14 - done a tutorial series using it so i
00:16 - kind of came up with this game right
00:17 - here which actually fun fact is one of
00:19 - the first games i ever created using a
00:22 - software called game maker so i kind of
00:24 - recreate it in python and it turns out
00:26 - to actually be pretty complicated to
00:28 - implement it makes a really good
00:30 - tutorial anyways let me explain who this
00:32 - tutorial is for and then i will demo the
00:35 - game to you so this tutorial is kind of
00:37 - designed for intermediate programmers if
00:39 - you are a beginner you can definitely
00:41 - follow along i'll try my best to explain
00:43 - everything as always but this is going
00:45 - to use quite a bit of kind of more
00:46 - advanced python syntax or more
00:48 - intermediate python syntax and so if you
00:50 - haven't seen object oriented programming
00:52 - before it might be a little bit
00:54 - difficult to follow along but again i
00:55 - will try my best to explain with that
00:58 - said this will probably be five videos
01:00 - maybe two and a half hours of content
01:03 - everything you need will be linked in
01:04 - the description in each video all of the
01:06 - assets you see here most of them i
01:08 - actually made myself and of course
01:10 - they're free to download from the
01:11 - description all of the code that i write
01:13 - in each video will be uploaded to github
01:15 - so you can look at the code per video
01:17 - not just the finished code and yeah with
01:20 - that said that's pretty much everything
01:21 - you need to know so let me demo the game
01:23 - for you and then we will start actually
01:25 - writing the code so the idea behind this
01:27 - game is we have two cars one car is kind
01:30 - of the player car so the red car the
01:31 - other one is the computer right so the
01:33 - green car
01:34 - now the objective is to simply beat the
01:36 - green car to the finish line at every
01:39 - single level now you can see right now
01:40 - that the green card is going quite slow
01:42 - but as the levels increase it increases
01:45 - in speed and well it gets progressively
01:47 - more difficult now i always like to
01:49 - leave my games pretty basic and then
01:50 - allow you guys to kind of add on to them
01:52 - so something you could do to make this
01:53 - more challenging is add obstacles you
01:56 - could add like i don't know oil or
01:58 - something on the track so that you would
01:59 - slip if you hit it you can do all kinds
02:02 - of crazy stuff what i'll be showing you
02:04 - in this tutorial will allow you to kind
02:05 - of add that stuff as you continue now
02:08 - you can see here we've moved on to level
02:09 - two notice the car will get
02:11 - progressively faster and then this game
02:13 - goes up to 10 levels the last level has
02:16 - the green car almost as fast as the red
02:18 - car and so if you beat that last level
02:20 - there then you win the game anyways i
02:22 - won't keep playing through this but this
02:24 - is a pretty complicated thing to
02:26 - actually make i know it looks trivial
02:27 - but to allow the car to move in this way
02:30 - to have this car follow a path to have a
02:32 - collision with a track that's kind of
02:34 - not square right not rectangular
02:36 - collision to have the finish line to
02:38 - increment levels to change speeds
02:39 - there's a lot going on here and this is
02:41 - a really good kind of learning
02:42 - experience from this tutorial anyways
02:44 - enough of this long introduction i
02:46 - apologize let's go ahead and get into
02:49 - the code
02:52 - [Music]
02:58 - all right so let's go ahead and get
02:59 - started now we have some setup steps
03:01 - that we need to walk through and then
03:02 - once we do that in this first video i'm
03:05 - going to show you how we can move a car
03:06 - around the screen i know that seems
03:08 - trivial but we're going to implement
03:10 - acceleration velocity braking and
03:12 - slowing down and a bunch of other stuff
03:14 - like actually changing the angle of the
03:16 - car and determining the horizontal and
03:19 - vertical displacement of the car based
03:20 - on its angle so it's actually pretty
03:22 - complicated and that's why this video
03:24 - will be you know the length it is it's
03:25 - probably pretty long although i haven't
03:27 - filmed it yet obviously
03:28 - and anyways before we can do all that we
03:30 - need to set up our environment
03:32 - so i'm here in visual studio code feel
03:34 - free to use whatever editor you want and
03:37 - the first thing we're going to want to
03:38 - do here is download all of the assets
03:40 - for the game so i'll just walk through
03:42 - them kind of one by one because i
03:43 - actually made almost all these assets
03:45 - myself so hopefully you guys are
03:46 - impressed by that but we have a finish
03:48 - line we have this grass which is kind of
03:50 - the background i didn't make this i
03:51 - found this on google images we have a
03:54 - green car i made this i was impressed
03:56 - that i made this with pixlr hopefully
03:58 - you guys like that too we have a gray
04:00 - car we have a bunch of other cars as
04:02 - well i just made a bunch of different
04:03 - colors so you guys could swap the colors
04:04 - if you want but i'm using green and red
04:07 - and then obviously we have the red car
04:09 - and then we have our track border i'll
04:11 - discuss why we need this in a second and
04:13 - then we have our track
04:15 - so notice this track kind of has some
04:16 - white outlines the reason for that is i
04:19 - took this from google images and then
04:20 - removed the background from it in
04:22 - photoshop i'm not very good at doing
04:23 - that so that's why it looks the way it
04:25 - does feel free to use any track that you
04:27 - want but what you will need if you use a
04:29 - different track is you will need the
04:30 - border or kind of like the
04:32 - yeah i guess you'd call it border i
04:33 - guess you could call it the walls or the
04:36 - outline of the track as well you'll see
04:38 - why we need this but this is how we're
04:39 - going to handle collision by using kind
04:42 - of just the edges to determine if our
04:44 - car has actually gone off of the main
04:46 - track and that's how we're going to
04:47 - bounce our car backwards so again you
04:49 - need the main track like this and then
04:51 - you would need the track border you
04:53 - could do it with just the border as well
04:55 - and then you could have some background
04:57 - kind of beneath the border you'll see
04:58 - what i mean in a minute but i'm kind of
05:00 - just explaining why we have these two
05:01 - images here then of course we have the
05:03 - white car again this is just so you guys
05:05 - can have some options when we're using
05:07 - the cars great so download all of those
05:09 - again link in the description it should
05:10 - download a zip folder and then you can
05:12 - extract extract the zip folder sorry by
05:14 - right clicking on it and get all of the
05:16 - images
05:17 - now that we have that what we need to do
05:19 - is install pygame so what you're going
05:21 - to do is go in your terminal or command
05:22 - prompt and type pip
05:24 - install
05:25 - pi game like that now for some reason
05:28 - this doesn't work i have two videos on
05:30 - this channel i'll link them in the
05:31 - description as well they'll walk through
05:32 - all of the possible ways that installing
05:34 - pi game could go wrong and how to fix
05:36 - them so i'll refer you to those two
05:38 - videos there for some reason you cannot
05:40 - install python so watch those and then
05:42 - come back great obviously i already have
05:43 - pygame installed so we are good to go
05:46 - now that we've done that i'm going to
05:47 - make a python file in fact i already
05:48 - have one called main.pi outside of the
05:52 - images directory but inside of the
05:54 - folder where my project is going to be
05:56 - all right so now that we've got all of
05:57 - that set up i'm inside of the main.pi
05:59 - file and we're going to start writing
06:01 - some code now the first thing i'm going
06:02 - to do is just import pygame
06:04 - because we're going to need that a few
06:06 - other imports we'll need as well is
06:07 - going to be import time and then i'm
06:10 - just looking at my cheat sheet here in
06:11 - fact if you notice me looking to the
06:13 - right it's because i have all of the
06:14 - code already written just so that i
06:16 - don't get lost as i'm going through this
06:17 - tutorial we're also going to import math
06:20 - we'll be using a lot of stuff from the
06:21 - math module
06:22 - now that we've done that the first thing
06:24 - i actually want to do is just load in
06:26 - all of my images the reason i'm doing
06:28 - that now is because we actually need
06:30 - some of the images to set up some other
06:31 - things you're going to see so the first
06:33 - thing i'm going to do is load in my
06:34 - grass so in all capitals i'm going to
06:36 - say grass the reason all capitals is
06:38 - because this is a constant this is not
06:40 - going to change so that's the convention
06:42 - i'm going to say
06:44 - pygame.image.load and i'm going to put
06:46 - the path to my image which is going to
06:48 - be images slash and then grass
06:51 - dot png like that so now i have my grass
06:55 - next i'm going to load my track so i'm
06:57 - going to say track is equal to pi
06:59 - game.image.load
07:00 - it's this can be images slash track dot
07:03 - png like that
07:05 - after we do that we will load in our
07:08 - track border so i'm going to say track
07:10 - underscore border like that is equal to
07:12 - pygame.image.load and this will be track
07:14 - hyphen border let's make sure that's the
07:16 - correct name
07:17 - looks like it is okay great
07:19 - and now that we have the track border
07:22 - we can load in the finish line
07:24 - so i'll just say
07:26 - finish is equal to that and then this
07:28 - will be
07:29 - finish dot png and then we can load in
07:31 - our cars
07:33 - so we'll say
07:35 - red car is equal to and then this will
07:37 - be
07:38 - red hyphen car
07:40 - and then we will have our green car
07:43 - let's make sure that's all capitals and
07:45 - then green car
07:47 - like that now of course feel free to
07:49 - swap these cars if you want i don't
07:50 - think i need to explain how to do that
07:52 - but you just change the name inside of
07:53 - here and then the corresponding variable
07:55 - name
07:56 - great so now that we've done that what i
07:58 - want to do is start displaying some of
08:00 - these images on the screen but first i
08:02 - need to actually set up a screen or set
08:04 - up what's known as kind of the display
08:05 - surface so what i'm going to do here is
08:08 - say that my window or my win in all
08:11 - capitals is going to be equal to pie
08:14 - game
08:15 - dot display dot set underscore mode and
08:19 - then the mode that i need to set inside
08:20 - of here is a tuple containing the width
08:23 - and the height of my display now the
08:26 - width and the height of this display i
08:27 - actually want to be equal to the size of
08:30 - my track so whatever the track size is
08:32 - that's how big i want my pi game display
08:35 - to be so what i'm going to do here say
08:37 - width
08:38 - comma height is equal to and then track
08:41 - dot get underscore width
08:43 - and then track
08:45 - dot
08:46 - get
08:47 - underscore height like this so a little
08:49 - trick in python whenever you have a
08:51 - surface which is what this does it loads
08:53 - in an image and renders it as a surface
08:55 - or stores it as a pi game surface you
08:58 - can get the width and the height of that
08:59 - surface by using get width and get
09:01 - height so we're going to get the width
09:02 - and the height of our track and then i'm
09:04 - going to say that i want a display that
09:06 - is of size width height and that is
09:08 - obviously corresponding to the size of
09:10 - the track now that i have set up the
09:12 - window i'm just going to give my window
09:13 - a name so i'm going to say win dot and
09:16 - then this will be set
09:18 - underscore caption like that and i'm
09:20 - just going to say
09:21 - racing game
09:23 - exclamation point like that okay so now
09:25 - that we have our windows set up we
09:27 - should see if we run the code here
09:30 - let's see
09:31 - no such file or directory images
09:34 - grass.png
09:35 - okay that's interesting let's see why
09:38 - that's happening
09:39 - oh it's grass.jpg well that makes sense
09:42 - so let's fix that
09:44 - let's run this now and then we should
09:45 - see a pie game window pops up and then
09:47 - it just immediately goes away
09:49 - because apparently it has no attribute
09:51 - set caption
09:53 - interesting i believe that's because
09:55 - this is actually the correct one
09:57 - pygame.display.set underscore caption my
09:59 - apologies again that's going to happen a
10:00 - lot i'm going to make mistakes in this
10:02 - video
10:03 - let's run this code now though and see
10:05 - what we get and there we go perfect so
10:08 - everything is working as you would
10:09 - expect the reason the window is not
10:10 - staying on the screen is because we
10:12 - haven't made it stay on the screen yet
10:14 - okay so now we have loaded in some of
10:16 - our images the next thing that i want to
10:18 - do is actually show some of them on the
10:20 - screen so i'm going to set up my event
10:21 - loop
10:22 - i'm going to say wow
10:24 - run and i'm going to make a variable
10:26 - here
10:26 - that says run equals true now the event
10:30 - loop in python is kind of a constant
10:32 - loop or in pi game story that is going
10:34 - to be handling all of your collision all
10:36 - of your movement all of your events like
10:38 - the user pressing a key and so the first
10:40 - thing you usually do is you set up this
10:42 - main event loop and that's what keeps
10:44 - the window alive right keeps it running
10:46 - on the screen and then as soon as you
10:48 - quit the window or the game ends then
10:50 - you would destroy the event loop and
10:52 - destroy the game and then the window
10:54 - would disappear
10:55 - hopefully that makes a bit of sense but
10:56 - we're going to say run equals true while
10:58 - run now inside of here i'm going to say
11:00 - the following for event
11:02 - in pygame
11:03 - dot event dot get this is going to give
11:06 - us a list of all of the events and then
11:07 - we can loop through them and the first
11:09 - event that we want to check is if the
11:11 - user has closed the window so if they
11:13 - press the x in the top right hand corner
11:16 - so the way we do that is we say if event
11:18 - dot type
11:20 - is equal
11:22 - to pi game dot quit then we're going to
11:24 - say run
11:25 - is equal to false we're going to break
11:27 - out of this for loop right here and then
11:29 - underneath this while loop i'm going to
11:31 - say
11:32 - pygame.quit now this will just close the
11:35 - window cleanly for us so the idea is
11:38 - if we press the quit button we make run
11:40 - equal false we exit the while loop and
11:41 - then well we would quit the game awesome
11:44 - so now that we have that
11:46 - if i run my code
11:48 - we should see that it says racing game
11:50 - window shows up everything's fine and
11:52 - then if i click x it closes there we go
11:56 - and that is some good progress okay so
11:58 - now that we have that what i want to do
12:00 - is set up a clock now what a clock does
12:02 - is make sure that our window is not
12:04 - going to run faster than a certain frame
12:07 - per second that or then a certain speed
12:09 - is probably what i should say so right
12:11 - now this while loop is going to run as
12:14 - quickly as our processor can handle it
12:15 - so if you have a really quick processor
12:17 - it's going to run faster than if you
12:18 - have a really slow processor but the
12:20 - thing is when i have this game i want it
12:23 - to run at the same speed on every single
12:25 - person's computer right or i want to at
12:28 - least have a maximum speed so one person
12:30 - can't be going like super fast down the
12:31 - track meanwhile on a slower computer
12:33 - they're going really slow just because
12:35 - their processor can't handle it so i'm
12:37 - going to set up a clock and this clock
12:38 - will fix that for us so i'm going to say
12:40 - clock is equal
12:42 - to pi game dot time and then dot clock
12:45 - with a capital c
12:47 - then up here i'm going to say fps
12:50 - standing for frames per second is equal
12:52 - to 60.
12:53 - right at the top of my wall loop i'm
12:55 - going to say clock like this
12:57 - dot tick and i'm going to tick by fps
13:00 - now what this does is make sure that
13:02 - this while loop cannot run faster than
13:04 - 60 frames per second okay so if you
13:07 - change this number then that will change
13:08 - how quickly this while loop can run
13:10 - hopefully that makes sense but if we run
13:12 - the code now we should see that it's
13:14 - just working the exact same we're not
13:16 - really going to see a difference because
13:17 - we're not drawing anything on the screen
13:19 - okay so now that we've done that i want
13:20 - to draw some of these images on the
13:22 - screen and just see the size of them and
13:24 - then we're going to kind of position
13:25 - them and redraw them just to make sure
13:27 - they look good so let's go inside of
13:30 - here and let's start by doing this pie
13:32 - game dot display not clear but dot
13:36 - update now this is a method that you
13:38 - need to run every single time you want
13:40 - what you've drawn on the screen to
13:42 - actually be drawn so what you can kind
13:44 - of do in pi game is you can draw a bunch
13:46 - of stuff and then as soon as you've
13:47 - drawn it onto the screen you update the
13:50 - display and then it will show all of the
13:52 - stuff that you've drawn so in this case
13:54 - i want to start by drawing this grass
13:56 - background and the track over top of it
13:58 - so let's do that we're going to say pie
14:00 - game
14:01 - actually not pie game we're going to say
14:02 - win which is the name of our window dot
14:05 - blit this is what you do when you want
14:06 - to draw an image onto the screen
14:08 - we're going to put the image we want to
14:10 - draw so i want to draw grass and where
14:11 - do i want to draw this at position 0 0.
14:14 - now the coordinate system for pi game is
14:16 - 0 0 is at the top left hand corner i
14:18 - guess top left would be there for you
14:20 - guys and then as you go down the y
14:23 - increases so the bottom of the screen
14:25 - would be the largest y value and as you
14:27 - go to the right the x increases so the
14:29 - furthest right would be the largest x
14:31 - value sorry so yeah the x increases as
14:33 - you go right
14:35 - perfect so let's run this now let's see
14:37 - if grass is showing up
14:38 - and notice grass is showing up now it's
14:40 - not quite large enough we'll make it
14:42 - larger in a minute but for now we can
14:43 - see it on the screen so now that we've
14:45 - done that we want to draw the track so
14:47 - i'm going to say window blit
14:49 - and then track like that and we'll draw
14:52 - the track at 0 0. now notice the order
14:54 - i've drawn this i've done the grass
14:56 - first and then the track second that's
14:58 - so the track will show up over top of
15:00 - the grass if you did in the other order
15:02 - well you would get it in the other way
15:03 - let's run it now
15:05 - and notice now we have our track and
15:07 - that the size of the window is exactly
15:09 - kind of the size of the track here right
15:11 - so now what we need to do is draw the
15:13 - finish line and we also need to increase
15:15 - the size of the grass and i actually
15:16 - want to make the track a little bit
15:18 - smaller because it's taking up a bit too
15:19 - much room on the screen for my liking so
15:22 - let's just draw the finish line now
15:23 - we'll say win
15:25 - dot
15:26 - blit
15:27 - like that and then we'll say
15:30 - finish and we'll just draw this at 0 0
15:32 - as well just so we can see what it looks
15:34 - like and then that's the finish line
15:36 - that might actually be a good size but
15:38 - we might need to make that a bit smaller
15:39 - as well when we change the size of this
15:41 - stuff
15:41 - okay so now that we've done that we need
15:43 - to change the size of some of these
15:45 - images so to do that i want to write a
15:47 - function the reason i want to write a
15:48 - function is just going to make it a lot
15:50 - easier for us to scale our image rather
15:52 - than having to manually write the same
15:53 - thing a bunch of times so i need to go
15:55 - look at my cheat sheet here
15:57 - and we're going to write the following
15:58 - function
15:59 - define scale underscore image
16:02 - this is going to take in an image and a
16:04 - scale factor now the factor is like if i
16:07 - give 2 it's going to scale it by 2x if i
16:09 - give 0.5 it's going to shrink it by a
16:11 - factor of 2 or shrink it or i guess
16:13 - multiply it by a factor of 0.5 right
16:16 - whatever way you want to think of it but
16:17 - that's kind of how it works so now i'm
16:19 - going to say the size this will be the
16:21 - new size is going to be equal to round
16:24 - and then this is going to be image dot
16:26 - get underscore width
16:28 - multiplied by the factor the reason we
16:30 - need to round this is because we need to
16:32 - have integers when we scale the image we
16:34 - cannot have decimal values so we'll do
16:36 - that now let's copy this we're going to
16:39 - go comma and instead of get width now
16:41 - we're going to do get height
16:42 - and again we're going to multiply it by
16:44 - the factor so this will give us a tuple
16:46 - that contains the new width and the new
16:48 - height of our image then what we're
16:50 - going to do is return
16:54 - like this pygame dot trend form
16:59 - dot
16:59 - scale and then we're going to pass the
17:01 - image and we're going to pass the new
17:03 - size that we want this image to be
17:05 - let me make sure that's right looks like
17:07 - it is so that will allow us to scale our
17:10 - image now the thing is i don't really
17:11 - want this function kind of cluttering up
17:13 - my main file so what i'm going to do
17:15 - just to clean things up a little bit
17:17 - here is i'm going to make a new file
17:18 - called utils.pi
17:21 - and inside of utils.pi i'm going to put
17:23 - utility functions that are going to be
17:25 - used from inside of this main file so
17:28 - inside of here i'm just going to import
17:29 - this function and at the top of the
17:32 - program i'm going to say import
17:35 - pi game like that just because we need
17:37 - access to pi game in here to use this pi
17:39 - game function great so now rather than
17:41 - having this function here i'm just going
17:43 - to say from utils import and we will
17:46 - import scale underscore
17:49 - image like that great so now we can use
17:51 - scale image so the first thing i want to
17:53 - do is i want to scale my graph so i want
17:54 - to say scale image i'm going to pass
17:56 - this image to scale and then what do i
17:59 - want to scale it by let me check here
18:01 - and see
18:03 - for now we'll try with 2.5 we might want
18:07 - to change that but that's what we'll go
18:08 - with right now
18:09 - and then for my track i don't really
18:11 - want to shrink this too much but i want
18:13 - it to be a bit smaller so i'm just going
18:15 - to scale it by 0.9
18:17 - okay so now we've scaled the track and
18:19 - the grass while we're at it i'm just
18:21 - going to scale the track border to be
18:22 - the same size
18:24 - as my track the reason for that is i
18:26 - need the border to be the same size
18:28 - otherwise we're going to have come some
18:30 - weird collision errors in the future so
18:32 - let's make this 0.9 and then the finish
18:34 - line we'll leave like that for now okay
18:36 - so let's run this and notice that that
18:39 - looks a little bit better the grass is
18:40 - taking up the full screen track is a bit
18:42 - smaller
18:43 - everything looks good now let's just
18:45 - draw a few cars and then let's scale
18:47 - those so let's go down here and rather
18:49 - than blitting the finish line let's blit
18:51 - a car so let's just go with red
18:53 - underscore car
18:55 - all the cars are the same size so if you
18:56 - scale one you can scale all of them
18:58 - notice the car is a little bit big i'd
19:00 - like that to be a bit smaller because we
19:02 - want to be able to fit two cars on the
19:04 - track kind of parallel or beside each
19:06 - other so let's make the car a bit
19:08 - smaller let's go to red car
19:11 - let's go scale image
19:12 - and that should not be in all capitals
19:14 - let's go scale image like that
19:17 - we're going to scale this to 55 so 0.55
19:21 - and then we'll do the same thing here
19:23 - scale image
19:25 - and 0.55
19:27 - okay now let's run it and let's look at
19:29 - our car and that is a much better size
19:32 - sweet so now we have drawn pretty much
19:34 - what we need to onto the screen however
19:37 - what i would like to do is kind of clean
19:38 - this up a bit we're going to notice
19:40 - we're going to continually be cleaning
19:41 - and refactoring stuff as we go through
19:43 - this i want to take all of the stuff
19:45 - related to drawing and i want to put
19:47 - this in a separate function
19:49 - just to make sure that i know where all
19:52 - of my drawings being done and i'm not
19:53 - drawing you know like 100 things inside
19:55 - of this wallet because that's going to
19:56 - get really messy really quickly so i'm
19:58 - going to make a function up here called
19:59 - draw now the reason i'm not going to put
20:01 - this inside of the utils function is
20:03 - because this is very
20:05 - heavy or very
20:06 - correlated to the game whereas the stuff
20:08 - inside of utils.pi i could use this in
20:10 - any game whereas this draw function is
20:12 - going to be used only in this game right
20:14 - so it kind of makes more sense to be in
20:15 - this file
20:16 - anyways i'm going to take a window that
20:17 - i want to draw stuff on
20:19 - and then i'm going to take images that i
20:20 - want to draw then inside of here i'm
20:22 - going to say 4 and we're going to go
20:24 - with img
20:26 - in images i'm going to say win
20:30 - blit and then i'm going to blit the img
20:33 - and we're actually going to say img
20:34 - comma pause and you'll see why in a
20:36 - second and i'm going to blend it at this
20:38 - position
20:39 - now what i'm going to do is i'm going to
20:40 - say my images are equal to and i'm going
20:43 - to make a list containing images and
20:45 - their positions that i want to draw them
20:46 - on the screen so i'm going to say grass
20:49 - and i want to draw this at 0 0 and then
20:51 - i'm going to say
20:53 - track and i again want to draw this at 0
20:56 - 0 and for now we won't draw the car
20:58 - we're going to draw that a bit
20:59 - differently
21:00 - so now inside of here i need to call
21:02 - this draw function i need to pass in my
21:04 - window which is a capital win and then
21:06 - my images like that
21:07 - so now if we run the code
21:09 - we should get the same thing we got
21:10 - before and we do
21:12 - always work
21:14 - okay so that is all good
21:15 - now
21:16 - we want to draw the car and we want to
21:18 - move the car around the screen and the
21:21 - thing with the car is we need it to be
21:23 - able to change its position we need to
21:24 - be able to rotate the car right so we
21:26 - can go left it can go right because
21:28 - that's how we're going to be able to
21:30 - turn we have to be able to turn around
21:32 - the track and we need to turn the
21:34 - heading of the car so we will continue
21:36 - in one second but i need to quickly
21:38 - thank the sponsor of this video and this
21:39 - series which is algo expert algo expert
21:42 - is the best platform to use when
21:43 - preparing for your software engineering
21:45 - coding interviews they have over 160
21:47 - coding interview questions on the
21:49 - platform and i am one of the instructors
21:51 - on that platform so you can be sure
21:52 - there are great explanations for each of
21:54 - those questions check them out from the
21:56 - link in the description and use the code
21:58 - tech with tim for a discount on the
22:00 - platform so what i'm going to do here
22:01 - set up a class
22:03 - and this class is going to handle all of
22:05 - that stuff for our car so i'm just going
22:07 - to say class and i'm actually going to
22:09 - make in what's known as an abstract
22:11 - class i'm going to say abstract car like
22:13 - this now let's see why we need this in a
22:15 - minute but the idea is we're going to
22:16 - have both a player car and a computer
22:19 - car so there's going to be a lot of
22:20 - stuff that's common to both of these
22:22 - cars so we're going to put all of the
22:24 - common stuff in an abstract class this
22:26 - is a class that's not meant to be
22:28 - instantiated but it's meant to act as
22:30 - the base class for the other two classes
22:33 - if you're not familiar with inheritance
22:34 - don't worry about it too much just
22:36 - understand that all of the stuff i put
22:37 - inside of here is going to be used by
22:39 - both my player car and my computer car
22:42 - and that's the point of this so inside
22:44 - of abstract car
22:46 - i need to go and look at my code here to
22:47 - remember what i put i'm going to define
22:50 - an init now i'm going to say define a
22:52 - knit like this and inside of here we're
22:54 - going to take self
22:56 - we're going to take a x and a y
22:59 - um actually no we don't want an x y
23:01 - we're going to go with max velocity as
23:03 - our first parameter and as our second
23:05 - parameter we're going to go with the
23:06 - rotation underscore velocity so the
23:09 - reason i want both of these is because i
23:11 - want to know the maximum speed my car
23:13 - can go so the maximum velocity and i
23:15 - also want to know how quickly my car can
23:17 - rotate so it's rotation velocity and
23:19 - then inside of here i'm going to say
23:20 - self dot max underscore val is equal to
23:23 - max underscore val i'm going to say
23:24 - self.vel equals zero the reason why the
23:27 - starting velocity is zero is because
23:29 - your car's not moving when it starts it
23:31 - has a velocity of zero and i'm going to
23:33 - say self dot rotation velocity is equal
23:35 - to rotation val i'm going to say
23:37 - self.angle is equal to zero and the
23:40 - point of this is that our car will start
23:41 - at an angle of zero and then when we
23:43 - change the angle that will change the
23:45 - way that the car is rotating
23:47 - okay so now that we have that the first
23:49 - thing i want to handle is just rotating
23:50 - the car so i'm going to go inside of
23:53 - here and i'm going to say define
23:55 - rotate like that i'm going to take a
23:58 - self a left is equal to false
24:01 - and a right is equal to false now you're
24:03 - going to pass left equals true if you
24:05 - want to rotate to the left and right
24:06 - equals true if you want to rotate to the
24:08 - right now inside of here all i need to
24:10 - do is say if left i'm going to say self
24:13 - dot angle and then this is going to be
24:15 - plus equal and then self dot rotation
24:18 - velocity like that and then if we are
24:20 - moving to the right it's going to be the
24:22 - opposite so we're going to say left
24:23 - right
24:25 - then self
24:26 - dot angle
24:27 - minus equals self dot rotation val and
24:31 - now that i'm thinking about it
24:32 - when i'm going to the right
24:34 - my angle is increasing
24:36 - when i'm going to the left my angle is
24:37 - decreasing so i actually think it might
24:40 - need to be the other way around um or
24:42 - maybe i'm crazy here you know we'll
24:43 - leave it like this for now and if for
24:45 - some reason we're rotating in the
24:46 - inverse direction then we'll change this
24:48 - i think this is right i'm just confusing
24:50 - myself okay so now we have rotate i'm
24:53 - just looking at anything else we might
24:54 - need here
24:55 - for now that actually looks good so what
24:58 - we can do is call the rotate method and
24:59 - then depending on if we're going left or
25:01 - right we'll rotate to the left or right
25:02 - the way we rotate is by changing the
25:04 - angle
25:05 - however we need to actually rotate the
25:08 - car right we can change the angle in
25:09 - this class but that's not going to
25:10 - change the position of the car image so
25:14 - what we need to do is find a way to
25:15 - actually draw the car image rotated so
25:18 - we need to know how to rotate the image
25:19 - in pygame now this is a little bit
25:21 - complicated but i'm going to go inside
25:22 - of utils.pi and i'm going to write a
25:24 - function that can take an image and
25:26 - return to a rotated image based on an
25:29 - angle so let's do that
25:31 - we're going to say define
25:34 - blit
25:34 - underscore rotate underscore center
25:37 - and what this is going to take is a
25:39 - surface this is where we want to draw
25:41 - the uh
25:42 - actually let's call this wind this is
25:44 - where we want to draw the rotated image
25:45 - then we're going to say the image we're
25:47 - going to say the top
25:49 - underscore left and we're going to say
25:51 - the angle okay so i'm just going to
25:53 - write this function and i'll explain a
25:55 - little bit about what's going on after
25:56 - but i will note that rotating an image
25:58 - in pi game is not trivial if you're
26:00 - going to be rotating an image you can
26:02 - just normally rotate it but if you do
26:04 - that you're going to get all kinds of
26:06 - distortions and the reason for that is
26:08 - the rectangle that contains the image so
26:10 - i should say every single image in pi
26:12 - game is really a rectangle and then the
26:14 - actual image is inside of that rectangle
26:17 - so even if it doesn't look like a
26:18 - rectangle there is a rectangle that's
26:20 - containing the image so when you rotate
26:22 - the image you're also rotating the
26:24 - rectangle and based on the position that
26:27 - you're rotating the rectangle around you
26:29 - can get really kind of weird like you
26:31 - know morphing and distortions occurring
26:33 - with the image so that's why we need
26:34 - whatever we're doing here
26:36 - so i'm going to say rotated image is
26:38 - equal to pi game
26:39 - and i believe this is dot transform it
26:42 - is dot transform dot rotate we're going
26:45 - to pass the image and the angle that we
26:47 - want to rotate
26:48 - now what this will do is rotate the
26:50 - image around the top left hand corner
26:52 - now that's no good we don't want to
26:54 - rotate the image around the top left
26:55 - hand corner because that's going to lead
26:57 - to us kind of having like a circle
26:58 - around that
27:00 - stationary point instead we want to
27:02 - rotate around the center of the image so
27:05 - the way we're going to do that
27:07 - is we're going to say new rectangle is
27:09 - equal to rotated image like this and
27:12 - this is going to be dot get underscore
27:13 - rect
27:14 - and we're going to say that the center
27:16 - of this rect is equal to image dot and
27:19 - then get underscore rect like this and
27:23 - we're going to say that the top left so
27:25 - top left like that is equal to the top
27:28 - underscore left and then inside of here
27:31 - we're going to say dot center okay so
27:33 - what's happening here is pretty
27:34 - complicated but i will try my best to
27:36 - briefly explain it i have to admit i did
27:38 - take this code from stack overflow i
27:40 - didn't come up with this on my own
27:42 - anyways point being we rotate the
27:44 - original image when we rotate this image
27:46 - i'll show you in a second we get all
27:47 - kinds of weird distortions and the
27:49 - actual x and y of the image is going to
27:51 - change based on how it's rotating around
27:53 - the top left hand corner so then we have
27:56 - our new rectangle so we say the new
27:57 - rectangle is equal to the rotated
27:59 - image.getrectangle
28:01 - the point of this is we want to remove
28:02 - the offset so we want to make it so that
28:04 - we rotate the image without changing the
28:07 - x and y position of the image on the
28:09 - screen that's what this whole line is
28:10 - trying to do for us so we're saying
28:12 - let's get a rectangle from the new rect
28:14 - but let's make its center equal to the
28:18 - image the original image its rectangle
28:20 - at the top left hand corner position
28:23 - then whatever the center of that is so
28:25 - we're getting the original image we're
28:26 - saying the top left hand corner of that
28:29 - original image is equal to whatever its
28:31 - x and y position is because the image
28:33 - doesn't know its x and y position so we
28:35 - need to set the top left hand corner
28:37 - explicitly to be equal to that then
28:39 - we're saying let's get the center of
28:41 - that and wherever that center is the new
28:43 - image needs to still be on that center
28:46 - so that way we're only rotating from the
28:48 - center of the image not from the top
28:50 - left but we had to originally rotate
28:52 - from the top left because that's the
28:53 - only way to rotate an image in pi game
28:55 - hopefully that makes a little bit of
28:56 - sense and then what we're going to do is
28:59 - say this we're going to say win
29:01 - dot blit and we're going to blit the
29:03 - rotated image and we're going to do this
29:06 - at the new rect.top left so the whole
29:09 - idea of this new rectangle is to find
29:10 - the correct x and y position of the new
29:13 - rectangle such that it's going to be in
29:15 - the same position as it was before but
29:17 - now it's rotated
29:18 - all right a lot of complicated code
29:20 - there but
29:21 - there you go that will blit it and
29:23 - rotate it in the center for us
29:25 - so let's go to main.pi now and let's
29:27 - define a method inside of abstractcar
29:29 - that can draw the car for us
29:31 - we're going to say define draw and then
29:33 - we're going to take in self and we're
29:34 - going to take in a window all we're
29:36 - going to do is the following we're going
29:38 - to say first we need to import this
29:41 - i believe this was blit underscore
29:43 - rotate center yes it was so we're just
29:45 - going to say inside of here blit
29:48 - underscore rotate center and then we're
29:50 - going to pass
29:52 - self dot img actually we're going to
29:55 - pass wind sorry and self.img which we've
29:58 - yet to define which we'll do now
30:00 - so we're going to go to abstract car
30:02 - we're going to say self
30:03 - dot img actually not up here what am i
30:05 - doing
30:06 - sorry we're going to do inside of here
30:08 - we're going to say self.img is equal to
30:11 - and then here i'm going to say img is
30:13 - equal to
30:14 - and we are just going to reference one
30:16 - of the images that we want for this car
30:18 - so in this case
30:19 - i want the red underscore car i'm going
30:21 - to say self.img is equal to self.img
30:25 - i understand this a little bit weird
30:27 - what we're doing here is saying the
30:28 - following we're going to store inside of
30:30 - the class the image that should be used
30:31 - for this class so in this case i want it
30:33 - to be a red car then i say the
30:35 - self.image so the image specific to this
30:38 - instance is equal to self.img so
30:41 - whatever the image is here and then
30:42 - inside of here we then reference that
30:44 - image so that we can rotate it and we'll
30:46 - blend it in the center okay that's all
30:48 - great however i need to first make a way
30:51 - to actually rotate my car before we can
30:53 - see if this is working so let's let's
30:55 - actually just draw the car first let's
30:57 - make a car i'm going to say car
31:00 - is equal to and first we should create a
31:04 - concrete instance of this class so i'm
31:06 - going to say class i'm going to go with
31:08 - player car like that now inside of here
31:11 - all i'm going to do is just copy this
31:14 - i'm going to remove it from abstract car
31:15 - because now we have this class
31:17 - and that's actually all i need inside of
31:19 - player car but i need to make sure i
31:21 - inherit from abstract car so let me just
31:25 - explain this quickly in case this is a
31:26 - bit confusing we have the abstract car
31:28 - class this defines a bunch of
31:30 - functionality when we put it inside of
31:32 - the brackets like this we're saying
31:33 - we're going to use everything from
31:34 - inside of here so imagine all of this is
31:36 - just copy and pasted right inside of
31:38 - player car the only thing we're doing
31:39 - differently here is we're defining image
31:41 - inside of here and then it will be used
31:44 - inside of the initialization when we
31:46 - instantiate this car class
31:49 - okay that was a lot of big words but
31:50 - let's continue so i'm going to go here
31:52 - and say car
31:54 - actually with playerunderscore car is
31:56 - equal to player car like that now we
31:59 - need to pass to this a maximum velocity
32:01 - and a rotation velocity so for now i'm
32:03 - going to go with 4 4
32:05 - feel free to change that to make it
32:06 - slower or faster obviously the higher
32:08 - number the faster it will go and now
32:10 - let's just draw the car so inside of
32:12 - draw i'm now going to pass my player car
32:15 - so that means we need to now take
32:17 - player underscore car and now we're
32:19 - going to say player
32:21 - underscore car
32:22 - dot draw and then inside of here now i'm
32:24 - going to take my pie game.display.update
32:27 - i'm just going to put this right inside
32:28 - of the draw function
32:29 - so that everything related to drawing is
32:31 - contained in one place
32:33 - okay so that should draw our car let's
32:35 - see if this is working and required one
32:38 - uh required missing one required
32:40 - position argument win
32:42 - okay
32:43 - playercard.draw that would be right here
32:46 - so we just need to make sure we pass our
32:47 - window to the draw method
32:49 - so let's run this now
32:51 - and we got an error blit rotate center
32:53 - missing two required positional
32:54 - arguments top left and angle of course i
32:57 - forgot those let's fix that
32:59 - so we need to pass the top left hand
33:01 - position now the top left hand position
33:03 - is actually going to be equal to the x
33:05 - and the y of the car which we haven't
33:07 - defined yet so we're going to do that
33:08 - now we're going to say self.x
33:10 - self.y is equal to self.start underscore
33:14 - position
33:15 - pause like that sorry and then inside of
33:18 - here we're going to say start underscore
33:21 - pause is equal to and then we're going
33:23 - to define what the starting position
33:24 - should be so i'm just going to say
33:26 - actually let me just go look at my other
33:27 - code and see where i started it before i
33:29 - was starting it at 180.
33:32 - uh was that right
33:34 - let's see 180 and 200 okay
33:37 - so go 180
33:39 - and 200. okay so now our self and x
33:42 - self.x and self.y is equal to the
33:44 - starting position which we've defined
33:46 - here
33:47 - and inside of here we now need to pass
33:49 - that so we're going to say
33:50 - self
33:51 - dot x
33:52 - self dot y and then we want to pass the
33:55 - angle and the angle is just going to be
33:58 - self
33:59 - dot angle like that
34:00 - okay
34:01 - let's run this now
34:04 - and let's see what we get okay so there
34:06 - we go our car is now drawn here
34:08 - now let's just see if changing the angle
34:10 - actually does anything so let's go
34:13 - and make the angle
34:14 - 90.
34:16 - let's see where we go now
34:17 - notice we are facing left perfect that's
34:20 - what we would expect okay now let's make
34:22 - the angle 180
34:24 - we should be upside down now and there
34:26 - we go so we are getting the car in the
34:28 - correct position
34:30 - sweet so let's make that back to zero
34:32 - and now let's make it so we can change
34:33 - the angle based on pressing a key
34:36 - so we're going to go and i'm going to
34:38 - write the following inside of my main
34:39 - event loop remember anything in the
34:41 - event loop is kind of handling events
34:43 - handling collision handling all of those
34:45 - types of things so this is where we
34:47 - would put you know key presses and
34:48 - moving the car so i'm going to say keys
34:50 - is equal to pi game dot key dot get
34:54 - underscore pressed like that and then
34:56 - what i want to do is check if we pressed
34:58 - a specific key so i'm going to say if
35:00 - keys and then i'm going to go highgame.k
35:04 - notice that's a capital underscore and
35:06 - then a so i want to use wasd to move my
35:08 - car so this would be left if i'm
35:10 - pressing on the a key so if i'm doing
35:12 - that then i want to say
35:14 - player underscore car dot rotate left
35:18 - is equal to true
35:20 - okay let's copy this
35:21 - and then let's go here and say if
35:24 - keys pi game k underscore d so this
35:26 - would be right then i want to say right
35:30 - is equal to true
35:31 - okay so that should now allow us to
35:33 - actually rotate our car left and right
35:35 - by clicking on a and d if you're
35:36 - wondering how you find other keys you
35:38 - can look them up there's a bunch of i
35:40 - guess these are called constants in pi
35:42 - game but you also can just do k
35:44 - underscore and then whatever the
35:45 - lowercase letter is of the key that you
35:46 - want if you want like a spacebar or
35:48 - something then you would go all capitals
35:50 - and you would go space same thing with
35:51 - like shift or enter or any of those keys
35:54 - if it's not just a standard character
35:55 - then it's usually in all capitals okay
35:58 - let's run this though and let's see if
35:59 - it works
36:01 - and now notice if i go left and right i
36:03 - can rotate my car and the speed at which
36:05 - i'm rotating my car is defined by that
36:07 - rotation velocity so you guys can mess
36:09 - around with that but if you change the
36:10 - rotation velocity you'll notice you're
36:12 - rotating faster or slower okay that's
36:15 - great so we can now rotate the car off
36:17 - to a good start that's actually a pretty
36:18 - difficult thing to do so congratulate
36:20 - yourselves if you made it through that
36:22 - now let's see how we can move the car
36:24 - forward so we have our self.velocity
36:28 - we have the maximum velocity we have the
36:29 - rotation velocity we have the angle the
36:32 - next thing we need is the acceleration
36:33 - because cars don't just instantly reach
36:35 - their top speed they take a few seconds
36:38 - to get up to speed when you slam on the
36:39 - gas you are accelerating you're adding
36:42 - more force to the tires you're going
36:44 - faster and then eventually you re reach
36:46 - kind of like a terminal velocity which
36:47 - is what we're going to get to here so
36:49 - i'm going to say self dot acceleration
36:52 - did i spell that correctly looks like i
36:53 - did is equal to 0.1 so this means every
36:57 - time that we are pressing down on i
36:59 - guess it's going to be the w key to go
37:01 - forward we're going to increase the
37:02 - velocity of our car by 0.1 let's call it
37:05 - pixels per second that's maybe the unit
37:07 - that we're going at if you want to
37:08 - accelerate slower then make this 0.05
37:11 - right or if you want to go faster make
37:13 - it something like 0.2
37:15 - anyways we have that
37:16 - now i want to define a method and i want
37:18 - to call this move
37:21 - underscore forward okay so define move
37:23 - forward and inside of here i'm going to
37:25 - take self now all this is going to do is
37:27 - it's going to increase the velocity of
37:30 - my car based on the acceleration and if
37:32 - i'm already at the maximum velocity it
37:34 - just won't do anything but it will move
37:36 - me forward so inside of here i'm going
37:37 - to say self.vel is equal to i guess this
37:41 - is going to be
37:42 - the
37:43 - minimum uh yeah the minimum of self.bell
37:47 - plus
37:48 - self.acceleration and self.max
37:50 - underscore velocity
37:52 - so what this is doing is saying okay
37:53 - well if self.vel is already at the
37:55 - maximum and we add self.acceleration we
37:58 - don't want to go faster than the maximum
37:59 - so we put self. max val here so if this
38:02 - is greater than this we just default to
38:04 - the maximum velocity if it's not though
38:06 - then we will increase the speed of the
38:08 - car by the acceleration remember the
38:11 - velocity starts at zero okay
38:13 - so we'll increase our velocity now
38:15 - that's great but we actually want to
38:16 - move the car forward so to do that i'm
38:18 - going to make a new method called move
38:20 - i'm going to say define move like this
38:22 - and inside of here after i increase the
38:24 - velocity i'm going to say self.move
38:27 - now the thing is inside of move
38:29 - i need to actually calculate what
38:32 - direction i'm going to move my car
38:34 - because if i'm angled to the right or
38:35 - i'm angle to the left then i need to
38:36 - move in that appropriate direction i
38:38 - can't just go up or go right or go left
38:40 - so i'm going to start by just showing
38:41 - you how we move in one direction so i
38:43 - guess one plane or one dimension
38:46 - and then i will show you how we can move
38:48 - in multiple dimensions so move x and y
38:50 - based on the direction of our car that's
38:52 - going to involve a little bit of
38:53 - trigonometry
38:55 - anyways inside of here i am going to say
38:57 - self.x plus equals self.velocity so
39:01 - we're just going to move to the right
39:03 - based on whatever our velocity is that's
39:05 - all we're going to do to start right now
39:07 - then we'll get more complex
39:09 - okay so now that we've done that we want
39:11 - to implement another key press to move
39:13 - the car forward so i'm going to go here
39:15 - and say if keys pie game dot key
39:17 - underscored w
39:18 - then player card dot
39:21 - move
39:22 - underscore forward like that so now as
39:24 - we press down the w key we should
39:26 - increase speed as soon as we get to the
39:28 - top speed we'll stay at that speed and
39:29 - we'll move forward now remember we're
39:32 - not decreasing the velocity here so as
39:34 - soon as we hit the maximum speed we'll
39:36 - stay at that maximum speed even if we
39:38 - let go of the w key we'll keep going at
39:40 - the same speed i'll show you how we fix
39:41 - that in a second
39:43 - but just wanted to note that as we got
39:44 - in here
39:45 - okay so i've loaded now notice when i
39:47 - press w i move over to the right like
39:49 - that now i'm going to stop as soon as i
39:51 - let go of the key but when i press the
39:54 - key again i'll be moving at the maximum
39:55 - speed
39:56 - so that's it that's how you move one
39:57 - direction right we just incremented the
39:59 - x of the car and that moved our car over
40:03 - okay that's great but we ideally would
40:06 - like to be able to move in two
40:08 - dimensions
40:09 - so this is where i need to pull out
40:11 - the paint program and start showing you
40:14 - some trigonometry okay so i'm here in
40:16 - paint and i'm gonna start describing the
40:18 - trigonometry that we're gonna use to
40:19 - actually move in the direction that
40:21 - we're facing this is not trivial this is
40:23 - why i'm in paint now please go easy on
40:25 - me i am using my mouse so this is going
40:27 - to be really rough but it will give you
40:29 - kind of you know what you need it would
40:31 - give you the basic visualization of this
40:33 - so the idea is we have some car let's
40:36 - say this is our car now if he's just
40:38 - moving this way all we have to do is
40:40 - move the y direction right if he's
40:41 - facing completely up then we can just
40:43 - move that direction if he's facing
40:45 - completely to the right or completely to
40:46 - the left any of these kind of polar
40:48 - coordinates here then we can just go in
40:51 - those directions right it's very easy we
40:53 - can just decrement the x increment the x
40:55 - decrement the y increment the y however
40:57 - what happens if we're moving on an angle
41:00 - like this
41:01 - well it is not so simple now to actually
41:04 - figure out how much we need to move this
41:06 - guy by because we can't just move by the
41:09 - x and we can't just move by the y we
41:10 - need to move by both of them we need to
41:12 - go some amount up right
41:15 - and some amount
41:16 - to the right now first of all
41:19 - what are those amounts
41:21 - well if you said the amount is equal to
41:23 - whatever the velocity of the car is
41:24 - that's incorrect the reason for that is
41:27 - if my car has the heading like this like
41:29 - it's pointing this direction then the
41:31 - velocity that we have is in that
41:34 - direction right so let's say my velocity
41:36 - is 4.
41:37 - well if that's the case then this is 4.
41:40 - that does not mean that my x is 4 and my
41:42 - y is 4 in fact i need to use this total
41:44 - velocity to determine how much x and how
41:47 - much y i need to go by so that my total
41:50 - velocity accumulates 4 because when i'm
41:52 - moving in two directions i'm moving well
41:55 - two ways and so i need to sum the
41:57 - velocities but it's not it's not as easy
41:59 - as just adding them together to
42:00 - determine what the total velocity is
42:02 - going to be now in this way we're going
42:04 - to go in the opposite direction we're
42:05 - going to say the following we're going
42:07 - to say okay well this is like a right
42:09 - triangle right we want to go some
42:11 - direction
42:13 - x
42:14 - some direction y so let's say x
42:17 - and y like that and then this is our
42:19 - total velocity right here now it turns
42:22 - out that we know this angle and if we
42:24 - know this angle
42:25 - we can actually figure out what y and
42:27 - what x are
42:28 - by using trigonometry so there's a few
42:30 - very popular equations the way i
42:32 - remember them is the following
42:33 - we have so
42:35 - which is soh
42:36 - and then we have
42:38 - uh cap
42:40 - c-a-h like this so cat and then we have
42:43 - toa as well
42:44 - t-o-a
42:46 - now
42:47 - o stands for opposite now this is
42:49 - relative to the angle that you're
42:50 - talking about so if i'm talking about
42:52 - this angle right here the opposite side
42:55 - is y so
42:56 - oh those are all sides okay that's side
42:59 - lengths is what i'm talking about and s
43:01 - stands for sine c stands for cosine and
43:03 - t stands for tangent anyways
43:06 - i have my angle so the opposite side is
43:08 - this because that's kind of what the
43:09 - angle is like facing it's what it's
43:11 - looking at and the adjacent side is this
43:13 - it's x because that's what's beside the
43:15 - angle that's the way you can think of it
43:16 - so if i want to solve for y here keep in
43:18 - mind i know my angle and i know my
43:21 - velocity then what i need to do is the
43:23 - following i need to set up my equation
43:24 - so i'm going to say that the sine
43:27 - of theta
43:29 - is equal to
43:31 - my opposite
43:33 - over my hypotenuse now we know the angle
43:36 - and we know the hypotenuse so h is
43:39 - really v which is my velocity now let's
43:41 - just plug in 4 because we know the
43:42 - velocity is going to be 4. we'll say the
43:44 - maximum velocity is 4 right so now we're
43:46 - solving for o and o is really
43:50 - equal to y right because that's the
43:52 - opposite side and so what we do
43:55 - is we say that the sine of theta which
43:57 - we can calculate we just take the sine
43:58 - of the angle multiplied by 4 because we
44:01 - need to take the division and multiply
44:03 - it on this side is equal to y so the
44:05 - sine of theta multiplied by our velocity
44:08 - gives us our displacement in y and then
44:11 - if we go to cosine here it's just going
44:13 - to be the other way around we're just
44:15 - going to take the cosine and we're going
44:17 - to multiply that by our velocity and
44:19 - that is going to give us how much we
44:21 - have for displacement in x
44:23 - so just basic trigonometry but i wanted
44:25 - to walk you through that all right so
44:27 - hopefully that is a decent enough
44:28 - explanation what we actually do in the
44:30 - code might differ a tiny bit just
44:31 - because of a few factors but this is the
44:33 - general idea of how we can solve kind of
44:35 - two components based on one velocity and
44:37 - an angle we're calculating the x and the
44:39 - y component that's what they're known as
44:41 - because this is we can kind of call this
44:42 - a vector right like this line right here
44:45 - if you know anything about physics you
44:46 - would call this a vector because we have
44:48 - a angle so we have a direction and we
44:49 - have a velocity or a magnitude and then
44:51 - we want to split it into its two
44:53 - components x and y
44:54 - okay so let's get rid of that and let's
44:56 - implement this so let's go to our move
44:58 - method and now rather than moving just
44:59 - by the velocity we're going to do that
45:01 - kind of fancy equation that we just did
45:03 - so the first thing i need to do is i
45:04 - need to convert my angle into radians
45:06 - this is because we use radians in most
45:08 - computer math radians is just kind of a
45:10 - special way of calculating angles in
45:13 - case you're unfamiliar 360 is equal to 2
45:15 - pi in radians and 180 is equal to pi
45:20 - okay you don't really need to know that
45:21 - but just figured i'd let you know so
45:23 - we're just going to say math.radians and
45:24 - then self.angle like that
45:27 - notice our angle is in degrees because
45:29 - that's how we want to rotate it but then
45:31 - when we actually are looking for the
45:32 - components we need it in radians
45:34 - now let's calculate the vertical
45:36 - displacement or the vertical velocity so
45:38 - we're going to say vertical is equal to
45:40 - and then this is going to be math dot
45:42 - and i actually think this is going to be
45:43 - cosine for this math.cosine of radians
45:46 - multiplied by self dot
45:49 - velocity and then we are going to say
45:51 - that the horizontal is equal to
45:54 - math.sine
45:57 - of radians multiplied by self.bell
46:00 - then i'm going to say self.y
46:03 - minus equals vertical
46:05 - and self.x minus equals horizontal now
46:09 - you can switch this to the plus side and
46:11 - watch what happens but the reason we we
46:13 - need minus is because these are actually
46:15 - going to return to us in a lot of
46:17 - instances negative values and based on
46:19 - the way that we are
46:21 - angling our car and just kind of some
46:23 - other things we've done that i don't
46:24 - really want to get into too much we need
46:26 - to subtract rather than adding now if
46:28 - we're subtracting that means if this
46:29 - value is positive we're going to the
46:31 - left right and if we are uh and sorry
46:34 - and we're going up so going to the left
46:36 - and up
46:37 - which is the way that our angle is
46:38 - directing so that makes sense and then
46:41 - if this value is negative that means
46:42 - that we're going to be going to the
46:43 - right and we're going to be going down i
46:45 - mean respective to x and y
46:48 - anyways let's just run our code here and
46:51 - see if this works
46:52 - and so let's do this and now notice i
46:55 - can move in whatever direction my car is
46:57 - facing
46:58 - there you go so we are now moving our
47:00 - car which i'm going to call a success
47:02 - now the only thing we need to do here is
47:05 - we need to make it so our car slows down
47:07 - because as you saw let me actually run
47:08 - this again my car just instantly stops
47:11 - right if i let go of the key it just
47:12 - instantly stops
47:13 - that's not realistic our car is going to
47:15 - have momentum it's going to be moving
47:17 - and it's going to take some friction to
47:18 - slow the car down so we need some way to
47:21 - actually slow the car down when we're
47:22 - not pressing on the key which is what
47:24 - we're going to do now so we're going to
47:25 - implement a method here on our car
47:27 - we're going to call this reduce
47:29 - underscore speed and we're just going to
47:31 - take in self now what we're going to do
47:33 - is reduce our speed by half of our
47:36 - acceleration
47:37 - that is because we can accelerate faster
47:39 - than we can slow down
47:41 - at least that's the logic that i'm going
47:42 - to use i'm not sure if that actually
47:44 - applies in the real world but that's
47:45 - kind of what we're going to do here also
47:47 - just so that we don't slow down super
47:48 - super quick because we can accelerate
47:50 - really quick anyways you'll see how this
47:52 - works as i get into this method now i
47:53 - just need to look at where i have this
47:55 - in my other code so that i don't mess
47:58 - this up too bad
47:59 - okay so we have reduce speed what we're
48:02 - going to do inside of here is say
48:03 - self.bell
48:05 - is equal to the maximum of self
48:08 - dot vel minus self dot acceleration
48:12 - over two and then this is going to be
48:15 - zero now the reason we have this is
48:17 - because if this value for some reason is
48:19 - negative we don't want to be moving
48:21 - backwards we just want to stop and so
48:23 - that's why we have the zero right here
48:24 - so we change the velocity and then since
48:26 - we have this move method already set up
48:28 - we can just say
48:30 - self.move
48:32 - so now when we reduce the speed all
48:34 - that's happening is we're reducing the
48:35 - velocity by half of the acceleration and
48:38 - then we're just going to move and since
48:39 - this is set up it'll just work it's just
48:41 - going to move us slower in whatever
48:42 - direction we're facing and while we're
48:44 - slowing down if we're not on the gas we
48:46 - can still turn which is a very important
48:48 - thing to keep in mind okay so now we
48:50 - have reduced speed so what we're going
48:52 - to do is go inside of here and we're
48:54 - just going to do something i'm going to
48:56 - say
48:57 - moved
48:58 - is equal to false and inside of here i'm
49:02 - going to say moved
49:03 - is equal to true now the point of this
49:05 - is that if we are pressing the w key we
49:08 - don't want to reduce the speed but if we
49:10 - let go of the w speed or w speed the w
49:12 - key we do want to reduce the speed so
49:14 - now i'm going to say if not moved so if
49:16 - i didn't press forward on the gas reduce
49:18 - my speed so i'm just going to say not
49:20 - self it will go with player underscore
49:23 - car and this will be dot reduce
49:25 - underscore speed so now you should see
49:28 - that when i'm not pressing on the gas
49:29 - and not pressing on the w key we should
49:31 - reduce the speed so let's run this code
49:34 - and let's see what we get so now notice
49:36 - that we slow down right and it takes a
49:38 - second to slow down
49:39 - i'm pressing the key i let go of the key
49:41 - and we continue going and then we slow
49:44 - down until eventually we stop
49:46 - all right so with that said this long
49:48 - video is now over if you guys had the
49:50 - patience to sit through all of this give
49:51 - yourself a pat on the back and not
49:53 - expect it to be this long but there is a
49:55 - lot of stuff that goes into moving a car
49:57 - in this fashion in the next video we're
49:59 - going to set up the actual collision
50:01 - with the track we're going to make it so
50:02 - you bounce off of the track we'll then
50:04 - add a finish line and we'll make it so
50:06 - that you can hit the finish line and
50:08 - collide with the fission line so we'll
50:09 - just be doing collision pretty much in
50:10 - the next tutorial then after that we
50:12 - will implement the computer car so
50:14 - moving around a path which is also not
50:17 - that easy to do and then i guess we'll
50:19 - do four videos for this series and in
50:20 - the last video we'll about all of the
50:22 - nice stuff like the text showing the
50:24 - kind of the stats the level system all
50:26 - of that fun stuff anyways if you guys
50:28 - enjoyed make sure to leave a like
50:30 - subscribe the channel and i will see you
50:31 - in the next one
50:34 - [Music]

Cleaned transcript:

hello everybody and welcome to a brand new tutorial series on this channel where i will be showing you how to make a car racing game in python using pygame now pygame is one of my favorite modules in python it's been a while since i've done a tutorial series using it so i kind of came up with this game right here which actually fun fact is one of the first games i ever created using a software called game maker so i kind of recreate it in python and it turns out to actually be pretty complicated to implement it makes a really good tutorial anyways let me explain who this tutorial is for and then i will demo the game to you so this tutorial is kind of designed for intermediate programmers if you are a beginner you can definitely follow along i'll try my best to explain everything as always but this is going to use quite a bit of kind of more advanced python syntax or more intermediate python syntax and so if you haven't seen object oriented programming before it might be a little bit difficult to follow along but again i will try my best to explain with that said this will probably be five videos maybe two and a half hours of content everything you need will be linked in the description in each video all of the assets you see here most of them i actually made myself and of course they're free to download from the description all of the code that i write in each video will be uploaded to github so you can look at the code per video not just the finished code and yeah with that said that's pretty much everything you need to know so let me demo the game for you and then we will start actually writing the code so the idea behind this game is we have two cars one car is kind of the player car so the red car the other one is the computer right so the green car now the objective is to simply beat the green car to the finish line at every single level now you can see right now that the green card is going quite slow but as the levels increase it increases in speed and well it gets progressively more difficult now i always like to leave my games pretty basic and then allow you guys to kind of add on to them so something you could do to make this more challenging is add obstacles you could add like i don't know oil or something on the track so that you would slip if you hit it you can do all kinds of crazy stuff what i'll be showing you in this tutorial will allow you to kind of add that stuff as you continue now you can see here we've moved on to level two notice the car will get progressively faster and then this game goes up to 10 levels the last level has the green car almost as fast as the red car and so if you beat that last level there then you win the game anyways i won't keep playing through this but this is a pretty complicated thing to actually make i know it looks trivial but to allow the car to move in this way to have this car follow a path to have a collision with a track that's kind of not square right not rectangular collision to have the finish line to increment levels to change speeds there's a lot going on here and this is a really good kind of learning experience from this tutorial anyways enough of this long introduction i apologize let's go ahead and get into the code all right so let's go ahead and get started now we have some setup steps that we need to walk through and then once we do that in this first video i'm going to show you how we can move a car around the screen i know that seems trivial but we're going to implement acceleration velocity braking and slowing down and a bunch of other stuff like actually changing the angle of the car and determining the horizontal and vertical displacement of the car based on its angle so it's actually pretty complicated and that's why this video will be you know the length it is it's probably pretty long although i haven't filmed it yet obviously and anyways before we can do all that we need to set up our environment so i'm here in visual studio code feel free to use whatever editor you want and the first thing we're going to want to do here is download all of the assets for the game so i'll just walk through them kind of one by one because i actually made almost all these assets myself so hopefully you guys are impressed by that but we have a finish line we have this grass which is kind of the background i didn't make this i found this on google images we have a green car i made this i was impressed that i made this with pixlr hopefully you guys like that too we have a gray car we have a bunch of other cars as well i just made a bunch of different colors so you guys could swap the colors if you want but i'm using green and red and then obviously we have the red car and then we have our track border i'll discuss why we need this in a second and then we have our track so notice this track kind of has some white outlines the reason for that is i took this from google images and then removed the background from it in photoshop i'm not very good at doing that so that's why it looks the way it does feel free to use any track that you want but what you will need if you use a different track is you will need the border or kind of like the yeah i guess you'd call it border i guess you could call it the walls or the outline of the track as well you'll see why we need this but this is how we're going to handle collision by using kind of just the edges to determine if our car has actually gone off of the main track and that's how we're going to bounce our car backwards so again you need the main track like this and then you would need the track border you could do it with just the border as well and then you could have some background kind of beneath the border you'll see what i mean in a minute but i'm kind of just explaining why we have these two images here then of course we have the white car again this is just so you guys can have some options when we're using the cars great so download all of those again link in the description it should download a zip folder and then you can extract extract the zip folder sorry by right clicking on it and get all of the images now that we have that what we need to do is install pygame so what you're going to do is go in your terminal or command prompt and type pip install pi game like that now for some reason this doesn't work i have two videos on this channel i'll link them in the description as well they'll walk through all of the possible ways that installing pi game could go wrong and how to fix them so i'll refer you to those two videos there for some reason you cannot install python so watch those and then come back great obviously i already have pygame installed so we are good to go now that we've done that i'm going to make a python file in fact i already have one called main.pi outside of the images directory but inside of the folder where my project is going to be all right so now that we've got all of that set up i'm inside of the main.pi file and we're going to start writing some code now the first thing i'm going to do is just import pygame because we're going to need that a few other imports we'll need as well is going to be import time and then i'm just looking at my cheat sheet here in fact if you notice me looking to the right it's because i have all of the code already written just so that i don't get lost as i'm going through this tutorial we're also going to import math we'll be using a lot of stuff from the math module now that we've done that the first thing i actually want to do is just load in all of my images the reason i'm doing that now is because we actually need some of the images to set up some other things you're going to see so the first thing i'm going to do is load in my grass so in all capitals i'm going to say grass the reason all capitals is because this is a constant this is not going to change so that's the convention i'm going to say pygame.image.load and i'm going to put the path to my image which is going to be images slash and then grass dot png like that so now i have my grass next i'm going to load my track so i'm going to say track is equal to pi game.image.load it's this can be images slash track dot png like that after we do that we will load in our track border so i'm going to say track underscore border like that is equal to pygame.image.load and this will be track hyphen border let's make sure that's the correct name looks like it is okay great and now that we have the track border we can load in the finish line so i'll just say finish is equal to that and then this will be finish dot png and then we can load in our cars so we'll say red car is equal to and then this will be red hyphen car and then we will have our green car let's make sure that's all capitals and then green car like that now of course feel free to swap these cars if you want i don't think i need to explain how to do that but you just change the name inside of here and then the corresponding variable name great so now that we've done that what i want to do is start displaying some of these images on the screen but first i need to actually set up a screen or set up what's known as kind of the display surface so what i'm going to do here is say that my window or my win in all capitals is going to be equal to pie game dot display dot set underscore mode and then the mode that i need to set inside of here is a tuple containing the width and the height of my display now the width and the height of this display i actually want to be equal to the size of my track so whatever the track size is that's how big i want my pi game display to be so what i'm going to do here say width comma height is equal to and then track dot get underscore width and then track dot get underscore height like this so a little trick in python whenever you have a surface which is what this does it loads in an image and renders it as a surface or stores it as a pi game surface you can get the width and the height of that surface by using get width and get height so we're going to get the width and the height of our track and then i'm going to say that i want a display that is of size width height and that is obviously corresponding to the size of the track now that i have set up the window i'm just going to give my window a name so i'm going to say win dot and then this will be set underscore caption like that and i'm just going to say racing game exclamation point like that okay so now that we have our windows set up we should see if we run the code here let's see no such file or directory images grass.png okay that's interesting let's see why that's happening oh it's grass.jpg well that makes sense so let's fix that let's run this now and then we should see a pie game window pops up and then it just immediately goes away because apparently it has no attribute set caption interesting i believe that's because this is actually the correct one pygame.display.set underscore caption my apologies again that's going to happen a lot i'm going to make mistakes in this video let's run this code now though and see what we get and there we go perfect so everything is working as you would expect the reason the window is not staying on the screen is because we haven't made it stay on the screen yet okay so now we have loaded in some of our images the next thing that i want to do is actually show some of them on the screen so i'm going to set up my event loop i'm going to say wow run and i'm going to make a variable here that says run equals true now the event loop in python is kind of a constant loop or in pi game story that is going to be handling all of your collision all of your movement all of your events like the user pressing a key and so the first thing you usually do is you set up this main event loop and that's what keeps the window alive right keeps it running on the screen and then as soon as you quit the window or the game ends then you would destroy the event loop and destroy the game and then the window would disappear hopefully that makes a bit of sense but we're going to say run equals true while run now inside of here i'm going to say the following for event in pygame dot event dot get this is going to give us a list of all of the events and then we can loop through them and the first event that we want to check is if the user has closed the window so if they press the x in the top right hand corner so the way we do that is we say if event dot type is equal to pi game dot quit then we're going to say run is equal to false we're going to break out of this for loop right here and then underneath this while loop i'm going to say pygame.quit now this will just close the window cleanly for us so the idea is if we press the quit button we make run equal false we exit the while loop and then well we would quit the game awesome so now that we have that if i run my code we should see that it says racing game window shows up everything's fine and then if i click x it closes there we go and that is some good progress okay so now that we have that what i want to do is set up a clock now what a clock does is make sure that our window is not going to run faster than a certain frame per second that or then a certain speed is probably what i should say so right now this while loop is going to run as quickly as our processor can handle it so if you have a really quick processor it's going to run faster than if you have a really slow processor but the thing is when i have this game i want it to run at the same speed on every single person's computer right or i want to at least have a maximum speed so one person can't be going like super fast down the track meanwhile on a slower computer they're going really slow just because their processor can't handle it so i'm going to set up a clock and this clock will fix that for us so i'm going to say clock is equal to pi game dot time and then dot clock with a capital c then up here i'm going to say fps standing for frames per second is equal to 60. right at the top of my wall loop i'm going to say clock like this dot tick and i'm going to tick by fps now what this does is make sure that this while loop cannot run faster than 60 frames per second okay so if you change this number then that will change how quickly this while loop can run hopefully that makes sense but if we run the code now we should see that it's just working the exact same we're not really going to see a difference because we're not drawing anything on the screen okay so now that we've done that i want to draw some of these images on the screen and just see the size of them and then we're going to kind of position them and redraw them just to make sure they look good so let's go inside of here and let's start by doing this pie game dot display not clear but dot update now this is a method that you need to run every single time you want what you've drawn on the screen to actually be drawn so what you can kind of do in pi game is you can draw a bunch of stuff and then as soon as you've drawn it onto the screen you update the display and then it will show all of the stuff that you've drawn so in this case i want to start by drawing this grass background and the track over top of it so let's do that we're going to say pie game actually not pie game we're going to say win which is the name of our window dot blit this is what you do when you want to draw an image onto the screen we're going to put the image we want to draw so i want to draw grass and where do i want to draw this at position 0 0. now the coordinate system for pi game is 0 0 is at the top left hand corner i guess top left would be there for you guys and then as you go down the y increases so the bottom of the screen would be the largest y value and as you go to the right the x increases so the furthest right would be the largest x value sorry so yeah the x increases as you go right perfect so let's run this now let's see if grass is showing up and notice grass is showing up now it's not quite large enough we'll make it larger in a minute but for now we can see it on the screen so now that we've done that we want to draw the track so i'm going to say window blit and then track like that and we'll draw the track at 0 0. now notice the order i've drawn this i've done the grass first and then the track second that's so the track will show up over top of the grass if you did in the other order well you would get it in the other way let's run it now and notice now we have our track and that the size of the window is exactly kind of the size of the track here right so now what we need to do is draw the finish line and we also need to increase the size of the grass and i actually want to make the track a little bit smaller because it's taking up a bit too much room on the screen for my liking so let's just draw the finish line now we'll say win dot blit like that and then we'll say finish and we'll just draw this at 0 0 as well just so we can see what it looks like and then that's the finish line that might actually be a good size but we might need to make that a bit smaller as well when we change the size of this stuff okay so now that we've done that we need to change the size of some of these images so to do that i want to write a function the reason i want to write a function is just going to make it a lot easier for us to scale our image rather than having to manually write the same thing a bunch of times so i need to go look at my cheat sheet here and we're going to write the following function define scale underscore image this is going to take in an image and a scale factor now the factor is like if i give 2 it's going to scale it by 2x if i give 0.5 it's going to shrink it by a factor of 2 or shrink it or i guess multiply it by a factor of 0.5 right whatever way you want to think of it but that's kind of how it works so now i'm going to say the size this will be the new size is going to be equal to round and then this is going to be image dot get underscore width multiplied by the factor the reason we need to round this is because we need to have integers when we scale the image we cannot have decimal values so we'll do that now let's copy this we're going to go comma and instead of get width now we're going to do get height and again we're going to multiply it by the factor so this will give us a tuple that contains the new width and the new height of our image then what we're going to do is return like this pygame dot trend form dot scale and then we're going to pass the image and we're going to pass the new size that we want this image to be let me make sure that's right looks like it is so that will allow us to scale our image now the thing is i don't really want this function kind of cluttering up my main file so what i'm going to do just to clean things up a little bit here is i'm going to make a new file called utils.pi and inside of utils.pi i'm going to put utility functions that are going to be used from inside of this main file so inside of here i'm just going to import this function and at the top of the program i'm going to say import pi game like that just because we need access to pi game in here to use this pi game function great so now rather than having this function here i'm just going to say from utils import and we will import scale underscore image like that great so now we can use scale image so the first thing i want to do is i want to scale my graph so i want to say scale image i'm going to pass this image to scale and then what do i want to scale it by let me check here and see for now we'll try with 2.5 we might want to change that but that's what we'll go with right now and then for my track i don't really want to shrink this too much but i want it to be a bit smaller so i'm just going to scale it by 0.9 okay so now we've scaled the track and the grass while we're at it i'm just going to scale the track border to be the same size as my track the reason for that is i need the border to be the same size otherwise we're going to have come some weird collision errors in the future so let's make this 0.9 and then the finish line we'll leave like that for now okay so let's run this and notice that that looks a little bit better the grass is taking up the full screen track is a bit smaller everything looks good now let's just draw a few cars and then let's scale those so let's go down here and rather than blitting the finish line let's blit a car so let's just go with red underscore car all the cars are the same size so if you scale one you can scale all of them notice the car is a little bit big i'd like that to be a bit smaller because we want to be able to fit two cars on the track kind of parallel or beside each other so let's make the car a bit smaller let's go to red car let's go scale image and that should not be in all capitals let's go scale image like that we're going to scale this to 55 so 0.55 and then we'll do the same thing here scale image and 0.55 okay now let's run it and let's look at our car and that is a much better size sweet so now we have drawn pretty much what we need to onto the screen however what i would like to do is kind of clean this up a bit we're going to notice we're going to continually be cleaning and refactoring stuff as we go through this i want to take all of the stuff related to drawing and i want to put this in a separate function just to make sure that i know where all of my drawings being done and i'm not drawing you know like 100 things inside of this wallet because that's going to get really messy really quickly so i'm going to make a function up here called draw now the reason i'm not going to put this inside of the utils function is because this is very heavy or very correlated to the game whereas the stuff inside of utils.pi i could use this in any game whereas this draw function is going to be used only in this game right so it kind of makes more sense to be in this file anyways i'm going to take a window that i want to draw stuff on and then i'm going to take images that i want to draw then inside of here i'm going to say 4 and we're going to go with img in images i'm going to say win blit and then i'm going to blit the img and we're actually going to say img comma pause and you'll see why in a second and i'm going to blend it at this position now what i'm going to do is i'm going to say my images are equal to and i'm going to make a list containing images and their positions that i want to draw them on the screen so i'm going to say grass and i want to draw this at 0 0 and then i'm going to say track and i again want to draw this at 0 0 and for now we won't draw the car we're going to draw that a bit differently so now inside of here i need to call this draw function i need to pass in my window which is a capital win and then my images like that so now if we run the code we should get the same thing we got before and we do always work okay so that is all good now we want to draw the car and we want to move the car around the screen and the thing with the car is we need it to be able to change its position we need to be able to rotate the car right so we can go left it can go right because that's how we're going to be able to turn we have to be able to turn around the track and we need to turn the heading of the car so we will continue in one second but i need to quickly thank the sponsor of this video and this series which is algo expert algo expert is the best platform to use when preparing for your software engineering coding interviews they have over 160 coding interview questions on the platform and i am one of the instructors on that platform so you can be sure there are great explanations for each of those questions check them out from the link in the description and use the code tech with tim for a discount on the platform so what i'm going to do here set up a class and this class is going to handle all of that stuff for our car so i'm just going to say class and i'm actually going to make in what's known as an abstract class i'm going to say abstract car like this now let's see why we need this in a minute but the idea is we're going to have both a player car and a computer car so there's going to be a lot of stuff that's common to both of these cars so we're going to put all of the common stuff in an abstract class this is a class that's not meant to be instantiated but it's meant to act as the base class for the other two classes if you're not familiar with inheritance don't worry about it too much just understand that all of the stuff i put inside of here is going to be used by both my player car and my computer car and that's the point of this so inside of abstract car i need to go and look at my code here to remember what i put i'm going to define an init now i'm going to say define a knit like this and inside of here we're going to take self we're going to take a x and a y um actually no we don't want an x y we're going to go with max velocity as our first parameter and as our second parameter we're going to go with the rotation underscore velocity so the reason i want both of these is because i want to know the maximum speed my car can go so the maximum velocity and i also want to know how quickly my car can rotate so it's rotation velocity and then inside of here i'm going to say self dot max underscore val is equal to max underscore val i'm going to say self.vel equals zero the reason why the starting velocity is zero is because your car's not moving when it starts it has a velocity of zero and i'm going to say self dot rotation velocity is equal to rotation val i'm going to say self.angle is equal to zero and the point of this is that our car will start at an angle of zero and then when we change the angle that will change the way that the car is rotating okay so now that we have that the first thing i want to handle is just rotating the car so i'm going to go inside of here and i'm going to say define rotate like that i'm going to take a self a left is equal to false and a right is equal to false now you're going to pass left equals true if you want to rotate to the left and right equals true if you want to rotate to the right now inside of here all i need to do is say if left i'm going to say self dot angle and then this is going to be plus equal and then self dot rotation velocity like that and then if we are moving to the right it's going to be the opposite so we're going to say left right then self dot angle minus equals self dot rotation val and now that i'm thinking about it when i'm going to the right my angle is increasing when i'm going to the left my angle is decreasing so i actually think it might need to be the other way around um or maybe i'm crazy here you know we'll leave it like this for now and if for some reason we're rotating in the inverse direction then we'll change this i think this is right i'm just confusing myself okay so now we have rotate i'm just looking at anything else we might need here for now that actually looks good so what we can do is call the rotate method and then depending on if we're going left or right we'll rotate to the left or right the way we rotate is by changing the angle however we need to actually rotate the car right we can change the angle in this class but that's not going to change the position of the car image so what we need to do is find a way to actually draw the car image rotated so we need to know how to rotate the image in pygame now this is a little bit complicated but i'm going to go inside of utils.pi and i'm going to write a function that can take an image and return to a rotated image based on an angle so let's do that we're going to say define blit underscore rotate underscore center and what this is going to take is a surface this is where we want to draw the uh actually let's call this wind this is where we want to draw the rotated image then we're going to say the image we're going to say the top underscore left and we're going to say the angle okay so i'm just going to write this function and i'll explain a little bit about what's going on after but i will note that rotating an image in pi game is not trivial if you're going to be rotating an image you can just normally rotate it but if you do that you're going to get all kinds of distortions and the reason for that is the rectangle that contains the image so i should say every single image in pi game is really a rectangle and then the actual image is inside of that rectangle so even if it doesn't look like a rectangle there is a rectangle that's containing the image so when you rotate the image you're also rotating the rectangle and based on the position that you're rotating the rectangle around you can get really kind of weird like you know morphing and distortions occurring with the image so that's why we need whatever we're doing here so i'm going to say rotated image is equal to pi game and i believe this is dot transform it is dot transform dot rotate we're going to pass the image and the angle that we want to rotate now what this will do is rotate the image around the top left hand corner now that's no good we don't want to rotate the image around the top left hand corner because that's going to lead to us kind of having like a circle around that stationary point instead we want to rotate around the center of the image so the way we're going to do that is we're going to say new rectangle is equal to rotated image like this and this is going to be dot get underscore rect and we're going to say that the center of this rect is equal to image dot and then get underscore rect like this and we're going to say that the top left so top left like that is equal to the top underscore left and then inside of here we're going to say dot center okay so what's happening here is pretty complicated but i will try my best to briefly explain it i have to admit i did take this code from stack overflow i didn't come up with this on my own anyways point being we rotate the original image when we rotate this image i'll show you in a second we get all kinds of weird distortions and the actual x and y of the image is going to change based on how it's rotating around the top left hand corner so then we have our new rectangle so we say the new rectangle is equal to the rotated image.getrectangle the point of this is we want to remove the offset so we want to make it so that we rotate the image without changing the x and y position of the image on the screen that's what this whole line is trying to do for us so we're saying let's get a rectangle from the new rect but let's make its center equal to the image the original image its rectangle at the top left hand corner position then whatever the center of that is so we're getting the original image we're saying the top left hand corner of that original image is equal to whatever its x and y position is because the image doesn't know its x and y position so we need to set the top left hand corner explicitly to be equal to that then we're saying let's get the center of that and wherever that center is the new image needs to still be on that center so that way we're only rotating from the center of the image not from the top left but we had to originally rotate from the top left because that's the only way to rotate an image in pi game hopefully that makes a little bit of sense and then what we're going to do is say this we're going to say win dot blit and we're going to blit the rotated image and we're going to do this at the new rect.top left so the whole idea of this new rectangle is to find the correct x and y position of the new rectangle such that it's going to be in the same position as it was before but now it's rotated all right a lot of complicated code there but there you go that will blit it and rotate it in the center for us so let's go to main.pi now and let's define a method inside of abstractcar that can draw the car for us we're going to say define draw and then we're going to take in self and we're going to take in a window all we're going to do is the following we're going to say first we need to import this i believe this was blit underscore rotate center yes it was so we're just going to say inside of here blit underscore rotate center and then we're going to pass self dot img actually we're going to pass wind sorry and self.img which we've yet to define which we'll do now so we're going to go to abstract car we're going to say self dot img actually not up here what am i doing sorry we're going to do inside of here we're going to say self.img is equal to and then here i'm going to say img is equal to and we are just going to reference one of the images that we want for this car so in this case i want the red underscore car i'm going to say self.img is equal to self.img i understand this a little bit weird what we're doing here is saying the following we're going to store inside of the class the image that should be used for this class so in this case i want it to be a red car then i say the self.image so the image specific to this instance is equal to self.img so whatever the image is here and then inside of here we then reference that image so that we can rotate it and we'll blend it in the center okay that's all great however i need to first make a way to actually rotate my car before we can see if this is working so let's let's actually just draw the car first let's make a car i'm going to say car is equal to and first we should create a concrete instance of this class so i'm going to say class i'm going to go with player car like that now inside of here all i'm going to do is just copy this i'm going to remove it from abstract car because now we have this class and that's actually all i need inside of player car but i need to make sure i inherit from abstract car so let me just explain this quickly in case this is a bit confusing we have the abstract car class this defines a bunch of functionality when we put it inside of the brackets like this we're saying we're going to use everything from inside of here so imagine all of this is just copy and pasted right inside of player car the only thing we're doing differently here is we're defining image inside of here and then it will be used inside of the initialization when we instantiate this car class okay that was a lot of big words but let's continue so i'm going to go here and say car actually with playerunderscore car is equal to player car like that now we need to pass to this a maximum velocity and a rotation velocity so for now i'm going to go with 4 4 feel free to change that to make it slower or faster obviously the higher number the faster it will go and now let's just draw the car so inside of draw i'm now going to pass my player car so that means we need to now take player underscore car and now we're going to say player underscore car dot draw and then inside of here now i'm going to take my pie game.display.update i'm just going to put this right inside of the draw function so that everything related to drawing is contained in one place okay so that should draw our car let's see if this is working and required one uh required missing one required position argument win okay playercard.draw that would be right here so we just need to make sure we pass our window to the draw method so let's run this now and we got an error blit rotate center missing two required positional arguments top left and angle of course i forgot those let's fix that so we need to pass the top left hand position now the top left hand position is actually going to be equal to the x and the y of the car which we haven't defined yet so we're going to do that now we're going to say self.x self.y is equal to self.start underscore position pause like that sorry and then inside of here we're going to say start underscore pause is equal to and then we're going to define what the starting position should be so i'm just going to say actually let me just go look at my other code and see where i started it before i was starting it at 180. uh was that right let's see 180 and 200 okay so go 180 and 200. okay so now our self and x self.x and self.y is equal to the starting position which we've defined here and inside of here we now need to pass that so we're going to say self dot x self dot y and then we want to pass the angle and the angle is just going to be self dot angle like that okay let's run this now and let's see what we get okay so there we go our car is now drawn here now let's just see if changing the angle actually does anything so let's go and make the angle 90. let's see where we go now notice we are facing left perfect that's what we would expect okay now let's make the angle 180 we should be upside down now and there we go so we are getting the car in the correct position sweet so let's make that back to zero and now let's make it so we can change the angle based on pressing a key so we're going to go and i'm going to write the following inside of my main event loop remember anything in the event loop is kind of handling events handling collision handling all of those types of things so this is where we would put you know key presses and moving the car so i'm going to say keys is equal to pi game dot key dot get underscore pressed like that and then what i want to do is check if we pressed a specific key so i'm going to say if keys and then i'm going to go highgame.k notice that's a capital underscore and then a so i want to use wasd to move my car so this would be left if i'm pressing on the a key so if i'm doing that then i want to say player underscore car dot rotate left is equal to true okay let's copy this and then let's go here and say if keys pi game k underscore d so this would be right then i want to say right is equal to true okay so that should now allow us to actually rotate our car left and right by clicking on a and d if you're wondering how you find other keys you can look them up there's a bunch of i guess these are called constants in pi game but you also can just do k underscore and then whatever the lowercase letter is of the key that you want if you want like a spacebar or something then you would go all capitals and you would go space same thing with like shift or enter or any of those keys if it's not just a standard character then it's usually in all capitals okay let's run this though and let's see if it works and now notice if i go left and right i can rotate my car and the speed at which i'm rotating my car is defined by that rotation velocity so you guys can mess around with that but if you change the rotation velocity you'll notice you're rotating faster or slower okay that's great so we can now rotate the car off to a good start that's actually a pretty difficult thing to do so congratulate yourselves if you made it through that now let's see how we can move the car forward so we have our self.velocity we have the maximum velocity we have the rotation velocity we have the angle the next thing we need is the acceleration because cars don't just instantly reach their top speed they take a few seconds to get up to speed when you slam on the gas you are accelerating you're adding more force to the tires you're going faster and then eventually you re reach kind of like a terminal velocity which is what we're going to get to here so i'm going to say self dot acceleration did i spell that correctly looks like i did is equal to 0.1 so this means every time that we are pressing down on i guess it's going to be the w key to go forward we're going to increase the velocity of our car by 0.1 let's call it pixels per second that's maybe the unit that we're going at if you want to accelerate slower then make this 0.05 right or if you want to go faster make it something like 0.2 anyways we have that now i want to define a method and i want to call this move underscore forward okay so define move forward and inside of here i'm going to take self now all this is going to do is it's going to increase the velocity of my car based on the acceleration and if i'm already at the maximum velocity it just won't do anything but it will move me forward so inside of here i'm going to say self.vel is equal to i guess this is going to be the minimum uh yeah the minimum of self.bell plus self.acceleration and self.max underscore velocity so what this is doing is saying okay well if self.vel is already at the maximum and we add self.acceleration we don't want to go faster than the maximum so we put self. max val here so if this is greater than this we just default to the maximum velocity if it's not though then we will increase the speed of the car by the acceleration remember the velocity starts at zero okay so we'll increase our velocity now that's great but we actually want to move the car forward so to do that i'm going to make a new method called move i'm going to say define move like this and inside of here after i increase the velocity i'm going to say self.move now the thing is inside of move i need to actually calculate what direction i'm going to move my car because if i'm angled to the right or i'm angle to the left then i need to move in that appropriate direction i can't just go up or go right or go left so i'm going to start by just showing you how we move in one direction so i guess one plane or one dimension and then i will show you how we can move in multiple dimensions so move x and y based on the direction of our car that's going to involve a little bit of trigonometry anyways inside of here i am going to say self.x plus equals self.velocity so we're just going to move to the right based on whatever our velocity is that's all we're going to do to start right now then we'll get more complex okay so now that we've done that we want to implement another key press to move the car forward so i'm going to go here and say if keys pie game dot key underscored w then player card dot move underscore forward like that so now as we press down the w key we should increase speed as soon as we get to the top speed we'll stay at that speed and we'll move forward now remember we're not decreasing the velocity here so as soon as we hit the maximum speed we'll stay at that maximum speed even if we let go of the w key we'll keep going at the same speed i'll show you how we fix that in a second but just wanted to note that as we got in here okay so i've loaded now notice when i press w i move over to the right like that now i'm going to stop as soon as i let go of the key but when i press the key again i'll be moving at the maximum speed so that's it that's how you move one direction right we just incremented the x of the car and that moved our car over okay that's great but we ideally would like to be able to move in two dimensions so this is where i need to pull out the paint program and start showing you some trigonometry okay so i'm here in paint and i'm gonna start describing the trigonometry that we're gonna use to actually move in the direction that we're facing this is not trivial this is why i'm in paint now please go easy on me i am using my mouse so this is going to be really rough but it will give you kind of you know what you need it would give you the basic visualization of this so the idea is we have some car let's say this is our car now if he's just moving this way all we have to do is move the y direction right if he's facing completely up then we can just move that direction if he's facing completely to the right or completely to the left any of these kind of polar coordinates here then we can just go in those directions right it's very easy we can just decrement the x increment the x decrement the y increment the y however what happens if we're moving on an angle like this well it is not so simple now to actually figure out how much we need to move this guy by because we can't just move by the x and we can't just move by the y we need to move by both of them we need to go some amount up right and some amount to the right now first of all what are those amounts well if you said the amount is equal to whatever the velocity of the car is that's incorrect the reason for that is if my car has the heading like this like it's pointing this direction then the velocity that we have is in that direction right so let's say my velocity is 4. well if that's the case then this is 4. that does not mean that my x is 4 and my y is 4 in fact i need to use this total velocity to determine how much x and how much y i need to go by so that my total velocity accumulates 4 because when i'm moving in two directions i'm moving well two ways and so i need to sum the velocities but it's not it's not as easy as just adding them together to determine what the total velocity is going to be now in this way we're going to go in the opposite direction we're going to say the following we're going to say okay well this is like a right triangle right we want to go some direction x some direction y so let's say x and y like that and then this is our total velocity right here now it turns out that we know this angle and if we know this angle we can actually figure out what y and what x are by using trigonometry so there's a few very popular equations the way i remember them is the following we have so which is soh and then we have uh cap cah like this so cat and then we have toa as well toa now o stands for opposite now this is relative to the angle that you're talking about so if i'm talking about this angle right here the opposite side is y so oh those are all sides okay that's side lengths is what i'm talking about and s stands for sine c stands for cosine and t stands for tangent anyways i have my angle so the opposite side is this because that's kind of what the angle is like facing it's what it's looking at and the adjacent side is this it's x because that's what's beside the angle that's the way you can think of it so if i want to solve for y here keep in mind i know my angle and i know my velocity then what i need to do is the following i need to set up my equation so i'm going to say that the sine of theta is equal to my opposite over my hypotenuse now we know the angle and we know the hypotenuse so h is really v which is my velocity now let's just plug in 4 because we know the velocity is going to be 4. we'll say the maximum velocity is 4 right so now we're solving for o and o is really equal to y right because that's the opposite side and so what we do is we say that the sine of theta which we can calculate we just take the sine of the angle multiplied by 4 because we need to take the division and multiply it on this side is equal to y so the sine of theta multiplied by our velocity gives us our displacement in y and then if we go to cosine here it's just going to be the other way around we're just going to take the cosine and we're going to multiply that by our velocity and that is going to give us how much we have for displacement in x so just basic trigonometry but i wanted to walk you through that all right so hopefully that is a decent enough explanation what we actually do in the code might differ a tiny bit just because of a few factors but this is the general idea of how we can solve kind of two components based on one velocity and an angle we're calculating the x and the y component that's what they're known as because this is we can kind of call this a vector right like this line right here if you know anything about physics you would call this a vector because we have a angle so we have a direction and we have a velocity or a magnitude and then we want to split it into its two components x and y okay so let's get rid of that and let's implement this so let's go to our move method and now rather than moving just by the velocity we're going to do that kind of fancy equation that we just did so the first thing i need to do is i need to convert my angle into radians this is because we use radians in most computer math radians is just kind of a special way of calculating angles in case you're unfamiliar 360 is equal to 2 pi in radians and 180 is equal to pi okay you don't really need to know that but just figured i'd let you know so we're just going to say math.radians and then self.angle like that notice our angle is in degrees because that's how we want to rotate it but then when we actually are looking for the components we need it in radians now let's calculate the vertical displacement or the vertical velocity so we're going to say vertical is equal to and then this is going to be math dot and i actually think this is going to be cosine for this math.cosine of radians multiplied by self dot velocity and then we are going to say that the horizontal is equal to math.sine of radians multiplied by self.bell then i'm going to say self.y minus equals vertical and self.x minus equals horizontal now you can switch this to the plus side and watch what happens but the reason we we need minus is because these are actually going to return to us in a lot of instances negative values and based on the way that we are angling our car and just kind of some other things we've done that i don't really want to get into too much we need to subtract rather than adding now if we're subtracting that means if this value is positive we're going to the left right and if we are uh and sorry and we're going up so going to the left and up which is the way that our angle is directing so that makes sense and then if this value is negative that means that we're going to be going to the right and we're going to be going down i mean respective to x and y anyways let's just run our code here and see if this works and so let's do this and now notice i can move in whatever direction my car is facing there you go so we are now moving our car which i'm going to call a success now the only thing we need to do here is we need to make it so our car slows down because as you saw let me actually run this again my car just instantly stops right if i let go of the key it just instantly stops that's not realistic our car is going to have momentum it's going to be moving and it's going to take some friction to slow the car down so we need some way to actually slow the car down when we're not pressing on the key which is what we're going to do now so we're going to implement a method here on our car we're going to call this reduce underscore speed and we're just going to take in self now what we're going to do is reduce our speed by half of our acceleration that is because we can accelerate faster than we can slow down at least that's the logic that i'm going to use i'm not sure if that actually applies in the real world but that's kind of what we're going to do here also just so that we don't slow down super super quick because we can accelerate really quick anyways you'll see how this works as i get into this method now i just need to look at where i have this in my other code so that i don't mess this up too bad okay so we have reduce speed what we're going to do inside of here is say self.bell is equal to the maximum of self dot vel minus self dot acceleration over two and then this is going to be zero now the reason we have this is because if this value for some reason is negative we don't want to be moving backwards we just want to stop and so that's why we have the zero right here so we change the velocity and then since we have this move method already set up we can just say self.move so now when we reduce the speed all that's happening is we're reducing the velocity by half of the acceleration and then we're just going to move and since this is set up it'll just work it's just going to move us slower in whatever direction we're facing and while we're slowing down if we're not on the gas we can still turn which is a very important thing to keep in mind okay so now we have reduced speed so what we're going to do is go inside of here and we're just going to do something i'm going to say moved is equal to false and inside of here i'm going to say moved is equal to true now the point of this is that if we are pressing the w key we don't want to reduce the speed but if we let go of the w speed or w speed the w key we do want to reduce the speed so now i'm going to say if not moved so if i didn't press forward on the gas reduce my speed so i'm just going to say not self it will go with player underscore car and this will be dot reduce underscore speed so now you should see that when i'm not pressing on the gas and not pressing on the w key we should reduce the speed so let's run this code and let's see what we get so now notice that we slow down right and it takes a second to slow down i'm pressing the key i let go of the key and we continue going and then we slow down until eventually we stop all right so with that said this long video is now over if you guys had the patience to sit through all of this give yourself a pat on the back and not expect it to be this long but there is a lot of stuff that goes into moving a car in this fashion in the next video we're going to set up the actual collision with the track we're going to make it so you bounce off of the track we'll then add a finish line and we'll make it so that you can hit the finish line and collide with the fission line so we'll just be doing collision pretty much in the next tutorial then after that we will implement the computer car so moving around a path which is also not that easy to do and then i guess we'll do four videos for this series and in the last video we'll about all of the nice stuff like the text showing the kind of the stats the level system all of that fun stuff anyways if you guys enjoyed make sure to leave a like subscribe the channel and i will see you in the next one
