With timestamps:

00:02 - [Music]
00:08 - okay
00:09 - so now we have peace and if we want to
00:11 - see them well we need to start creating
00:12 - some pieces
00:13 - so inside of my board class under create
00:16 - board i'm going to create a bunch of
00:17 - pieces
00:18 - we're going to start obviously by making
00:20 - the white pieces will be at the top
00:22 - and then the red pieces at the bottom so
00:25 - this
00:26 - is not too complicated but it is a
00:28 - little bit of a for loop kind of
00:30 - in indentation thing that you'll see
00:32 - here because we need to
00:34 - obviously have them be spread out we're
00:36 - only going to have i believe
00:37 - four in each row and then they need to
00:39 - be staggering and then the white needs
00:40 - to go up there there needs to be a space
00:42 - and then it needs to be
00:43 - the black or the red sorry the white and
00:47 - then the red my bad
00:48 - all right so four row
00:51 - in range rows
00:54 - for call in range calls we can
00:58 - import calls up here technically again
01:02 - i mean i can change this here to be
01:04 - calls doesn't matter because they are
01:06 - the same value but say we had
01:07 - a checkerboard that wasn't exactly
01:09 - square then these would matter
01:11 - so four range or four row in range rows
01:14 - four call in range calls what we're
01:16 - going to do is we're going to start by
01:17 - saying
01:17 - self self dot
01:21 - board dot append and empty list
01:24 - the reason for this is because we want
01:26 - to have interior lists for each row
01:29 - right so we want to have a list that
01:30 - represent
01:31 - what each row is going to have inside of
01:33 - it and we'll just do that by appending
01:34 - one
01:35 - for each row that we have next what
01:38 - we're going to say
01:38 - is if call mod 2 equals equals
01:42 - a little bit of fancy math here row plus
01:45 - 1
01:46 - mod 2 what this is saying essentially is
01:50 - if the current column that we are on
01:53 - modulus two so if it's divisible by two
01:55 - if that equals whatever the row plus one
01:58 - so say we're on row zero
01:59 - technically we're on row one mod two
02:02 - then
02:02 - what we can actually do is we can draw
02:04 - the red or white cube
02:06 - now if we look at the checkerboard i'll
02:08 - kind of explain to you how this works by
02:10 - going through a few examples
02:11 - so on when row is i'm trying to be able
02:13 - to view the code at the same time
02:15 - so when geez bring back my pi game
02:19 - uh we've got two of them open let's
02:20 - close one okay there we go
02:23 - so let's say row is zero we're on the
02:24 - first row then
02:26 - the uh row plus one mod two is going to
02:29 - be equal to one right so that here
02:31 - that i can't highlight unless it will
02:32 - put away this is equal to
02:34 - one and then call so if we're on column
02:37 - zero in this case
02:38 - call mod two will not be equal to that
02:40 - so that'll be this first square here
02:41 - this red one so we won't draw the
02:43 - checker
02:44 - all right i think that's why you call it
02:45 - like a checker piece i guess and then
02:47 - the next cube over
02:48 - right so the row stays the same but the
02:50 - column now is column one
02:52 - mod two so that's equal to it so we draw
02:54 - white all right
02:55 - move next now it's column two so we're
02:58 - not drawing that
02:59 - next we go column three we will be
03:01 - drawing that so on so forth
03:03 - now you increment the row when you
03:05 - increment the row what happens is row
03:07 - plus one so one plus one is two
03:08 - mod two is equal to zero which means
03:11 - we'll only draw on the even columns
03:13 - right and then the next one will draw on
03:15 - the odd columns
03:16 - so that's kind of how this is going to
03:18 - work and that's like the basis behind
03:20 - this math that i'm explaining okay so in
03:23 - this case
03:24 - we can draw so if this happens we can
03:26 - draw something but we only want to draw
03:29 - when we're in a certain row
03:30 - so we have to say if row is less than 3
03:34 - because 0 1 2 are the first three rows
03:37 - that we want to draw the white pieces in
03:39 - then what we will do is we'll say and
03:41 - we're not actually drawing here we're
03:42 - just creating the pieces but
03:43 - same promise we'll say dot board
03:47 - row dot append and we'll create a piece
03:51 - and what will what will we do here we'll
03:53 - say row
03:55 - column and then the color we're going to
03:57 - put here is going to be white
04:00 - so i think i imported white i did not so
04:02 - first of all let's import calls properly
04:04 - and now let's import white
04:06 - okay so black row red square size calls
04:08 - white great and then we can append
04:10 - white in there l if row
04:13 - is um i guess we'll say less than
04:17 - should be five six seven is where so if
04:19 - we say if rho is less than
04:21 - four then we'll simply continue
04:26 - uh actually let's just do this
04:29 - if row is greater than four so if row is
04:32 - five six or seven then we can say
04:35 - self.board
04:37 - row dot append
04:40 - piece row call red
04:44 - so hopefully this makes sense uh and we
04:46 - need to import piece which we'll do in a
04:48 - second
04:48 - but the idea being that we're just
04:50 - creating this board we're gonna do it
04:52 - with the checkerboard pattern
04:53 - and then obviously we're not going to do
04:55 - anything
04:56 - in the rows that are three or four
05:01 - what am i saying three or four yeah in
05:03 - rows three or four we are not going to
05:04 - add any pieces
05:06 - now when we don't add a piece though
05:08 - what i want to do
05:09 - is i actually want to add a zero instead
05:12 - so i'm going to say else
05:13 - and in this case we're going to say
05:14 - self.board
05:17 - row dot append 0.
05:20 - the reason for this is that's just going
05:21 - to be like our blank piece like we'll
05:23 - have
05:24 - zero white zero white zero white so we
05:26 - can keep track of
05:28 - by looking at the board what row and
05:29 - column each piece is in
05:31 - by having these kind of blank separators
05:33 - next we're going to say
05:34 - else self
05:38 - dot board row dot append
05:42 - zero so essentially if we don't add a
05:45 - piece
05:45 - we are going to add a zero so that we
05:47 - can separate the pieces and be able to
05:49 - look at this list and figure out where
05:50 - the pieces are now we need to import
05:52 - piece so let's say from
05:55 - dot piece import
05:58 - piece like that okay so that should be
06:02 - good that should create the board for us
06:05 - now what i want to do just to make sure
06:06 - this is working is actually draw the
06:09 - board
06:09 - so i'm going to make a new method here
06:11 - called draw and what this is going to do
06:13 - is say
06:14 - self win and this will draw all of the
06:16 - pieces
06:17 - and the squares so this is going to say
06:21 - self.drawsquares
06:22 - so we'll draw the squares on the window
06:24 - and then we'll loop through all the
06:25 - pieces and draw those
06:26 - so let's say 4 row in
06:30 - oops range
06:33 - if we can do this here for row in range
06:38 - all capital rows and then we'll say
06:42 - for call and range all capital
06:45 - calls what we'll do is loop through
06:48 - the board so we'll say piece
06:54 - equals self dot board
06:57 - row column like that
07:00 - we'll say if piece does not equal zero
07:04 - because if the piece is zero obviously
07:06 - we're not going to draw anything right
07:07 - so if the piece does not equal zero
07:10 - then piece dot draw
07:14 - on the window so i think that should be
07:17 - good
07:18 - let's test this so i'm going to go to
07:20 - main now and rather than board.draw
07:22 - squares
07:23 - i'm just going to call board.draw and
07:25 - let's just make
07:26 - a quick test here and see if we crash
07:29 - invalid
07:30 - syntax where is the invalid syntax okay
07:33 - so i don't know what arrow is having but
07:34 - i managed to
07:35 - fix it i think it was because i was
07:37 - actually in the python console
07:38 - accidentally
07:39 - but anyways when i'm running this i'm
07:40 - getting an error now that says list
07:42 - index out of
07:43 - range now the reason for that is that we
07:45 - have this create board method
07:47 - but we haven't called it so i haven't
07:48 - actually created a board so we have
07:50 - this draw that's trying to loop through
07:52 - all these rows and columns yet they
07:53 - don't exist in the board so let's
07:55 - actually fix that by saying
07:57 - self dot create board inside of our init
08:00 - so that right when this object gets
08:01 - created we automatically create the
08:03 - board
08:03 - let's try this now and pie game is
08:07 - not defined okay so i guess i didn't
08:10 - import pie game inside of some place
08:13 - here that would be inside a piece
08:14 - so let's say import pie game like that
08:18 - inside of our piece module file whatever
08:20 - you want to call it
08:22 - okay now we can run it and there we go
08:24 - we can see our red
08:25 - and white pieces and they look to be
08:27 - working fine
08:29 - now i'm not a fan of how big these are
08:31 - so i'm going to make them a little bit
08:32 - smaller
08:33 - we can do that really easily by just
08:34 - changing our padding right so if i
08:36 - change the padding to 15
08:38 - and run this file now we can see they
08:40 - move down a little bit
08:42 - and you guys can experiment those make
08:44 - those bigger smaller whatever you like
08:46 - okay so i think that is good for right
08:49 - now
08:50 - next what we're going to do is we are
08:52 - going to actually work i guess
08:53 - on a bit of the logic of the game so we
08:55 - have
08:56 - now the ability to draw these things we
08:58 - can see everything now we need to
09:00 - actually move them
09:01 - figure out the valid moves for each
09:03 - piece as well as we need to figure out
09:04 - what happens if one of these pieces
09:06 - is a king so first thing i'm going to do
09:09 - actually
09:09 - is start working on how we can draw the
09:11 - crown for a king piece
09:13 - we'll test that out and then we'll get
09:15 - into the logic
09:16 - so to make a king first what we're going
09:18 - to need to do is we're actually i need
09:20 - to download an asset for a little crown
09:22 - that we will draw
09:23 - on our piece if it is a king piece so
09:25 - let me see if i can bring
09:26 - this up for you i have an image of it
09:29 - i'm going to pop it over here
09:31 - you can see this is what the crown looks
09:32 - like it's a transparent background
09:34 - so go to the link in the description it
09:36 - will say like download asset here or
09:38 - something
09:39 - you're going to download a compressed
09:41 - zip folder what you need to do is
09:43 - right click on that compressed zip
09:45 - folder press
09:47 - uncompress or unzip here so just make it
09:50 - so that you don't have that like
09:51 - zipped up folder anymore it's an
09:53 - unzipped folder and then take that
09:55 - unzipped folder it should be called
09:57 - assets and just put it inside of this
10:00 - directory right here so inside of this
10:02 - checkers directory so it's going to go
10:04 - inside of the checkers directory
10:07 - not like inside of the root directory
10:10 - although you could put it inside the
10:11 - root directory but we're just going to
10:12 - put it inside of this checkers directory
10:14 - so let me actually do that i need to
10:16 - grab that folder so i'm just going to
10:18 - look for it on my system so i have
10:19 - assets right here
10:21 - i'm going to copy that and i'll put that
10:23 - into
10:24 - my checkers folder like that so now we
10:27 - have the assets
10:28 - and is this inside of the right one yes
10:30 - it is now we should be able to
10:32 - load it so what i'm going to do is
10:34 - inside of constants.pi
10:36 - i'm actually going to load that image so
10:38 - i'm simply going to say
10:40 - crown equals pygame
10:43 - dot image dot load and i'm gonna load
10:48 - assets slash crown
10:51 - dot and in this case i think it is png
10:54 - okay
10:55 - so we'll go crown dot png now what i
10:58 - need to do actually is i need to resize
11:00 - this
11:01 - so it's actually too big by default we
11:03 - need to make it small enough that it
11:04 - will fit
11:05 - on the actual check checkers pieces so
11:08 - to do that we're just going to use a
11:09 - method from pi game
11:11 - i just have to find it because i forget
11:12 - exactly what it is we're going to say
11:14 - pie game
11:15 - dot transform i think
11:20 - is it pie game dot transform or pie game
11:22 - dot image
11:24 - no and it's pie game dot transform dot
11:27 - scale
11:29 - and what we do is we put the image first
11:31 - and then we put the resolution that we
11:33 - want to scale it to
11:35 - so i've just kind of hard coded these
11:36 - numbers in you could do this
11:37 - mathematically i guess but
11:39 - i'm going to go with 45 and 25 this
11:42 - relatively keeps the aspect ratio of
11:45 - this image
11:46 - and it makes it small enough that we can
11:47 - actually put it on the direct center of
11:49 - all of our pieces and we can tell them
11:51 - hey you know
11:52 - this is a king piece so i'm going to
11:54 - make this sorry capital again don't know
11:55 - why i made that lowercase
11:57 - and now let's go to piece and from
12:00 - constants import red white square size
12:02 - gray
12:02 - and crown inside of the draw
12:05 - we're going to add a really basic if
12:09 - uh the piece is king so if self.king
12:12 - then what we will do is we'll say win
12:16 - dot blitz the crown
12:19 - blitz simply means put some image onto
12:22 - the screen or put some surface
12:24 - onto the screen that's what it's saying
12:25 - these are just special pie game methods
12:27 - to draw
12:27 - directly onto the display whereas this
12:29 - one where you know just blitting the
12:31 - image
12:31 - and then we need to pick our xy position
12:33 - that we want to put this on
12:35 - now i want this to be perfectly centered
12:36 - so i'm going to use a little bit of math
12:38 - here to do this
12:39 - what we're going to say is self dot x
12:42 - minus
12:43 - crown dot get underscore with get
12:46 - underscore width is going to get the
12:48 - width of the image now we already know
12:50 - what the width of the image
12:51 - is but what i'm trying to say here is
12:53 - that let me actually just go to
12:54 - a kind of drawing whiteboard so i can
12:59 - show you what i mean if we have a square
13:02 - okay
13:02 - got it come on let me draw
13:05 - why can't i draw okay so apparently uh
13:08 - windows or microsoft ink just
13:10 - doesn't work so i can't draw the thing
13:12 - for you right now i don't know the
13:13 - solution to that
13:14 - what i'm trying to say is imagine that
13:16 - the x and y position you'd have to
13:18 - imagine the x and y position we have
13:20 - is in the middle of the square so let me
13:23 - just load
13:23 - the other game and at least i can maybe
13:25 - show this to you so the xy position is
13:28 - right in the middle so where my mouse is
13:30 - now we want to draw the crown right in
13:32 - the middle so it's perfectly centered
13:34 - but if i just draw at the x y it's going
13:36 - to move the crown it'll be kind of to
13:38 - the right because the x
13:39 - y is the top left of an image when we're
13:42 - drawing it other than
13:43 - a circle right where we have the radius
13:46 - so i can't just draw it at the x
13:48 - y i need to draw it someplace to the
13:50 - left and
13:51 - up a bit such that it will be perfectly
13:53 - equal distance from this left side and
13:55 - the right side of the circle
13:57 - so all i have to do is get the width of
13:59 - the image and subtract
14:01 - half of that to figure out where the
14:03 - starting x position should be
14:05 - because that will say okay from this
14:06 - point if this is the center we just move
14:08 - half of the image's width to the left
14:10 - and that will mean that it's being drawn
14:12 - perfectly center
14:13 - in the cube or on the circle same thing
14:16 - with the y position we can do that as
14:17 - well to make sure it happens perfectly
14:19 - in the center
14:19 - so that's what we'll do we'll say self.x
14:22 - minus crown.get
14:23 - underscore with integer division two
14:25 - just so we don't have any rounding
14:26 - errors
14:27 - then we'll say self.y minus
14:30 - crown dot get underscore height
14:34 - over over two great so that should draw
14:37 - the crown for us
14:38 - in the middle so what i'll do is just
14:40 - set all of these crowns to be true
14:42 - just so we can make sure that this is
14:43 - working and test it out
14:46 - uh pygame.transform has no attribute
14:49 - scale well it would help if i spelt
14:51 - scale correctly so scale there we go
14:55 - all right let's check check this now
14:58 - cannot load assets slash crown dot png
15:03 - okay so let's try to fix this
15:06 - um i believe the issue we're having
15:10 - is something to do with kind of the path
15:11 - system in python
15:13 - so what i'm going to do is just take
15:14 - this folder and put it outside so put it
15:17 - in the main
15:18 - root directory rather than inside of the
15:20 - checkers directly
15:21 - directory and now it should probably
15:24 - load so let's try this now
15:25 - and there we go that is working just to
15:28 - reemphasize what was happening there
15:30 - this i had assets crown.png i had that
15:34 - folder
15:34 - inside of this checkers folder i
15:36 - specifically told you to put it there
15:37 - but
15:38 - i was wrong so what we need to do is
15:40 - take it out
15:41 - and just put it alongside the checkers
15:44 - directory so it's in that root directory
15:46 - because when we run this main.pi file
15:48 - that's not inside of the checkers folder
15:50 - the path that python will look at to
15:53 - load images will be in this directory
15:55 - where we loaded main.pi
15:58 - so i would have to say checkers slash
16:00 - assets slash
16:01 - if i wanted to load the image the way
16:03 - that we were doing it before without
16:05 - moving
16:05 - this folder anyways not a huge deal but
16:08 - hopefully that's loading for us
16:09 - and i think that this is working fine we
16:12 - can see the crown on all of the pieces
16:14 - again perfectly in the center alright so
16:17 - let's
16:17 - go back and remove that now so peace
16:21 - we no longer want to draw the crown
16:24 - so we will say false and now i gotta
16:26 - figure out what we are going to do
16:29 - next so i'm thinking probably what we
16:31 - should do next is actually set up a way
16:34 - to move pieces around and delete pieces
16:37 - so from board what i'm going to do is
16:38 - i'm going to make a move
16:40 - method so i'm going to say define move
16:43 - i'm going to say self
16:44 - and i'm going to say piece so you tell
16:47 - me the piece you want to move and what
16:49 - row and column you want to move it to
16:51 - now what we'll have to do to move the
16:53 - piece is we'll have to
16:54 - delete the piece from where it is and
16:56 - we'll have to change its position
16:58 - so that reminds me that we actually need
17:00 - to go to piece and we need to add a move
17:02 - method as well so define
17:04 - move like this self row
17:07 - call so what will happen when we move a
17:10 - piece well we're going to have to say
17:11 - self dot row equals the new row right
17:14 - because this needs to say updated
17:16 - self.call equals the new call and then
17:20 - self.calc position so remember calc
17:23 - position which is right here
17:24 - simply tells us what the xy position of
17:27 - our piece should be
17:28 - so we have to recalculate that when we
17:30 - change our row and column so we have
17:31 - move now on piece
17:33 - so board what we'll need to do is we'll
17:35 - actually need to
17:36 - first of all move the piece within the
17:38 - list right because we have this
17:39 - list that represents all our pieces and
17:42 - then we'll have to
17:43 - also actually change the piece itself so
17:46 - piece dot move to wherever it's going to
17:48 - go to update on the pieces side
17:50 - all right so what we'll do is we will
17:53 - say
17:55 - self.board and we're going to say
17:59 - peace.row
18:02 - peace.call comma self.board
18:07 - row call
18:10 - equals and we're going to say self.board
18:14 - and we're literally going to copy these
18:15 - just
18:15 - in reverse so i'll talk about how this
18:17 - works but this is a easy way to swap
18:20 - things in python or swap positions in a
18:22 - list
18:24 - so what i'm saying with this line here
18:25 - and i'll zoom out so you guys can read
18:27 - it is essentially that
18:29 - the piece that's in the position
18:32 - piece.row peace.call so the one we want
18:34 - to move and i need to spell
18:36 - piece correctly and then the piece
18:38 - that's in the position that we want to
18:39 - move to
18:40 - we're going to swap their values by
18:42 - simply reversing it like this
18:44 - so this piece here will move to this one
18:47 - here so row call
18:48 - and then the other one will move to this
18:50 - one so they'll essentially swap
18:52 - that's just how this works and this
18:54 - means we don't need to make like a temp
18:55 - variable
18:56 - delete something re-add it in all that
18:58 - that we would usually have to do
19:00 - all right so now that we have that what
19:02 - we'll actually do is we'll say self.
19:06 - actually we don't need itself we'll just
19:07 - say piece
19:09 - dot move row column
19:13 - there we go so if uh or not if but
19:16 - when we move this actual piece we'll
19:18 - just move it row
19:20 - column now i just want to look and make
19:22 - sure i've done this
19:24 - correctly i think we have but there
19:26 - might be some other things that we want
19:28 - to consider here
19:29 - all right so now we've moved the piece
19:32 - this
19:32 - should actually work we'll test this out
19:34 - after but we need to do is make sure
19:36 - that we haven't moved
19:38 - well we don't need to check that we need
19:40 - to make sure
19:41 - if we've moved into a position where
19:43 - we'll become a king
19:44 - we become a king right so if we move and
19:46 - we hit the last row
19:48 - or the first row then whatever our piece
19:51 - is should become
19:52 - a king so what we can simply do is just
19:54 - check if the row column that we moved to
19:57 - is actually a position that should make
19:58 - us a king and if it is then we will make
20:01 - that piece a king
20:02 - and we will also update the variables we
20:04 - have here for the amount of kings that
20:06 - we have
20:06 - so what i'm going to say is if piece
20:10 - dot row or i guess we could actually
20:11 - just say row if row
20:13 - equals equals rows or row equals equals
20:17 - zero
20:18 - what we can do and say self are not self
20:21 - peace dot make
20:25 - not make move make king
20:28 - so this will make that piece a king and
20:30 - then we'll need to update the red
20:31 - or black is it red red or white kings
20:35 - so the reason this works is because if
20:37 - we move into a position that is 0 or 7
20:40 - for the row
20:42 - that means that we are at the end or the
20:44 - beginning of the board now some of you
20:45 - might be asking well won't this break
20:46 - because we already have pieces
20:49 - in those positions that are the same
20:51 - color right so like the white piece
20:52 - is already in row 0 and the red pieces
20:55 - are already in
20:57 - row 7 or row 8 whatever you want to call
20:59 - it
21:00 - so won't those just become kings well no
21:02 - they won't because they have to move
21:04 - into that position so we're not going to
21:06 - let them move backwards
21:07 - unless they're a king which means that
21:10 - they won't become a king
21:12 - unless they actually move to the other
21:14 - side of the board from where they start
21:16 - at now there will be a situation where a
21:18 - king will move into
21:20 - not its own side and become a king again
21:22 - but that's fine
21:23 - if it's already a king there's no
21:25 - difference in making it a king again
21:27 - right it's not
21:28 - double kinging or anything like that all
21:30 - right so if row equals equals rows or
21:32 - row equals equals zero
21:33 - p stop make king we need to update the
21:35 - red and uh
21:37 - white king so if peace dot color
21:41 - equals equals white then self.whitekings
21:45 - plus equals one else so if it's not
21:48 - white it must be
21:49 - red self.red kings
21:53 - plus equals one okay so that should be
21:55 - it for
21:56 - move what we can do now is check to make
21:58 - sure this is working
22:00 - so what we'll do is just simply put
22:02 - inside of this
22:05 - actually we'll just do it right here say
22:07 - board dot move
22:08 - ah and now we run to our first problem
22:11 - we need a piece right
22:13 - we actually need to pass a piece object
22:16 - like this to this move function or move
22:19 - method so that it can move it so how am
22:20 - i actually going to get a piece
22:22 - well we'll write a method here that says
22:24 - define get
22:26 - underscore piece and we'll say self
22:29 - row call so essentially you give this
22:32 - board object a row and a column
22:34 - and it will give you a piece back so
22:36 - this will simply return
22:38 - dot board row call
22:42 - all right so now let's just say
22:47 - piece equals
22:50 - board dot get piece and let's pass a row
22:53 - and column we know there's going to be a
22:54 - piece in
22:55 - so in this case i believe there's one in
22:57 - 0 1 because i don't think it starts in
22:59 - the top left corner
23:00 - so we'll get a piece at 0 1 and then
23:02 - we'll say board
23:03 - dot move that piece right here
23:08 - and let's move this to i don't know
23:10 - where do we want to move this somewhere
23:11 - where there's not already a piece let's
23:12 - go
23:14 - row 4 column
23:17 - 3. all right so that should move it into
23:20 - the center of the board
23:21 - or relatively into the center of board
23:23 - and
23:24 - what is it saying oh missing one
23:26 - required positional argument column
23:28 - so oops i shouldn't have put these in a
23:30 - tuple i should just have them separated
23:32 - out like this so four three
23:34 - let's run this now and what is the other
23:36 - one piece is not defined well it would
23:38 - help if i spelt piece correctly where is
23:40 - it telling me this is undefined
23:42 - uh it is undefined here looks like
23:46 - yeah piece is spelt wrong okay so let's
23:48 - go back to board
23:50 - let's go to move and let's fix that
23:54 - there we go okay run work and there we
23:57 - go we can see that now that piece here
23:59 - is moved over here
24:00 - so this move method does work now we
24:03 - want to figure out a way that we can do
24:04 - it using our mouse right
24:06 - so this will be a bit more complicated
24:07 - but very doable and the next part of
24:09 - this
24:10 - series here or this video so what i'm
24:12 - going to do is i'm going to make a
24:13 - method that says define
24:15 - get row underscore call from
24:19 - mouse so this will simply take the
24:22 - position of our mouse and it will tell
24:24 - us based on the position of our mouse
24:26 - what row and column we're in so we're
24:28 - going to say x y equals position
24:31 - because this is going to be a tuple that
24:32 - will have the x position of our mouse
24:34 - and the y position of our mouse and then
24:36 - based on the square size we can
24:38 - calculate really easily
24:39 - what row and column we're in so we can
24:41 - simply say well we'll make a bit easier
24:43 - we'll say row
24:44 - equals y integer divided by
24:47 - square size so this is really easy right
24:50 - and we need to import square size but if
24:52 - the square size is 100 and we're trying
24:54 - to figure out what row we're in
24:55 - if our y is at 650 then we know we must
24:58 - be in row
24:59 - six right and if our y is 700 we must be
25:03 - in row seven right
25:04 - it's pretty straightforward so that is
25:06 - how this works that's how we get the row
25:08 - and the column just a little bit of
25:09 - division so we say
25:10 - call xx or divide divided by
25:14 - square size now we'll need to import
25:17 - square size like that and we can return
25:20 - the row column great so get row column
25:24 - from mouse position
25:25 - now what we'll do is when we press the
25:28 - mouse down we will get what row in
25:30 - column we're in
25:31 - we will select that piece and then we
25:33 - will move that piece
25:35 - to wherever we want to move so we'll be
25:37 - able to select the piece and then we can
25:38 - select where we want to move it to
25:40 - so if pygame dot mouse button down then
25:43 - we will say
25:44 - row call equals and first we'll say
25:47 - position
25:47 - equals pi game dot mouse
25:51 - dot get underscore pause this will get
25:53 - the mouse position
25:54 - say row call equals get row call from
25:58 - mouse
25:59 - position then we can get the piece
26:01 - associated with this so we can say piece
26:03 - equals and we can say
26:07 - board dot get piece
26:11 - row column and we can move it now
26:14 - what i'll do right now is just because i
26:16 - don't want to code everything
26:18 - is i will simply just move whatever
26:19 - piece we select to the same position so
26:22 - we'll just move it to four
26:23 - 3 just so you can see that this does
26:25 - work when we
26:26 - press on the piece um but we will
26:28 - obviously make it so that
26:30 - you're moving it where you want to move
26:31 - it afterwards okay so let's just test
26:33 - this out and make sure this works
26:36 - so if i select this piece you can see
26:38 - that all these pieces
26:39 - obviously are going to be hidden by that
26:40 - white piece because that's there
26:42 - but they get moved to that
26:45 - position so when i press them they move
26:48 - there again
26:49 - obviously all of them are moving to the
26:50 - same one so you can't really see but
26:52 - that is
26:52 - how this works

Cleaned transcript:

okay so now we have peace and if we want to see them well we need to start creating some pieces so inside of my board class under create board i'm going to create a bunch of pieces we're going to start obviously by making the white pieces will be at the top and then the red pieces at the bottom so this is not too complicated but it is a little bit of a for loop kind of in indentation thing that you'll see here because we need to obviously have them be spread out we're only going to have i believe four in each row and then they need to be staggering and then the white needs to go up there there needs to be a space and then it needs to be the black or the red sorry the white and then the red my bad all right so four row in range rows for call in range calls we can import calls up here technically again i mean i can change this here to be calls doesn't matter because they are the same value but say we had a checkerboard that wasn't exactly square then these would matter so four range or four row in range rows four call in range calls what we're going to do is we're going to start by saying self self dot board dot append and empty list the reason for this is because we want to have interior lists for each row right so we want to have a list that represent what each row is going to have inside of it and we'll just do that by appending one for each row that we have next what we're going to say is if call mod 2 equals equals a little bit of fancy math here row plus 1 mod 2 what this is saying essentially is if the current column that we are on modulus two so if it's divisible by two if that equals whatever the row plus one so say we're on row zero technically we're on row one mod two then what we can actually do is we can draw the red or white cube now if we look at the checkerboard i'll kind of explain to you how this works by going through a few examples so on when row is i'm trying to be able to view the code at the same time so when geez bring back my pi game uh we've got two of them open let's close one okay there we go so let's say row is zero we're on the first row then the uh row plus one mod two is going to be equal to one right so that here that i can't highlight unless it will put away this is equal to one and then call so if we're on column zero in this case call mod two will not be equal to that so that'll be this first square here this red one so we won't draw the checker all right i think that's why you call it like a checker piece i guess and then the next cube over right so the row stays the same but the column now is column one mod two so that's equal to it so we draw white all right move next now it's column two so we're not drawing that next we go column three we will be drawing that so on so forth now you increment the row when you increment the row what happens is row plus one so one plus one is two mod two is equal to zero which means we'll only draw on the even columns right and then the next one will draw on the odd columns so that's kind of how this is going to work and that's like the basis behind this math that i'm explaining okay so in this case we can draw so if this happens we can draw something but we only want to draw when we're in a certain row so we have to say if row is less than 3 because 0 1 2 are the first three rows that we want to draw the white pieces in then what we will do is we'll say and we're not actually drawing here we're just creating the pieces but same promise we'll say dot board row dot append and we'll create a piece and what will what will we do here we'll say row column and then the color we're going to put here is going to be white so i think i imported white i did not so first of all let's import calls properly and now let's import white okay so black row red square size calls white great and then we can append white in there l if row is um i guess we'll say less than should be five six seven is where so if we say if rho is less than four then we'll simply continue uh actually let's just do this if row is greater than four so if row is five six or seven then we can say self.board row dot append piece row call red so hopefully this makes sense uh and we need to import piece which we'll do in a second but the idea being that we're just creating this board we're gonna do it with the checkerboard pattern and then obviously we're not going to do anything in the rows that are three or four what am i saying three or four yeah in rows three or four we are not going to add any pieces now when we don't add a piece though what i want to do is i actually want to add a zero instead so i'm going to say else and in this case we're going to say self.board row dot append 0. the reason for this is that's just going to be like our blank piece like we'll have zero white zero white zero white so we can keep track of by looking at the board what row and column each piece is in by having these kind of blank separators next we're going to say else self dot board row dot append zero so essentially if we don't add a piece we are going to add a zero so that we can separate the pieces and be able to look at this list and figure out where the pieces are now we need to import piece so let's say from dot piece import piece like that okay so that should be good that should create the board for us now what i want to do just to make sure this is working is actually draw the board so i'm going to make a new method here called draw and what this is going to do is say self win and this will draw all of the pieces and the squares so this is going to say self.drawsquares so we'll draw the squares on the window and then we'll loop through all the pieces and draw those so let's say 4 row in oops range if we can do this here for row in range all capital rows and then we'll say for call and range all capital calls what we'll do is loop through the board so we'll say piece equals self dot board row column like that we'll say if piece does not equal zero because if the piece is zero obviously we're not going to draw anything right so if the piece does not equal zero then piece dot draw on the window so i think that should be good let's test this so i'm going to go to main now and rather than board.draw squares i'm just going to call board.draw and let's just make a quick test here and see if we crash invalid syntax where is the invalid syntax okay so i don't know what arrow is having but i managed to fix it i think it was because i was actually in the python console accidentally but anyways when i'm running this i'm getting an error now that says list index out of range now the reason for that is that we have this create board method but we haven't called it so i haven't actually created a board so we have this draw that's trying to loop through all these rows and columns yet they don't exist in the board so let's actually fix that by saying self dot create board inside of our init so that right when this object gets created we automatically create the board let's try this now and pie game is not defined okay so i guess i didn't import pie game inside of some place here that would be inside a piece so let's say import pie game like that inside of our piece module file whatever you want to call it okay now we can run it and there we go we can see our red and white pieces and they look to be working fine now i'm not a fan of how big these are so i'm going to make them a little bit smaller we can do that really easily by just changing our padding right so if i change the padding to 15 and run this file now we can see they move down a little bit and you guys can experiment those make those bigger smaller whatever you like okay so i think that is good for right now next what we're going to do is we are going to actually work i guess on a bit of the logic of the game so we have now the ability to draw these things we can see everything now we need to actually move them figure out the valid moves for each piece as well as we need to figure out what happens if one of these pieces is a king so first thing i'm going to do actually is start working on how we can draw the crown for a king piece we'll test that out and then we'll get into the logic so to make a king first what we're going to need to do is we're actually i need to download an asset for a little crown that we will draw on our piece if it is a king piece so let me see if i can bring this up for you i have an image of it i'm going to pop it over here you can see this is what the crown looks like it's a transparent background so go to the link in the description it will say like download asset here or something you're going to download a compressed zip folder what you need to do is right click on that compressed zip folder press uncompress or unzip here so just make it so that you don't have that like zipped up folder anymore it's an unzipped folder and then take that unzipped folder it should be called assets and just put it inside of this directory right here so inside of this checkers directory so it's going to go inside of the checkers directory not like inside of the root directory although you could put it inside the root directory but we're just going to put it inside of this checkers directory so let me actually do that i need to grab that folder so i'm just going to look for it on my system so i have assets right here i'm going to copy that and i'll put that into my checkers folder like that so now we have the assets and is this inside of the right one yes it is now we should be able to load it so what i'm going to do is inside of constants.pi i'm actually going to load that image so i'm simply going to say crown equals pygame dot image dot load and i'm gonna load assets slash crown dot and in this case i think it is png okay so we'll go crown dot png now what i need to do actually is i need to resize this so it's actually too big by default we need to make it small enough that it will fit on the actual check checkers pieces so to do that we're just going to use a method from pi game i just have to find it because i forget exactly what it is we're going to say pie game dot transform i think is it pie game dot transform or pie game dot image no and it's pie game dot transform dot scale and what we do is we put the image first and then we put the resolution that we want to scale it to so i've just kind of hard coded these numbers in you could do this mathematically i guess but i'm going to go with 45 and 25 this relatively keeps the aspect ratio of this image and it makes it small enough that we can actually put it on the direct center of all of our pieces and we can tell them hey you know this is a king piece so i'm going to make this sorry capital again don't know why i made that lowercase and now let's go to piece and from constants import red white square size gray and crown inside of the draw we're going to add a really basic if uh the piece is king so if self.king then what we will do is we'll say win dot blitz the crown blitz simply means put some image onto the screen or put some surface onto the screen that's what it's saying these are just special pie game methods to draw directly onto the display whereas this one where you know just blitting the image and then we need to pick our xy position that we want to put this on now i want this to be perfectly centered so i'm going to use a little bit of math here to do this what we're going to say is self dot x minus crown dot get underscore with get underscore width is going to get the width of the image now we already know what the width of the image is but what i'm trying to say here is that let me actually just go to a kind of drawing whiteboard so i can show you what i mean if we have a square okay got it come on let me draw why can't i draw okay so apparently uh windows or microsoft ink just doesn't work so i can't draw the thing for you right now i don't know the solution to that what i'm trying to say is imagine that the x and y position you'd have to imagine the x and y position we have is in the middle of the square so let me just load the other game and at least i can maybe show this to you so the xy position is right in the middle so where my mouse is now we want to draw the crown right in the middle so it's perfectly centered but if i just draw at the x y it's going to move the crown it'll be kind of to the right because the x y is the top left of an image when we're drawing it other than a circle right where we have the radius so i can't just draw it at the x y i need to draw it someplace to the left and up a bit such that it will be perfectly equal distance from this left side and the right side of the circle so all i have to do is get the width of the image and subtract half of that to figure out where the starting x position should be because that will say okay from this point if this is the center we just move half of the image's width to the left and that will mean that it's being drawn perfectly center in the cube or on the circle same thing with the y position we can do that as well to make sure it happens perfectly in the center so that's what we'll do we'll say self.x minus crown.get underscore with integer division two just so we don't have any rounding errors then we'll say self.y minus crown dot get underscore height over over two great so that should draw the crown for us in the middle so what i'll do is just set all of these crowns to be true just so we can make sure that this is working and test it out uh pygame.transform has no attribute scale well it would help if i spelt scale correctly so scale there we go all right let's check check this now cannot load assets slash crown dot png okay so let's try to fix this um i believe the issue we're having is something to do with kind of the path system in python so what i'm going to do is just take this folder and put it outside so put it in the main root directory rather than inside of the checkers directly directory and now it should probably load so let's try this now and there we go that is working just to reemphasize what was happening there this i had assets crown.png i had that folder inside of this checkers folder i specifically told you to put it there but i was wrong so what we need to do is take it out and just put it alongside the checkers directory so it's in that root directory because when we run this main.pi file that's not inside of the checkers folder the path that python will look at to load images will be in this directory where we loaded main.pi so i would have to say checkers slash assets slash if i wanted to load the image the way that we were doing it before without moving this folder anyways not a huge deal but hopefully that's loading for us and i think that this is working fine we can see the crown on all of the pieces again perfectly in the center alright so let's go back and remove that now so peace we no longer want to draw the crown so we will say false and now i gotta figure out what we are going to do next so i'm thinking probably what we should do next is actually set up a way to move pieces around and delete pieces so from board what i'm going to do is i'm going to make a move method so i'm going to say define move i'm going to say self and i'm going to say piece so you tell me the piece you want to move and what row and column you want to move it to now what we'll have to do to move the piece is we'll have to delete the piece from where it is and we'll have to change its position so that reminds me that we actually need to go to piece and we need to add a move method as well so define move like this self row call so what will happen when we move a piece well we're going to have to say self dot row equals the new row right because this needs to say updated self.call equals the new call and then self.calc position so remember calc position which is right here simply tells us what the xy position of our piece should be so we have to recalculate that when we change our row and column so we have move now on piece so board what we'll need to do is we'll actually need to first of all move the piece within the list right because we have this list that represents all our pieces and then we'll have to also actually change the piece itself so piece dot move to wherever it's going to go to update on the pieces side all right so what we'll do is we will say self.board and we're going to say peace.row peace.call comma self.board row call equals and we're going to say self.board and we're literally going to copy these just in reverse so i'll talk about how this works but this is a easy way to swap things in python or swap positions in a list so what i'm saying with this line here and i'll zoom out so you guys can read it is essentially that the piece that's in the position piece.row peace.call so the one we want to move and i need to spell piece correctly and then the piece that's in the position that we want to move to we're going to swap their values by simply reversing it like this so this piece here will move to this one here so row call and then the other one will move to this one so they'll essentially swap that's just how this works and this means we don't need to make like a temp variable delete something readd it in all that that we would usually have to do all right so now that we have that what we'll actually do is we'll say self. actually we don't need itself we'll just say piece dot move row column there we go so if uh or not if but when we move this actual piece we'll just move it row column now i just want to look and make sure i've done this correctly i think we have but there might be some other things that we want to consider here all right so now we've moved the piece this should actually work we'll test this out after but we need to do is make sure that we haven't moved well we don't need to check that we need to make sure if we've moved into a position where we'll become a king we become a king right so if we move and we hit the last row or the first row then whatever our piece is should become a king so what we can simply do is just check if the row column that we moved to is actually a position that should make us a king and if it is then we will make that piece a king and we will also update the variables we have here for the amount of kings that we have so what i'm going to say is if piece dot row or i guess we could actually just say row if row equals equals rows or row equals equals zero what we can do and say self are not self peace dot make not make move make king so this will make that piece a king and then we'll need to update the red or black is it red red or white kings so the reason this works is because if we move into a position that is 0 or 7 for the row that means that we are at the end or the beginning of the board now some of you might be asking well won't this break because we already have pieces in those positions that are the same color right so like the white piece is already in row 0 and the red pieces are already in row 7 or row 8 whatever you want to call it so won't those just become kings well no they won't because they have to move into that position so we're not going to let them move backwards unless they're a king which means that they won't become a king unless they actually move to the other side of the board from where they start at now there will be a situation where a king will move into not its own side and become a king again but that's fine if it's already a king there's no difference in making it a king again right it's not double kinging or anything like that all right so if row equals equals rows or row equals equals zero p stop make king we need to update the red and uh white king so if peace dot color equals equals white then self.whitekings plus equals one else so if it's not white it must be red self.red kings plus equals one okay so that should be it for move what we can do now is check to make sure this is working so what we'll do is just simply put inside of this actually we'll just do it right here say board dot move ah and now we run to our first problem we need a piece right we actually need to pass a piece object like this to this move function or move method so that it can move it so how am i actually going to get a piece well we'll write a method here that says define get underscore piece and we'll say self row call so essentially you give this board object a row and a column and it will give you a piece back so this will simply return dot board row call all right so now let's just say piece equals board dot get piece and let's pass a row and column we know there's going to be a piece in so in this case i believe there's one in 0 1 because i don't think it starts in the top left corner so we'll get a piece at 0 1 and then we'll say board dot move that piece right here and let's move this to i don't know where do we want to move this somewhere where there's not already a piece let's go row 4 column 3. all right so that should move it into the center of the board or relatively into the center of board and what is it saying oh missing one required positional argument column so oops i shouldn't have put these in a tuple i should just have them separated out like this so four three let's run this now and what is the other one piece is not defined well it would help if i spelt piece correctly where is it telling me this is undefined uh it is undefined here looks like yeah piece is spelt wrong okay so let's go back to board let's go to move and let's fix that there we go okay run work and there we go we can see that now that piece here is moved over here so this move method does work now we want to figure out a way that we can do it using our mouse right so this will be a bit more complicated but very doable and the next part of this series here or this video so what i'm going to do is i'm going to make a method that says define get row underscore call from mouse so this will simply take the position of our mouse and it will tell us based on the position of our mouse what row and column we're in so we're going to say x y equals position because this is going to be a tuple that will have the x position of our mouse and the y position of our mouse and then based on the square size we can calculate really easily what row and column we're in so we can simply say well we'll make a bit easier we'll say row equals y integer divided by square size so this is really easy right and we need to import square size but if the square size is 100 and we're trying to figure out what row we're in if our y is at 650 then we know we must be in row six right and if our y is 700 we must be in row seven right it's pretty straightforward so that is how this works that's how we get the row and the column just a little bit of division so we say call xx or divide divided by square size now we'll need to import square size like that and we can return the row column great so get row column from mouse position now what we'll do is when we press the mouse down we will get what row in column we're in we will select that piece and then we will move that piece to wherever we want to move so we'll be able to select the piece and then we can select where we want to move it to so if pygame dot mouse button down then we will say row call equals and first we'll say position equals pi game dot mouse dot get underscore pause this will get the mouse position say row call equals get row call from mouse position then we can get the piece associated with this so we can say piece equals and we can say board dot get piece row column and we can move it now what i'll do right now is just because i don't want to code everything is i will simply just move whatever piece we select to the same position so we'll just move it to four 3 just so you can see that this does work when we press on the piece um but we will obviously make it so that you're moving it where you want to move it afterwards okay so let's just test this out and make sure this works so if i select this piece you can see that all these pieces obviously are going to be hidden by that white piece because that's there but they get moved to that position so when i press them they move there again obviously all of them are moving to the same one so you can't really see but that is how this works
