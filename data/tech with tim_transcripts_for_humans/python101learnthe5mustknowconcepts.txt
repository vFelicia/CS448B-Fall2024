With timestamps:

00:00 - [Music]
00:02 - if you're interested in becoming a
00:04 - developer that writes any type of code
00:05 - in Python then you need to understand
00:07 - these five very important python
00:09 - Concepts these are what I see most
00:11 - beginner and intermediate python
00:13 - programmers making a ton of mistakes
00:15 - with and misunderstanding when they're
00:17 - reading through production code the goal
00:19 - of this video is to make sure that when
00:20 - you're reading through production python
00:22 - code you understand what's happening you
00:24 - know the concept and then you can
00:25 - reproduce that code and write your own
00:27 - pull requests and own features using
00:29 - python code that other developers will
00:31 - understand and expect
00:33 - so with that said let's get into the
00:35 - video after I share with you the first
00:37 - very important concept you need to
00:38 - understand which is the sponsor of this
00:41 - video nordpass nordpass is the ultimate
00:44 - password and credential management
00:45 - solution that I've actually been looking
00:47 - for for a long time now I don't know
00:49 - about you guys but I have a lot of
00:51 - passwords credit cards Bank details
00:53 - private Keys Etc and oftentimes I need
00:56 - to share these with my co-workers making
00:58 - it a constant struggle to not only keep
01:00 - this data secure and safe but to allow
01:02 - them to access it quickly without having
01:03 - to message me all the time now nordpass
01:06 - fixes this problem because it allows me
01:07 - to store both my personal or my business
01:09 - data in a single secure location and
01:12 - then give different access to members of
01:14 - my team now if you don't believe me you
01:16 - can check it out from the link in the
01:17 - description and use the code Tech with
01:18 - Tim which means you'll no longer have to
01:20 - be sending messages or receiving
01:22 - messages asking for passwords not to
01:25 - mention the nordpass has features like
01:27 - autofill data breach detection and
01:29 - activity log a password generator and
01:31 - much more check out Nord from the link
01:34 - in the description and use the code
01:35 - tequitim for a three month free trial so
01:38 - you can take control over your data and
01:40 - your accounts thanks again to nordpass
01:42 - for sponsoring this video so the first
01:45 - concept to go over here is mutable
01:46 - versus immutable types now this is the
01:48 - concept that most beginner and
01:50 - intermediate programmers make mistakes
01:51 - with don't worry if you already
01:53 - understand it there's a lot more
01:54 - complicated Concepts so stick around for
01:56 - the rest of the video regardless an
01:58 - immutable type is something that cannot
02:00 - change a mutable type is something that
02:03 - can change an example of these in Python
02:05 - is the following so immutable types are
02:07 - going to be our string our ins our
02:10 - floats our Boolean our bytes type and
02:15 - our topple type all of these are
02:17 - immutable meaning once you define this
02:19 - you cannot change it however we have
02:22 - mutable types in Python which are the
02:24 - list the set and the dictionary and
02:27 - pretty much any other type used from
02:28 - some third-party library or module these
02:31 - can change which means once you find
02:33 - them you can actually modify them let me
02:36 - give you a super quick example here of
02:38 - immutable versus mutable then we'll go
02:40 - into a more complex one using a function
02:42 - which is where I see most beginners make
02:44 - a mistake okay so let's say we have some
02:46 - number like x equals one and we say Y is
02:48 - equal to X and in fact let's change this
02:50 - to a tuple which remember is e mutable
02:53 - meaning we cannot change it actually to
02:56 - quickly show this to you let's try to do
02:57 - something like x0 is equal to one where
02:59 - we're trying to change this Tuple
03:01 - without reassigning something to this
03:04 - variable so if I go here and run my code
03:06 - notice I get an error and it says the
03:08 - Tuple object does not support item
03:10 - assignment now the reason it doesn't
03:12 - support that is because this is
03:13 - immutable that means that once I Define
03:15 - this Tuple I cannot change it now if we
03:18 - go here and do something like Y equals X
03:20 - and let's come and say X
03:23 - is equal
03:24 - to one two three I just want to show you
03:27 - if I print out both X and Y here that my
03:30 - change to X here after assigning X to Y
03:32 - did not affect y the reason for that is
03:35 - whenever you're using immutable types
03:37 - when you do an assignment to another
03:39 - variable so I do something like Y equals
03:41 - X it makes a copy so an actual real copy
03:44 - of this immutable object meaning that if
03:47 - I now go something like X is equal to
03:49 - one two three that's not going to affect
03:51 - y because I'm not modifying what Y is
03:54 - storing I'm just reassigning a new value
03:56 - to X I know that seems trivial but the
03:58 - reason I'm illustrating this to you is
04:00 - because this works differently when we
04:02 - change this to a list
04:04 - so if I change this to a list now and
04:06 - then I come and do something like x 0 is
04:09 - equal to 100
04:12 - you might think that Y is not going to
04:14 - change but when I run this you see that
04:16 - both X and Y have the same value now the
04:18 - reason for that is when you're using
04:20 - mutable types and you do something like
04:22 - Y equals X here so you're signing a
04:24 - variable to another variable and this
04:27 - variable is storing a mutable type what
04:29 - happens is you actually store a
04:30 - reference or an alias to this same
04:33 - object meaning that if I make a change
04:35 - to the object like I'm doing right here
04:37 - it changes for both of these variables
04:39 - because they're actually storing the
04:41 - same object in fact they're storing a
04:43 - reference to the same object so again if
04:45 - you change the underlying object then it
04:47 - changes for both X and Y that's the
04:49 - difference between immutable and mutable
04:51 - types now let me just paste in a quick
04:53 - example here that will illustrate this
04:55 - even a little bit further so you can see
04:56 - in this example we have a function that
04:58 - Returns the largest numbers it Returns
05:00 - the N largest numbers actually what it
05:02 - does is it sorts the list of numbers
05:04 - that it accepts so what I've done down
05:06 - here is I've created a list of numbers I
05:08 - printed out what the value of the list
05:09 - was before I called the function and
05:11 - then I printed out with the value was
05:13 - afterwards now take a guess if you want
05:15 - it what you think the output is going to
05:16 - be but I'll go ahead and run the code
05:18 - and you can see here that we actually
05:20 - get the list before that's unsorted and
05:22 - then the list becomes sorted afterwards
05:24 - now the reason this occurs is because
05:26 - what happens is when we call this
05:28 - function we pass this nums list as the
05:31 - parameter numbers now since we're
05:33 - passing a mutable object a list is
05:35 - mutable when we do a numbers.sort what
05:38 - this does is actually sort the list in
05:40 - place now numbers here is going to be
05:43 - storing a reference to this same list so
05:46 - when I sort the numbers parameter here
05:48 - since I had passed in my numbers array
05:51 - it ends up sorting that numbers array
05:53 - that's down here seems a little bit
05:55 - strange but the reason this is occurring
05:57 - is again because we're using a mutable
05:59 - object so the point here is that you
06:00 - need to understand when you're using
06:02 - mutable versus immutable objects because
06:04 - you could have functions like this that
06:05 - can perform side effects on your mutable
06:08 - objects this is referred to as a side
06:10 - effect because what happens is one of
06:11 - the parameters is being mutated or
06:13 - modified inside of the function
06:15 - sometimes you want that to be the case
06:17 - sometimes you don't want that to be the
06:19 - case you need to be intentional when
06:20 - you're writing your code so the next
06:22 - concept to understand here is list
06:23 - comprehensions now the reason you need
06:25 - to understand this is because it's used
06:27 - quite a bit in Python and oftentimes
06:29 - you'll see people writing fairly
06:31 - complicated comprehensions to simplify a
06:33 - line of code now this can kind of do the
06:36 - reverse sometimes it can actually make
06:37 - it more complicated regardless you need
06:40 - to understand what they are so that you
06:41 - can actually understand them if you see
06:43 - them in some production code so let's
06:45 - have a look at a list comprehension so
06:47 - the most basic comprehension you can do
06:49 - here is something like X or we'll go
06:51 - with i for I in range and then maybe
06:54 - something like 10 and in case you can't
06:57 - guess it here what this is going to do
06:58 - is give me an array that contains the
07:00 - numbers 0 through 9. so let me open up
07:02 - my terminal and run this and there you
07:04 - go we get zero through nine so this is a
07:06 - list comprehension where essentially you
07:08 - write a for Loop inside of a list what
07:10 - you do on the left hand side is you put
07:12 - but the value that you want to populate
07:14 - the list with and then you have some
07:16 - kind of iterator in this case we have a
07:17 - for Loop that's going to Loop through
07:19 - and generate these different values now
07:21 - this is a very simple list comprehension
07:23 - you can make much more complicated ones
07:25 - for example we can have a list here
07:27 - instead so now if I do a list we have a
07:30 - bunch of empty lists inside of this list
07:32 - but just like we have a list
07:33 - comprehension here we can have one
07:35 - inside of this list so I can do
07:36 - something like four so actually let's go
07:39 - with J 4J in range 5 like that and now
07:44 - we have a nested list comprehension and
07:46 - if I run this code you can see that now
07:48 - we get a bunch of lists that contain
07:50 - five different values inside of them 10
07:53 - times okay so that's one thing you can
07:55 - do another thing that we can do here is
07:58 - the following so let's go here and say I
08:01 - for I in range 10 and then we can put in
08:03 - if statement and we can say if I mod 2
08:06 - is equal to zero now this means we're
08:09 - going to only put this value here if
08:11 - this condition evaluate true so in this
08:13 - case we're only going to put even values
08:15 - or 0 inside of this list so when I run
08:18 - this you see that we get all of the even
08:19 - values up to but not including 10. all
08:22 - right so the next concept here is the
08:24 - different python argument and parameter
08:26 - types now there's quite a few that's why
08:28 - I'm going through this concept and a lot
08:30 - of times people have no idea what they
08:32 - are beyond the basic ones so if we
08:34 - Define a function here like complicated
08:36 - function we can have what's known as our
08:38 - necessary parameters or our positional
08:40 - parameters that are defined in order so
08:43 - I can have something like X Y now these
08:45 - are required and they are positional
08:46 - meaning that if I want to pass values
08:49 - here I have to do something like 1 2
08:51 - right I pass them in the order in which
08:53 - I want them to be um kind of assigned so
08:55 - X is 1 and Y is 2. however I can
08:59 - actually switch things up a little bit
09:00 - here and as I pass these arguments I can
09:03 - do something like Y is equal to 2 and X
09:07 - is equal to 1. and now if I go here and
09:09 - print this so X and Y
09:13 - you see that we get one and two so this
09:16 - is valid when you are calling a function
09:18 - you can actually write out the name of
09:19 - the parameter whether or not it's
09:21 - positional optional Etc and then you can
09:23 - just assign it directly inside of here
09:25 - this allows you to no longer pass this
09:28 - positionally however if I pass some
09:31 - positional arguments so let's say I do
09:33 - something like one
09:34 - now I can do something like Z2 Y is
09:37 - equal to 3. so I can pass some of the
09:40 - arguments positionally and then some of
09:42 - them I can pass uh using the kind of
09:44 - keyword argument here or you know the
09:47 - named argument whatever you want to
09:48 - refer to it as by the way inside of your
09:50 - function call you refer to these as
09:52 - arguments and up here in your function
09:53 - you refer to these as parameters so I
09:55 - just wanted to show you that I can pass
09:57 - some of these positionally however
09:58 - things get a little bit weird if I try
10:00 - to pass some positionally and some using
10:03 - the keyword so in this case I have like
10:05 - Z equals 2 1 and then y equals three if
10:08 - I try to run this notice I get an error
10:09 - and it says a positional argument
10:11 - follows a keyword argument which you're
10:13 - not allowed to do so if I want to use
10:15 - some positional arguments and the rest
10:16 - keyword arguments that means that I need
10:19 - to start by defining my positional
10:20 - arguments then I can do the keyword
10:22 - arguments after hopefully that's clear
10:24 - but that was the first thing to go over
10:26 - okay next thing is optional parameters
10:29 - so inside of your function you can mark
10:31 - one of your parameters as optional by
10:33 - putting in equal signs by do Z equals
10:35 - two in this case none now this is
10:37 - optional meaning I'm not required to
10:39 - pass it when I call this function so if
10:42 - I call with 1 and 3 here you can see
10:44 - this is perfectly fine however if I got
10:46 - rid of the equal sign here so I made
10:48 - this no longer optional then I get an
10:50 - error and it says it's missing one
10:52 - required positional argument okay that's
10:54 - worth noting now if I try to access Zed
10:57 - here you'll see that actually let's make
10:58 - it equal something like 10.
11:00 - if I run this it actually gets its
11:03 - default value so when you make something
11:04 - optional really what you're doing is
11:06 - providing a default value for it which
11:08 - means if you don't pass that value when
11:10 - you call the function by default it will
11:12 - be equal to that value okay so that was
11:14 - actually the easy stuff now we move on
11:16 - to the more complicated ones now we have
11:18 - something referred to as asterisk arcs
11:21 - now what this allows us to do is
11:23 - actually accept any number of positional
11:25 - arguments so I can pass
11:28 - a bunch of arguments like this
11:31 - okay I can pass no additional arguments
11:34 - I can pass one two whatever it's any
11:36 - number after my positional arguments so
11:38 - if I print out x y z and then args here
11:42 - and I run the code you see that this is
11:44 - perfectly valid so when I do this
11:45 - asterisk args again this means okay I'm
11:48 - going to accept any number of positional
11:49 - arguments at this point so after my two
11:53 - positional arguments that I have here
11:54 - and it's going to store all of them in a
11:56 - tuple which is an e-mutable type okay if
11:59 - we just have star args here then you see
12:02 - it works the exact same way we accept
12:04 - any number of positional arguments even
12:06 - zero right so if I have none here this
12:09 - works perfectly fine okay that is star
12:11 - args now we also have
12:13 - star star quarks so when you have star
12:16 - star quarks this means we're going to
12:18 - accept any number of keyword arguments
12:20 - so let me just print out quarks here and
12:23 - go and pass some keyword arguments so
12:25 - the keyword arguments are like this
12:26 - something like x equals one
12:28 - s is equal to
12:31 - I don't know hello
12:32 - B is equal to True whatever let's do a
12:36 - capital true here so now if I run this
12:38 - you see that we have no positional
12:40 - arguments but we have these three
12:41 - keyword arguments and they are stored
12:43 - inside of a dictionary so if I want to
12:45 - access any of these individual keyword
12:47 - arguments I go quarks and then I
12:49 - reference whatever the key is so I want
12:51 - to reference X here and notice I get one
12:54 - okay this is useful when you want to
12:56 - make your functions Dynamic and you
12:57 - don't know how many regular arguments or
12:59 - keyword arguments are going to be
13:00 - accepting now you can obviously pass
13:02 - both so if I do something like one two
13:04 - three and then some keyword arguments
13:06 - here you'll now see that we'll get both
13:08 - args and quarks having some values and
13:10 - then we can process those values however
13:12 - we see fit okay great last thing to show
13:15 - you is how to use these uh with inside
13:17 - of your function so let's swap this
13:20 - around out and let's say we have like a
13:21 - b and then C is equal to True d
13:25 - is equal to false
13:27 - okay now if we go here we can actually
13:30 - use the asterisks to kind of break apart
13:33 - a list and pass different positional
13:35 - arguments so let's have a list here and
13:38 - I have one two three inside of it and
13:39 - these are actually the corresponding
13:41 - values for both a b and not C Just A and
13:44 - B if that's the case I can't just pass
13:46 - this list because if I do that it's
13:48 - going to be the positional argument for
13:49 - a so what I can do is put an asterisk
13:52 - before it and this is actually going to
13:53 - kind of decompose or break this apart
13:55 - into two individual positional arguments
13:58 - so if I go here and I print my a and my
14:01 - B and I run this notice I get 1 2 works
14:04 - perfectly fine okay now we have the same
14:07 - thing we can do with our keyword
14:09 - arguments so let's say I have a
14:11 - dictionary that contains my keyword
14:12 - arguments something like C is I don't
14:15 - know hello and D is cool I can actually
14:19 - place a dictionary here and then put two
14:22 - asterisks before it and what this will
14:23 - do is break this dictionary into its
14:25 - keyword arguments and pass that to the
14:27 - file function so now I can print C and D
14:31 - and when I have a look uh what does it
14:33 - say here C is not defined sorry we need
14:35 - to just add a string here
14:37 - always forget that you need to do that
14:39 - in Python let's clear and rerun and
14:41 - notice now that we get the values for
14:43 - our keyword arguments so the next
14:45 - concept here is if underscore underscore
14:47 - name equals underscore underscore main
14:49 - now this is simply telling you if you
14:52 - ran the current python file the reason
14:54 - why it's important to understand that is
14:56 - because a lot of times you can have a
14:58 - bunch of different python modules and
14:59 - sometimes you run the module directly
15:01 - other times it might be imported by a
15:04 - different module so let's have a look at
15:05 - this example in this case we have
15:07 - start.pi we have some function
15:09 - and then we have this if underscore
15:11 - under square name equals equals
15:12 - underscore underscore main we're
15:14 - printing run then we have another file
15:16 - here inside of this file we import the
15:19 - add function from this start module now
15:22 - if I didn't have this line here what
15:24 - would happen is when I import this
15:26 - module by default python would read the
15:29 - entire kind of block of code here the
15:31 - entire file and if I didn't have
15:32 - something inside of the if statement so
15:34 - I just had to say print run here then it
15:36 - would actually execute that line of code
15:37 - which I might not want to happen unless
15:40 - I'm actually inside of that module or
15:42 - sorry not inside of that module but if I
15:44 - ran that module it's better if I just
15:46 - show it to you so if I go here and I run
15:48 - pythonstart.pi you see that we get run
15:50 - printing out to the screen however if I
15:53 - run my other file so python other
15:55 - file.pi notice it doesn't print out run
15:58 - however if I remove this line here and
16:01 - we remove the indentation now it will
16:03 - print run so the purpose again of having
16:06 - this line is to determine if you ran
16:08 - this file drag directly a lot of times
16:10 - you have a file where it has a ton of
16:12 - utility functions that are going to be
16:13 - imported by other files and then you
16:15 - have something you might want to do when
16:17 - you're running it directly like maybe
16:18 - initializing a game or starting some
16:20 - program or sending an API request
16:22 - whatever it may be but you don't want
16:24 - this event to occur you don't want this
16:26 - code to run if it's being imported only
16:29 - if it's being ran directly so that's how
16:31 - you use this that's pretty much all you
16:32 - need to know hopefully now you know so
16:35 - the next concept to go over here does
16:36 - not involve my computer and this is the
16:38 - Gil or the global interpreter lock now
16:41 - this is exclusive to Python and
16:43 - essentially what this says is that any
16:45 - thread that wants to be executing needs
16:47 - to acquire The Interpreter lock now what
16:50 - that kind of technically means for you
16:52 - is that you can only execute one thread
16:54 - at the same time even if you have
16:56 - multiple CPU cores on your computer now
16:59 - to better illustrate this because I'm
17:00 - sure it's a bit confusing on your
17:02 - computer you have a CPU or in your
17:04 - computer you have a CPU that CPU will
17:06 - typically have multiple cores two cores
17:08 - four core eight cores whatever it may be
17:11 - now each one of these cores can execute
17:13 - one operation at a time with hyper
17:16 - threading and virtualization you might
17:18 - be able to do a few more I'm not going
17:19 - to talk about all the details there for
17:21 - Simplicity let's say each CPU core can
17:23 - execute one operation well this is great
17:26 - because that means your CPU can be
17:27 - working on multiple things at the same
17:29 - time and if you have a complex
17:31 - application it's possible that you want
17:33 - to be doing something like processing an
17:34 - image while allowing a user to type
17:36 - something in while maybe sending a
17:38 - request to the network there's a ton of
17:40 - different things you could be doing at
17:42 - the same time and this is where
17:43 - multi-threading comes in a thread is
17:46 - essentially a component of your
17:47 - application that's being executed by the
17:49 - CPU when you start getting into larger
17:51 - programs you start designing
17:53 - multi-threaded applications where you
17:55 - have different pieces of your code
17:57 - separated into different threads such
17:59 - that they can execute at the same point
18:01 - in time now with python you can do this
18:03 - you can have multiple threads the issue
18:05 - becomes though that you have this Global
18:07 - interpreter lock now what that means is
18:09 - even if you have a bunch of CPU cores on
18:11 - your computer only one of these threads
18:13 - can be executing at a time that's
18:16 - because this thread needs to acquire
18:18 - something known as a lock on The
18:20 - Interpreter now I'm not going to discuss
18:22 - why this was implemented in Python but
18:24 - what you need to know about this is that
18:26 - if you do actually have multiple threads
18:28 - this is not going to give you a
18:29 - performance bonus in Python it's not
18:31 - going to increase the speed at which you
18:33 - execute your code so to give you a
18:35 - simple example here let's say I wanted
18:36 - to sum the numbers from 1 to 100. well
18:39 - if I was doing this in a single thread
18:41 - I'd have to sum all of the numbers from
18:42 - 1 to 100 in a row however what could be
18:45 - more efficient is if I split this into
18:47 - four threads or six threads or eight
18:49 - threads and I summed sections of the
18:51 - numbers for example if there was four of
18:53 - me then I could sum the first 0 to 25 25
18:57 - to 50 50 to 75 75 to 100 and then I
19:00 - could add all of those values together
19:02 - and this would allow me to sum the
19:03 - numbers four times faster and in a
19:06 - traditional programming language you can
19:07 - do this you can create four threads
19:09 - they're going to be executed on four
19:10 - different CPU cores and this will allow
19:12 - you to very quickly speed up your
19:14 - programs using these multiple threats in
19:17 - Python you can't do that even though you
19:19 - have these multiple threads only one of
19:21 - them can execute at a time which means
19:23 - it doesn't matter how you split these
19:25 - things up it's going to take the exact
19:26 - same amount of time or approximately the
19:28 - exact same amount of time to execute
19:30 - this code now I'm going to stop here
19:32 - hopefully you get the point that you can
19:34 - only have one thread in execution at a
19:36 - time if you know that you pretty much
19:37 - know the global interpreter lock if you
19:39 - want to learn more then I'll encourage
19:41 - you to read about it or let me know in
19:42 - the comments if you want to see me make
19:44 - an entire video on it regardless I'm
19:46 - going to wrap it up here I hope that you
19:48 - found this helpful and I look forward to
19:49 - seeing you in another YouTube video
19:54 - foreign
19:56 - [Music]

Cleaned transcript:

if you're interested in becoming a developer that writes any type of code in Python then you need to understand these five very important python Concepts these are what I see most beginner and intermediate python programmers making a ton of mistakes with and misunderstanding when they're reading through production code the goal of this video is to make sure that when you're reading through production python code you understand what's happening you know the concept and then you can reproduce that code and write your own pull requests and own features using python code that other developers will understand and expect so with that said let's get into the video after I share with you the first very important concept you need to understand which is the sponsor of this video nordpass nordpass is the ultimate password and credential management solution that I've actually been looking for for a long time now I don't know about you guys but I have a lot of passwords credit cards Bank details private Keys Etc and oftentimes I need to share these with my coworkers making it a constant struggle to not only keep this data secure and safe but to allow them to access it quickly without having to message me all the time now nordpass fixes this problem because it allows me to store both my personal or my business data in a single secure location and then give different access to members of my team now if you don't believe me you can check it out from the link in the description and use the code Tech with Tim which means you'll no longer have to be sending messages or receiving messages asking for passwords not to mention the nordpass has features like autofill data breach detection and activity log a password generator and much more check out Nord from the link in the description and use the code tequitim for a three month free trial so you can take control over your data and your accounts thanks again to nordpass for sponsoring this video so the first concept to go over here is mutable versus immutable types now this is the concept that most beginner and intermediate programmers make mistakes with don't worry if you already understand it there's a lot more complicated Concepts so stick around for the rest of the video regardless an immutable type is something that cannot change a mutable type is something that can change an example of these in Python is the following so immutable types are going to be our string our ins our floats our Boolean our bytes type and our topple type all of these are immutable meaning once you define this you cannot change it however we have mutable types in Python which are the list the set and the dictionary and pretty much any other type used from some thirdparty library or module these can change which means once you find them you can actually modify them let me give you a super quick example here of immutable versus mutable then we'll go into a more complex one using a function which is where I see most beginners make a mistake okay so let's say we have some number like x equals one and we say Y is equal to X and in fact let's change this to a tuple which remember is e mutable meaning we cannot change it actually to quickly show this to you let's try to do something like x0 is equal to one where we're trying to change this Tuple without reassigning something to this variable so if I go here and run my code notice I get an error and it says the Tuple object does not support item assignment now the reason it doesn't support that is because this is immutable that means that once I Define this Tuple I cannot change it now if we go here and do something like Y equals X and let's come and say X is equal to one two three I just want to show you if I print out both X and Y here that my change to X here after assigning X to Y did not affect y the reason for that is whenever you're using immutable types when you do an assignment to another variable so I do something like Y equals X it makes a copy so an actual real copy of this immutable object meaning that if I now go something like X is equal to one two three that's not going to affect y because I'm not modifying what Y is storing I'm just reassigning a new value to X I know that seems trivial but the reason I'm illustrating this to you is because this works differently when we change this to a list so if I change this to a list now and then I come and do something like x 0 is equal to 100 you might think that Y is not going to change but when I run this you see that both X and Y have the same value now the reason for that is when you're using mutable types and you do something like Y equals X here so you're signing a variable to another variable and this variable is storing a mutable type what happens is you actually store a reference or an alias to this same object meaning that if I make a change to the object like I'm doing right here it changes for both of these variables because they're actually storing the same object in fact they're storing a reference to the same object so again if you change the underlying object then it changes for both X and Y that's the difference between immutable and mutable types now let me just paste in a quick example here that will illustrate this even a little bit further so you can see in this example we have a function that Returns the largest numbers it Returns the N largest numbers actually what it does is it sorts the list of numbers that it accepts so what I've done down here is I've created a list of numbers I printed out what the value of the list was before I called the function and then I printed out with the value was afterwards now take a guess if you want it what you think the output is going to be but I'll go ahead and run the code and you can see here that we actually get the list before that's unsorted and then the list becomes sorted afterwards now the reason this occurs is because what happens is when we call this function we pass this nums list as the parameter numbers now since we're passing a mutable object a list is mutable when we do a numbers.sort what this does is actually sort the list in place now numbers here is going to be storing a reference to this same list so when I sort the numbers parameter here since I had passed in my numbers array it ends up sorting that numbers array that's down here seems a little bit strange but the reason this is occurring is again because we're using a mutable object so the point here is that you need to understand when you're using mutable versus immutable objects because you could have functions like this that can perform side effects on your mutable objects this is referred to as a side effect because what happens is one of the parameters is being mutated or modified inside of the function sometimes you want that to be the case sometimes you don't want that to be the case you need to be intentional when you're writing your code so the next concept to understand here is list comprehensions now the reason you need to understand this is because it's used quite a bit in Python and oftentimes you'll see people writing fairly complicated comprehensions to simplify a line of code now this can kind of do the reverse sometimes it can actually make it more complicated regardless you need to understand what they are so that you can actually understand them if you see them in some production code so let's have a look at a list comprehension so the most basic comprehension you can do here is something like X or we'll go with i for I in range and then maybe something like 10 and in case you can't guess it here what this is going to do is give me an array that contains the numbers 0 through 9. so let me open up my terminal and run this and there you go we get zero through nine so this is a list comprehension where essentially you write a for Loop inside of a list what you do on the left hand side is you put but the value that you want to populate the list with and then you have some kind of iterator in this case we have a for Loop that's going to Loop through and generate these different values now this is a very simple list comprehension you can make much more complicated ones for example we can have a list here instead so now if I do a list we have a bunch of empty lists inside of this list but just like we have a list comprehension here we can have one inside of this list so I can do something like four so actually let's go with J 4J in range 5 like that and now we have a nested list comprehension and if I run this code you can see that now we get a bunch of lists that contain five different values inside of them 10 times okay so that's one thing you can do another thing that we can do here is the following so let's go here and say I for I in range 10 and then we can put in if statement and we can say if I mod 2 is equal to zero now this means we're going to only put this value here if this condition evaluate true so in this case we're only going to put even values or 0 inside of this list so when I run this you see that we get all of the even values up to but not including 10. all right so the next concept here is the different python argument and parameter types now there's quite a few that's why I'm going through this concept and a lot of times people have no idea what they are beyond the basic ones so if we Define a function here like complicated function we can have what's known as our necessary parameters or our positional parameters that are defined in order so I can have something like X Y now these are required and they are positional meaning that if I want to pass values here I have to do something like 1 2 right I pass them in the order in which I want them to be um kind of assigned so X is 1 and Y is 2. however I can actually switch things up a little bit here and as I pass these arguments I can do something like Y is equal to 2 and X is equal to 1. and now if I go here and print this so X and Y you see that we get one and two so this is valid when you are calling a function you can actually write out the name of the parameter whether or not it's positional optional Etc and then you can just assign it directly inside of here this allows you to no longer pass this positionally however if I pass some positional arguments so let's say I do something like one now I can do something like Z2 Y is equal to 3. so I can pass some of the arguments positionally and then some of them I can pass uh using the kind of keyword argument here or you know the named argument whatever you want to refer to it as by the way inside of your function call you refer to these as arguments and up here in your function you refer to these as parameters so I just wanted to show you that I can pass some of these positionally however things get a little bit weird if I try to pass some positionally and some using the keyword so in this case I have like Z equals 2 1 and then y equals three if I try to run this notice I get an error and it says a positional argument follows a keyword argument which you're not allowed to do so if I want to use some positional arguments and the rest keyword arguments that means that I need to start by defining my positional arguments then I can do the keyword arguments after hopefully that's clear but that was the first thing to go over okay next thing is optional parameters so inside of your function you can mark one of your parameters as optional by putting in equal signs by do Z equals two in this case none now this is optional meaning I'm not required to pass it when I call this function so if I call with 1 and 3 here you can see this is perfectly fine however if I got rid of the equal sign here so I made this no longer optional then I get an error and it says it's missing one required positional argument okay that's worth noting now if I try to access Zed here you'll see that actually let's make it equal something like 10. if I run this it actually gets its default value so when you make something optional really what you're doing is providing a default value for it which means if you don't pass that value when you call the function by default it will be equal to that value okay so that was actually the easy stuff now we move on to the more complicated ones now we have something referred to as asterisk arcs now what this allows us to do is actually accept any number of positional arguments so I can pass a bunch of arguments like this okay I can pass no additional arguments I can pass one two whatever it's any number after my positional arguments so if I print out x y z and then args here and I run the code you see that this is perfectly valid so when I do this asterisk args again this means okay I'm going to accept any number of positional arguments at this point so after my two positional arguments that I have here and it's going to store all of them in a tuple which is an emutable type okay if we just have star args here then you see it works the exact same way we accept any number of positional arguments even zero right so if I have none here this works perfectly fine okay that is star args now we also have star star quarks so when you have star star quarks this means we're going to accept any number of keyword arguments so let me just print out quarks here and go and pass some keyword arguments so the keyword arguments are like this something like x equals one s is equal to I don't know hello B is equal to True whatever let's do a capital true here so now if I run this you see that we have no positional arguments but we have these three keyword arguments and they are stored inside of a dictionary so if I want to access any of these individual keyword arguments I go quarks and then I reference whatever the key is so I want to reference X here and notice I get one okay this is useful when you want to make your functions Dynamic and you don't know how many regular arguments or keyword arguments are going to be accepting now you can obviously pass both so if I do something like one two three and then some keyword arguments here you'll now see that we'll get both args and quarks having some values and then we can process those values however we see fit okay great last thing to show you is how to use these uh with inside of your function so let's swap this around out and let's say we have like a b and then C is equal to True d is equal to false okay now if we go here we can actually use the asterisks to kind of break apart a list and pass different positional arguments so let's have a list here and I have one two three inside of it and these are actually the corresponding values for both a b and not C Just A and B if that's the case I can't just pass this list because if I do that it's going to be the positional argument for a so what I can do is put an asterisk before it and this is actually going to kind of decompose or break this apart into two individual positional arguments so if I go here and I print my a and my B and I run this notice I get 1 2 works perfectly fine okay now we have the same thing we can do with our keyword arguments so let's say I have a dictionary that contains my keyword arguments something like C is I don't know hello and D is cool I can actually place a dictionary here and then put two asterisks before it and what this will do is break this dictionary into its keyword arguments and pass that to the file function so now I can print C and D and when I have a look uh what does it say here C is not defined sorry we need to just add a string here always forget that you need to do that in Python let's clear and rerun and notice now that we get the values for our keyword arguments so the next concept here is if underscore underscore name equals underscore underscore main now this is simply telling you if you ran the current python file the reason why it's important to understand that is because a lot of times you can have a bunch of different python modules and sometimes you run the module directly other times it might be imported by a different module so let's have a look at this example in this case we have start.pi we have some function and then we have this if underscore under square name equals equals underscore underscore main we're printing run then we have another file here inside of this file we import the add function from this start module now if I didn't have this line here what would happen is when I import this module by default python would read the entire kind of block of code here the entire file and if I didn't have something inside of the if statement so I just had to say print run here then it would actually execute that line of code which I might not want to happen unless I'm actually inside of that module or sorry not inside of that module but if I ran that module it's better if I just show it to you so if I go here and I run pythonstart.pi you see that we get run printing out to the screen however if I run my other file so python other file.pi notice it doesn't print out run however if I remove this line here and we remove the indentation now it will print run so the purpose again of having this line is to determine if you ran this file drag directly a lot of times you have a file where it has a ton of utility functions that are going to be imported by other files and then you have something you might want to do when you're running it directly like maybe initializing a game or starting some program or sending an API request whatever it may be but you don't want this event to occur you don't want this code to run if it's being imported only if it's being ran directly so that's how you use this that's pretty much all you need to know hopefully now you know so the next concept to go over here does not involve my computer and this is the Gil or the global interpreter lock now this is exclusive to Python and essentially what this says is that any thread that wants to be executing needs to acquire The Interpreter lock now what that kind of technically means for you is that you can only execute one thread at the same time even if you have multiple CPU cores on your computer now to better illustrate this because I'm sure it's a bit confusing on your computer you have a CPU or in your computer you have a CPU that CPU will typically have multiple cores two cores four core eight cores whatever it may be now each one of these cores can execute one operation at a time with hyper threading and virtualization you might be able to do a few more I'm not going to talk about all the details there for Simplicity let's say each CPU core can execute one operation well this is great because that means your CPU can be working on multiple things at the same time and if you have a complex application it's possible that you want to be doing something like processing an image while allowing a user to type something in while maybe sending a request to the network there's a ton of different things you could be doing at the same time and this is where multithreading comes in a thread is essentially a component of your application that's being executed by the CPU when you start getting into larger programs you start designing multithreaded applications where you have different pieces of your code separated into different threads such that they can execute at the same point in time now with python you can do this you can have multiple threads the issue becomes though that you have this Global interpreter lock now what that means is even if you have a bunch of CPU cores on your computer only one of these threads can be executing at a time that's because this thread needs to acquire something known as a lock on The Interpreter now I'm not going to discuss why this was implemented in Python but what you need to know about this is that if you do actually have multiple threads this is not going to give you a performance bonus in Python it's not going to increase the speed at which you execute your code so to give you a simple example here let's say I wanted to sum the numbers from 1 to 100. well if I was doing this in a single thread I'd have to sum all of the numbers from 1 to 100 in a row however what could be more efficient is if I split this into four threads or six threads or eight threads and I summed sections of the numbers for example if there was four of me then I could sum the first 0 to 25 25 to 50 50 to 75 75 to 100 and then I could add all of those values together and this would allow me to sum the numbers four times faster and in a traditional programming language you can do this you can create four threads they're going to be executed on four different CPU cores and this will allow you to very quickly speed up your programs using these multiple threats in Python you can't do that even though you have these multiple threads only one of them can execute at a time which means it doesn't matter how you split these things up it's going to take the exact same amount of time or approximately the exact same amount of time to execute this code now I'm going to stop here hopefully you get the point that you can only have one thread in execution at a time if you know that you pretty much know the global interpreter lock if you want to learn more then I'll encourage you to read about it or let me know in the comments if you want to see me make an entire video on it regardless I'm going to wrap it up here I hope that you found this helpful and I look forward to seeing you in another YouTube video foreign
