With timestamps:

00:02 - [Music]
00:08 - hello everybody and welcome to the fifth
00:10 - video in this blockchain for beginners
00:12 - tutorial series now in this video i'm
00:15 - going to be talking to you about the
00:16 - limitations of solidity and of smart
00:19 - contracts and some applications that are
00:21 - very difficult to deploy on the
00:23 - blockchain because of these limitations
00:26 - specifically i'll be talking to you
00:27 - about arrays strings for loops while
00:30 - loops and why it's very expensive to use
00:32 - those things in a spark contract and how
00:34 - they can actually cause your smart
00:36 - contract to break or to be in a state
00:38 - where it can never be ran again i'll get
00:40 - into all of that in this video but
00:42 - before we dive in i do need to thank
00:43 - cartesi for sponsoring this video and
00:45 - this series as i've said many times
00:47 - they're an awesome company i've loved
00:49 - working with them through these videos
00:51 - they've really helped me come up with a
00:52 - great curriculum to teach you guys so
00:54 - another massive thank you to them and
00:55 - with that said let's go ahead and get
00:57 - into the video all right so i'm now on
01:00 - my computer and i am in remix in front
01:02 - of me i have a very simple smart
01:04 - contract and what i'm going to be doing
01:05 - in the first part of the video here is
01:07 - talking to you about arrays strings for
01:09 - loops while loops and then finally
01:11 - structs now after we do that i'll talk
01:14 - about some of the limitations of
01:15 - solidities and expenses in using these
01:17 - different features and then we'll talk
01:19 - about some potential i guess fixes or
01:21 - solutions for these limitations so let's
01:24 - begin by talking about arrays so the way
01:26 - you create an array in solidity is you
01:28 - define the type you would like to be
01:30 - inside of the array for all of the
01:31 - elements so in this case i'll say you
01:33 - int you put your square brackets like
01:35 - this if you wanted a multi-dimensional
01:36 - array you do another set of square
01:38 - brackets and then what you can do after
01:40 - this is put the name of the array or the
01:42 - modifier so i'm going to do something
01:43 - like public arr and then i can just
01:46 - close it off like that so there you go
01:47 - i've just now created a dynamically
01:49 - sized array in solidity so in solidity
01:52 - you could have both a statically sized
01:54 - or fixed sized array or a dynamically
01:56 - sized array if i do something like this
01:58 - where i just have square brackets with
01:59 - no element inside or no value inside
02:02 - this is dynamically sized so this means
02:04 - it will grow as i add more elements to
02:06 - it now if i do something like 5 this is
02:08 - going to say this array can only have 5
02:11 - elements inside of it i will initialize
02:13 - those elements i believe all as 0.
02:16 - all right so there's the basics for
02:17 - arrays now arrays are a reference type
02:19 - in solidity and that means that they are
02:21 - mutable and we can modify them once they
02:23 - have been created so we have direct
02:25 - index access we can access the length of
02:27 - elements or the length of the array
02:29 - sorry and again we can push elements
02:31 - inside
02:32 - okay so let's just deploy the contract
02:33 - right now and have a look at how we
02:35 - actually access the elements in this
02:36 - array so i'm going to deploy this when i
02:39 - go here notice i'm going to have arr and
02:41 - then i can pass the index of the element
02:43 - that i want to access now arrays are 0
02:45 - indexed so if i do something like arr
02:47 - and 0 it's going to give me the value 0
02:49 - because since we statically initialize
02:51 - this array we're going to have one
02:52 - element with value zero or sorry five
02:54 - elements with value zero inside of the
02:56 - array now let's access index one okay we
02:58 - get zero again let's do index four zero
03:01 - again let's do five and then notice here
03:04 - that we actually are going to get a
03:05 - revert the transaction has been reverted
03:07 - to the initial state and that's because
03:08 - an error would have occurred because
03:10 - we're accessing an index that is out of
03:12 - the bounds of this array
03:13 - perfect so now that we have done that
03:15 - let's look at how we can actually i
03:17 - guess modify the elements of this array
03:19 - so let's create a function let's say
03:21 - function i'm just going to say mod arr
03:24 - standing for modify array we will make
03:26 - this a public function and we're not
03:29 - going to return anything we'll just
03:30 - actually modify this okay now inside of
03:32 - here i'm just going to take in a uiint x
03:35 - and a uint
03:38 - idx
03:39 - and instead of x let's actually just go
03:40 - with value just so this is a little bit
03:42 - more clear now essentially what this is
03:44 - going to do is change the element at
03:46 - index to be equal to value so let's just
03:48 - say ar at index let's go idx
03:52 - is equal to val notice we're not getting
03:54 - any errors so this should be good to go
03:56 - okay so let's deploy the contract
03:58 - let's go here we're going to look at
04:00 - index 0 see that that has value 0. now
04:03 - let's change this so let's
04:05 - pass to here a value of say 10 and an
04:09 - index of 0 let's transact looks like
04:11 - that's all good now when we look here
04:13 - notice we have a value of 10. very basic
04:16 - that's how you can modify this array now
04:18 - what i want to do is create a
04:19 - dynamically sized array so let's simply
04:21 - change this by removing the five and now
04:23 - when we do mod array we're just going to
04:24 - take in a value and i'll show you how we
04:26 - can append this value or push it to the
04:28 - array pretty straightforward but you can
04:30 - use the dot push method so i can say ar
04:33 - dot push i can push the value which is
04:36 - uint and now this should be good so
04:38 - let's try this let's deploy the contract
04:41 - let me just delete this one here
04:43 - okay now
04:45 - we have mod array that takes it a value
04:47 - so let's just pass
04:48 - one
04:50 - let's pass two and let's pass three now
04:53 - let's look at index zero index zero is
04:55 - one
04:56 - index one is two and index two is three
04:59 - perfect there we go we just pushed
05:01 - elements into the array all right great
05:03 - so now that we've done that let me show
05:04 - you how we can get the length of the
05:05 - array so i'm just gonna say function
05:08 - get length we'll make this an external
05:12 - and then this can be a view function
05:16 - that returns and then we'll just put you
05:19 - in like that and then inside of here i
05:21 - can simply return error dot length like
05:25 - that okay so this will give us the
05:26 - length you can just use the dot length
05:28 - property so let's now deploy this
05:30 - contract let's go deploy
05:32 - let's mod the array by adding one
05:34 - two
05:35 - and
05:36 - three now let's get the length and
05:38 - notice we have a length of three now
05:39 - let's add another element let's add four
05:41 - get length we're at four there you go
05:44 - that pretty much covers erase i don't
05:46 - think there's actually anything more to
05:47 - go through with arrays uh one thing you
05:50 - can do is access individual elements
05:52 - using the index notation so i can do
05:54 - something like array at zero is equal to
05:56 - one that's perfectly valid or i can just
05:58 - do array at zero that works as well as
06:01 - you saw previously
06:02 - last thing i will mention is that if you
06:04 - want to actually
06:06 - define the literal for the array so you
06:08 - want to do something
06:09 - like this use square brackets so say
06:11 - uint public arr and then one two three
06:15 - this is different than something like i
06:17 - guess c plus plus or java where you
06:19 - would use uh squiggly brackets at least
06:21 - i think you use those in those languages
06:22 - anyways and solidity use square brackets
06:24 - to define the elements in the array
06:27 - perfect hopefully that is clear that
06:28 - pretty much covers arrays okay so now
06:31 - that we have gone through arrays i want
06:32 - to cover strings so let's get rid of all
06:34 - of this now strings and solidity are
06:37 - very expensive to work with and same
06:39 - thing with arrays arrays are very
06:41 - expensive as well and in fact the reason
06:43 - i'm showing them to you last is because
06:45 - mappings are much preferred over a race
06:47 - so you pretty much never want to be
06:49 - using arrays or using strings if you can
06:51 - avoid doing so there is some use cases
06:53 - where you do need them but essentially
06:55 - you always want to go with something
06:56 - like a mapping as opposed to an array i
06:58 - won't get into all of the details but
07:00 - just understand that they cost a lot
07:01 - more gas than something like a mapping
07:04 - so if you can avoid it avoid using
07:06 - arrays and if you want to mess around
07:07 - with kind of the differences in arrays
07:09 - and mappings deploy a few contracts and
07:11 - look at the actual gas cost in terms of
07:13 - working with arrays versus working with
07:16 - mappings and same thing with strings
07:18 - strings are extremely expensive to use
07:20 - in solidity and one of the reasons for
07:22 - that is that a string in solidity is
07:24 - actually a bytes array so you can create
07:26 - a byte array like this now bytes are
07:28 - used for kind of a raw data type and a
07:30 - string in solidity essentially is a
07:32 - bytes array that's going to be decoded
07:34 - and encoded with utf-8 just allowing you
07:37 - to actually view the string
07:39 - so let me show you what i mean if i do
07:40 - something like string
07:42 - and i guess we can put public although
07:43 - we don't really need to and we'll just
07:44 - make this equal to a low we can say this
07:47 - is equal to world that is completely
07:49 - valid now you want to again avoid using
07:52 - strings whenever you possibly can
07:54 - because they're very expensive to work
07:55 - with same reason with the arrays because
07:57 - they are actually represented by a bytes
07:59 - array now strings and solidity are
08:01 - extremely simple you do not have index
08:04 - access to them you cannot concatenate
08:06 - them you can't get the length of them
08:07 - there's actually almost no methods or
08:09 - properties for strings you literally can
08:11 - just store a literal string and in most
08:14 - situations it's going to be much more
08:15 - efficient especially if you're working
08:16 - with large strings to store them off of
08:18 - the block chain and simply store a hash
08:21 - of that string in the storage of your
08:23 - contract that will be much much cheaper
08:25 - than actually storing the string itself
08:27 - in the contract anyways let's deploy the
08:29 - contract here with the string notice
08:31 - that i can
08:32 - access this and i can have world right
08:34 - let's see i can see world there so let's
08:36 - create another function let's go
08:37 - function
08:38 - set string and let's go string and then
08:42 - let's go with value now i'm not quite
08:45 - done with this yet i need to talk about
08:47 - something with having strings inside of
08:49 - functions but for now i will say hello
08:51 - is equal to val okay so notice that i'm
08:54 - getting an error here now why am i
08:56 - getting an error this function actually
08:57 - looks pretty valid right i have my
08:58 - string parameter i have this public i'm
09:01 - setting a value this should be good the
09:03 - reason why i'm getting an error here we
09:05 - can hover over this is because the data
09:07 - location must be memory or call data for
09:10 - a parameter so this is where i'm going
09:12 - to talk about the different storage
09:14 - locations that you have in your contract
09:16 - so in your contract you have state or
09:18 - storage they're kind of the same things
09:20 - storage slash state now that essentially
09:22 - means that you're persistently going to
09:23 - be storing this data in the smart
09:25 - contract itself now any data you store
09:28 - is going to cost you small amounts of
09:30 - ethereum right it's going to be more
09:31 - expensive to store more data than to
09:33 - store less you want to store the least
09:35 - amount of stuff that you possibly can so
09:36 - that's the first location storage slash
09:38 - state that's persistent it's always
09:40 - going to be there the other location is
09:43 - memory now memory similar to your
09:45 - computer's ram is a temporary location
09:47 - that's only going to be used when the
09:48 - contract is actually executing so when
09:51 - i'm using a reference type like a string
09:53 - i need to specify it's going to be
09:54 - stored in memory so i'm going to say
09:56 - memory like this so as soon as i put
09:58 - memory we actually would have seen this
10:00 - before i think now this is valid because
10:02 - it's saying i want to store this
10:03 - parameter in memory as opposed to in the
10:06 - state or storage of the contract and you
10:08 - only need to specify this for reference
10:10 - data types so same thing with arrays
10:12 - let's say i did something like uint
10:15 - and then i wanted to have my
10:17 - value like this i would need to now
10:19 - specify memory to not get yelled at by
10:21 - the compiler okay so let's go back to
10:23 - what we had before string memory value
10:26 - hello equals val let's deploy this let's
10:29 - look at this let's go
10:31 - hello world i am tim
10:33 - let's set the string let's look at hello
10:35 - and now we have hello world i am awesome
10:38 - again avoid using strings if you need to
10:40 - use a large string what you want to do
10:41 - is store it off the block chain and
10:43 - simply store a hash of that string on
10:45 - the blockchain that will be much cheaper
10:47 - okay so now we've gone through arrays we
10:48 - have gone through strings i want to show
10:50 - you looping and then i will show you the
10:52 - gas cost associated with a lot of these
10:54 - different features i'm just trying to
10:55 - give you kind of the basics right now
10:57 - okay so let us
10:59 - should we loop through an array no let's
11:01 - just loop over kind of a range of
11:03 - numbers to start so i'm just going to
11:04 - say function and i will say loop
11:07 - and i'm going to take in uint n
11:10 - and all i'm going to do here
11:11 - is simply loop over n numbers so to do a
11:14 - for loop in solidity is similar to
11:16 - pretty much every other programming
11:17 - language you can say 4 and then you can
11:20 - define your looping variable so i'm
11:22 - going to say u and i i'm going to say i
11:24 - is less than n
11:26 - and then i'm going to say i plus plus
11:28 - okay so i'm just incrementing i by 1 in
11:30 - every iteration and then what i'm going
11:32 - to do here is i guess we can just add to
11:35 - some variable or something because i'm
11:36 - just trying to illustrate looping so
11:38 - i'll do something like uint sum is equal
11:41 - to zero
11:42 - and then sum plus equals i
11:45 - and i think that should be good and if
11:47 - we wanted to we could return the sum but
11:48 - this is fine we'll just do this for now
11:50 - so i just had to take a quick cut there
11:51 - because my cat was freaking out at me
11:53 - for some reason anyways that is now
11:55 - resolved but continuing here we're
11:57 - getting a warning the reason we're
11:58 - getting a warning is because this can be
12:00 - restricted to pure the reason for that
12:02 - is because we're not actually modifying
12:03 - or accessing the state of the contract
12:06 - so i just want to put pure like this
12:08 - anyways this is how you do a for loop
12:10 - now i will mention that the for loops
12:12 - again are going to be very very
12:14 - expensive to run if you're not doing
12:16 - them in something like a pure function
12:17 - right in a pure function or something
12:19 - that doesn't require a transaction it's
12:21 - not going to cost you ethereum to run
12:22 - this however it's going to be very
12:24 - expensive to implement for loops when
12:26 - you're actually working with the state
12:27 - of the contract now the reason for that
12:29 - is whenever you do a transaction you
12:31 - need to pass gas along with that
12:33 - transaction right and the gas cost is
12:36 - the sum of all the operations that the
12:38 - contract is doing so in this case it's
12:40 - going to cost me gas to actually add a
12:42 - number to another number right for me to
12:44 - add two numbers that cost gas but here
12:46 - in this situation the amount of gas this
12:48 - would cost if it wasn't a pure function
12:50 - is n multiplied by all of the gas used
12:54 - inside of the for loop now that might
12:56 - not seem like a lot but if an n is a
12:58 - large number say like a thousand or ten
13:00 - thousand and the amount of gas in here
13:02 - is four gas 20 gas 100 gas something
13:05 - along those lines you can see how the
13:07 - amount of gas required adds up very very
13:09 - quickly and it becomes unfeasible to
13:11 - actually be able to loop inside of smart
13:13 - contracts and in fact there's actually a
13:15 - maximum amount of gas that you can pass
13:17 - to an ethereum smart contract i believe
13:20 - right now it's at 30 million gas in fact
13:22 - i think that's right here it's the gas
13:23 - limit that's showing up regardless you
13:25 - can only pass so much gas so if your
13:27 - smart contract needs to do a ton of
13:29 - computations you have to have multiple
13:31 - transactions to be able to complete that
13:34 - because you need to pass the required
13:35 - gas and you can only do a certain amount
13:37 - of gas in each transaction
13:40 - anyways that was kind of it for for
13:41 - loops i just want to show you the syntax
13:43 - this is the basics of for loops now i
13:45 - will show you while loops so let's do a
13:47 - very similar thing here let's just
13:49 - manually declare i so u and i is equal
13:52 - to zero we'll say well i is less than n
13:56 - we'll say i plus plus we can do that at
13:59 - the end and then we'll say sum plus
14:02 - equals i like that perfect there you go
14:05 - this is a while loop again not really
14:07 - going to explain this i'm sure most of
14:08 - you understand how this works anyways
14:10 - those are for loops and while loops and
14:12 - now that we've looked at those i want to
14:14 - write a very simple smart contract
14:16 - that's going to work with arrays and for
14:18 - loops or while loops and show you how
14:20 - much gas it actually costs on an
14:22 - ethereum test network so let's start by
14:25 - just initializing an array here and
14:26 - let's just say u end
14:28 - and let's go arr and let's just make
14:31 - this equal i guess actually i can just
14:33 - define it like that u and ar that's fine
14:35 - for now then i'm going to have a
14:36 - function i'm going to say function
14:39 - create ar i'm going to say u and n and i
14:43 - will go with string value and i'm
14:46 - actually going to change the type of
14:47 - this array to be a string array and show
14:49 - you how expensive this gets
14:51 - okay now i will make this public
14:53 - now what i want to do here is
14:54 - essentially initialize this array with n
14:57 - elements that are equal to this string
14:59 - value now i need to remember to add my
15:00 - memory keyword otherwise it's going to
15:02 - get mad
15:03 - okay so let's do this so what i'm going
15:04 - to do is write a for loop i'm going to
15:06 - say 4
15:07 - again this will be i uh u and i
15:10 - this is going to be i is less than n
15:14 - let's add a space here and then i plus
15:17 - plus
15:18 - okay now what we'll do is set rr
15:20 - dot push and we're going to push the
15:23 - value like so
15:25 - okay so right now we can technically run
15:27 - this infinite number of times and i'll
15:29 - show you what happens if we try to do
15:30 - that but i want to deploy this to our
15:32 - injected web 3 to the go rally test
15:35 - network uh so it says custom network
15:37 - right now let me just go to my metamask
15:38 - and change this to goreli and then we
15:40 - will deploy this and test it out all
15:41 - right so we are back on goreli i'm going
15:44 - to deploy
15:45 - let's see how much this is going to cost
15:46 - us right now okay so not a significant
15:48 - amount of gas because obviously we
15:50 - haven't done any computation yet in the
15:52 - contract and then once this is deployed
15:54 - we will actually try running this method
15:56 - and see how much gas it cost us all
15:58 - right so it looks as though the contract
15:59 - has been deployed we can see it down
16:01 - here it says create arr now let's just
16:03 - see again this is going to be kind of
16:04 - antidote i'll just go through a few uh
16:06 - examples here how much it costs to do
16:08 - one that has 10 elements and the string
16:12 - hello world now i need to quote this
16:13 - string here so let's do that and let's
16:16 - transact and see approximately how much
16:18 - this costs us so when i do this notice
16:20 - we're getting 0.00
16:23 - okay so we can kind of copy that and
16:25 - keep that in mind and then i'll show you
16:26 - how this is going to i guess not
16:28 - exponentially but go up a lot as i
16:30 - increase the value of n so let's now do
16:33 - one that has a thousand elements and see
16:35 - how much this costs so when i do
16:37 - transact now
16:38 - we're going to see that now we're at
16:40 - 0.05
16:41 - now if you actually put that into the
16:43 - price of ethereum 0.05 ethereum is a lot
16:46 - now i'm not sure if it would be the
16:47 - exact same on the regular ethereum
16:49 - network but the point is you saw how we
16:51 - drastically increase this to a whole
16:53 - decimal point right just by making this
16:56 - a thousand instead of site 10 and then
16:58 - let's go crazy and let's make this
16:59 - something like a hundred thousand and
17:01 - transact and see how much this would
17:03 - cost and here it tells me we actually
17:04 - cannot even send this amount of gas the
17:07 - transaction will likely fail so let's go
17:09 - to 10 000 and see if 10 000 is doable
17:12 - same thing we can't even do 10 000 let's
17:14 - try doing something like 5000 and see if
17:17 - that's gonna work okay 5000 doesn't work
17:20 - let's try
17:21 - 25 000 transact okay that's not going to
17:23 - work so just trying to show you here
17:26 - that we really cannot do a lot of
17:27 - looping operations and even if we try to
17:29 - do a lot of looping operations that is
17:32 - going to be very very expensive to the
17:33 - point where it really doesn't make sense
17:35 - to do them inside of the smart contract
17:37 - all right so now that we've gone through
17:38 - those few examples just so you can see
17:40 - kind of in the real world how much the
17:42 - gas is going to cost let me delete all
17:44 - of this and show you that remix can
17:46 - actually give us a gas estimate for
17:48 - specific functions so what i can do is
17:51 - something like let's go u into x is
17:54 - equal to zero and let's go function
17:58 - set x let's take in
18:00 - a uint value
18:02 - let's just make this
18:04 - public and then what we can do is say x
18:06 - is equal to value okay so this is my
18:09 - function very very simple all we're
18:10 - doing is assigning a variable now if i
18:12 - hover over the function name notice that
18:15 - down here kind of in the right corner or
18:17 - i guess not really corner but right on
18:18 - the console bar it's showing us the
18:20 - execution cost is going to be 22
18:23 - 498 gas so that's a significant amount
18:26 - of gas considering we're only doing a
18:28 - very simple operation all right so now
18:30 - that we've seen that let's just do a few
18:31 - more examples and estimate some more gas
18:33 - costs so another thing we might want to
18:35 - do is evaluate a condition maybe we want
18:37 - to use a require statement or something
18:39 - like that so let's just do something
18:41 - like
18:42 - require and we'll say val
18:45 - is greater than and let's just go with
18:47 - 10 and we'll say val is too low okay put
18:51 - our semicolon let's see how much gas
18:53 - it's telling us now so if i hover over
18:54 - here now you can see the gas has
18:56 - increased a small amount so the required
18:57 - statement doesn't really use that much
18:59 - gas right now let's see what happens if
19:01 - we try to add a number so let's do
19:03 - something like x plus equals val
19:05 - multiplied by 10
19:07 - and let's look at the gas estimate now
19:09 - and nose is giving us an infinite gas
19:11 - now whenever you're seeing infinite gas
19:13 - that usually means a remix is not able
19:15 - to estimate how much this is going to
19:17 - cost now in this case the reason it's
19:19 - saying infinite is because val can be
19:20 - any single number now if val is any
19:23 - number greater than 10 when i multiply
19:25 - this by 10 remix has no idea how much
19:27 - this computation is going to cost
19:29 - because the larger value is then you
19:32 - know the more that this is going to be
19:33 - the more gas this is going to cost
19:35 - because the more addition operations we
19:37 - need to do essentially whenever you're
19:38 - doing multiplication you're really doing
19:40 - repeated addition and while the more
19:41 - repeated addition the more gas this
19:43 - costs so infinite gas is just telling
19:45 - you it could theoretically be anything
19:47 - and you really want to try to limit
19:48 - these functions so that they cannot cost
19:50 - infinite gas because if they cost
19:52 - infinite gas you could do a transaction
19:54 - that will never be able to run because
19:56 - you can't pass enough gas to actually be
19:58 - able to execute it alright hopefully
20:00 - that makes a bit of sense i just want to
20:02 - give you a quick example of the gas
20:04 - costs and how quickly they go up using
20:06 - smart contracts now i will talk to you
20:08 - about structs and then we'll talk about
20:10 - some programs that are really limited on
20:13 - the blockchain because of the fact that
20:15 - we can't really do any looping or at
20:16 - least not very efficiently all right so
20:18 - to illustrate structs to you i first
20:20 - want to start by showing the alternative
20:21 - to structs would which would be actually
20:23 - representing objects using contracts now
20:26 - contracts just like classes can be
20:28 - instantiated so i can have different
20:30 - instances of the contract now typically
20:32 - we just deploy a single contract but
20:34 - this contract can instantiate another
20:36 - contract and then have a reference to
20:38 - them so for example i can do something
20:40 - like this i can have contract person i
20:43 - can have you and age string name you end
20:45 - balance i can have a constructor and i
20:47 - can treat this just like i would any
20:49 - other class and say job right now from
20:51 - this tutorial class what i might do is
20:54 - create a function like this i might say
20:55 - function
20:57 - create
20:58 - and then person and then maybe i take in
21:00 - my uint age and then my string
21:05 - memory
21:06 - name like that and then the balance
21:07 - would just imagine would be uh
21:09 - implemented at another time
21:11 - okay then i'm going to say public and
21:13 - then inside of here what i can do is
21:14 - actually create an instance of this
21:15 - person class so i would say person
21:17 - person equals new
21:20 - person and then i would just pass my
21:22 - constructor values so
21:24 - uh this needs to be a string sorry age
21:27 - and name okay there we go i've just
21:28 - created a person instance now this is an
21:30 - instance of this contract now this looks
21:33 - perfectly fine however this is going to
21:34 - cost you a ton of gas because contracts
21:37 - are much more expensive to work with
21:39 - than structs so instead what you would
21:41 - want to do is replace this contract with
21:43 - the struct now the struct would look
21:45 - something like this
21:48 - let's do this struct and then we can
21:50 - remove the constructor and just do the
21:52 - following there's a few other changes i
21:54 - need to make here so when i'm working
21:55 - with a struct first of all i no longer
21:57 - need the new keyword and i also need to
21:59 - pass a balance right so i'm going to
22:01 - pass the balance zero the reason i need
22:03 - the balance is because this is a
22:04 - required field in the struct i'm storing
22:06 - an age a name and a balance and if i
22:08 - initialize my struct in this way then i
22:10 - need to pass all of these fields i'll
22:11 - show you another way to initialize it in
22:13 - a second now we're getting an error the
22:15 - error is that i need to specify the
22:16 - location for this type the reason for
22:19 - that is this is a reference data type
22:20 - meaning it's mutable so i can change it
22:22 - later on
22:23 - so i need to specify memory here just
22:26 - like for my strings now when i do this
22:28 - notice it's all good now it's telling me
22:30 - i can make this a pure function i
22:31 - believe yeah because i'm not actually
22:32 - working with the state of the contract
22:34 - this is just an example to illustrate
22:36 - the struct now i'm getting a warning
22:38 - here just saying that this can be a pure
22:40 - function because uh what do you call
22:42 - we're not dealing with the state of the
22:44 - contract anyways this is what you want
22:46 - to do if you want to store like custom
22:48 - data essentially in a custom type create
22:50 - a struct rather than creating a contract
22:52 - so now to really uh kind of show the use
22:55 - case of a struct we'll write a very
22:56 - simple contract that's going to allow us
22:59 - to associate an address with a person so
23:02 - what i'm going to do is put a mapping up
23:03 - here and i'm going to map
23:06 - an address
23:07 - to a person like that totally fine for
23:10 - me to do that and i will just call this
23:12 - people
23:13 - so now when i create my person i will
23:16 - add them into the uh the people map so
23:19 - what i'll do after i make my person is i
23:21 - will say people at and then this is
23:23 - going to be the address so
23:25 - message.sender is equal to person like
23:28 - that and then of course i would adjust
23:30 - the balance if money was sent into this
23:33 - contract so now that we've seen this
23:34 - i'll just show you another way of
23:35 - initializing this person because we
23:37 - don't have to do it in this way so i can
23:39 - actually remove kind of the literal i
23:41 - guess written person
23:42 - and just say person memory person like
23:45 - that and now i can just specify the
23:47 - attributes on this person so i can say
23:49 - person.age
23:51 - is equal to age i can say person.name
23:55 - is equal to name and then if i don't do
23:57 - anything for the balance that's
23:58 - completely fine because the balance will
24:00 - be initialized as 0.
24:02 - anyways that's another way that you can
24:03 - initialize a struct just wanted to show
24:05 - you you can do it in this way or you can
24:06 - actually write out kind of i guess the
24:08 - main initialization or the constructor
24:10 - initialization where you pass in those
24:12 - values
24:13 - anyways that is pretty much all i had
24:15 - for this first section here i showed you
24:18 - the gas cost associated with looping and
24:20 - how looping is really a big problem in
24:22 - smart contracts and is unfeasible
24:24 - especially if you're doing a large
24:25 - amount of computations i also showed you
24:27 - that storing strings and bytes is very
24:29 - expensive and you don't want to do that
24:32 - lastly i talked about structs here and
24:34 - how if you want to represent kind of a
24:35 - custom object or a custom type it's much
24:38 - cheaper and better practice to use a
24:40 - struct rather than to use a separate
24:43 - contract right which would kind of act
24:45 - as a class you don't really want to be
24:47 - doing that in solidity there are some
24:48 - use cases but if we're going to be
24:50 - creating a ton of different people like
24:51 - this we definitely don't want to be
24:52 - using a separate contract now what i
24:55 - would like to do is really focus more on
24:57 - the limitations of solidity based on
24:58 - some of these things you just saw and
25:00 - talk about how we would implement
25:02 - something like an order book in solidity
25:04 - now an order book is essentially what's
25:06 - used when you're trading stocks you're
25:08 - trading assets of some sort you want to
25:10 - have buy orders and sell orders and
25:12 - match the buy and the sell orders now in
25:14 - cryptocurrency you definitely need this
25:16 - you need a way to exchange your
25:17 - different coins buy coins sell coins
25:20 - whatever it may be so i'm going to hop
25:22 - over to the blackboard now or the
25:23 - drawing tablet and start talking to you
25:25 - about how we would implement order book
25:27 - in solidity a lot of the problems that
25:29 - we're going to run into doing that and
25:31 - then some of the solutions we may have
25:33 - to actually make this more feasible all
25:35 - right so i'm here on my drawing tablet i
25:37 - want to begin by explaining to you what
25:39 - an order book is so an order book is
25:41 - essentially used whenever you're trying
25:43 - to trade something so in this situation
25:45 - let's say we're talking about us dollars
25:46 - and then something like ethereum
25:49 - now an order book just really states the
25:51 - buy and the sell orders for this
25:53 - specific asset so in this case with us
25:55 - dollars we would be buying ethereum so
25:57 - these would be our buy orders and then
25:58 - on the other side we would have sell
26:00 - orders now whenever we want to actually
26:02 - make a trade we need to match buy and
26:04 - sell orders together based on the price
26:07 - so when i put in a buy order i need to
26:09 - specify the price that i want to
26:10 - purchase the ethereum at
26:12 - now what i would do is something like
26:14 - one ethereum and then i want to buy this
26:16 - at maybe 4k right that's the price that
26:18 - i'm willing to buy this at i put that
26:20 - buy order into the book
26:22 - now maybe someone wants to sell ethereum
26:24 - maybe they're selling one ethereum and
26:25 - maybe they want to sell it at like four
26:27 - point four thousand well if this is the
26:28 - case we cannot match these two orders
26:30 - together because they have different
26:32 - prices now you can probably realize just
26:34 - by looking at this it's going to be very
26:36 - difficult to actually match buy and sell
26:38 - orders because the probability that two
26:40 - people are going to have the exact same
26:42 - price in mind for this specific asset
26:44 - well that's just very rare you know the
26:46 - seller is always going to want to sell
26:47 - high the buyer is always going to want
26:48 - to buy low so because of this situation
26:51 - we can use multiple buy orders or
26:53 - multiple cell orders to fill either
26:55 - order right so maybe i have a ton of
26:57 - small buy orders something like 0.1
26:59 - ethereum well if all of these small
27:01 - orders allow me to actually fill one
27:03 - large cell order then i would use you
27:05 - know all let's say 10 of these to fill
27:07 - this one ethereum order now of course
27:08 - they have to be at the same price and so
27:10 - we end up running into the same problem
27:11 - again now this is where we talk about
27:13 - something called market makers so i'm
27:15 - going to draw this right here market
27:17 - make now a market maker essentially
27:19 - provides liquidity to this trading pair
27:22 - or to this order book because as i was
27:24 - saying it can be very rare to have our
27:26 - buyers and sellers agreeing on a price
27:28 - so the market maker is actually a
27:30 - neutral entity that's always willing to
27:32 - buy and always willing to sell now they
27:34 - have incentives to do this they will
27:36 - earn some rewards some fees whatever it
27:38 - may be but the idea is they're always
27:40 - buying and they're always selling and
27:41 - this allows liquidity in this market
27:44 - they make the market it allows me at any
27:46 - point in time to go and buy my ethereum
27:48 - or sell the ethereum now the market
27:50 - maker is pretty well dictating the price
27:52 - of this asset based on the pressure to
27:54 - buy and the pressure to sell now i don't
27:56 - want to get more into this because it's
27:58 - a bit beyond my scope of knowledge and
28:00 - finance and all of that but that's the
28:01 - basics of an order book and now we'll
28:03 - talk about how you would implement
28:04 - something like that on the blockchain so
28:07 - of course an order book is pretty
28:08 - important especially when we're talking
28:09 - about cryptocurrency people want to buy
28:11 - and people want to sell
28:13 - so let's draw out another order book
28:15 - right here and i'll talk about how we
28:17 - would actually kind of do this
28:18 - algorithmically because of course
28:20 - although this was done manually in the
28:21 - old days we now have computers that do
28:23 - this for us and they can do it very very
28:25 - quickly and efficiently
28:27 - so let's say we have a bunch of buy
28:28 - orders over here in green we have a
28:30 - bunch of sell orders here in red well
28:33 - the first thing that we should realize
28:35 - is that since we're going to implement
28:36 - this as a smart contract if someone is
28:38 - going to be making say a large cell
28:40 - order maybe a one ethereum or maybe a
28:42 - lot more than one ethereum they're going
28:44 - to have to use
28:46 - usually multiple buy orders to fill this
28:49 - cell order so they may have to actually
28:51 - loop maybe 20 30 40 maybe 500 times to
28:55 - actually fill their order and as we saw
28:57 - previously looping is very very
28:59 - expensive and so the more looping we
29:01 - have to do the more it's going to cost
29:02 - whoever is performing the transaction
29:04 - now we also may run into a problem where
29:06 - someone needs to loop more times than
29:08 - that is allowed in the smart contract
29:10 - based on the gas limit let's say i want
29:13 - to make a sell order of maybe a hundred
29:15 - ethereum well the chances that someone
29:17 - else is going to be buying 100 ethereum
29:19 - is slim maybe there's a ton of people
29:20 - buying a small amount of ethereum so i
29:22 - might have to loop say
29:24 - 2 000 times now if the maximum number of
29:27 - loops i can do in one iteration of my
29:29 - smart contract or one call sorry of my
29:31 - smart contract is a hundred then i'm
29:33 - going to have to split this into two
29:35 - separate orders to be able to actually
29:37 - make this cell right i'm gonna have to
29:39 - do two 50 f cells because i can only do
29:42 - a thousand loops in one smart contract
29:44 - transaction
29:45 - so that's kind of the main problem we're
29:47 - going to run into here and it really
29:48 - just has to do with the ability of
29:50 - looping with the smart contract
29:52 - now this is kind of a naive perspective
29:54 - because this assumes that everyone
29:56 - interacting with this contract is
29:58 - interacting with good intentions they're
30:00 - a good actor everyone wants to buy
30:01 - everyone wants to sell they're not
30:03 - trying to manipulate the market but of
30:05 - course people are always going to try to
30:06 - manipulate the market and one way they
30:08 - could do that with something like this
30:10 - is they could put in a ton of tiny buy
30:13 - orders so let's say we have some buyer
30:15 - who's really trying to kind of lag the
30:16 - smart contract and make it take a very
30:18 - long time or be very expensive to
30:20 - interact with well the way they would do
30:22 - this
30:23 - is they would put in a ton of fractional
30:25 - kind of bogus buy orders and they would
30:27 - do this many many times let's say maybe
30:29 - they have a thousand of these orders
30:30 - realistically it would be way more than
30:32 - that but they have a ton of these orders
30:34 - that they're adding they're all very
30:35 - small buy orders well now even if i want
30:37 - to make a relatively small cell order of
30:39 - say one ethereum i have to loop
30:41 - thousands of times in this case probably
30:43 - hundreds of thousands of times to
30:45 - actually be able to fill this order
30:46 - because there's so many small buy orders
30:48 - so now again that requires me as the
30:50 - seller to split this into very very
30:53 - small amounts to be selling so maybe i
30:55 - have to sell
30:56 - this amount at a time because i just
30:58 - cannot do enough loops in my smart
31:00 - contract transaction
31:02 - so that's kind of a main problem that
31:03 - can arise here you can have people try
31:05 - to manipulate the market and when
31:06 - someone does this if we're not handling
31:09 - this correctly it's going to cause the
31:10 - seller practically to not be able to
31:12 - sell because it's going to take them so
31:14 - long and it's going to cost them a lot
31:15 - of money to do that so the way that we
31:17 - de-incentivize this type of behavior is
31:19 - we put the burden of looping on the
31:21 - buyer now the seller is still going to
31:24 - have to loop to fill their order but we
31:26 - try to make it so that less small buy
31:28 - orders come in by kind of penalizing
31:30 - those so for example if we want to
31:32 - purchase one ethereum what we do as the
31:34 - seller is we loop through buy orders
31:36 - hopefully in efficient manner and we
31:38 - mark all of the orders that we require
31:40 - to fill this cell order as executed now
31:43 - when we mark them as executed that
31:45 - essentially means that we've made the
31:46 - trade so we immediately take all of the
31:49 - usd funds we give those to the seller
31:52 - but then we lock this asset in the smart
31:54 - contract and we require that the buyer
31:57 - do as many transactions as they
31:59 - originally did to buy to be able to take
32:02 - their stock back
32:03 - so what i mean by that is if they did a
32:06 - thousand of these tiny little
32:07 - transactions
32:08 - they need to do a thousand more
32:10 - transactions to retrieve all of those
32:12 - funds from the smart contract so for
32:15 - example if they want to take whatever it
32:16 - is they bought for you know 0.0001 usd
32:19 - or after whatever it's going to be then
32:21 - they need to do one transaction and that
32:23 - will give them whatever the amount of
32:25 - stock that was traded in this specific
32:27 - trade hopefully that's making a bit of
32:29 - sense but they will take this amount of
32:31 - ethereum they'll get that from this one
32:32 - transaction then they have to do this a
32:35 - thousand more times because they had so
32:36 - many orders so for every order they need
32:39 - to do one transaction to retrieve all of
32:41 - the funds that were traded in that
32:43 - specific order
32:44 - so this now puts the burden of looping
32:46 - on the buyer and hopefully
32:48 - de-incentivizes them from doing this now
32:50 - of course we still have this underlying
32:52 - problem that the seller needs to do
32:54 - looping to be able to actually fill
32:56 - their cell order so we need to come up
32:58 - with an efficient way to do this and
32:59 - that's what i want to talk to you about
33:01 - now as we head over to the other screen
33:03 - so to reiterate here the main problem
33:05 - that we're running into is that we're
33:07 - requiring a ton of loops to be able to
33:10 - perform buy and sell orders and even if
33:12 - we implement that previous solution we
33:14 - talked about the seller still needs to
33:16 - determine which buy orders to match with
33:19 - to be able to make the sale right and
33:21 - then we have to mark orders as executed
33:23 - we have to store these orders somewhere
33:25 - how do we do all of that that's really
33:27 - the question right now and how do we do
33:29 - it in an efficient manner because we
33:30 - can't have nested for loops we can't
33:32 - have any crazy algorithms that are
33:34 - taking really long time to run that's
33:36 - just not feasible on the blockchain and
33:38 - with smart contracts now solution one is
33:41 - really the approach that has to be done
33:43 - on the blockchain and this is to come up
33:45 - with the most efficient data structures
33:47 - and algorithms possible to implement
33:49 - what we just talked about we need
33:50 - probably an advanced type of tree that's
33:52 - going to allow us to look for the
33:54 - largest possible orders to fill the
33:55 - largest sell orders so we only use four
33:58 - five six orders and require a very
34:00 - little amount of looping to be able to
34:02 - make a sale now of course the same thing
34:04 - happens on the buy side the idea though
34:06 - is that we need to do all of this
34:07 - efficiently and again we need to manage
34:09 - our storage efficiently as well because
34:11 - it's expensive to store orders on the
34:13 - blockchain so solution one is
34:15 - essentially be a genius and come up with
34:17 - a great data structure and algorithm
34:18 - that has no bugs has no problems is
34:20 - never going to be inefficient and use
34:22 - that now of course that's not really the
34:24 - most reasonable approach ask me to
34:26 - implement order book i have no idea
34:28 - where to even start that's going to be
34:29 - very complicated i'm going to do a ton
34:30 - of research hopefully i'm going to find
34:32 - someone who's done something like this
34:34 - before and kind of copy what they have
34:36 - but even then again this is just really
34:38 - an impractical approach for most people
34:39 - trying to implement something like this
34:41 - and even if you do come up with an
34:42 - implementation the first approach is
34:44 - most likely going to be buggy it's going
34:46 - to be inefficient and it's probably
34:47 - going to be infeasible to use so then
34:50 - solution two is essentially kind of
34:52 - similar to solution one
34:54 - copy someone else who's already done
34:55 - this hope that there's some genius out
34:57 - there who's written a great order book
34:58 - just take the exact same order book
35:00 - maybe modify it a little bit if you were
35:02 - trying to make your own and use that now
35:03 - again that's really still not a great
35:05 - approach you can still have a lot of
35:07 - inefficiencies and you still might have
35:08 - to loop a ton of times to be able to
35:10 - fill a buy or sell order now the third
35:13 - solution is kind of more of an abstract
35:15 - one but this would be to use something
35:17 - off the blockchain maybe like a sql
35:19 - database that's already very efficient
35:21 - at searching for specific orders maybe
35:23 - you write some advanced select query
35:25 - that can kind of give this information
35:27 - to you and then you store hashes of this
35:29 - on the blockchain whatever it's going to
35:30 - be unfortunately interacting with sql
35:33 - from the blockchain isn't really
35:34 - possible right now at least i don't know
35:36 - how to do that and so that kind of
35:37 - limits that option as well
35:39 - so even with the only feasible option
35:41 - which is essentially have a really good
35:43 - data structure and algorithm you're
35:45 - still running into problems now you
35:47 - might be asking yourself at this point
35:48 - in time well how is this done then how
35:50 - do people do this if this is such a
35:51 - problem now you can still use an order
35:53 - book it's just not going to be the most
35:54 - efficient thing in the world but what a
35:56 - lot of platforms are doing now is using
35:58 - something called a liquidity pool now
36:00 - liquidity pool has its own issues i'm
36:01 - not going to talk about those in this
36:03 - video essentially the liquidity pool is
36:05 - just a store of a ton of the assets that
36:08 - you're going to be trading so you have
36:09 - whatever asset 1 is in asset two you
36:11 - have usually an equal amount of them in
36:13 - the pool and then based on the demand
36:15 - for the specific assets the price of
36:16 - those assets will fluctuate within the
36:18 - liquidity pool and the people providing
36:20 - liquidity so putting their assets into
36:22 - the pool will be given a type of reward
36:24 - kind of like a fee that you would pay
36:25 - when you're actually trading them right
36:27 - anyways that's liquidity pool again has
36:29 - its own issues but that's kind of an
36:30 - approach that's being used currently and
36:33 - really with that said i think i'm going
36:34 - to wrap up the video here now i know i
36:36 - didn't talk too much about the solutions
36:38 - but that's because this video is really
36:40 - focused on the limitations of the
36:42 - blockchain and showing you that a lot of
36:44 - stuff we would like to be able to create
36:46 - that would be way simpler to do off the
36:48 - blockchain we just can't feasibly do
36:50 - using smart contracts and on the
36:52 - blockchain because of those limitations
36:54 - now even the stuff i showed you at the
36:55 - beginning of the video strings arrays
36:57 - for loops while loops those are very
36:59 - inefficient to use they cost a lot of
37:01 - money and the reason we left them until
37:03 - the very end was because we don't really
37:05 - want to encourage their use and i want
37:07 - to make sure that
37:08 - you understand kind of the problems with
37:10 - them and that they do exist you can use
37:12 - them but you should be very careful when
37:13 - you're implementing those specific
37:15 - features all right so with that said i
37:16 - am going to end the video here another
37:18 - massive thank you to cartesi for
37:19 - sponsoring this video and this series in
37:22 - the next video we'll be looking at
37:23 - specific solutions and how we can
37:25 - actually write scalable smart contracts
37:27 - in decentralized applications i hope you
37:29 - guys enjoyed if you did make sure to
37:30 - leave a like subscribe the channel and i
37:32 - will see you in another one
37:36 - [Music]

Cleaned transcript:

hello everybody and welcome to the fifth video in this blockchain for beginners tutorial series now in this video i'm going to be talking to you about the limitations of solidity and of smart contracts and some applications that are very difficult to deploy on the blockchain because of these limitations specifically i'll be talking to you about arrays strings for loops while loops and why it's very expensive to use those things in a spark contract and how they can actually cause your smart contract to break or to be in a state where it can never be ran again i'll get into all of that in this video but before we dive in i do need to thank cartesi for sponsoring this video and this series as i've said many times they're an awesome company i've loved working with them through these videos they've really helped me come up with a great curriculum to teach you guys so another massive thank you to them and with that said let's go ahead and get into the video all right so i'm now on my computer and i am in remix in front of me i have a very simple smart contract and what i'm going to be doing in the first part of the video here is talking to you about arrays strings for loops while loops and then finally structs now after we do that i'll talk about some of the limitations of solidities and expenses in using these different features and then we'll talk about some potential i guess fixes or solutions for these limitations so let's begin by talking about arrays so the way you create an array in solidity is you define the type you would like to be inside of the array for all of the elements so in this case i'll say you int you put your square brackets like this if you wanted a multidimensional array you do another set of square brackets and then what you can do after this is put the name of the array or the modifier so i'm going to do something like public arr and then i can just close it off like that so there you go i've just now created a dynamically sized array in solidity so in solidity you could have both a statically sized or fixed sized array or a dynamically sized array if i do something like this where i just have square brackets with no element inside or no value inside this is dynamically sized so this means it will grow as i add more elements to it now if i do something like 5 this is going to say this array can only have 5 elements inside of it i will initialize those elements i believe all as 0. all right so there's the basics for arrays now arrays are a reference type in solidity and that means that they are mutable and we can modify them once they have been created so we have direct index access we can access the length of elements or the length of the array sorry and again we can push elements inside okay so let's just deploy the contract right now and have a look at how we actually access the elements in this array so i'm going to deploy this when i go here notice i'm going to have arr and then i can pass the index of the element that i want to access now arrays are 0 indexed so if i do something like arr and 0 it's going to give me the value 0 because since we statically initialize this array we're going to have one element with value zero or sorry five elements with value zero inside of the array now let's access index one okay we get zero again let's do index four zero again let's do five and then notice here that we actually are going to get a revert the transaction has been reverted to the initial state and that's because an error would have occurred because we're accessing an index that is out of the bounds of this array perfect so now that we have done that let's look at how we can actually i guess modify the elements of this array so let's create a function let's say function i'm just going to say mod arr standing for modify array we will make this a public function and we're not going to return anything we'll just actually modify this okay now inside of here i'm just going to take in a uiint x and a uint idx and instead of x let's actually just go with value just so this is a little bit more clear now essentially what this is going to do is change the element at index to be equal to value so let's just say ar at index let's go idx is equal to val notice we're not getting any errors so this should be good to go okay so let's deploy the contract let's go here we're going to look at index 0 see that that has value 0. now let's change this so let's pass to here a value of say 10 and an index of 0 let's transact looks like that's all good now when we look here notice we have a value of 10. very basic that's how you can modify this array now what i want to do is create a dynamically sized array so let's simply change this by removing the five and now when we do mod array we're just going to take in a value and i'll show you how we can append this value or push it to the array pretty straightforward but you can use the dot push method so i can say ar dot push i can push the value which is uint and now this should be good so let's try this let's deploy the contract let me just delete this one here okay now we have mod array that takes it a value so let's just pass one let's pass two and let's pass three now let's look at index zero index zero is one index one is two and index two is three perfect there we go we just pushed elements into the array all right great so now that we've done that let me show you how we can get the length of the array so i'm just gonna say function get length we'll make this an external and then this can be a view function that returns and then we'll just put you in like that and then inside of here i can simply return error dot length like that okay so this will give us the length you can just use the dot length property so let's now deploy this contract let's go deploy let's mod the array by adding one two and three now let's get the length and notice we have a length of three now let's add another element let's add four get length we're at four there you go that pretty much covers erase i don't think there's actually anything more to go through with arrays uh one thing you can do is access individual elements using the index notation so i can do something like array at zero is equal to one that's perfectly valid or i can just do array at zero that works as well as you saw previously last thing i will mention is that if you want to actually define the literal for the array so you want to do something like this use square brackets so say uint public arr and then one two three this is different than something like i guess c plus plus or java where you would use uh squiggly brackets at least i think you use those in those languages anyways and solidity use square brackets to define the elements in the array perfect hopefully that is clear that pretty much covers arrays okay so now that we have gone through arrays i want to cover strings so let's get rid of all of this now strings and solidity are very expensive to work with and same thing with arrays arrays are very expensive as well and in fact the reason i'm showing them to you last is because mappings are much preferred over a race so you pretty much never want to be using arrays or using strings if you can avoid doing so there is some use cases where you do need them but essentially you always want to go with something like a mapping as opposed to an array i won't get into all of the details but just understand that they cost a lot more gas than something like a mapping so if you can avoid it avoid using arrays and if you want to mess around with kind of the differences in arrays and mappings deploy a few contracts and look at the actual gas cost in terms of working with arrays versus working with mappings and same thing with strings strings are extremely expensive to use in solidity and one of the reasons for that is that a string in solidity is actually a bytes array so you can create a byte array like this now bytes are used for kind of a raw data type and a string in solidity essentially is a bytes array that's going to be decoded and encoded with utf8 just allowing you to actually view the string so let me show you what i mean if i do something like string and i guess we can put public although we don't really need to and we'll just make this equal to a low we can say this is equal to world that is completely valid now you want to again avoid using strings whenever you possibly can because they're very expensive to work with same reason with the arrays because they are actually represented by a bytes array now strings and solidity are extremely simple you do not have index access to them you cannot concatenate them you can't get the length of them there's actually almost no methods or properties for strings you literally can just store a literal string and in most situations it's going to be much more efficient especially if you're working with large strings to store them off of the block chain and simply store a hash of that string in the storage of your contract that will be much much cheaper than actually storing the string itself in the contract anyways let's deploy the contract here with the string notice that i can access this and i can have world right let's see i can see world there so let's create another function let's go function set string and let's go string and then let's go with value now i'm not quite done with this yet i need to talk about something with having strings inside of functions but for now i will say hello is equal to val okay so notice that i'm getting an error here now why am i getting an error this function actually looks pretty valid right i have my string parameter i have this public i'm setting a value this should be good the reason why i'm getting an error here we can hover over this is because the data location must be memory or call data for a parameter so this is where i'm going to talk about the different storage locations that you have in your contract so in your contract you have state or storage they're kind of the same things storage slash state now that essentially means that you're persistently going to be storing this data in the smart contract itself now any data you store is going to cost you small amounts of ethereum right it's going to be more expensive to store more data than to store less you want to store the least amount of stuff that you possibly can so that's the first location storage slash state that's persistent it's always going to be there the other location is memory now memory similar to your computer's ram is a temporary location that's only going to be used when the contract is actually executing so when i'm using a reference type like a string i need to specify it's going to be stored in memory so i'm going to say memory like this so as soon as i put memory we actually would have seen this before i think now this is valid because it's saying i want to store this parameter in memory as opposed to in the state or storage of the contract and you only need to specify this for reference data types so same thing with arrays let's say i did something like uint and then i wanted to have my value like this i would need to now specify memory to not get yelled at by the compiler okay so let's go back to what we had before string memory value hello equals val let's deploy this let's look at this let's go hello world i am tim let's set the string let's look at hello and now we have hello world i am awesome again avoid using strings if you need to use a large string what you want to do is store it off the block chain and simply store a hash of that string on the blockchain that will be much cheaper okay so now we've gone through arrays we have gone through strings i want to show you looping and then i will show you the gas cost associated with a lot of these different features i'm just trying to give you kind of the basics right now okay so let us should we loop through an array no let's just loop over kind of a range of numbers to start so i'm just going to say function and i will say loop and i'm going to take in uint n and all i'm going to do here is simply loop over n numbers so to do a for loop in solidity is similar to pretty much every other programming language you can say 4 and then you can define your looping variable so i'm going to say u and i i'm going to say i is less than n and then i'm going to say i plus plus okay so i'm just incrementing i by 1 in every iteration and then what i'm going to do here is i guess we can just add to some variable or something because i'm just trying to illustrate looping so i'll do something like uint sum is equal to zero and then sum plus equals i and i think that should be good and if we wanted to we could return the sum but this is fine we'll just do this for now so i just had to take a quick cut there because my cat was freaking out at me for some reason anyways that is now resolved but continuing here we're getting a warning the reason we're getting a warning is because this can be restricted to pure the reason for that is because we're not actually modifying or accessing the state of the contract so i just want to put pure like this anyways this is how you do a for loop now i will mention that the for loops again are going to be very very expensive to run if you're not doing them in something like a pure function right in a pure function or something that doesn't require a transaction it's not going to cost you ethereum to run this however it's going to be very expensive to implement for loops when you're actually working with the state of the contract now the reason for that is whenever you do a transaction you need to pass gas along with that transaction right and the gas cost is the sum of all the operations that the contract is doing so in this case it's going to cost me gas to actually add a number to another number right for me to add two numbers that cost gas but here in this situation the amount of gas this would cost if it wasn't a pure function is n multiplied by all of the gas used inside of the for loop now that might not seem like a lot but if an n is a large number say like a thousand or ten thousand and the amount of gas in here is four gas 20 gas 100 gas something along those lines you can see how the amount of gas required adds up very very quickly and it becomes unfeasible to actually be able to loop inside of smart contracts and in fact there's actually a maximum amount of gas that you can pass to an ethereum smart contract i believe right now it's at 30 million gas in fact i think that's right here it's the gas limit that's showing up regardless you can only pass so much gas so if your smart contract needs to do a ton of computations you have to have multiple transactions to be able to complete that because you need to pass the required gas and you can only do a certain amount of gas in each transaction anyways that was kind of it for for loops i just want to show you the syntax this is the basics of for loops now i will show you while loops so let's do a very similar thing here let's just manually declare i so u and i is equal to zero we'll say well i is less than n we'll say i plus plus we can do that at the end and then we'll say sum plus equals i like that perfect there you go this is a while loop again not really going to explain this i'm sure most of you understand how this works anyways those are for loops and while loops and now that we've looked at those i want to write a very simple smart contract that's going to work with arrays and for loops or while loops and show you how much gas it actually costs on an ethereum test network so let's start by just initializing an array here and let's just say u end and let's go arr and let's just make this equal i guess actually i can just define it like that u and ar that's fine for now then i'm going to have a function i'm going to say function create ar i'm going to say u and n and i will go with string value and i'm actually going to change the type of this array to be a string array and show you how expensive this gets okay now i will make this public now what i want to do here is essentially initialize this array with n elements that are equal to this string value now i need to remember to add my memory keyword otherwise it's going to get mad okay so let's do this so what i'm going to do is write a for loop i'm going to say 4 again this will be i uh u and i this is going to be i is less than n let's add a space here and then i plus plus okay now what we'll do is set rr dot push and we're going to push the value like so okay so right now we can technically run this infinite number of times and i'll show you what happens if we try to do that but i want to deploy this to our injected web 3 to the go rally test network uh so it says custom network right now let me just go to my metamask and change this to goreli and then we will deploy this and test it out all right so we are back on goreli i'm going to deploy let's see how much this is going to cost us right now okay so not a significant amount of gas because obviously we haven't done any computation yet in the contract and then once this is deployed we will actually try running this method and see how much gas it cost us all right so it looks as though the contract has been deployed we can see it down here it says create arr now let's just see again this is going to be kind of antidote i'll just go through a few uh examples here how much it costs to do one that has 10 elements and the string hello world now i need to quote this string here so let's do that and let's transact and see approximately how much this costs us so when i do this notice we're getting 0.00 okay so we can kind of copy that and keep that in mind and then i'll show you how this is going to i guess not exponentially but go up a lot as i increase the value of n so let's now do one that has a thousand elements and see how much this costs so when i do transact now we're going to see that now we're at 0.05 now if you actually put that into the price of ethereum 0.05 ethereum is a lot now i'm not sure if it would be the exact same on the regular ethereum network but the point is you saw how we drastically increase this to a whole decimal point right just by making this a thousand instead of site 10 and then let's go crazy and let's make this something like a hundred thousand and transact and see how much this would cost and here it tells me we actually cannot even send this amount of gas the transaction will likely fail so let's go to 10 000 and see if 10 000 is doable same thing we can't even do 10 000 let's try doing something like 5000 and see if that's gonna work okay 5000 doesn't work let's try 25 000 transact okay that's not going to work so just trying to show you here that we really cannot do a lot of looping operations and even if we try to do a lot of looping operations that is going to be very very expensive to the point where it really doesn't make sense to do them inside of the smart contract all right so now that we've gone through those few examples just so you can see kind of in the real world how much the gas is going to cost let me delete all of this and show you that remix can actually give us a gas estimate for specific functions so what i can do is something like let's go u into x is equal to zero and let's go function set x let's take in a uint value let's just make this public and then what we can do is say x is equal to value okay so this is my function very very simple all we're doing is assigning a variable now if i hover over the function name notice that down here kind of in the right corner or i guess not really corner but right on the console bar it's showing us the execution cost is going to be 22 498 gas so that's a significant amount of gas considering we're only doing a very simple operation all right so now that we've seen that let's just do a few more examples and estimate some more gas costs so another thing we might want to do is evaluate a condition maybe we want to use a require statement or something like that so let's just do something like require and we'll say val is greater than and let's just go with 10 and we'll say val is too low okay put our semicolon let's see how much gas it's telling us now so if i hover over here now you can see the gas has increased a small amount so the required statement doesn't really use that much gas right now let's see what happens if we try to add a number so let's do something like x plus equals val multiplied by 10 and let's look at the gas estimate now and nose is giving us an infinite gas now whenever you're seeing infinite gas that usually means a remix is not able to estimate how much this is going to cost now in this case the reason it's saying infinite is because val can be any single number now if val is any number greater than 10 when i multiply this by 10 remix has no idea how much this computation is going to cost because the larger value is then you know the more that this is going to be the more gas this is going to cost because the more addition operations we need to do essentially whenever you're doing multiplication you're really doing repeated addition and while the more repeated addition the more gas this costs so infinite gas is just telling you it could theoretically be anything and you really want to try to limit these functions so that they cannot cost infinite gas because if they cost infinite gas you could do a transaction that will never be able to run because you can't pass enough gas to actually be able to execute it alright hopefully that makes a bit of sense i just want to give you a quick example of the gas costs and how quickly they go up using smart contracts now i will talk to you about structs and then we'll talk about some programs that are really limited on the blockchain because of the fact that we can't really do any looping or at least not very efficiently all right so to illustrate structs to you i first want to start by showing the alternative to structs would which would be actually representing objects using contracts now contracts just like classes can be instantiated so i can have different instances of the contract now typically we just deploy a single contract but this contract can instantiate another contract and then have a reference to them so for example i can do something like this i can have contract person i can have you and age string name you end balance i can have a constructor and i can treat this just like i would any other class and say job right now from this tutorial class what i might do is create a function like this i might say function create and then person and then maybe i take in my uint age and then my string memory name like that and then the balance would just imagine would be uh implemented at another time okay then i'm going to say public and then inside of here what i can do is actually create an instance of this person class so i would say person person equals new person and then i would just pass my constructor values so uh this needs to be a string sorry age and name okay there we go i've just created a person instance now this is an instance of this contract now this looks perfectly fine however this is going to cost you a ton of gas because contracts are much more expensive to work with than structs so instead what you would want to do is replace this contract with the struct now the struct would look something like this let's do this struct and then we can remove the constructor and just do the following there's a few other changes i need to make here so when i'm working with a struct first of all i no longer need the new keyword and i also need to pass a balance right so i'm going to pass the balance zero the reason i need the balance is because this is a required field in the struct i'm storing an age a name and a balance and if i initialize my struct in this way then i need to pass all of these fields i'll show you another way to initialize it in a second now we're getting an error the error is that i need to specify the location for this type the reason for that is this is a reference data type meaning it's mutable so i can change it later on so i need to specify memory here just like for my strings now when i do this notice it's all good now it's telling me i can make this a pure function i believe yeah because i'm not actually working with the state of the contract this is just an example to illustrate the struct now i'm getting a warning here just saying that this can be a pure function because uh what do you call we're not dealing with the state of the contract anyways this is what you want to do if you want to store like custom data essentially in a custom type create a struct rather than creating a contract so now to really uh kind of show the use case of a struct we'll write a very simple contract that's going to allow us to associate an address with a person so what i'm going to do is put a mapping up here and i'm going to map an address to a person like that totally fine for me to do that and i will just call this people so now when i create my person i will add them into the uh the people map so what i'll do after i make my person is i will say people at and then this is going to be the address so message.sender is equal to person like that and then of course i would adjust the balance if money was sent into this contract so now that we've seen this i'll just show you another way of initializing this person because we don't have to do it in this way so i can actually remove kind of the literal i guess written person and just say person memory person like that and now i can just specify the attributes on this person so i can say person.age is equal to age i can say person.name is equal to name and then if i don't do anything for the balance that's completely fine because the balance will be initialized as 0. anyways that's another way that you can initialize a struct just wanted to show you you can do it in this way or you can actually write out kind of i guess the main initialization or the constructor initialization where you pass in those values anyways that is pretty much all i had for this first section here i showed you the gas cost associated with looping and how looping is really a big problem in smart contracts and is unfeasible especially if you're doing a large amount of computations i also showed you that storing strings and bytes is very expensive and you don't want to do that lastly i talked about structs here and how if you want to represent kind of a custom object or a custom type it's much cheaper and better practice to use a struct rather than to use a separate contract right which would kind of act as a class you don't really want to be doing that in solidity there are some use cases but if we're going to be creating a ton of different people like this we definitely don't want to be using a separate contract now what i would like to do is really focus more on the limitations of solidity based on some of these things you just saw and talk about how we would implement something like an order book in solidity now an order book is essentially what's used when you're trading stocks you're trading assets of some sort you want to have buy orders and sell orders and match the buy and the sell orders now in cryptocurrency you definitely need this you need a way to exchange your different coins buy coins sell coins whatever it may be so i'm going to hop over to the blackboard now or the drawing tablet and start talking to you about how we would implement order book in solidity a lot of the problems that we're going to run into doing that and then some of the solutions we may have to actually make this more feasible all right so i'm here on my drawing tablet i want to begin by explaining to you what an order book is so an order book is essentially used whenever you're trying to trade something so in this situation let's say we're talking about us dollars and then something like ethereum now an order book just really states the buy and the sell orders for this specific asset so in this case with us dollars we would be buying ethereum so these would be our buy orders and then on the other side we would have sell orders now whenever we want to actually make a trade we need to match buy and sell orders together based on the price so when i put in a buy order i need to specify the price that i want to purchase the ethereum at now what i would do is something like one ethereum and then i want to buy this at maybe 4k right that's the price that i'm willing to buy this at i put that buy order into the book now maybe someone wants to sell ethereum maybe they're selling one ethereum and maybe they want to sell it at like four point four thousand well if this is the case we cannot match these two orders together because they have different prices now you can probably realize just by looking at this it's going to be very difficult to actually match buy and sell orders because the probability that two people are going to have the exact same price in mind for this specific asset well that's just very rare you know the seller is always going to want to sell high the buyer is always going to want to buy low so because of this situation we can use multiple buy orders or multiple cell orders to fill either order right so maybe i have a ton of small buy orders something like 0.1 ethereum well if all of these small orders allow me to actually fill one large cell order then i would use you know all let's say 10 of these to fill this one ethereum order now of course they have to be at the same price and so we end up running into the same problem again now this is where we talk about something called market makers so i'm going to draw this right here market make now a market maker essentially provides liquidity to this trading pair or to this order book because as i was saying it can be very rare to have our buyers and sellers agreeing on a price so the market maker is actually a neutral entity that's always willing to buy and always willing to sell now they have incentives to do this they will earn some rewards some fees whatever it may be but the idea is they're always buying and they're always selling and this allows liquidity in this market they make the market it allows me at any point in time to go and buy my ethereum or sell the ethereum now the market maker is pretty well dictating the price of this asset based on the pressure to buy and the pressure to sell now i don't want to get more into this because it's a bit beyond my scope of knowledge and finance and all of that but that's the basics of an order book and now we'll talk about how you would implement something like that on the blockchain so of course an order book is pretty important especially when we're talking about cryptocurrency people want to buy and people want to sell so let's draw out another order book right here and i'll talk about how we would actually kind of do this algorithmically because of course although this was done manually in the old days we now have computers that do this for us and they can do it very very quickly and efficiently so let's say we have a bunch of buy orders over here in green we have a bunch of sell orders here in red well the first thing that we should realize is that since we're going to implement this as a smart contract if someone is going to be making say a large cell order maybe a one ethereum or maybe a lot more than one ethereum they're going to have to use usually multiple buy orders to fill this cell order so they may have to actually loop maybe 20 30 40 maybe 500 times to actually fill their order and as we saw previously looping is very very expensive and so the more looping we have to do the more it's going to cost whoever is performing the transaction now we also may run into a problem where someone needs to loop more times than that is allowed in the smart contract based on the gas limit let's say i want to make a sell order of maybe a hundred ethereum well the chances that someone else is going to be buying 100 ethereum is slim maybe there's a ton of people buying a small amount of ethereum so i might have to loop say 2 000 times now if the maximum number of loops i can do in one iteration of my smart contract or one call sorry of my smart contract is a hundred then i'm going to have to split this into two separate orders to be able to actually make this cell right i'm gonna have to do two 50 f cells because i can only do a thousand loops in one smart contract transaction so that's kind of the main problem we're going to run into here and it really just has to do with the ability of looping with the smart contract now this is kind of a naive perspective because this assumes that everyone interacting with this contract is interacting with good intentions they're a good actor everyone wants to buy everyone wants to sell they're not trying to manipulate the market but of course people are always going to try to manipulate the market and one way they could do that with something like this is they could put in a ton of tiny buy orders so let's say we have some buyer who's really trying to kind of lag the smart contract and make it take a very long time or be very expensive to interact with well the way they would do this is they would put in a ton of fractional kind of bogus buy orders and they would do this many many times let's say maybe they have a thousand of these orders realistically it would be way more than that but they have a ton of these orders that they're adding they're all very small buy orders well now even if i want to make a relatively small cell order of say one ethereum i have to loop thousands of times in this case probably hundreds of thousands of times to actually be able to fill this order because there's so many small buy orders so now again that requires me as the seller to split this into very very small amounts to be selling so maybe i have to sell this amount at a time because i just cannot do enough loops in my smart contract transaction so that's kind of a main problem that can arise here you can have people try to manipulate the market and when someone does this if we're not handling this correctly it's going to cause the seller practically to not be able to sell because it's going to take them so long and it's going to cost them a lot of money to do that so the way that we deincentivize this type of behavior is we put the burden of looping on the buyer now the seller is still going to have to loop to fill their order but we try to make it so that less small buy orders come in by kind of penalizing those so for example if we want to purchase one ethereum what we do as the seller is we loop through buy orders hopefully in efficient manner and we mark all of the orders that we require to fill this cell order as executed now when we mark them as executed that essentially means that we've made the trade so we immediately take all of the usd funds we give those to the seller but then we lock this asset in the smart contract and we require that the buyer do as many transactions as they originally did to buy to be able to take their stock back so what i mean by that is if they did a thousand of these tiny little transactions they need to do a thousand more transactions to retrieve all of those funds from the smart contract so for example if they want to take whatever it is they bought for you know 0.0001 usd or after whatever it's going to be then they need to do one transaction and that will give them whatever the amount of stock that was traded in this specific trade hopefully that's making a bit of sense but they will take this amount of ethereum they'll get that from this one transaction then they have to do this a thousand more times because they had so many orders so for every order they need to do one transaction to retrieve all of the funds that were traded in that specific order so this now puts the burden of looping on the buyer and hopefully deincentivizes them from doing this now of course we still have this underlying problem that the seller needs to do looping to be able to actually fill their cell order so we need to come up with an efficient way to do this and that's what i want to talk to you about now as we head over to the other screen so to reiterate here the main problem that we're running into is that we're requiring a ton of loops to be able to perform buy and sell orders and even if we implement that previous solution we talked about the seller still needs to determine which buy orders to match with to be able to make the sale right and then we have to mark orders as executed we have to store these orders somewhere how do we do all of that that's really the question right now and how do we do it in an efficient manner because we can't have nested for loops we can't have any crazy algorithms that are taking really long time to run that's just not feasible on the blockchain and with smart contracts now solution one is really the approach that has to be done on the blockchain and this is to come up with the most efficient data structures and algorithms possible to implement what we just talked about we need probably an advanced type of tree that's going to allow us to look for the largest possible orders to fill the largest sell orders so we only use four five six orders and require a very little amount of looping to be able to make a sale now of course the same thing happens on the buy side the idea though is that we need to do all of this efficiently and again we need to manage our storage efficiently as well because it's expensive to store orders on the blockchain so solution one is essentially be a genius and come up with a great data structure and algorithm that has no bugs has no problems is never going to be inefficient and use that now of course that's not really the most reasonable approach ask me to implement order book i have no idea where to even start that's going to be very complicated i'm going to do a ton of research hopefully i'm going to find someone who's done something like this before and kind of copy what they have but even then again this is just really an impractical approach for most people trying to implement something like this and even if you do come up with an implementation the first approach is most likely going to be buggy it's going to be inefficient and it's probably going to be infeasible to use so then solution two is essentially kind of similar to solution one copy someone else who's already done this hope that there's some genius out there who's written a great order book just take the exact same order book maybe modify it a little bit if you were trying to make your own and use that now again that's really still not a great approach you can still have a lot of inefficiencies and you still might have to loop a ton of times to be able to fill a buy or sell order now the third solution is kind of more of an abstract one but this would be to use something off the blockchain maybe like a sql database that's already very efficient at searching for specific orders maybe you write some advanced select query that can kind of give this information to you and then you store hashes of this on the blockchain whatever it's going to be unfortunately interacting with sql from the blockchain isn't really possible right now at least i don't know how to do that and so that kind of limits that option as well so even with the only feasible option which is essentially have a really good data structure and algorithm you're still running into problems now you might be asking yourself at this point in time well how is this done then how do people do this if this is such a problem now you can still use an order book it's just not going to be the most efficient thing in the world but what a lot of platforms are doing now is using something called a liquidity pool now liquidity pool has its own issues i'm not going to talk about those in this video essentially the liquidity pool is just a store of a ton of the assets that you're going to be trading so you have whatever asset 1 is in asset two you have usually an equal amount of them in the pool and then based on the demand for the specific assets the price of those assets will fluctuate within the liquidity pool and the people providing liquidity so putting their assets into the pool will be given a type of reward kind of like a fee that you would pay when you're actually trading them right anyways that's liquidity pool again has its own issues but that's kind of an approach that's being used currently and really with that said i think i'm going to wrap up the video here now i know i didn't talk too much about the solutions but that's because this video is really focused on the limitations of the blockchain and showing you that a lot of stuff we would like to be able to create that would be way simpler to do off the blockchain we just can't feasibly do using smart contracts and on the blockchain because of those limitations now even the stuff i showed you at the beginning of the video strings arrays for loops while loops those are very inefficient to use they cost a lot of money and the reason we left them until the very end was because we don't really want to encourage their use and i want to make sure that you understand kind of the problems with them and that they do exist you can use them but you should be very careful when you're implementing those specific features all right so with that said i am going to end the video here another massive thank you to cartesi for sponsoring this video and this series in the next video we'll be looking at specific solutions and how we can actually write scalable smart contracts in decentralized applications i hope you guys enjoyed if you did make sure to leave a like subscribe the channel and i will see you in another one
