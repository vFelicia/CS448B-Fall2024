With timestamps:

00:02 - [Music]
00:08 - okay so now
00:09 - that we have this what we need to do is
00:12 - actually allow us to select the piece
00:14 - have it selected and move to a valid
00:16 - square that also involves having to
00:18 - figure out
00:19 - where can we move to like what is a
00:22 - valid square
00:23 - right and if we move and we say jump
00:25 - over a piece
00:27 - how do we remove that piece how do we
00:28 - get rid of it you know can we jump and
00:30 - double jump like those are the stuff
00:31 - things we have to figure out now
00:33 - which are kind of difficult but
00:36 - obviously we're going to do them they
00:37 - won't be
00:37 - that hard okay so i'm going to make a
00:40 - another file inside of checkers and i'm
00:42 - going to call this
00:42 - game.pi now what this is going to be
00:45 - responsible for
00:46 - is handling actually the game so
00:48 - figuring out like whose turn is it
00:50 - did we select a piece is this piece good
00:52 - like can we move here can we move there
00:54 - that's what game is going to do and it's
00:56 - going to use board and a bunch of other
00:58 - stuff to do that for us it's also going
01:00 - to handle like drawing everything and a
01:02 - bunch of other stuff
01:03 - all right so now we're going to code out
01:04 - the game class now the whole point of
01:06 - the game class
01:07 - is going to be to let us actually
01:10 - interface with the board
01:12 - and the pieces and everything else with
01:14 - a few really simple methods
01:15 - so essentially i don't want
01:18 - this main kind of loop that's actually
01:21 - running and checking for us pressing
01:22 - buttons and stuff
01:23 - to be associated at all with how this
01:26 - game operates
01:27 - i want this game to be able to be
01:29 - operated by in theory
01:31 - to computers right i don't want it to be
01:34 - linked in directly to us pressing
01:37 - buttons and all of that because
01:38 - later on what we'll do is implement an
01:40 - ai so we can play against it right
01:42 - so we need to make sure that it's very
01:44 - clear that game just exposes
01:47 - some methods that we can use but it's
01:49 - not like
01:50 - it's not dependent on the fact that
01:52 - we're pressing certain things
01:53 - or that two human players are playing
01:55 - that's kind of what i'm trying to get at
01:56 - here with the point
01:57 - uh with with this so let's define the
02:00 - class
02:02 - let's import pie game like that
02:05 - and say divine underscore underscore net
02:08 - self
02:09 - and doing anything else for game we're
02:11 - actually going to take the window that
02:13 - we want to draw this game on
02:15 - so we could put the window in here if we
02:18 - want like we could define it in this
02:20 - game class
02:21 - i'm not going to just for the purpose
02:23 - that say
02:24 - we actually want to draw or play maybe
02:26 - like four or five chess games at the
02:27 - same time
02:29 - well we could in theory pass a window
02:31 - that is big enough that we could draw
02:32 - four chess games
02:34 - and then we could just pass subsets of
02:36 - that window to different games and play
02:38 - multiple games at the same time so i'm
02:40 - just trying to keep things flexible
02:41 - um we could define win here i'm not
02:44 - going to but
02:45 - just figured i'd tell you why so first
02:47 - i'm going to say self.selected equals
02:49 - none this actually reminds me that i
02:51 - want to go back to
02:52 - board and remove the selected piece
02:54 - because we're not going to use that
02:55 - inside of board we're going to use this
02:57 - inside of game to figure out
02:59 - what piece is selected by someone that's
03:01 - playing if they are
03:02 - and then next i'm going to say
03:03 - self.board
03:06 - equals board so that means from main
03:09 - here
03:10 - we're actually not going to make a board
03:12 - we're actually just going to make a game
03:13 - and the game will control the board for
03:15 - us so rather than having to get the
03:17 - piece move the piece all of that
03:19 - all we'll do is use the game to say okay
03:21 - we selected this row and column
03:23 - move it to this row and column and that
03:25 - will figure all of that out for us
03:26 - so self.board equals board next we're
03:29 - going to say self.turn
03:30 - equals red which means we need to import
03:33 - constants
03:33 - so from dot
03:37 - constants import red
03:40 - white uh what else would we need uh
03:43 - probably a few other things but we'll
03:44 - just leave red and white for now
03:46 - so self.turn equals red and after that
03:49 - we need self dot valid underscore moves
03:53 - equals a dictionary
03:54 - we'll talk about this after but this is
03:56 - going to pretty much tell us what the
03:57 - current valid moves are for whatever
03:59 - player is playing so that we can draw
04:01 - those or we can move those or whatever
04:03 - it may be
04:04 - next we're going to say self.win equals
04:06 - win
04:08 - so just store that window in here so we
04:09 - don't need to pass it every time
04:11 - and then what we're going to do is
04:13 - define an update method
04:15 - so update will just be like say we're
04:17 - updating the pi game display
04:19 - instead we'll just simply call this
04:21 - update method so we'll say
04:23 - inside of update self.board.draw
04:28 - and then anything else that we want to
04:30 - do to actually kind of update the game
04:32 - and then next we'll say pie game dot
04:35 - display
04:36 - dot update so now right if we go back to
04:39 - main
04:40 - all we have to do actually is instead of
04:43 - saying
04:45 - board.drawingpygame.display.update
04:46 - we'll say game dot update like that
04:49 - instead of making a board we'll say game
04:52 - equals game
04:55 - so now in theory we've just kind of
04:57 - wrapped some of this functionality and
04:59 - so i'm going to get rid of those two
05:00 - lines we're not going to use this right
05:01 - now
05:02 - and we need to import game but once we
05:04 - import game all we'll have to do is just
05:06 - use the update method
05:07 - the move method it's a lot simpler on
05:09 - this end when we do that
05:10 - so let's say from trackers dot
05:14 - game import game
05:17 - and let's run this and see if this works
05:20 - okay so i'm getting an issue
05:21 - missing up is a positional argument win
05:24 - so i forgot i have to pass the window to
05:26 - my game
05:26 - so let's do that and what is this now
05:29 - board is
05:30 - not defined as so we need to actually
05:32 - import board
05:34 - into game so let's do that
05:37 - and now let's try it and what's the
05:39 - error this time
05:40 - missing one required positional argument
05:43 - uh win
05:44 - okay so let's go back to uh game sorry
05:47 - guys and let's
05:48 - say self.win inside of the call to
05:51 - selftopword.draw
05:53 - okay and there we go now it's working so
05:55 - we can see that it all works the same
05:57 - we've just kind of wrapped it up and are
05:59 - using it a little bit differently
06:00 - all right so now let's go back to game
06:03 - and let's start defining a few other
06:04 - methods that we want so first i'm going
06:06 - to define a reset method
06:07 - this is pretty straightforward just say
06:08 - we want to reset the game and what we'll
06:10 - need to do is say self.selected equals
06:12 - none
06:14 - self.board equals
06:18 - board self.turn
06:21 - equals red and self.valid moves equals
06:25 - blank and in fact
06:26 - that looks really similar to what all
06:27 - this stuff is right so let's wrap this
06:29 - in a new method
06:30 - and let's just say define and let's
06:32 - actually just call this a knit
06:34 - so inside of the reset method we can
06:37 - just call
06:38 - a knit like that and i'm going to make
06:40 - this private just putting an underscore
06:42 - beside it so that no one else can call
06:44 - this they have to call the reset method
06:47 - and then here what we'll do is we'll
06:49 - just call underscore a net
06:51 - so the logic behind this is that since
06:53 - we're doing the same thing twice but
06:55 - there's a little bit difference in the
06:56 - init
06:56 - method here let's just put in a method
06:58 - that does it
07:00 - and rather than having the user um just
07:03 - call
07:03 - a knit right what i will do is have them
07:05 - called reset
07:07 - the reason for that is that init
07:08 - technically is initializing the game
07:10 - but we don't want the user to have to
07:12 - call in a nit method when they want to
07:13 - reset the game right so just for it so
07:15 - it's more clear for them
07:17 - we make this private so they don't see
07:19 - it they only see the reset
07:20 - and really all it's doing is just
07:22 - calling a net which is also used
07:24 - by the initialization of the game so
07:26 - it's just about what we're exposing and
07:28 - showing to whoever's using this class
07:30 - yes we ourselves are using this class
07:32 - but you have to imagine that
07:33 - maybe someone else is using it or maybe
07:35 - we're going to use it in a different
07:36 - capacity
07:37 - so it makes more sense to have methods
07:39 - that are named the right thing and then
07:40 - inside of a knit we're going to have
07:41 - self like that okay and this will be
07:44 - self.init
07:46 - and self.init my bad okay so now that
07:49 - we've
07:49 - done that i'm going to add a method for
07:51 - select
07:53 - so this will say select a row and column
07:56 - so self
07:57 - row call and we will have move so define
08:01 - move self row call
08:05 - all right great so this is pretty much
08:07 - saying all right
08:08 - when you select something you will call
08:10 - this select method you will tell us the
08:12 - row and column that you selected
08:14 - and then based on that whatever
08:16 - information we're currently storing in
08:17 - the state of this game will do something
08:19 - right so if you already selected a piece
08:22 - then maybe we'll move it or if you
08:24 - selected a different piece
08:25 - we'll change that selection right that's
08:27 - what we're going to do so i'm going to
08:28 - save self
08:29 - dot selected so if we have something
08:31 - selected because note right now select
08:33 - is equal to none
08:34 - then what we'll do is we'll say result
08:38 - equals self dot move of row
08:41 - call now this won't make too much sense
08:44 - right now because we haven't defined
08:45 - this move method but what i'm saying is
08:47 - okay if we already selected something
08:49 - then let's try to move what we've
08:51 - selected to the row and column that you
08:54 - put in here
08:55 - the point of this being that i'm
08:57 - actually going to make move private
08:59 - we only ever select something from the
09:02 - game
09:02 - so when we are like moving stuff around
09:04 - or when we're
09:05 - giving any input to the game we just
09:07 - call this select method
09:09 - we say okay i selected this i selected
09:10 - this i selected this blah blah blah
09:12 - and this will handle what happens based
09:15 - on that selection so we don't need to
09:16 - call
09:16 - move and select we just call select and
09:19 - select will determine whether or not we
09:21 - should move something
09:22 - based on what you've already selected
09:25 - that's what i'm doing at least
09:26 - might not make perfect sense but anyways
09:28 - i'm going to say if not
09:29 - result then self.selected
09:33 - equals none and self.select
09:36 - row call so essentially what's going to
09:39 - happen from this move method
09:41 - is if we were able to successfully move
09:43 - something
09:44 - so if the row column that we selected
09:46 - was valid because we already had
09:47 - something selected so we selected say
09:50 - you know a diagonal square that we could
09:51 - move to then we will actually move it
09:54 - but otherwise what we will do is select
09:56 - a different piece or at least try to
09:58 - select a different piece
10:00 - so we'll say um sorry let me re-clarify
10:03 - this
10:04 - so what this is doing essentially is
10:05 - saying okay if we have something
10:07 - selected already that means we already
10:09 - pressed on some piece
10:10 - so we're trying to move the piece that
10:13 - was selected
10:14 - to whatever row and column we just
10:16 - passed here now let's say that doesn't
10:18 - make sense like maybe we pressed a red
10:20 - square and then we pressed a white
10:21 - square
10:21 - well that's going to mean that result is
10:24 - going to be false it's going to tell us
10:25 - hey
10:26 - no that wasn't valid like you couldn't
10:28 - move there so we do is we reset the
10:30 - selection
10:31 - and then we re-select a row and column
10:34 - so this is going to call this method
10:36 - again except now
10:37 - we're going to get into the else
10:39 - statement that i'll put here
10:41 - or not the else statement but we'll get
10:43 - into the rest of the code that i'm going
10:45 - to put here
10:46 - which will essentially say okay let's
10:48 - select this piece let's do that let's
10:50 - whatever right
10:51 - that's what it's going to do so we're
10:52 - going to say piece equals
10:54 - and in this case we'll say self dot
10:56 - board dot
10:57 - get piece row column so we've used this
11:00 - before but we're going to use it in here
11:01 - we'll say if piece does not equal zero
11:04 - so if we're not selecting an empty piece
11:06 - we're actually selecting something
11:07 - that's red or
11:08 - or black and
11:11 - and not black sorry red or white and
11:14 - self.piece.color
11:16 - and actually it's not self it's just
11:18 - piece.color
11:19 - if p stock color equals equals
11:23 - self.turn so whatever turn it currently
11:26 - is then what we can do is actually
11:28 - select that piece
11:30 - so let's say self.selected equals that
11:33 - piece
11:33 - and we'll say self.valid moves are
11:36 - equal to self.board.getvalidmoves which
11:40 - is a method we're going to define in a
11:41 - second
11:42 - and we'll simply pass in that piece
11:45 - and then we will return true to tell us
11:49 - hey
11:49 - this was right we selected something
11:51 - that's good otherwise we'll return
11:53 - false so this is just to tell the user
11:56 - hey
11:56 - this selection was valid so we're
11:58 - returning true to you
11:59 - if it's not valid we're returning false
12:02 - and that's the basis of how this works
12:04 - so again we'll go through it if we
12:06 - selected something
12:07 - then try to move it to whatever else we
12:09 - just pressed here
12:10 - if that doesn't work so we get a false
12:12 - back then say okay get rid of our
12:14 - current selection
12:16 - re-select something else which means
12:18 - call this method again
12:20 - and that means we'll do whatever happens
12:22 - here now we could
12:24 - put an else statement just to make sure
12:27 - in this case return false is fine just
12:29 - to make sure that
12:31 - we're not going to accidentally run this
12:33 - code after the self.select happens and
12:36 - we return
12:37 - back here if that's making sense because
12:39 - this is technically recursive but
12:41 - anyways that's what i'm getting at so we
12:43 - can go over this again later but i think
12:44 - that's enough of an explanation
12:46 - okay so now we're going to do move so
12:48 - move is called
12:49 - here and now we need to actually move
12:51 - something
12:52 - if this is called so we're going to say
12:54 - piece equals
12:57 - self.board.getpeace row
12:59 - oops comma
13:03 - call next if self dot
13:06 - selected so if we have actually selected
13:09 - something
13:10 - and the piece is equal to zero
13:14 - and the row call is in
13:18 - valid moves which is going to be self
13:20 - dot valid underscore moves
13:23 - so hopefully this is reading clean
13:24 - enough that it makes sense but
13:25 - essentially if we selected something
13:27 - and the piece that we selected is zero
13:31 - this is important because we can't move
13:32 - into a position that has another piece
13:35 - so only if we selected something and
13:38 - what we selected is actually not another
13:40 - piece because
13:41 - at this point we've okay so we've
13:43 - already selected something
13:44 - and then what the row and column that we
13:46 - pass here that we're trying to move to
13:48 - is not another piece if that's the case
13:50 - so actually i can't i don't think i can
13:51 - say
13:52 - yeah if piece is equal to zero from row
13:54 - and column that we just pressed on
13:56 - and the row and column that we want to
13:58 - move to right
13:59 - is in the valid moves then we can
14:01 - actually move it so we can say
14:02 - self.board
14:04 - dot move and we can move the piece which
14:08 - we would have had as selected so
14:12 - self dot selected we can move
14:16 - the selected piece to the row
14:20 - and to the column okay so i double
14:22 - checked that i'm pretty sure and this is
14:24 - right
14:24 - i've been confusing myself there's a lot
14:26 - of rows and columns and the same words
14:28 - everywhere
14:29 - we'll move the currently selected piece
14:31 - to the row and column
14:33 - that was passed to us here and this will
14:35 - work we've already set up how
14:37 - the board moves the pieces and then what
14:39 - i'm going to say is
14:40 - this will be weird because we haven't
14:41 - seen this yet but skipped
14:43 - is going to be equal to self dot valid
14:46 - moves
14:47 - uh you know what actually let's skip
14:49 - this because
14:50 - i don't want to confuse anyone if they
14:53 - if they don't
14:54 - we haven't yet wrote the code that we're
14:56 - about to try to like
14:57 - work with if that makes any sense but
14:59 - otherwise if this is not true
15:01 - we're going to return false
15:04 - and then return true if this actually
15:06 - works now the other thing we need to do
15:08 - is actually change the turn
15:10 - so i'm going to say define change
15:13 - turn self and we're going to say if
15:17 - self.turn equals equals
15:20 - red self dot turn
15:25 - oops self.turn equals white
15:28 - and otherwise self.turn
15:32 - equals red so change turn just to make
15:34 - this a bit cleaner to see
15:36 - and then we'll call self dot change turn
15:39 - all right so valid moves we haven't
15:41 - looked at this yet but this is going to
15:43 - be a
15:43 - dictionary of the valid moves that we
15:46 - can take from any
15:47 - uh possible position and then we have
15:49 - change turn
15:50 - which is going to say okay if it's red
15:52 - we'll go to white if it's white we'll go
15:54 - to red so pretty straightforward
15:55 - i want to see now if i can get select to
15:59 - work or if this is working
16:00 - the only problem is we're not drawing
16:02 - anything right so i won't really be able
16:04 - to see if
16:04 - what piece i've selected is working or
16:06 - not so we're actually going to have to
16:08 - keep writing code until we can really
16:10 - test this and make sure that
16:11 - we haven't messed anything up okay so
16:14 - now it's actually
16:15 - time for in my opinion what the fun part
16:17 - is which is trying to figure out
16:19 - an algorithm that can essentially be
16:21 - given
16:22 - any piece and determine all of the valid
16:24 - moves for
16:25 - that piece now unfortunately my um
16:28 - like drawing software isn't working i'm
16:30 - going to try to get it working if it
16:31 - doesn't then you'll be seeing me hand
16:33 - drawing something in just a second all
16:36 - right so now
16:36 - i got the drawing stuff to work
16:38 - fortunately so i don't have to actually
16:39 - go and get a piece of paper and film
16:41 - myself doing that
16:42 - but what i'm going to show you is
16:43 - essentially how we figure out
16:46 - what pieces are where what piece where
16:49 - what moves pieces can go to based on
16:51 - where they are that's a mouthful and i
16:52 - still didn't say it correctly but let's
16:54 - say we're considering this red piece
16:55 - right here that i'm filling in so this
16:57 - red checker
16:58 - essentially what are the valid moves for
17:00 - this piece i'm going to draw them in
17:01 - green so one of the valid moves would be
17:03 - this
17:03 - another one would be this right to hop
17:05 - over this piece
17:07 - but if i move this piece so i remove
17:10 - this blue one
17:11 - then no longer is that a valid move the
17:13 - valid move
17:14 - is if i can go back to green this one
17:17 - right here
17:18 - so this is actually kind of tricky
17:20 - because it looks simple it looks like
17:21 - just expand on the diagonals
17:23 - and figure out um where you need to move
17:26 - to just say okay is there you know empty
17:27 - space on the diagonals
17:28 - if there is you can move there right but
17:31 - then again what happens if i add a
17:32 - checker
17:33 - right here so i add a blue one right
17:34 - here i can no longer move here i can
17:36 - only jump over top
17:38 - and if i add another blue one right here
17:40 - at the end now i can't even move on this
17:42 - diagonal at all
17:43 - so hopefully you can understand kind of
17:45 - the complexity in this
17:47 - and why the algorithm we're about to
17:48 - write is actually kind of complicated to
17:51 - figure out where a chess piece is or a
17:54 - checkers piece is able to move
17:55 - essentially we need to look at all of
17:57 - the checker pieces
17:59 - on the diagonals of where that checker
18:01 - piece is and now
18:02 - imagine the situation in which this is a
18:04 - king so if we give him like a little
18:06 - crown or something that's sure this will
18:08 - be our king it's not really a crown but
18:10 - if it's a king it can move backwards
18:12 - right and it has the same rules applying
18:13 - to it
18:14 - except it can move backwards as well and
18:17 - then
18:17 - what happens when we can double jump
18:19 - right so if
18:20 - we have a situation i can't even i don't
18:22 - think i can even set one up where we can
18:24 - double jump uh let me see if i can uh
18:28 - okay let's see if we can get a double
18:30 - jump set up somewhere just to show you
18:31 - an example
18:32 - if i have a piece here and i have a
18:34 - piece here and then imagine that
18:36 - this expanded on technically
18:40 - a valid move is right here in this
18:42 - square
18:43 - for this piece it can jump here and then
18:46 - it can jump over there and capture both
18:47 - of these pieces
18:48 - and we need to keep track of what pieces
18:50 - we jumped over so that we know
18:53 - if we remove them so it seems pretty
18:54 - simplistic but actually
18:56 - moving these pieces is pretty
18:57 - complicated
18:59 - so let's consider the algorithm that i'm
19:01 - actually going to run through
19:02 - i have it up beside me i'm going to
19:05 - bring it up beside me at least
19:07 - and i'll show you what i'm going to do
19:09 - so the first thing that we're going to
19:10 - do is check the color
19:12 - of the piece so is it red or in this
19:14 - case is it blue but this would be white
19:16 - obviously i'm just doing it in blue
19:18 - because you cannot see white on this
19:19 - background
19:20 - okay so the color is it red or is it
19:22 - blue that determines the direction that
19:24 - we're going to move it in fact i think
19:25 - we already have the direction set on the
19:27 - piece as either negative one or positive
19:29 - one
19:30 - so let's say that we're considering
19:31 - something that's red we can only move
19:33 - down
19:33 - in that direction so what we're going to
19:35 - do is look on this left diagonal in this
19:38 - right diagonal for
19:39 - any valid moves for this piece we can
19:41 - only move diagonally again right
19:44 - so what are we going to do the first
19:45 - thing we're going to do is we're going
19:47 - to move
19:47 - down one row so whatever row this is on
19:49 - we're going to start
19:50 - from this row right here and we're going
19:53 - to if we're checking the left diagonal
19:54 - on the right diagonal we're going to
19:55 - check one at a time so i'll start by
19:57 - checking the left diagonal here
19:59 - i'm going to look to the square that is
20:01 - one
20:02 - left and one down so on the diagonal
20:04 - right here
20:05 - and say okay is does this have a piece
20:08 - in it or does it not have a piece in it
20:10 - so the two things here are okay if it
20:12 - has a piece in it
20:14 - is the piece blue or is the piece red so
20:17 - is the piece the same color as our piece
20:20 - if it is we can't move on that diagonal
20:22 - so if this piece right here is actually
20:25 - red
20:25 - then we can't move here right because we
20:27 - cannot have a red move into a piece
20:29 - where another red
20:30 - is now if the piece is empty so if
20:33 - there's nothing there we can move there
20:34 - that's a valid square so if it's empty
20:36 - then we say check okay boom we can go
20:38 - there that's fine
20:40 - if it has the opposite color piece in it
20:43 - then we have to keep moving on the
20:45 - diagonal
20:46 - and see if we can jump over this piece
20:49 - so if there is a piece on this diagonal
20:51 - we need to check
20:52 - the next piece here and see if we can
20:55 - move
20:56 - into that square so if there is not
20:58 - another piece in this
20:59 - next square over doesn't matter what
21:01 - color it is then this becomes a valid
21:04 - move and we can move
21:05 - into this square now this applies the
21:07 - exact same way on the right side of the
21:10 - diagonal as well we'll move
21:11 - over one and to the right and we'll say
21:14 - okay is there anything here
21:15 - in this case there's not so we can move
21:17 - there but if there was we need to check
21:19 - the color of it if it's the opposite
21:21 - color we need to check
21:22 - continuing on the diagonal and see if we
21:25 - can move over top of that color to
21:27 - jump it right and if we do jump that we
21:29 - need to keep track
21:30 - that this move would jump a piece so
21:32 - that we can remove that piece if we
21:34 - decide to take that move
21:36 - now where it gets a little bit more
21:37 - complicated is if you're double jumping
21:39 - or doing something else so actually let
21:41 - me just erase all of this
21:42 - just and draw a fresh grid because it's
21:44 - getting kind of messy here
21:46 - and i'll talk about how we handle the
21:47 - situation in which we're double jumping
21:49 - so let's just say this is
21:52 - our grid uh it's it doesn't have to be
21:56 - even or neat it's just for the purpose
21:57 - of showing you here
21:59 - and let's say we have you know maybe
22:02 - we can change the colors again we have
22:04 - our red checker here
22:06 - then we have a blue one and a blue one
22:10 - and we'll expand this out like
22:13 - that okay so technically we should be
22:16 - able to move
22:17 - here to this square to double jump so
22:20 - what i
22:21 - what i'm doing at least in my algorithm
22:22 - to check this is saying okay
22:24 - if we jump over a piece and we land in a
22:28 - square
22:28 - that doesn't have another piece in it
22:30 - from this square
22:32 - check if we can jump any other piece on
22:35 - the diagonals
22:36 - so we already know to check if we can
22:38 - jump a piece but imagine that there's a
22:39 - piece here and here
22:40 - technically this is a valid move because
22:43 - if we move here we can actually
22:45 - jump over to the other side and jump the
22:47 - other piece so
22:48 - that's something to be aware of as well
22:49 - so as soon as we go here i'm actually
22:52 - going to run
22:52 - the exact same algorithm i ran before
22:55 - right
22:56 - except this time i'm only going to
22:57 - consider a move valid if it jumps over
23:00 - another piece for the double jump or
23:01 - triple jump or so on and so forth
23:03 - so as soon as we jump a piece we
23:05 - immediately consider if from the current
23:07 - position that we jump
23:08 - to we can jump any other piece and if we
23:10 - can we
23:11 - add those moves to the valid move set
23:14 - so that is how we're going to do this
23:16 - i'll write the code for it which is more
23:18 - complicated than this
23:19 - and then that will be probably the
23:21 - hardest part of this video is writing
23:22 - this little bit of algorithm here
23:25 - all right so let's get into it now bring
23:28 - the keyboard back
23:29 - get rid of all the wires for my drawing
23:32 - tablet
23:32 - and there we go okay so
23:36 - what i'm going to do is i'm going to say
23:39 - define inside of board dot pi get
23:42 - underscore valid underscore moves
23:45 - and this is going to take self and do we
23:48 - want to take a piece
23:50 - or do we want to take yeah or we'll take
23:52 - a piece instead of row and call
23:54 - all right so first i'm going to say
23:55 - moves equals an empty dictionary
23:57 - what i'm going to do in this dictionary
23:59 - is store
24:00 - the move as the key so what place we
24:03 - could potentially move to as a row call
24:05 - so like
24:06 - 4 5 might be a available space that we
24:09 - can move to
24:10 - and i'm going to have this as the key
24:12 - being equal to
24:13 - any pieces that we jump to that move
24:17 - so say that we jump over the piece in
24:20 - three
24:20 - four to get to four five then that would
24:23 - be stored in a list
24:24 - that is associated with this key in the
24:26 - dictionary
24:27 - so you know more accurately be it like
24:30 - that
24:30 - so that we know if we move to this move
24:32 - we have to remove that piece because we
24:34 - jumped it
24:35 - all right so moves equals empty
24:38 - dictionary
24:39 - i'm going to say left equals piece
24:42 - dot call minus one oops because we're
24:46 - moving
24:46 - left one and then right
24:49 - oops equals piece dot call
24:53 - plus one so essentially just getting the
24:57 - you know what's left and what's right
24:58 - because that's the diagonals we're going
25:00 - to start considering
25:01 - and then row equals piece dot row
25:04 - like that all right so now what i'm
25:07 - going to say
25:08 - is actually i need to
25:11 - check something here yeah the direction
25:14 - that we have
25:15 - on this piece is actually
25:18 - if i can find it uh to have direction
25:21 - not going to be relevant so we can
25:23 - actually just get rid of it because
25:24 - we're not going to use that we have to
25:25 - do it another way that i forgot
25:27 - so inside of here what i'm going to say
25:28 - is if p stock color
25:31 - equals equals red or piece
25:34 - dot king we'll do something
25:39 - if peace.color equals equals white
25:45 - or piece dot king do something
25:49 - the reason i'm doing this is because we
25:51 - need to check
25:53 - whether we can move up or whether we can
25:54 - move down based on the color and based
25:57 - on if this piece is a king
25:59 - that's what we need to do now what i'm
26:01 - going to do is i'm going to define two
26:02 - more methods i'm going to say define
26:04 - underscore traverse underscore left
26:08 - which is going to look on the left
26:09 - diagonal for us because we're going to
26:11 - have to do this multiple
26:12 - times i'm going to say self pass and
26:16 - i'll fill in the rest of the parameters
26:17 - after
26:18 - and then next we're going to say define
26:20 - underscore
26:21 - traverse underscore right which is going
26:24 - to move
26:25 - to the right so we have two methods here
26:28 - that we're going to call from inside of
26:29 - here to kind of split up this algorithm
26:31 - and just make it a little bit more
26:33 - digestible and easier to see
26:34 - but for our traverse left i'm going to
26:37 - say where do we start
26:38 - where do we stop how much should we step
26:41 - by
26:41 - and what is the color left and i think
26:46 - one more thing skip only equals that or
26:51 - skipped equals that i'm going to copy
26:54 - these
26:55 - and i'm going to put them inside of
26:56 - traverse right now let me just explain
26:58 - why i've added all these so start stop
27:00 - step
27:00 - is going to be for the for loops we're
27:02 - going to put inside of here the step
27:04 - is the most important because
27:06 - essentially it's telling us okay
27:07 - do i go up or do i go down when i'm
27:10 - traversing through the rows
27:11 - for the diagonals am i going on the top
27:13 - left diagonal or the top
27:15 - or the bottom left diagonal right am i
27:16 - going on the top right diagonal or the
27:18 - bottom right diagonal skipped will tell
27:20 - us okay
27:21 - because we're going to call this method
27:23 - recursively which you'll see in a second
27:25 - have we skipped any pieces yet if we
27:28 - have we can only move
27:30 - to squares when we skip another piece
27:32 - right that's what this is telling us
27:33 - and left sorry this should say right in
27:35 - traverse right is telling us okay
27:37 - where are we starting in terms of the
27:40 - column uh
27:41 - when we're traversing to the left okay
27:43 - so that's
27:44 - what this is telling us so inside we're
27:46 - going to fill in traverse left and first
27:48 - right and then we'll
27:49 - use them inside of get valid moves so
27:51 - traverse left
27:52 - i have to look at my other screen here
27:54 - because there's no way i'm gonna be able
27:55 - to do this just off the fly
27:57 - i have to say moves equals a empty
27:59 - dictionary
28:00 - last equals an empty list we're going to
28:03 - say 4r
28:04 - in range r is going to stand for row
28:07 - start
28:07 - stop step so again the point of this is
28:10 - that
28:11 - i'm giving the parameters for my for
28:13 - loop in the
28:14 - uh or i guess i'm giving the arguments
28:17 - for my for loop in the parameters
28:18 - so that i can simply just put them here
28:20 - and this will tell me okay what row am i
28:22 - starting at what row am i stopping at
28:24 - and what am i stepping by awesome okay
28:26 - so start stop step
28:28 - next we're going to say if left is less
28:30 - than 0
28:32 - break so if we get to a situation where
28:34 - we're now looking
28:35 - outside of the board so our left is no
28:37 - longer in the range of columns that we
28:39 - have
28:40 - because we're going to subtract from
28:41 - left every time in this loop in fact we
28:43 - can just do that
28:44 - like this at the end then we need to
28:46 - break
28:47 - all right so we're looping through all
28:48 - the rows and we're going to have a
28:49 - variable that keeps track of left
28:51 - for us that we just increment as we move
28:54 - through the rows
28:55 - this again will move us kind of on a
28:57 - diagonal pattern which is what we're
28:58 - trying to look for
28:59 - we're going to say current equals
29:02 - self.board
29:04 - dot get underscore piece
29:07 - and we're going to put r left like that
29:09 - so row
29:10 - and then left which is the variable
29:11 - keeping track of again the column that
29:13 - we're on
29:13 - i'm going to say if current equals
29:16 - equals 0
29:17 - and now we need a more advanced thing
29:20 - inside of here and by the way we're
29:21 - going to copy and list all this for
29:22 - traverse right so once we do this
29:23 - there's just a few minor changes
29:25 - so if current equals zero meaning the
29:27 - current thing we're looking at
29:28 - if it is zero then we need to check if
29:31 - skip underscore only
29:34 - and not last
29:38 - then we'll say is break okay so to
29:41 - explain this
29:42 - is kind of complicated but what we're
29:44 - going to do and maybe it actually be
29:45 - easier if we call traverse left
29:47 - first just so that i can kind of
29:48 - illustrate this better in fact that's
29:50 - what i'm going to do
29:51 - i'm simply going to say here moves
29:55 - dot update self dot underscore traverse
29:58 - left and then what i'm going to pass is
30:00 - row minus 1
30:02 - i'm going to pass the max
30:06 - of row minus three a uh
30:09 - and negative one and i'll talk about
30:11 - this in a second negative one
30:14 - piece dot call up
30:17 - wait is this correct sorry piece dot
30:20 - color
30:21 - we need the color and left okay
30:24 - so what i'm saying is i want to update
30:25 - the moves with whatever is returned from
30:27 - here which is going to be another
30:28 - dictionary
30:29 - i'm traversing left i'm passing row
30:32 - minus 1 which means okay if we're red
30:35 - we are moving up right so we need to
30:37 - move
30:38 - we need to check upwards to see if
30:40 - there's anything valid there so we're
30:41 - going to start remember this is the
30:42 - first parameter here
30:44 - start at the row above the current row
30:46 - that we're at
30:47 - we're going to say okay how far up are
30:49 - we going to look how many rows up am i
30:51 - looking
30:52 - well i'm going to look at row minus 3 or
30:55 - negative 1. so the maximum of that now
30:58 - negative 1 pretty much says stop at
30:59 - negative 1 which means
31:00 - look up to row 0 right which is a valid
31:03 - row and the reason i put row minus 3 is
31:05 - because i don't want to look
31:07 - further than 2 pieces away from where i
31:10 - currently am and if i start at row minus
31:12 - 1
31:13 - and i move to maximum of row minus 3
31:16 - right then what that means is i'm only
31:18 - looking to above the current row that
31:20 - i'm at
31:21 - at most so that's why i'm putting real
31:22 - minus 3. negative 1 is saying move
31:25 - up when we increment this for loop or
31:27 - decrement this for loop in this case
31:28 - the color obviously is the piece color
31:31 - and left is where we're going to start
31:32 - for our column and what we're going to
31:34 - subtract as we move
31:35 - upwards that's what this moves.update is
31:37 - doing now i'm going to do the same thing
31:38 - for moves.update with right
31:40 - except it's going to be changed a little
31:41 - bit so move.update
31:43 - traverse right the start stop
31:46 - step is going to be the same peace stock
31:49 - color will be the same except instead of
31:51 - left we're obviously going to pass
31:52 - right now let's do the same for white
31:54 - just to show you what i mean hopefully
31:56 - this will make it more clear
31:57 - and this order of explaining and instead
31:59 - of uh
32:00 - yeah traverse left is right except now
32:02 - instead of row minus one is going to be
32:03 - row plus one
32:04 - because we're moving down this time
32:07 - right and now instead of the max it's
32:09 - going to be the min
32:10 - of row plus three or
32:13 - rows right hopefully this is making
32:16 - sense
32:17 - and then instead of negative one it's
32:19 - going to be one and left and right
32:21 - is the same so i think that's right let
32:23 - me make sure i did that correctly
32:25 - yes it is and then outside of here we'll
32:27 - return
32:28 - moves so this
32:31 - method right here traverse left interest
32:33 - right will return as a dictionary
32:35 - essentially what moves.update is doing
32:37 - is merging this dictionary with the one
32:38 - we currently have
32:40 - so that we can have as many things as we
32:41 - want in that dictionary we don't have to
32:43 - say moves
32:43 - equals this and then go through and add
32:45 - them automatically this this method
32:47 - doesn't
32:48 - okay so hopefully that's making sense on
32:50 - how we're going up and how we're going
32:51 - down
32:52 - but what i'm saying is if current is
32:54 - equal to zero
32:56 - and we skipped a piece and we have
32:59 - not um seen a piece yet so it like
33:03 - we'll define last in a second but if
33:04 - we've skipped a piece and last which is
33:06 - a piece that we would skip to move to
33:08 - where we're going to go is not
33:10 - defined then break the reason for that
33:12 - is if the next square we look at when we
33:14 - jump over a piece is a blank
33:16 - square we can't move there because we
33:17 - need to jump to another piece
33:19 - jump over another piece to be able to
33:21 - actually make that a valid move now this
33:23 - will make more sense as i complete the
33:24 - algorithm
33:25 - i like to explain things as i go but
33:26 - sometimes you just have to walk through
33:28 - all of it and then kind of
33:29 - go through parts after so elif
33:32 - skip only we'll do something in a second
33:36 - and else we're going to say moves
33:41 - and this will be our left
33:44 - is equal to last all right and then
33:48 - finally
33:49 - what i'm going to do not finally there's
33:51 - actually more to this
33:53 - i'm going to say if and last why is that
33:56 - an error
33:57 - we'll see in a second so if last
34:00 - then we're going to say is if step
34:03 - equals equals negative 1
34:05 - rho equals the max of r minus 3
34:09 - comma 0 else rho
34:12 - equals the min of r plus 3
34:16 - rows so this is now doing the same thing
34:20 - that we did before because what i'm
34:21 - preparing to do essentially is saying
34:23 - okay
34:23 - if we found an empty square and last
34:27 - had a um a value in it so there was like
34:30 - we found something
34:31 - uh when we were looping which you know
34:34 - what i'm just gonna keep going and then
34:35 - i'll explain this
34:36 - so if current does not equal zero what
34:38 - i'm gonna say
34:39 - is l if current dot color
34:44 - equals equals color break
34:50 - else
34:54 - last equals current
34:57 - we're going to put this inside of a list
34:59 - okay now
35:01 - we're i'm actually almost done with this
35:02 - but i just need to code out a good
35:04 - amount to be able to start explaining
35:05 - this
35:05 - so if current is equal to zero that
35:08 - means we found an empty square
35:10 - otherwise if it's not so if it has a
35:13 - color it wasn't equal to zero and it's
35:14 - equal to
35:15 - our current color so the piece we're
35:16 - trying to move is equal to our piece
35:19 - then we can't move there obviously we're
35:20 - blocked we can't jump over it so we
35:22 - break
35:23 - and we won't be adding any moves if
35:25 - that's the case otherwise
35:27 - we say okay if it wasn't our color it
35:30 - means it was the other color
35:31 - which means we could potentially move
35:33 - over top of it assuming that
35:35 - it's an empty square next so we say last
35:38 - equals current so then what happens in
35:41 - this instance
35:42 - we're seeing if we can jump right which
35:43 - is the complex aspect
35:45 - last gets equal to current we loop again
35:47 - and we look at the next row and we move
35:49 - left and we look at the other diagonal
35:51 - piece
35:52 - say okay if current now so this next
35:55 - piece
35:56 - is zero and if we skipped and not last
36:00 - break i'll talk about that after
36:02 - if skip only let's do that but in the
36:04 - situation where it's zero and none of
36:06 - this was true
36:07 - we add this as a possible move so we say
36:10 - okay
36:11 - if it's zero and last existed right
36:14 - then that means we can jump over it so
36:16 - we say moves r comma left equals last
36:19 - now in the situation where we find this
36:21 - first and we don't just find
36:24 - um a like a a piece that is the other
36:27 - color in between
36:28 - we will add uh the move but we just
36:31 - won't skip anything because last
36:33 - will be equal to an empty list all right
36:36 - now we're saying if last so essentially
36:39 - if current was equal to zero
36:41 - and last which means that we had
36:43 - something that we skipped over
36:45 - now we can actually skip it we're
36:47 - preparing to see if we can double jump
36:49 - or
36:50 - triple jump right so that's what we're
36:52 - trying to do
36:53 - so what we do now is we say okay what
36:56 - direction were we going
36:57 - were we going up or were we going down
36:58 - because we need to recalculate and this
37:00 - shouldn't say r plus
37:02 - r let's say r plus 3. we need to
37:04 - recalculate
37:06 - where we're going to stop because now
37:07 - we're at a new position when we recall
37:10 - these two functions so what we're going
37:11 - to say now is moves.update
37:15 - and we're going to say self.underscore
37:17 - traverse left
37:18 - which is the same one that we're doing
37:19 - here we're going to r
37:21 - plus uh step so either we're going up or
37:25 - down based on
37:26 - what the step is if step is negative one
37:28 - r will subtract one if it's one we'll
37:29 - add one
37:30 - say r plus step we'll say row
37:34 - and actually is it row sorry this should
37:36 - be
37:37 - r plus step yeah row and then in this
37:41 - case
37:41 - step because we already passed the step
37:43 - so we know what direction we're going in
37:45 - then what do we need to pass after that
37:47 - we need the color
37:49 - okay we're gonna pass left minus one
37:53 - and finally we're gonna pass skipped
37:55 - equals
37:56 - last okay so that's what we passed for
37:58 - that and then we'll copy the exact same
38:00 - thing
38:01 - move down a line and do this now except
38:05 - traverse right and instead of left minus
38:08 - one
38:09 - it's going to be left plus one all right
38:12 - so let me make sure i
38:13 - did this correctly i think i did but the
38:15 - whole point of this is like once we get
38:17 - to a point
38:18 - where we've skipped over something so in
38:20 - this case we we found a valid square
38:22 - we skipped over something we figured out
38:24 - okay now where are we going to go to
38:26 - figure out if we can double jump or
38:27 - triple jump what row do we stop at
38:29 - we call this again recursively which
38:31 - means just do it again
38:32 - and see if we can double jump or triple
38:35 - jump from this position
38:37 - and then we actually can just
38:40 - break here it won't matter if we put a
38:43 - break or not because based on the way
38:44 - that this for loop is set up it won't
38:46 - run anymore
38:47 - but i'm just going to break just so
38:48 - we're clear that after we do this
38:50 - there's no more
38:51 - valid moves in this current iteration
38:54 - and now i need to fill in this pass here
38:56 - for skip only but it should actually
38:58 - just say
38:59 - skipped okay so let's go to skip now
39:03 - if skipped we're going to say moves
39:08 - r comma left and yeah
39:11 - r yeah r comma left equals last plus
39:15 - skipped so essentially if we're in the
39:18 - situation where
39:19 - we found a valid move uh we skipped over
39:22 - something
39:23 - right now what we can do is we can
39:26 - actually
39:27 - sorry this isn't this is the situation
39:28 - where we're double jumping something
39:30 - we will combine the last uh checker that
39:33 - we jumped with the checker we jumped on
39:35 - this move
39:36 - into this moves skip so that we know
39:38 - whether we can jump one or whether we
39:39 - can jump two and which ones we need to
39:41 - remove
39:42 - this is all going to make more sense as
39:44 - we continue doing it but
39:45 - just it's hard to explain this because
39:47 - it is a really kind of abstract
39:48 - complicated algorithm without really a
39:50 - visualization
39:51 - now the reason we have this break here
39:52 - again is essentially we're saying
39:55 - if we've skipped over something we found
39:58 - a blank square
39:59 - and we don't have anything that we can
40:02 - skip again
40:03 - we can't move there that's what this is
40:05 - saying so that means all we have to do
40:07 - here is check if we've skipped because
40:09 - if
40:10 - we skipped and we did find another thing
40:12 - that we can skip over
40:14 - then we can update the move or add
40:15 - another move that has the last
40:17 - plus this one if none of this is true if
40:20 - we didn't skip anything so we're on the
40:22 - first one as soon as we find an empty
40:23 - square
40:24 - this is valid moves our left equals last
40:26 - right and there we go
40:27 - and then we check and do this recursive
40:29 - call to see if we can skip any more
40:31 - from that blank space that is kind of
40:35 - how this works again hard to explain but
40:39 - that's what we have to do to get this
40:40 - work and now i'm going to go traverse
40:41 - right
40:42 - i'm going to copy all of this and we're
40:44 - just going to update a few of the
40:46 - variables
40:47 - so instead of left we're going to say
40:49 - right
40:50 - and instead of write being less than
40:51 - zero it's going to be right greater than
40:54 - or equal to rows and actually not rows
40:58 - is going to say
40:58 - calls now current that's fine instead of
41:02 - left again this says
41:03 - right so pretty much anywhere says left
41:06 - just substitute it with right
41:09 - and some of the minuses and pluses will
41:10 - have to substitute as well
41:12 - uh yep and this would say right so right
41:14 - minus equals one that's gonna be right
41:15 - plus
41:16 - equals one and so left so it's gonna be
41:19 - right
41:20 - that can stay the same with plus one and
41:21 - minus one
41:23 - and let's see if there's anywhere else i
41:27 - think that should be good and
41:28 - finally let's return moves
41:31 - from this and
41:34 - from this okay so this
41:38 - is the algorithm to determine the valid
41:41 - moves based on
41:42 - a piece right so given a piece tell us
41:45 - all the valid moves
41:46 - this will do it i don't think i messed
41:48 - it up at all
41:50 - and now what i want to do is just add
41:52 - something
41:53 - that can draw these valid moves so we
41:54 - can actually make sure that this is
41:56 - working
41:57 - so next what i'm going to say is define
41:59 - draw underscore valid
42:00 - underscore moves and
42:03 - why is this break giving me an error
42:05 - let's see what it says instance of list
42:06 - has no get
42:07 - piece method current equals self.board
42:10 - oh
42:11 - oops sorry so this should say self.board
42:14 - my apology guys we're gonna have to make
42:15 - quick fix here line
42:16 - 78 self dot board
42:19 - are left because we're inside board not
42:22 - game i forgot so the internal
42:24 - representation is different
42:25 - and then here same thing self.board
42:29 - are right okay so that should be good
42:33 - now let's go to draw valid moves let's
42:36 - say
42:37 - self we can say do i should i
42:40 - say moves i'm just going to look at
42:41 - where i've done this before
42:43 - so actually what i'm going to do is i'm
42:44 - going to take this method sorry and i'm
42:45 - going to put this
42:46 - inside of game just because game handles
42:48 - most of the drawing
42:49 - so inside of here we'll say define
42:53 - draw valid moves self moves
42:56 - and then what we will do is we'll say
42:58 - okay uh we need to just draw squares for
43:00 - all of these valid moves
43:02 - so we'll figure out their row and their
43:04 - column and then just draw a circle there
43:05 - for each move so we'll say 4 move
43:08 - in moves and then we will get the row
43:12 - and columns we'll say
43:12 - row call equals move remember
43:16 - all the moves are going to be a
43:17 - dictionary okay so we say row call
43:19 - equals move
43:20 - this loops through all the keys of the
43:21 - dictionary which coincidentally is the
43:23 - rows and columns that are a tuple for us
43:25 - there
43:26 - so row call equals move and then
43:29 - pygame.draw.circle
43:31 - we'll draw it on the surface which is
43:33 - self.win
43:36 - and then what we will do is we'll draw
43:38 - it what color do we want
43:40 - we want blue which i'm going to import
43:42 - from here
43:44 - so blue like that we'll say self.x
43:49 - oops not self.x we have to actually
43:51 - calculate self.x so i'm going to say row
43:53 - multiplied by
43:54 - square size
43:58 - rho multiplied by square size
44:01 - minus square size over over 2
44:05 - that should give us the middle and then
44:07 - same thing with call so
44:08 - call times square size
44:12 - minus square size over over two
44:15 - we've already talked about how that
44:16 - works so i'm not going to go over it
44:17 - again and then we need the radius
44:20 - which in this case let's just hard code
44:22 - at 15.
44:23 - okay so square size we also need to
44:26 - import so let's import that like that
44:28 - and i think that's all i need to do for
44:30 - draw valid moves
44:32 - now inside of draw or inside update
44:34 - sorry where is that
44:36 - i've got to find where the update method
44:38 - is we'll say
44:41 - oops self dot draw valid moves
44:46 - and we'll pass the self dot
44:50 - valid underscore moves or self dot
44:53 - board dot valid moves
44:56 - okay so i think
45:00 - that is or no we have it stored
45:03 - inside of here what am i saying sorry
45:05 - guys after an
45:06 - hour and almost two hours of recording
45:08 - the brain starts to go when i'm talking
45:10 - and doing all this
45:11 - but anyways self.valid moves which is
45:13 - stored in here
45:15 - which should be updated when we select a
45:16 - piece and now i apologize it's been like
45:18 - 40 minutes since we've tested this but
45:20 - i'm going to run this
45:21 - and see what is happening oops what is
45:23 - this going on here let's go back here
45:25 - okay
45:26 - so now when i select something nothing
45:29 - is showing up
45:30 - which is great and let's just
45:34 - check check this okay so i realize why
45:36 - nothing is showing up because i just
45:37 - looked at this here
45:38 - we have not called the select method of
45:41 - our game at all so we need to actually
45:43 - call the select method
45:44 - so what we're going to do to do that is
45:47 - we're simply going to say
45:51 - game dot select
45:55 - row call whenever we press on something
45:57 - and that should be good
45:59 - let's check that out and actually what
46:00 - i'll do here is say if game.turn
46:04 - equals equals red so pretty much just
46:06 - make it just let us select the red ones
46:08 - is what i'm saying here
46:09 - because later we'll make the we need to
46:12 - import red
46:13 - later we'll make the white ones the ai
46:15 - but let's run this and see now if we get
46:17 - anything okay so
46:18 - select and okay so it's giving us some
46:20 - moves but clearly these are not
46:22 - valid so i'm just gonna have a quick
46:23 - look at the bug that i made and then i
46:25 - will be back
46:26 - and we can discuss what is going wrong
46:29 - so i've made
46:30 - a stupid mistake here by mixing up
46:32 - inside of the draw
46:34 - move the draw valid moves uh the row and
46:37 - the column
46:37 - so i was like looking through all my
46:39 - code like what the heck did i do wrong
46:40 - like where did i break something
46:42 - when in reality this just needs to be
46:44 - changed from call
46:45 - and row because i'm drawing the row uh
46:49 - on the i'm drawing like the x and y
46:51 - reversed so i was like this looks like
46:52 - it's like getting it right just drawing
46:54 - it
46:54 - opposite that's exactly what it was
46:56 - doing so i did some debugging and
46:58 - figured that out
46:59 - i'm trying to figure out where else i
47:00 - think i printed some stuff out that i
47:02 - want to remove
47:04 - uh maybe not anyways okay but that was
47:07 - the major issue also there was a small
47:09 - mistake i had a break statement i think
47:11 - i went over this but
47:12 - on line 91 uh 92 the break stand was
47:16 - indented just needs to
47:17 - uh in and i guess in indent is that what
47:20 - you want to call it out here so it's in
47:22 - line with the if statement
47:24 - same thing here in traverse right so
47:26 - let's look at this
47:27 - now all right so one more error here in
47:29 - this draw method i just looked at i'm
47:31 - like what the heck what have i done
47:32 - wrong
47:33 - these negative signs need to be positive
47:35 - signs so
47:36 - what i was doing is saying okay we're
47:39 - going to go
47:40 - to the edge of the square so the top
47:42 - left edge and then subtract from the top
47:44 - left edge which meant we were going
47:45 - up into the other square which is why it
47:47 - was going off so
47:49 - that was the issue but now change those
47:51 - negative signs to positive signs
47:53 - inside of here between the square sides
47:54 - and square sides over two
47:56 - and hopefully fingers crossed let's
47:58 - click something
48:00 - everything looks to be working okay
48:02 - great so that's awesome so that
48:04 - is pretty much how this works to get the
48:07 - valid move so i apologize to everyone
48:09 - for
48:10 - butchering that horribly and i'm trying
48:12 - to make sure that the white and red i
48:13 - think the checkerboard pattern is good
48:16 - now we need to worry about actually
48:17 - jumping over pieces
48:19 - updating the valve moves you can see
48:20 - that work to actually move where i moved
48:22 - it
48:23 - but there's a few glitches so let's fix
48:24 - that now all right so let's go back into
48:26 - game let's go into the select method
48:28 - that i don't think i actually ended up
48:30 - finishing and let's just check and make
48:34 - sure this is all good so first of all i
48:36 - need to get rid of this else statement
48:37 - which i realize is a mistake
48:39 - and put it like that um i'm not gonna
48:42 - explain exactly why but just
48:43 - don't add that else statement that
48:46 - messes it all up you can read through
48:47 - this and
48:48 - and go back i think i explained kind of
48:50 - how this works
48:51 - okay so after that what we'll do is go
48:53 - back into move and now i'll make it so
48:55 - if we skip
48:56 - over a piece we actually capture that
48:58 - piece
48:59 - so we're going to move the position this
49:01 - is what we've done we'll change
49:02 - turns but what i want to do is check if
49:05 - the position we moved to had a piece
49:07 - skipped
49:08 - so i'm going to say skipped equals self
49:11 - dot valid moves and not peace
49:14 - we're going to say valid moves and
49:16 - inside of here
49:18 - i'm going to say row column now we say
49:20 - if
49:21 - skipped and then what we need to do is
49:24 - say self.board
49:27 - dot remove skipped
49:31 - like that and then actually we can just
49:32 - put change turn at the end because i
49:34 - think it makes more sense to go
49:35 - afterwards rather than
49:36 - before and looking at that i think
49:39 - that's all we need inside of here
49:43 - just double checking looks good now we
49:45 - need to add this remove method
49:47 - inside of the board class here so what
49:50 - i'm going to do is say
49:51 - define remove
49:56 - self pieces and what we'll do is loop
49:59 - through all the pieces and just remove
50:00 - the ones we need to so we'll say
50:02 - four piece
50:05 - in pieces and then simply say self.board
50:09 - and we'll say peace.row
50:15 - peace.call equals 0.
50:18 - so that should be as easy as it is to
50:20 - remove all of these loop through all the
50:21 - keys that are in this
50:22 - because it's going to be a dictionary or
50:25 - not dictionary it'll just be actually a
50:26 - bunch of pieces
50:27 - and we will simply just remove those
50:29 - pieces
50:30 - so we'll just set them equal to zero
50:32 - which you know at the same time we'll
50:34 - remove them
50:35 - okay so now that should work uh let's
50:38 - see how this works now if we run okay so
50:41 - let me go here
50:42 - now let's see if i can move white oh i
50:44 - can great
50:46 - and what's something that's happening
50:48 - here so i notice that
50:49 - when i'm moving it doesn't at the end of
50:52 - the move
50:52 - remove these valid moves so we have to
50:54 - do that so let's actually do that now
50:56 - let's go to move and yes at the end of
51:00 - valid move here where it says
51:01 - self.change turn
51:02 - let's go inside of change turn and let's
51:04 - say self.valid moves
51:07 - equals a blank list okay so that should
51:09 - hopefully fix that
51:11 - let me close this and restart it and now
51:14 - let's test some stuff out
51:15 - so first of all i can't move to any
51:17 - places that aren't valid moves right so
51:19 - click on a piece and try to move it
51:20 - somewhere else you can't you can only
51:22 - move it to a place
51:24 - that is valid so i can move it there now
51:26 - i can't move these pieces or even select
51:28 - them because it's not my turn
51:29 - but i can select the white so if i
51:31 - select this one here
51:32 - now let's go with the red and let's see
51:34 - if we can jump over
51:36 - and looks like it's working when we jump
51:38 - it actually captures it
51:39 - so really with that this is the finished
51:42 - checkers game
51:44 - what we have to add as well now would be
51:46 - checking if someone has one so i'll show
51:47 - you how we do that quickly
51:49 - and actually let's just make sure that
51:50 - the king pieces work properly
51:52 - before i say that that we finished the
51:55 - tutorial
51:56 - all right so we capture there capture
51:58 - there i'd like to set up some kind of
52:00 - double jump and make sure that that's
52:01 - going to work at some point too so let's
52:03 - do that as well actually
52:05 - um it's not doing a great job at setting
52:08 - it up though okay let's move this here
52:10 - um which turn is it now my turn okay
52:14 - let's go
52:14 - here we can go
52:18 - there i'm trying to move this i guess i
52:21 - can't move it down
52:22 - i wanted to move this one so we could
52:23 - double jump but anyways let's see
52:25 - if we can just get a king piece first as
52:27 - well okay so let's move that there
52:29 - this can go here that can go
52:32 - there all right move you here
52:36 - here go there and king okay that looks
52:39 - like it's working
52:41 - and now it's white and when i press the
52:42 - king i can jump backwards over
52:44 - the other pieces okay so that's great to
52:46 - see that looks like that is
52:48 - somewhat working now let's move this guy
52:51 - here
52:52 - and it's hard to play the same game
52:53 - against yourself i'm just trying to get
52:55 - a double jump setup so let's move that
52:57 - here and let's see okay so it looks like
52:59 - i can double jump and that this is
53:01 - indeed valid
53:02 - now it'd be cool if i could have done a
53:03 - triple jump in fact maybe let's let's
53:05 - see if we can get a triple jump and just
53:07 - really test ourselves out here
53:09 - and see if that's working so yeah triple
53:11 - jump i'm gonna make this guy a king
53:14 - and it looks like something went wrong
53:16 - so good job we were testing that
53:18 - list index out of range board are right
53:21 - so actually when i moved to the last
53:23 - square we had an issue so let me just
53:25 - look at the code and see what's going on
53:26 - there
53:27 - so first the mistake is here i had row
53:29 - equals equals rows
53:30 - obviously that's never going to be true
53:32 - because we can't move into rows
53:34 - which is 8 we can only move into
53:36 - potentially row 7 but based on the way
53:37 - it's indexing so i'm saying if rho now
53:39 - equals
53:40 - equals row minus one then in that case
53:42 - we can make this
53:43 - a king so that should fix the fact that
53:46 - that guy didn't go to a king
53:47 - but now i'm trying to figure out what
53:49 - the issue was with that index out of
53:51 - range
53:52 - and let's have a look at that aha so i
53:53 - found the culprit here again
53:55 - this max on line 69 should say
53:58 - min so what happened was we were maxing
54:01 - row plus three or
54:02 - rows which meant we were going to use
54:04 - whatever the larger one was so we'd use
54:06 - row
54:07 - plus three when we were traversing which
54:09 - meant we would try to go down
54:11 - from when we moved into that position
54:13 - and obviously that wouldn't work because
54:14 - there was no more rows to look at
54:16 - so let's just kind of run through and
54:17 - test one more time i'll add one thing to
54:19 - check if someone's a winner
54:21 - and then we'll pretty much be done okay
54:23 - so let's do that
54:26 - let's do that let's see you go there
54:29 - you can jump i just want to move a white
54:31 - to the other end to make sure that
54:34 - all of that is working okay
54:37 - let's just keep going
54:41 - and white okay so now he's king
54:45 - and now it's the red's turn and there we
54:48 - go he can move here
54:49 - okay so that seems to generally be
54:51 - working
54:52 - i'm going to test just one more time and
54:54 - see if this double jump works
54:56 - so this is crazy look he can go boom
54:57 - boom and if i go there it actually
54:59 - captures both of those pieces
55:00 - so this is working properly great so i
55:03 - am satisfied that this
55:04 - is functioning that the game is working
55:06 - we can move around of course you can add
55:08 - some music sound effects make it look
55:10 - better i'm not focused on that i always
55:11 - focus on the function first
55:13 - and now let's add one thing to check if
55:14 - someone has one and
55:16 - let's go actually back to board let's go
55:19 - to
55:20 - remove and let's update that method
55:21 - because i remember that i forgot to do
55:23 - something
55:24 - so now when we remove a piece i want to
55:26 - actually check if
55:27 - that piece does not equal zero first of
55:30 - all
55:31 - and so if piece does not equal zero
55:36 - if piece dot color equals equals red
55:40 - then remember we have this count up here
55:43 - uh for the red and white left that we
55:45 - need to update so
55:46 - now what we'll say is okay if p stock
55:47 - color equals equals red then
55:50 - self dot i believe it's red
55:53 - left minus equals one
55:57 - else self dot white left minus equals
56:00 - one
56:01 - now we can even add a winner onto here
56:03 - so we say define
56:05 - winner and this will return to us the
56:07 - color that won
56:08 - if they won so we'll say if
56:12 - self.red left
56:15 - is less than or equal to zero return
56:19 - red l if self.white left
56:25 - is less than or equal to zero return
56:30 - oops sorry this should be other way
56:31 - around
56:32 - return white and return red and then
56:34 - finally
56:35 - return none in the situation where no
56:39 - one won
56:40 - so return none
56:43 - like that now i'm not gonna actually
56:46 - like program
56:47 - anything related to that but what i'll
56:49 - do is simply just say if
56:51 - game.winner does not equal
56:54 - none then print
56:59 - game.winner could simplify that but this
57:02 - is fine for now
57:03 - and this is pretty much i'm just trying
57:05 - to show you if you want to check if they
57:06 - win
57:07 - just do this and then inside of here you
57:08 - can do something specific in my case i'm
57:10 - literally just going to print out
57:12 - the color of the winner because i can't
57:14 - be bothered to add any more to this now
57:16 - so with that being said this has been
57:19 - checkers
57:20 - all right so i am back and this is the
57:21 - next day and i just read through this
57:23 - code and tested it and i realized that i
57:25 - made a kind of small mistake at the end
57:27 - so i just wanted to hop in here quickly
57:28 - and fix it for you guys in case any of
57:30 - you were running into problems
57:31 - so essentially some of you probably
57:33 - noticed this but when i said if
57:34 - game.winner
57:36 - i didn't actually add this winner method
57:38 - to the game class i added it to the
57:41 - board class
57:42 - so that's fine we can just add another
57:44 - one to the game class that simply uses
57:46 - the one from the board class
57:48 - really easy fix but i just wanted to hop
57:49 - in here and show you how to do that so
57:51 - we're just gonna have to define
57:52 - winner inside of our game class we'll
57:54 - take self here and we'll simply just
57:56 - return
57:57 - self dot board dot winner so that's it
58:00 - let me just run this and make sure that
58:02 - everything's working now
58:03 - and we can see that it is and we're good
58:05 - to go so let's get back
58:06 - to the original video uh if you guys
58:09 - made it to the end of this video give
58:10 - yourself a pat on the back because
58:12 - i hardly did it is much more difficult
58:14 - than you would imagine to go through and
58:16 - explain
58:16 - about 400 500 lines of code especially
58:19 - because i'm doing this
58:19 - pretty much in one take only cutting out
58:21 - like any major mistakes i make
58:23 - so if you guys appreciate this please do
58:25 - leave a like subscribe to the channel
58:27 - all the code will be available in the
58:28 - description in case your game isn't
58:30 - working or something is messed up
58:31 - and yeah let me know you thought of this
58:33 - series and hopefully you're looking
58:34 - forward to adding to the ai to this
58:36 - which we'll be doing
58:37 - [Music]
58:44 - shortly

Cleaned transcript:

okay so now that we have this what we need to do is actually allow us to select the piece have it selected and move to a valid square that also involves having to figure out where can we move to like what is a valid square right and if we move and we say jump over a piece how do we remove that piece how do we get rid of it you know can we jump and double jump like those are the stuff things we have to figure out now which are kind of difficult but obviously we're going to do them they won't be that hard okay so i'm going to make a another file inside of checkers and i'm going to call this game.pi now what this is going to be responsible for is handling actually the game so figuring out like whose turn is it did we select a piece is this piece good like can we move here can we move there that's what game is going to do and it's going to use board and a bunch of other stuff to do that for us it's also going to handle like drawing everything and a bunch of other stuff all right so now we're going to code out the game class now the whole point of the game class is going to be to let us actually interface with the board and the pieces and everything else with a few really simple methods so essentially i don't want this main kind of loop that's actually running and checking for us pressing buttons and stuff to be associated at all with how this game operates i want this game to be able to be operated by in theory to computers right i don't want it to be linked in directly to us pressing buttons and all of that because later on what we'll do is implement an ai so we can play against it right so we need to make sure that it's very clear that game just exposes some methods that we can use but it's not like it's not dependent on the fact that we're pressing certain things or that two human players are playing that's kind of what i'm trying to get at here with the point uh with with this so let's define the class let's import pie game like that and say divine underscore underscore net self and doing anything else for game we're actually going to take the window that we want to draw this game on so we could put the window in here if we want like we could define it in this game class i'm not going to just for the purpose that say we actually want to draw or play maybe like four or five chess games at the same time well we could in theory pass a window that is big enough that we could draw four chess games and then we could just pass subsets of that window to different games and play multiple games at the same time so i'm just trying to keep things flexible um we could define win here i'm not going to but just figured i'd tell you why so first i'm going to say self.selected equals none this actually reminds me that i want to go back to board and remove the selected piece because we're not going to use that inside of board we're going to use this inside of game to figure out what piece is selected by someone that's playing if they are and then next i'm going to say self.board equals board so that means from main here we're actually not going to make a board we're actually just going to make a game and the game will control the board for us so rather than having to get the piece move the piece all of that all we'll do is use the game to say okay we selected this row and column move it to this row and column and that will figure all of that out for us so self.board equals board next we're going to say self.turn equals red which means we need to import constants so from dot constants import red white uh what else would we need uh probably a few other things but we'll just leave red and white for now so self.turn equals red and after that we need self dot valid underscore moves equals a dictionary we'll talk about this after but this is going to pretty much tell us what the current valid moves are for whatever player is playing so that we can draw those or we can move those or whatever it may be next we're going to say self.win equals win so just store that window in here so we don't need to pass it every time and then what we're going to do is define an update method so update will just be like say we're updating the pi game display instead we'll just simply call this update method so we'll say inside of update self.board.draw and then anything else that we want to do to actually kind of update the game and then next we'll say pie game dot display dot update so now right if we go back to main all we have to do actually is instead of saying board.drawingpygame.display.update we'll say game dot update like that instead of making a board we'll say game equals game so now in theory we've just kind of wrapped some of this functionality and so i'm going to get rid of those two lines we're not going to use this right now and we need to import game but once we import game all we'll have to do is just use the update method the move method it's a lot simpler on this end when we do that so let's say from trackers dot game import game and let's run this and see if this works okay so i'm getting an issue missing up is a positional argument win so i forgot i have to pass the window to my game so let's do that and what is this now board is not defined as so we need to actually import board into game so let's do that and now let's try it and what's the error this time missing one required positional argument uh win okay so let's go back to uh game sorry guys and let's say self.win inside of the call to selftopword.draw okay and there we go now it's working so we can see that it all works the same we've just kind of wrapped it up and are using it a little bit differently all right so now let's go back to game and let's start defining a few other methods that we want so first i'm going to define a reset method this is pretty straightforward just say we want to reset the game and what we'll need to do is say self.selected equals none self.board equals board self.turn equals red and self.valid moves equals blank and in fact that looks really similar to what all this stuff is right so let's wrap this in a new method and let's just say define and let's actually just call this a knit so inside of the reset method we can just call a knit like that and i'm going to make this private just putting an underscore beside it so that no one else can call this they have to call the reset method and then here what we'll do is we'll just call underscore a net so the logic behind this is that since we're doing the same thing twice but there's a little bit difference in the init method here let's just put in a method that does it and rather than having the user um just call a knit right what i will do is have them called reset the reason for that is that init technically is initializing the game but we don't want the user to have to call in a nit method when they want to reset the game right so just for it so it's more clear for them we make this private so they don't see it they only see the reset and really all it's doing is just calling a net which is also used by the initialization of the game so it's just about what we're exposing and showing to whoever's using this class yes we ourselves are using this class but you have to imagine that maybe someone else is using it or maybe we're going to use it in a different capacity so it makes more sense to have methods that are named the right thing and then inside of a knit we're going to have self like that okay and this will be self.init and self.init my bad okay so now that we've done that i'm going to add a method for select so this will say select a row and column so self row call and we will have move so define move self row call all right great so this is pretty much saying all right when you select something you will call this select method you will tell us the row and column that you selected and then based on that whatever information we're currently storing in the state of this game will do something right so if you already selected a piece then maybe we'll move it or if you selected a different piece we'll change that selection right that's what we're going to do so i'm going to save self dot selected so if we have something selected because note right now select is equal to none then what we'll do is we'll say result equals self dot move of row call now this won't make too much sense right now because we haven't defined this move method but what i'm saying is okay if we already selected something then let's try to move what we've selected to the row and column that you put in here the point of this being that i'm actually going to make move private we only ever select something from the game so when we are like moving stuff around or when we're giving any input to the game we just call this select method we say okay i selected this i selected this i selected this blah blah blah and this will handle what happens based on that selection so we don't need to call move and select we just call select and select will determine whether or not we should move something based on what you've already selected that's what i'm doing at least might not make perfect sense but anyways i'm going to say if not result then self.selected equals none and self.select row call so essentially what's going to happen from this move method is if we were able to successfully move something so if the row column that we selected was valid because we already had something selected so we selected say you know a diagonal square that we could move to then we will actually move it but otherwise what we will do is select a different piece or at least try to select a different piece so we'll say um sorry let me reclarify this so what this is doing essentially is saying okay if we have something selected already that means we already pressed on some piece so we're trying to move the piece that was selected to whatever row and column we just passed here now let's say that doesn't make sense like maybe we pressed a red square and then we pressed a white square well that's going to mean that result is going to be false it's going to tell us hey no that wasn't valid like you couldn't move there so we do is we reset the selection and then we reselect a row and column so this is going to call this method again except now we're going to get into the else statement that i'll put here or not the else statement but we'll get into the rest of the code that i'm going to put here which will essentially say okay let's select this piece let's do that let's whatever right that's what it's going to do so we're going to say piece equals and in this case we'll say self dot board dot get piece row column so we've used this before but we're going to use it in here we'll say if piece does not equal zero so if we're not selecting an empty piece we're actually selecting something that's red or or black and and not black sorry red or white and self.piece.color and actually it's not self it's just piece.color if p stock color equals equals self.turn so whatever turn it currently is then what we can do is actually select that piece so let's say self.selected equals that piece and we'll say self.valid moves are equal to self.board.getvalidmoves which is a method we're going to define in a second and we'll simply pass in that piece and then we will return true to tell us hey this was right we selected something that's good otherwise we'll return false so this is just to tell the user hey this selection was valid so we're returning true to you if it's not valid we're returning false and that's the basis of how this works so again we'll go through it if we selected something then try to move it to whatever else we just pressed here if that doesn't work so we get a false back then say okay get rid of our current selection reselect something else which means call this method again and that means we'll do whatever happens here now we could put an else statement just to make sure in this case return false is fine just to make sure that we're not going to accidentally run this code after the self.select happens and we return back here if that's making sense because this is technically recursive but anyways that's what i'm getting at so we can go over this again later but i think that's enough of an explanation okay so now we're going to do move so move is called here and now we need to actually move something if this is called so we're going to say piece equals self.board.getpeace row oops comma call next if self dot selected so if we have actually selected something and the piece is equal to zero and the row call is in valid moves which is going to be self dot valid underscore moves so hopefully this is reading clean enough that it makes sense but essentially if we selected something and the piece that we selected is zero this is important because we can't move into a position that has another piece so only if we selected something and what we selected is actually not another piece because at this point we've okay so we've already selected something and then what the row and column that we pass here that we're trying to move to is not another piece if that's the case so actually i can't i don't think i can say yeah if piece is equal to zero from row and column that we just pressed on and the row and column that we want to move to right is in the valid moves then we can actually move it so we can say self.board dot move and we can move the piece which we would have had as selected so self dot selected we can move the selected piece to the row and to the column okay so i double checked that i'm pretty sure and this is right i've been confusing myself there's a lot of rows and columns and the same words everywhere we'll move the currently selected piece to the row and column that was passed to us here and this will work we've already set up how the board moves the pieces and then what i'm going to say is this will be weird because we haven't seen this yet but skipped is going to be equal to self dot valid moves uh you know what actually let's skip this because i don't want to confuse anyone if they if they don't we haven't yet wrote the code that we're about to try to like work with if that makes any sense but otherwise if this is not true we're going to return false and then return true if this actually works now the other thing we need to do is actually change the turn so i'm going to say define change turn self and we're going to say if self.turn equals equals red self dot turn oops self.turn equals white and otherwise self.turn equals red so change turn just to make this a bit cleaner to see and then we'll call self dot change turn all right so valid moves we haven't looked at this yet but this is going to be a dictionary of the valid moves that we can take from any uh possible position and then we have change turn which is going to say okay if it's red we'll go to white if it's white we'll go to red so pretty straightforward i want to see now if i can get select to work or if this is working the only problem is we're not drawing anything right so i won't really be able to see if what piece i've selected is working or not so we're actually going to have to keep writing code until we can really test this and make sure that we haven't messed anything up okay so now it's actually time for in my opinion what the fun part is which is trying to figure out an algorithm that can essentially be given any piece and determine all of the valid moves for that piece now unfortunately my um like drawing software isn't working i'm going to try to get it working if it doesn't then you'll be seeing me hand drawing something in just a second all right so now i got the drawing stuff to work fortunately so i don't have to actually go and get a piece of paper and film myself doing that but what i'm going to show you is essentially how we figure out what pieces are where what piece where what moves pieces can go to based on where they are that's a mouthful and i still didn't say it correctly but let's say we're considering this red piece right here that i'm filling in so this red checker essentially what are the valid moves for this piece i'm going to draw them in green so one of the valid moves would be this another one would be this right to hop over this piece but if i move this piece so i remove this blue one then no longer is that a valid move the valid move is if i can go back to green this one right here so this is actually kind of tricky because it looks simple it looks like just expand on the diagonals and figure out um where you need to move to just say okay is there you know empty space on the diagonals if there is you can move there right but then again what happens if i add a checker right here so i add a blue one right here i can no longer move here i can only jump over top and if i add another blue one right here at the end now i can't even move on this diagonal at all so hopefully you can understand kind of the complexity in this and why the algorithm we're about to write is actually kind of complicated to figure out where a chess piece is or a checkers piece is able to move essentially we need to look at all of the checker pieces on the diagonals of where that checker piece is and now imagine the situation in which this is a king so if we give him like a little crown or something that's sure this will be our king it's not really a crown but if it's a king it can move backwards right and it has the same rules applying to it except it can move backwards as well and then what happens when we can double jump right so if we have a situation i can't even i don't think i can even set one up where we can double jump uh let me see if i can uh okay let's see if we can get a double jump set up somewhere just to show you an example if i have a piece here and i have a piece here and then imagine that this expanded on technically a valid move is right here in this square for this piece it can jump here and then it can jump over there and capture both of these pieces and we need to keep track of what pieces we jumped over so that we know if we remove them so it seems pretty simplistic but actually moving these pieces is pretty complicated so let's consider the algorithm that i'm actually going to run through i have it up beside me i'm going to bring it up beside me at least and i'll show you what i'm going to do so the first thing that we're going to do is check the color of the piece so is it red or in this case is it blue but this would be white obviously i'm just doing it in blue because you cannot see white on this background okay so the color is it red or is it blue that determines the direction that we're going to move it in fact i think we already have the direction set on the piece as either negative one or positive one so let's say that we're considering something that's red we can only move down in that direction so what we're going to do is look on this left diagonal in this right diagonal for any valid moves for this piece we can only move diagonally again right so what are we going to do the first thing we're going to do is we're going to move down one row so whatever row this is on we're going to start from this row right here and we're going to if we're checking the left diagonal on the right diagonal we're going to check one at a time so i'll start by checking the left diagonal here i'm going to look to the square that is one left and one down so on the diagonal right here and say okay is does this have a piece in it or does it not have a piece in it so the two things here are okay if it has a piece in it is the piece blue or is the piece red so is the piece the same color as our piece if it is we can't move on that diagonal so if this piece right here is actually red then we can't move here right because we cannot have a red move into a piece where another red is now if the piece is empty so if there's nothing there we can move there that's a valid square so if it's empty then we say check okay boom we can go there that's fine if it has the opposite color piece in it then we have to keep moving on the diagonal and see if we can jump over this piece so if there is a piece on this diagonal we need to check the next piece here and see if we can move into that square so if there is not another piece in this next square over doesn't matter what color it is then this becomes a valid move and we can move into this square now this applies the exact same way on the right side of the diagonal as well we'll move over one and to the right and we'll say okay is there anything here in this case there's not so we can move there but if there was we need to check the color of it if it's the opposite color we need to check continuing on the diagonal and see if we can move over top of that color to jump it right and if we do jump that we need to keep track that this move would jump a piece so that we can remove that piece if we decide to take that move now where it gets a little bit more complicated is if you're double jumping or doing something else so actually let me just erase all of this just and draw a fresh grid because it's getting kind of messy here and i'll talk about how we handle the situation in which we're double jumping so let's just say this is our grid uh it's it doesn't have to be even or neat it's just for the purpose of showing you here and let's say we have you know maybe we can change the colors again we have our red checker here then we have a blue one and a blue one and we'll expand this out like that okay so technically we should be able to move here to this square to double jump so what i what i'm doing at least in my algorithm to check this is saying okay if we jump over a piece and we land in a square that doesn't have another piece in it from this square check if we can jump any other piece on the diagonals so we already know to check if we can jump a piece but imagine that there's a piece here and here technically this is a valid move because if we move here we can actually jump over to the other side and jump the other piece so that's something to be aware of as well so as soon as we go here i'm actually going to run the exact same algorithm i ran before right except this time i'm only going to consider a move valid if it jumps over another piece for the double jump or triple jump or so on and so forth so as soon as we jump a piece we immediately consider if from the current position that we jump to we can jump any other piece and if we can we add those moves to the valid move set so that is how we're going to do this i'll write the code for it which is more complicated than this and then that will be probably the hardest part of this video is writing this little bit of algorithm here all right so let's get into it now bring the keyboard back get rid of all the wires for my drawing tablet and there we go okay so what i'm going to do is i'm going to say define inside of board dot pi get underscore valid underscore moves and this is going to take self and do we want to take a piece or do we want to take yeah or we'll take a piece instead of row and call all right so first i'm going to say moves equals an empty dictionary what i'm going to do in this dictionary is store the move as the key so what place we could potentially move to as a row call so like 4 5 might be a available space that we can move to and i'm going to have this as the key being equal to any pieces that we jump to that move so say that we jump over the piece in three four to get to four five then that would be stored in a list that is associated with this key in the dictionary so you know more accurately be it like that so that we know if we move to this move we have to remove that piece because we jumped it all right so moves equals empty dictionary i'm going to say left equals piece dot call minus one oops because we're moving left one and then right oops equals piece dot call plus one so essentially just getting the you know what's left and what's right because that's the diagonals we're going to start considering and then row equals piece dot row like that all right so now what i'm going to say is actually i need to check something here yeah the direction that we have on this piece is actually if i can find it uh to have direction not going to be relevant so we can actually just get rid of it because we're not going to use that we have to do it another way that i forgot so inside of here what i'm going to say is if p stock color equals equals red or piece dot king we'll do something if peace.color equals equals white or piece dot king do something the reason i'm doing this is because we need to check whether we can move up or whether we can move down based on the color and based on if this piece is a king that's what we need to do now what i'm going to do is i'm going to define two more methods i'm going to say define underscore traverse underscore left which is going to look on the left diagonal for us because we're going to have to do this multiple times i'm going to say self pass and i'll fill in the rest of the parameters after and then next we're going to say define underscore traverse underscore right which is going to move to the right so we have two methods here that we're going to call from inside of here to kind of split up this algorithm and just make it a little bit more digestible and easier to see but for our traverse left i'm going to say where do we start where do we stop how much should we step by and what is the color left and i think one more thing skip only equals that or skipped equals that i'm going to copy these and i'm going to put them inside of traverse right now let me just explain why i've added all these so start stop step is going to be for the for loops we're going to put inside of here the step is the most important because essentially it's telling us okay do i go up or do i go down when i'm traversing through the rows for the diagonals am i going on the top left diagonal or the top or the bottom left diagonal right am i going on the top right diagonal or the bottom right diagonal skipped will tell us okay because we're going to call this method recursively which you'll see in a second have we skipped any pieces yet if we have we can only move to squares when we skip another piece right that's what this is telling us and left sorry this should say right in traverse right is telling us okay where are we starting in terms of the column uh when we're traversing to the left okay so that's what this is telling us so inside we're going to fill in traverse left and first right and then we'll use them inside of get valid moves so traverse left i have to look at my other screen here because there's no way i'm gonna be able to do this just off the fly i have to say moves equals a empty dictionary last equals an empty list we're going to say 4r in range r is going to stand for row start stop step so again the point of this is that i'm giving the parameters for my for loop in the uh or i guess i'm giving the arguments for my for loop in the parameters so that i can simply just put them here and this will tell me okay what row am i starting at what row am i stopping at and what am i stepping by awesome okay so start stop step next we're going to say if left is less than 0 break so if we get to a situation where we're now looking outside of the board so our left is no longer in the range of columns that we have because we're going to subtract from left every time in this loop in fact we can just do that like this at the end then we need to break all right so we're looping through all the rows and we're going to have a variable that keeps track of left for us that we just increment as we move through the rows this again will move us kind of on a diagonal pattern which is what we're trying to look for we're going to say current equals self.board dot get underscore piece and we're going to put r left like that so row and then left which is the variable keeping track of again the column that we're on i'm going to say if current equals equals 0 and now we need a more advanced thing inside of here and by the way we're going to copy and list all this for traverse right so once we do this there's just a few minor changes so if current equals zero meaning the current thing we're looking at if it is zero then we need to check if skip underscore only and not last then we'll say is break okay so to explain this is kind of complicated but what we're going to do and maybe it actually be easier if we call traverse left first just so that i can kind of illustrate this better in fact that's what i'm going to do i'm simply going to say here moves dot update self dot underscore traverse left and then what i'm going to pass is row minus 1 i'm going to pass the max of row minus three a uh and negative one and i'll talk about this in a second negative one piece dot call up wait is this correct sorry piece dot color we need the color and left okay so what i'm saying is i want to update the moves with whatever is returned from here which is going to be another dictionary i'm traversing left i'm passing row minus 1 which means okay if we're red we are moving up right so we need to move we need to check upwards to see if there's anything valid there so we're going to start remember this is the first parameter here start at the row above the current row that we're at we're going to say okay how far up are we going to look how many rows up am i looking well i'm going to look at row minus 3 or negative 1. so the maximum of that now negative 1 pretty much says stop at negative 1 which means look up to row 0 right which is a valid row and the reason i put row minus 3 is because i don't want to look further than 2 pieces away from where i currently am and if i start at row minus 1 and i move to maximum of row minus 3 right then what that means is i'm only looking to above the current row that i'm at at most so that's why i'm putting real minus 3. negative 1 is saying move up when we increment this for loop or decrement this for loop in this case the color obviously is the piece color and left is where we're going to start for our column and what we're going to subtract as we move upwards that's what this moves.update is doing now i'm going to do the same thing for moves.update with right except it's going to be changed a little bit so move.update traverse right the start stop step is going to be the same peace stock color will be the same except instead of left we're obviously going to pass right now let's do the same for white just to show you what i mean hopefully this will make it more clear and this order of explaining and instead of uh yeah traverse left is right except now instead of row minus one is going to be row plus one because we're moving down this time right and now instead of the max it's going to be the min of row plus three or rows right hopefully this is making sense and then instead of negative one it's going to be one and left and right is the same so i think that's right let me make sure i did that correctly yes it is and then outside of here we'll return moves so this method right here traverse left interest right will return as a dictionary essentially what moves.update is doing is merging this dictionary with the one we currently have so that we can have as many things as we want in that dictionary we don't have to say moves equals this and then go through and add them automatically this this method doesn't okay so hopefully that's making sense on how we're going up and how we're going down but what i'm saying is if current is equal to zero and we skipped a piece and we have not um seen a piece yet so it like we'll define last in a second but if we've skipped a piece and last which is a piece that we would skip to move to where we're going to go is not defined then break the reason for that is if the next square we look at when we jump over a piece is a blank square we can't move there because we need to jump to another piece jump over another piece to be able to actually make that a valid move now this will make more sense as i complete the algorithm i like to explain things as i go but sometimes you just have to walk through all of it and then kind of go through parts after so elif skip only we'll do something in a second and else we're going to say moves and this will be our left is equal to last all right and then finally what i'm going to do not finally there's actually more to this i'm going to say if and last why is that an error we'll see in a second so if last then we're going to say is if step equals equals negative 1 rho equals the max of r minus 3 comma 0 else rho equals the min of r plus 3 rows so this is now doing the same thing that we did before because what i'm preparing to do essentially is saying okay if we found an empty square and last had a um a value in it so there was like we found something uh when we were looping which you know what i'm just gonna keep going and then i'll explain this so if current does not equal zero what i'm gonna say is l if current dot color equals equals color break else last equals current we're going to put this inside of a list okay now we're i'm actually almost done with this but i just need to code out a good amount to be able to start explaining this so if current is equal to zero that means we found an empty square otherwise if it's not so if it has a color it wasn't equal to zero and it's equal to our current color so the piece we're trying to move is equal to our piece then we can't move there obviously we're blocked we can't jump over it so we break and we won't be adding any moves if that's the case otherwise we say okay if it wasn't our color it means it was the other color which means we could potentially move over top of it assuming that it's an empty square next so we say last equals current so then what happens in this instance we're seeing if we can jump right which is the complex aspect last gets equal to current we loop again and we look at the next row and we move left and we look at the other diagonal piece say okay if current now so this next piece is zero and if we skipped and not last break i'll talk about that after if skip only let's do that but in the situation where it's zero and none of this was true we add this as a possible move so we say okay if it's zero and last existed right then that means we can jump over it so we say moves r comma left equals last now in the situation where we find this first and we don't just find um a like a a piece that is the other color in between we will add uh the move but we just won't skip anything because last will be equal to an empty list all right now we're saying if last so essentially if current was equal to zero and last which means that we had something that we skipped over now we can actually skip it we're preparing to see if we can double jump or triple jump right so that's what we're trying to do so what we do now is we say okay what direction were we going were we going up or were we going down because we need to recalculate and this shouldn't say r plus r let's say r plus 3. we need to recalculate where we're going to stop because now we're at a new position when we recall these two functions so what we're going to say now is moves.update and we're going to say self.underscore traverse left which is the same one that we're doing here we're going to r plus uh step so either we're going up or down based on what the step is if step is negative one r will subtract one if it's one we'll add one say r plus step we'll say row and actually is it row sorry this should be r plus step yeah row and then in this case step because we already passed the step so we know what direction we're going in then what do we need to pass after that we need the color okay we're gonna pass left minus one and finally we're gonna pass skipped equals last okay so that's what we passed for that and then we'll copy the exact same thing move down a line and do this now except traverse right and instead of left minus one it's going to be left plus one all right so let me make sure i did this correctly i think i did but the whole point of this is like once we get to a point where we've skipped over something so in this case we we found a valid square we skipped over something we figured out okay now where are we going to go to figure out if we can double jump or triple jump what row do we stop at we call this again recursively which means just do it again and see if we can double jump or triple jump from this position and then we actually can just break here it won't matter if we put a break or not because based on the way that this for loop is set up it won't run anymore but i'm just going to break just so we're clear that after we do this there's no more valid moves in this current iteration and now i need to fill in this pass here for skip only but it should actually just say skipped okay so let's go to skip now if skipped we're going to say moves r comma left and yeah r yeah r comma left equals last plus skipped so essentially if we're in the situation where we found a valid move uh we skipped over something right now what we can do is we can actually sorry this isn't this is the situation where we're double jumping something we will combine the last uh checker that we jumped with the checker we jumped on this move into this moves skip so that we know whether we can jump one or whether we can jump two and which ones we need to remove this is all going to make more sense as we continue doing it but just it's hard to explain this because it is a really kind of abstract complicated algorithm without really a visualization now the reason we have this break here again is essentially we're saying if we've skipped over something we found a blank square and we don't have anything that we can skip again we can't move there that's what this is saying so that means all we have to do here is check if we've skipped because if we skipped and we did find another thing that we can skip over then we can update the move or add another move that has the last plus this one if none of this is true if we didn't skip anything so we're on the first one as soon as we find an empty square this is valid moves our left equals last right and there we go and then we check and do this recursive call to see if we can skip any more from that blank space that is kind of how this works again hard to explain but that's what we have to do to get this work and now i'm going to go traverse right i'm going to copy all of this and we're just going to update a few of the variables so instead of left we're going to say right and instead of write being less than zero it's going to be right greater than or equal to rows and actually not rows is going to say calls now current that's fine instead of left again this says right so pretty much anywhere says left just substitute it with right and some of the minuses and pluses will have to substitute as well uh yep and this would say right so right minus equals one that's gonna be right plus equals one and so left so it's gonna be right that can stay the same with plus one and minus one and let's see if there's anywhere else i think that should be good and finally let's return moves from this and from this okay so this is the algorithm to determine the valid moves based on a piece right so given a piece tell us all the valid moves this will do it i don't think i messed it up at all and now what i want to do is just add something that can draw these valid moves so we can actually make sure that this is working so next what i'm going to say is define draw underscore valid underscore moves and why is this break giving me an error let's see what it says instance of list has no get piece method current equals self.board oh oops sorry so this should say self.board my apology guys we're gonna have to make quick fix here line 78 self dot board are left because we're inside board not game i forgot so the internal representation is different and then here same thing self.board are right okay so that should be good now let's go to draw valid moves let's say self we can say do i should i say moves i'm just going to look at where i've done this before so actually what i'm going to do is i'm going to take this method sorry and i'm going to put this inside of game just because game handles most of the drawing so inside of here we'll say define draw valid moves self moves and then what we will do is we'll say okay uh we need to just draw squares for all of these valid moves so we'll figure out their row and their column and then just draw a circle there for each move so we'll say 4 move in moves and then we will get the row and columns we'll say row call equals move remember all the moves are going to be a dictionary okay so we say row call equals move this loops through all the keys of the dictionary which coincidentally is the rows and columns that are a tuple for us there so row call equals move and then pygame.draw.circle we'll draw it on the surface which is self.win and then what we will do is we'll draw it what color do we want we want blue which i'm going to import from here so blue like that we'll say self.x oops not self.x we have to actually calculate self.x so i'm going to say row multiplied by square size rho multiplied by square size minus square size over over 2 that should give us the middle and then same thing with call so call times square size minus square size over over two we've already talked about how that works so i'm not going to go over it again and then we need the radius which in this case let's just hard code at 15. okay so square size we also need to import so let's import that like that and i think that's all i need to do for draw valid moves now inside of draw or inside update sorry where is that i've got to find where the update method is we'll say oops self dot draw valid moves and we'll pass the self dot valid underscore moves or self dot board dot valid moves okay so i think that is or no we have it stored inside of here what am i saying sorry guys after an hour and almost two hours of recording the brain starts to go when i'm talking and doing all this but anyways self.valid moves which is stored in here which should be updated when we select a piece and now i apologize it's been like 40 minutes since we've tested this but i'm going to run this and see what is happening oops what is this going on here let's go back here okay so now when i select something nothing is showing up which is great and let's just check check this okay so i realize why nothing is showing up because i just looked at this here we have not called the select method of our game at all so we need to actually call the select method so what we're going to do to do that is we're simply going to say game dot select row call whenever we press on something and that should be good let's check that out and actually what i'll do here is say if game.turn equals equals red so pretty much just make it just let us select the red ones is what i'm saying here because later we'll make the we need to import red later we'll make the white ones the ai but let's run this and see now if we get anything okay so select and okay so it's giving us some moves but clearly these are not valid so i'm just gonna have a quick look at the bug that i made and then i will be back and we can discuss what is going wrong so i've made a stupid mistake here by mixing up inside of the draw move the draw valid moves uh the row and the column so i was like looking through all my code like what the heck did i do wrong like where did i break something when in reality this just needs to be changed from call and row because i'm drawing the row uh on the i'm drawing like the x and y reversed so i was like this looks like it's like getting it right just drawing it opposite that's exactly what it was doing so i did some debugging and figured that out i'm trying to figure out where else i think i printed some stuff out that i want to remove uh maybe not anyways okay but that was the major issue also there was a small mistake i had a break statement i think i went over this but on line 91 uh 92 the break stand was indented just needs to uh in and i guess in indent is that what you want to call it out here so it's in line with the if statement same thing here in traverse right so let's look at this now all right so one more error here in this draw method i just looked at i'm like what the heck what have i done wrong these negative signs need to be positive signs so what i was doing is saying okay we're going to go to the edge of the square so the top left edge and then subtract from the top left edge which meant we were going up into the other square which is why it was going off so that was the issue but now change those negative signs to positive signs inside of here between the square sides and square sides over two and hopefully fingers crossed let's click something everything looks to be working okay great so that's awesome so that is pretty much how this works to get the valid move so i apologize to everyone for butchering that horribly and i'm trying to make sure that the white and red i think the checkerboard pattern is good now we need to worry about actually jumping over pieces updating the valve moves you can see that work to actually move where i moved it but there's a few glitches so let's fix that now all right so let's go back into game let's go into the select method that i don't think i actually ended up finishing and let's just check and make sure this is all good so first of all i need to get rid of this else statement which i realize is a mistake and put it like that um i'm not gonna explain exactly why but just don't add that else statement that messes it all up you can read through this and and go back i think i explained kind of how this works okay so after that what we'll do is go back into move and now i'll make it so if we skip over a piece we actually capture that piece so we're going to move the position this is what we've done we'll change turns but what i want to do is check if the position we moved to had a piece skipped so i'm going to say skipped equals self dot valid moves and not peace we're going to say valid moves and inside of here i'm going to say row column now we say if skipped and then what we need to do is say self.board dot remove skipped like that and then actually we can just put change turn at the end because i think it makes more sense to go afterwards rather than before and looking at that i think that's all we need inside of here just double checking looks good now we need to add this remove method inside of the board class here so what i'm going to do is say define remove self pieces and what we'll do is loop through all the pieces and just remove the ones we need to so we'll say four piece in pieces and then simply say self.board and we'll say peace.row peace.call equals 0. so that should be as easy as it is to remove all of these loop through all the keys that are in this because it's going to be a dictionary or not dictionary it'll just be actually a bunch of pieces and we will simply just remove those pieces so we'll just set them equal to zero which you know at the same time we'll remove them okay so now that should work uh let's see how this works now if we run okay so let me go here now let's see if i can move white oh i can great and what's something that's happening here so i notice that when i'm moving it doesn't at the end of the move remove these valid moves so we have to do that so let's actually do that now let's go to move and yes at the end of valid move here where it says self.change turn let's go inside of change turn and let's say self.valid moves equals a blank list okay so that should hopefully fix that let me close this and restart it and now let's test some stuff out so first of all i can't move to any places that aren't valid moves right so click on a piece and try to move it somewhere else you can't you can only move it to a place that is valid so i can move it there now i can't move these pieces or even select them because it's not my turn but i can select the white so if i select this one here now let's go with the red and let's see if we can jump over and looks like it's working when we jump it actually captures it so really with that this is the finished checkers game what we have to add as well now would be checking if someone has one so i'll show you how we do that quickly and actually let's just make sure that the king pieces work properly before i say that that we finished the tutorial all right so we capture there capture there i'd like to set up some kind of double jump and make sure that that's going to work at some point too so let's do that as well actually um it's not doing a great job at setting it up though okay let's move this here um which turn is it now my turn okay let's go here we can go there i'm trying to move this i guess i can't move it down i wanted to move this one so we could double jump but anyways let's see if we can just get a king piece first as well okay so let's move that there this can go here that can go there all right move you here here go there and king okay that looks like it's working and now it's white and when i press the king i can jump backwards over the other pieces okay so that's great to see that looks like that is somewhat working now let's move this guy here and it's hard to play the same game against yourself i'm just trying to get a double jump setup so let's move that here and let's see okay so it looks like i can double jump and that this is indeed valid now it'd be cool if i could have done a triple jump in fact maybe let's let's see if we can get a triple jump and just really test ourselves out here and see if that's working so yeah triple jump i'm gonna make this guy a king and it looks like something went wrong so good job we were testing that list index out of range board are right so actually when i moved to the last square we had an issue so let me just look at the code and see what's going on there so first the mistake is here i had row equals equals rows obviously that's never going to be true because we can't move into rows which is 8 we can only move into potentially row 7 but based on the way it's indexing so i'm saying if rho now equals equals row minus one then in that case we can make this a king so that should fix the fact that that guy didn't go to a king but now i'm trying to figure out what the issue was with that index out of range and let's have a look at that aha so i found the culprit here again this max on line 69 should say min so what happened was we were maxing row plus three or rows which meant we were going to use whatever the larger one was so we'd use row plus three when we were traversing which meant we would try to go down from when we moved into that position and obviously that wouldn't work because there was no more rows to look at so let's just kind of run through and test one more time i'll add one thing to check if someone's a winner and then we'll pretty much be done okay so let's do that let's do that let's see you go there you can jump i just want to move a white to the other end to make sure that all of that is working okay let's just keep going and white okay so now he's king and now it's the red's turn and there we go he can move here okay so that seems to generally be working i'm going to test just one more time and see if this double jump works so this is crazy look he can go boom boom and if i go there it actually captures both of those pieces so this is working properly great so i am satisfied that this is functioning that the game is working we can move around of course you can add some music sound effects make it look better i'm not focused on that i always focus on the function first and now let's add one thing to check if someone has one and let's go actually back to board let's go to remove and let's update that method because i remember that i forgot to do something so now when we remove a piece i want to actually check if that piece does not equal zero first of all and so if piece does not equal zero if piece dot color equals equals red then remember we have this count up here uh for the red and white left that we need to update so now what we'll say is okay if p stock color equals equals red then self dot i believe it's red left minus equals one else self dot white left minus equals one now we can even add a winner onto here so we say define winner and this will return to us the color that won if they won so we'll say if self.red left is less than or equal to zero return red l if self.white left is less than or equal to zero return oops sorry this should be other way around return white and return red and then finally return none in the situation where no one won so return none like that now i'm not gonna actually like program anything related to that but what i'll do is simply just say if game.winner does not equal none then print game.winner could simplify that but this is fine for now and this is pretty much i'm just trying to show you if you want to check if they win just do this and then inside of here you can do something specific in my case i'm literally just going to print out the color of the winner because i can't be bothered to add any more to this now so with that being said this has been checkers all right so i am back and this is the next day and i just read through this code and tested it and i realized that i made a kind of small mistake at the end so i just wanted to hop in here quickly and fix it for you guys in case any of you were running into problems so essentially some of you probably noticed this but when i said if game.winner i didn't actually add this winner method to the game class i added it to the board class so that's fine we can just add another one to the game class that simply uses the one from the board class really easy fix but i just wanted to hop in here and show you how to do that so we're just gonna have to define winner inside of our game class we'll take self here and we'll simply just return self dot board dot winner so that's it let me just run this and make sure that everything's working now and we can see that it is and we're good to go so let's get back to the original video uh if you guys made it to the end of this video give yourself a pat on the back because i hardly did it is much more difficult than you would imagine to go through and explain about 400 500 lines of code especially because i'm doing this pretty much in one take only cutting out like any major mistakes i make so if you guys appreciate this please do leave a like subscribe to the channel all the code will be available in the description in case your game isn't working or something is messed up and yeah let me know you thought of this series and hopefully you're looking forward to adding to the ai to this which we'll be doing shortly
