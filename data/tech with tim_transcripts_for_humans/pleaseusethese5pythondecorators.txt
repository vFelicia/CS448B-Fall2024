With timestamps:

00:00 - in this video I'll show you five python
00:02 - decorators that you need to know but
00:04 - first let's understand what a decorator
00:07 - is now a decorator is really just a
00:10 - function that modifies another function
00:12 - there's a bunch of built-in decorators
00:14 - in Python and we can also write our own
00:16 - now I want to look at an example of
00:17 - writing a custom decorator so we can
00:20 - understand what's actually happening
00:21 - behind the scenes when we use the
00:23 - built-in ones in Python so what we see
00:25 - here with the timer function is a
00:27 - decorator notice that what it actually
00:29 - does is return another function now
00:31 - we'll dive into that syntax in a second
00:33 - but let's look at how we use this what
00:35 - we do is we write the at symbol then the
00:38 - name of the function in this case it's
00:40 - timer and we decorate a function with it
00:43 - we put it on top of this function now
00:45 - you may have seen this in other modules
00:47 - like flask or Jango where we actually
00:49 - have these decorators to Define
00:51 - different roots and we use them all over
00:53 - python really behind the scenes they're
00:55 - functions that look something like this
00:57 - and what they do is take a function as
01:00 - their first argument and then return a
01:02 - new function that will replace this
01:04 - function seems a little bit strange but
01:06 - let's look at some equivalent syntax so
01:09 - rather than using The Decorator syntax
01:11 - here which is the at symbol what we can
01:13 - actually do is write the following line
01:15 - we can say the example function is equal
01:18 - to the timer function and then we can
01:20 - pass the example function to it when we
01:23 - do this this is effectively the exact
01:25 - same as simply writing The Decorator
01:28 - above the function I know seems a little
01:31 - bit strange but that's all it's doing
01:32 - it's simply taking this function right
01:35 - here passing it to this decorator and
01:38 - then replacing the function definition
01:39 - with whatever is returned from The
01:41 - Decorator so as you can see what the
01:43 - decorator really does is modify a
01:45 - function and typically add some Behavior
01:48 - around it in this case what the timer
01:50 - decorator will do is simply time how
01:52 - long it takes for a function to run so
01:54 - let's have a quick look at actually
01:55 - executing this code and then we'll dive
01:57 - into the syntax and understand how we
01:59 - write a custom decorator so let's start
02:01 - by running the code without decorating
02:03 - this function when I do that you see
02:05 - that we get the sum is and then this
02:07 - huge number now let's clear that and
02:09 - let's add our decorator so we'll say at
02:12 - at timer now when we run the code you'll
02:15 - notice that it tells us how long it took
02:17 - the function to run and then it tells us
02:19 - the sum now let's clear that and let's
02:21 - use that new syntax that I just showed
02:23 - you so rather than decorating the
02:25 - function we will say that the example
02:28 - function is equal to the timer and then
02:30 - we'll call the example function since
02:33 - this returns a new function we're just
02:34 - saying this function is now equal to a
02:36 - different one and now when I call this
02:39 - we'll get the exact same thing so that's
02:41 - what happens when we use a decorator now
02:43 - let's dive into this syntax so let's
02:45 - start with the first function here which
02:47 - is timer now notice that our decorator
02:50 - functions are always going to accept at
02:52 - least one argument or have one parameter
02:54 - which is the function that they're
02:56 - modifying so in this case we take in
02:58 - Funk and that means any fun function
03:00 - that we actually decorate with this
03:02 - decorator will be passed as the first
03:04 - argument this allows us to use this
03:06 - decorator for any type of function that
03:08 - we want then what we do is we write some
03:11 - kind of wrapper function inside of this
03:13 - function it might look like strange
03:15 - syntax but it's totally valid to Define
03:17 - functions inside of other functions in
03:19 - Python this is known as an inner
03:21 - function and there's some more
03:22 - complexities we don't need to get into
03:24 - that now within the wrapper function
03:26 - what we accept here is always star args
03:28 - and star star quarks now really what
03:31 - we're telling the function here is that
03:33 - we don't know how many arguments are
03:35 - going to be passed to it because this
03:36 - timer function could be used to decorate
03:38 - any function so we're going to accept
03:41 - any number of positional arguments and
03:43 - any number of keyword arguments if
03:45 - you've never seen this syntax before
03:47 - that's all it means except any number of
03:49 - positional arguments and any number of
03:51 - keyword arguments then what we do is we
03:53 - start a timer so this is our custom
03:55 - functionality that we're adding or
03:57 - decorating the function with so we start
03:59 - the timer by getting the start time we
04:01 - then actually call the function so we
04:04 - say the result is equal to the original
04:06 - function which was right here and then
04:08 - we pass to It Whatever the arguments and
04:10 - the keyword arguments were that were
04:12 - passed to this wrapper function we then
04:15 - figure out what the end time is and then
04:16 - we print how much time it took to run
04:19 - this function and then we return the
04:21 - result now the important thing is that
04:23 - we always want to be calling the
04:25 - function that we decorated we want to
04:27 - store whatever the result was and we
04:29 - want to return that result this way the
04:32 - decorated function will always work
04:34 - exactly the same as if it wasn't
04:36 - decorated except we've added some
04:38 - additional functionality right so in
04:40 - this case we're just starting a timer
04:42 - and seeing how long it took the function
04:43 - to run there's all kinds of advanced
04:45 - decorators and more use cases that we
04:47 - can look at but that's the basics of a
04:49 - decorator you write a function it
04:51 - accepts some function as the first
04:53 - argument it can accept other arguments
04:55 - but in this case we just accept one we
04:57 - have some wrapper function defined
04:59 - inside of it this wrapper function
05:01 - always accepts any number of positional
05:03 - and keyword arguments so it's Dynamic
05:05 - and can work for any function we add
05:07 - some additional functionality call the
05:09 - original function and then return
05:11 - whatever that result is now when I go
05:13 - and I use my decorator on top of any
05:15 - type of function it will work and it
05:17 - will allow me to add that timer
05:19 - functionality to it now if you want an
05:21 - entire video tutorial just showing you
05:23 - how to write custom decorators I'll link
05:25 - one on the screen but for now let's look
05:27 - at five built-in python decorators that
05:30 - you need to know about but first another
05:32 - thing that you need to know about is
05:33 - that even during this really tough job
05:35 - market the program that I run with
05:37 - course careers is still helping students
05:39 - land software development jobs we had a
05:41 - student complete the program in 39 days
05:44 - and in under a month later he landed a
05:46 - junior developer position making 70k per
05:48 - year if you want to learn more about how
05:50 - that works I have a free introduction
05:52 - course that you can check out from the
05:53 - link below there's a ton of value in
05:55 - there and even if you don't purchase the
05:57 - course it really breaks down what you
05:59 - need to do in 2024 and Beyond to qualify
06:02 - for these Junior developer positions
06:04 - because just being honest with you guys
06:05 - it is harder now than it was a few years
06:07 - ago but it's possible if you have the
06:10 - right guidance and you know the path you
06:11 - need to follow anyways check it out from
06:13 - the link below so the first deck rator
06:15 - we need to look at is known as property
06:18 - now this is used for various methods
06:20 - inside of a class and the idea here is
06:22 - that we can treat a method as if it was
06:24 - an attribute and we can gate the access
06:26 - to a specific field or attribute in
06:29 - Python
06:30 - now you may not know this but in Python
06:31 - we don't have access modifiers like
06:34 - private public and protected if you
06:36 - don't know what those are don't worry
06:38 - but in other programming languages we
06:39 - have a way to determine whether or not
06:41 - an attribute can be accessed from
06:43 - outside of the class in Python we don't
06:46 - have that so what we do as a convention
06:48 - is we add a leading underscore before
06:51 - any of the attributes that we defined
06:53 - inside of our instance that we don't
06:55 - want to be accessed outside of the class
06:57 - whenever you see something that starts
06:59 - with an _ that indicates that it should
07:01 - be treated as private and that means
07:03 - that I shouldn't come here and write
07:05 - something like C doore radius equals 10
07:08 - even though I can do that we're denoting
07:10 - to the user of this class that we
07:12 - shouldn't do that and really this should
07:14 - be a private attribute now the reason
07:17 - that's important is that we typically
07:18 - use property in combination with a
07:21 - private attribute so that we can
07:23 - actually control the access of the
07:25 - attribute and whether you can set it
07:27 - delete it Etc so what we've done here
07:29 - here is we've written a method called
07:31 - radius all this does is return the value
07:35 - of the private attribute radius but
07:37 - we've denoted this as a property now
07:39 - when we do that that actually allows us
07:42 - to access the name of this method
07:43 - without calling the method from our
07:46 - Circle object so in this case I can say
07:48 - c. rius and that's actually going to
07:50 - call this radius method and return
07:53 - whatever is inside of it now just to
07:55 - show that to you if I say print called
07:58 - me here and I run this you'll see that
08:00 - it says called me and then we get five
08:02 - 10 then it says called me and we get 10
08:04 - so the idea is we're going to go through
08:07 - this radius method every time we try to
08:09 - access the radius property now as well
08:12 - as a getter which is what this is known
08:14 - as we also have the ability to add a
08:16 - Setter now a Setter is what'll be used
08:19 - when we actually want to change the
08:20 - value of the attribute in this case we
08:23 - always use this private attribute as the
08:25 - source of Truth so what the actual value
08:27 - of radius is going to be and then we use
08:29 - the getter and the setter to control the
08:31 - axis for it so in this case we Define a
08:34 - Setter for our radius it takes in self
08:37 - and a value what we do is we make sure
08:39 - the value is positive and if it is then
08:41 - we actually set the radius which is our
08:43 - private attribute to be that value
08:45 - otherwise we raise a value error and we
08:48 - say that the radius must be positive so
08:50 - now when I come down here and I say c.
08:52 - radius is equal to 10 what will happen
08:55 - since I've used this decorator is I'll
08:57 - go into this method and I'll start
09:00 - executing the code inside of here so the
09:02 - value pass is going to be the value that
09:04 - I specified here which is 10 we're going
09:06 - to do our check since it's positive this
09:09 - will work and we'll be able to set the
09:10 - radius now let's see what happens if we
09:12 - try to set this to say something like -1
09:15 - well when I run my code here notice we
09:17 - get an error and it says the radius must
09:19 - be positive because our Setter caught
09:21 - that this was a negative value and it
09:23 - didn't allow us to actually make that
09:25 - change to the private attribute so
09:27 - that's how the property decorator works
09:29 - that allows you to control access to a
09:31 - private attribute and to have some logic
09:33 - be handled or called when you're getting
09:36 - or setting a value now as well as
09:38 - getting in setting we can also add a
09:39 - deleter method so I've just slightly
09:41 - changed the example now to add the
09:43 - deleter method notice that the deleter
09:45 - method will be triggered whenever we use
09:47 - the Dell keyword so if I go here and I
09:50 - run my code we'll see that we get the
09:51 - output deleted the reason we're getting
09:53 - that is because we first print deleted
09:55 - we then delete the private attribute and
09:57 - now we would no longer be able to access
09:59 - access it now you can do anything you
10:00 - want inside of these methods but the
10:02 - idea is you define one of them as a
10:04 - property the name of the property is
10:06 - going to be the name of the method then
10:08 - you use whatever the method name is do
10:10 - Setter and. deleter to actually write
10:13 - your own custom Setter and deleter
10:15 - methods you don't have to implement them
10:16 - there's a few other options and things
10:18 - you can do here with properties but
10:20 - that's the basic idea and this is quite
10:22 - useful for creating read only attributes
10:24 - write only attributes or other custom
10:27 - Behavior to really gate the access to
10:29 - the private attributes and control
10:31 - what's happening with the internal state
10:33 - of your class so now we move on to a
10:35 - pretty popular decorator that you've
10:37 - probably seen before which is static
10:39 - method now the static method decorator
10:41 - is used when we want to denote a method
10:43 - inside of the class as static now a
10:46 - static method simply means it's
10:47 - something that belongs to the class and
10:49 - not to an instance of the class and it's
10:52 - not going to have any implicit first
10:54 - parameters like the self keyword or the
10:56 - class all that really means that we use
10:59 - the static method when we want to have
11:01 - some kind of function that belongs
11:03 - inside of a class but doesn't belong to
11:05 - a particular instance so maybe we have
11:08 - some math class and we have a function
11:10 - like add or multiply now it wouldn't
11:12 - really make sense for this to be
11:14 - associated with an instance we're not
11:15 - going to create an instance of this math
11:18 - class we're really just using the math
11:20 - class to organize a few different
11:21 - functions so that they're in a logical
11:23 - area and we know where to access them so
11:25 - this is a great example of where you
11:27 - would use a static method and you need
11:29 - need to decorate the method with the at
11:31 - static method decorator the reason you
11:33 - do that is you no longer need to accept
11:35 - that implicit first parameter like self
11:37 - or CLS now in this case the way that we
11:40 - would utilize these methods is by simply
11:42 - writing the name of the class however if
11:44 - you were to have an instance of the
11:45 - class we have something like m is equal
11:48 - to math you can still call these methods
11:50 - using the instance so I can say m. add
11:53 - one2 that's perfectly fine but what will
11:55 - happen since we've added this decorator
11:57 - is we'll no longer pass this instance as
11:59 - the first argument self allowing us to
12:02 - just treat these as static methods I
12:04 - don't have much more to say here just
12:06 - always use the static method decorator
12:08 - when you need a static method moving on
12:10 - now we have our class method decorator
12:12 - now again like the static method
12:14 - decorator this is used for a method
12:16 - inside of a class and what this will do
12:18 - is transform the first implicit
12:21 - parameter or argument here to be the
12:23 - name or instance of the class not an
12:26 - individual object so typically when you
12:28 - call a meth right you have that first
12:30 - parameter which is self so do something
12:32 - Define getor name self and then maybe
12:35 - we'd return something like the name of
12:38 - this person now when we use the class
12:40 - method decorator rather than getting
12:43 - access to the instance in which this
12:44 - method was called on we get access to
12:47 - the class so person itself now what that
12:49 - means is that we can only access
12:51 - attributes which are class attributes
12:53 - like the one defined here or other class
12:56 - or static methods so we can pretty much
12:58 - only access anything that's defined on
13:00 - the class not on the instance so again
13:04 - if we go here we can print the value of
13:08 - CLS and you'll notice that when I run my
13:11 - code here we get the class main doerson
13:14 - we don't get an instance of the class we
13:15 - get the class itself that allows us to
13:18 - access something like a class attribute
13:20 - and to access other class methods or
13:22 - static methods if this was a static
13:25 - method we wouldn't get anything and we
13:27 - would not be able to access this class
13:29 - attribute in summary use a class method
13:31 - decorator when you want to access class
13:33 - attributes or other class or static
13:36 - methods and use a static method
13:38 - decorator when the function is
13:40 - completely independent and it doesn't
13:41 - need to access anything else associated
13:44 - with the class or with the instance now
13:46 - moving on we're looking at a decorator
13:48 - from the funk tools module which
13:49 - actually has a few different decorators
13:51 - and this one specifically allows us to
13:53 - Cache the results of various function
13:55 - calls this is super useful when you
13:57 - continually make the same same call to a
13:59 - function especially in a recursive case
14:02 - like the one I'm going to demonstrate
14:03 - here so first let me just break down an
14:05 - example where we actually need this and
14:07 - then we'll look at how The Decorator
14:08 - works so here we have the Fibonacci
14:10 - function this is a very famous problem
14:12 - in computer science and the sequence
14:15 - that the Fibonacci function generates
14:17 - looks like this 1 1 2 3 5 8 Etc now if
14:23 - you haven't been able to catch on to the
14:24 - pattern the way it works is the first
14:26 - two values are one and then the next
14:28 - value is equ equal to the previous two
14:30 - values summ together so the basic idea
14:32 - is WR some Fibonacci function where it
14:34 - gives you the value of n so what the
14:36 - term n is equal to and the way you
14:39 - calculate that is by simply calculating
14:41 - what the previous term is and then what
14:43 - the second previous term is then adding
14:45 - those values together now what this
14:47 - involves in this simple implementation
14:50 - is continually calling the same function
14:52 - multiple times with the same value and
14:54 - the reason that's the case is because we
14:56 - get a recursive call stack that looks
14:58 - something like this so here's an
15:00 - illustration of the recursive call stack
15:02 - when we call the Fibonacci function with
15:04 - the value five keep in mind this is a
15:06 - recursive function again where we're
15:08 - calling n minus1 and n minus 2 now when
15:11 - we call the Fibonacci a five in order to
15:13 - calculate that we need the Fibonacci of
15:15 - four and we need the Fibonacci of three
15:17 - now in order to calculate the Fibonacci
15:19 - of four we're going to need to calculate
15:20 - the Fibonacci of three and the Fibonacci
15:22 - of two now in order to calculate the
15:24 - Fibonacci of two we need one and zero
15:26 - and you get the idea we're continually
15:29 - actually calculating the same values of
15:31 - Fibonacci exponentially more times as
15:34 - this value goes up so what we can
15:36 - actually do instead here is cache the
15:38 - results that we've already calculated so
15:40 - that we don't need to keep calculating
15:42 - them when we already know what the
15:43 - result is now what this will do is
15:45 - drastically increase the speed of our
15:47 - function and I'll show you an example of
15:49 - that right now so just as a simple
15:51 - illustration here I'm going to call the
15:52 - Fibonacci function here with a value of
15:54 - 40 now you'll notice that I don't
15:56 - actually get an immediate result and to
15:58 - be be honest with you I'm not sure how
16:00 - long this is going to take because this
16:02 - is a very very poor time complexity
16:05 - algorithm and we're going to run a lot
16:07 - of times continually doing the same
16:09 - computation that we've already
16:11 - calculated so you can see here even
16:13 - while I'm talking it still isn't
16:14 - finished and there you go it just
16:15 - finished now that took about 10 to 15
16:18 - seconds and I want to show you what
16:19 - happens now when we add a simple cache
16:22 - so here's a modified version of the
16:23 - function now where we actually wrote in
16:25 - our own cache this is us doing it
16:27 - customly and you'll see see that when I
16:29 - run the code now we instantly get the
16:31 - result now let's see how we can do this
16:33 - in Python without having to actually
16:35 - modify the original function so we've
16:37 - gone back to the original example and
16:39 - what I can do now is I can simply
16:41 - decorate this with the funk tools.
16:44 - decorator now what this will do is
16:46 - actually write a custom cache for us and
16:48 - it will automatically resize the cache
16:51 - so we don't need to handle that ourself
16:52 - so Watch What Happens now when I run the
16:54 - code same thing we get the value
16:56 - instantly and we didn't need to write
16:58 - our own custom cache so whenever you're
17:00 - calling the same function repeatedly
17:02 - with the same arguments you can cache
17:04 - that result using the funk tools. cach
17:06 - without writing your own custom cache so
17:09 - now we are moving on to our final
17:10 - decorator which in my opinion is the
17:12 - coolest one and this one is the data
17:15 - class decorator now what the data class
17:17 - decorator will do is automatically fill
17:20 - in that boilerplate code that you're
17:21 - used to writing yourself now in order to
17:24 - understand the benefit of it let's look
17:25 - at the following class on our screen and
17:27 - then I'll show you how the data class
17:29 - decorator works it's also worth noting I
17:31 - made an entire video on this that goes
17:33 - through all of the details in
17:34 - intricacies if you want to learn more
17:36 - then check it out from the link in the
17:37 - description or the card on screen
17:40 - anyways let's have a look at this class
17:42 - so you can see here that what we're
17:43 - doing in this class is we're really just
17:44 - storing some information so we might
17:46 - have a method right where we're
17:47 - calculating some cost but generally
17:49 - we're just storing a name price and
17:51 - quantity and then we're writing a
17:53 - representation method something you've
17:55 - probably seen before and we're writing a
17:57 - very basic equal method we can actually
17:59 - compare if two products are the same
18:01 - products are the same if they have the
18:02 - same name price and quantity now this is
18:05 - great we can write this out but python
18:07 - has actually realized that this is a
18:08 - very common convention and people quite
18:11 - often do what you see here so they've
18:13 - actually given us a shortcut to really
18:15 - avoid having to write all three of the
18:18 - methods you see here now that shortcut
18:20 - is using the data class decorator so
18:22 - let's transform this code using that
18:25 - convention so there we are we now have
18:27 - code that is exactly equivalent to what
18:29 - you saw at the beginning of this section
18:31 - where we now don't need to write the
18:32 - init repper or equal method they're
18:35 - actually automatically implemented for
18:37 - us now if you don't believe me I'll show
18:39 - you a quick demo executing it but the
18:41 - way this works is we import data class
18:44 - this is The Decorator from the data
18:45 - classes module we put this on top of our
18:48 - class and what it will now do is it will
18:51 - read through the different attributes
18:53 - that we've ridden with their type
18:54 - annotation so string float and int and
18:57 - it will automatically populate the anit
19:00 - repper and equal method for us it can
19:02 - actually do quite a bit more and it's
19:04 - very flexible in terms of how it works
19:06 - again I made an entire video on it but
19:08 - the idea is now all that boilerplate
19:10 - code that we' commonly have to write on
19:12 - our own will automatically be added for
19:15 - us so let's paste in a simple usage
19:17 - example so you can see how it works so
19:19 - I've just pasted in some simple usage
19:21 - here and you can see that when I run my
19:23 - code this works and we get the results
19:25 - that were shown on the screen the idea
19:27 - is our initialization is already written
19:29 - for us again we didn't write that but
19:31 - it's already implemented to handle the
19:33 - name price and quantity we then have the
19:35 - representation method so when we print
19:37 - out the product we get it in a human
19:39 - readable form we can call any of the
19:41 - original methods that were written on
19:43 - this class and then we can use the
19:45 - equivalents to check if these products
19:47 - are the same notice that P1 and P2 were
19:49 - the same because they had the same value
19:51 - for each of their attributes that is the
19:53 - data class decorator super cool and with
19:55 - that said that's going to wrap up this
19:57 - video I hope you guys enjoyed if you did
19:59 - leave a like subscribe and I will see
20:02 - you in the next
20:03 - [Music]
20:10 - one

Cleaned transcript:

in this video I'll show you five python decorators that you need to know but first let's understand what a decorator is now a decorator is really just a function that modifies another function there's a bunch of builtin decorators in Python and we can also write our own now I want to look at an example of writing a custom decorator so we can understand what's actually happening behind the scenes when we use the builtin ones in Python so what we see here with the timer function is a decorator notice that what it actually does is return another function now we'll dive into that syntax in a second but let's look at how we use this what we do is we write the at symbol then the name of the function in this case it's timer and we decorate a function with it we put it on top of this function now you may have seen this in other modules like flask or Jango where we actually have these decorators to Define different roots and we use them all over python really behind the scenes they're functions that look something like this and what they do is take a function as their first argument and then return a new function that will replace this function seems a little bit strange but let's look at some equivalent syntax so rather than using The Decorator syntax here which is the at symbol what we can actually do is write the following line we can say the example function is equal to the timer function and then we can pass the example function to it when we do this this is effectively the exact same as simply writing The Decorator above the function I know seems a little bit strange but that's all it's doing it's simply taking this function right here passing it to this decorator and then replacing the function definition with whatever is returned from The Decorator so as you can see what the decorator really does is modify a function and typically add some Behavior around it in this case what the timer decorator will do is simply time how long it takes for a function to run so let's have a quick look at actually executing this code and then we'll dive into the syntax and understand how we write a custom decorator so let's start by running the code without decorating this function when I do that you see that we get the sum is and then this huge number now let's clear that and let's add our decorator so we'll say at at timer now when we run the code you'll notice that it tells us how long it took the function to run and then it tells us the sum now let's clear that and let's use that new syntax that I just showed you so rather than decorating the function we will say that the example function is equal to the timer and then we'll call the example function since this returns a new function we're just saying this function is now equal to a different one and now when I call this we'll get the exact same thing so that's what happens when we use a decorator now let's dive into this syntax so let's start with the first function here which is timer now notice that our decorator functions are always going to accept at least one argument or have one parameter which is the function that they're modifying so in this case we take in Funk and that means any fun function that we actually decorate with this decorator will be passed as the first argument this allows us to use this decorator for any type of function that we want then what we do is we write some kind of wrapper function inside of this function it might look like strange syntax but it's totally valid to Define functions inside of other functions in Python this is known as an inner function and there's some more complexities we don't need to get into that now within the wrapper function what we accept here is always star args and star star quarks now really what we're telling the function here is that we don't know how many arguments are going to be passed to it because this timer function could be used to decorate any function so we're going to accept any number of positional arguments and any number of keyword arguments if you've never seen this syntax before that's all it means except any number of positional arguments and any number of keyword arguments then what we do is we start a timer so this is our custom functionality that we're adding or decorating the function with so we start the timer by getting the start time we then actually call the function so we say the result is equal to the original function which was right here and then we pass to It Whatever the arguments and the keyword arguments were that were passed to this wrapper function we then figure out what the end time is and then we print how much time it took to run this function and then we return the result now the important thing is that we always want to be calling the function that we decorated we want to store whatever the result was and we want to return that result this way the decorated function will always work exactly the same as if it wasn't decorated except we've added some additional functionality right so in this case we're just starting a timer and seeing how long it took the function to run there's all kinds of advanced decorators and more use cases that we can look at but that's the basics of a decorator you write a function it accepts some function as the first argument it can accept other arguments but in this case we just accept one we have some wrapper function defined inside of it this wrapper function always accepts any number of positional and keyword arguments so it's Dynamic and can work for any function we add some additional functionality call the original function and then return whatever that result is now when I go and I use my decorator on top of any type of function it will work and it will allow me to add that timer functionality to it now if you want an entire video tutorial just showing you how to write custom decorators I'll link one on the screen but for now let's look at five builtin python decorators that you need to know about but first another thing that you need to know about is that even during this really tough job market the program that I run with course careers is still helping students land software development jobs we had a student complete the program in 39 days and in under a month later he landed a junior developer position making 70k per year if you want to learn more about how that works I have a free introduction course that you can check out from the link below there's a ton of value in there and even if you don't purchase the course it really breaks down what you need to do in 2024 and Beyond to qualify for these Junior developer positions because just being honest with you guys it is harder now than it was a few years ago but it's possible if you have the right guidance and you know the path you need to follow anyways check it out from the link below so the first deck rator we need to look at is known as property now this is used for various methods inside of a class and the idea here is that we can treat a method as if it was an attribute and we can gate the access to a specific field or attribute in Python now you may not know this but in Python we don't have access modifiers like private public and protected if you don't know what those are don't worry but in other programming languages we have a way to determine whether or not an attribute can be accessed from outside of the class in Python we don't have that so what we do as a convention is we add a leading underscore before any of the attributes that we defined inside of our instance that we don't want to be accessed outside of the class whenever you see something that starts with an _ that indicates that it should be treated as private and that means that I shouldn't come here and write something like C doore radius equals 10 even though I can do that we're denoting to the user of this class that we shouldn't do that and really this should be a private attribute now the reason that's important is that we typically use property in combination with a private attribute so that we can actually control the access of the attribute and whether you can set it delete it Etc so what we've done here here is we've written a method called radius all this does is return the value of the private attribute radius but we've denoted this as a property now when we do that that actually allows us to access the name of this method without calling the method from our Circle object so in this case I can say c. rius and that's actually going to call this radius method and return whatever is inside of it now just to show that to you if I say print called me here and I run this you'll see that it says called me and then we get five 10 then it says called me and we get 10 so the idea is we're going to go through this radius method every time we try to access the radius property now as well as a getter which is what this is known as we also have the ability to add a Setter now a Setter is what'll be used when we actually want to change the value of the attribute in this case we always use this private attribute as the source of Truth so what the actual value of radius is going to be and then we use the getter and the setter to control the axis for it so in this case we Define a Setter for our radius it takes in self and a value what we do is we make sure the value is positive and if it is then we actually set the radius which is our private attribute to be that value otherwise we raise a value error and we say that the radius must be positive so now when I come down here and I say c. radius is equal to 10 what will happen since I've used this decorator is I'll go into this method and I'll start executing the code inside of here so the value pass is going to be the value that I specified here which is 10 we're going to do our check since it's positive this will work and we'll be able to set the radius now let's see what happens if we try to set this to say something like 1 well when I run my code here notice we get an error and it says the radius must be positive because our Setter caught that this was a negative value and it didn't allow us to actually make that change to the private attribute so that's how the property decorator works that allows you to control access to a private attribute and to have some logic be handled or called when you're getting or setting a value now as well as getting in setting we can also add a deleter method so I've just slightly changed the example now to add the deleter method notice that the deleter method will be triggered whenever we use the Dell keyword so if I go here and I run my code we'll see that we get the output deleted the reason we're getting that is because we first print deleted we then delete the private attribute and now we would no longer be able to access access it now you can do anything you want inside of these methods but the idea is you define one of them as a property the name of the property is going to be the name of the method then you use whatever the method name is do Setter and. deleter to actually write your own custom Setter and deleter methods you don't have to implement them there's a few other options and things you can do here with properties but that's the basic idea and this is quite useful for creating read only attributes write only attributes or other custom Behavior to really gate the access to the private attributes and control what's happening with the internal state of your class so now we move on to a pretty popular decorator that you've probably seen before which is static method now the static method decorator is used when we want to denote a method inside of the class as static now a static method simply means it's something that belongs to the class and not to an instance of the class and it's not going to have any implicit first parameters like the self keyword or the class all that really means that we use the static method when we want to have some kind of function that belongs inside of a class but doesn't belong to a particular instance so maybe we have some math class and we have a function like add or multiply now it wouldn't really make sense for this to be associated with an instance we're not going to create an instance of this math class we're really just using the math class to organize a few different functions so that they're in a logical area and we know where to access them so this is a great example of where you would use a static method and you need need to decorate the method with the at static method decorator the reason you do that is you no longer need to accept that implicit first parameter like self or CLS now in this case the way that we would utilize these methods is by simply writing the name of the class however if you were to have an instance of the class we have something like m is equal to math you can still call these methods using the instance so I can say m. add one2 that's perfectly fine but what will happen since we've added this decorator is we'll no longer pass this instance as the first argument self allowing us to just treat these as static methods I don't have much more to say here just always use the static method decorator when you need a static method moving on now we have our class method decorator now again like the static method decorator this is used for a method inside of a class and what this will do is transform the first implicit parameter or argument here to be the name or instance of the class not an individual object so typically when you call a meth right you have that first parameter which is self so do something Define getor name self and then maybe we'd return something like the name of this person now when we use the class method decorator rather than getting access to the instance in which this method was called on we get access to the class so person itself now what that means is that we can only access attributes which are class attributes like the one defined here or other class or static methods so we can pretty much only access anything that's defined on the class not on the instance so again if we go here we can print the value of CLS and you'll notice that when I run my code here we get the class main doerson we don't get an instance of the class we get the class itself that allows us to access something like a class attribute and to access other class methods or static methods if this was a static method we wouldn't get anything and we would not be able to access this class attribute in summary use a class method decorator when you want to access class attributes or other class or static methods and use a static method decorator when the function is completely independent and it doesn't need to access anything else associated with the class or with the instance now moving on we're looking at a decorator from the funk tools module which actually has a few different decorators and this one specifically allows us to Cache the results of various function calls this is super useful when you continually make the same same call to a function especially in a recursive case like the one I'm going to demonstrate here so first let me just break down an example where we actually need this and then we'll look at how The Decorator works so here we have the Fibonacci function this is a very famous problem in computer science and the sequence that the Fibonacci function generates looks like this 1 1 2 3 5 8 Etc now if you haven't been able to catch on to the pattern the way it works is the first two values are one and then the next value is equ equal to the previous two values summ together so the basic idea is WR some Fibonacci function where it gives you the value of n so what the term n is equal to and the way you calculate that is by simply calculating what the previous term is and then what the second previous term is then adding those values together now what this involves in this simple implementation is continually calling the same function multiple times with the same value and the reason that's the case is because we get a recursive call stack that looks something like this so here's an illustration of the recursive call stack when we call the Fibonacci function with the value five keep in mind this is a recursive function again where we're calling n minus1 and n minus 2 now when we call the Fibonacci a five in order to calculate that we need the Fibonacci of four and we need the Fibonacci of three now in order to calculate the Fibonacci of four we're going to need to calculate the Fibonacci of three and the Fibonacci of two now in order to calculate the Fibonacci of two we need one and zero and you get the idea we're continually actually calculating the same values of Fibonacci exponentially more times as this value goes up so what we can actually do instead here is cache the results that we've already calculated so that we don't need to keep calculating them when we already know what the result is now what this will do is drastically increase the speed of our function and I'll show you an example of that right now so just as a simple illustration here I'm going to call the Fibonacci function here with a value of 40 now you'll notice that I don't actually get an immediate result and to be be honest with you I'm not sure how long this is going to take because this is a very very poor time complexity algorithm and we're going to run a lot of times continually doing the same computation that we've already calculated so you can see here even while I'm talking it still isn't finished and there you go it just finished now that took about 10 to 15 seconds and I want to show you what happens now when we add a simple cache so here's a modified version of the function now where we actually wrote in our own cache this is us doing it customly and you'll see see that when I run the code now we instantly get the result now let's see how we can do this in Python without having to actually modify the original function so we've gone back to the original example and what I can do now is I can simply decorate this with the funk tools. decorator now what this will do is actually write a custom cache for us and it will automatically resize the cache so we don't need to handle that ourself so Watch What Happens now when I run the code same thing we get the value instantly and we didn't need to write our own custom cache so whenever you're calling the same function repeatedly with the same arguments you can cache that result using the funk tools. cach without writing your own custom cache so now we are moving on to our final decorator which in my opinion is the coolest one and this one is the data class decorator now what the data class decorator will do is automatically fill in that boilerplate code that you're used to writing yourself now in order to understand the benefit of it let's look at the following class on our screen and then I'll show you how the data class decorator works it's also worth noting I made an entire video on this that goes through all of the details in intricacies if you want to learn more then check it out from the link in the description or the card on screen anyways let's have a look at this class so you can see here that what we're doing in this class is we're really just storing some information so we might have a method right where we're calculating some cost but generally we're just storing a name price and quantity and then we're writing a representation method something you've probably seen before and we're writing a very basic equal method we can actually compare if two products are the same products are the same if they have the same name price and quantity now this is great we can write this out but python has actually realized that this is a very common convention and people quite often do what you see here so they've actually given us a shortcut to really avoid having to write all three of the methods you see here now that shortcut is using the data class decorator so let's transform this code using that convention so there we are we now have code that is exactly equivalent to what you saw at the beginning of this section where we now don't need to write the init repper or equal method they're actually automatically implemented for us now if you don't believe me I'll show you a quick demo executing it but the way this works is we import data class this is The Decorator from the data classes module we put this on top of our class and what it will now do is it will read through the different attributes that we've ridden with their type annotation so string float and int and it will automatically populate the anit repper and equal method for us it can actually do quite a bit more and it's very flexible in terms of how it works again I made an entire video on it but the idea is now all that boilerplate code that we' commonly have to write on our own will automatically be added for us so let's paste in a simple usage example so you can see how it works so I've just pasted in some simple usage here and you can see that when I run my code this works and we get the results that were shown on the screen the idea is our initialization is already written for us again we didn't write that but it's already implemented to handle the name price and quantity we then have the representation method so when we print out the product we get it in a human readable form we can call any of the original methods that were written on this class and then we can use the equivalents to check if these products are the same notice that P1 and P2 were the same because they had the same value for each of their attributes that is the data class decorator super cool and with that said that's going to wrap up this video I hope you guys enjoyed if you did leave a like subscribe and I will see you in the next one
