With timestamps:

00:00 - hey guys and welcome back so in today's
00:02 - video I am bringing you another
00:03 - programming problem and solution now I
00:06 - do these once a week so make sure you
00:07 - guys are staying tuned for those I
00:09 - typically try to release them on like
00:10 - Monday or Tuesday but at least once a
00:12 - week I'm trying to get one out now it's
00:14 - a new thing that I've kind of been
00:15 - starting so essentially the problem
00:16 - we're doing today is call is a biscuit
00:19 - maze traversal problem now I'll go
00:22 - through the exact specifications but I'm
00:23 - not gonna read this entire thing so if
00:25 - you want to read this it'll be on my
00:26 - website there'll be a link in the
00:28 - description you can go there and I'll
00:29 - have the PDF and you have a look at it
00:30 - also I don't make these I just find I
00:33 - got this off of the Waterloo website
00:35 - they do some programming competitions
00:36 - for high school students and I believe
00:38 - University as well they have a bunch of
00:40 - really complicated and good programs or
00:42 - problems on there and they also have the
00:44 - solutions and the test files so that's
00:46 - typically where I take my problems from
00:47 - now anyways so essentially what we're
00:50 - gonna be doing here is we're defining a
00:52 - maze and we have to find a way given any
00:54 - start room so starting in like room so
00:57 - there's a maze of a bunch of different
00:59 - rooms a bunch of different corridors
01:00 - that connect those rooms given a
01:02 - starting room we have to figure out how
01:04 - long it could possibly take us by
01:05 - traversing the maze to get back to our
01:08 - starting room so essentially taking any
01:11 - path throughout the maze how long is the
01:15 - maximum time like if we took the longest
01:17 - path how long would it take us to get
01:18 - back to that starting room and we're
01:20 - gonna do this in a certain way which
01:21 - you'll see in a second so the main kind
01:23 - of constraints on this maze are that we
01:25 - have n rooms connected by different
01:27 - corridors each room is in the shape of a
01:29 - circle now each corridor forms
01:31 - connection between two distinct rooms so
01:33 - no corridor goes into the same room
01:35 - there's no like big loop that goes into
01:36 - the same room which is actually really
01:38 - nice for us no two quarters will connect
01:41 - the same pair of rooms which again is
01:42 - also very nice which means that there's
01:45 - not two pathways going from like room 1
01:48 - to room 2 there's only one way to go
01:50 - from room 1 to room 2 now each room will
01:52 - have at least one corridor that connects
01:53 - to it so that's not really that
01:55 - important but essentially it means we
01:56 - don't have any floating rooms that are
01:57 - inaccessible that we can't get to or
01:59 - like we start in a room and there's no
02:01 - way to get out of it something like that
02:02 - okay so is essentially the way that it's
02:04 - saying to navigate through this maze is
02:06 - since the lights are out that's what
02:09 - like the problem is the lights are out
02:11 - in this maze what we're gonna do is
02:13 - we're gonna
02:13 - in our starting room place our right
02:14 - hand on one of the somewhere on the wall
02:17 - so since it's a circle obviously it's
02:19 - one wall but somewhere on that wall
02:21 - we'll place our right hand now
02:22 - determining where we where we put our
02:24 - right hand will take us in two different
02:27 - corridors so we could place our right
02:28 - hand like maybe near corridor one or
02:31 - corridor two and we'll just keep
02:32 - following that in a counterclockwise
02:34 - direction until eventually we end up
02:37 - back into our original room if you don't
02:39 - know this is a thing with mazes if
02:40 - you're ever stuck in a maze you put your
02:42 - hand on the right wall and you just
02:43 - follow that right wall until eventually
02:45 - you end up at the exit or what do you
02:48 - call it like back where you started or
02:49 - something like that I don't know how
02:51 - this works mathematically but it does
02:52 - but it is shouldn't be noted that this
02:55 - could take you a very long time and
02:57 - that's what this is asking for how long
02:58 - could it take us so that's how that kind
03:01 - of works so yeah now there's a bunch of
03:04 - input specifications and output
03:05 - specifications and whatnot I mean if you
03:07 - guys are going to attempt to solve this
03:08 - problem I assume you'll be able to
03:10 - figure out how these work by just
03:11 - reading through them so I'm not really
03:12 - gonna bother but what I'll do is quickly
03:14 - go through an example of how the steps
03:17 - that we should take to solve this talk
03:19 - about the algorithm I'm gonna use and
03:21 - then go into the solution I will note
03:23 - this is a very complicated problem if
03:25 - you're not in university I don't expect
03:27 - you to be able to solve this even for
03:29 - myself like we haven't learned how to do
03:30 - this in class I had to do a bit of a
03:32 - research to kind of figure out the best
03:34 - way to approach this and my solution is
03:35 - far from perfect I'll tell you that so
03:38 - what I'm gonna do is just load up a
03:39 - little drawing thing here and let's do
03:41 - an example starting room at one so
03:43 - essentially the input right it gives us
03:44 - a maze and our main look something like
03:46 - this so it's saying like one is
03:47 - connected to three three is connected to
03:49 - one two connects to five 5 to 4 4 to 6 2
03:54 - to 4 that's what this our maze layout
03:55 - now note that this is the same maze I
03:57 - know that one like these are not
03:59 - connected in any way but that's
04:00 - perfectly fine you can have kind of
04:02 - floating components now let's say we
04:05 - start in room 1 what is the maximum
04:08 - amount of corridors we have to pass
04:09 - through before we get back to room 1
04:11 - well we got to go so we'll pick up we'll
04:13 - put our hand on any place on the wall
04:15 - let's say we choose here ok and we're
04:18 - gonna go counterclockwise like this and
04:21 - keep our hand on that right wall so
04:23 - that'll mean it'll bring us to here and
04:25 - then we'll go to here and then we'll
04:27 - come back
04:27 - so we kind of went like that which means
04:29 - that we passed through this corridor not
04:31 - one but two times so the maximum amount
04:35 - of time is to get back to room one
04:36 - starting in room one is two now
04:39 - obviously this is very simple because
04:40 - there's only one room that can external
04:41 - one so obviously that would be the only
04:44 - way this works but say three branched
04:46 - out like this and three went into
04:48 - another room well if we put our hands
04:51 - here and we go and we go well we're on
04:53 - this right wall which means that we now
04:54 - have to go into here and then we go here
04:56 - and then we go back back back so it
04:59 - would take us what do you call it four
05:01 - steps to do this because we had to go
05:03 - through this corridor twice so two like
05:06 - that then we had to go through this
05:07 - corridor twice so it took us four steps
05:09 - to do that so just another example now
05:11 - down here let's say we start in room two
05:13 - well we're gonna place our Wolf's place
05:15 - our hands summer on the wall but here's
05:17 - the thing we can place our hand
05:19 - somewhere on kind of like this section
05:22 - of the wall or we could place it right
05:24 - here now do you know why this makes a
05:27 - difference where we place our hands like
05:28 - if we place it somewhere here or if we
05:30 - place it somewhere here why will this
05:31 - make a difference well let's think about
05:33 - this for a second if we decide to place
05:35 - our hand on the wall here where I'm
05:37 - making the red dot what we're gonna go
05:39 - counterclockwise rooms we're gonna go
05:41 - this way I'm going to follow this right
05:42 - wall so we're gonna do something that
05:45 - looks like this until we end back up in
05:47 - the room which means we've gone through
05:48 - one to three corridors and we ended back
05:51 - up in room number two now that's fine
05:54 - that works but let's contrast that if we
05:57 - put our hand here same process we put
06:00 - our hand here
06:00 - now we're gonna go counterclockwise what
06:02 - we're gonna do though is we're gonna
06:03 - follow this path right and now we're
06:06 - gonna go into six which we didn't go
06:07 - into before we're gonna come back up
06:09 - into five and loop back in to here now
06:13 - that is one two three because we had to
06:15 - go through this corridor first or twice
06:17 - right four five so as opposed to the
06:21 - first solution we got which was three
06:22 - now we have five which means five is the
06:25 - maximum to get back into this room
06:28 - starting in this room I mean I can show
06:30 - you examples for all the other ones but
06:31 - I think you guys probably get the point
06:33 - now this is actually a really simple
06:34 - example of the maze I know this might
06:36 - seem a bit confusing because you have
06:37 - like paths connecting like that but now
06:39 - imagine that this goes on
06:41 - and it looks something like this okay
06:44 - and then these are connected and then
06:46 - there's one connected here and then this
06:48 - one connects to this room and then that
06:50 - connects to this right like
06:51 - geometrically this doesn't have to make
06:53 - sense the maze that it gives you it just
06:54 - gives you connections right so I mean
06:57 - like let's say we start here we going to
06:59 - five well we could go back like that but
07:01 - if we come into five on this angle right
07:04 - so if we come from four to five and we
07:05 - keep our hand on that right wall now
07:07 - we're gonna go into here and then we're
07:08 - gonna go into this and then we're gonna
07:10 - go into this and then right wall we're
07:11 - gonna go here and then we gonna go here
07:13 - now we're in six and now we're back
07:14 - right wall and now we're back into five
07:16 - right and then we go into this again so
07:19 - that's not a possible solution right so
07:22 - like that is a somewhere that we can run
07:25 - into an issue so we're gonna go through
07:26 - the kind of my solution and how this
07:27 - works but let's quickly talk about
07:29 - something called a queue based algorithm
07:31 - which is what I'm gonna use to solve
07:32 - this problem now essentially what I want
07:35 - to do is I want to try every single path
07:38 - that I can because I need to find the
07:40 - maximum distance to get into this like
07:43 - Inc back into this room so for this room
07:46 - we'll just stick with example two what I
07:47 - did was I said well what are the
07:49 - neighbors of this room well the
07:52 - neighbors I'm saying are gonna be four
07:53 - and they're gonna be five now these are
07:55 - the two rooms that I could possibly
07:57 - these are my options right when I start
07:59 - in room two I can go into room five or I
08:02 - can go into room for those are the two
08:04 - options I have so what I'm gonna do is
08:05 - I'm gonna say okay so these are our
08:06 - options well we start in room two now we
08:09 - can go into room five or we can start in
08:11 - room two and we can go into room for
08:14 - those are my two options now let's think
08:17 - about this though okay let's go back
08:18 - there if I start in room two so now
08:21 - let's say I decided let's cross this one
08:23 - out let's say I decided to go into room
08:24 - five okay that's the one I picked well
08:26 - what are my options now let's think
08:29 - about it we have to determine how we
08:31 - came into room five to figure out what
08:33 - room we're gonna go into next because
08:36 - well let's think about this if I come in
08:38 - from this way and I'm on the right wall
08:39 - I need to go into room before right but
08:43 - if I came in from corridor for I would
08:45 - have to go into court or two right I'd
08:47 - have to go to room two so we have to
08:49 - determine how we came in to pick the
08:52 - next room we're gonna go to so what
08:53 - we'll do is we'll look at this and we'll
08:54 - say okay so we
08:55 - from room to room 5 so that corridor is
08:57 - located here right so what's the next
09:01 - corridor counterclockwise that's closest
09:04 - to us well that's this corridor as
09:06 - opposed to let's pretend there was
09:07 - another one here okay that went into a
09:08 - room like that okay so we need to go
09:11 - into this corridor so we say okay so we
09:13 - went into five now since we went into
09:15 - five and we use that specific corridor
09:17 - which was two to five well that means
09:19 - that now we'll change this and rather
09:21 - than going from two to five we're gonna
09:23 - go from two to five and then the next
09:25 - one we have to go to is four so we'll
09:28 - put four like that we continue this
09:30 - process so what we do now is we say okay
09:32 - well let's see here so now we've we've
09:35 - essentially the path we've done is we've
09:37 - done two to five and now we're back to
09:40 - for now from four where do we go well
09:44 - again it matters how we came in to four
09:47 - because there's three ways to get into
09:48 - four you can go in from six to or five
09:50 - so we came in from five so we're on this
09:53 - right wall right so now we have to look
09:55 - and find the corridor that's the most
09:56 - counterclockwise the closest
09:58 - counterclockwise to us that's gonna be
10:01 - this quarter which goes from four to two
10:02 - which means that now the next room we
10:04 - have to go into is to okay sweet so
10:07 - we've done this we've now the first one
10:09 - is the same as the last one which means
10:11 - that we've reached the original room and
10:13 - how long did it take us we'll one two
10:15 - three corridors right because I mean you
10:18 - just count the the connections between
10:20 - the rooms really calm okay so that's how
10:23 - that worked
10:23 - now that's one possible solution right
10:26 - so we've exhausted this we've created
10:27 - this and we said okay so this leads to
10:29 - to a value of three but what was the
10:32 - other solution that we decided not to
10:34 - determine or not to go on yet well that
10:36 - was two and four so let's try two and
10:38 - four now let's clear all this and let's
10:39 - do two and four well two and four is
10:42 - like this right so we go here and
10:44 - remember we're on this kind of outside
10:46 - wall like that alright so if we come
10:48 - into for now we came in from corridor
10:51 - two to four so what's the next room we
10:53 - have to go into well since we're on this
10:54 - right wall and we're following that that
10:56 - means we got to go into the next most
10:57 - counterclockwise thing which is six so
11:00 - now we go from four to room six
11:03 - now let's look at this so six let's find
11:06 - the most counterclockwise room
11:08 - corridor 2 for like from coming in on
11:11 - four well that's actually for itself and
11:14 - that work that works fine we can go
11:15 - through the same corridor twice because
11:17 - it only has one corridor connecting to
11:19 - it so that's kind of a case is if you go
11:22 - into a room and only as one corridor
11:23 - connecting into it and it's not the same
11:25 - room that we started in just go back the
11:26 - other way
11:27 - but that still counts as a traversal
11:28 - because that's what we had to do right
11:29 - so we go six and then we go back to four
11:32 - like that so now let's let's look at
11:35 - this right so now what our path looks
11:37 - like is we've gone from two to four into
11:40 - six and now we're back into four but
11:43 - this time when we come in four what side
11:44 - do we come in we don't come from two
11:46 - anymore
11:46 - we're coming from six which means that
11:48 - we go to the next most counterclockwise
11:50 - thing which is five and then we go in
11:52 - five okay so it's odd five here and then
11:55 - from five what do we do well most
11:57 - counterclockwise which is two so we go
11:59 - into two and then obviously well we
12:01 - found our solution and now it takes one
12:03 - two three four five to do that so that
12:07 - is our answer and that's how the
12:08 - solution works and what we do to kind of
12:11 - simulate this right is well we start
12:15 - with a few different paths we start with
12:17 - two five two four and then we extend out
12:20 - and just kind of follow and loop through
12:22 - the maze and then get a list of a
12:23 - certain size and once eventually we have
12:26 - the start and the end the same we've
12:28 - gone back into that room which means
12:30 - that we're done we found a solution
12:32 - we're good to go
12:33 - awesome all right so my solution I'm
12:37 - gonna show you now is it does exactly
12:40 - what I just showed you except in code
12:42 - form now it's a bit confusing obviously
12:45 - reading someone else's code is not that
12:46 - easy but I'm gonna try to walk you guys
12:47 - through it and show you exactly how it
12:49 - works so just stay tuned for one second
12:51 - okay so what I'm gonna do for you guys
12:52 - now is run my script and show you it
12:54 - working and point out some kind of the
12:56 - flaws and then why the solution is not
12:58 - amazing but works so essentially the
13:01 - solution that I'm about to show you is
13:02 - exactly what I talked about it works in
13:04 - the exact same way it follows that
13:06 - procedure now it uses what's known as a
13:09 - breadth first search algorithm which
13:11 - essentially is what I showed you just
13:13 - creating a bunch of different paths and
13:15 - then kind of finishing those paths using
13:17 - what's known as a queue now this is a
13:20 - queue based algorithm I'm not really
13:21 - gonna talk
13:22 - exactly but what that is I have a video
13:23 - on my channel that explains that I if
13:26 - you need to link to that let me know and
13:27 - I'll send one in the description or
13:29 - whatever but anyways these are all of
13:32 - the test files that we have
13:33 - so essentially you can see we have these
13:36 - in files and these out files now the in
13:38 - files obviously like the number in
13:40 - number out correspond to some sample
13:42 - input and the expected output now what I
13:45 - did is just wrote a nice script that
13:47 - automated this process of testing all
13:49 - the in files and out files on my
13:51 - solution and then determining how many I
13:52 - got correct how many took too long or
13:54 - how many I got wrong now since you can
13:57 - see that some of these files are quite
13:58 - large for example let's look at mais 18
14:02 - or even let's look at this one may is 25
14:05 - if I edit this um you can see that this
14:09 - goes on for a long time in fact we have
14:13 - two hundred thousand lines of input so
14:17 - simply even reading this input and alone
14:19 - takes a long time let alone processing
14:22 - the information so we have a hundred
14:24 - thousand rooms and then for every single
14:27 - one of those rooms we have to determine
14:28 - how long it's gonna take so you can
14:29 - imagine that like a slow solution which
14:32 - is something that I have will not really
14:34 - work for this because it takes so long
14:36 - so there's obviously something that
14:37 - could be improved for my solution and I
14:40 - want you guys to help me if you have a
14:42 - better solution please like show it to
14:43 - me comment it down below because I've
14:46 - been trying to find a way to optimize
14:47 - this and I can't figure it out yet so
14:49 - anyways that's kind of like some what
14:50 - the input looks like I'll show you an
14:52 - output file so you get an idea this is
14:53 - not the corresponding one but I output
14:56 - right like like that's what an expected
14:58 - output is so anyways let's run this and
15:01 - I'll show you kind of how this this
15:02 - works
15:03 - so I time all my solutions just to see
15:05 - how long they actually take and I can
15:07 - give so I can see if I'm improving them
15:09 - when I'm making modifications but the
15:11 - timeouts are I time out ever after half
15:13 - a second so essentially if it takes more
15:15 - than half a second to find the solution
15:17 - I just say timeout because I really
15:19 - don't wanna sit here for a long time
15:20 - like technically if I ran this for a day
15:22 - it would get all the solutions but I
15:25 - don't want to do that especially not for
15:26 - the video so anyways you can see here so
15:29 - there's 28 problems
15:30 - I got 11 correct 17 timed out zero we're
15:32 - incorrect well I mean if you consider
15:35 - the timed out ones
15:36 - no answer and then it just gives me kind
15:38 - of an outline of the pound sign means I
15:41 - got it correct tea means time out and
15:43 - then so you can see all the different
15:44 - ones so I just wrote the script that
15:45 - does this for me it's not really a part
15:48 - of the solution it just automates the
15:50 - testing so anyways let's get into the
15:51 - code now and talk about all this so this
15:54 - would I'm about to highlight is the
15:57 - automated tester so what it does is
15:59 - essentially just opens all the in files
16:00 - and the out files in the directory and
16:02 - then just calls the function run to get
16:05 - an answer for the given for given input
16:07 - and then based on that answer compares
16:10 - it to the expected answer and then it'll
16:12 - tell you if you got it correct incorrect
16:13 - keep track and then you know give you a
16:15 - nice little output at the end I think
16:17 - it's a really easy way to test your
16:18 - programs really quickly now the actual
16:20 - solution is down here now essentially
16:23 - right like I'll read through this but it
16:25 - is kind of complicated how it works
16:27 - uh-huh and you're gonna have to look at
16:29 - it on your own if you really want to
16:30 - understand it but essentially given some
16:33 - kind of input what we're gonna start by
16:35 - doing is we'll create a blank maze
16:36 - dictionary what this is gonna represent
16:38 - is kind of the data structure of our
16:39 - maze so it's gonna store a bunch of keys
16:41 - which are between 0 and the amount of
16:43 - rooms and each of those keys will be
16:45 - corresponding to a node now those nodes
16:48 - are what is here now this node simply is
16:52 - just an object that stores all of the
16:54 - neighbors of a given way codes like room
16:59 - so for example all the connections to
17:01 - that room that's what we're storing I
17:02 - mean I didn't really need to do this as
17:04 - a class but I just felt like doing it as
17:06 - a class and that's all it's storing here
17:08 - so that's how we kind of are storing
17:10 - things in here now when I get the input
17:12 - I got to split it up into the different
17:13 - parts which is obviously the the actual
17:17 - room layout and then the rooms that I
17:18 - need to be count doing calculations are
17:20 - doing the solution for so I do that I
17:22 - just get the time before we start
17:24 - running the solution so that I can see
17:26 - you know how long it took to do
17:28 - something then I'm converting each line
17:30 - of input into integers because I need
17:32 - everything an int and then just what do
17:34 - you call it setting up this data
17:36 - structure of the maze with the key I
17:38 - which is the room I and then all the
17:41 - given neighbors now this is the actual
17:43 - real solution that's kind of just
17:44 - setting things up and since we're gonna
17:47 - have to do a certain amount of queries
17:48 - which is like however many
17:49 - they asked us to do calculations for we
17:52 - need to do the solution for each room so
17:54 - I do this this is gonna be the current
17:57 - max value of the solution we're looking
17:59 - for it's essentially how long so far has
18:01 - it taken us to get back to the same room
18:03 - pretty straightforward
18:04 - now I used a cue just simply import it
18:07 - out from Python import cue really
18:09 - standard and then what I'm doing is I'm
18:12 - initially starting off by setting up the
18:14 - past that we could take now those paths
18:17 - right and that's what this for loops
18:18 - doing are the ones that I talked about
18:19 - before like starting in room - we could
18:21 - go to room 4 we go to room 5 good room 7
18:23 - right that's what we start off with
18:25 - there and then I add those into a queue
18:27 - and we constantly strip off one of the
18:30 - possible solutions from the queue and
18:33 - then just keep trying essentially is
18:36 - what we do so while the queue is not
18:39 - empty so while we haven't looked at
18:41 - every single possible solution we have
18:42 - keep trying now this is just responsible
18:45 - for the timeout it's simply saying if it
18:47 - takes more than half a second just just
18:48 - quit we're done this is gonna DQ which
18:51 - means get whatever solution we should be
18:53 - working on next so either adding to it
18:55 - checking if it's finished we're moving
18:57 - into a new room because each time we run
18:59 - this loop we for a given solution we go
19:02 - into like a different room that's that's
19:04 - how it works
19:05 - then we'll check based on whatever the
19:08 - current solution is we'll say well if
19:09 - the last element in that solution is
19:12 - equal to whatever room were in like the
19:14 - way that I showed you that means we've
19:15 - successfully gone back to our room so
19:18 - we'll check if this the length of that
19:20 - solution is greater than our current max
19:22 - if it is will simply say MX is equal to
19:25 - so our max the length of current
19:28 - otherwise what we do is we're gonna copy
19:31 - the solution and we're gonna add to it
19:32 - we're gonna add to it the next room we
19:34 - need to go into so what I'm doing here
19:36 - is simply just checking if there's only
19:38 - one neighbor we just need to go back
19:39 - into the previous room so that's what
19:42 - this if statement does but down here
19:44 - we're simply just gonna go to the next
19:45 - clockwise room and that's what all this
19:48 - is doing just making sure that we're
19:50 - going into them like the next room
19:52 - that's we should be going into and then
19:54 - I'm just checking here and saying you
19:55 - know what well if at this point we
19:58 - already gotten in this is meant to speed
20:00 - things up a bit if we've already reached
20:02 - that room that we
20:03 - to be in then just add one because well
20:05 - it would be one more solution to get in
20:07 - one more step to get in and then add
20:09 - that to the queue now I'm storing all
20:11 - these in the output and then we're
20:12 - simply returning at the end and this is
20:14 - how this solution works now again this
20:16 - is very slow because it's a queue based
20:18 - algorithm so there's a ton of different
20:19 - steps and it's running through like
20:21 - millions of times
20:22 - tons of operations you guys have a
20:24 - better solution this please don't
20:26 - hesitate to let me know really
20:27 - interesting problem if you're able to
20:29 - solve this give yourself a pat on the
20:30 - back because it is complicated and with
20:32 - that being said I'd love to hear you
20:34 - guys feedback on this I know this was a
20:35 - difficult problem but I want to give
20:37 - some of you more advanced people on
20:38 - something to look into and to challenge
20:40 - yourself with so that being said I guess
20:42 - I will wrap up the video here and I'll
20:44 - see you again in another one
20:45 - [Music]

Cleaned transcript:

hey guys and welcome back so in today's video I am bringing you another programming problem and solution now I do these once a week so make sure you guys are staying tuned for those I typically try to release them on like Monday or Tuesday but at least once a week I'm trying to get one out now it's a new thing that I've kind of been starting so essentially the problem we're doing today is call is a biscuit maze traversal problem now I'll go through the exact specifications but I'm not gonna read this entire thing so if you want to read this it'll be on my website there'll be a link in the description you can go there and I'll have the PDF and you have a look at it also I don't make these I just find I got this off of the Waterloo website they do some programming competitions for high school students and I believe University as well they have a bunch of really complicated and good programs or problems on there and they also have the solutions and the test files so that's typically where I take my problems from now anyways so essentially what we're gonna be doing here is we're defining a maze and we have to find a way given any start room so starting in like room so there's a maze of a bunch of different rooms a bunch of different corridors that connect those rooms given a starting room we have to figure out how long it could possibly take us by traversing the maze to get back to our starting room so essentially taking any path throughout the maze how long is the maximum time like if we took the longest path how long would it take us to get back to that starting room and we're gonna do this in a certain way which you'll see in a second so the main kind of constraints on this maze are that we have n rooms connected by different corridors each room is in the shape of a circle now each corridor forms connection between two distinct rooms so no corridor goes into the same room there's no like big loop that goes into the same room which is actually really nice for us no two quarters will connect the same pair of rooms which again is also very nice which means that there's not two pathways going from like room 1 to room 2 there's only one way to go from room 1 to room 2 now each room will have at least one corridor that connects to it so that's not really that important but essentially it means we don't have any floating rooms that are inaccessible that we can't get to or like we start in a room and there's no way to get out of it something like that okay so is essentially the way that it's saying to navigate through this maze is since the lights are out that's what like the problem is the lights are out in this maze what we're gonna do is we're gonna in our starting room place our right hand on one of the somewhere on the wall so since it's a circle obviously it's one wall but somewhere on that wall we'll place our right hand now determining where we where we put our right hand will take us in two different corridors so we could place our right hand like maybe near corridor one or corridor two and we'll just keep following that in a counterclockwise direction until eventually we end up back into our original room if you don't know this is a thing with mazes if you're ever stuck in a maze you put your hand on the right wall and you just follow that right wall until eventually you end up at the exit or what do you call it like back where you started or something like that I don't know how this works mathematically but it does but it is shouldn't be noted that this could take you a very long time and that's what this is asking for how long could it take us so that's how that kind of works so yeah now there's a bunch of input specifications and output specifications and whatnot I mean if you guys are going to attempt to solve this problem I assume you'll be able to figure out how these work by just reading through them so I'm not really gonna bother but what I'll do is quickly go through an example of how the steps that we should take to solve this talk about the algorithm I'm gonna use and then go into the solution I will note this is a very complicated problem if you're not in university I don't expect you to be able to solve this even for myself like we haven't learned how to do this in class I had to do a bit of a research to kind of figure out the best way to approach this and my solution is far from perfect I'll tell you that so what I'm gonna do is just load up a little drawing thing here and let's do an example starting room at one so essentially the input right it gives us a maze and our main look something like this so it's saying like one is connected to three three is connected to one two connects to five 5 to 4 4 to 6 2 to 4 that's what this our maze layout now note that this is the same maze I know that one like these are not connected in any way but that's perfectly fine you can have kind of floating components now let's say we start in room 1 what is the maximum amount of corridors we have to pass through before we get back to room 1 well we got to go so we'll pick up we'll put our hand on any place on the wall let's say we choose here ok and we're gonna go counterclockwise like this and keep our hand on that right wall so that'll mean it'll bring us to here and then we'll go to here and then we'll come back so we kind of went like that which means that we passed through this corridor not one but two times so the maximum amount of time is to get back to room one starting in room one is two now obviously this is very simple because there's only one room that can external one so obviously that would be the only way this works but say three branched out like this and three went into another room well if we put our hands here and we go and we go well we're on this right wall which means that we now have to go into here and then we go here and then we go back back back so it would take us what do you call it four steps to do this because we had to go through this corridor twice so two like that then we had to go through this corridor twice so it took us four steps to do that so just another example now down here let's say we start in room two well we're gonna place our Wolf's place our hands summer on the wall but here's the thing we can place our hand somewhere on kind of like this section of the wall or we could place it right here now do you know why this makes a difference where we place our hands like if we place it somewhere here or if we place it somewhere here why will this make a difference well let's think about this for a second if we decide to place our hand on the wall here where I'm making the red dot what we're gonna go counterclockwise rooms we're gonna go this way I'm going to follow this right wall so we're gonna do something that looks like this until we end back up in the room which means we've gone through one to three corridors and we ended back up in room number two now that's fine that works but let's contrast that if we put our hand here same process we put our hand here now we're gonna go counterclockwise what we're gonna do though is we're gonna follow this path right and now we're gonna go into six which we didn't go into before we're gonna come back up into five and loop back in to here now that is one two three because we had to go through this corridor first or twice right four five so as opposed to the first solution we got which was three now we have five which means five is the maximum to get back into this room starting in this room I mean I can show you examples for all the other ones but I think you guys probably get the point now this is actually a really simple example of the maze I know this might seem a bit confusing because you have like paths connecting like that but now imagine that this goes on and it looks something like this okay and then these are connected and then there's one connected here and then this one connects to this room and then that connects to this right like geometrically this doesn't have to make sense the maze that it gives you it just gives you connections right so I mean like let's say we start here we going to five well we could go back like that but if we come into five on this angle right so if we come from four to five and we keep our hand on that right wall now we're gonna go into here and then we're gonna go into this and then we're gonna go into this and then right wall we're gonna go here and then we gonna go here now we're in six and now we're back right wall and now we're back into five right and then we go into this again so that's not a possible solution right so like that is a somewhere that we can run into an issue so we're gonna go through the kind of my solution and how this works but let's quickly talk about something called a queue based algorithm which is what I'm gonna use to solve this problem now essentially what I want to do is I want to try every single path that I can because I need to find the maximum distance to get into this like Inc back into this room so for this room we'll just stick with example two what I did was I said well what are the neighbors of this room well the neighbors I'm saying are gonna be four and they're gonna be five now these are the two rooms that I could possibly these are my options right when I start in room two I can go into room five or I can go into room for those are the two options I have so what I'm gonna do is I'm gonna say okay so these are our options well we start in room two now we can go into room five or we can start in room two and we can go into room for those are my two options now let's think about this though okay let's go back there if I start in room two so now let's say I decided let's cross this one out let's say I decided to go into room five okay that's the one I picked well what are my options now let's think about it we have to determine how we came into room five to figure out what room we're gonna go into next because well let's think about this if I come in from this way and I'm on the right wall I need to go into room before right but if I came in from corridor for I would have to go into court or two right I'd have to go to room two so we have to determine how we came in to pick the next room we're gonna go to so what we'll do is we'll look at this and we'll say okay so we from room to room 5 so that corridor is located here right so what's the next corridor counterclockwise that's closest to us well that's this corridor as opposed to let's pretend there was another one here okay that went into a room like that okay so we need to go into this corridor so we say okay so we went into five now since we went into five and we use that specific corridor which was two to five well that means that now we'll change this and rather than going from two to five we're gonna go from two to five and then the next one we have to go to is four so we'll put four like that we continue this process so what we do now is we say okay well let's see here so now we've we've essentially the path we've done is we've done two to five and now we're back to for now from four where do we go well again it matters how we came in to four because there's three ways to get into four you can go in from six to or five so we came in from five so we're on this right wall right so now we have to look and find the corridor that's the most counterclockwise the closest counterclockwise to us that's gonna be this quarter which goes from four to two which means that now the next room we have to go into is to okay sweet so we've done this we've now the first one is the same as the last one which means that we've reached the original room and how long did it take us we'll one two three corridors right because I mean you just count the the connections between the rooms really calm okay so that's how that worked now that's one possible solution right so we've exhausted this we've created this and we said okay so this leads to to a value of three but what was the other solution that we decided not to determine or not to go on yet well that was two and four so let's try two and four now let's clear all this and let's do two and four well two and four is like this right so we go here and remember we're on this kind of outside wall like that alright so if we come into for now we came in from corridor two to four so what's the next room we have to go into well since we're on this right wall and we're following that that means we got to go into the next most counterclockwise thing which is six so now we go from four to room six now let's look at this so six let's find the most counterclockwise room corridor 2 for like from coming in on four well that's actually for itself and that work that works fine we can go through the same corridor twice because it only has one corridor connecting to it so that's kind of a case is if you go into a room and only as one corridor connecting into it and it's not the same room that we started in just go back the other way but that still counts as a traversal because that's what we had to do right so we go six and then we go back to four like that so now let's let's look at this right so now what our path looks like is we've gone from two to four into six and now we're back into four but this time when we come in four what side do we come in we don't come from two anymore we're coming from six which means that we go to the next most counterclockwise thing which is five and then we go in five okay so it's odd five here and then from five what do we do well most counterclockwise which is two so we go into two and then obviously well we found our solution and now it takes one two three four five to do that so that is our answer and that's how the solution works and what we do to kind of simulate this right is well we start with a few different paths we start with two five two four and then we extend out and just kind of follow and loop through the maze and then get a list of a certain size and once eventually we have the start and the end the same we've gone back into that room which means that we're done we found a solution we're good to go awesome all right so my solution I'm gonna show you now is it does exactly what I just showed you except in code form now it's a bit confusing obviously reading someone else's code is not that easy but I'm gonna try to walk you guys through it and show you exactly how it works so just stay tuned for one second okay so what I'm gonna do for you guys now is run my script and show you it working and point out some kind of the flaws and then why the solution is not amazing but works so essentially the solution that I'm about to show you is exactly what I talked about it works in the exact same way it follows that procedure now it uses what's known as a breadth first search algorithm which essentially is what I showed you just creating a bunch of different paths and then kind of finishing those paths using what's known as a queue now this is a queue based algorithm I'm not really gonna talk exactly but what that is I have a video on my channel that explains that I if you need to link to that let me know and I'll send one in the description or whatever but anyways these are all of the test files that we have so essentially you can see we have these in files and these out files now the in files obviously like the number in number out correspond to some sample input and the expected output now what I did is just wrote a nice script that automated this process of testing all the in files and out files on my solution and then determining how many I got correct how many took too long or how many I got wrong now since you can see that some of these files are quite large for example let's look at mais 18 or even let's look at this one may is 25 if I edit this um you can see that this goes on for a long time in fact we have two hundred thousand lines of input so simply even reading this input and alone takes a long time let alone processing the information so we have a hundred thousand rooms and then for every single one of those rooms we have to determine how long it's gonna take so you can imagine that like a slow solution which is something that I have will not really work for this because it takes so long so there's obviously something that could be improved for my solution and I want you guys to help me if you have a better solution please like show it to me comment it down below because I've been trying to find a way to optimize this and I can't figure it out yet so anyways that's kind of like some what the input looks like I'll show you an output file so you get an idea this is not the corresponding one but I output right like like that's what an expected output is so anyways let's run this and I'll show you kind of how this this works so I time all my solutions just to see how long they actually take and I can give so I can see if I'm improving them when I'm making modifications but the timeouts are I time out ever after half a second so essentially if it takes more than half a second to find the solution I just say timeout because I really don't wanna sit here for a long time like technically if I ran this for a day it would get all the solutions but I don't want to do that especially not for the video so anyways you can see here so there's 28 problems I got 11 correct 17 timed out zero we're incorrect well I mean if you consider the timed out ones no answer and then it just gives me kind of an outline of the pound sign means I got it correct tea means time out and then so you can see all the different ones so I just wrote the script that does this for me it's not really a part of the solution it just automates the testing so anyways let's get into the code now and talk about all this so this would I'm about to highlight is the automated tester so what it does is essentially just opens all the in files and the out files in the directory and then just calls the function run to get an answer for the given for given input and then based on that answer compares it to the expected answer and then it'll tell you if you got it correct incorrect keep track and then you know give you a nice little output at the end I think it's a really easy way to test your programs really quickly now the actual solution is down here now essentially right like I'll read through this but it is kind of complicated how it works uhhuh and you're gonna have to look at it on your own if you really want to understand it but essentially given some kind of input what we're gonna start by doing is we'll create a blank maze dictionary what this is gonna represent is kind of the data structure of our maze so it's gonna store a bunch of keys which are between 0 and the amount of rooms and each of those keys will be corresponding to a node now those nodes are what is here now this node simply is just an object that stores all of the neighbors of a given way codes like room so for example all the connections to that room that's what we're storing I mean I didn't really need to do this as a class but I just felt like doing it as a class and that's all it's storing here so that's how we kind of are storing things in here now when I get the input I got to split it up into the different parts which is obviously the the actual room layout and then the rooms that I need to be count doing calculations are doing the solution for so I do that I just get the time before we start running the solution so that I can see you know how long it took to do something then I'm converting each line of input into integers because I need everything an int and then just what do you call it setting up this data structure of the maze with the key I which is the room I and then all the given neighbors now this is the actual real solution that's kind of just setting things up and since we're gonna have to do a certain amount of queries which is like however many they asked us to do calculations for we need to do the solution for each room so I do this this is gonna be the current max value of the solution we're looking for it's essentially how long so far has it taken us to get back to the same room pretty straightforward now I used a cue just simply import it out from Python import cue really standard and then what I'm doing is I'm initially starting off by setting up the past that we could take now those paths right and that's what this for loops doing are the ones that I talked about before like starting in room we could go to room 4 we go to room 5 good room 7 right that's what we start off with there and then I add those into a queue and we constantly strip off one of the possible solutions from the queue and then just keep trying essentially is what we do so while the queue is not empty so while we haven't looked at every single possible solution we have keep trying now this is just responsible for the timeout it's simply saying if it takes more than half a second just just quit we're done this is gonna DQ which means get whatever solution we should be working on next so either adding to it checking if it's finished we're moving into a new room because each time we run this loop we for a given solution we go into like a different room that's that's how it works then we'll check based on whatever the current solution is we'll say well if the last element in that solution is equal to whatever room were in like the way that I showed you that means we've successfully gone back to our room so we'll check if this the length of that solution is greater than our current max if it is will simply say MX is equal to so our max the length of current otherwise what we do is we're gonna copy the solution and we're gonna add to it we're gonna add to it the next room we need to go into so what I'm doing here is simply just checking if there's only one neighbor we just need to go back into the previous room so that's what this if statement does but down here we're simply just gonna go to the next clockwise room and that's what all this is doing just making sure that we're going into them like the next room that's we should be going into and then I'm just checking here and saying you know what well if at this point we already gotten in this is meant to speed things up a bit if we've already reached that room that we to be in then just add one because well it would be one more solution to get in one more step to get in and then add that to the queue now I'm storing all these in the output and then we're simply returning at the end and this is how this solution works now again this is very slow because it's a queue based algorithm so there's a ton of different steps and it's running through like millions of times tons of operations you guys have a better solution this please don't hesitate to let me know really interesting problem if you're able to solve this give yourself a pat on the back because it is complicated and with that being said I'd love to hear you guys feedback on this I know this was a difficult problem but I want to give some of you more advanced people on something to look into and to challenge yourself with so that being said I guess I will wrap up the video here and I'll see you again in another one
