With timestamps:

00:03 - foreign
00:09 - [Music]
00:18 - with you how to build a platformer game
00:21 - in Python this game will have Pixel
00:23 - Perfect Collision it will have an
00:24 - animated character as you can see here
00:26 - it will have single and double jumping
00:28 - it will have all kinds of different
00:30 - animations for falling jumping colliding
00:33 - with obstacles for example you can see
00:35 - here when I hit the fire I kind of go
00:37 - into this hit State I will show you how
00:39 - to generate different objects how to
00:41 - scroll the background and really at the
00:43 - end of this video you will have a solid
00:45 - fundamental understanding of how to
00:46 - build a platformer game in Python and
00:49 - you can go and extend this and build
00:50 - really anything that you can think of I
00:53 - will even include a ton of free assets
00:54 - for you that allow you to change your
00:56 - character change the terrain change the
00:58 - background and do all of that extremely
01:00 - easily in fact in this tutorial alone I
01:03 - will show you how to use four different
01:04 - characters let me show you those
01:06 - characters before we continue so this is
01:08 - the second character here this is being
01:10 - referred to as mask dude this is the
01:12 - third character I'm calling this guy the
01:15 - ninja Frog as you can see and Final
01:17 - finally we have this character here
01:19 - which is called pink man now in this
01:21 - tutorial you will learn how to use all
01:23 - of these characters and you can swap
01:24 - them out with a single line of code with
01:27 - that said I hope you're excited this
01:28 - video has taken a very long time to
01:30 - prepare so please click the like button
01:32 - subscribe to the channel and we'll dive
01:34 - in after a quick word from our sponsor
01:36 - thanks to dice for sponsoring this video
01:39 - dice is the platform for go-getters like
01:41 - yourself to find your next job in Tech
01:43 - that aligns with your values and skill
01:45 - set on dice.com you can easily search
01:48 - and filter for jobs and set personalized
01:50 - alerts so you never miss a job
01:52 - opportunity start by creating your free
01:54 - profile setting up your job alerts and
01:57 - then going visible and connecting with
01:59 - employers immediately now Beyond Just
02:01 - Landing a job dice helps you gain
02:02 - insights into the tech industry and
02:04 - learn what skills and Technologies you
02:06 - need to master to get to the next level
02:08 - with dice.com you get access to
02:10 - countless articles free ebooks and a
02:13 - variety of other resources that help you
02:15 - understand things like what tech
02:16 - salaries you can expect effect job
02:18 - postings by volumes the number of jobs
02:21 - by occupation and a lot of other
02:23 - valuable information that helps you
02:25 - craft your career in Tech we all know
02:27 - that searching for a tech job can be
02:28 - difficult but with dice it doesn't have
02:30 - to be click the link in the description
02:32 - to start leveling up with dice today and
02:34 - don't forget to download their mobile
02:36 - app so you never miss a great job
02:38 - opportunity thanks again to dice for
02:40 - sponsoring this video alright so let's
02:42 - go ahead and get into it now since this
02:45 - is a long video I do want to spend a
02:46 - minute here just talking about who this
02:48 - video is designed for exactly what
02:50 - you're going to learn and what you can
02:52 - expect just so you don't waste your time
02:53 - if you don't want to go through it so
02:55 - this video is really designed for people
02:56 - that have a bit of experience with
02:58 - python ideally you are an intermediate
03:00 - python programmer you understand the
03:02 - syntax you know for Loops you know
03:04 - functions you know all of that if you
03:06 - don't feel free to follow along but I'm
03:08 - not going to be explaining those basic
03:09 - concepts now this video will teach you
03:12 - how to build exactly what you see here
03:13 - so by the end of the video you will have
03:15 - exactly this and if you're not
03:17 - interested in waiting until the end of
03:18 - the video then you can download the code
03:20 - from the GitHub repository that I will
03:22 - leave in the description that's also
03:24 - where all the assets are going to be so
03:25 - regardless you're going to have to
03:27 - download the code from GitHub again I
03:28 - will leave that in the description
03:29 - download that open up the folder and
03:33 - kind of we can start working from there
03:34 - now really what I'm going to be showing
03:36 - you here mostly is Sprite sheet
03:37 - animation uh Pixel Perfect Collision
03:40 - using what's called masks and then how
03:42 - you can do the scrolling background
03:44 - generating objects all of that kind of
03:46 - stuff that is really the hard part when
03:48 - it comes to generating a platform or
03:49 - game once you have all of that down it's
03:52 - very easy to extend this to add levels
03:54 - to add like you know a finishing flag to
03:57 - add coins to add you know lives you can
04:00 - turn this game into anything you want
04:01 - and that's how I've designed this so
04:03 - that you have the base and then you can
04:04 - go and make it kind of a full-fledged
04:06 - game and work off of that so with that
04:08 - said I will stop talking now I think
04:11 - this game looks really good I'm excited
04:12 - to share this with you guys so let's get
04:14 - into actually building it
04:18 - so right now I have Visual Studio code
04:21 - open obviously we're doing this in
04:23 - Python and I already have Pi game
04:25 - installed now the first thing we're
04:27 - going to have to do is install pygame
04:29 - which is the module we're going to be
04:30 - using so to do that go to your terminal
04:33 - and type pip install Pi game if that
04:36 - doesn't work for you you're going to try
04:37 - pip 3 install Pi game if that doesn't
04:40 - work try python
04:42 - hyphen M pip install Pi game if that
04:45 - doesn't work try Python 3 hyphadam pip
04:47 - install Pi game if none of those work I
04:49 - will leave two videos on the screen that
04:50 - show you how to install that module now
04:52 - once you have Pi game installed I'm
04:54 - going to assume that you've downloaded
04:56 - the GitHub repository go to GitHub
04:58 - there's a little button that says click
05:00 - to download download the folder extract
05:03 - it to your desktop and then open it in
05:05 - vs code or whatever editor you want so
05:07 - you have something that looks like this
05:08 - you should have an assets directory
05:10 - inside of assets you should have a bunch
05:12 - of different folders then you should
05:14 - have a main python file that contains
05:16 - all of the finished code now obviously
05:19 - we're going to write the code from
05:20 - scratch but you can either work off that
05:22 - existing code or you can kind of clear
05:23 - the file and type along with me whatever
05:25 - you want to do I quickly want to run you
05:27 - through the assets folder and then we'll
05:28 - get into the code so in assets we have a
05:30 - ton of stuff we're not going to use most
05:31 - of this but I wanted to include all of
05:33 - it so that you could kind of continue
05:35 - the game later if you want so we have
05:37 - for example backgrounds these are a
05:38 - bunch of background tiles so you can
05:40 - change kind of the theme or color
05:42 - background very easily I'll show you how
05:44 - to do that we have items like boxes
05:46 - checkpoints fruits Etc we're not going
05:49 - to use any of those then we have main
05:51 - characters for main characters we have a
05:53 - bunch of sprite sheets inside of here
05:55 - and I'll show you how we can split these
05:56 - Sprite sheets apart and use all of the
05:59 - different kind of animations inside of
06:00 - here right
06:01 - so we have that for Mass dude ninja frog
06:04 - Pinkman and virtual guy all of the file
06:06 - names are the exact same okay then we
06:09 - have menu we're not going to be using
06:10 - anything from there we have other we
06:12 - have terrain we are actually going to be
06:14 - using terrain specifically we're going
06:16 - to pull out this kind of block here but
06:18 - you could change the block again if you
06:19 - want to do that and then we have traps
06:21 - and we are going to be using the fire
06:23 - trap wherever that is right here that
06:26 - has kind of an animation right where the
06:28 - fire is going but again you can add all
06:30 - of this stuff later on I'll show you
06:32 - kind of the base on how to do it and
06:33 - then you'll be able to extend from there
06:35 - okay now that we understand the assets I
06:37 - apologize for such a long introduction
06:39 - let's get into writing the code I also
06:41 - need to plug the idea of a course
06:43 - programmingexpert.io if you guys want to
06:44 - get better at python check that out from
06:46 - the link in the description
06:50 - okay so let's start at the top of our
06:52 - program here by importing everything we
06:54 - need we're going to import OS we're
06:56 - going to import random we're going to
06:58 - import math we're going to import pygame
07:01 - we're going to say from OS import list
07:06 - directory
07:07 - and we're going to say from OS dot path
07:11 - import is file and join now the reason
07:14 - I'm doing all this OS stuff is because
07:17 - we are going to be dynamically loading
07:19 - all of the Sprite sheets and the images
07:21 - so we don't have to manually like type
07:23 - out the file names that we want I'll
07:25 - show you how we write a function that
07:26 - just loads these folders here kind of
07:29 - splits the Sprite sheets automatically
07:31 - and gives us all the images that we're
07:32 - interested in okay
07:34 - after we do that we're going to say
07:35 - pygame.net we need to initialize the pi
07:37 - gate module then we're going to go down
07:40 - here we're going to set a caption for
07:41 - our display I'm going to say Pi game dot
07:43 - display dot set underscore caption if
07:46 - you're unfamiliar with what this is
07:47 - doing this is setting the caption at the
07:49 - top of the window I'll try to explain
07:51 - most the pi game stuff as we go through
07:53 - the video I also have a ton of videos on
07:55 - Pi game on my channel if you want to
07:57 - check out something a little bit more
07:58 - basic okay now what I'm going to do is
08:00 - Define a few Global variables that we're
08:02 - going to be using here the first one is
08:04 - going to be the background color now
08:07 - we'll use this for now until we
08:08 - Implement our own background and for the
08:10 - background color I'm going to make this
08:12 - white which is going to be 255 255 255
08:15 - all of our colors in pi game are going
08:17 - to be in RGB okay so red green blue
08:20 - that's what we have for our background
08:21 - color we're then going to define the
08:23 - width and the height of our screen
08:25 - for some of you you're going to have to
08:27 - make this smaller if you're on a smaller
08:29 - display for me I'm on a 2K monitor so
08:31 - I'm going to go with a thousand by 800
08:33 - but if you're on again a smaller screen
08:35 - you might want to make this just a bit
08:37 - smaller so that it works for you
08:38 - although it doesn't really matter
08:40 - um make it whatever size you want next
08:42 - I'm going to say my FPS which is my
08:44 - frames per second is going to be equal
08:45 - to 60 and I'm going to Define my player
08:48 - velocity equal to 5 and this is going to
08:51 - be the speed at which my player moves
08:53 - around the screen
08:54 - okay now that we've done that we need to
08:56 - set up a pi game window
08:58 - so I'm going to say
09:00 - pygame.display.set underscore mode and
09:02 - then I'm going to pass the width and the
09:04 - height to this window argument here this
09:07 - mode argument and this is going to kind
09:09 - of create the pi game window for us
09:11 - I'm going to store that in the window
09:13 - variable and there we go we have kind of
09:15 - our Global variables created
09:17 - now I'm going to make a main function
09:20 - I'm going to say Define Main
09:22 - this main function is going to be what
09:24 - we run to kind of start the game
09:26 - so inside of here I'm going to take a
09:28 - window and at the bottom of my program
09:30 - I'm going to say if underscore
09:31 - underscore name underscore underscore is
09:33 - equal to underscore underscore Main
09:35 - underscore underscore then
09:38 - call the main function and pass the
09:40 - window argument
09:42 - okay so hopefully you can see kind of
09:43 - the structure of our program already the
09:45 - reason I have this line right here is so
09:47 - that we only call the main function if
09:49 - we run this file directly if we don't
09:52 - run this file directly say we imported
09:54 - something from it then we won't run the
09:56 - game code okay
09:57 - so that's why I have this inside of main
09:59 - is where we're going to write kind of
10:01 - our event Loop the event Loop will be
10:03 - what's handling say the Collision moving
10:05 - our character redrawing the window all
10:08 - of that kind of stuff this kind of good
10:09 - practice to have your event Loop in one
10:11 - place
10:12 - so inside of the main function we need
10:14 - to set up a few things the first thing
10:16 - we need is a clock so we're going to say
10:18 - clock is equal to Pi game dot time dot
10:21 - clock we also need to Define uh what is
10:24 - it a while loop that's going to
10:26 - continually Loop and act as our event
10:28 - Loop so I'm going to say run is equal to
10:30 - true
10:31 - I'm going to say while true or while run
10:33 - sorry and then the first thing I'm going
10:35 - to do is say clock.tick FPS now FPS
10:39 - members our variable right here what
10:41 - this line does is ensures that our while
10:43 - loop is going to run 60 frames per
10:46 - second okay so no more than 60 times per
10:48 - second that's what this ensures if
10:50 - you're on a really slow computer chances
10:52 - are you could be running less than 60
10:54 - frames per second but in my case I'm on
10:56 - quite a fast computer and if I didn't
10:57 - put this here then you'd see that my
10:59 - game would be like way faster than yours
11:01 - so we need to do this to regulate the
11:03 - frame rate across different devices okay
11:06 - now that we have that we're going to say
11:08 - four event in pygame dot event dot get
11:12 - and the first event that we're going to
11:15 - check for is if the user quits the game
11:16 - if they quit by quitting I mean they hit
11:18 - the red X in the top right hand corner
11:20 - then we need to stop the event Loop and
11:22 - exit our program so I'm going to say if
11:24 - event DOT type
11:26 - is equal to pygame dot quit then we're
11:31 - going to say run
11:33 - is equal to false and we can break out
11:36 - of this Loop
11:37 - then we can go down here and we can say
11:39 - hi game dot quit notice this is outside
11:41 - of the while loop
11:43 - and then we can put quit which will
11:45 - actually quit the Python program okay
11:47 - so now we have our basic event Loop and
11:50 - what should happen if I run the code now
11:52 - is a pi game window should pop up
11:53 - nothing should be on the screen and if I
11:55 - hit the red arrow it should close so
11:57 - let's try this and see what we get okay
11:59 - notice it says platformer and then I hit
12:01 - X and it closes perfect uh we're well on
12:04 - our way to creating the platformer game
12:08 - all right so now that we've done that I
12:11 - actually think that the first thing we
12:12 - can do is generate our background then
12:14 - once we have the background we can
12:15 - create a basic player that we can move
12:17 - around the screen and once we have that
12:19 - we'll start doing all of the animations
12:20 - and then later in the video once we've
12:22 - got uh kind of the bulk of the stuff
12:24 - done we'll handle the collision and all
12:26 - of the movements right
12:28 - okay so I need to make a function here
12:30 - and I'm going to call this get
12:31 - underscore background
12:33 - now before I dive into this let's have a
12:35 - look at our assets folder again now what
12:38 - I want to do is use these tiles right
12:40 - they're just tiles I believe their size
12:42 - is 64 by 64 or 32 by 32 something along
12:45 - those lines anyways we'll want to use
12:47 - these tiles and tile the whole
12:49 - background
12:50 - so what I need to do is essentially
12:52 - create a whole grid of these tiles based
12:56 - on the size of my screen so the way I'm
12:58 - going to do that is by using a folder
12:59 - here this folder is going to return to
13:02 - me sorry not this folder my bad this
13:04 - function this function is going to
13:05 - return to me a list that contains all of
13:08 - the background tiles that we need to
13:10 - draw so that's what we're going to do
13:11 - here with get background now what we
13:13 - want to take is the name
13:15 - sorry as I was saying the name is going
13:17 - to be the color of our background and
13:18 - that's going to allow us to change what
13:20 - background that we're using so the first
13:22 - thing we need to do here is load this
13:24 - background image now it's very important
13:26 - that when you run this file you run it
13:28 - from the directory that the file exists
13:31 - in now the reason I'm saying that right
13:33 - now is because the way I'm going to load
13:34 - this image relies on the fact that
13:37 - you're running this code from the
13:39 - directory that it exists in so see here
13:41 - that I'm in desktop python platformer
13:43 - and then notice tutorials inside of that
13:45 - directory that's why this is going to
13:47 - work if you try to run this code from a
13:49 - different directory say a CD to desktop
13:51 - and then I tried to run this then I'm
13:53 - going to get an issue so just make sure
13:54 - you're in the correct directory I just
13:56 - want to say that before we even get into
13:57 - this okay so I'm going to load my image
13:59 - I'm going to say image is equal to
14:01 - pygame dot image dot load
14:04 - and then what I'm going to do is join
14:07 - the assets path which is directly in the
14:10 - directory this file is in with the
14:12 - background uh path here if I spell
14:15 - background correctly and then with the
14:18 - name which is going to be the file name
14:19 - that I want to load which is really just
14:21 - the color of the background okay now
14:23 - that I have that I want to get the width
14:25 - and the height of this image so I'm not
14:26 - guessing what it is so I'm going to say
14:28 - underscore underscore with height is
14:31 - equal
14:32 - to image.get underscore rect now when
14:35 - you do this it will give you the X Y
14:38 - width height I don't care about the XY
14:40 - so I've just put two underscores here
14:42 - denoting that I don't care about these
14:43 - values and then I'm able to grab the
14:45 - width and the height so now that I have
14:47 - the width and the height
14:48 - I'm going to say tiles is equal to an
14:51 - empty list and then I'm going to Loop
14:53 - through
14:55 - um essentially how many tiles I need to
14:56 - create in the X and the Y Direction
14:59 - so I'm going to say 4i in range and then
15:03 - I'm going to take my width I'm going to
15:05 - integer divide this by the width of my
15:06 - tile and I'm going to add one and I'm
15:08 - going to do the same thing for my height
15:10 - here so I'm going to say 4J in range
15:12 - height over the height of my image Plus
15:15 - 1. okay so notice width here is the
15:18 - width of the screen height is the height
15:20 - of the screen I'm integer dividing this
15:22 - by the width of my tile and that tells
15:24 - me approximately how many tiles I need
15:26 - kind of in The X direction to fill the
15:28 - whole screen then just to make sure that
15:30 - I don't have any gaps I add one
15:33 - and I do the exact same thing for height
15:35 - in the y direction
15:37 - then what I'm going to do is say
15:39 - actually
15:40 - yeah I'm going to say rect uh is this
15:42 - wrecked no we're gonna say pause is
15:44 - equal to I multiply by the width and J
15:48 - multiplied by the height and this is
15:51 - going to denote the position of the top
15:53 - left hand corner of the current tile
15:55 - that I'm adding to this tiles list in pi
15:58 - game when you draw something on the
16:00 - screen you draw it from the top left
16:01 - hand corner so what I'll be doing is
16:03 - continually moving the positions based
16:06 - on how this for Loop is going right so
16:08 - for every eye for every J I'm
16:10 - multiplying it by the width and
16:11 - multiplying it by the height and that
16:13 - gives me the accurate positions I need
16:14 - to place every single tile in on the
16:16 - screen
16:17 - hopefully that makes a bit of sense but
16:19 - that's how this is working uh and then
16:21 - I'm going to say towels.append my
16:23 - position and then I'm going to return my
16:26 - tiles I'm also going to return the image
16:28 - so that I can know what image I need to
16:31 - use when I'm drawing all of these tiles
16:33 - okay now that I have my background I'm
16:35 - going to go into Main and I'm going to
16:37 - say my background is equal to get
16:40 - background and for the name I'm going to
16:42 - reference here in the background folder
16:44 - any of these images so we can use anyone
16:47 - we want it doesn't really matter I kind
16:48 - of like the blue one so I'll go with
16:50 - blue feel free to change this though on
16:52 - your end and
16:55 - there we go if I can type this correctly
16:57 - okay so I'm going to say background
16:58 - comma
17:00 - BG image like that
17:03 - and now I want to set up something
17:04 - that's going to draw my background so
17:06 - I'm going to make a function here and
17:08 - I'm going to say draw this is going to
17:10 - take in a window and for now it's going
17:12 - to take in a background and later it'll
17:13 - take in everything else we want to draw
17:15 - inside of here I'm going to say Pi game
17:18 - dot display
17:19 - dot update
17:21 - and before I do that I'm going to draw
17:23 - my background so I'm going to say
17:25 - 4 and this is going to be tile in
17:28 - background like that and then I'm going
17:31 - to say window
17:33 - dot blit
17:34 - and actually I need to take my BG image
17:36 - as well
17:38 - so let's take that
17:40 - and I'm going to draw the background
17:41 - image
17:43 - and then what I need to pass here is the
17:45 - position I want to draw it at which is
17:47 - going to be tile so what I can actually
17:50 - do is just convert this to a tuple
17:52 - notice the tile is going to be a list
17:54 - right tile is going to contain kind of
17:56 - my X Y position you can see that here
17:59 - right we're appending pause which is a
18:01 - list of x y and now that I think of it
18:03 - to make it easier let's just make this a
18:04 - tuple directly and now we don't need to
18:06 - convert it
18:08 - okay so in case anyone's confused what
18:10 - we're doing here is looping through
18:11 - every single tile that we have and then
18:13 - we're going to draw our background image
18:15 - at that position which will fill the
18:18 - entire screen with background images
18:19 - then what we're going to do is update
18:21 - the display the reason we update it so
18:23 - that every single frame we kind of clear
18:25 - the screen right and we don't have old
18:27 - drawings still on the screen you'll see
18:29 - what I mean in a second but this draw
18:31 - function is what we're going to do all
18:32 - of our drawing for now the only thing we
18:34 - need to draw is the background later it
18:36 - will be the player the blocks the
18:37 - obstacles Etc
18:39 - okay so now I'm gonna go inside of my
18:41 - wallet I'm going to call this draw
18:42 - function that we just created I'm going
18:45 - to pass window and then of course I'm
18:46 - going to pass my background and my BG
18:49 - image okay now this reminds me that I no
18:52 - longer need this background color we're
18:53 - not going to use that so I can get rid
18:54 - of that there
18:56 - okay so at this point assuming I've
18:58 - loaded the image correctly we're now
18:59 - going to see this tiling the entire
19:01 - screen so let's save and run and notice
19:04 - that we get it right it's tiling the
19:06 - entire screen looks pretty good to me
19:07 - and we can quite easily change this if
19:09 - we want by just going here and saying
19:11 - okay rather than blue I want yellow and
19:14 - then we say yellow and now we get a
19:16 - yellow background great so that's kind
19:18 - of the advantage of how I've done this
19:19 - here you can change the background to
19:21 - any color you want well given that it's
19:23 - in the background directory
19:27 - now that we have our background what
19:29 - should we do next well we probably want
19:31 - to put a player on the screen and start
19:33 - seeing some images for that player now
19:36 - the player itself is the most
19:37 - complicated aspect of this program
19:39 - there's a lot of movement going on with
19:40 - it so we'll start by just creating like
19:42 - a block for our player kind of move the
19:44 - block around have it jumping around then
19:46 - once we do that we'll do all of the
19:48 - Sprites and animations just so that we
19:50 - can get some more progress before we
19:52 - dive into that because it is a bit of
19:53 - work okay so let's go here and let's say
19:56 - class player
19:58 - we're going to use a class for our
19:59 - player kind of makes sense here and this
20:01 - class is going to inherit from pie game
20:04 - dot Sprite dot Sprite now I don't
20:07 - typically use Sprites when I'm working
20:09 - in pi game but I'm going to use them in
20:11 - this tutorial and the reason for that is
20:13 - that it makes it very easy to do Pixel
20:15 - Perfect Collision when we have two
20:18 - Sprite objects which we're going to have
20:19 - because we're inheriting from the pi
20:21 - game Sprite class we can use a method
20:23 - that tells us if these Sprites are
20:26 - colliding with each other so just
20:27 - understand that's why I'm doing this
20:29 - inheritance you don't have to understand
20:30 - exactly what the Sprite is but it kind
20:32 - of denotes that we have some properties
20:34 - on our class and then it allows these
20:36 - special Pi game methods to use those
20:38 - properties to handle the Collision for
20:40 - us so we don't have to write anything
20:41 - too complicated when it comes to the
20:43 - Collision although we still do need to
20:45 - handle it a bit okay so what we're going
20:47 - to do here is Define our initialization
20:49 - and we're going to take in a self an X Y
20:52 - width and height
20:54 - now the width and height will really be
20:56 - determined by the image that we're using
20:58 - for our player but for now since we're
21:01 - going to have like a block for our
21:02 - player until we add that image we're
21:04 - going to have a width and height now
21:05 - that reminds me that I just need to set
21:07 - a color for my player so I'm going to
21:09 - say color is 255.00 I'm making this a
21:12 - class variable just so it's the same for
21:15 - all of my players and I have access to
21:17 - it just right on the class
21:18 - okay now what I'm going to do is say
21:20 - self direct is equal to pygame.rect I'm
21:25 - going to pass my X Y width and height
21:28 - so rather than representing all of these
21:30 - values individually uh we're just going
21:32 - to put them on the rectangle and this is
21:35 - going to make it a little bit easier for
21:36 - us to kind of move the play around and
21:39 - do collision and all of that so erect
21:41 - really is just a tuple that's storing
21:43 - four individual values when I make it Pi
21:45 - game.rect it means we can use it in some
21:47 - kind of special equations and whatnot
21:50 - okay now for our player we're gonna have
21:52 - to have a few values uh the first thing
21:56 - we're going to have I'm getting a bit
21:57 - ahead of myself here but is going to be
21:59 - the x velocity and the next is going to
22:01 - be the Y velocity now the X and Y
22:04 - velocity is going to denote
22:07 - um what do you call it here
22:09 - how fast we are moving our player every
22:11 - single frame in both directions right so
22:15 - the way that we'll actually move our
22:16 - player
22:17 - is we'll just apply a velocity in a
22:19 - direction and then it'll just keep
22:21 - moving in that direction until we remove
22:23 - that velocity now this will be great for
22:25 - example for something like gravity or
22:27 - jumping
22:28 - um and you'll you'll see what I mean in
22:30 - a minute
22:30 - okay now that we have that we need to
22:34 - add something known as a mask for now
22:37 - I'm going to say the mask is equal to
22:39 - none and then I think that's all we need
22:43 - for right now so now that we have that
22:45 - let's add our first function here which
22:47 - is going to be the move function so move
22:49 - is going to take in a displacement in
22:51 - the X Direction and a displacement in
22:53 - the y direction and it's going to say
22:55 - the self.rec dot X plus equals the
22:58 - Direction X or displacement X sorry and
23:01 - self.rect.y
23:03 - plus equals the displacement y now if we
23:05 - want to move upward down or left or
23:07 - right we just change the sign of this DX
23:11 - or d y right
23:12 - okay so now we have a move next what we
23:16 - want to do is create two functions one
23:17 - for moving to the left
23:20 - and this is going to take in the
23:22 - velocity we want to move in the left
23:24 - Direction and the next is going to be
23:26 - moving in the right direction again this
23:29 - is going to take in self and Vel now to
23:32 - move left what we're going to do is say
23:34 - ourself.x velocity is equal to and then
23:38 - this is going to be negative velocity
23:39 - and then to move to the right we're
23:41 - going to say self.xfel is equal to Vel
23:44 - now the reason we use negative velocity
23:47 - here is because if we want to go left we
23:49 - have to subtract from our X position in
23:51 - pi game remember our coordinate system
23:53 - is that 0 0 is the top left hand corner
23:56 - of the screen so if I want to move down
23:58 - I add to my y-coordinate and if I want
24:01 - to move to the right I add to my x
24:03 - coordinate so if I want to go up I
24:05 - subtract y if I want to go left I
24:07 - subtract X so that's why I'm putting a
24:09 - negative Val here I know it seems a bit
24:11 - weird how I've just done move and now
24:12 - I'm saying move left we're going to have
24:14 - negative don't worry you'll see how this
24:15 - works in a second next I'm going to say
24:18 - if self dot Direct action does not equal
24:22 - left then self Dot
24:26 - Direction
24:27 - is equal to left and I'm going to say
24:30 - self.animation count is equal to zero
24:32 - now we're not going to use these right
24:34 - now but I just want to add them in
24:36 - um for now at least and you'll see why
24:38 - in a second now I'm also going to say
24:40 - appear yourself dot direction is equal
24:42 - to left and the reason I'm adding this
24:44 - direction is because I need to keep
24:46 - track of what direction my player is
24:48 - facing so later once I have my Sprites I
24:50 - know if I'm showing the animation to the
24:53 - left or I'm showing the animation to the
24:54 - right now the animation count uh we're
24:58 - resetting that when we change directions
24:59 - and the reason we're doing that is so
25:02 - that the animation doesn't look all
25:03 - wonky when we go from going left to
25:05 - right so we need to kind of reset the
25:07 - count that we're using to change the
25:09 - animation frames again you're going to
25:11 - see that later as we go through the
25:12 - tutorial now I've just added up here um
25:15 - self.animation count equals zero just to
25:17 - make sure we don't get any weird errors
25:18 - later so now I have my direction and my
25:20 - animation cap perfect
25:22 - okay now I'm going to copy this I'm
25:24 - going to put the same thing in move
25:25 - right and I'm going to change the
25:27 - direction here to say right
25:30 - and then right so now we know what
25:32 - direction we're facing at all points in
25:33 - time
25:34 - okay
25:35 - perfect next what we need to do is we
25:39 - need to have some kind of draw function
25:41 - and we also need to have what I'm going
25:42 - to call the loop function and in fact
25:44 - let's do the loop function first so I'm
25:46 - going to say Define Loop
25:48 - and inside of here I'm going to take in
25:52 - self and FPS now what Loop is going to
25:55 - do is be called once every frame when I
25:59 - say frame that's really one iteration of
26:00 - the while loop and this is going to move
26:03 - our character in the correct direction
26:04 - and handle things like updating the
26:07 - animation and all of the stuff that we
26:09 - constantly need to do for our character
26:11 - so for right now I only care about
26:14 - moving in the X Direction we'll handle
26:15 - the jumping later so what I'm going to
26:18 - do is just say self.move
26:20 - and I'm going to say
26:21 - that we're going to move based on our x
26:23 - velocity
26:25 - and our y velocity
26:28 - now notice we're updating our x velocity
26:30 - here when we move left or we move to the
26:32 - right so now if we call Loop and we have
26:34 - some velocity in the X Direction it's
26:35 - going to move our character to the left
26:37 - or to the right
26:38 - okay again all this will start to make
26:40 - sense as we get through the tutorial
26:42 - there is a lot of stuff I need to do
26:43 - kind of up front before I can just show
26:45 - you instantly so hopefully you guys are
26:47 - following along but I just want to note
26:49 - we eventually of course will see how all
26:51 - this works I'll walk through the code so
26:52 - no worries if it's a bit confusing right
26:54 - now now what else do we need to do
26:56 - inside of the loop well we need to
26:57 - update something known as The Mask which
26:59 - I'm going to get to in a second but
27:01 - before we can do that we need to Define
27:02 - uh what's known as our image so I'm
27:04 - going to say Define and this is going to
27:07 - be draw and this is going to be the
27:08 - function that handles drawing on the
27:10 - screen and for draw we are going to take
27:13 - in our window which I'll just represent
27:15 - with win now what we'll do for now is
27:18 - we'll just say Pi game
27:20 - dot draw dot rectangle we'll draw the
27:23 - rectangle on the window which is the
27:25 - first argument here it's where we're
27:26 - drawing it the second argument is the
27:28 - color which is going to be self.color
27:30 - then the last is the rectangle so I'm
27:33 - going to say that is self dot rect now
27:36 - notice the react here right has our XY
27:39 - width height and when we move we're
27:40 - updating the X and Y of the rectangle
27:42 - which will then change where we're
27:44 - drawing it if I can find it here on the
27:46 - screen
27:47 - okay so that's what we need for drum now
27:51 - actually for now I think that's okay
27:54 - uh we will add to this obviously in a
27:58 - second but I think we can generate a
27:59 - player draw the player see it moving and
28:02 - then go from there
28:03 - so let's do that so let's go to main
28:05 - here
28:06 - I'm going to create a player
28:08 - I'm going to say player is equal to
28:09 - player I need to pass an x a y and a
28:11 - width and a height so I'm going to pass
28:13 - let's say a hundred
28:16 - and let's make him 50 by 50.
28:18 - and then what we can do now
28:20 - is pass our player to the draw function
28:25 - we can then take player inside of here
28:28 - and we can say player don't draw and we
28:31 - can pass the window
28:33 - okay so I will move the player in one
28:34 - second but for now let's just see if
28:36 - this is working if it's going to show up
28:37 - on the screen so let's run the code
28:40 - and notice that now we have a red
28:41 - rectangle in the top left hand corner
28:43 - obviously nothing's happening right now
28:45 - because we're not moving it around the
28:46 - screen but you could see it's showing
28:51 - so we have our player we're drawing the
28:52 - player on the screen now we want to
28:54 - start using some of these methods Right
28:56 - Moving left moving right Etc so I want
28:59 - to separate my movement into a function
29:01 - so I'm going to say Define handle move
29:03 - like this and for this right now we'll
29:06 - just take in the player
29:08 - now inside of handle move what we're
29:10 - going to do is essentially check the
29:11 - keys that are being pressed on the
29:13 - keyboard if you're pressing left or
29:14 - you're pressing right then we'll move
29:16 - the character to the left or to the
29:17 - right eventually we will check for
29:19 - collision and we will do all of it so
29:21 - I'm going to say key is equal to pygame
29:23 - dot keys
29:26 - actually not keys.key DOT get underscore
29:28 - pressed this tells you all of the keys
29:30 - on the keyboard that are currently being
29:32 - pressed and I'm going to say if
29:34 - and actually this is going to be key
29:36 - really we should call this Keys though
29:39 - because this makes a bit more sense so
29:40 - we're going to say if keys and then this
29:43 - is pygame dot k underscore left this is
29:46 - the left Arrow key if you wanted to use
29:48 - the a key then you would use a like that
29:51 - uh yeah actually I'll go with left Arrow
29:53 - key because that's what I usually do but
29:55 - you can use a or swap it however you
29:57 - want and then I'm going to say if this
29:59 - is the case then player dot move
30:02 - underscore left and how much do I want
30:05 - to move the player bikes we have to pass
30:06 - the velocity well this is going to be my
30:08 - player velocity right
30:10 - okay next I'm going to say if keys and
30:13 - this is pygame dot k underscore right
30:16 - then I'm going to say player dot move
30:19 - underscore right
30:20 - again same thing I'm going to move this
30:22 - by my player velocity now it's important
30:25 - that before I do this I set my player
30:28 - velocity to be zero now the reason this
30:31 - is the case is because if I don't do
30:33 - this what will happen is as soon as I
30:35 - move left this is going to set my player
30:37 - velocity right which you can see here my
30:39 - X Val it's going to set the x velocity
30:42 - now once I set that I'm going to
30:44 - continue moving in that direction until
30:46 - it gets set back to zero so if you
30:49 - wanted to make it so when you press a
30:50 - key you just continually move in that
30:52 - direction until you press a different
30:53 - key then you could omit this but in our
30:56 - case we only want to move while you're
30:58 - holding down the key so I'm going to say
31:00 - player.xval equals zero there's a lot of
31:02 - other ways to go about doing this but I
31:04 - just wanted to stay consistent with our
31:05 - movement because of how we're going to
31:06 - do the gravity so for now just bear with
31:09 - me we essentially set the velocity to
31:11 - zero and then if we are moving left or
31:13 - right so if we're pressing these Keys
31:14 - then we change the velocity to be you
31:16 - know the negative player velocity or the
31:18 - positive player velocity based on the
31:20 - direction we're moving in
31:22 - okay that's actually all we need for
31:24 - handling the movement so let's put the
31:26 - handle movement function uh where are we
31:29 - going to put this we're going to put
31:30 - this before we draw
31:32 - so I'm going to say handle move I want
31:34 - to pass my player all right now I need
31:36 - to make sure before I do this that I
31:38 - call my Loop function okay and I pass my
31:42 - FPS and the reason I need to call Loop
31:45 - is because Loop is what actually moves
31:47 - my player right
31:48 - if you look at loop it's moving my
31:50 - player in the x velocity and Y velocity
31:53 - direction every single frame so if I set
31:56 - the x velocity well then I continue
31:57 - moving again if I set the Y velocity I
31:59 - move in that direction but that only
32:00 - works if we're continually calling this
32:02 - Loop function
32:04 - okay
32:05 - good so we've made great progress so far
32:07 - let's see now if we can move our player
32:09 - or if I've made any mistakes which are
32:11 - very likely so let's run the code
32:13 - and let's see okay so I'm going to hit
32:15 - my right arrow key you can see I can
32:16 - move to the right and I can move to the
32:18 - left obviously if I wanted to go up and
32:20 - down I could Implement that but we want
32:22 - to have it jumping
32:23 - which I will show you uh in a second but
32:26 - we kind of need Collision before we can
32:27 - do jumping
32:31 - very good all is looking great so far
32:34 - now let's Implement gravity so we kind
32:37 - of fall down then we can do uh kind of
32:40 - the Sprite sheets then we can do the
32:42 - Collision because the Collision makes
32:43 - more sense I guess once we have the uh
32:45 - the Sprite sheets done so let's
32:46 - Implement gravity now gravity is a
32:48 - little bit complicated because we want
32:50 - to have
32:52 - um like kind of a realistic gravity
32:54 - right that actually implements some
32:55 - basic physics what I mean by that is
32:57 - rather than just having a constant
32:58 - velocity we want to actually have an
33:01 - acceleration for our gravity so as many
33:03 - of you know if you're in physics gravity
33:06 - um the acceleration is negative 9.8
33:08 - meters per second squared I believe
33:09 - that's what the acceleration is anyway
33:11 - in our game we want to emulate something
33:13 - similar to that where it feels like the
33:15 - longer you're falling the faster you
33:17 - fall you're not falling at a constant
33:18 - speed that makes the game just feel like
33:20 - really really unrealistic so the first
33:22 - thing we need to do is pick some value
33:24 - that we want our gravity to be and this
33:27 - is the acceleration of gravity so keep
33:29 - that in mind
33:30 - so for this I'm going to make a variable
33:31 - in my player class because it's the only
33:33 - place we need it right now I'm going to
33:35 - say this equal to 1. so gravity is equal
33:37 - to one if you want gravity to be faster
33:39 - obviously you increment this value right
33:41 - make it large
33:43 - okay now inside of loop this is where we
33:46 - need to handle our gravity
33:48 - so every single frame in our loop we're
33:51 - going to increase the Y velocity by our
33:55 - gravity however how we know how much to
33:59 - increase the velocity by varies on how
34:03 - long we've been falling for
34:05 - again I know this seems really weird but
34:07 - we essentially need to keep track of how
34:09 - long we've been falling so that we know
34:11 - how quickly we should be increasing our
34:13 - velocity or how quick we should be
34:15 - accelerating downwards so that means
34:18 - that I need to create a variable here
34:19 - called self dot count and given we
34:23 - should really call this something better
34:24 - I'll call it fall count and this will um
34:27 - essentially tell us okay how long have
34:28 - we been in the air for how long have we
34:30 - been falling and we'll use this value to
34:32 - determine how much we um increment our
34:35 - velocity by so I'm now I'm going to say
34:37 - myself.w underscore velocity
34:40 - and I'm going to add to this the minimum
34:43 - of 1 or and I'm going to take my
34:46 - self.count and this is my fall count
34:49 - divided by the frames per second
34:52 - multiplied by the self.gravity now this
34:55 - isn't truly what the acceleration would
34:57 - be but this will give us like a kind of
35:00 - somewhat realistic looking gravity in
35:03 - the game so just bear with me here so
35:05 - what we're doing we're taking our fall
35:06 - count we're dividing it by FPS the point
35:08 - of this is that if I want this value to
35:10 - be in seconds then I need to take
35:12 - whatever my count is which I'm going to
35:13 - increment every single Loop in fact
35:15 - we'll do this right now
35:17 - plus equals 1 and I divide it by FPS so
35:20 - if my FPS is 60 as soon as this is 60
35:22 - then I've been falling for one second I
35:24 - take that amount of time I multiply it
35:26 - by my gravity and then that tells me how
35:29 - much I'm going to increment my y
35:30 - velocity by however this is going to
35:32 - start out being really really small just
35:34 - like fractional decimal decimal amounts
35:36 - so just to make this a bit easier for us
35:38 - when we do our Collision I'm going to
35:40 - increment this by the minimum of 1 or
35:42 - this value so every frame we're moving
35:44 - at least one pixel down and it doesn't
35:47 - take us like a full second before we
35:48 - really start feeling any effect of
35:50 - gravity
35:51 - hopefully uh that makes a bit of sense
35:53 - you guys are understanding me here but
35:54 - just bear with me I've uh experimented
35:56 - with these numbers quite a bit so I
35:57 - think this should be fine
35:59 - okay so now that we have this what
36:01 - should happen when I just click run here
36:03 - is I should just start falling
36:05 - immediately on the screen and obviously
36:06 - until we have some platforms or
36:08 - Collision we can't really stop falling
36:09 - if we have gravity uh but let's have a
36:12 - look and let's see how it works right
36:13 - now
36:15 - okay so you can see that I've fall and
36:17 - notice I'll do this again that I start
36:19 - falling slowly and then it picks up the
36:21 - pace right so this is somewhat realistic
36:23 - to how gravity would actually work and
36:25 - that's what I was trying to implement
36:26 - when I did this
36:30 - now that we have done that it's time to
36:33 - move on and have some kind of Sprites or
36:35 - images I was going to do this later but
36:37 - I realized that we can't really do the
36:38 - Collision which is going to be Pixel
36:40 - Perfect Collision until we have some
36:42 - kind of images that's that's really what
36:43 - we need we need our Sprites so what we
36:45 - need to do here first is examine what
36:48 - our Sprites look like for our characters
36:49 - now remember all these characters pretty
36:51 - much the exact same they just look
36:53 - different but in terms of their
36:54 - movements their animations number of
36:56 - images they're identical so whatever I
36:57 - show you for one of these is the same
36:59 - for all of them hence why we can just
37:00 - kind of swap them out so when I go to
37:02 - mask dude here let's zoom in you can see
37:04 - that we have for example double jumper I
37:06 - just picked a random Sprite sheet now
37:08 - this sheet has six different animations
37:10 - or six different frames which represent
37:12 - what this guy's going to look like while
37:14 - he's kind of jumping or double jumping
37:16 - in the air so what we need to do is we
37:18 - need to split this one image into the
37:22 - six individual images and then Loop
37:24 - through those images at some frequency
37:26 - or some time so that we can show them on
37:28 - the screen and show in an animation
37:30 - right we need to kind of manually do
37:32 - this now some of these are single frames
37:34 - like falling is just single frame that's
37:35 - easy
37:36 - hit okay this is um like you know the
37:39 - guy disappears for a second kind of
37:41 - expands goes back
37:43 - you get the point where you want to Loop
37:45 - through these animations idle single
37:47 - frame actually no idle is not a single
37:48 - frame it's a bunch of frames this guy's
37:50 - arms are kind of wagging up and down we
37:52 - have jump a single frame run a bunch of
37:54 - frames and then wall jump now
37:57 - notice here with these images that
38:00 - they're in different directions or let's
38:03 - say they're all kind of facing right so
38:06 - another thing we're going to have to do
38:07 - is rotate this image to face left when
38:11 - our character is facing left so that's
38:13 - another thing we have to handle that not
38:14 - only do we just have to split these
38:15 - images up we also have to get a rotated
38:18 - version of them so that we can show you
38:20 - moving in a different direction same
38:22 - with jumping same with being idle like
38:24 - whatever Direction you're going we need
38:25 - to show the image flipped in that
38:27 - direction
38:28 - uh so not rotate sorry flip that's what
38:30 - we're gonna do okay
38:32 - so let's do this first thing I will do
38:35 - actually is I'll write the function that
38:37 - will flip our image
38:39 - so I'm going to say flip Sprites this is
38:42 - going to take in a list of Sprites
38:44 - and I'm going to return
38:46 - High game
38:47 - dot transform dot flip and this is going
38:50 - to be Sprite true false notice as it
38:54 - says here this is indicating what
38:56 - directions you want to flip in when I
38:58 - pass true this means flip in the X
39:00 - Direction when I pass false this means
39:01 - don't flip in the y direction if you
39:03 - want to flip both you'd pass true twice
39:06 - but we don't want to do that so I have
39:08 - Pi game.transform.flip Sprite and then
39:10 - this is going to be four
39:12 - Sprite in Sprites really I could call
39:15 - this image but you get the point okay so
39:18 - we have flip now we're going to write a
39:20 - function which is load Sprite
39:23 - sheets and
39:26 - should we call it sheet or sheets I
39:27 - think sheets is fine and what this is
39:29 - going to do is load all of the different
39:31 - Sprite sheets for our character so it's
39:33 - going to give us the spreadsheet for
39:34 - double jumping for hitting for falling
39:36 - and then within our character we can
39:38 - pick what sheet we want to be using and
39:40 - what animations we want to Loop through
39:43 - so I'm going to take in directory 1 and
39:44 - directory 2 and the reason I'm doing
39:46 - this is so that I can load other images
39:49 - that aren't just my characters and this
39:51 - will be very dynamic I also want to take
39:53 - in the desired width and height of my
39:55 - image
39:56 - and if we need to load multiple
39:59 - directions so I'm going to say Direction
40:01 - equals false as a default parameter so
40:03 - that we only load like the left and the
40:06 - right side images like we flipped the
40:07 - images if you pass this equal to true
40:10 - okay now the first thing we need to do
40:12 - is determine the path to the images
40:14 - we're going to be loading so I'm going
40:15 - to say join assets der one dir 2. notice
40:20 - I can use join because I imported this
40:22 - from os.path okay
40:24 - now I'm gonna get all of the images in
40:27 - this directory now the way I do that is
40:29 - a phone I'm going to say images is equal
40:30 - to and this is going to be f for f in
40:34 - list directory again notice I can use
40:36 - that because I import it here we're
40:38 - going to list all of these things that
40:40 - are inside of this path directory and
40:43 - then we're going to say if
40:45 - is file and then this is going to be
40:47 - join path
40:49 - and F
40:51 - so what this for Loop is going to do
40:53 - here this uh I forget what you actually
40:55 - call this when you write a for Loop in a
40:56 - list anyways what this line is going to
40:58 - do here is load every single file only
41:01 - file that is inside of this directory so
41:05 - again we're just going to get every
41:06 - single one of these file names and then
41:08 - once we have those file names we can
41:09 - load that image and we can then split
41:11 - that image up into the individual images
41:13 - that we want
41:15 - okay so we have images now I'm going to
41:17 - say
41:18 - all Sprites is equal to a dictionary and
41:20 - what I'm going to do with this
41:21 - dictionary is have key value pairs where
41:23 - the key is the let's say animation style
41:26 - and the values all of the images in that
41:29 - animation
41:30 - okay so I have all Sprites and I'm going
41:32 - to say for image in images
41:35 - and I'm going to say that my Sprite
41:37 - sheet so the individual Sprite sheet I
41:39 - want to load here is going to be equal
41:40 - to pygame dot image dot load and then
41:45 - this is going to be join
41:47 - path and image and then dot convert
41:51 - Alpha which is essentially going to
41:52 - allow me to load a transparent
41:54 - background image okay so we are loading
41:57 - the image which is just one of the files
42:00 - that we found right from this path and
42:03 - we just need to append the path to it
42:05 - right
42:05 - so whatever the path to the directory is
42:07 - plus the image name
42:09 - okay we're going to load that in we're
42:10 - going to get the transparent background
42:11 - now that we have this we need to get all
42:13 - of the Sprites in this image
42:16 - so I'm going to say Sprites is equal to
42:18 - and now this is going to be a list okay
42:21 - so again the processes load all of the
42:23 - different files
42:25 - okay we have all the files these are
42:26 - sprite sheets now we need to get all the
42:27 - individual images from the Sprite sheet
42:29 - and load those okay so I'm going to say
42:32 - 4i in range and then this is going to be
42:35 - Sprite sheet dot get underscore with
42:39 - integer divided by the width of the
42:42 - image that we're loading now width is
42:45 - going to be the width of an individual
42:47 - image inside of our animation or inside
42:49 - of our Sprite sheet so if I know this is
42:51 - say 32 pixels I pass 32 and then it
42:55 - gives me a bunch of images that are 32
42:57 - pixels wide that's how I'm doing the
42:59 - loading so that's why I took width and
43:00 - height here okay
43:02 - now that we have that
43:03 - we're going to say surface
43:05 - is equal to
43:07 - High game
43:09 - dot surface and then this is going to be
43:12 - with
43:14 - height
43:15 - we're going to pass Pi game dot s r c
43:19 - Alpha which allows us to load again
43:21 - transparent images and then I'm going to
43:23 - pass 32 here which is the depth don't
43:26 - worry about that but this is what we
43:28 - need to load these images and now we
43:30 - need to create a rectangle which is
43:32 - going to tell us where in this image
43:35 - again image being the Sprite sheet that
43:36 - we want to take an individual image from
43:39 - and BLT it onto this surface I know this
43:42 - seems really weird what we're doing is
43:43 - we're going to create a surface that's
43:45 - the size of our desired individual
43:47 - animation frame we're then going to grab
43:49 - that animation frame from our main main
43:51 - image we're going to draw it onto the
43:53 - surface and then we're going to kind of
43:55 - export that surface that's the way that
43:57 - we have to do this so I'm going to say
43:59 - rectangle is equal to Pi game
44:02 - Dot rect and for the rect this is the
44:06 - location on our original image that we
44:08 - want to grab this new frame from so I'm
44:10 - going to say this is I multiplied by my
44:12 - width and then 0 and then the width and
44:16 - the height of my image
44:17 - okay now that I have that I'm going to
44:19 - say surface.blit blit really means draw
44:22 - and I'm going to draw my Sprite sheet
44:25 - but I'm going to draw this at 0 0 and
44:28 - I'm only going to draw the portion of it
44:30 - which is my rectangle so notice this is
44:32 - my source this is the destination and
44:35 - this is the area of my source that I'm
44:37 - drawing so in position 0 0 which is the
44:40 - top left hand corner of my new Surface I
44:43 - am drawing my Sprite sheet but I'm only
44:45 - drawing the frame from my Sprite sheet
44:47 - that I want
44:48 - okay then I'm going to say Sprite start
44:50 - append and I'm going to append my
44:53 - Surface but I'm going to make my Surface
44:55 - Two Times larger because that's what I
44:57 - want to do I want this to be bigger than
44:58 - the default size so I'm going to say Pi
45:00 - game Dot
45:02 - transform dot scale to X and then I'm
45:06 - going to scale to X my Surface
45:08 - okay
45:10 - again I know this seems a bit
45:11 - complicated but now we have essentially
45:14 - stripped out all the individual frames
45:16 - we've just scaled them up to be double
45:18 - their size so if they're 32 by 32 we've
45:20 - made them 64 by 64 that's what scale 2x
45:23 - does and now we need to handle the
45:25 - directions
45:26 - okay so now we need to say
45:30 - if Direction then all underscore Sprites
45:35 - and this is going to be image
45:37 - dot replace it's going to be dot PNG
45:40 - this is going to be an empty string plus
45:43 - underscore right is equal to our Sprites
45:47 - and then we're going to copy the same
45:49 - thing
45:50 - let's copy this and put it here and now
45:52 - this is going to be underscore left is
45:55 - equal to
45:56 - and this is going to be flip
45:59 - Sprites
46:01 - so what we're saying here is if you want
46:03 - a multi-directional animation then we
46:06 - need to add two keys to our dictionary
46:07 - here for every single one of our
46:09 - animations so for falling for hit for
46:11 - idle we need a left and a right side so
46:14 - the right side is the one that we
46:15 - already have so we're going to say okay
46:16 - all Sprite at and then we're just going
46:19 - to strip off the dot PNG from whatever
46:21 - the name of our base image was so that's
46:23 - going to give us run jump idle hit
46:25 - whatever the name of our files and then
46:26 - we're going to append underscore write
46:28 - or underscore left now for underscore
46:30 - right that's our basic Sprites for
46:32 - underscore left we need to flip all of
46:34 - those Sprites and we already wrote the
46:35 - function that did that now otherwise
46:38 - then what we'll do is say all underscore
46:42 - Sprites at image dot replace
46:45 - dot PNG
46:47 - with an empty string this just removes
46:49 - the dot PNG
46:50 - and then it's going to be equal
46:52 - two Sprites
46:53 - okay then we can return
46:57 - all of our Sprites
46:59 - all right probably one of the most
47:01 - complicated aspects of the code that we
47:03 - need to write so don't worry we are done
47:05 - now with loading images at least we'll
47:07 - have to load our block but that's going
47:09 - to be a lot easier than loading our
47:10 - Sprite sheets so this now will load a
47:13 - Sprite shoot for us now that we've
47:15 - loaded our Sprite sheet we actually want
47:16 - to start using this so inside of player
47:19 - we are going to grab our images so I'm
47:22 - going to say my Sprites is equal to and
47:26 - it's going to be load Sprite sheets and
47:28 - now I need to pass what I want to load
47:29 - so now I need to pass the main character
47:33 - directory and actually this is the main
47:35 - characters
47:37 - okay so have a look here so inside of
47:40 - assets right uh yes so we're joining
47:42 - assets with dur1 and dirt 2. so the
47:44 - first directory I pass is main
47:46 - characters and then I pass the second
47:47 - directory which is the name of the
47:49 - character I want to load so mask dude
47:51 - ninja frog pink men or virtual guy you
47:54 - can pick whatever one you want I'm gonna
47:56 - go with mask dude for now now for width
47:59 - and height uh the width and the height
48:00 - of this is going to be 32. so make sure
48:02 - you do this 3232 and then you pass true
48:05 - because we want a multi-directional
48:07 - Sprite so both the left and right side
48:09 - animations that's what we want okay
48:12 - now that we have that we are going to
48:14 - change our draw here so that we're
48:16 - drawing our Sprite now for for now we're
48:19 - just going to draw like one simple
48:21 - Sprite just so you see how it looks on
48:22 - the screen then I'll go through
48:24 - animating the Sprite and showing you how
48:25 - that works
48:26 - okay so rather than pygame.draw.rect I'm
48:29 - going to say self.sprite is equal to and
48:33 - then this is going to be self dot
48:35 - Sprites at idle now idle is one of the
48:40 - name of our animations right so if we go
48:41 - here you can see we have idle jump Etc
48:43 - so I'm accessing the key from my
48:45 - dictionary and then I'm going to access
48:47 - the first frame of this key which is
48:49 - zero because every single key is a whole
48:51 - like Sprite sheet right so now that I
48:53 - have my Sprite
48:54 - I'm going to say window blit and then
48:56 - this is going to be self.sprite and I'm
48:58 - going to blip this at self.rec dot X and
49:02 - self.rec.y which is the position on the
49:04 - screen and then if we want we can just
49:06 - turn off the gravity for right now so we
49:08 - can kind of see it on the screen it
49:10 - doesn't just disappear okay let's try
49:12 - this out let's just make sure it
49:13 - actually loaded correctly so let me run
49:15 - this and we got an error okay so let me
49:17 - see what error we got here
49:20 - um
49:20 - run this again
49:23 - it said key key error idle okay so the
49:26 - issue here is that since we load a
49:28 - directional Sprite we need to reference
49:30 - either idle right or idle left so we can
49:33 - actually do this by saying idle
49:34 - underscore Plus
49:36 - self
49:37 - dot Direction and then so long as we set
49:39 - the direction which we did here to left
49:41 - uh this should work so now it'll change
49:43 - based on if we're going left or right so
49:45 - actually you'll see that it should swap
49:46 - as we change directions okay let's try
49:48 - this now
49:50 - all right so now we have this guy facing
49:52 - left if I go right
49:54 - he turns right left right perfect now we
49:58 - want to see him animated
50:02 - so as I was saying let's get into the
50:04 - animation now this is actually going to
50:07 - be pretty easy because we've already
50:08 - loaded in all of the frames that we need
50:11 - so I know that we don't have a ton to
50:12 - show right now but a lot of the hard
50:13 - stuff is done for this video so just
50:16 - making you aware that all this time has
50:17 - not gone to waste what we need to do is
50:20 - we need to come up with something that
50:22 - has a way to kind of update our Sprite
50:24 - or update what we're showing on the
50:26 - screen so I'm going to write a function
50:27 - here called update
50:30 - Sprite
50:31 - and I'm going to take in self
50:34 - and I'm going to say Sprite sheet
50:36 - is equal to idle now this is the default
50:40 - spreadsheet if we're not moving if we're
50:42 - not jumping if we're not falling if
50:43 - we're not being attacked we use idle
50:46 - however if we are running or we're doing
50:48 - something else then we use the other
50:49 - spreadsheet so now I'm going to say if
50:51 - myself dot x velocity does not equal
50:54 - zero
50:56 - then my Sprite sheet is going to be
50:59 - equal to run so if I have some velocity
51:01 - in the X Direction then I'm running
51:03 - right so then I want to change this to
51:05 - the Run spreadsheet so now I'm going to
51:07 - say my Sprite sheet name
51:09 - is equal to and this is going to be my
51:13 - Sprite sheet plus and then underscore
51:17 - and then plus the self dot Direction
51:21 - perfect so now we just change the main
51:23 - Sprite sheet name so idle run jump
51:25 - whatever we add the direction to it and
51:27 - this tells us you know what exact Sprite
51:30 - shoot we want
51:31 - okay now that we have that what we're
51:33 - going to do is say these Sprites that we
51:35 - could be using for this animation is
51:37 - equal to self.sprites and this is in all
51:40 - capitals at the Sprite sheet name all
51:44 - right now that we've done that we need
51:46 - to essentially iterate through these
51:48 - Sprites and every few seconds change the
51:51 - Sprite that we're showing so it looks
51:52 - like we're animating so we need to add a
51:54 - variable here that is going to account
51:56 - for the amount of delay between changing
51:58 - Sprites so I'm going to call this the
52:01 - animation delay I'm going to make this
52:04 - equal to five okay now I'm going to come
52:07 - here and I'm going to say that my Sprite
52:10 - index which essentially a Sprite that I
52:12 - want to be using here is equal to my
52:14 - self.animation count which we're going
52:16 - to increment in a second integer divided
52:19 - by my self.animation delay
52:22 - modulus by the length of these Sprites
52:26 - that I'm using now let's just put
52:28 - some parentheses here for order of
52:29 - operations
52:31 - and let me explain what we're doing so
52:33 - we have an animation delay that's every
52:35 - five frames so every five frames we want
52:37 - to show a different Sprite in whatever
52:39 - animation we're using so if we're
52:41 - running left if we're idle whatever it
52:42 - doesn't matter we want to show a
52:43 - different one so we take the animation
52:46 - count we divide it by five and then we
52:48 - mod whatever the line of our Sprites is
52:50 - so if we have five Sprites then when
52:52 - we're on say animation count 10 we're
52:54 - showing the second Sprite right you get
52:56 - the idea so this is dynamic this will
52:58 - now work for any single Sprite so
53:01 - hopefully you guys understand how this
53:02 - animation count is kind of working but
53:04 - we're just trying to pick a new index
53:06 - every animation frames from our uh
53:09 - Sprites but we want this to be dynamic
53:11 - so we're using the length of the Sprites
53:12 - and again it's just it's dynamical work
53:14 - for any single Sprite sheet we have now
53:17 - we need to select our Sprites we say
53:19 - self.sprite is equal to the Sprites that
53:22 - we have access to at the Sprite index
53:24 - then we update our animation count by
53:26 - one
53:27 - now what we can do is remove this here
53:30 - from draw and we just need to Now call
53:33 - the self Dot
53:35 - update sprite from our Loop okay so now
53:39 - that we've done that we'll call this
53:40 - we'll update our Sprite every single
53:43 - frame and then we'll draw that updated
53:45 - Sprite on the screen
53:47 - okay let's run it and let's see what we
53:49 - get
53:50 - notice we have idle notice I can run to
53:53 - the right and I can run to the left now
53:56 - if you think this is too slow and some
53:58 - of you may argue that it is then you
53:59 - just make this number smaller so make
54:01 - this three
54:04 - okay and now it looks like we're running
54:06 - a little bit faster so it's completely
54:07 - up to you how you want to animate this
54:09 - um I'll do two for now and let's see if
54:12 - this looks better
54:14 - so actually I think three was a pretty
54:16 - kind of happy medium here so let's go
54:18 - back to three again you guys can change
54:20 - this is up to you how you want it to
54:21 - look okay now that we have that
54:23 - we're almost ready to start doing
54:25 - Collision however we need to introduce
54:27 - something known as a mask so I'm going
54:30 - to make another method here I'm going to
54:32 - say Define update
54:34 - now what we need to do here is
54:37 - essentially update the rectangle that
54:39 - bounds our character based on the Sprite
54:42 - that we're showing so there's different
54:45 - um like kind of sizes to the Sprites
54:47 - right some are a little bit taller some
54:48 - are a little push to the left or pushed
54:50 - to the right and the rectangle that we
54:52 - have we want to be essentially the same
54:54 - as the Sprite that we have again I know
54:58 - this seems a bit weird but we're going
55:00 - to do this we're going to say self.rect
55:02 - is equal to self Dot and then it's going
55:05 - to be Sprite dot get underscore rect and
55:08 - we're going to say that the top left of
55:10 - this rectangle is equal to the
55:13 - self.rect dot X
55:16 - and the self.rec dot y
55:18 - now pretty much what's going to happen
55:20 - here is depending on what Sprite image
55:22 - we have if it's slightly smaller
55:24 - slightly bigger whatever we're going to
55:25 - constantly adjust the rectangle
55:27 - specifically we're going to adjust the
55:29 - width and the height of it but we're
55:30 - going to use the same X and Y position
55:32 - that we've had for this rectangle if you
55:35 - don't understand that
55:36 - um it's fine it's not a massive deal
55:37 - this line is not crazy important but
55:39 - it's just trying to make sure that the
55:41 - rectangle we're using to kind of bound
55:42 - our character is constantly adjusted
55:44 - based on the Sprite that we're using now
55:46 - what's more important is this line which
55:48 - is updating the mask we're going to say
55:50 - self.mask is equal to pygame dot mask
55:53 - Dot from surface and this is going to be
55:56 - self dot Sprite
55:59 - now let me quickly explain this a mask
56:01 - is essentially a mapping of all of the
56:04 - pixels that exist in the Sprite so
56:06 - whenever we draw something on the screen
56:07 - we're really drawing a rectangle right
56:09 - but the rectangle may not have
56:13 - um non-transparent pixels right so only
56:15 - part of the rectangle is actually filled
56:17 - in hence why we get kind of a circular
56:19 - image a dynamic image whatever so what
56:21 - this mask tells us is where there's
56:23 - actually images or where's this actually
56:25 - pixels sorry and this mask allows us to
56:28 - perform Pixel Perfect Collision because
56:30 - we can overlap it with another mask and
56:33 - make sure that we only say two objects
56:35 - Collide if pixels are colliding not if
56:37 - the rectangular box is colliding if we
56:40 - did rectangular Collision then it
56:42 - constantly looks like we're hitting
56:43 - something even when we're not because
56:45 - the rectangle for our character is
56:47 - larger than where all of the pixels for
56:49 - our character are you've probably seen
56:51 - this in a lot of games before but what
56:53 - the mask does is solve that problem for
56:54 - us and allow us to do this kind of Pixel
56:57 - Perfect Collision it's very important
56:58 - though that you you call this mask if
57:00 - you don't do that this Collision is not
57:02 - going to work properly it needs to be
57:04 - masked because the Sprite that we
57:06 - inherited from here uses this rectangle
57:09 - and uses this mask property when it does
57:12 - the Collision all right so now that
57:14 - we've done this I just need to call this
57:15 - function so I'm going to go here and say
57:17 - self dot update and now we're done with
57:21 - most of what we need for the player
57:26 - so what we want to do now is we want to
57:28 - start adding blocks onto the screen and
57:30 - then letting a player fall collide with
57:32 - those blocks and then be able to jump
57:33 - because obviously we can't really jump
57:35 - until we have something to jump off of
57:37 - otherwise jumping in thin air doesn't
57:39 - make a ton of sense alright so let's
57:42 - create another class here and this class
57:45 - I'm going to call object and this will
57:48 - be a base class that we use for
57:50 - essentially all of our objects just so
57:52 - that the Collision will be uniform
57:53 - across all of them so again we're going
57:55 - to inherit from the Sprite class from PI
57:57 - game and we're going to Define our
57:59 - initialization so to find a knit we're
58:02 - going to take in self X Y width and
58:06 - height and name which for now is going
58:08 - to be equal to none but could be equal
58:10 - to something we're then going to say
58:12 - super dot underscore underscore knit
58:15 - which will initialize the superclass
58:18 - which is this one right here now that
58:20 - reminds me we need this as well in our
58:22 - Constructor for player so let's put that
58:25 - in player
58:26 - okay now we need to define a rectangle
58:29 - so we're going to say self-directangle
58:31 - is equal to Pi game
58:33 - Dot rect
58:36 - and then this is going to be x y
58:38 - width and height
58:41 - we're going to say self.image is equal
58:44 - to Pi game
58:47 - dot surface and then this is going to be
58:50 - width
58:51 - height and then we're going to say Pi
58:54 - game
58:54 - dot source
58:56 - Alpha like that if we spell Pi game
58:59 - correctly again this just supports
59:01 - transport transparent images for us my
59:03 - apologies and then we're going to say
59:06 - self dot width equals width
59:10 - self.height
59:12 - is equal to height and self dot name
59:17 - is equal to name
59:18 - where are they going to say Define draw
59:22 - I'm going to say self and window like
59:25 - this and then we're going to say win
59:28 - dot blit
59:30 - and this is going to be self.image
59:33 - and then we're going to blip this at the
59:35 - self Direct
59:37 - dot X and the self.rect.y
59:41 - okay I know I went fast essentially this
59:44 - is just a base class we're not actually
59:46 - going to instantiate this but this just
59:48 - defines all the properties that we need
59:49 - for a valid Sprite so we have a
59:52 - rectangle we have our image we are
59:55 - drawing the image and then in a class
59:57 - that we're about to use we're going to
59:58 - inherit from this and it will just save
60:00 - us from rewriting a bunch of
60:01 - functionality that we don't need so the
60:03 - idea here is that
60:05 - all we do is modify this image when we
60:07 - change the image now the draw function
60:09 - will automatically draw it accurately on
60:10 - the screen for us and all these other
60:13 - properties we're just saving in case we
60:14 - need them from our child class so I'm
60:17 - going to make a class now called block
60:18 - this is going to inherit from object
60:22 - now we're going to say Define
60:24 - a net and we're going to take in self x
60:27 - y and the size of our block now since
60:29 - the block is a square we just need one
60:31 - dimension not two right
60:33 - okay we're going to say super
60:35 - dot underscore underscore knit
60:37 - and we're going to pass x y
60:40 - size size so notice this Constructor
60:42 - requires four arguments so we have to
60:44 - pass four here we just duplicate size
60:46 - because it's the same for the width and
60:48 - the height then we're going to say block
60:50 - is equal to load block which is going to
60:52 - be a function that we write in a second
60:54 - that will take a size we're then going
60:57 - to say self dot image dot blit
61:00 - imagine that this is going to give us an
61:02 - image okay which it will in a second
61:03 - when we write it we're going to blit the
61:05 - block
61:06 - at position zero zero and then we're
61:09 - going to say the self.mask is equal to
61:12 - High game
61:13 - dot mask Dot from surface we're going to
61:16 - take our self.image and there you go we
61:20 - have our mask which we need for
61:21 - Collision
61:23 - again I know this is a little confusing
61:25 - it'll make more sense in a second but
61:27 - we're using this object which now has
61:28 - this draw function built in for us it
61:30 - also defines the rack that defines the
61:32 - width and the height and all of that
61:33 - stuff here what we do is we get the
61:35 - image that we need which we're going to
61:37 - write this in one second then we BLT
61:40 - this image to our image which is a pi
61:42 - game surface and then we say self.maski
61:45 - we'll do pygame.mask Dot from surface
61:47 - self.image we also could just say
61:48 - self.image is equal to the block but
61:51 - let's do it this way for now okay so
61:53 - let's now write our get Block function
61:55 - which I'm going to do beneath our get
61:58 - Sprite sheet or load Sprite sheet so I'm
62:00 - going to say get Block
62:02 - and I'm going to take in a size now what
62:05 - I need to do here is essentially find
62:06 - the block that I want in my train folder
62:09 - so I'm going to say path is equal to
62:11 - join
62:13 - assets and then this is going to be
62:15 - terrain like so and then we're going to
62:19 - use the terrain.png file so if I go here
62:23 - you can see that we have train terrain
62:25 - and then what we want to do is load this
62:27 - block
62:28 - which I'll be showing you how to load in
62:30 - one second
62:32 - okay
62:33 - now that we have done that now that we
62:34 - have our path we're going to say the
62:36 - image is equal to Pi game dot image dot
62:40 - load and we're going to say path again
62:42 - dot convert Alpha so that we get a
62:44 - transparent background we don't really
62:46 - need it for this one but just in case
62:47 - later we load something does have
62:49 - transparency we will
62:51 - and then we're going to say surface is
62:52 - equal to Pi game dot surface and for the
62:56 - surface we're going to pass size size
62:58 - which is the width and the height of our
63:00 - surface
63:01 - we're gonna pass pygame DOT Source Alpha
63:04 - with a depth sorry of 32. we're going to
63:08 - say rectangle is equal to pygame Dot
63:11 - rect and then this is going to be 96 0
63:15 - size size now let me slow down for one
63:18 - second if we go to Terrain
63:20 - we can see that we want to load this guy
63:23 - right here now I've already done the
63:25 - math this image starts 96 pixels from
63:29 - the top of the screen so that's the
63:30 - reason I'm putting 96 there because I
63:32 - want to start at 96 so 960 is my
63:34 - position and then I want to load the
63:36 - size of this which I think is going to
63:38 - be either 96 or 64 or something along
63:41 - those lines anyways if I wanted to load
63:43 - say this terrain image then I would
63:45 - still have 96 but my y position would be
63:48 - different in fact the Y position would
63:50 - probably be a little bit less than 96 it
63:52 - might be 80 it might be 85 I'd have to
63:54 - like experiment with it to see exactly
63:56 - where this image starts but I just want
63:58 - you to understand that what I'm passing
64:00 - here when I say something like 960 I'm
64:02 - passing the position that I want to load
64:05 - the image from from the image right so
64:08 - I'm picking out a part of this image and
64:10 - this is like 96 0. that's where I'm
64:13 - picking it right here
64:14 - hopefully uh you guys understand that
64:16 - but if you want to load a different
64:18 - train image then you have to adjust
64:19 - these to be the starting position the
64:21 - top left hand corner of whatever image
64:23 - it is you want to load here and if yeah
64:26 - I was going to say we could load a
64:27 - different one but I don't want to waste
64:28 - time guessing which one it is so you
64:30 - guys can mess with that if you want but
64:31 - let's just load this top one which I
64:33 - already know works okay now that we have
64:35 - that
64:36 - we're gonna say surface dot Blitz and
64:39 - we're going to Blitz the image
64:42 - and again we're going to BLT it at 0 0.
64:45 - but we're only going to blit the area of
64:47 - it which is represented by the rectangle
64:49 - then we're going to return pygame Dot
64:52 - transform dot scale 2X
64:57 - surface
64:58 - Okay so we've passed what size we want
65:02 - our block to be
65:04 - then we create an image that is of that
65:06 - size okay we then say rectangle is equal
65:09 - to 96 0 size size right and then we BLT
65:13 - this image onto our surface which will
65:16 - be the image that we return and we
65:17 - return this scaled up by two times so it
65:19 - just doubles the size that we pass here
65:21 - you don't have to scale it if you don't
65:22 - want but I want it to be larger so I am
65:24 - scaling it now I understand again it's a
65:27 - bit confusing this size is going to be
65:29 - the dimension of this block so you want
65:32 - to pass whatever the size from this
65:34 - Sprite sheet is that you want to get in
65:35 - our case I think it's going to be 64 or
65:37 - something along those lines so that's
65:39 - what size will be
65:41 - you guys can mess around with this but
65:42 - really what you're going to be changing
65:44 - is these two values and the size that's
65:46 - what you're going to change when you
65:48 - want to load a different image for your
65:49 - block okay so now for Block we have get
65:52 - block or load block uh did I call it
65:55 - load block or get Block
65:56 - I called it get Block okay so let's
65:58 - change this to be get Block
66:01 - all right so we now have our block let's
66:04 - create a block let's draw a block on the
66:06 - screen and let's do some collision with
66:08 - our blocks
66:10 - okay so let's go here to Main
66:13 - and let's say blocks is equal to and
66:16 - let's just start by creating a single
66:18 - block so for our block uh let's just put
66:20 - it kind of randomly on the screen for
66:22 - now uh where do I want to put this let's
66:25 - go with something like
66:29 - actually I'm going to create a variable
66:30 - first I'm going to say block size let's
66:33 - put this at zero
66:34 - height minus the block underscore size
66:38 - block size is going to be equal to 96
66:41 - okay and then 4
66:44 - B size we're going to pass block size
66:46 - okay
66:48 - so the size of our block is actually 96
66:50 - I lied it is not 64. it's going to be
66:53 - 96. so we're going to create a block
66:55 - it's going to be positioned at zero
66:56 - height minus block size which is going
66:58 - to put it at the bottom of the screen
66:59 - and then the size is this now we need to
67:03 - draw our blocks so I'm going to pass
67:04 - blocks to my draw function
67:06 - okay and I'm going to go here
67:09 - and actually let's call this objects
67:12 - and we're going to say form objects or
67:15 - for obj
67:17 - in objects if we could type this
67:20 - correctly
67:22 - obj dot draw I'm struggling here with
67:25 - the typing and we will draw this on the
67:27 - window
67:28 - okay so we have our block now
67:31 - let's quickly look at this again right
67:32 - we load our image okay we get our block
67:34 - we have our size now we create the block
67:36 - down here
67:38 - and then we put it on the screen
67:40 - let's run it and let's see if we got a
67:41 - block
67:42 - and of course we've got an error what
67:44 - does it say here I need to run this
67:46 - again
67:48 - I take zero positional arguments but one
67:50 - was given okay so let's go to our player
67:53 - class here
67:54 - and we can see update I forgot to add
67:56 - the self parameter so let's add that in
67:58 - and that should fix it
68:00 - okay so now you can see that we have a
68:02 - block so now what we can do is create a
68:04 - whole floor of blocks if we want to do
68:06 - that and then we'll Implement gravity
68:07 - and then collision with the block so
68:09 - that you can see that you like can land
68:10 - on the Block and we can jump off of the
68:12 - block
68:13 - all right so let's make a whole floor so
68:15 - to make a floor we can do this we can
68:19 - say floor is equal to we're going to say
68:21 - block
68:22 - it's going to be I
68:24 - times
68:26 - block size
68:30 - it's gonna be height minus block size
68:31 - block size
68:34 - 4 I in range and I'm going to say
68:38 - negative width
68:40 - width times two
68:43 - um and we're going to divide this
68:46 - by the block size
68:48 - and by the block size
68:51 - okay then for my
68:53 - blocks uh let's actually just
68:56 - replace this and instead we'll just pass
68:58 - floor
68:59 - okay what I've done here with this for
69:01 - Loop is I've said I want to create
69:04 - blocks that go kind of to the left and
69:07 - to the right of the screen so I don't
69:08 - want to just fill the current screen
69:10 - because we're going to have a scrolling
69:11 - background in a second which we'll
69:12 - Implement in a minute anyways I want to
69:14 - have some kind of going to the left and
69:15 - so I'm going to the right so I'm taking
69:16 - my negative width uh over the block size
69:19 - which is how many blocks I want to the
69:21 - left side of the screen and then I'm
69:23 - taking my width times 2 and I'm
69:25 - interested dividing that by the block
69:26 - size again that's how many blocks I want
69:28 - to the right of the screen then I'm
69:31 - taking I I'm multiplying it by my block
69:33 - size which is telling me the x
69:35 - coordinate position that I want my block
69:37 - to be at
69:39 - and then this is always going to be the
69:41 - same because I want it to be at kind of
69:43 - the bottom of the screen and then for my
69:45 - block size well I want that to always be
69:46 - the same
69:47 - okay so let's run this now and see what
69:49 - we get
69:50 - and now we get a bunch of blocks so now
69:53 - that we have these blocks let's make it
69:55 - so we can collide with the blocks and so
69:57 - we have gravity and we actually fall
69:59 - onto those blocks
70:03 - so the Collision all right Collision is
70:06 - a little complicated but let's write it
70:09 - and let's see how we can how we can get
70:12 - it going here so inside of handle move
70:14 - is where we're going to handle our
70:15 - Collision which means we need to have a
70:17 - list of objects that we can potentially
70:19 - be colliding with now we are going to
70:22 - write a function here
70:24 - called handle vertical
70:27 - Collision because we need to handle the
70:29 - vertical and horizontal Collision
70:30 - differently for now we'll just start
70:32 - with uh vertical and we're going to take
70:34 - in player objects and the displacement
70:36 - in y that we just moved
70:39 - now we're going to have collided
70:40 - underscore objects is equal to a list
70:43 - we're going to say for object in
70:46 - objects these are all the objects we
70:48 - could be colliding with
70:49 - and we're going to say if High game
70:53 - Dot Sprites dot Collide mask and then
70:58 - we're going to pass
70:59 - our player
71:01 - and our object
71:04 - now remember I told you Collision was
71:05 - going to be simple well there you go
71:07 - this is all you need to do to determine
71:09 - if two objects are colliding the reason
71:11 - we can do this is because our objects
71:13 - we've inherited from the Sprite class
71:15 - and on them we have a mask so we're
71:18 - going to use this mask property as well
71:19 - as the rectangle property when we
71:21 - collide with the mask so I pass my
71:23 - player I pass my object and this will
71:25 - tell me if I am colliding with my object
71:28 - perfect now if I am I'm going to do some
71:32 - stuff differently depending on what
71:34 - direction I'm colliding in so if I'm
71:35 - hitting the top of the object it's going
71:36 - to be different than if I'm hitting the
71:38 - bottom so we need to handle that here so
71:40 - I'm going to say if my displacement Y is
71:42 - greater than zero really this should be
71:45 - velocity but that's fine
71:47 - then what I'm going to do is place
71:50 - my character on top of the object it
71:53 - collided with so I'm no longer colliding
71:55 - with it
71:57 - now what this is saying is if I'm moving
71:59 - down on the screen so if I'm moving down
72:01 - then that would mean I was colliding
72:02 - with the top of this object so if I am
72:05 - I'm going to take the bottom of my
72:07 - player rectangle which is my bottom my
72:09 - player's feet essentially and I'm going
72:11 - to make it equal to the top of the
72:14 - object I'm colliding with this is
72:16 - another advantage of using rectangles
72:17 - you can use this kind of bottom and top
72:18 - property and avoid having to do you know
72:20 - add the height and all that kind of
72:22 - stuff so that's what I'm going to do now
72:24 - otherwise I'm going to say if my
72:25 - displacement Y is less than 0 and I
72:27 - suppose this can be an L if
72:29 - then
72:30 - what I will do is say myplayer.rec dot
72:34 - top is equal to the obj.rec dot bottom
72:37 - because if I'm moving up which means I
72:39 - have a negative velocity then I am
72:42 - hitting the bottom of an object so I
72:44 - need to make my top be equal to the
72:46 - bottom okay this just makes it so you
72:48 - don't like say stay inside of the object
72:50 - excuse me you go outside of it and it
72:52 - looks like you collided but you didn't
72:54 - go through the object
72:55 - now one thing we also need to do here is
72:58 - we need to call the method player.landin
73:00 - and player.hit head which I've not yet
73:02 - created and we're going to write these
73:05 - to handle what happens when we land on a
73:07 - block and when we hit our head on a
73:09 - block
73:09 - okay then we're going to say collided
73:11 - objects dot append and we're going to
73:13 - append our object and we're going to
73:15 - return our collided objects just so that
73:18 - we know what objects we collide with so
73:21 - that we can check if we collided with
73:22 - like fire or a certain special object or
73:25 - something like that
73:26 - okay so let's handle vertical Collision
73:28 - now we need to write the uh landed and
73:32 - hit head method
73:33 - so let's go to player
73:35 - and let's do this so I'm going to say
73:38 - let's do it here
73:39 - landed
73:41 - self
73:42 - now what do we do if we lend it well if
73:46 - we just landed then we need to reset our
73:48 - gravity or our fall counter
73:50 - so we're going to say self dot fall
73:52 - count
73:54 - is equal to zero so that way we stop
73:57 - um like adding gravity right okay what
74:00 - else do we need to do if we land it we
74:01 - need to say that our y velocity is equal
74:04 - to zero if we let it on a block stop
74:06 - moving us down
74:07 - and I'll add this in now we're going to
74:10 - say our self.jump count is equal to zero
74:12 - we're going to do something with jumping
74:14 - that involves double jumping so we'll
74:15 - have a jump counter I'll just put this
74:17 - here now and then we'll we'll use it
74:18 - later
74:19 - okay so that's if we landed otherwise
74:21 - I'm going to say Define
74:23 - hit head
74:25 - for self I'm going to say self.count
74:27 - equals zero but if we hit our head I
74:29 - want to reverse our velocity so that now
74:31 - we move down because we're moving up
74:33 - right so I'm going to multiply my
74:35 - velocity by negative one so when I hit
74:37 - my head I kind of bounce off the block
74:38 - and go downwards that's what's going to
74:40 - look most natural
74:41 - okay so that's all we need for right now
74:43 - for hitting the head now we can add our
74:45 - gravity back and when we add our gravity
74:47 - back what's going to happen is we'll
74:49 - fall we'll hit the block I'll move us to
74:51 - the top of the block
74:52 - and then we should just be able to move
74:53 - on top of the block
74:54 - let's see if that's going to work though
74:56 - uh although it's not gonna work if we
74:58 - don't add the function call so let's add
75:01 - the function call here
75:03 - in handle move we're going to say
75:06 - handle vertical Collision we'll pass the
75:09 - player the objects
75:10 - and the player.y velocity
75:13 - and the Y velocity is essentially how
75:16 - much we just moved right
75:18 - okay very good now let's make sure
75:21 - handle move we need to pass our floor so
75:25 - let's do that
75:26 - all right let's run the code
75:28 - let's see what we get
75:30 - and boom look we land on a block and we
75:33 - can now run on top of the block
75:36 - and everything is looking very good
75:39 - to me okay so that's pretty good now
75:41 - that we're on top of a block we can jump
75:43 - and then we can deal with uh hitting
75:45 - blocks
75:46 - um what do you call this uh horizontally
75:48 - right so that we can't like run into a
75:50 - block and we'll also make the background
75:51 - scroll and then we'll be pretty good
75:54 - we'll have a lot of this tutorial
75:56 - finished
76:00 - I wanted to make us jump yes let's make
76:01 - it jump okay so let's go to our player
76:04 - and let's create a variable here
76:06 - self.jump underscore count is equal to
76:09 - zero now based on the way we've coded
76:11 - this jumping is actually quite easy I
76:13 - can say Define jump
76:16 - self
76:17 - and when we jump all we're going to do
76:20 - is say self.y underscore velocity is
76:24 - equal to the negative of self-dog
76:26 - gravity multiplied by whatever Factor
76:28 - you want in terms of the speed of your
76:30 - jump so I'm going to multiply Gravity by
76:32 - eight the reason I'm doing this negative
76:34 - is that I jump up in the air right so
76:36 - now that I've done this what will happen
76:38 - is as soon as I hit the jump key I'll
76:40 - jump up into the error it's pretty
76:42 - straightforward and the reason that's
76:44 - going to happen is because my y velocity
76:45 - will change and what will bring me down
76:47 - is the fact that inside of my Loop if I
76:51 - go to where Loop is I'm constantly
76:53 - applying downward gravity so what I'm
76:54 - doing is changing my velocity to go
76:56 - upwards and then I'm letting gravity
76:58 - take me down so that's kind of the
77:01 - benefit of how we've coded this jumping
77:02 - is very easy
77:03 - now I'm also going to reset my animation
77:05 - count to zero I'm going to say my jump
77:07 - count plus equals one I'm going to say
77:11 - if the self dot jump underscore count
77:17 - is equal to one this means that I'm
77:19 - double jumping so if the jump counts
77:21 - equal to one when I hit jump that means
77:23 - it's just going to be equal to 2 now
77:26 - actually let me take this sorry and put
77:28 - this down here
77:29 - then I will say self.count is equal to
77:34 - zero
77:35 - yeah I think does that make sense
77:40 - no I want to do it this way sorry
77:42 - okay so what I'm trying to do here is
77:44 - make it so that as soon as I jump I
77:46 - essentially get rid of any gravity I've
77:48 - already obtained so let's say I was like
77:51 - falling and then I landed and then I
77:53 - jumped there would be some gravity on me
77:55 - keeping me on the ground so I want to
77:57 - remove that gravity so that when I jump
77:59 - up it's not in uh the factor it's like
78:01 - it's not taken into account and then
78:03 - I'll start applying the gravity after
78:05 - I've jumped hopefully that makes a bit
78:07 - of sense but this should say
78:09 - fall count so as soon as I jump I'm
78:11 - resetting the fall count to be equal to
78:13 - zero so that any gravity I've
78:15 - accumulated I'm removing but I'm only
78:18 - doing that if this is the first jump I'm
78:20 - making because for the second jump I
78:23 - want you to have to time it based on
78:25 - like when you're jumping right so if you
78:27 - jump a second time close to when you
78:30 - jump the first time you will jump higher
78:32 - than if you jumped at like the peak of
78:34 - your jump when your gravity would be the
78:35 - highest okay I don't know if that makes
78:37 - sense but just just follow along here
78:38 - this I messed with this before this
78:40 - works trust me all right so we have
78:43 - jumping now I think that's all we really
78:46 - need for jumping
78:48 - um yeah that seems good to me so now if
78:50 - we want to jump let's make it so when we
78:51 - hit space we jump so we can do that
78:53 - inside of handle move
78:55 - actually I'm not going to do a handle
78:57 - move I'm going to do it here in the
78:59 - event Loop and the reason for this is
79:01 - that if I do it in handle move what's
79:03 - going to happen is if I press the jump
79:04 - key and I hold the jump key down I'm
79:06 - going to keep jumping a bunch of times I
79:08 - don't want to do that I just want to
79:09 - jump once when I hit the key and then I
79:12 - have to release the key and press it
79:13 - again to jump this tells me if I'm
79:15 - holding down the key what I'm going to
79:17 - do in here tells me if I released the
79:19 - key yeah you'll see
79:21 - um but yeah this is this is how I do it
79:22 - so I'm going to say if event DOT type is
79:25 - equal to pygame Dot key down I'm going
79:29 - to say if event dot key is equal to Pi
79:33 - game
79:34 - dot k underscore space
79:37 - and
79:38 - my player dot jump count is less than
79:42 - two so I'm going to allow double jumping
79:44 - right so I'll have two jumps then I'm
79:46 - going to say player dot jump
79:49 - okay
79:50 - that should be all we need for jumping
79:52 - so let's try it out and let's see if
79:54 - this works
79:56 - and I can jump
79:58 - and notice I can kind of Run and Jump at
80:00 - the same time now what I'll do now is
80:02 - add uh like falling and jumping
80:05 - animations because obviously it looks
80:06 - kind of weird right now when I'm jumping
80:09 - but there you go we can jump nice
80:11 - okay so let's add the uh the animations
80:13 - now so if we go to update Sprite all we
80:17 - need to do here is we can say if
80:20 - self Dot
80:23 - and actually I need to refer to my cheat
80:25 - sheet here because this is a bit more
80:27 - complicated than I thought okay I'm
80:28 - going to say if not self if self.y
80:30 - underscore velocity does not equal zero
80:33 - then what I will do is say if self dot
80:37 - jump count equals equals one
80:40 - then I'm going to say my Sprite sheet is
80:43 - equal to jump
80:45 - I'm going to say l if self
80:47 - dot jump count
80:49 - equals equals two then my spreadsheet
80:52 - is equal
80:54 - to double jump
80:56 - now this is actually going to be if my
80:57 - velocity is less than zero which means
80:59 - I'm moving up
81:01 - now the next one that I want to add is I
81:03 - want to say if and actually these are
81:05 - all going to be L IFS
81:07 - well not that one but this one I'm going
81:10 - to say elif myself.y underscore Val is
81:14 - greater than zero this means I'm moving
81:15 - down then my Sprite sheet should be
81:17 - equal to fall
81:20 - okay
81:21 - so this is handling regular jump and
81:23 - double jump and this is telling me if
81:25 - I'm falling let's try it now
81:28 - and let's see what happens when I jump
81:31 - okay so it's kind of glitching a little
81:33 - bit uh the reason this is happening I
81:35 - believe is because we are applying
81:37 - gravity even while we're on the ground
81:40 - so my y velocity
81:42 - is always greater than zero and then
81:44 - stops being greater than zero that's
81:46 - greater than zero again so I will show
81:48 - you how to fix this all right so
81:50 - actually the way that I'm going to fix
81:51 - this is a bit of a hack but it's it's
81:55 - gonna be good it'll work here so I'm
81:56 - actually going to say if myself the Y
81:58 - velocity is greater than
82:01 - self
82:02 - Dot
82:04 - gravity
82:06 - times two now the reason I'm going to do
82:08 - this for fall is so that I don't
82:11 - immediately start glitching into this
82:13 - false State when I have a really low
82:15 - amount of gravity being applied to me
82:16 - when I've gone off the block and then
82:18 - I've fallen down to the block so let me
82:20 - show you what I mean by just kind of
82:21 - kind of writing the code here so you can
82:23 - see that what happens is when I hit the
82:25 - block when I collide with it it's going
82:27 - to reset my gravity count and then I'm
82:29 - going to kind of Spawn to the top of the
82:31 - block so when I'm on the top of the
82:32 - block I'm going to be slowly falling
82:34 - down to the block then I'm going to hit
82:36 - the block when I hit the Block it's
82:37 - gonna do the same thing it's going to
82:38 - bring me to the top reset my gravity
82:40 - account so what was happening before is
82:41 - that we would go to the top of the block
82:44 - and then our gravity would increase a
82:46 - tiny bit right it would increase to be
82:48 - one pixel per second or something along
82:49 - those lines which would mean we were
82:51 - falling so then we were falling we hit
82:53 - the block and then it reset it so it
82:54 - kept glitching between the two states so
82:56 - what I've done is just made it so we
82:57 - have to have a significant amount of
82:59 - gravity before it starts showing that
83:00 - fall state so now it doesn't look
83:02 - glitchy on the screen as I'm jumping
83:04 - around
83:06 - and you can see that what actually
83:07 - happens is when I jump and I get to the
83:09 - peak of my jump you can see that it
83:10 - starts the falling State because now my
83:14 - velocity has changed directions right
83:16 - now I'm going down
83:17 - okay so now we have jumping now we have
83:19 - running around and colliding with blocks
83:21 - done quite a bit actually the next thing
83:23 - I want to do is make it so that objects
83:25 - move on the screen then we will do a
83:27 - horizontal collision and then we will
83:29 - pretty much be done after I add kind of
83:32 - that like fire uh state right or that
83:34 - let's call it trap something like that
83:39 - okay so we want to do scrolling
83:41 - background scrolling background is
83:42 - actually fairly easy the way that we do
83:44 - a scrolling background is we simply
83:46 - offset every single thing that we're
83:48 - drawing on the screen by a certain
83:49 - amount so any object that we have we
83:52 - don't change its position at all we just
83:53 - change how we're drawing it on the
83:55 - screen so it doesn't affect any of our
83:57 - Collision all it affects is what's seen
84:00 - right so what's happening in the
84:01 - background is we may be colliding at a
84:03 - really far position to the right we're
84:05 - showing the position currently on the
84:07 - screen
84:08 - you see what I mean but what this
84:10 - involves
84:11 - is having some offset X which I'm going
84:13 - to say is equal to zero now the way that
84:15 - I want to have it and I'll just
84:16 - illustrate here is that when I'm on the
84:19 - screen I only start scrolling the
84:21 - background when I get close to the edge
84:22 - so like here right it would start
84:24 - scrolling whereas if I'm in the middle
84:25 - and I'm kind of moving like this I don't
84:27 - want it to scroll the background until I
84:29 - get to the edge oh also notice you can
84:31 - double jump here I kind of forgot to to
84:32 - mention that part
84:34 - um so I'm going to implement that where
84:36 - essentially once we reach a certain
84:37 - boundary then the screen will start
84:39 - scrolling
84:41 - all right so how do we do this well we
84:43 - can do it just directly inside of our
84:46 - Loop here and we're going to do it here
84:48 - we're going to say if the player.rect
84:52 - dot X
84:54 - minus the offset X
84:56 - plus the player.rect dot width and
84:59 - actually now that I think of this we're
85:01 - just going to do this we're going to say
85:02 - if the player.rect dot right which will
85:06 - account for the width minus the offset X
85:10 - is greater than or equal to
85:13 - the width
85:16 - minus a variable that I'm going to write
85:18 - in a second which is scroll area
85:21 - width
85:22 - and the blair.x underscore velocity is
85:26 - greater than zero
85:28 - then we're going to say
85:30 - offset underscore X and this is going to
85:34 - be plus equals the player dot x velocity
85:39 - all right let me just write this
85:41 - variable then I'll explain how this
85:42 - works because we also have to do the
85:44 - other side so I'm going to say scroll
85:45 - area width is equal to 200
85:47 - what that means is that when I get to
85:49 - 200 pixels on the left or 200 pixels on
85:52 - the right of the screen I start
85:53 - scrolling okay so here what I'm doing is
85:56 - I'm checking if I'm moving to the right
85:57 - that's what this checks if my x velocity
85:59 - is greater than zero that means I'm
86:01 - moving to the right
86:02 - and this is checking if my character is
86:06 - right on the screen
86:08 - like if it's crossed a specific boundary
86:11 - so I take whatever the right position of
86:13 - my player is which could be very far off
86:16 - the screen
86:17 - I subtract whatever offset we currently
86:21 - have so if we're offsetting everything
86:22 - by 100 pixels for example I subtract
86:25 - that so I know where I'm actually
86:27 - showing the character on the screen and
86:29 - I say if that's greater than the width
86:31 - minus the scroll area width which means
86:33 - I'm at say 700 pixels something like
86:35 - that on the right side of the screen
86:36 - then I'm going to offset the screen by
86:40 - whatever the velocity was that my player
86:42 - just moved to the right so that will
86:44 - make it look like I'm scrolling now we
86:46 - can say or
86:49 - and do the exact same thing for the left
86:51 - side so I'm going to say if player Dot
86:53 - rect
86:54 - dot left
86:56 - and this is actually going to be
86:58 - is going to be plus the offset I gotta
87:00 - check if it's Plus or if it's minus no
87:02 - it's going to be minus again minus the
87:03 - offset X is less than or equal to the
87:06 - scroll area width
87:08 - and my player dot X underscore Val is
87:12 - less than zero
87:13 - then I want to do this now let's move
87:16 - this down on the screen a bit I'm just
87:18 - going to add some parentheses so that my
87:20 - condition is
87:22 - correct here
87:26 - okay so I think that should be good
87:27 - again I'm checking to the left and to
87:29 - the right side if I'm moving to the left
87:31 - I want to check if I'm at that boundary
87:33 - if I'm checking to the right or if I'm
87:35 - moving to the right story I want to
87:36 - check if I'm at that boundary and then I
87:37 - increment my offset X now all I have to
87:40 - do to account for this is add an offset
87:43 - X to my draw function and draw every
87:45 - single object offset by this x so I'm
87:48 - going to go here and say offset
87:50 - underscore X and now just to all of my
87:53 - draw functions I'm going to pass
87:57 - offset X
87:59 - offset underscore X I'm going to go to
88:02 - all my draw functions and I'm going to
88:03 - add this
88:06 - offset X and what I'm going to do is
88:08 - just subtract
88:09 - the offset X from the X position I'm
88:12 - drawing everything out so we say minus
88:13 - offset X and we'll take in
88:16 - the offset underscore X
88:18 - okay now the reason this works if I move
88:20 - to the left my offset X is going to be
88:22 - negative which means everything is going
88:24 - to push to the right side because we're
88:26 - adding to the position for it if I move
88:28 - to the left side or sorry if I move to
88:30 - the right side the offset X is going to
88:31 - be positive which means everything is
88:33 - going to move to the left so it has a
88:35 - scrolling background effect
88:37 - let's just run it though and see if it
88:39 - works then I can fix it if it doesn't
88:42 - okay so as I start running here you can
88:44 - see that now the floor is going to start
88:46 - going with me once I reach this boundary
88:48 - however
88:49 - on this side right like when I'm in the
88:51 - middle is not doing anything I have to
88:52 - get to a certain boundary which is kind
88:54 - of invisible on the screen and then it
88:56 - starts scrolling with me which is what I
88:58 - wanted to do and then notice if I jump
89:00 - here boom I fall off the platform
89:05 - let's do collision with blocks in the
89:08 - horizontal Direction
89:10 - so to do that I'm just going to add a
89:12 - block here so I'm actually going to make
89:14 - a list
89:15 - I'm going to say objects is equal to
89:17 - Asterix floor now if you've ever seen uh
89:21 - like kind of dot dot dot in JavaScript
89:23 - that's what this does in Python it just
89:25 - essentially breaks this floor into all
89:27 - its individual elements and passes them
89:29 - inside of this list so imagine it if me
89:32 - just writing this here that's what it's
89:34 - doing
89:35 - and then I'm going to pass another block
89:37 - and for this block I'm going to place
89:39 - this at
89:41 - let's do zero and then for the Y this is
89:46 - going to be the height of the screen
89:49 - minus the block size times two
89:52 - now the reason I'm multiplying this by
89:54 - two is so that I get it a bit higher on
89:56 - the screen
89:58 - so that we can kind of run into it
90:00 - horizontally and I'm going to pass my
90:02 - block size
90:03 - so I'll just see now I want to go and
90:06 - rather than drawing my floor
90:08 - want to pass objects
90:11 - and same here with handle move on to
90:13 - pass objects
90:14 - so let me run this
90:16 - so now you can see that I have that
90:17 - block there right
90:19 - now notice that when I hit the block I
90:21 - kind of go to the top of it and the
90:23 - reason I go to the top of the block is
90:25 - because right now I'm only handling my
90:26 - vertical Collision so when I hit the
90:29 - block I have a little bit of gravity
90:30 - because remember there's always some
90:31 - gravity on me when I'm on the floor and
90:33 - so it thinks that I've hit the top of
90:34 - the block so it spawns me on the top of
90:36 - the block so we need to make it now so
90:38 - that when you hit the Block in the
90:39 - horizontal Direction it kind of Pops you
90:41 - off of it so that it doesn't think
90:43 - you're hitting the top of the block or
90:45 - the bottom of the block alternatively
90:46 - which you'll see in a second and in fact
90:48 - let me add one more block to show you uh
90:50 - hitting our head on the Block
90:52 - so let's add another block
90:54 - let's make this at say block size
90:57 - multiplied by three and then for the
91:01 - height let's do times four
91:04 - okay now we have another block let's see
91:07 - where this guy is now I can show you
91:09 - that I can hit my head on the Block
91:10 - right and I can't kind of go
91:12 - above it
91:15 - okay anyways we have that let's do our
91:17 - horizontal Collision
91:19 - so the horizontal Collision
91:21 - is a bit weird to implement the idea
91:25 - behind this is that since we're using
91:27 - our Sprite Collide mask we want to make
91:31 - sure that if we collide with a block
91:32 - horizontally we move ourselves off of
91:35 - that block so that it doesn't think that
91:38 - we're colliding with it in the vertical
91:39 - Direction now you just saw that happen
91:41 - we hit the block it thought that we were
91:43 - hitting it like the top of the block so
91:45 - it put us on the top of the block
91:46 - because that's what this line does right
91:48 - here so in our horizontal Collision we
91:51 - essentially need to check okay by moving
91:54 - in this direction are you going to hit
91:55 - the block if you are going to hit the
91:57 - block we want to prevent you from moving
91:59 - in that direction so that you don't
92:02 - hit it collide with it and then we like
92:04 - spawn to the top of it
92:05 - so let me write it and I'll explain to
92:07 - you how it works but it's just very
92:09 - important that we check the horizontal
92:10 - Collision first then once we check that
92:13 - we check the vertical Collision because
92:15 - we only want to check vertical Collision
92:17 - if we are not colliding with a block
92:19 - horizontally
92:21 - or if we haven't already handled or if
92:23 - we have already handled the horizontal
92:25 - Collision again the idea is we don't
92:27 - want to be thinking that we're hitting
92:29 - the block on the top when really we hit
92:31 - it on the left or the right side so we
92:33 - got to check that first
92:34 - so I'm going to make a function I'm
92:35 - going to say define collide
92:37 - I'm going to take player objects a
92:41 - displacement X like that now I'm going
92:44 - to say player.move
92:46 - and I'm going to move my player in the
92:48 - displacement X Direction and 0 in the y
92:51 - direction the reason I'm doing this is I
92:53 - want to check if with the current
92:55 - velocity that my player has
92:57 - if
92:58 - now the reason I'm doing this is I want
93:00 - to check if my player were to move to
93:03 - the right or if they were to move to the
93:04 - left would they hit a block that's
93:06 - that's what I'm checking essentially by
93:08 - moving the player preemptively
93:10 - so now what I need to do is say
93:12 - player.update now the reason I need to
93:14 - call that update and let's go here to
93:16 - dot update is because I need to update
93:17 - the rectangle in The Mask before I check
93:19 - for Collision so again what I'm doing is
93:22 - I'm preemptively moving my player to
93:23 - where they would be moving if they're
93:25 - going left or right I'm updating their
93:27 - mask and their rectangle and then I'm
93:29 - going to say four object
93:32 - in objects if pygame dot Sprite dot
93:37 - Collide mask
93:39 - and then I'm passing my player
93:42 - and my object so this is why I needed to
93:44 - update my mask and my rectangle so I
93:46 - move my player I update it and then
93:48 - using that updated mask I check would I
93:50 - be colliding with an object now I'm
93:53 - going to say
93:54 - collided
93:55 - object
93:57 - is equal to none
94:00 - I've got to spell collided correctly
94:02 - if I am then I'm going to say collided
94:05 - and this is just going to be object
94:09 - is equal to obj
94:12 - then I'm going to break okay then I'm
94:14 - going to say player.move and I'm going
94:17 - to move them back
94:19 - and then I'm going to say
94:21 - player.update
94:24 - okay and then I'm going to return the
94:26 - collided object
94:28 - okay so what I'm doing right I'm moving
94:30 - my player I'm updating the mask I'm
94:32 - checking if they would collide with
94:34 - something if they were to move in that
94:35 - direction then if they did okay I get
94:38 - that Clyde object it doesn't matter if
94:40 - they do or they don't after I check this
94:41 - Collision I have to move them back to
94:43 - where they originally were so I have to
94:45 - reverse the movement
94:47 - and then update the mask again
94:49 - then a return collided object
94:51 - okay again moving checking if we hit
94:54 - anything either way moving back to where
94:56 - we were before this is preemptively
94:58 - tracking before we allow them to move
94:59 - into a block
95:01 - all right now what we need to do is use
95:03 - this function uh to allow us to move
95:07 - left or right or to disallow us from
95:09 - moving left or right so I'm going to say
95:10 - Collide underscore left is equal to
95:12 - collide
95:14 - player objects and then negative player
95:18 - Vel then I'm going to say Collide
95:20 - underscore right is equal to collide
95:24 - player objects and then player and then
95:29 - I'm going to say and not Collide left
95:33 - and not Collide right
95:36 - again what we're doing here is we're
95:38 - checking if we should be able to move
95:40 - left or if we should be able to move
95:41 - right uh based on our current position
95:43 - that's why I make that preemptive
95:45 - movement and then here I only let you
95:47 - make the movement if that movement does
95:49 - not cause you moving into a block or
95:51 - colliding with one
95:53 - now that we have that that should
95:54 - actually handle our horizontal Collision
95:57 - that's actually all we need
95:58 - all right so let me run this code and
96:01 - let's see so I'm here okay obviously
96:03 - that's still working and you can see
96:05 - that I can't go through the block now
96:07 - let's go here and actually I'm getting a
96:10 - bit of a bug on the right side okay so
96:12 - that time it worked but it's a little
96:14 - bit glitchy and I have a feeling it has
96:16 - to do with the animation count of me
96:19 - running because it's only sometimes when
96:21 - I'm running and I hit the block that it
96:23 - spawns me up here so I'm just going to
96:25 - do another little hack here and I'm just
96:28 - going to multiply this by two both of
96:30 - them here the reason for this being that
96:33 - I'll just make it so there's a little
96:34 - bit of space between the block
96:36 - and that way me changing the Sprite
96:39 - isn't going to affect if I collide with
96:41 - the object or not because remember the
96:43 - Sprites kind of shift to the left or to
96:45 - the right a little bit so just by adding
96:46 - this multiplied by two it should make it
96:49 - so that I'm never going to be colliding
96:51 - left or right it will make it so as a
96:52 - bit of space see how there's a bit of
96:53 - space between the block now but that's
96:55 - okay because now I'm never going to have
96:57 - that Collision bug
96:59 - um where it's going to spawn me to the
97:01 - top
97:01 - and really you could probably just add
97:03 - one or two pixels but you can see that
97:05 - that kind of fixed it right there
97:07 - okay so now we have collision with
97:09 - blocks we have a scrolling background we
97:12 - have double jumping
97:13 - I think that the last thing that we need
97:17 - to add here is the fire thing right kind
97:20 - of that trap where you hit it and you
97:21 - kind of Flash and then once we've done
97:23 - that will pretty much be done the
97:24 - tutorial
97:28 - all right so let's write our class for
97:30 - representing our fire
97:33 - so I'm going to say class fire this is
97:36 - going to inherit from object as well and
97:39 - this is going to be animated right we're
97:41 - going to have animated fire
97:42 - so this will take a bit more work but I
97:44 - think it'll be worth it it looks pretty
97:45 - cool on the screen
97:46 - so I'm going to take X Y width and
97:49 - height
97:50 - and then I'm going to call my super
97:52 - initializer so super
97:55 - dot underscore squared knit self x y
98:00 - with
98:01 - and height
98:03 - okay and then for the name of this I'm
98:05 - actually going to call it fire remember
98:06 - that we can pass a name the reason I'm
98:08 - adding a name to the object is so that I
98:10 - can determine when I collide with the
98:12 - object if it's fire and if it's fire
98:14 - then I want to do something right
98:16 - okay so for self.fire I'm going to use
98:18 - our load Sprite sheets function for
98:20 - directory one this is going to be traps
98:22 - and for directory two this is going to
98:25 - be fire
98:26 - now if we go here to trops you can see
98:28 - that fire is one of our traps so we have
98:30 - hit off on okay now there's also a bunch
98:34 - of other traps right so you can you can
98:36 - pick a different trap if you want like
98:37 - you could pass this blink one or
98:39 - whatever the thing with these ones is
98:40 - that they have uh some more animations
98:43 - so there's a bit more logic you need to
98:44 - handle for them so that's why I'm going
98:46 - with fire because it's a pretty simple
98:47 - one to do
98:48 - now up here for fire I'm again gonna
98:50 - have my animation delay so let's make
98:54 - that equal three
98:56 - and now let's specify our image so let's
98:58 - say ourself.image is going to be
99:00 - self.fire
99:02 - off we're going to start with it off
99:04 - and then zero okay then I'm going to say
99:08 - self.mask is equal to pygame dot mask
99:12 - Dot from surface self Dot
99:15 - image like that
99:17 - okay then I need to set an animation
99:19 - count so I'm going to say my animation
99:21 - underscore count is equal to zero just
99:24 - like we did for our player and I need to
99:26 - set myself dot animation underscore name
99:29 - which for now is going to be equal to
99:31 - off
99:32 - okay now I'm going to make a few
99:34 - functions my first function is going to
99:36 - be on or my first method and I'm going
99:37 - to say self dot animation name is equal
99:40 - to on if we look at fire we see we have
99:43 - hit off on we're not going to use hit
99:45 - we're just going to use off and on
99:47 - okay now we're going to have off
99:51 - self.animation name
99:53 - is equal to off okay and then we'll have
99:58 - our Loop we'll say Define Loop self and
100:01 - inside of our loop we're going to do a
100:02 - very similar thing to what we did inside
100:04 - of our player Loop in fact so similar
100:07 - that I can copy pretty much all of this
100:09 - right here so let's copy all that
100:12 - and let's paste that here now for update
100:16 - rather than actually just calling an
100:18 - update method we'll just copy
100:21 - the stuff from the update method here
100:22 - and just paste it down
100:24 - okay and rather than self.sprite
100:27 - we're going to change this to image and
100:30 - I actually think that once we remove the
100:32 - direction here this is all that we need
100:35 - for our um
100:39 - all right so now we just need to make a
100:41 - few changes we're going to get rid of
100:42 - this Sprite sheet name and rather than
100:44 - Sprite sheet name we're going to say
100:45 - self dot animation name
100:49 - and now we should actually be good to
100:52 - just use this so let me space this out a
100:54 - bit we get our Sprites okay this isn't
100:58 - going to be self that Sprites no it's
100:59 - not gonna be self-destrates it's gonna
101:01 - be self.fire which is this okay really I
101:04 - probably should call this something else
101:05 - but
101:06 - fire is going to represent all of our
101:08 - fire images okay so I'm using this to
101:11 - get my different animations
101:13 - I'm getting the animation name that I'm
101:15 - currently playing so either on or off
101:16 - and then I'm saying my Sprite index is
101:19 - equal to self.animation count
101:21 - divided by the self.animation delay mod
101:24 - the line of Sprites same as what we had
101:27 - before my image is equal to Sprites at
101:28 - Sprite index and then I increment the
101:30 - animation count update my rectangle and
101:32 - update my mask which is important for
101:34 - the collision and I'm good now last
101:37 - thing I want to do here
101:39 - is I want to just check if my self dot
101:41 - animation count is greater than actually
101:45 - if this divided by myself dot animation
101:48 - delay is greater than the line of
101:50 - Sprites
101:52 - now the reason I want to do this is so
101:54 - that my animation count doesn't get too
101:56 - large now you'll notice in my player
101:58 - class I actually didn't do this now that
102:00 - was intentional because if you do this
102:02 - then it kind of messes up how the double
102:04 - jump works you can do it if you want but
102:06 - you'll see that it kind of messes with
102:07 - things and with our player we're
102:10 - constantly resetting the animation
102:12 - account when we jump or when we go left
102:13 - or when we go right so that value
102:15 - doesn't really get too large but here
102:17 - for our fire since it's just static like
102:19 - it's just sitting forever what will
102:21 - happen is the animation count if we
102:22 - never change it back to zero we'll get
102:24 - to an extremely large number which can
102:26 - kind of lag our program so what I want
102:28 - to do is just make it smaller right so
102:30 - if it goes beyond what the actual
102:33 - animation
102:34 - um what do you call this is the line of
102:36 - the Sprites are then I want to set this
102:38 - to zero it's important I divide it by
102:40 - the animation delay though because if
102:41 - I'm dividing it here I need to divide it
102:43 - here before I set it back to zero
102:46 - okay so now we have fire I think that's
102:48 - actually all we need for fire so now we
102:49 - just need to add it to our objects so
102:51 - let's create it let's say
102:55 - fire it's equal to Fire and what do we
102:57 - need to pass for fire we need X Y width
102:59 - and height so we can pick where we want
103:02 - to put this
103:04 - um where do I want to put my X and Y
103:07 - okay for now let's go 100 and let's go
103:11 - height minus the block size and then I
103:15 - don't know how tall my fire is going to
103:17 - be I've got to see how big I want to
103:19 - make this let's make it say 64.
103:23 - and then we'll go 32 64 here
103:27 - okay so if we look at fire
103:29 - let's quickly have a look here and go to
103:31 - off for example or on
103:34 - the size of this is 32 by 64. okay
103:38 - that's what the size is and you need to
103:40 - pass that uh correctly to the fire class
103:43 - otherwise it won't load the image
103:44 - properly
103:45 - so we take our height minus our block
103:48 - size minus 64 which will put us on top
103:51 - of a block
103:52 - now I will put this at yeah 100 is fine
103:54 - for now for the X and yeah 32 with 64
103:58 - height there we go we have our fire now
104:01 - I'm just going to say fire.on I'm just
104:02 - going to turn it on we'll just leave it
104:04 - on forever uh you can turn off
104:05 - programmatically if you want and then
104:07 - inside of objects I'll just place my
104:09 - fire
104:10 - now that I've done that it should just
104:12 - show up on the screen when I run my code
104:15 - so I got an issue let's see what the bug
104:16 - is here of course the output is not
104:19 - showing up correctly it says and it
104:20 - takes
104:21 - from five to six positional arguments
104:24 - where seven were given
104:26 - uh okay
104:28 - I see the issue here
104:30 - let's go back to our
104:32 - fire and we don't want to pass self
104:35 - let's remove self okay let's run this
104:39 - uh list index out of range self.fire off
104:41 - zero
104:43 - hmm okay I'm wondering why that's giving
104:46 - us an issue we have off here so that
104:48 - should have been okay so let's go here
104:51 - and let's print self.fire and let's see
104:55 - why it's giving us this uh this bug here
104:57 - all right so I've determined the issue
105:00 - and the issue is that I passed the
105:01 - incorrect size here it's actually 16 by
105:04 - 32. so I was passing too large of a size
105:07 - and that's why it wasn't giving us the
105:08 - correct number of images so let's change
105:10 - this now and run and now we should be
105:13 - okay and there we go now we have fire uh
105:16 - but however it is off now the reason
105:17 - it's off is because we didn't call the
105:20 - loop method on fire so let's fix that I
105:23 - can also get rid of the print statement
105:24 - that I put here that I don't need
105:26 - anymore
105:27 - okay so let's go down to Main and where
105:31 - we have player.loop let's call fire.loop
105:34 - and is asking for the FPS
105:36 - I don't know if I took that in my Loop
105:39 - here
105:41 - no I don't need the FPS for that so
105:43 - let's get rid of that
105:44 - okay now let's call it and it should
105:46 - start being on
105:48 - uh fire object has not shoot Sprite okay
105:51 - let's go fix that error my apologies
105:55 - fire we have Sprite somewhere here that
105:57 - we don't want self.sprite there's gonna
105:58 - be self Dot image and self Dot
106:02 - image all right start with that let's
106:05 - run it now
106:07 - and there we go we now have a moving
106:09 - fire and notice that
106:11 - I can kind of be on top of the fire
106:13 - right so I can collide with it and it's
106:15 - like Pixel Perfect Collision pretty much
106:17 - when I'm hitting it
106:20 - so now the last thing we need is to just
106:22 - make it so we go into that kind of hit
106:24 - State when we do hit the fire that's
106:26 - actually pretty easy to do we just need
106:28 - to add a kind of state to our player to
106:31 - know if we're hit or not so we're going
106:32 - to say self.hit is equal to false
106:36 - we also want to hit count
106:39 - because we're going to only be flashing
106:41 - for a certain amount of time then we're
106:43 - going to have a method here to find
106:46 - hit
106:47 - self
106:49 - .hit equals true
106:53 - and self.hit count
106:55 - is equal to zero then we're going to go
106:58 - in Loop and before our update Sprite
107:01 - we're going to say if
107:03 - self dot hit
107:04 - then self dot hit count
107:08 - plus equals one and then we're going to
107:10 - say if self dot hit count is greater
107:14 - than and we can just pick some value but
107:17 - let's say FPS multiplied by two which is
107:19 - going to be two seconds then the self
107:22 - dot hit
107:24 - is equal to false
107:26 - then we go here into our update Sprite
107:29 - and we say
107:30 - actually at the top here if self.hit
107:35 - it's important you put this at the top
107:36 - by the way so make sure you put it here
107:38 - then we are going to say the Sprite
107:41 - sheet is equal to
107:44 - hit
107:45 - great then we want to now determine if
107:48 - we actually got hit so we do that from
107:50 - our Collision functions which are going
107:54 - to be here
107:55 - all right so we have Collide left we
107:58 - have Collide right and we're going to
107:59 - have
108:00 - vertical
108:03 - collide
108:04 - now what we're going to do is we're
108:06 - essentially going to Loop through all of
108:08 - these objects and we're going to see if
108:11 - we hit fire now the way we'll know if we
108:13 - hit fire is by looking at all the
108:15 - objects that were returned here and it
108:17 - will tell us well if if we hit fire or
108:19 - not right it's because we can look at
108:21 - the name of the object and if the name
108:22 - of the object is fire then we know we
108:24 - hit fire so I'm going to say
108:27 - to check is equal to collide left
108:32 - Collide right and asterisk vertical
108:34 - Collide now I realize that inside of
108:36 - here I only returned one object whereas
108:39 - inside of here I returned all the
108:40 - objects I was colliding with vertically
108:42 - really we should probably be returning
108:44 - all of them from here as well but I
108:46 - think this is still going to work so
108:47 - we'll just leave it how it is for right
108:49 - now so I'm going to say 4 obj into
108:52 - underscore check these are all the
108:54 - objects we collided with remember I'm
108:56 - going to say if to underscore check
108:59 - and to underscore check Dot name
109:04 - is equal to fire then player.hit
109:09 - is able to trip
109:10 - okay
109:12 - that is all we need actually I'm going
109:13 - to say player.hit I want to call the
109:15 - method I don't want to set it equal to
109:16 - true so what we're doing here is looking
109:18 - through all the objects we collided with
109:19 - if any of them are fire then we will put
109:22 - hit on the player the reason I'm doing
109:24 - this first if to check is because these
109:27 - could be none right we could have no
109:29 - objects we collided with so I need to
109:30 - make sure I handle that case before I
109:32 - try to access name on an object that
109:34 - isn't defined
109:35 - all right let's run the code and let's
109:37 - see
109:38 - and player has no object no attribute
109:40 - hit count okay so let's go to player
109:45 - and let's go to hit count
109:47 - and let's make that equal to zero I
109:48 - guess I forgot to assign that all right
109:50 - let's try this now uh list object has no
109:52 - attribute name okay
109:55 - interesting
109:57 - uh let's see here
110:01 - okay all right so I'm using two check
110:03 - when I need to be checking obj
110:06 - so let's fix that and run the code
110:11 - Bool object is not callable okay
110:13 - player.hits aha so let's call this make
110:17 - hit
110:18 - it's because I have an attribute with
110:20 - the same name as my method so it's
110:22 - accessing the attribute when it should
110:24 - be accessing the method so I'm just
110:25 - going to say make underscore hit and now
110:27 - that should fix the problem for us
110:30 - run the code and there we go now it
110:34 - looks like I'm always being hit right
110:36 - now
110:37 - that of course is a bug
110:40 - so hit is equal to false
110:42 - let's check our hit count it's because
110:45 - if self.it so if the hit count plus
110:47 - equals one if self-doh hit count is
110:49 - greater than
110:51 - self.he equals false
110:53 - maybe we need to reset our hit count as
110:55 - well
110:56 - okay and there's probably a bug
111:01 - here let's scroll down
111:04 - keep scrolling
111:06 - with our fire so we have to check if obj
111:10 - and obj and a name equals equals fire
111:12 - player.make hit
111:14 - okay
111:16 - I'm not sure what the bug is let me run
111:18 - this again
111:20 - and yeah it seems like we start out in
111:22 - the hit state so maybe it's an issue in
111:25 - here
111:27 - let's have a look here if self dot hit
111:31 - spreadsheet equals hit but we are we hit
111:34 - right away for some reason it's making
111:37 - us hit immediately okay let me have a
111:39 - look here guys and I'll be right back
111:40 - alright so I've realized I made a silly
111:42 - mistake here I actually had this
111:44 - collided objects append outside of this
111:47 - if statement that was causing all kinds
111:49 - of bugs and issues for me I think I was
111:51 - doing some print debugging so let me get
111:53 - rid of that here uh anyways I just moved
111:55 - it back now so that it's in the correct
111:57 - location so now if I re-run this
112:00 - now we should see that
112:02 - when I hit the fire it puts me into kind
112:04 - of this hit State last two seconds and
112:07 - then it ends
112:08 - all right so with that said guys I think
112:11 - that's pretty much gonna wrap up this
112:12 - video
112:13 - this showed you how to create a
112:15 - platformer how to do animations how to
112:17 - do Sprites how to do a scrolling
112:19 - background obviously there's a ton of
112:21 - stuff that can be added to this game but
112:23 - I really want to leave that to you
112:24 - obviously I could spend hours days
112:27 - months working on a game like this but I
112:29 - think this is a solid enough base to
112:31 - really give you guys a good foundation
112:33 - to go out there and create something
112:34 - pretty cool obviously there's all kinds
112:36 - of assets that I will leave in the
112:38 - GitHub that you can use I have all kinds
112:40 - of other Pi game tutorials that you may
112:42 - want to reference if you want to learn
112:44 - about menus sound effects
112:46 - um points scoring all of that kind of
112:49 - stuff you guys just go on my channel
112:51 - search Pi game tutorial you will see a
112:53 - bunch of them those will show you how to
112:55 - do a ton of other things that you know
112:57 - you may want to add to this game so I
112:59 - hope you guys enjoyed this this was a
113:01 - ton of work as always the code will be
113:03 - in the description if you did enjoy make
113:05 - sure to leave a like subscribe to the
113:07 - channel consider supporting me by
113:09 - purchasing something like programming
113:10 - expert I hope to see you in another
113:12 - YouTube video

Cleaned transcript:

foreign with you how to build a platformer game in Python this game will have Pixel Perfect Collision it will have an animated character as you can see here it will have single and double jumping it will have all kinds of different animations for falling jumping colliding with obstacles for example you can see here when I hit the fire I kind of go into this hit State I will show you how to generate different objects how to scroll the background and really at the end of this video you will have a solid fundamental understanding of how to build a platformer game in Python and you can go and extend this and build really anything that you can think of I will even include a ton of free assets for you that allow you to change your character change the terrain change the background and do all of that extremely easily in fact in this tutorial alone I will show you how to use four different characters let me show you those characters before we continue so this is the second character here this is being referred to as mask dude this is the third character I'm calling this guy the ninja Frog as you can see and Final finally we have this character here which is called pink man now in this tutorial you will learn how to use all of these characters and you can swap them out with a single line of code with that said I hope you're excited this video has taken a very long time to prepare so please click the like button subscribe to the channel and we'll dive in after a quick word from our sponsor thanks to dice for sponsoring this video dice is the platform for gogetters like yourself to find your next job in Tech that aligns with your values and skill set on dice.com you can easily search and filter for jobs and set personalized alerts so you never miss a job opportunity start by creating your free profile setting up your job alerts and then going visible and connecting with employers immediately now Beyond Just Landing a job dice helps you gain insights into the tech industry and learn what skills and Technologies you need to master to get to the next level with dice.com you get access to countless articles free ebooks and a variety of other resources that help you understand things like what tech salaries you can expect effect job postings by volumes the number of jobs by occupation and a lot of other valuable information that helps you craft your career in Tech we all know that searching for a tech job can be difficult but with dice it doesn't have to be click the link in the description to start leveling up with dice today and don't forget to download their mobile app so you never miss a great job opportunity thanks again to dice for sponsoring this video alright so let's go ahead and get into it now since this is a long video I do want to spend a minute here just talking about who this video is designed for exactly what you're going to learn and what you can expect just so you don't waste your time if you don't want to go through it so this video is really designed for people that have a bit of experience with python ideally you are an intermediate python programmer you understand the syntax you know for Loops you know functions you know all of that if you don't feel free to follow along but I'm not going to be explaining those basic concepts now this video will teach you how to build exactly what you see here so by the end of the video you will have exactly this and if you're not interested in waiting until the end of the video then you can download the code from the GitHub repository that I will leave in the description that's also where all the assets are going to be so regardless you're going to have to download the code from GitHub again I will leave that in the description download that open up the folder and kind of we can start working from there now really what I'm going to be showing you here mostly is Sprite sheet animation uh Pixel Perfect Collision using what's called masks and then how you can do the scrolling background generating objects all of that kind of stuff that is really the hard part when it comes to generating a platform or game once you have all of that down it's very easy to extend this to add levels to add like you know a finishing flag to add coins to add you know lives you can turn this game into anything you want and that's how I've designed this so that you have the base and then you can go and make it kind of a fullfledged game and work off of that so with that said I will stop talking now I think this game looks really good I'm excited to share this with you guys so let's get into actually building it so right now I have Visual Studio code open obviously we're doing this in Python and I already have Pi game installed now the first thing we're going to have to do is install pygame which is the module we're going to be using so to do that go to your terminal and type pip install Pi game if that doesn't work for you you're going to try pip 3 install Pi game if that doesn't work try python hyphen M pip install Pi game if that doesn't work try Python 3 hyphadam pip install Pi game if none of those work I will leave two videos on the screen that show you how to install that module now once you have Pi game installed I'm going to assume that you've downloaded the GitHub repository go to GitHub there's a little button that says click to download download the folder extract it to your desktop and then open it in vs code or whatever editor you want so you have something that looks like this you should have an assets directory inside of assets you should have a bunch of different folders then you should have a main python file that contains all of the finished code now obviously we're going to write the code from scratch but you can either work off that existing code or you can kind of clear the file and type along with me whatever you want to do I quickly want to run you through the assets folder and then we'll get into the code so in assets we have a ton of stuff we're not going to use most of this but I wanted to include all of it so that you could kind of continue the game later if you want so we have for example backgrounds these are a bunch of background tiles so you can change kind of the theme or color background very easily I'll show you how to do that we have items like boxes checkpoints fruits Etc we're not going to use any of those then we have main characters for main characters we have a bunch of sprite sheets inside of here and I'll show you how we can split these Sprite sheets apart and use all of the different kind of animations inside of here right so we have that for Mass dude ninja frog Pinkman and virtual guy all of the file names are the exact same okay then we have menu we're not going to be using anything from there we have other we have terrain we are actually going to be using terrain specifically we're going to pull out this kind of block here but you could change the block again if you want to do that and then we have traps and we are going to be using the fire trap wherever that is right here that has kind of an animation right where the fire is going but again you can add all of this stuff later on I'll show you kind of the base on how to do it and then you'll be able to extend from there okay now that we understand the assets I apologize for such a long introduction let's get into writing the code I also need to plug the idea of a course programmingexpert.io if you guys want to get better at python check that out from the link in the description okay so let's start at the top of our program here by importing everything we need we're going to import OS we're going to import random we're going to import math we're going to import pygame we're going to say from OS import list directory and we're going to say from OS dot path import is file and join now the reason I'm doing all this OS stuff is because we are going to be dynamically loading all of the Sprite sheets and the images so we don't have to manually like type out the file names that we want I'll show you how we write a function that just loads these folders here kind of splits the Sprite sheets automatically and gives us all the images that we're interested in okay after we do that we're going to say pygame.net we need to initialize the pi gate module then we're going to go down here we're going to set a caption for our display I'm going to say Pi game dot display dot set underscore caption if you're unfamiliar with what this is doing this is setting the caption at the top of the window I'll try to explain most the pi game stuff as we go through the video I also have a ton of videos on Pi game on my channel if you want to check out something a little bit more basic okay now what I'm going to do is Define a few Global variables that we're going to be using here the first one is going to be the background color now we'll use this for now until we Implement our own background and for the background color I'm going to make this white which is going to be 255 255 255 all of our colors in pi game are going to be in RGB okay so red green blue that's what we have for our background color we're then going to define the width and the height of our screen for some of you you're going to have to make this smaller if you're on a smaller display for me I'm on a 2K monitor so I'm going to go with a thousand by 800 but if you're on again a smaller screen you might want to make this just a bit smaller so that it works for you although it doesn't really matter um make it whatever size you want next I'm going to say my FPS which is my frames per second is going to be equal to 60 and I'm going to Define my player velocity equal to 5 and this is going to be the speed at which my player moves around the screen okay now that we've done that we need to set up a pi game window so I'm going to say pygame.display.set underscore mode and then I'm going to pass the width and the height to this window argument here this mode argument and this is going to kind of create the pi game window for us I'm going to store that in the window variable and there we go we have kind of our Global variables created now I'm going to make a main function I'm going to say Define Main this main function is going to be what we run to kind of start the game so inside of here I'm going to take a window and at the bottom of my program I'm going to say if underscore underscore name underscore underscore is equal to underscore underscore Main underscore underscore then call the main function and pass the window argument okay so hopefully you can see kind of the structure of our program already the reason I have this line right here is so that we only call the main function if we run this file directly if we don't run this file directly say we imported something from it then we won't run the game code okay so that's why I have this inside of main is where we're going to write kind of our event Loop the event Loop will be what's handling say the Collision moving our character redrawing the window all of that kind of stuff this kind of good practice to have your event Loop in one place so inside of the main function we need to set up a few things the first thing we need is a clock so we're going to say clock is equal to Pi game dot time dot clock we also need to Define uh what is it a while loop that's going to continually Loop and act as our event Loop so I'm going to say run is equal to true I'm going to say while true or while run sorry and then the first thing I'm going to do is say clock.tick FPS now FPS members our variable right here what this line does is ensures that our while loop is going to run 60 frames per second okay so no more than 60 times per second that's what this ensures if you're on a really slow computer chances are you could be running less than 60 frames per second but in my case I'm on quite a fast computer and if I didn't put this here then you'd see that my game would be like way faster than yours so we need to do this to regulate the frame rate across different devices okay now that we have that we're going to say four event in pygame dot event dot get and the first event that we're going to check for is if the user quits the game if they quit by quitting I mean they hit the red X in the top right hand corner then we need to stop the event Loop and exit our program so I'm going to say if event DOT type is equal to pygame dot quit then we're going to say run is equal to false and we can break out of this Loop then we can go down here and we can say hi game dot quit notice this is outside of the while loop and then we can put quit which will actually quit the Python program okay so now we have our basic event Loop and what should happen if I run the code now is a pi game window should pop up nothing should be on the screen and if I hit the red arrow it should close so let's try this and see what we get okay notice it says platformer and then I hit X and it closes perfect uh we're well on our way to creating the platformer game all right so now that we've done that I actually think that the first thing we can do is generate our background then once we have the background we can create a basic player that we can move around the screen and once we have that we'll start doing all of the animations and then later in the video once we've got uh kind of the bulk of the stuff done we'll handle the collision and all of the movements right okay so I need to make a function here and I'm going to call this get underscore background now before I dive into this let's have a look at our assets folder again now what I want to do is use these tiles right they're just tiles I believe their size is 64 by 64 or 32 by 32 something along those lines anyways we'll want to use these tiles and tile the whole background so what I need to do is essentially create a whole grid of these tiles based on the size of my screen so the way I'm going to do that is by using a folder here this folder is going to return to me sorry not this folder my bad this function this function is going to return to me a list that contains all of the background tiles that we need to draw so that's what we're going to do here with get background now what we want to take is the name sorry as I was saying the name is going to be the color of our background and that's going to allow us to change what background that we're using so the first thing we need to do here is load this background image now it's very important that when you run this file you run it from the directory that the file exists in now the reason I'm saying that right now is because the way I'm going to load this image relies on the fact that you're running this code from the directory that it exists in so see here that I'm in desktop python platformer and then notice tutorials inside of that directory that's why this is going to work if you try to run this code from a different directory say a CD to desktop and then I tried to run this then I'm going to get an issue so just make sure you're in the correct directory I just want to say that before we even get into this okay so I'm going to load my image I'm going to say image is equal to pygame dot image dot load and then what I'm going to do is join the assets path which is directly in the directory this file is in with the background uh path here if I spell background correctly and then with the name which is going to be the file name that I want to load which is really just the color of the background okay now that I have that I want to get the width and the height of this image so I'm not guessing what it is so I'm going to say underscore underscore with height is equal to image.get underscore rect now when you do this it will give you the X Y width height I don't care about the XY so I've just put two underscores here denoting that I don't care about these values and then I'm able to grab the width and the height so now that I have the width and the height I'm going to say tiles is equal to an empty list and then I'm going to Loop through um essentially how many tiles I need to create in the X and the Y Direction so I'm going to say 4i in range and then I'm going to take my width I'm going to integer divide this by the width of my tile and I'm going to add one and I'm going to do the same thing for my height here so I'm going to say 4J in range height over the height of my image Plus 1. okay so notice width here is the width of the screen height is the height of the screen I'm integer dividing this by the width of my tile and that tells me approximately how many tiles I need kind of in The X direction to fill the whole screen then just to make sure that I don't have any gaps I add one and I do the exact same thing for height in the y direction then what I'm going to do is say actually yeah I'm going to say rect uh is this wrecked no we're gonna say pause is equal to I multiply by the width and J multiplied by the height and this is going to denote the position of the top left hand corner of the current tile that I'm adding to this tiles list in pi game when you draw something on the screen you draw it from the top left hand corner so what I'll be doing is continually moving the positions based on how this for Loop is going right so for every eye for every J I'm multiplying it by the width and multiplying it by the height and that gives me the accurate positions I need to place every single tile in on the screen hopefully that makes a bit of sense but that's how this is working uh and then I'm going to say towels.append my position and then I'm going to return my tiles I'm also going to return the image so that I can know what image I need to use when I'm drawing all of these tiles okay now that I have my background I'm going to go into Main and I'm going to say my background is equal to get background and for the name I'm going to reference here in the background folder any of these images so we can use anyone we want it doesn't really matter I kind of like the blue one so I'll go with blue feel free to change this though on your end and there we go if I can type this correctly okay so I'm going to say background comma BG image like that and now I want to set up something that's going to draw my background so I'm going to make a function here and I'm going to say draw this is going to take in a window and for now it's going to take in a background and later it'll take in everything else we want to draw inside of here I'm going to say Pi game dot display dot update and before I do that I'm going to draw my background so I'm going to say 4 and this is going to be tile in background like that and then I'm going to say window dot blit and actually I need to take my BG image as well so let's take that and I'm going to draw the background image and then what I need to pass here is the position I want to draw it at which is going to be tile so what I can actually do is just convert this to a tuple notice the tile is going to be a list right tile is going to contain kind of my X Y position you can see that here right we're appending pause which is a list of x y and now that I think of it to make it easier let's just make this a tuple directly and now we don't need to convert it okay so in case anyone's confused what we're doing here is looping through every single tile that we have and then we're going to draw our background image at that position which will fill the entire screen with background images then what we're going to do is update the display the reason we update it so that every single frame we kind of clear the screen right and we don't have old drawings still on the screen you'll see what I mean in a second but this draw function is what we're going to do all of our drawing for now the only thing we need to draw is the background later it will be the player the blocks the obstacles Etc okay so now I'm gonna go inside of my wallet I'm going to call this draw function that we just created I'm going to pass window and then of course I'm going to pass my background and my BG image okay now this reminds me that I no longer need this background color we're not going to use that so I can get rid of that there okay so at this point assuming I've loaded the image correctly we're now going to see this tiling the entire screen so let's save and run and notice that we get it right it's tiling the entire screen looks pretty good to me and we can quite easily change this if we want by just going here and saying okay rather than blue I want yellow and then we say yellow and now we get a yellow background great so that's kind of the advantage of how I've done this here you can change the background to any color you want well given that it's in the background directory now that we have our background what should we do next well we probably want to put a player on the screen and start seeing some images for that player now the player itself is the most complicated aspect of this program there's a lot of movement going on with it so we'll start by just creating like a block for our player kind of move the block around have it jumping around then once we do that we'll do all of the Sprites and animations just so that we can get some more progress before we dive into that because it is a bit of work okay so let's go here and let's say class player we're going to use a class for our player kind of makes sense here and this class is going to inherit from pie game dot Sprite dot Sprite now I don't typically use Sprites when I'm working in pi game but I'm going to use them in this tutorial and the reason for that is that it makes it very easy to do Pixel Perfect Collision when we have two Sprite objects which we're going to have because we're inheriting from the pi game Sprite class we can use a method that tells us if these Sprites are colliding with each other so just understand that's why I'm doing this inheritance you don't have to understand exactly what the Sprite is but it kind of denotes that we have some properties on our class and then it allows these special Pi game methods to use those properties to handle the Collision for us so we don't have to write anything too complicated when it comes to the Collision although we still do need to handle it a bit okay so what we're going to do here is Define our initialization and we're going to take in a self an X Y width and height now the width and height will really be determined by the image that we're using for our player but for now since we're going to have like a block for our player until we add that image we're going to have a width and height now that reminds me that I just need to set a color for my player so I'm going to say color is 255.00 I'm making this a class variable just so it's the same for all of my players and I have access to it just right on the class okay now what I'm going to do is say self direct is equal to pygame.rect I'm going to pass my X Y width and height so rather than representing all of these values individually uh we're just going to put them on the rectangle and this is going to make it a little bit easier for us to kind of move the play around and do collision and all of that so erect really is just a tuple that's storing four individual values when I make it Pi game.rect it means we can use it in some kind of special equations and whatnot okay now for our player we're gonna have to have a few values uh the first thing we're going to have I'm getting a bit ahead of myself here but is going to be the x velocity and the next is going to be the Y velocity now the X and Y velocity is going to denote um what do you call it here how fast we are moving our player every single frame in both directions right so the way that we'll actually move our player is we'll just apply a velocity in a direction and then it'll just keep moving in that direction until we remove that velocity now this will be great for example for something like gravity or jumping um and you'll you'll see what I mean in a minute okay now that we have that we need to add something known as a mask for now I'm going to say the mask is equal to none and then I think that's all we need for right now so now that we have that let's add our first function here which is going to be the move function so move is going to take in a displacement in the X Direction and a displacement in the y direction and it's going to say the self.rec dot X plus equals the Direction X or displacement X sorry and self.rect.y plus equals the displacement y now if we want to move upward down or left or right we just change the sign of this DX or d y right okay so now we have a move next what we want to do is create two functions one for moving to the left and this is going to take in the velocity we want to move in the left Direction and the next is going to be moving in the right direction again this is going to take in self and Vel now to move left what we're going to do is say ourself.x velocity is equal to and then this is going to be negative velocity and then to move to the right we're going to say self.xfel is equal to Vel now the reason we use negative velocity here is because if we want to go left we have to subtract from our X position in pi game remember our coordinate system is that 0 0 is the top left hand corner of the screen so if I want to move down I add to my ycoordinate and if I want to move to the right I add to my x coordinate so if I want to go up I subtract y if I want to go left I subtract X so that's why I'm putting a negative Val here I know it seems a bit weird how I've just done move and now I'm saying move left we're going to have negative don't worry you'll see how this works in a second next I'm going to say if self dot Direct action does not equal left then self Dot Direction is equal to left and I'm going to say self.animation count is equal to zero now we're not going to use these right now but I just want to add them in um for now at least and you'll see why in a second now I'm also going to say appear yourself dot direction is equal to left and the reason I'm adding this direction is because I need to keep track of what direction my player is facing so later once I have my Sprites I know if I'm showing the animation to the left or I'm showing the animation to the right now the animation count uh we're resetting that when we change directions and the reason we're doing that is so that the animation doesn't look all wonky when we go from going left to right so we need to kind of reset the count that we're using to change the animation frames again you're going to see that later as we go through the tutorial now I've just added up here um self.animation count equals zero just to make sure we don't get any weird errors later so now I have my direction and my animation cap perfect okay now I'm going to copy this I'm going to put the same thing in move right and I'm going to change the direction here to say right and then right so now we know what direction we're facing at all points in time okay perfect next what we need to do is we need to have some kind of draw function and we also need to have what I'm going to call the loop function and in fact let's do the loop function first so I'm going to say Define Loop and inside of here I'm going to take in self and FPS now what Loop is going to do is be called once every frame when I say frame that's really one iteration of the while loop and this is going to move our character in the correct direction and handle things like updating the animation and all of the stuff that we constantly need to do for our character so for right now I only care about moving in the X Direction we'll handle the jumping later so what I'm going to do is just say self.move and I'm going to say that we're going to move based on our x velocity and our y velocity now notice we're updating our x velocity here when we move left or we move to the right so now if we call Loop and we have some velocity in the X Direction it's going to move our character to the left or to the right okay again all this will start to make sense as we get through the tutorial there is a lot of stuff I need to do kind of up front before I can just show you instantly so hopefully you guys are following along but I just want to note we eventually of course will see how all this works I'll walk through the code so no worries if it's a bit confusing right now now what else do we need to do inside of the loop well we need to update something known as The Mask which I'm going to get to in a second but before we can do that we need to Define uh what's known as our image so I'm going to say Define and this is going to be draw and this is going to be the function that handles drawing on the screen and for draw we are going to take in our window which I'll just represent with win now what we'll do for now is we'll just say Pi game dot draw dot rectangle we'll draw the rectangle on the window which is the first argument here it's where we're drawing it the second argument is the color which is going to be self.color then the last is the rectangle so I'm going to say that is self dot rect now notice the react here right has our XY width height and when we move we're updating the X and Y of the rectangle which will then change where we're drawing it if I can find it here on the screen okay so that's what we need for drum now actually for now I think that's okay uh we will add to this obviously in a second but I think we can generate a player draw the player see it moving and then go from there so let's do that so let's go to main here I'm going to create a player I'm going to say player is equal to player I need to pass an x a y and a width and a height so I'm going to pass let's say a hundred and let's make him 50 by 50. and then what we can do now is pass our player to the draw function we can then take player inside of here and we can say player don't draw and we can pass the window okay so I will move the player in one second but for now let's just see if this is working if it's going to show up on the screen so let's run the code and notice that now we have a red rectangle in the top left hand corner obviously nothing's happening right now because we're not moving it around the screen but you could see it's showing so we have our player we're drawing the player on the screen now we want to start using some of these methods Right Moving left moving right Etc so I want to separate my movement into a function so I'm going to say Define handle move like this and for this right now we'll just take in the player now inside of handle move what we're going to do is essentially check the keys that are being pressed on the keyboard if you're pressing left or you're pressing right then we'll move the character to the left or to the right eventually we will check for collision and we will do all of it so I'm going to say key is equal to pygame dot keys actually not keys.key DOT get underscore pressed this tells you all of the keys on the keyboard that are currently being pressed and I'm going to say if and actually this is going to be key really we should call this Keys though because this makes a bit more sense so we're going to say if keys and then this is pygame dot k underscore left this is the left Arrow key if you wanted to use the a key then you would use a like that uh yeah actually I'll go with left Arrow key because that's what I usually do but you can use a or swap it however you want and then I'm going to say if this is the case then player dot move underscore left and how much do I want to move the player bikes we have to pass the velocity well this is going to be my player velocity right okay next I'm going to say if keys and this is pygame dot k underscore right then I'm going to say player dot move underscore right again same thing I'm going to move this by my player velocity now it's important that before I do this I set my player velocity to be zero now the reason this is the case is because if I don't do this what will happen is as soon as I move left this is going to set my player velocity right which you can see here my X Val it's going to set the x velocity now once I set that I'm going to continue moving in that direction until it gets set back to zero so if you wanted to make it so when you press a key you just continually move in that direction until you press a different key then you could omit this but in our case we only want to move while you're holding down the key so I'm going to say player.xval equals zero there's a lot of other ways to go about doing this but I just wanted to stay consistent with our movement because of how we're going to do the gravity so for now just bear with me we essentially set the velocity to zero and then if we are moving left or right so if we're pressing these Keys then we change the velocity to be you know the negative player velocity or the positive player velocity based on the direction we're moving in okay that's actually all we need for handling the movement so let's put the handle movement function uh where are we going to put this we're going to put this before we draw so I'm going to say handle move I want to pass my player all right now I need to make sure before I do this that I call my Loop function okay and I pass my FPS and the reason I need to call Loop is because Loop is what actually moves my player right if you look at loop it's moving my player in the x velocity and Y velocity direction every single frame so if I set the x velocity well then I continue moving again if I set the Y velocity I move in that direction but that only works if we're continually calling this Loop function okay good so we've made great progress so far let's see now if we can move our player or if I've made any mistakes which are very likely so let's run the code and let's see okay so I'm going to hit my right arrow key you can see I can move to the right and I can move to the left obviously if I wanted to go up and down I could Implement that but we want to have it jumping which I will show you uh in a second but we kind of need Collision before we can do jumping very good all is looking great so far now let's Implement gravity so we kind of fall down then we can do uh kind of the Sprite sheets then we can do the Collision because the Collision makes more sense I guess once we have the uh the Sprite sheets done so let's Implement gravity now gravity is a little bit complicated because we want to have um like kind of a realistic gravity right that actually implements some basic physics what I mean by that is rather than just having a constant velocity we want to actually have an acceleration for our gravity so as many of you know if you're in physics gravity um the acceleration is negative 9.8 meters per second squared I believe that's what the acceleration is anyway in our game we want to emulate something similar to that where it feels like the longer you're falling the faster you fall you're not falling at a constant speed that makes the game just feel like really really unrealistic so the first thing we need to do is pick some value that we want our gravity to be and this is the acceleration of gravity so keep that in mind so for this I'm going to make a variable in my player class because it's the only place we need it right now I'm going to say this equal to 1. so gravity is equal to one if you want gravity to be faster obviously you increment this value right make it large okay now inside of loop this is where we need to handle our gravity so every single frame in our loop we're going to increase the Y velocity by our gravity however how we know how much to increase the velocity by varies on how long we've been falling for again I know this seems really weird but we essentially need to keep track of how long we've been falling so that we know how quickly we should be increasing our velocity or how quick we should be accelerating downwards so that means that I need to create a variable here called self dot count and given we should really call this something better I'll call it fall count and this will um essentially tell us okay how long have we been in the air for how long have we been falling and we'll use this value to determine how much we um increment our velocity by so I'm now I'm going to say myself.w underscore velocity and I'm going to add to this the minimum of 1 or and I'm going to take my self.count and this is my fall count divided by the frames per second multiplied by the self.gravity now this isn't truly what the acceleration would be but this will give us like a kind of somewhat realistic looking gravity in the game so just bear with me here so what we're doing we're taking our fall count we're dividing it by FPS the point of this is that if I want this value to be in seconds then I need to take whatever my count is which I'm going to increment every single Loop in fact we'll do this right now plus equals 1 and I divide it by FPS so if my FPS is 60 as soon as this is 60 then I've been falling for one second I take that amount of time I multiply it by my gravity and then that tells me how much I'm going to increment my y velocity by however this is going to start out being really really small just like fractional decimal decimal amounts so just to make this a bit easier for us when we do our Collision I'm going to increment this by the minimum of 1 or this value so every frame we're moving at least one pixel down and it doesn't take us like a full second before we really start feeling any effect of gravity hopefully uh that makes a bit of sense you guys are understanding me here but just bear with me I've uh experimented with these numbers quite a bit so I think this should be fine okay so now that we have this what should happen when I just click run here is I should just start falling immediately on the screen and obviously until we have some platforms or Collision we can't really stop falling if we have gravity uh but let's have a look and let's see how it works right now okay so you can see that I've fall and notice I'll do this again that I start falling slowly and then it picks up the pace right so this is somewhat realistic to how gravity would actually work and that's what I was trying to implement when I did this now that we have done that it's time to move on and have some kind of Sprites or images I was going to do this later but I realized that we can't really do the Collision which is going to be Pixel Perfect Collision until we have some kind of images that's that's really what we need we need our Sprites so what we need to do here first is examine what our Sprites look like for our characters now remember all these characters pretty much the exact same they just look different but in terms of their movements their animations number of images they're identical so whatever I show you for one of these is the same for all of them hence why we can just kind of swap them out so when I go to mask dude here let's zoom in you can see that we have for example double jumper I just picked a random Sprite sheet now this sheet has six different animations or six different frames which represent what this guy's going to look like while he's kind of jumping or double jumping in the air so what we need to do is we need to split this one image into the six individual images and then Loop through those images at some frequency or some time so that we can show them on the screen and show in an animation right we need to kind of manually do this now some of these are single frames like falling is just single frame that's easy hit okay this is um like you know the guy disappears for a second kind of expands goes back you get the point where you want to Loop through these animations idle single frame actually no idle is not a single frame it's a bunch of frames this guy's arms are kind of wagging up and down we have jump a single frame run a bunch of frames and then wall jump now notice here with these images that they're in different directions or let's say they're all kind of facing right so another thing we're going to have to do is rotate this image to face left when our character is facing left so that's another thing we have to handle that not only do we just have to split these images up we also have to get a rotated version of them so that we can show you moving in a different direction same with jumping same with being idle like whatever Direction you're going we need to show the image flipped in that direction uh so not rotate sorry flip that's what we're gonna do okay so let's do this first thing I will do actually is I'll write the function that will flip our image so I'm going to say flip Sprites this is going to take in a list of Sprites and I'm going to return High game dot transform dot flip and this is going to be Sprite true false notice as it says here this is indicating what directions you want to flip in when I pass true this means flip in the X Direction when I pass false this means don't flip in the y direction if you want to flip both you'd pass true twice but we don't want to do that so I have Pi game.transform.flip Sprite and then this is going to be four Sprite in Sprites really I could call this image but you get the point okay so we have flip now we're going to write a function which is load Sprite sheets and should we call it sheet or sheets I think sheets is fine and what this is going to do is load all of the different Sprite sheets for our character so it's going to give us the spreadsheet for double jumping for hitting for falling and then within our character we can pick what sheet we want to be using and what animations we want to Loop through so I'm going to take in directory 1 and directory 2 and the reason I'm doing this is so that I can load other images that aren't just my characters and this will be very dynamic I also want to take in the desired width and height of my image and if we need to load multiple directions so I'm going to say Direction equals false as a default parameter so that we only load like the left and the right side images like we flipped the images if you pass this equal to true okay now the first thing we need to do is determine the path to the images we're going to be loading so I'm going to say join assets der one dir 2. notice I can use join because I imported this from os.path okay now I'm gonna get all of the images in this directory now the way I do that is a phone I'm going to say images is equal to and this is going to be f for f in list directory again notice I can use that because I import it here we're going to list all of these things that are inside of this path directory and then we're going to say if is file and then this is going to be join path and F so what this for Loop is going to do here this uh I forget what you actually call this when you write a for Loop in a list anyways what this line is going to do here is load every single file only file that is inside of this directory so again we're just going to get every single one of these file names and then once we have those file names we can load that image and we can then split that image up into the individual images that we want okay so we have images now I'm going to say all Sprites is equal to a dictionary and what I'm going to do with this dictionary is have key value pairs where the key is the let's say animation style and the values all of the images in that animation okay so I have all Sprites and I'm going to say for image in images and I'm going to say that my Sprite sheet so the individual Sprite sheet I want to load here is going to be equal to pygame dot image dot load and then this is going to be join path and image and then dot convert Alpha which is essentially going to allow me to load a transparent background image okay so we are loading the image which is just one of the files that we found right from this path and we just need to append the path to it right so whatever the path to the directory is plus the image name okay we're going to load that in we're going to get the transparent background now that we have this we need to get all of the Sprites in this image so I'm going to say Sprites is equal to and now this is going to be a list okay so again the processes load all of the different files okay we have all the files these are sprite sheets now we need to get all the individual images from the Sprite sheet and load those okay so I'm going to say 4i in range and then this is going to be Sprite sheet dot get underscore with integer divided by the width of the image that we're loading now width is going to be the width of an individual image inside of our animation or inside of our Sprite sheet so if I know this is say 32 pixels I pass 32 and then it gives me a bunch of images that are 32 pixels wide that's how I'm doing the loading so that's why I took width and height here okay now that we have that we're going to say surface is equal to High game dot surface and then this is going to be with height we're going to pass Pi game dot s r c Alpha which allows us to load again transparent images and then I'm going to pass 32 here which is the depth don't worry about that but this is what we need to load these images and now we need to create a rectangle which is going to tell us where in this image again image being the Sprite sheet that we want to take an individual image from and BLT it onto this surface I know this seems really weird what we're doing is we're going to create a surface that's the size of our desired individual animation frame we're then going to grab that animation frame from our main main image we're going to draw it onto the surface and then we're going to kind of export that surface that's the way that we have to do this so I'm going to say rectangle is equal to Pi game Dot rect and for the rect this is the location on our original image that we want to grab this new frame from so I'm going to say this is I multiplied by my width and then 0 and then the width and the height of my image okay now that I have that I'm going to say surface.blit blit really means draw and I'm going to draw my Sprite sheet but I'm going to draw this at 0 0 and I'm only going to draw the portion of it which is my rectangle so notice this is my source this is the destination and this is the area of my source that I'm drawing so in position 0 0 which is the top left hand corner of my new Surface I am drawing my Sprite sheet but I'm only drawing the frame from my Sprite sheet that I want okay then I'm going to say Sprite start append and I'm going to append my Surface but I'm going to make my Surface Two Times larger because that's what I want to do I want this to be bigger than the default size so I'm going to say Pi game Dot transform dot scale to X and then I'm going to scale to X my Surface okay again I know this seems a bit complicated but now we have essentially stripped out all the individual frames we've just scaled them up to be double their size so if they're 32 by 32 we've made them 64 by 64 that's what scale 2x does and now we need to handle the directions okay so now we need to say if Direction then all underscore Sprites and this is going to be image dot replace it's going to be dot PNG this is going to be an empty string plus underscore right is equal to our Sprites and then we're going to copy the same thing let's copy this and put it here and now this is going to be underscore left is equal to and this is going to be flip Sprites so what we're saying here is if you want a multidirectional animation then we need to add two keys to our dictionary here for every single one of our animations so for falling for hit for idle we need a left and a right side so the right side is the one that we already have so we're going to say okay all Sprite at and then we're just going to strip off the dot PNG from whatever the name of our base image was so that's going to give us run jump idle hit whatever the name of our files and then we're going to append underscore write or underscore left now for underscore right that's our basic Sprites for underscore left we need to flip all of those Sprites and we already wrote the function that did that now otherwise then what we'll do is say all underscore Sprites at image dot replace dot PNG with an empty string this just removes the dot PNG and then it's going to be equal two Sprites okay then we can return all of our Sprites all right probably one of the most complicated aspects of the code that we need to write so don't worry we are done now with loading images at least we'll have to load our block but that's going to be a lot easier than loading our Sprite sheets so this now will load a Sprite shoot for us now that we've loaded our Sprite sheet we actually want to start using this so inside of player we are going to grab our images so I'm going to say my Sprites is equal to and it's going to be load Sprite sheets and now I need to pass what I want to load so now I need to pass the main character directory and actually this is the main characters okay so have a look here so inside of assets right uh yes so we're joining assets with dur1 and dirt 2. so the first directory I pass is main characters and then I pass the second directory which is the name of the character I want to load so mask dude ninja frog pink men or virtual guy you can pick whatever one you want I'm gonna go with mask dude for now now for width and height uh the width and the height of this is going to be 32. so make sure you do this 3232 and then you pass true because we want a multidirectional Sprite so both the left and right side animations that's what we want okay now that we have that we are going to change our draw here so that we're drawing our Sprite now for for now we're just going to draw like one simple Sprite just so you see how it looks on the screen then I'll go through animating the Sprite and showing you how that works okay so rather than pygame.draw.rect I'm going to say self.sprite is equal to and then this is going to be self dot Sprites at idle now idle is one of the name of our animations right so if we go here you can see we have idle jump Etc so I'm accessing the key from my dictionary and then I'm going to access the first frame of this key which is zero because every single key is a whole like Sprite sheet right so now that I have my Sprite I'm going to say window blit and then this is going to be self.sprite and I'm going to blip this at self.rec dot X and self.rec.y which is the position on the screen and then if we want we can just turn off the gravity for right now so we can kind of see it on the screen it doesn't just disappear okay let's try this out let's just make sure it actually loaded correctly so let me run this and we got an error okay so let me see what error we got here um run this again it said key key error idle okay so the issue here is that since we load a directional Sprite we need to reference either idle right or idle left so we can actually do this by saying idle underscore Plus self dot Direction and then so long as we set the direction which we did here to left uh this should work so now it'll change based on if we're going left or right so actually you'll see that it should swap as we change directions okay let's try this now all right so now we have this guy facing left if I go right he turns right left right perfect now we want to see him animated so as I was saying let's get into the animation now this is actually going to be pretty easy because we've already loaded in all of the frames that we need so I know that we don't have a ton to show right now but a lot of the hard stuff is done for this video so just making you aware that all this time has not gone to waste what we need to do is we need to come up with something that has a way to kind of update our Sprite or update what we're showing on the screen so I'm going to write a function here called update Sprite and I'm going to take in self and I'm going to say Sprite sheet is equal to idle now this is the default spreadsheet if we're not moving if we're not jumping if we're not falling if we're not being attacked we use idle however if we are running or we're doing something else then we use the other spreadsheet so now I'm going to say if myself dot x velocity does not equal zero then my Sprite sheet is going to be equal to run so if I have some velocity in the X Direction then I'm running right so then I want to change this to the Run spreadsheet so now I'm going to say my Sprite sheet name is equal to and this is going to be my Sprite sheet plus and then underscore and then plus the self dot Direction perfect so now we just change the main Sprite sheet name so idle run jump whatever we add the direction to it and this tells us you know what exact Sprite shoot we want okay now that we have that what we're going to do is say these Sprites that we could be using for this animation is equal to self.sprites and this is in all capitals at the Sprite sheet name all right now that we've done that we need to essentially iterate through these Sprites and every few seconds change the Sprite that we're showing so it looks like we're animating so we need to add a variable here that is going to account for the amount of delay between changing Sprites so I'm going to call this the animation delay I'm going to make this equal to five okay now I'm going to come here and I'm going to say that my Sprite index which essentially a Sprite that I want to be using here is equal to my self.animation count which we're going to increment in a second integer divided by my self.animation delay modulus by the length of these Sprites that I'm using now let's just put some parentheses here for order of operations and let me explain what we're doing so we have an animation delay that's every five frames so every five frames we want to show a different Sprite in whatever animation we're using so if we're running left if we're idle whatever it doesn't matter we want to show a different one so we take the animation count we divide it by five and then we mod whatever the line of our Sprites is so if we have five Sprites then when we're on say animation count 10 we're showing the second Sprite right you get the idea so this is dynamic this will now work for any single Sprite so hopefully you guys understand how this animation count is kind of working but we're just trying to pick a new index every animation frames from our uh Sprites but we want this to be dynamic so we're using the length of the Sprites and again it's just it's dynamical work for any single Sprite sheet we have now we need to select our Sprites we say self.sprite is equal to the Sprites that we have access to at the Sprite index then we update our animation count by one now what we can do is remove this here from draw and we just need to Now call the self Dot update sprite from our Loop okay so now that we've done that we'll call this we'll update our Sprite every single frame and then we'll draw that updated Sprite on the screen okay let's run it and let's see what we get notice we have idle notice I can run to the right and I can run to the left now if you think this is too slow and some of you may argue that it is then you just make this number smaller so make this three okay and now it looks like we're running a little bit faster so it's completely up to you how you want to animate this um I'll do two for now and let's see if this looks better so actually I think three was a pretty kind of happy medium here so let's go back to three again you guys can change this is up to you how you want it to look okay now that we have that we're almost ready to start doing Collision however we need to introduce something known as a mask so I'm going to make another method here I'm going to say Define update now what we need to do here is essentially update the rectangle that bounds our character based on the Sprite that we're showing so there's different um like kind of sizes to the Sprites right some are a little bit taller some are a little push to the left or pushed to the right and the rectangle that we have we want to be essentially the same as the Sprite that we have again I know this seems a bit weird but we're going to do this we're going to say self.rect is equal to self Dot and then it's going to be Sprite dot get underscore rect and we're going to say that the top left of this rectangle is equal to the self.rect dot X and the self.rec dot y now pretty much what's going to happen here is depending on what Sprite image we have if it's slightly smaller slightly bigger whatever we're going to constantly adjust the rectangle specifically we're going to adjust the width and the height of it but we're going to use the same X and Y position that we've had for this rectangle if you don't understand that um it's fine it's not a massive deal this line is not crazy important but it's just trying to make sure that the rectangle we're using to kind of bound our character is constantly adjusted based on the Sprite that we're using now what's more important is this line which is updating the mask we're going to say self.mask is equal to pygame dot mask Dot from surface and this is going to be self dot Sprite now let me quickly explain this a mask is essentially a mapping of all of the pixels that exist in the Sprite so whenever we draw something on the screen we're really drawing a rectangle right but the rectangle may not have um nontransparent pixels right so only part of the rectangle is actually filled in hence why we get kind of a circular image a dynamic image whatever so what this mask tells us is where there's actually images or where's this actually pixels sorry and this mask allows us to perform Pixel Perfect Collision because we can overlap it with another mask and make sure that we only say two objects Collide if pixels are colliding not if the rectangular box is colliding if we did rectangular Collision then it constantly looks like we're hitting something even when we're not because the rectangle for our character is larger than where all of the pixels for our character are you've probably seen this in a lot of games before but what the mask does is solve that problem for us and allow us to do this kind of Pixel Perfect Collision it's very important though that you you call this mask if you don't do that this Collision is not going to work properly it needs to be masked because the Sprite that we inherited from here uses this rectangle and uses this mask property when it does the Collision all right so now that we've done this I just need to call this function so I'm going to go here and say self dot update and now we're done with most of what we need for the player so what we want to do now is we want to start adding blocks onto the screen and then letting a player fall collide with those blocks and then be able to jump because obviously we can't really jump until we have something to jump off of otherwise jumping in thin air doesn't make a ton of sense alright so let's create another class here and this class I'm going to call object and this will be a base class that we use for essentially all of our objects just so that the Collision will be uniform across all of them so again we're going to inherit from the Sprite class from PI game and we're going to Define our initialization so to find a knit we're going to take in self X Y width and height and name which for now is going to be equal to none but could be equal to something we're then going to say super dot underscore underscore knit which will initialize the superclass which is this one right here now that reminds me we need this as well in our Constructor for player so let's put that in player okay now we need to define a rectangle so we're going to say selfdirectangle is equal to Pi game Dot rect and then this is going to be x y width and height we're going to say self.image is equal to Pi game dot surface and then this is going to be width height and then we're going to say Pi game dot source Alpha like that if we spell Pi game correctly again this just supports transport transparent images for us my apologies and then we're going to say self dot width equals width self.height is equal to height and self dot name is equal to name where are they going to say Define draw I'm going to say self and window like this and then we're going to say win dot blit and this is going to be self.image and then we're going to blip this at the self Direct dot X and the self.rect.y okay I know I went fast essentially this is just a base class we're not actually going to instantiate this but this just defines all the properties that we need for a valid Sprite so we have a rectangle we have our image we are drawing the image and then in a class that we're about to use we're going to inherit from this and it will just save us from rewriting a bunch of functionality that we don't need so the idea here is that all we do is modify this image when we change the image now the draw function will automatically draw it accurately on the screen for us and all these other properties we're just saving in case we need them from our child class so I'm going to make a class now called block this is going to inherit from object now we're going to say Define a net and we're going to take in self x y and the size of our block now since the block is a square we just need one dimension not two right okay we're going to say super dot underscore underscore knit and we're going to pass x y size size so notice this Constructor requires four arguments so we have to pass four here we just duplicate size because it's the same for the width and the height then we're going to say block is equal to load block which is going to be a function that we write in a second that will take a size we're then going to say self dot image dot blit imagine that this is going to give us an image okay which it will in a second when we write it we're going to blit the block at position zero zero and then we're going to say the self.mask is equal to High game dot mask Dot from surface we're going to take our self.image and there you go we have our mask which we need for Collision again I know this is a little confusing it'll make more sense in a second but we're using this object which now has this draw function built in for us it also defines the rack that defines the width and the height and all of that stuff here what we do is we get the image that we need which we're going to write this in one second then we BLT this image to our image which is a pi game surface and then we say self.maski we'll do pygame.mask Dot from surface self.image we also could just say self.image is equal to the block but let's do it this way for now okay so let's now write our get Block function which I'm going to do beneath our get Sprite sheet or load Sprite sheet so I'm going to say get Block and I'm going to take in a size now what I need to do here is essentially find the block that I want in my train folder so I'm going to say path is equal to join assets and then this is going to be terrain like so and then we're going to use the terrain.png file so if I go here you can see that we have train terrain and then what we want to do is load this block which I'll be showing you how to load in one second okay now that we have done that now that we have our path we're going to say the image is equal to Pi game dot image dot load and we're going to say path again dot convert Alpha so that we get a transparent background we don't really need it for this one but just in case later we load something does have transparency we will and then we're going to say surface is equal to Pi game dot surface and for the surface we're going to pass size size which is the width and the height of our surface we're gonna pass pygame DOT Source Alpha with a depth sorry of 32. we're going to say rectangle is equal to pygame Dot rect and then this is going to be 96 0 size size now let me slow down for one second if we go to Terrain we can see that we want to load this guy right here now I've already done the math this image starts 96 pixels from the top of the screen so that's the reason I'm putting 96 there because I want to start at 96 so 960 is my position and then I want to load the size of this which I think is going to be either 96 or 64 or something along those lines anyways if I wanted to load say this terrain image then I would still have 96 but my y position would be different in fact the Y position would probably be a little bit less than 96 it might be 80 it might be 85 I'd have to like experiment with it to see exactly where this image starts but I just want you to understand that what I'm passing here when I say something like 960 I'm passing the position that I want to load the image from from the image right so I'm picking out a part of this image and this is like 96 0. that's where I'm picking it right here hopefully uh you guys understand that but if you want to load a different train image then you have to adjust these to be the starting position the top left hand corner of whatever image it is you want to load here and if yeah I was going to say we could load a different one but I don't want to waste time guessing which one it is so you guys can mess with that if you want but let's just load this top one which I already know works okay now that we have that we're gonna say surface dot Blitz and we're going to Blitz the image and again we're going to BLT it at 0 0. but we're only going to blit the area of it which is represented by the rectangle then we're going to return pygame Dot transform dot scale 2X surface Okay so we've passed what size we want our block to be then we create an image that is of that size okay we then say rectangle is equal to 96 0 size size right and then we BLT this image onto our surface which will be the image that we return and we return this scaled up by two times so it just doubles the size that we pass here you don't have to scale it if you don't want but I want it to be larger so I am scaling it now I understand again it's a bit confusing this size is going to be the dimension of this block so you want to pass whatever the size from this Sprite sheet is that you want to get in our case I think it's going to be 64 or something along those lines so that's what size will be you guys can mess around with this but really what you're going to be changing is these two values and the size that's what you're going to change when you want to load a different image for your block okay so now for Block we have get block or load block uh did I call it load block or get Block I called it get Block okay so let's change this to be get Block all right so we now have our block let's create a block let's draw a block on the screen and let's do some collision with our blocks okay so let's go here to Main and let's say blocks is equal to and let's just start by creating a single block so for our block uh let's just put it kind of randomly on the screen for now uh where do I want to put this let's go with something like actually I'm going to create a variable first I'm going to say block size let's put this at zero height minus the block underscore size block size is going to be equal to 96 okay and then 4 B size we're going to pass block size okay so the size of our block is actually 96 I lied it is not 64. it's going to be 96. so we're going to create a block it's going to be positioned at zero height minus block size which is going to put it at the bottom of the screen and then the size is this now we need to draw our blocks so I'm going to pass blocks to my draw function okay and I'm going to go here and actually let's call this objects and we're going to say form objects or for obj in objects if we could type this correctly obj dot draw I'm struggling here with the typing and we will draw this on the window okay so we have our block now let's quickly look at this again right we load our image okay we get our block we have our size now we create the block down here and then we put it on the screen let's run it and let's see if we got a block and of course we've got an error what does it say here I need to run this again I take zero positional arguments but one was given okay so let's go to our player class here and we can see update I forgot to add the self parameter so let's add that in and that should fix it okay so now you can see that we have a block so now what we can do is create a whole floor of blocks if we want to do that and then we'll Implement gravity and then collision with the block so that you can see that you like can land on the Block and we can jump off of the block all right so let's make a whole floor so to make a floor we can do this we can say floor is equal to we're going to say block it's going to be I times block size it's gonna be height minus block size block size 4 I in range and I'm going to say negative width width times two um and we're going to divide this by the block size and by the block size okay then for my blocks uh let's actually just replace this and instead we'll just pass floor okay what I've done here with this for Loop is I've said I want to create blocks that go kind of to the left and to the right of the screen so I don't want to just fill the current screen because we're going to have a scrolling background in a second which we'll Implement in a minute anyways I want to have some kind of going to the left and so I'm going to the right so I'm taking my negative width uh over the block size which is how many blocks I want to the left side of the screen and then I'm taking my width times 2 and I'm interested dividing that by the block size again that's how many blocks I want to the right of the screen then I'm taking I I'm multiplying it by my block size which is telling me the x coordinate position that I want my block to be at and then this is always going to be the same because I want it to be at kind of the bottom of the screen and then for my block size well I want that to always be the same okay so let's run this now and see what we get and now we get a bunch of blocks so now that we have these blocks let's make it so we can collide with the blocks and so we have gravity and we actually fall onto those blocks so the Collision all right Collision is a little complicated but let's write it and let's see how we can how we can get it going here so inside of handle move is where we're going to handle our Collision which means we need to have a list of objects that we can potentially be colliding with now we are going to write a function here called handle vertical Collision because we need to handle the vertical and horizontal Collision differently for now we'll just start with uh vertical and we're going to take in player objects and the displacement in y that we just moved now we're going to have collided underscore objects is equal to a list we're going to say for object in objects these are all the objects we could be colliding with and we're going to say if High game Dot Sprites dot Collide mask and then we're going to pass our player and our object now remember I told you Collision was going to be simple well there you go this is all you need to do to determine if two objects are colliding the reason we can do this is because our objects we've inherited from the Sprite class and on them we have a mask so we're going to use this mask property as well as the rectangle property when we collide with the mask so I pass my player I pass my object and this will tell me if I am colliding with my object perfect now if I am I'm going to do some stuff differently depending on what direction I'm colliding in so if I'm hitting the top of the object it's going to be different than if I'm hitting the bottom so we need to handle that here so I'm going to say if my displacement Y is greater than zero really this should be velocity but that's fine then what I'm going to do is place my character on top of the object it collided with so I'm no longer colliding with it now what this is saying is if I'm moving down on the screen so if I'm moving down then that would mean I was colliding with the top of this object so if I am I'm going to take the bottom of my player rectangle which is my bottom my player's feet essentially and I'm going to make it equal to the top of the object I'm colliding with this is another advantage of using rectangles you can use this kind of bottom and top property and avoid having to do you know add the height and all that kind of stuff so that's what I'm going to do now otherwise I'm going to say if my displacement Y is less than 0 and I suppose this can be an L if then what I will do is say myplayer.rec dot top is equal to the obj.rec dot bottom because if I'm moving up which means I have a negative velocity then I am hitting the bottom of an object so I need to make my top be equal to the bottom okay this just makes it so you don't like say stay inside of the object excuse me you go outside of it and it looks like you collided but you didn't go through the object now one thing we also need to do here is we need to call the method player.landin and player.hit head which I've not yet created and we're going to write these to handle what happens when we land on a block and when we hit our head on a block okay then we're going to say collided objects dot append and we're going to append our object and we're going to return our collided objects just so that we know what objects we collide with so that we can check if we collided with like fire or a certain special object or something like that okay so let's handle vertical Collision now we need to write the uh landed and hit head method so let's go to player and let's do this so I'm going to say let's do it here landed self now what do we do if we lend it well if we just landed then we need to reset our gravity or our fall counter so we're going to say self dot fall count is equal to zero so that way we stop um like adding gravity right okay what else do we need to do if we land it we need to say that our y velocity is equal to zero if we let it on a block stop moving us down and I'll add this in now we're going to say our self.jump count is equal to zero we're going to do something with jumping that involves double jumping so we'll have a jump counter I'll just put this here now and then we'll we'll use it later okay so that's if we landed otherwise I'm going to say Define hit head for self I'm going to say self.count equals zero but if we hit our head I want to reverse our velocity so that now we move down because we're moving up right so I'm going to multiply my velocity by negative one so when I hit my head I kind of bounce off the block and go downwards that's what's going to look most natural okay so that's all we need for right now for hitting the head now we can add our gravity back and when we add our gravity back what's going to happen is we'll fall we'll hit the block I'll move us to the top of the block and then we should just be able to move on top of the block let's see if that's going to work though uh although it's not gonna work if we don't add the function call so let's add the function call here in handle move we're going to say handle vertical Collision we'll pass the player the objects and the player.y velocity and the Y velocity is essentially how much we just moved right okay very good now let's make sure handle move we need to pass our floor so let's do that all right let's run the code let's see what we get and boom look we land on a block and we can now run on top of the block and everything is looking very good to me okay so that's pretty good now that we're on top of a block we can jump and then we can deal with uh hitting blocks um what do you call this uh horizontally right so that we can't like run into a block and we'll also make the background scroll and then we'll be pretty good we'll have a lot of this tutorial finished I wanted to make us jump yes let's make it jump okay so let's go to our player and let's create a variable here self.jump underscore count is equal to zero now based on the way we've coded this jumping is actually quite easy I can say Define jump self and when we jump all we're going to do is say self.y underscore velocity is equal to the negative of selfdog gravity multiplied by whatever Factor you want in terms of the speed of your jump so I'm going to multiply Gravity by eight the reason I'm doing this negative is that I jump up in the air right so now that I've done this what will happen is as soon as I hit the jump key I'll jump up into the error it's pretty straightforward and the reason that's going to happen is because my y velocity will change and what will bring me down is the fact that inside of my Loop if I go to where Loop is I'm constantly applying downward gravity so what I'm doing is changing my velocity to go upwards and then I'm letting gravity take me down so that's kind of the benefit of how we've coded this jumping is very easy now I'm also going to reset my animation count to zero I'm going to say my jump count plus equals one I'm going to say if the self dot jump underscore count is equal to one this means that I'm double jumping so if the jump counts equal to one when I hit jump that means it's just going to be equal to 2 now actually let me take this sorry and put this down here then I will say self.count is equal to zero yeah I think does that make sense no I want to do it this way sorry okay so what I'm trying to do here is make it so that as soon as I jump I essentially get rid of any gravity I've already obtained so let's say I was like falling and then I landed and then I jumped there would be some gravity on me keeping me on the ground so I want to remove that gravity so that when I jump up it's not in uh the factor it's like it's not taken into account and then I'll start applying the gravity after I've jumped hopefully that makes a bit of sense but this should say fall count so as soon as I jump I'm resetting the fall count to be equal to zero so that any gravity I've accumulated I'm removing but I'm only doing that if this is the first jump I'm making because for the second jump I want you to have to time it based on like when you're jumping right so if you jump a second time close to when you jump the first time you will jump higher than if you jumped at like the peak of your jump when your gravity would be the highest okay I don't know if that makes sense but just just follow along here this I messed with this before this works trust me all right so we have jumping now I think that's all we really need for jumping um yeah that seems good to me so now if we want to jump let's make it so when we hit space we jump so we can do that inside of handle move actually I'm not going to do a handle move I'm going to do it here in the event Loop and the reason for this is that if I do it in handle move what's going to happen is if I press the jump key and I hold the jump key down I'm going to keep jumping a bunch of times I don't want to do that I just want to jump once when I hit the key and then I have to release the key and press it again to jump this tells me if I'm holding down the key what I'm going to do in here tells me if I released the key yeah you'll see um but yeah this is this is how I do it so I'm going to say if event DOT type is equal to pygame Dot key down I'm going to say if event dot key is equal to Pi game dot k underscore space and my player dot jump count is less than two so I'm going to allow double jumping right so I'll have two jumps then I'm going to say player dot jump okay that should be all we need for jumping so let's try it out and let's see if this works and I can jump and notice I can kind of Run and Jump at the same time now what I'll do now is add uh like falling and jumping animations because obviously it looks kind of weird right now when I'm jumping but there you go we can jump nice okay so let's add the uh the animations now so if we go to update Sprite all we need to do here is we can say if self Dot and actually I need to refer to my cheat sheet here because this is a bit more complicated than I thought okay I'm going to say if not self if self.y underscore velocity does not equal zero then what I will do is say if self dot jump count equals equals one then I'm going to say my Sprite sheet is equal to jump I'm going to say l if self dot jump count equals equals two then my spreadsheet is equal to double jump now this is actually going to be if my velocity is less than zero which means I'm moving up now the next one that I want to add is I want to say if and actually these are all going to be L IFS well not that one but this one I'm going to say elif myself.y underscore Val is greater than zero this means I'm moving down then my Sprite sheet should be equal to fall okay so this is handling regular jump and double jump and this is telling me if I'm falling let's try it now and let's see what happens when I jump okay so it's kind of glitching a little bit uh the reason this is happening I believe is because we are applying gravity even while we're on the ground so my y velocity is always greater than zero and then stops being greater than zero that's greater than zero again so I will show you how to fix this all right so actually the way that I'm going to fix this is a bit of a hack but it's it's gonna be good it'll work here so I'm actually going to say if myself the Y velocity is greater than self Dot gravity times two now the reason I'm going to do this for fall is so that I don't immediately start glitching into this false State when I have a really low amount of gravity being applied to me when I've gone off the block and then I've fallen down to the block so let me show you what I mean by just kind of kind of writing the code here so you can see that what happens is when I hit the block when I collide with it it's going to reset my gravity count and then I'm going to kind of Spawn to the top of the block so when I'm on the top of the block I'm going to be slowly falling down to the block then I'm going to hit the block when I hit the Block it's gonna do the same thing it's going to bring me to the top reset my gravity account so what was happening before is that we would go to the top of the block and then our gravity would increase a tiny bit right it would increase to be one pixel per second or something along those lines which would mean we were falling so then we were falling we hit the block and then it reset it so it kept glitching between the two states so what I've done is just made it so we have to have a significant amount of gravity before it starts showing that fall state so now it doesn't look glitchy on the screen as I'm jumping around and you can see that what actually happens is when I jump and I get to the peak of my jump you can see that it starts the falling State because now my velocity has changed directions right now I'm going down okay so now we have jumping now we have running around and colliding with blocks done quite a bit actually the next thing I want to do is make it so that objects move on the screen then we will do a horizontal collision and then we will pretty much be done after I add kind of that like fire uh state right or that let's call it trap something like that okay so we want to do scrolling background scrolling background is actually fairly easy the way that we do a scrolling background is we simply offset every single thing that we're drawing on the screen by a certain amount so any object that we have we don't change its position at all we just change how we're drawing it on the screen so it doesn't affect any of our Collision all it affects is what's seen right so what's happening in the background is we may be colliding at a really far position to the right we're showing the position currently on the screen you see what I mean but what this involves is having some offset X which I'm going to say is equal to zero now the way that I want to have it and I'll just illustrate here is that when I'm on the screen I only start scrolling the background when I get close to the edge so like here right it would start scrolling whereas if I'm in the middle and I'm kind of moving like this I don't want it to scroll the background until I get to the edge oh also notice you can double jump here I kind of forgot to to mention that part um so I'm going to implement that where essentially once we reach a certain boundary then the screen will start scrolling all right so how do we do this well we can do it just directly inside of our Loop here and we're going to do it here we're going to say if the player.rect dot X minus the offset X plus the player.rect dot width and actually now that I think of this we're just going to do this we're going to say if the player.rect dot right which will account for the width minus the offset X is greater than or equal to the width minus a variable that I'm going to write in a second which is scroll area width and the blair.x underscore velocity is greater than zero then we're going to say offset underscore X and this is going to be plus equals the player dot x velocity all right let me just write this variable then I'll explain how this works because we also have to do the other side so I'm going to say scroll area width is equal to 200 what that means is that when I get to 200 pixels on the left or 200 pixels on the right of the screen I start scrolling okay so here what I'm doing is I'm checking if I'm moving to the right that's what this checks if my x velocity is greater than zero that means I'm moving to the right and this is checking if my character is right on the screen like if it's crossed a specific boundary so I take whatever the right position of my player is which could be very far off the screen I subtract whatever offset we currently have so if we're offsetting everything by 100 pixels for example I subtract that so I know where I'm actually showing the character on the screen and I say if that's greater than the width minus the scroll area width which means I'm at say 700 pixels something like that on the right side of the screen then I'm going to offset the screen by whatever the velocity was that my player just moved to the right so that will make it look like I'm scrolling now we can say or and do the exact same thing for the left side so I'm going to say if player Dot rect dot left and this is actually going to be is going to be plus the offset I gotta check if it's Plus or if it's minus no it's going to be minus again minus the offset X is less than or equal to the scroll area width and my player dot X underscore Val is less than zero then I want to do this now let's move this down on the screen a bit I'm just going to add some parentheses so that my condition is correct here okay so I think that should be good again I'm checking to the left and to the right side if I'm moving to the left I want to check if I'm at that boundary if I'm checking to the right or if I'm moving to the right story I want to check if I'm at that boundary and then I increment my offset X now all I have to do to account for this is add an offset X to my draw function and draw every single object offset by this x so I'm going to go here and say offset underscore X and now just to all of my draw functions I'm going to pass offset X offset underscore X I'm going to go to all my draw functions and I'm going to add this offset X and what I'm going to do is just subtract the offset X from the X position I'm drawing everything out so we say minus offset X and we'll take in the offset underscore X okay now the reason this works if I move to the left my offset X is going to be negative which means everything is going to push to the right side because we're adding to the position for it if I move to the left side or sorry if I move to the right side the offset X is going to be positive which means everything is going to move to the left so it has a scrolling background effect let's just run it though and see if it works then I can fix it if it doesn't okay so as I start running here you can see that now the floor is going to start going with me once I reach this boundary however on this side right like when I'm in the middle is not doing anything I have to get to a certain boundary which is kind of invisible on the screen and then it starts scrolling with me which is what I wanted to do and then notice if I jump here boom I fall off the platform let's do collision with blocks in the horizontal Direction so to do that I'm just going to add a block here so I'm actually going to make a list I'm going to say objects is equal to Asterix floor now if you've ever seen uh like kind of dot dot dot in JavaScript that's what this does in Python it just essentially breaks this floor into all its individual elements and passes them inside of this list so imagine it if me just writing this here that's what it's doing and then I'm going to pass another block and for this block I'm going to place this at let's do zero and then for the Y this is going to be the height of the screen minus the block size times two now the reason I'm multiplying this by two is so that I get it a bit higher on the screen so that we can kind of run into it horizontally and I'm going to pass my block size so I'll just see now I want to go and rather than drawing my floor want to pass objects and same here with handle move on to pass objects so let me run this so now you can see that I have that block there right now notice that when I hit the block I kind of go to the top of it and the reason I go to the top of the block is because right now I'm only handling my vertical Collision so when I hit the block I have a little bit of gravity because remember there's always some gravity on me when I'm on the floor and so it thinks that I've hit the top of the block so it spawns me on the top of the block so we need to make it now so that when you hit the Block in the horizontal Direction it kind of Pops you off of it so that it doesn't think you're hitting the top of the block or the bottom of the block alternatively which you'll see in a second and in fact let me add one more block to show you uh hitting our head on the Block so let's add another block let's make this at say block size multiplied by three and then for the height let's do times four okay now we have another block let's see where this guy is now I can show you that I can hit my head on the Block right and I can't kind of go above it okay anyways we have that let's do our horizontal Collision so the horizontal Collision is a bit weird to implement the idea behind this is that since we're using our Sprite Collide mask we want to make sure that if we collide with a block horizontally we move ourselves off of that block so that it doesn't think that we're colliding with it in the vertical Direction now you just saw that happen we hit the block it thought that we were hitting it like the top of the block so it put us on the top of the block because that's what this line does right here so in our horizontal Collision we essentially need to check okay by moving in this direction are you going to hit the block if you are going to hit the block we want to prevent you from moving in that direction so that you don't hit it collide with it and then we like spawn to the top of it so let me write it and I'll explain to you how it works but it's just very important that we check the horizontal Collision first then once we check that we check the vertical Collision because we only want to check vertical Collision if we are not colliding with a block horizontally or if we haven't already handled or if we have already handled the horizontal Collision again the idea is we don't want to be thinking that we're hitting the block on the top when really we hit it on the left or the right side so we got to check that first so I'm going to make a function I'm going to say define collide I'm going to take player objects a displacement X like that now I'm going to say player.move and I'm going to move my player in the displacement X Direction and 0 in the y direction the reason I'm doing this is I want to check if with the current velocity that my player has if now the reason I'm doing this is I want to check if my player were to move to the right or if they were to move to the left would they hit a block that's that's what I'm checking essentially by moving the player preemptively so now what I need to do is say player.update now the reason I need to call that update and let's go here to dot update is because I need to update the rectangle in The Mask before I check for Collision so again what I'm doing is I'm preemptively moving my player to where they would be moving if they're going left or right I'm updating their mask and their rectangle and then I'm going to say four object in objects if pygame dot Sprite dot Collide mask and then I'm passing my player and my object so this is why I needed to update my mask and my rectangle so I move my player I update it and then using that updated mask I check would I be colliding with an object now I'm going to say collided object is equal to none I've got to spell collided correctly if I am then I'm going to say collided and this is just going to be object is equal to obj then I'm going to break okay then I'm going to say player.move and I'm going to move them back and then I'm going to say player.update okay and then I'm going to return the collided object okay so what I'm doing right I'm moving my player I'm updating the mask I'm checking if they would collide with something if they were to move in that direction then if they did okay I get that Clyde object it doesn't matter if they do or they don't after I check this Collision I have to move them back to where they originally were so I have to reverse the movement and then update the mask again then a return collided object okay again moving checking if we hit anything either way moving back to where we were before this is preemptively tracking before we allow them to move into a block all right now what we need to do is use this function uh to allow us to move left or right or to disallow us from moving left or right so I'm going to say Collide underscore left is equal to collide player objects and then negative player Vel then I'm going to say Collide underscore right is equal to collide player objects and then player and then I'm going to say and not Collide left and not Collide right again what we're doing here is we're checking if we should be able to move left or if we should be able to move right uh based on our current position that's why I make that preemptive movement and then here I only let you make the movement if that movement does not cause you moving into a block or colliding with one now that we have that that should actually handle our horizontal Collision that's actually all we need all right so let me run this code and let's see so I'm here okay obviously that's still working and you can see that I can't go through the block now let's go here and actually I'm getting a bit of a bug on the right side okay so that time it worked but it's a little bit glitchy and I have a feeling it has to do with the animation count of me running because it's only sometimes when I'm running and I hit the block that it spawns me up here so I'm just going to do another little hack here and I'm just going to multiply this by two both of them here the reason for this being that I'll just make it so there's a little bit of space between the block and that way me changing the Sprite isn't going to affect if I collide with the object or not because remember the Sprites kind of shift to the left or to the right a little bit so just by adding this multiplied by two it should make it so that I'm never going to be colliding left or right it will make it so as a bit of space see how there's a bit of space between the block now but that's okay because now I'm never going to have that Collision bug um where it's going to spawn me to the top and really you could probably just add one or two pixels but you can see that that kind of fixed it right there okay so now we have collision with blocks we have a scrolling background we have double jumping I think that the last thing that we need to add here is the fire thing right kind of that trap where you hit it and you kind of Flash and then once we've done that will pretty much be done the tutorial all right so let's write our class for representing our fire so I'm going to say class fire this is going to inherit from object as well and this is going to be animated right we're going to have animated fire so this will take a bit more work but I think it'll be worth it it looks pretty cool on the screen so I'm going to take X Y width and height and then I'm going to call my super initializer so super dot underscore squared knit self x y with and height okay and then for the name of this I'm actually going to call it fire remember that we can pass a name the reason I'm adding a name to the object is so that I can determine when I collide with the object if it's fire and if it's fire then I want to do something right okay so for self.fire I'm going to use our load Sprite sheets function for directory one this is going to be traps and for directory two this is going to be fire now if we go here to trops you can see that fire is one of our traps so we have hit off on okay now there's also a bunch of other traps right so you can you can pick a different trap if you want like you could pass this blink one or whatever the thing with these ones is that they have uh some more animations so there's a bit more logic you need to handle for them so that's why I'm going with fire because it's a pretty simple one to do now up here for fire I'm again gonna have my animation delay so let's make that equal three and now let's specify our image so let's say ourself.image is going to be self.fire off we're going to start with it off and then zero okay then I'm going to say self.mask is equal to pygame dot mask Dot from surface self Dot image like that okay then I need to set an animation count so I'm going to say my animation underscore count is equal to zero just like we did for our player and I need to set myself dot animation underscore name which for now is going to be equal to off okay now I'm going to make a few functions my first function is going to be on or my first method and I'm going to say self dot animation name is equal to on if we look at fire we see we have hit off on we're not going to use hit we're just going to use off and on okay now we're going to have off self.animation name is equal to off okay and then we'll have our Loop we'll say Define Loop self and inside of our loop we're going to do a very similar thing to what we did inside of our player Loop in fact so similar that I can copy pretty much all of this right here so let's copy all that and let's paste that here now for update rather than actually just calling an update method we'll just copy the stuff from the update method here and just paste it down okay and rather than self.sprite we're going to change this to image and I actually think that once we remove the direction here this is all that we need for our um all right so now we just need to make a few changes we're going to get rid of this Sprite sheet name and rather than Sprite sheet name we're going to say self dot animation name and now we should actually be good to just use this so let me space this out a bit we get our Sprites okay this isn't going to be self that Sprites no it's not gonna be selfdestrates it's gonna be self.fire which is this okay really I probably should call this something else but fire is going to represent all of our fire images okay so I'm using this to get my different animations I'm getting the animation name that I'm currently playing so either on or off and then I'm saying my Sprite index is equal to self.animation count divided by the self.animation delay mod the line of Sprites same as what we had before my image is equal to Sprites at Sprite index and then I increment the animation count update my rectangle and update my mask which is important for the collision and I'm good now last thing I want to do here is I want to just check if my self dot animation count is greater than actually if this divided by myself dot animation delay is greater than the line of Sprites now the reason I want to do this is so that my animation count doesn't get too large now you'll notice in my player class I actually didn't do this now that was intentional because if you do this then it kind of messes up how the double jump works you can do it if you want but you'll see that it kind of messes with things and with our player we're constantly resetting the animation account when we jump or when we go left or when we go right so that value doesn't really get too large but here for our fire since it's just static like it's just sitting forever what will happen is the animation count if we never change it back to zero we'll get to an extremely large number which can kind of lag our program so what I want to do is just make it smaller right so if it goes beyond what the actual animation um what do you call this is the line of the Sprites are then I want to set this to zero it's important I divide it by the animation delay though because if I'm dividing it here I need to divide it here before I set it back to zero okay so now we have fire I think that's actually all we need for fire so now we just need to add it to our objects so let's create it let's say fire it's equal to Fire and what do we need to pass for fire we need X Y width and height so we can pick where we want to put this um where do I want to put my X and Y okay for now let's go 100 and let's go height minus the block size and then I don't know how tall my fire is going to be I've got to see how big I want to make this let's make it say 64. and then we'll go 32 64 here okay so if we look at fire let's quickly have a look here and go to off for example or on the size of this is 32 by 64. okay that's what the size is and you need to pass that uh correctly to the fire class otherwise it won't load the image properly so we take our height minus our block size minus 64 which will put us on top of a block now I will put this at yeah 100 is fine for now for the X and yeah 32 with 64 height there we go we have our fire now I'm just going to say fire.on I'm just going to turn it on we'll just leave it on forever uh you can turn off programmatically if you want and then inside of objects I'll just place my fire now that I've done that it should just show up on the screen when I run my code so I got an issue let's see what the bug is here of course the output is not showing up correctly it says and it takes from five to six positional arguments where seven were given uh okay I see the issue here let's go back to our fire and we don't want to pass self let's remove self okay let's run this uh list index out of range self.fire off zero hmm okay I'm wondering why that's giving us an issue we have off here so that should have been okay so let's go here and let's print self.fire and let's see why it's giving us this uh this bug here all right so I've determined the issue and the issue is that I passed the incorrect size here it's actually 16 by 32. so I was passing too large of a size and that's why it wasn't giving us the correct number of images so let's change this now and run and now we should be okay and there we go now we have fire uh but however it is off now the reason it's off is because we didn't call the loop method on fire so let's fix that I can also get rid of the print statement that I put here that I don't need anymore okay so let's go down to Main and where we have player.loop let's call fire.loop and is asking for the FPS I don't know if I took that in my Loop here no I don't need the FPS for that so let's get rid of that okay now let's call it and it should start being on uh fire object has not shoot Sprite okay let's go fix that error my apologies fire we have Sprite somewhere here that we don't want self.sprite there's gonna be self Dot image and self Dot image all right start with that let's run it now and there we go we now have a moving fire and notice that I can kind of be on top of the fire right so I can collide with it and it's like Pixel Perfect Collision pretty much when I'm hitting it so now the last thing we need is to just make it so we go into that kind of hit State when we do hit the fire that's actually pretty easy to do we just need to add a kind of state to our player to know if we're hit or not so we're going to say self.hit is equal to false we also want to hit count because we're going to only be flashing for a certain amount of time then we're going to have a method here to find hit self .hit equals true and self.hit count is equal to zero then we're going to go in Loop and before our update Sprite we're going to say if self dot hit then self dot hit count plus equals one and then we're going to say if self dot hit count is greater than and we can just pick some value but let's say FPS multiplied by two which is going to be two seconds then the self dot hit is equal to false then we go here into our update Sprite and we say actually at the top here if self.hit it's important you put this at the top by the way so make sure you put it here then we are going to say the Sprite sheet is equal to hit great then we want to now determine if we actually got hit so we do that from our Collision functions which are going to be here all right so we have Collide left we have Collide right and we're going to have vertical collide now what we're going to do is we're essentially going to Loop through all of these objects and we're going to see if we hit fire now the way we'll know if we hit fire is by looking at all the objects that were returned here and it will tell us well if if we hit fire or not right it's because we can look at the name of the object and if the name of the object is fire then we know we hit fire so I'm going to say to check is equal to collide left Collide right and asterisk vertical Collide now I realize that inside of here I only returned one object whereas inside of here I returned all the objects I was colliding with vertically really we should probably be returning all of them from here as well but I think this is still going to work so we'll just leave it how it is for right now so I'm going to say 4 obj into underscore check these are all the objects we collided with remember I'm going to say if to underscore check and to underscore check Dot name is equal to fire then player.hit is able to trip okay that is all we need actually I'm going to say player.hit I want to call the method I don't want to set it equal to true so what we're doing here is looking through all the objects we collided with if any of them are fire then we will put hit on the player the reason I'm doing this first if to check is because these could be none right we could have no objects we collided with so I need to make sure I handle that case before I try to access name on an object that isn't defined all right let's run the code and let's see and player has no object no attribute hit count okay so let's go to player and let's go to hit count and let's make that equal to zero I guess I forgot to assign that all right let's try this now uh list object has no attribute name okay interesting uh let's see here okay all right so I'm using two check when I need to be checking obj so let's fix that and run the code Bool object is not callable okay player.hits aha so let's call this make hit it's because I have an attribute with the same name as my method so it's accessing the attribute when it should be accessing the method so I'm just going to say make underscore hit and now that should fix the problem for us run the code and there we go now it looks like I'm always being hit right now that of course is a bug so hit is equal to false let's check our hit count it's because if self.it so if the hit count plus equals one if selfdoh hit count is greater than self.he equals false maybe we need to reset our hit count as well okay and there's probably a bug here let's scroll down keep scrolling with our fire so we have to check if obj and obj and a name equals equals fire player.make hit okay I'm not sure what the bug is let me run this again and yeah it seems like we start out in the hit state so maybe it's an issue in here let's have a look here if self dot hit spreadsheet equals hit but we are we hit right away for some reason it's making us hit immediately okay let me have a look here guys and I'll be right back alright so I've realized I made a silly mistake here I actually had this collided objects append outside of this if statement that was causing all kinds of bugs and issues for me I think I was doing some print debugging so let me get rid of that here uh anyways I just moved it back now so that it's in the correct location so now if I rerun this now we should see that when I hit the fire it puts me into kind of this hit State last two seconds and then it ends all right so with that said guys I think that's pretty much gonna wrap up this video this showed you how to create a platformer how to do animations how to do Sprites how to do a scrolling background obviously there's a ton of stuff that can be added to this game but I really want to leave that to you obviously I could spend hours days months working on a game like this but I think this is a solid enough base to really give you guys a good foundation to go out there and create something pretty cool obviously there's all kinds of assets that I will leave in the GitHub that you can use I have all kinds of other Pi game tutorials that you may want to reference if you want to learn about menus sound effects um points scoring all of that kind of stuff you guys just go on my channel search Pi game tutorial you will see a bunch of them those will show you how to do a ton of other things that you know you may want to add to this game so I hope you guys enjoyed this this was a ton of work as always the code will be in the description if you did enjoy make sure to leave a like subscribe to the channel consider supporting me by purchasing something like programming expert I hope to see you in another YouTube video
