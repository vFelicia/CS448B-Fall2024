With timestamps:

00:00 - hey guys and welcome back to another
00:02 - video in today's video I'm going to be
00:04 - explaining the difference between
00:04 - mutable and immutable data types this is
00:07 - an extremely extremely important concept
00:10 - it's fundamental to any programming
00:12 - you're gonna do in Python this is
00:13 - completely different from most other
00:15 - languages so even if you think you're a
00:17 - good programmer or maybe you program in
00:18 - Java and C and you're here to learn some
00:20 - Python make sure you watch the entire
00:22 - video and understand this because this
00:24 - is not something you would have learned
00:25 - before in other languages this is what
00:27 - makes Python distinct difference
00:29 - obviously a lot of other factors as well
00:31 - but this is completely different from
00:33 - other programming languages and it can
00:34 - cause a huge headache if you don't
00:36 - understand it so make sure if you do not
00:38 - understand that you watch through the
00:39 - entire video because I'm gonna be
00:41 - explaining it in depth and it is really
00:43 - a fundamental concept I can't emphasize
00:45 - that enough when I started programming I
00:47 - really wish at least with Python that I
00:49 - learned this right away as it would have
00:50 - saved me a lot of time and made my life
00:53 - a lot easier
00:54 - anyways let's go through so what is a
00:56 - mutable data type and what is an
00:58 - immutable data type well mutable let's
01:00 - type it out here for you so it's
01:02 - supposed to be a comment I don't know
01:03 - how I ended up hitting that okay mutable
01:05 - stands for changeable and immutable
01:09 - stands for not changeable so our mutable
01:11 - data types in Python are lists we have a
01:15 - set and we have a dictionary there's a
01:18 - few other ones but these are the
01:19 - standard built-in data types that are
01:21 - mutable in Python our immutable data
01:23 - types are everything else so everything
01:27 - else would contain like int strings I
01:31 - don't know what else do we have here
01:32 - floats tuples and so on there's
01:37 - obviously a lot of other data types I
01:39 - won't type them all out okay so let's
01:41 - just see an example here difference like
01:44 - how does this work what's what's the
01:45 - difference so pretty much I'm just going
01:46 - to create X I'm gonna make this equal to
01:48 - string I'm in space a Y it's gonna be a
01:51 - new list gonna have one and two in it
01:53 - like that now I will just type that out
01:56 - for here so the type of X obviously is a
01:59 - string and are the type of Y is a list
02:03 - so you can see that our list falls
02:06 - within mutable data types and our string
02:09 - falls within immutable data type so
02:11 - let's see what the main difference here
02:12 - is so I'm gonna show you
02:13 - we can do so with a list I hope you know
02:15 - you can do stuff like dot append so I
02:17 - and say why not append what's a pen two
02:20 - three to it if I print Y then Y is now
02:23 - equal to one two three
02:25 - I can do things like y1 equals seven
02:29 - print y you can see we get one seven
02:32 - three now notice I didn't have to say y
02:35 - equals y1 or I'd have to say y equals
02:39 - and then print the list again like one
02:40 - seven three something like that all I
02:44 - had to do was just say y1 equals I and
02:47 - like dot append simply okay so with our
02:50 - string now let's see if we can do the
02:52 - same thing so I'm gonna say X plus s and
02:56 - you can see that it gives us strings
02:59 - like this so now let's see if I print X
03:00 - well it's still equal to string by doing
03:05 - this plus s here this returned to us a
03:07 - new string with a added s to it whereas
03:12 - it doesn't actually change the value so
03:14 - if I do something like y1 equals seven
03:16 - it doesn't return to us we don't get
03:18 - anything printed after neath it
03:19 - underneath it sorry it doesn't return to
03:21 - us a new list with the changed values
03:24 - like one seven two it simply changes
03:27 - this original list now let's do some
03:31 - examples of alias and cloning and I'll
03:33 - talk about what that is alias just means
03:35 - another name for and cloning means like
03:38 - to copy okay so an alias of a list and
03:41 - this is works for all mutable data types
03:44 - like lists set dictionaries is if I do
03:47 - something like this so so LST equals y
03:50 - and I can print Y and I can print LST
03:53 - and we can see they are indeed the same
03:55 - now I'm just gonna close this and open
03:56 - up because I don't like working out the
03:58 - bottom of my screen okay so actually I'm
04:00 - gonna do this again so I was gonna say
04:01 - list equals one two three let's say x
04:05 - equals LST right so I print X and I put
04:08 - an LST you can see they are indeed the
04:10 - same so now let's see what happens if I
04:13 - change X I'm gonna say X dot append
04:15 - eight likes that so now we should have a
04:18 - list says one two three eight so I print
04:20 - X and I get one two three eight now list
04:22 - I didn't do I didn't do anything to list
04:23 - I didn't change list so it should just
04:26 - be equal to 1/2
04:27 - right so let's see if I print list but
04:30 - it's not it's equal to one two three
04:32 - eight now why did that happen well when
04:36 - we assigned the value of LST to X we
04:40 - simply created an alias for this list
04:43 - meaning that we just created another
04:45 - name for it it really that completely
04:47 - this line is completely useless it
04:48 - doesn't really change anything in memory
04:50 - and I'm gonna show this later with like
04:52 - a little drawing example to make it more
04:53 - clear we've simply just said okay X is
04:56 - equal to this list so whatever we do to
04:58 - this list is gonna change X as well
05:01 - whenever we do two X is given change
05:02 - this list as well they simply are the
05:04 - exact same object so any operation we do
05:07 - on that is going to apply to both of
05:09 - them because we created an alias by
05:11 - simply just doing this like assignment
05:14 - like this and you can have as many alias
05:15 - as you want so I can say y equals LST
05:17 - front Y I'm gonna do y dot append oops
05:20 - I've got 100 I print X Y and LST and you
05:27 - can see they're all equal to the same
05:28 - thing like that now let's watch it would
05:32 - have how this works with strings so
05:34 - immutable data types not mutable data
05:36 - types so I say x equals oops equals STR
05:41 - and I say X or if let's say y equals x I
05:46 - can print X I can print Y you can see we
05:49 - get STR STR and now if I do X plus
05:52 - equals like five I'll print X and I get
05:56 - string five now if I print Y we just get
05:59 - string so the operation that I applied
06:02 - to Y did not actually change X it did
06:06 - not change that value that's because
06:08 - these types are immutable meaning that
06:10 - you can't change them same thing with
06:12 - numbers right so if you do like x equals
06:15 - 5 y equals 6 like this or hot one my
06:19 - second let's say y equals x like that
06:22 - and then you do like x equals x plus 5
06:26 - and you change it and then you print Y
06:29 - well why didn't change it's still equal
06:31 - to 5 whereas X is equal to 10 and that
06:34 - is the main difference between mutable
06:35 - and immutable data types one you can
06:39 - change one you can no
06:40 - now I want to get into a memory model
06:43 - for these that's gonna explain it a lot
06:46 - more clear so have like a little drawing
06:47 - tablet thing that I got recently excuse
06:50 - me my handwriting is absolutely
06:52 - atrocious so there's really gonna be
06:53 - some symbols or letters you might not
06:55 - feel to make out but just bear with me
06:56 - this is one of the easiest ways that I
06:58 - can kind of explain it to you guys so
07:00 - I'm just gonna do this screen sketch all
07:03 - right so now it brings up this thing so
07:04 - let's make sure this is working all
07:05 - right okay
07:07 - so she's gonna go to pen here and I'm
07:09 - just gonna draw like a standard thing
07:12 - that I want to call the memory model and
07:13 - Python this is what is actually
07:14 - happening in your computer when you
07:16 - create lists and you create like
07:18 - integers and all that kind of stuff so
07:20 - we created a list here LST
07:22 - is equal to 1 2 3 so what this is done
07:25 - now is it's pointed LST points to a list
07:29 - in our memory that looks like this 1 2 3
07:35 - ok so it points to that list in memory
07:38 - and it actually doesn't quite point to
07:40 - that list but I'll talk about that after
07:42 - this is just the easiest way to explain
07:43 - ok and X now so X is equal to list what
07:46 - this actually does is it points to these
07:48 - same lists right so it makes sense they
07:51 - point to the same list now I'll show you
07:53 - down here when I created a string and
07:55 - when I said y equals x so when I create
07:57 - the string X what happens is we come up
07:59 - here and we have a string and it's equal
08:02 - to like s T are like that and that's
08:05 - gonna be X and I'm just gonna put X LST
08:08 - sir I should use different names for
08:10 - these but you can see so that's the
08:11 - value of x n LST this value X now when I
08:14 - say y equals x well what actually ends
08:16 - up happening is I come here and I point
08:20 - to a new string that's equal to s TR
08:24 - like that again sorry but the awful
08:26 - handwriting but you get the point
08:28 - so rather than these immutable objects
08:31 - pointing to the same object we point to
08:34 - two different instances of strings so
08:36 - that's why when I add a 5 here so like
08:38 - say out of 5 so let's just erase this it
08:42 - doesn't actually change our other value
08:45 - because well this is its own object so
08:48 - when we print that out you can see that
08:50 - it doesn't have the 5 attached to 1
08:51 - whereas up here if we
08:54 - change for example this value - and we
08:56 - change this to seven well that changes X
09:00 - as well because X is pointing to this
09:02 - same object and I hope that makes sense
09:04 - and this word this is the same kind of
09:06 - situation for mutable and immutable and
09:09 - immutable data types so if we want to
09:12 - create a copy something I'll show you
09:13 - how we can do that after but I hope this
09:15 - guides this gave you like an explanation
09:17 - of why that works so the same thing with
09:18 - integers if I created like let's say
09:21 - like x equals or whatever I'm using ax
09:23 - writing is x equals 6 then we get 6 here
09:26 - and I say y equals x then we get another
09:30 - 6 here and you can see that we point
09:32 - like that and we point like that ok so
09:36 - we get six six two different sixes we're
09:38 - not pointing to the same object whereas
09:40 - with this list that is precisely what's
09:42 - happening ok so I made a bit of a mess
09:44 - here so let's just go ahead and close
09:46 - this out and go back to typing some that
09:49 - stuff out here so what I'm gonna do now
09:51 - is I'm going to bring in like I have
09:53 - another file that I was writing here and
09:55 - just show you some examples of how we
09:57 - can kind of use this property so I have
10:00 - like a little summary of kind of what
10:01 - gone on went on here so mutable types
10:03 - you made will data types oh and of
10:06 - course I've closed that just give me a
10:07 - second guys what's gonna reopen this ok
10:11 - so I've got the file back up sorry about
10:13 - that
10:13 - anyways we have a change list and copy
10:16 - list these are two functions and then we
10:18 - have some operators down here so you can
10:20 - see here what's gonna happen so I'm just
10:23 - gonna actually call these functions down
10:24 - here to kind of illustrate what happens
10:26 - so this first function change list
10:28 - simply appends a hundred to a given list
10:32 - you can see it doesn't return anything
10:33 - all it does is it says l I don't append
10:36 - a hundred okay so what we have to do is
10:38 - we're gonna pass a list so I'm gonna say
10:40 - change list and we'll just do like one
10:43 - two three are actually I have to do like
10:46 - this otherwise we're not gonna be able
10:47 - to track what we're doing so X I give it
10:51 - X and then if I print X down here and
10:54 - I'm just gonna comment out all this so
10:56 - that we don't get that printing instead
10:58 - what happens here is I'm gonna print X
11:01 - so you can see if I do this I get one
11:03 - two three one hundred so again this is
11:05 - the same thing that I was talking about
11:06 - before
11:07 - when we say with the parameter the way
11:09 - parameters work in functions is whatever
11:12 - the past value is becomes equal to this
11:15 - name so Li is this is doing exactly this
11:18 - Li is equal to X that's simply all that
11:21 - it's executing Li equals x so when we
11:23 - pass X in here so okay Li is equal to X
11:26 - well that's one two three and they're
11:28 - the same object so when we change
11:29 - something on Li we're effectively
11:32 - changing X as well now I want to show
11:34 - you what happens when I do copy list so
11:37 - this copy list I haven't talked about
11:38 - what this does yet but I'll do it in
11:39 - just a second I change this to copy list
11:42 - and print X okay so actually I'm going
11:45 - to say I have to say X is equal to copy
11:47 - list year okay so what this copy list
11:49 - does is it creates a copy of the given
11:53 - list so we say x equals to L I here
11:55 - again now we're saying new list is equal
11:57 - to Li square bracket colon square
12:00 - bracket now what this does is it makes a
12:02 - copy so a new object of our list it's
12:06 - not this it's not no longer now pointing
12:08 - to the same object and they're pointing
12:10 - to a different object in memory that are
12:13 - just like identical okay so I hope that
12:15 - makes sense I'm going to explain this
12:16 - more with another like drawing thing
12:18 - after and then we're appending a hundred
12:20 - to that new list and we're returning
12:22 - that new list so let's now run the
12:25 - operation here so X use one two three
12:27 - copy list print X see we get one two
12:31 - three hundred but if I say oops let's
12:34 - just do Y here imprint XY otherwise
12:37 - we're not going to see so X is the
12:38 - original list Y is the change list you
12:40 - can see that we have one two three which
12:41 - was our original list that we passed in
12:43 - and then our new list one two three
12:44 - hundred and notice that hundred is not
12:46 - added to the old list because we simply
12:49 - copied it we did not actually change
12:52 - that original list okay so now I'm gonna
12:56 - talk about this is operator and what
12:58 - this does is it allows us to check
13:01 - whether two items are the same within
13:04 - memory so what I was telling you before
13:06 - was somewhat a lie somewhat true I was
13:08 - telling you that when you create a
13:10 - variable say like x equals one two three
13:11 - it points to a location in memory where
13:14 - we have one two three just a list one
13:16 - two three and not that's it that's not
13:18 - completely true
13:20 - what happens is actually each of these
13:23 - objects have an ID associated with them
13:26 - you see I'm printing ID like this and
13:28 - the ID is like the actual specific
13:30 - location in memory so I'm just gonna get
13:32 - out my tablet and start drawing in okay
13:35 - so I've got everything set up pretty
13:37 - well now and what I want to do is I'm
13:39 - gonna redraw that memory model that I
13:41 - was talking about before except we're
13:44 - gonna change a few things so we're gonna
13:47 - go to this LST here and remember I'm
13:49 - always saying that everything is
13:52 - actually in ID it's not actually the
13:56 - value so this is the value right here
13:58 - like 1 2 3 right but what's actually
14:01 - gonna be stored in this memory model
14:03 - when we create list is in address now
14:06 - this address is known as an ID like what
14:08 - I have done here so the ID will look
14:10 - something not really but it's gonna be
14:13 - like a big string of numbers so I'm just
14:14 - gonna say 0 1 okay now this is an ID
14:18 - this is obviously not the value 1 2 3
14:21 - now this ID points to a value so we
14:25 - change colors here so that we don't get
14:26 - too confused this is 0 1 points to a
14:30 - value that's gonna be this list and once
14:33 - we go start going further than this it
14:35 - kind of gets a little complicated but we
14:36 - have 1 2 3 like this and this ID points
14:41 - to that value so when I create an alias
14:43 - so like what I've done here let's change
14:44 - back to red what happens is this LST
14:48 - here is given the same ID so these lists
14:52 - so LST points to 0 1 and LST 2 also
14:56 - points to 0 1 now once we have 0 1 0 1
14:59 - points to 1 2 3 which is that value and
15:03 - that is known as the ID and that's what
15:06 - you can get by doing this little
15:08 - function here that I'm going to talk
15:08 - about ID and then whatever item or
15:11 - object whatever variable name okay so
15:13 - what this is operator does and I'm gonna
15:16 - demonstrate this with code is it checks
15:18 - to see if these two IDs are the same so
15:22 - rather than doing something and I guess
15:23 - I'll write down here by doing like 1
15:25 - equal equal to 1 which is comparing that
15:28 - the values are the same we're checking
15:31 - if the
15:32 - d is the same so if I say one okay let's
15:35 - I need to uh let's actually just erase
15:37 - that and do like a better example here
15:39 - to kind of show you how this operator
15:41 - works so what I'm gonna do is I'm going
15:43 - to create X or make that equal to one
15:46 - say like a thousand I'm gonna say Y is
15:49 - equal to a thousand now if I were to do
15:53 - something like x equals equals y well
15:56 - that gives us true right because they
15:59 - are the same value but if I did we just
16:01 - say X is y that's actually false now
16:05 - you'd say well what like a thousand is a
16:07 - thousand but the thing is remember what
16:08 - I was saying that we're pointing to
16:10 - different objects when we create the
16:12 - variable so when I create x equals a
16:14 - thousand what ends up happening is we
16:15 - come up here we get an ID that looks
16:17 - like 0 2 okay and this ID now points
16:21 - straw another black line here to a
16:24 - thousand like that okay so boom we're
16:27 - pointing to a thousand all right now
16:29 - when I create Y well same thing that I
16:31 - showed before Y comes up here and it's
16:34 - now actually created to an ID that's 0 3
16:37 - and 0 3 simply points to the value a
16:40 - thousand like that ok now I know we're
16:43 - gonna be confusing here but try to
16:45 - follow along so when I say is X equal to
16:48 - Y well we go to the ID we say okay so 0
16:50 - 2 that's a thousand 0 3 that's a
16:53 - thousand these are the same boom correct
16:55 - they are equal to when I say X is y
16:57 - where we go just to the IDs we don't
16:59 - care about the value when we say is we
17:01 - just care about the IDs and say well
17:03 - this ID is 0-2 this one here that I'm
17:05 - underlining and this one here is 0 3 now
17:07 - are those the same well no they're not
17:09 - so obviously this is gonna return false
17:13 - now when we do something like lists okay
17:16 - so I have LST and LST 2 so just go say
17:19 - LST is
17:21 - LST - like that well what do you think
17:24 - that's gonna return well LST has an ID
17:28 - of 0 1 and LST 2 also has an ID of 0 1
17:32 - so that gives us a true value like that
17:36 - now when you create a copy and I guess
17:39 - I'll just show this I'm gonna clear the
17:40 - screen here just cuz I have a big mess I
17:42 - create another like standard memory
17:44 - okay when I create a copy so I say LS t
17:46 - so L s T and then that points over here
17:50 - to we have again our list which looks
17:54 - like zero one two or what am I having
17:56 - one two three K you know what just
17:58 - pretend us has one two three I don't
17:59 - feel like writing it again and then I
18:01 - say LS T 2 equals L is T those point to
18:03 - the same thing but when I say LS t 3
18:05 - equals LS t and then we have this little
18:08 - colon thing here and I'm just skipping
18:09 - the IDs just to show you here what ends
18:11 - up happening is you say LS T 2 points to
18:15 - and then we actually create a new list
18:16 - so again a new ID and we get well 0 1 &
18:20 - 2 like that so these are no longer
18:23 - pointing to the same object or ID so you
18:25 - can imagine this as like id-1 id2 but
18:30 - simply these IDs are unique and they
18:32 - point to the same object like that i
18:34 - hope that makes sense in terms of like
18:36 - when you make a copy you get a new ID
18:38 - with the identical value of whatever
18:41 - you're copying so a new ID for this list
18:44 - like that okay so that's all I'm going
18:46 - to be doing with the drawing I know you
18:47 - guys are probably tired of seeing my
18:48 - horrible handwriting so let's go back to
18:50 - coding where I can't make hey look at
18:53 - that bad ok so now we're back onto the
18:56 - keyword so what I'm gonna do here is I'm
18:59 - just gonna simply print out some of the
19:00 - stuff that you're talking about so I
19:01 - don't need all these functions up here
19:03 - anymore and let's just see so LS t
19:05 - equals 1 2 3 LS t equals or LS t 2
19:08 - equals LS t so remember I was saying
19:10 - this should print true and then we
19:11 - create a copy of LS t and I say well as
19:13 - LS t is it equal to that no it should
19:16 - return false so let me just prove this
19:18 - to you run so we get true false and then
19:21 - we get the IDs and this is what I want
19:22 - to talk about with the IDs now that we
19:23 - have these open so we have this one what
19:27 - I was talking about before right since
19:29 - this is simply an alias I want this to
19:31 - stay open of the other list we get true
19:35 - because yes they are actually the same
19:36 - list when using this is operator and
19:38 - then LS t3 well that's not an alias of
19:41 - LS to you that's a copy so they don't
19:43 - have the same ID that's false and then I
19:47 - simply just print out the IDs for you to
19:48 - show you exactly what they look like so
19:50 - LS t well that has an ID four nine four
19:53 - three eight three nine two you can see
19:55 - that this indeed is the same ID for
19:57 - Alice
19:58 - - and LST 3 has a unique ID with
20:02 - different numbers and I'll just show you
20:05 - if I do something like I don't know
20:07 - i D like to 5/9 like that we get that's
20:12 - the number who say like ID of I don't
20:15 - know let's do something like this like
20:16 - STR we had a different number if I
20:18 - create X equals 90 for our 95 and iidx
20:22 - we get another note right so these IDs
20:25 - are unique and they for what do you call
20:29 - it immutable objects at least but if I
20:32 - create Wow let's do another example LS t
20:34 - equals 1 - you say x equals LST ID of X
20:40 - ID of oops LS t we can see that indeed
20:47 - they are the same just one more last
20:49 - proof for any of you that might have
20:51 - been skeptical at there ok so that has
20:53 - been it for explaining immutable and
20:55 - mutable data types I know this was a lot
20:58 - of information and don't feel bad if
21:00 - you're slightly confused but you should
21:02 - hopefully now have an understanding of
21:03 - how kind of the basic memory model in
21:05 - Python works if you have any other
21:07 - questions just let me know
21:08 - [Music]

Cleaned transcript:

hey guys and welcome back to another video in today's video I'm going to be explaining the difference between mutable and immutable data types this is an extremely extremely important concept it's fundamental to any programming you're gonna do in Python this is completely different from most other languages so even if you think you're a good programmer or maybe you program in Java and C and you're here to learn some Python make sure you watch the entire video and understand this because this is not something you would have learned before in other languages this is what makes Python distinct difference obviously a lot of other factors as well but this is completely different from other programming languages and it can cause a huge headache if you don't understand it so make sure if you do not understand that you watch through the entire video because I'm gonna be explaining it in depth and it is really a fundamental concept I can't emphasize that enough when I started programming I really wish at least with Python that I learned this right away as it would have saved me a lot of time and made my life a lot easier anyways let's go through so what is a mutable data type and what is an immutable data type well mutable let's type it out here for you so it's supposed to be a comment I don't know how I ended up hitting that okay mutable stands for changeable and immutable stands for not changeable so our mutable data types in Python are lists we have a set and we have a dictionary there's a few other ones but these are the standard builtin data types that are mutable in Python our immutable data types are everything else so everything else would contain like int strings I don't know what else do we have here floats tuples and so on there's obviously a lot of other data types I won't type them all out okay so let's just see an example here difference like how does this work what's what's the difference so pretty much I'm just going to create X I'm gonna make this equal to string I'm in space a Y it's gonna be a new list gonna have one and two in it like that now I will just type that out for here so the type of X obviously is a string and are the type of Y is a list so you can see that our list falls within mutable data types and our string falls within immutable data type so let's see what the main difference here is so I'm gonna show you we can do so with a list I hope you know you can do stuff like dot append so I and say why not append what's a pen two three to it if I print Y then Y is now equal to one two three I can do things like y1 equals seven print y you can see we get one seven three now notice I didn't have to say y equals y1 or I'd have to say y equals and then print the list again like one seven three something like that all I had to do was just say y1 equals I and like dot append simply okay so with our string now let's see if we can do the same thing so I'm gonna say X plus s and you can see that it gives us strings like this so now let's see if I print X well it's still equal to string by doing this plus s here this returned to us a new string with a added s to it whereas it doesn't actually change the value so if I do something like y1 equals seven it doesn't return to us we don't get anything printed after neath it underneath it sorry it doesn't return to us a new list with the changed values like one seven two it simply changes this original list now let's do some examples of alias and cloning and I'll talk about what that is alias just means another name for and cloning means like to copy okay so an alias of a list and this is works for all mutable data types like lists set dictionaries is if I do something like this so so LST equals y and I can print Y and I can print LST and we can see they are indeed the same now I'm just gonna close this and open up because I don't like working out the bottom of my screen okay so actually I'm gonna do this again so I was gonna say list equals one two three let's say x equals LST right so I print X and I put an LST you can see they are indeed the same so now let's see what happens if I change X I'm gonna say X dot append eight likes that so now we should have a list says one two three eight so I print X and I get one two three eight now list I didn't do I didn't do anything to list I didn't change list so it should just be equal to 1/2 right so let's see if I print list but it's not it's equal to one two three eight now why did that happen well when we assigned the value of LST to X we simply created an alias for this list meaning that we just created another name for it it really that completely this line is completely useless it doesn't really change anything in memory and I'm gonna show this later with like a little drawing example to make it more clear we've simply just said okay X is equal to this list so whatever we do to this list is gonna change X as well whenever we do two X is given change this list as well they simply are the exact same object so any operation we do on that is going to apply to both of them because we created an alias by simply just doing this like assignment like this and you can have as many alias as you want so I can say y equals LST front Y I'm gonna do y dot append oops I've got 100 I print X Y and LST and you can see they're all equal to the same thing like that now let's watch it would have how this works with strings so immutable data types not mutable data types so I say x equals oops equals STR and I say X or if let's say y equals x I can print X I can print Y you can see we get STR STR and now if I do X plus equals like five I'll print X and I get string five now if I print Y we just get string so the operation that I applied to Y did not actually change X it did not change that value that's because these types are immutable meaning that you can't change them same thing with numbers right so if you do like x equals 5 y equals 6 like this or hot one my second let's say y equals x like that and then you do like x equals x plus 5 and you change it and then you print Y well why didn't change it's still equal to 5 whereas X is equal to 10 and that is the main difference between mutable and immutable data types one you can change one you can no now I want to get into a memory model for these that's gonna explain it a lot more clear so have like a little drawing tablet thing that I got recently excuse me my handwriting is absolutely atrocious so there's really gonna be some symbols or letters you might not feel to make out but just bear with me this is one of the easiest ways that I can kind of explain it to you guys so I'm just gonna do this screen sketch all right so now it brings up this thing so let's make sure this is working all right okay so she's gonna go to pen here and I'm just gonna draw like a standard thing that I want to call the memory model and Python this is what is actually happening in your computer when you create lists and you create like integers and all that kind of stuff so we created a list here LST is equal to 1 2 3 so what this is done now is it's pointed LST points to a list in our memory that looks like this 1 2 3 ok so it points to that list in memory and it actually doesn't quite point to that list but I'll talk about that after this is just the easiest way to explain ok and X now so X is equal to list what this actually does is it points to these same lists right so it makes sense they point to the same list now I'll show you down here when I created a string and when I said y equals x so when I create the string X what happens is we come up here and we have a string and it's equal to like s T are like that and that's gonna be X and I'm just gonna put X LST sir I should use different names for these but you can see so that's the value of x n LST this value X now when I say y equals x well what actually ends up happening is I come here and I point to a new string that's equal to s TR like that again sorry but the awful handwriting but you get the point so rather than these immutable objects pointing to the same object we point to two different instances of strings so that's why when I add a 5 here so like say out of 5 so let's just erase this it doesn't actually change our other value because well this is its own object so when we print that out you can see that it doesn't have the 5 attached to 1 whereas up here if we change for example this value and we change this to seven well that changes X as well because X is pointing to this same object and I hope that makes sense and this word this is the same kind of situation for mutable and immutable and immutable data types so if we want to create a copy something I'll show you how we can do that after but I hope this guides this gave you like an explanation of why that works so the same thing with integers if I created like let's say like x equals or whatever I'm using ax writing is x equals 6 then we get 6 here and I say y equals x then we get another 6 here and you can see that we point like that and we point like that ok so we get six six two different sixes we're not pointing to the same object whereas with this list that is precisely what's happening ok so I made a bit of a mess here so let's just go ahead and close this out and go back to typing some that stuff out here so what I'm gonna do now is I'm going to bring in like I have another file that I was writing here and just show you some examples of how we can kind of use this property so I have like a little summary of kind of what gone on went on here so mutable types you made will data types oh and of course I've closed that just give me a second guys what's gonna reopen this ok so I've got the file back up sorry about that anyways we have a change list and copy list these are two functions and then we have some operators down here so you can see here what's gonna happen so I'm just gonna actually call these functions down here to kind of illustrate what happens so this first function change list simply appends a hundred to a given list you can see it doesn't return anything all it does is it says l I don't append a hundred okay so what we have to do is we're gonna pass a list so I'm gonna say change list and we'll just do like one two three are actually I have to do like this otherwise we're not gonna be able to track what we're doing so X I give it X and then if I print X down here and I'm just gonna comment out all this so that we don't get that printing instead what happens here is I'm gonna print X so you can see if I do this I get one two three one hundred so again this is the same thing that I was talking about before when we say with the parameter the way parameters work in functions is whatever the past value is becomes equal to this name so Li is this is doing exactly this Li is equal to X that's simply all that it's executing Li equals x so when we pass X in here so okay Li is equal to X well that's one two three and they're the same object so when we change something on Li we're effectively changing X as well now I want to show you what happens when I do copy list so this copy list I haven't talked about what this does yet but I'll do it in just a second I change this to copy list and print X okay so actually I'm going to say I have to say X is equal to copy list year okay so what this copy list does is it creates a copy of the given list so we say x equals to L I here again now we're saying new list is equal to Li square bracket colon square bracket now what this does is it makes a copy so a new object of our list it's not this it's not no longer now pointing to the same object and they're pointing to a different object in memory that are just like identical okay so I hope that makes sense I'm going to explain this more with another like drawing thing after and then we're appending a hundred to that new list and we're returning that new list so let's now run the operation here so X use one two three copy list print X see we get one two three hundred but if I say oops let's just do Y here imprint XY otherwise we're not going to see so X is the original list Y is the change list you can see that we have one two three which was our original list that we passed in and then our new list one two three hundred and notice that hundred is not added to the old list because we simply copied it we did not actually change that original list okay so now I'm gonna talk about this is operator and what this does is it allows us to check whether two items are the same within memory so what I was telling you before was somewhat a lie somewhat true I was telling you that when you create a variable say like x equals one two three it points to a location in memory where we have one two three just a list one two three and not that's it that's not completely true what happens is actually each of these objects have an ID associated with them you see I'm printing ID like this and the ID is like the actual specific location in memory so I'm just gonna get out my tablet and start drawing in okay so I've got everything set up pretty well now and what I want to do is I'm gonna redraw that memory model that I was talking about before except we're gonna change a few things so we're gonna go to this LST here and remember I'm always saying that everything is actually in ID it's not actually the value so this is the value right here like 1 2 3 right but what's actually gonna be stored in this memory model when we create list is in address now this address is known as an ID like what I have done here so the ID will look something not really but it's gonna be like a big string of numbers so I'm just gonna say 0 1 okay now this is an ID this is obviously not the value 1 2 3 now this ID points to a value so we change colors here so that we don't get too confused this is 0 1 points to a value that's gonna be this list and once we go start going further than this it kind of gets a little complicated but we have 1 2 3 like this and this ID points to that value so when I create an alias so like what I've done here let's change back to red what happens is this LST here is given the same ID so these lists so LST points to 0 1 and LST 2 also points to 0 1 now once we have 0 1 0 1 points to 1 2 3 which is that value and that is known as the ID and that's what you can get by doing this little function here that I'm going to talk about ID and then whatever item or object whatever variable name okay so what this is operator does and I'm gonna demonstrate this with code is it checks to see if these two IDs are the same so rather than doing something and I guess I'll write down here by doing like 1 equal equal to 1 which is comparing that the values are the same we're checking if the d is the same so if I say one okay let's I need to uh let's actually just erase that and do like a better example here to kind of show you how this operator works so what I'm gonna do is I'm going to create X or make that equal to one say like a thousand I'm gonna say Y is equal to a thousand now if I were to do something like x equals equals y well that gives us true right because they are the same value but if I did we just say X is y that's actually false now you'd say well what like a thousand is a thousand but the thing is remember what I was saying that we're pointing to different objects when we create the variable so when I create x equals a thousand what ends up happening is we come up here we get an ID that looks like 0 2 okay and this ID now points straw another black line here to a thousand like that okay so boom we're pointing to a thousand all right now when I create Y well same thing that I showed before Y comes up here and it's now actually created to an ID that's 0 3 and 0 3 simply points to the value a thousand like that ok now I know we're gonna be confusing here but try to follow along so when I say is X equal to Y well we go to the ID we say okay so 0 2 that's a thousand 0 3 that's a thousand these are the same boom correct they are equal to when I say X is y where we go just to the IDs we don't care about the value when we say is we just care about the IDs and say well this ID is 02 this one here that I'm underlining and this one here is 0 3 now are those the same well no they're not so obviously this is gonna return false now when we do something like lists okay so I have LST and LST 2 so just go say LST is LST like that well what do you think that's gonna return well LST has an ID of 0 1 and LST 2 also has an ID of 0 1 so that gives us a true value like that now when you create a copy and I guess I'll just show this I'm gonna clear the screen here just cuz I have a big mess I create another like standard memory okay when I create a copy so I say LS t so L s T and then that points over here to we have again our list which looks like zero one two or what am I having one two three K you know what just pretend us has one two three I don't feel like writing it again and then I say LS T 2 equals L is T those point to the same thing but when I say LS t 3 equals LS t and then we have this little colon thing here and I'm just skipping the IDs just to show you here what ends up happening is you say LS T 2 points to and then we actually create a new list so again a new ID and we get well 0 1 & 2 like that so these are no longer pointing to the same object or ID so you can imagine this as like id1 id2 but simply these IDs are unique and they point to the same object like that i hope that makes sense in terms of like when you make a copy you get a new ID with the identical value of whatever you're copying so a new ID for this list like that okay so that's all I'm going to be doing with the drawing I know you guys are probably tired of seeing my horrible handwriting so let's go back to coding where I can't make hey look at that bad ok so now we're back onto the keyword so what I'm gonna do here is I'm just gonna simply print out some of the stuff that you're talking about so I don't need all these functions up here anymore and let's just see so LS t equals 1 2 3 LS t equals or LS t 2 equals LS t so remember I was saying this should print true and then we create a copy of LS t and I say well as LS t is it equal to that no it should return false so let me just prove this to you run so we get true false and then we get the IDs and this is what I want to talk about with the IDs now that we have these open so we have this one what I was talking about before right since this is simply an alias I want this to stay open of the other list we get true because yes they are actually the same list when using this is operator and then LS t3 well that's not an alias of LS to you that's a copy so they don't have the same ID that's false and then I simply just print out the IDs for you to show you exactly what they look like so LS t well that has an ID four nine four three eight three nine two you can see that this indeed is the same ID for Alice and LST 3 has a unique ID with different numbers and I'll just show you if I do something like I don't know i D like to 5/9 like that we get that's the number who say like ID of I don't know let's do something like this like STR we had a different number if I create X equals 90 for our 95 and iidx we get another note right so these IDs are unique and they for what do you call it immutable objects at least but if I create Wow let's do another example LS t equals 1 you say x equals LST ID of X ID of oops LS t we can see that indeed they are the same just one more last proof for any of you that might have been skeptical at there ok so that has been it for explaining immutable and mutable data types I know this was a lot of information and don't feel bad if you're slightly confused but you should hopefully now have an understanding of how kind of the basic memory model in Python works if you have any other questions just let me know
