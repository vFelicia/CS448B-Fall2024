With timestamps:

00:03 - foreign
00:11 - python function explained in part one I
00:14 - shared with you about 30 functions in
00:16 - this part I'm going to share with you
00:17 - the rest of them I'm going to throw the
00:19 - definition up on this screen I'm going
00:21 - to give you a quick example of how each
00:22 - function works and by the end of this
00:24 - you will know some new python functions
00:26 - and I guarantee you that you will learn
00:28 - something with that said if you haven't
00:30 - checked out part one I will leave that
00:31 - on the screen I will also put it in the
00:33 - description and make sure you check out
00:35 - programmingexpert.io that's my
00:37 - programming course if you want to get
00:38 - better at coding Master python learn go
00:41 - learn about software engineering tools
00:43 - and software design it really is one of
00:45 - the best places to become a software
00:47 - engineer with that said let's dive into
00:49 - the video alright so let's dive in here
00:51 - with the first function which is Hash
00:53 - now hashing is used specifically for
00:56 - dictionaries and comparing dictionary
00:57 - keys so whenever you pass a key to a
01:00 - dictionary or you try to access an
01:02 - object you're going to Hash whatever
01:03 - that key is and then compare that with
01:06 - any hashes that currently exist in the
01:08 - dictionary if there's a match then
01:10 - you're going to get the value returned
01:11 - by that hash otherwise you're not right
01:13 - you're going to get a key error anyways
01:15 - I can show you how it works here though
01:16 - we have a random string and we just have
01:19 - a tuple which is a hashable object and
01:21 - if I run this you see we get kind of
01:22 - random strings here random numbers which
01:25 - are the hash of these values now one
01:28 - thing to note here is that you can only
01:30 - hash things that are mutable so I cannot
01:32 - Hash a list like this it just doesn't
01:35 - work right I cannot Hash a list now can
01:37 - I Hash a set let's try this so one two
01:40 - and I cannot hash set but I can hash a
01:43 - tuple so if you ever need some kind of
01:45 - pairing to be used in a dictionary then
01:47 - you're going to use a tuple rather than
01:49 - a list or a set or something like that
01:51 - because a tuple is immutable and hence
01:53 - we can hash it alright so the next
01:55 - function that I have here is len now
01:56 - this stands for length you can use this
01:58 - on any iterable object you can see that
02:01 - we can get the Elena of a list we can
02:02 - get the Len of a string of a dictionary
02:05 - or of a set now we can do this for a few
02:07 - other types as well and we we can also
02:09 - Implement our own Len Dunder method on
02:12 - any of our custom objects so what
02:14 - happens when you actually use this Len
02:15 - function is it calls the Len Dunder
02:18 - method and whatever's returned from that
02:19 - method is what you get when calling lens
02:21 - so in this case we'll get five when we
02:23 - print this out for C so if I run this
02:25 - you can see we get five and then of
02:26 - course the appropriate lengths for the
02:28 - other objects moving on we have list now
02:30 - this is really just the Constructor for
02:32 - the list data type in Python it allows
02:35 - us to convert something to a list now to
02:37 - convert something to a list we need an
02:38 - iterable object so something like a
02:40 - dictionary a set a string a tuple and we
02:43 - simply pass that object to the list
02:45 - Constructor now if we're converting a
02:47 - dictionary to a list that's going to
02:48 - give us all of the keys so we'll give us
02:50 - one two and three not the strings but
02:52 - the keys if we're doing a set is just
02:55 - going to give us all of the unique
02:56 - objects in the set if we're doing a
02:58 - string then we're going to get every
03:00 - single individual character if we're
03:02 - doing a tuple then we're going to get
03:03 - each element that's in this huffle so if
03:05 - I run this you see we get one two three
03:06 - one two three four we get every single
03:08 - character character in our string
03:09 - including the space and then we get all
03:11 - the elements in our Tuple now it's worth
03:13 - noting here that you cannot be certain
03:15 - that your elements are going to be the
03:16 - in the order in which you have them in
03:19 - your dictionary or your set so imagine
03:21 - you have a very large dictionary like
03:22 - we're not just writing out all the
03:24 - values here you're not necessarily going
03:25 - to get sorted values or the values in
03:28 - the order in which you inserted them in
03:29 - the dictionary it could be in
03:30 - potentially a random order alright so
03:32 - moving on we have locals now locals is
03:34 - going to give you information about all
03:36 - of the local variables that you have
03:38 - access to here in the file so if I run
03:40 - this code here you can see that I get
03:42 - this big dictionary containing all of
03:44 - the different variables as well as their
03:46 - value so we have the name of this file
03:49 - which is main we have a few other things
03:51 - that we don't really need to look at and
03:52 - then you can see here that I've printed
03:54 - out like the location of the file so you
03:55 - can see it's on my users Tim desktop
03:57 - every python function part two and then
03:59 - locals.pi now I've just accessed that
04:02 - from the dictionary returned by locals
04:04 - but I also could just use the special
04:05 - name here in Python which is underscore
04:07 - underscore file underscore score
04:09 - underscore alright so moving on we have
04:10 - the map function now the map function
04:12 - allows us to map all of the values in an
04:15 - iterable sequence using a function so
04:17 - what I can do is create a sequence like
04:19 - this I can use my map function I pass a
04:21 - function here now I'm passing an
04:23 - anonymous function but you can pass an
04:25 - actual function if you wanted to and if
04:27 - you were going to pass a function you
04:28 - defined you would just pass the name of
04:29 - the function you would not call the
04:31 - function by putting parentheses so I'm
04:33 - passing a function here which takes one
04:35 - argument which is X and then it's going
04:37 - to raise that to the exponent 2. then
04:39 - I'm going to pass by sequence what's
04:41 - going to happen is each element from my
04:42 - sequence will be passed to this function
04:44 - and get added into a new map object and
04:47 - then what we can do is convert that map
04:49 - object to a list sorry and now we'll get
04:51 - the squares of every single element from
04:53 - our sequence now you can do the same
04:55 - thing here with a dictionary so I've
04:57 - created kind of a more advanced example
04:59 - I guess we have a function what this
05:02 - function does is it takes items which is
05:05 - this array or this list at whatever key
05:07 - is passed to the phone function and then
05:09 - it multiplies it by the key now in this
05:12 - case we're going to have string
05:13 - multiplication and you'll see what kind
05:14 - of happens in this example so if I run
05:16 - this we get all of the squares from 1 to
05:18 - 10 and then we get a BBB and then four
05:21 - C's now the reason we get that result
05:23 - down here is because when you iterate
05:25 - over a dictionary you're going to get
05:28 - every single key that's what's going to
05:30 - be passed to your map function so we
05:32 - pass the key we get the value associated
05:34 - with the key and then we multiply that
05:36 - by the key since the key is a string
05:38 - that's then going to give a string
05:39 - multiplication and that's why we get
05:40 - four C's Three B's and one a moving on
05:43 - we have the max function this allows us
05:45 - to get the maximum value out of an
05:47 - iterable sequence or of multiple
05:49 - arguments there's different ways you can
05:51 - call this first of all we can pass like
05:52 - a list and this is just going to give us
05:54 - the maximum value in this list we can
05:56 - also pass numbers or arguments
05:59 - individually so I've done that here we
06:01 - can do the same with strings now when
06:03 - we're comparing strings we're going to
06:04 - be looking at the ASCII value of each
06:06 - character starting at the first
06:07 - character so we'd start by comparing
06:10 - each string using the first character if
06:12 - two strings have the same first
06:13 - character then we will look at the
06:15 - second character and use the ASCII value
06:17 - of that character
06:19 - next we have just passing multiple
06:22 - iterable sequences here now whenever you
06:24 - pass multiple values so like multiple
06:26 - parameters to this function they need to
06:28 - be the same type so in this case I'm
06:30 - passing three lists and what it's going
06:32 - to do to compare the list is actually
06:34 - use the first element of these lists so
06:36 - it will have this being the maximum
06:38 - element because this list has the
06:40 - greatest first element in it so just
06:42 - like comparing the strings it works the
06:44 - same for a list we can also use this on
06:46 - like a custom type so I have a custom
06:48 - type here and I can pass the key
06:50 - function or the key parameter sorry to
06:52 - my map function and now we're going to
06:54 - be using this to compare so we'll pass
06:57 - every single value to this key function
06:59 - and then whatever the result of that key
07:00 - function is we'll use to pick the
07:02 - largest value so let me run this and
07:04 - notice we get 34 9 yes we get 2 1 as I
07:07 - said and then we get a custom object if
07:10 - I were to print that out you would see
07:11 - that we would get C3 because the value
07:14 - returned by C3 is the largest alright so
07:18 - the next function is a member review
07:19 - this is a little bit complicated but you
07:21 - can use this on bytes types and a few
07:23 - other types while here in Python to kind
07:26 - of dig into the representation of this
07:28 - object so I have a memory view of my
07:30 - variable X which is a byte type that's
07:32 - what the b stands for here and I can
07:34 - look at for example the first index
07:36 - which would correspond with B now notice
07:38 - that when I print this out the first
07:40 - value I get is 98 so it's actually
07:42 - stored in memory for the character B is
07:44 - 98 and 98 is the ASCII representation of
07:48 - this character so if I then convert that
07:50 - ASCII representation to a character
07:51 - notice I get B and so I'm looking at
07:54 - this character here at index one or
07:56 - position one if I try to print out a
07:58 - slice of the memory I can do this and
08:00 - I'm going to get a memory view object or
08:03 - what I can do is convert this slice to a
08:05 - bytes type and now I'm going to get BCD
08:07 - right so if I'm going from one to four
08:09 - that would be here so I'm getting BCD
08:12 - when I actually convert that to bytes if
08:13 - I don't convert to bytes and of course I
08:15 - get the memory representation of that
08:17 - bytes object all right moving on we have
08:20 - the Min function now this is identical
08:22 - to the max function just the minimum
08:24 - value I don't really need to go through
08:25 - this note that you can use the keyword
08:27 - here as well and no pun intended but you
08:30 - can use key as a keyword and then that
08:32 - allows you to select the minimum based
08:34 - on the return value of this function now
08:36 - next we're talking about the next
08:38 - function now this is similar to the
08:40 - annex function that we saw in part one
08:42 - except this is for regular iterators not
08:45 - asynchronous iterators what this will do
08:47 - is give you the next value in an
08:49 - iterable sequence assuming that whatever
08:51 - you're calling this on is an iterator so
08:54 - I have my custom iterator object here
08:55 - notice that I Implement my inner method
08:58 - as well as my next method and now what I
09:00 - can do is create an enter or iterator
09:02 - sorry from my custom object so I create
09:05 - an iterator and then I can call next on
09:07 - it and I will get the next value in the
09:09 - iterable sequence and I can do the same
09:11 - thing using like a built-in object right
09:13 - so if I have a list I can actually get
09:16 - an iterator for this list and then I can
09:18 - call next on that list iterator and get
09:20 - the next value so let me show you this
09:22 - we have one two three ABC again very
09:25 - similar to the annex function just for
09:27 - regular iterators not asynchronous
09:29 - iterators alright so moving on we have
09:31 - the object function this is going to
09:33 - create an empty object for you if you
09:35 - didn't know every single class in Python
09:37 - by default inherits from object so it
09:40 - has some pre-built functionality it's
09:42 - not super useful but I'll run the code
09:43 - and show you that we can print out an
09:45 - object of type object and we can view
09:48 - all of the kind of built-in Behavior
09:50 - default behavior for this type moving on
09:52 - we have the oct function which stands
09:54 - for octal it's going to give us the base
09:56 - 8 representation of a base 10 number so
09:59 - if I print these out you can see that
10:00 - that's what we're getting really you
10:01 - want to be looking at the part after the
10:03 - zero o and notice that you get a
10:05 - negative zero o whenever you have a
10:07 - negative octal value don't need to go
10:09 - through this too much more but this
10:11 - gives you the octal value alright the
10:13 - next function I have for you is open now
10:14 - what this does is open a new file now
10:17 - I've put all of the different modes so
10:18 - you can use when opening a file here I'm
10:20 - not going to go through them feel free
10:22 - to pause the video and read them if you
10:23 - want but let's look at this example down
10:25 - here so I import the Json module just to
10:27 - show you how we can kind of save Json
10:29 - data anyways what I can do is use this
10:31 - open object to open a file in read mode
10:34 - or in write mode or whatever the other
10:36 - modes are so you put the name of the
10:38 - file and then the mode you want to open
10:39 - it in in this case lend dot Pi is a file
10:42 - that does exist then if I wanted to read
10:43 - all of the lines I can use the file
10:45 - object returned by open to say f dot
10:47 - read lines this will give me a list of
10:49 - all of the lines that exist I can print
10:51 - those out and then I can close the file
10:53 - object now the better approach to do
10:55 - this is to use this width which really
10:57 - is going to give you a context manager
10:59 - when you're kind of using this open
11:01 - function so you say with open as F lines
11:04 - equals F dot read lines and then print
11:06 - lines and now you don't need to manually
11:08 - close the file because as soon as you
11:10 - escape this with Block it's
11:11 - automatically going to close the file
11:12 - for you continuing I just wanted to show
11:14 - you how we can save Json data so I'm
11:16 - saying data is equal to and then some
11:18 - dictionary then I'm going to open a new
11:20 - Json file that doesn't already exist so
11:22 - data.json in W mode which stands for
11:25 - write mode I open this as F and then I
11:27 - can say json.dump and then data which is
11:29 - my dictionary and then into the file F
11:32 - and this will create a new file that has
11:33 - that content so if I run this code here
11:36 - you can see that I'm just printing out
11:37 - the contents of the lender apply file
11:40 - but now if we look here I have this
11:41 - data.json file that I created using the
11:44 - open function moving on we have the pal
11:46 - function now what pal will do is raise a
11:49 - base to an exponent we also have the
11:51 - option to get the modulus of a base
11:53 - raised to an exponent if we want so if
11:55 - we use the pound normally we just pass
11:56 - our base and our exponent and we can get
11:58 - 100 and we can also get 0.01 here if we
12:02 - pass like a negative 2 as the exponent
12:04 - continuing we have Pow with Mod now if
12:06 - you pass a third argument here to the
12:08 - pal function you're going to raise the
12:11 - base to the exponent then modulus it by
12:13 - whatever this is so mod 6 and in this
12:16 - case you can see this is kind of the
12:17 - order of operations we raise 11 to
12:19 - exponent 3 that gives us this value we
12:21 - then mod 6 that's going to give us five
12:23 - so when I print this out I get 100 0.01
12:26 - and 5. moving on we have the print
12:29 - function now I'm sure many of you know
12:30 - how this works but we can pass multiple
12:32 - arguments here to the print function
12:34 - they do not need to be strings and they
12:36 - will all be printed out separated by a
12:38 - space by default now if you want to
12:40 - override the default separator you can
12:42 - pass this sep keyword so if I use a pipe
12:45 - now hello enrolled will be separated by
12:47 - a pipe there will not be a space
12:49 - alternatively you can use this end
12:51 - keyword you can also use it in
12:52 - combination with sep and now this means
12:54 - at the end so once this print statement
12:56 - is done rather than printing the default
12:58 - which is an escape character so
13:00 - backslash n
13:01 - you're going to be printing this so
13:04 - usually what would happen is okay would
13:06 - be printed on the next line but since
13:08 - now we're not printing this backslash n
13:10 - which forces the terminal to go to the
13:12 - next line you're going to see that this
13:13 - will be printed directly after hello
13:15 - so let's do this and notice we got hello
13:17 - world one hello Pipe World and then
13:20 - hello end and then okay that's because
13:22 - again we didn't have this backslash n
13:24 - now if I manually add the backslash n in
13:27 - here and I print this out now you notice
13:28 - that we move down to the next one
13:30 - alright so moving on we have property
13:32 - now this allows us to protect an
13:34 - attribute by assigning a getter Setter
13:35 - and deleter you can see I have those
13:37 - here then I have my property function
13:39 - and I pass my getter Setter and deleter
13:41 - you do not need to pass a delete
13:43 - function and you do not need to pass
13:45 - this optional uh what do you call this
13:47 - description of the property so now that
13:49 - I've done this whenever I try to access
13:50 - X on my C-Class it's going to use the
13:53 - getter function to return the value to
13:55 - me when I try to set using an assignment
13:57 - like this it's going to use the setter
13:59 - function and pass my assigned value to
14:01 - Value inside of this function if I tried
14:04 - to delete same thing it would use my
14:06 - delete method or my delete function
14:08 - alright so that's that now we can also
14:11 - use a newer syntax which is The
14:12 - Decorator syntax so I can decorate a
14:15 - function which is is the name of my
14:17 - property then I can have a Setter
14:19 - deleter and getter and this works the
14:21 - exact same as just using the function
14:23 - plainly like this this is probably the
14:25 - preferred approach right now it's kind
14:26 - of modern python but you can use this
14:29 - property as well so just to show you
14:30 - here when I print out var.x you're going
14:33 - to see that since I haven't assigned a
14:34 - value to X it's going to give me 1
14:35 - because that's what the getter says when
14:37 - I set X to 10.2 it's going to round that
14:39 - off to be 10 so then when I print it a
14:41 - second time we should just get 10. so we
14:43 - should get 1 10 and then down here we'll
14:46 - get the same thing so if I run this I
14:48 - get 110 and then 110 this is the exact
14:51 - same example I've just used the
14:53 - decorator syntax alright so the next
14:54 - function I have for you is range now
14:56 - range is useful for for Loops or just
14:58 - generating some range that has a start
15:01 - stop and step value you can pass a start
15:04 - and stop you can just pass a stop or you
15:07 - can pass a start stop and step so the
15:09 - basic rules are the first value you pass
15:12 - is going to be your start the second
15:14 - value is a stop if you have two values
15:16 - if you only pass one value this is going
15:18 - to be your stopping point explain what
15:20 - this means in a second if you pass three
15:22 - values this is going to be the start
15:23 - this is going to be the stop this is
15:24 - going to be the step so you would start
15:26 - at one step by two so you go one three
15:28 - five nine and then you would not go to
15:30 - 11 because that is greater than 10. now
15:33 - this stopping value here is exclusive
15:36 - meaning if I put a 10 here I'm going to
15:37 - stop at 9. so I stop as soon as I hit
15:39 - this value and do not include this value
15:42 - in my range now here when we just put 10
15:44 - this means start at 0 and go to 10 so
15:47 - we're going to have 0 through 9 as our
15:49 - sequence and we when we do something
15:51 - with negative here which is valid we're
15:53 - starting at negative one going to
15:54 - negative 10 stepping by negative 2. so
15:57 - let me print this out and you can see
15:59 - that these are the sequences that we get
16:01 - all right so moving on we have the
16:02 - wrapper function which stands for
16:04 - representation this gives you the
16:06 - internal representation of a python
16:08 - object now the way wrapper works is it
16:11 - looks for this underscore underscore
16:12 - wrapper method if that exists then it
16:14 - will return to you whatever is is
16:16 - returned from that so here I have my pet
16:18 - class I have implemented the rapper
16:20 - Dunder method and now if I run this
16:22 - notice yet pet name equals Billy and pet
16:24 - name equals Sally now the point of this
16:26 - is that this is a debuggable object or
16:29 - debuggable output which makes it easier
16:31 - for me to read than maybe a string
16:33 - representation now a string
16:35 - representation may just say something
16:36 - like my name is Billy or Sally it may be
16:40 - whatever you want to show to the user or
16:42 - kind of a cleaner nicer looking output
16:44 - whereas wrapper is meant to be something
16:46 - that is your internal representation
16:48 - useful for debugging alright so the next
16:50 - function I have is reversed this is
16:52 - simply going to reverse an iterable
16:53 - sequence and give you a reversed
16:55 - iterator now this will give you a new
16:57 - object it will not modify the existing
16:59 - object so I get one two three it's going
17:01 - to give me three two one however it's
17:03 - going to give me this reversed object so
17:05 - if I want to view it then I need to use
17:07 - list now if you're just going to Loop
17:09 - through it that'd be fine because this
17:10 - is an iterator so you can just Loop over
17:12 - the Reversed object return from here but
17:14 - in our case we want to print it out so
17:16 - I'm just converting it to a list so
17:18 - notice I can do this with a list with a
17:19 - tuple with a string with a few other
17:21 - objects but there you go that is how
17:23 - reversed Works alright so the next
17:25 - function I have here is round now round
17:26 - is simply going to round a number for
17:28 - you in this case if you don't pass a
17:30 - second argument it will round to the
17:32 - nearest whole number so we should get 11
17:34 - here if you do pass a second argument
17:36 - this will be the level of precision so
17:38 - we'll round to the fourth decimal place
17:40 - if you pass 10 same thing to the 10th
17:42 - decimal place so when I print this out
17:44 - notice I get 10 10.2342 and then 0.828
17:48 - notice that it is not adding a bunch of
17:50 - zeros here uh when we do 10. there is
17:53 - ways to do that but not with the round
17:55 - function alright so moving on we have
17:57 - the set function now this is the
17:58 - Constructor for the set data type it
18:00 - allows you to pass an iterable sequence
18:02 - and it will create a set from that so
18:04 - it's useful if you want to get all of
18:06 - the unique elements in something like a
18:07 - list now one thing to note here is if
18:09 - you try to do something like s is equal
18:12 - to and then you do curly braces you may
18:14 - think this is going to create a new you
18:15 - set because this is an empty set however
18:17 - this is actually going to make a
18:19 - dictionary because both a set and a
18:21 - dictionary use the syntax so if you want
18:22 - to make an empty set you have to do a
18:24 - new set like this that will give you an
18:26 - empty set that you can then add elements
18:28 - into okay so we can do this with our
18:30 - list I just kind of showed a fancy way
18:32 - of initializing a set here
18:33 - pass a few different elements and then I
18:36 - am unpacking the list and putting all
18:38 - those inside of the set and then
18:40 - printing that out so this is another way
18:42 - to initialize a set we can make a new
18:44 - set and then as I was saying notice
18:45 - there's a new dictionary so if I go here
18:47 - we get our set our set and then class
18:50 - set and class dictionary again if you
18:52 - just use the curly braces gives you a
18:54 - dictionary not a set alright next
18:55 - function I have for you is set attribute
18:57 - or set Adder now what this will do is
19:00 - simply set an attribute on an instance
19:02 - of a class so I create my custom
19:04 - instance I say set Adder C and then I'm
19:07 - going to say the attribute name is X
19:08 - notice I'm putting that in a string I'm
19:10 - going to set that to one and if I print
19:12 - C dot X it's going to give me one there
19:14 - we go alright so next function we have
19:15 - here is slice now what slice does is
19:18 - give you a slice object which you can
19:19 - use to access parts of a list I don't
19:22 - actually know why you would use this
19:24 - over just using the standard slice
19:26 - syntax but you'll see here that when I
19:28 - print LST at s it's kind of injecting
19:31 - this as a slice so the first argument
19:34 - here is going to be your start the
19:36 - second is your stop and the last will be
19:38 - your step now just like the range
19:40 - function if you don't include a first
19:41 - argument it's just a stop if you include
19:44 - two then it's your start and your stop
19:46 - and if you include three then it's your
19:48 - start stop and step so when I do one
19:50 - three start at index one go to but do
19:53 - not include index three so I should get
19:55 - four and six when I do one five and two
19:58 - start at index one go to five which is
20:00 - the end of the list but don't include it
20:01 - step by two so I should get four and
20:04 - eight sorry
20:05 - so if I round this notice 4 6 and 4 8
20:07 - again kind of weird but this gives you a
20:10 - slice that you can kind of inject or use
20:12 - when you're accessing a list or any
20:14 - other iterable object all right moving
20:16 - on we have the sorted function now this
20:18 - is going to return a sorted iterable for
20:20 - you you can use this on lists on strings
20:23 - on dictionaries uh on say nested lists
20:26 - there's all kinds of things you can do
20:27 - so what I've done here is just sorted
20:29 - this by default it's going to sort in
20:31 - ascending order but you can do this in
20:33 - descending now this is going to return a
20:36 - new sequence for you or a new iterable
20:37 - it will not modify the existing object
20:40 - you're calling it on all right uh
20:42 - continuing here we can do this on a
20:43 - dictionary now if we do this on a
20:45 - dictionary by default it's going to use
20:46 - all of the keys so we'll give us a
20:48 - sorted list of the keys and if we want
20:50 - to do this descending then we pass
20:52 - reverse equals true and this will sort
20:54 - in descending order not ascending now I
20:57 - can also pass a key function here and
20:59 - when I do this it's then going to sort
21:01 - every single element that we have based
21:03 - on the key so when I pass something like
21:05 - sum it's going to sum all of the pairs
21:07 - that I have here and then sort by the
21:09 - result of the sum so whatever sum is
21:11 - higher will be I guess at the end
21:13 - because we're sorting in ascending order
21:15 - here okay so let's print this and notice
21:19 - that I get my first list I get my string
21:21 - I get my dictionary keys I get my
21:24 - descending order and then I get my pairs
21:26 - sorted by these alright so next function
21:28 - I have for you here is static method
21:29 - really this is a decorator this allows
21:31 - you to create a static method inside of
21:33 - a Class A static method is one that does
21:36 - not have access to the class or to the
21:38 - instance it's really just like a utility
21:40 - or helper function that kind of belongs
21:42 - with or is associated with a class so
21:44 - notice that I can call this in multiple
21:46 - ways I can use the dot notation on the
21:48 - class name or I can create an instance
21:50 - and then call it directly on the
21:51 - instance when I do this there's no self
21:53 - keyword so I don't have access to the
21:55 - instance or the class because there's no
21:57 - CLS keyword so if I run this I get five
21:59 - and three there you go that is static
22:01 - method alright so moving on I have the
22:03 - string function now the string function
22:05 - will return the string representation of
22:07 - an object useful for converting numbers
22:10 - to Strings or just anything else that
22:12 - you want now one thing to note here is
22:14 - that when you call the print function
22:15 - it's actually actually going to by
22:17 - default call the stringdunder method or
22:20 - the string function on every single
22:22 - object that you pass as an argument so
22:24 - if I pass my list here to print this is
22:27 - the exact same thing as me converting
22:28 - this to a string first and then printing
22:31 - it out so kind of an interesting note
22:33 - but whenever you print something it
22:34 - calls the stringdunder method on that
22:37 - object and then whatever that result is
22:39 - is what it actually prints out
22:41 - so we can convert many different things
22:42 - to Strings we can convert a set to a
22:44 - string we can also convert our own
22:46 - custom object by implementing the
22:48 - stringdunder method so if I run this
22:50 - notice I get the string representation
22:52 - of my list of my integer of my what is
22:55 - this a set and then of my custom object
22:57 - which is something that I've implemented
22:59 - moving on here we have the sum function
23:01 - now this is pretty straightforward but
23:02 - this is going to sum all of the values
23:04 - in an iterable sequence one thing you
23:07 - can do here that's cool with the sum
23:08 - function is pass a start value now when
23:11 - you do this you're going to be adding
23:12 - whatever the start is to the sum so kind
23:14 - of would save you an additional step of
23:16 - doing something like you know five plus
23:18 - all right let's have a look here when I
23:20 - sum this I get 37.3 42.3 even though
23:23 - it's the same list because I add this 5
23:25 - and then I sum my set which will be all
23:28 - of the unique elements and that gives me
23:30 - 50. next we have the super function this
23:32 - allows us to access attributes or
23:34 - methods from the parent class directly
23:36 - so when I have class parent here and
23:38 - then I inherit from that in my child
23:40 - class and now super is going to
23:42 - reference all of the stuff inside of the
23:44 - parent class if you have multiple
23:46 - inheritance it gets a bit complicated I
23:48 - won't get into that here but super is
23:50 - referencing your parent or parents class
23:52 - so what I can do with my initialization
23:55 - here is I can call the parent
23:56 - Constructor by saying super dot
23:58 - underscore underscore knit underscore
24:00 - underscore and then passing any value
24:02 - that's required to initialize the parent
24:04 - class I also can do something like super
24:06 - dot Funk and when I do that I'm now
24:08 - calling the Funk from the parent class
24:10 - as opposed to the funk that I have
24:12 - inside of my child class so notice here
24:14 - when I call c.funk it will call this
24:16 - when I do call parents it's going to
24:18 - call self.funk which will be this and
24:20 - then Super dot Funk which will be this
24:22 - alright so let's run and notice I got
24:24 - child child and then parent so moving on
24:26 - we have the Tuple function this is going
24:28 - to convert something to a tuple if I do
24:31 - something like convert a list of pairs
24:32 - then it's simply going to replace the
24:34 - list with a tuple and make this an
24:36 - immutable sequence so if I run this
24:38 - notice I get a tuple it does not convert
24:40 - all the objects inside of my list to a
24:42 - tuple just the object itself now if I
24:45 - use this on something like a string then
24:46 - I get all of the individual characters
24:48 - in my Tuple in the order in which they
24:50 - occurred in the string alright so the
24:52 - next function we have is type now type
24:54 - can be used in a very simple sense you
24:56 - just get the type of an object we also
24:58 - can use type though to create our own
25:00 - classes now I know this seems a bit
25:02 - weird I won't get into it too much but I
25:04 - can actually use it in this Advanced
25:06 - kind of use case to create my own class
25:09 - so I pass the class name I pass anything
25:11 - I want to inherit from and then I pass a
25:13 - dictionary containing all of the
25:14 - attributes or functions associated with
25:16 - my class so when I say attribute I am an
25:19 - attribute now it creates an attribute on
25:21 - this class and when I do add one it now
25:23 - creates an add one function because I'm
25:25 - passing a function here so if I do C
25:28 - equals class name now I can use this
25:29 - just like a class I can access the
25:31 - attribute I can call the add function so
25:33 - if I run this I get I'm an attribute N3
25:36 - and notice I pass 2 it added one and
25:38 - well there you go now if we just use it
25:40 - in the SIM simple sense we get whatever
25:42 - the classes or the type of the object
25:46 - that we're calling it on alright so the
25:47 - next function I have here is Mars now
25:49 - vars is going to give you all of the
25:51 - variables or attributes associated with
25:53 - a specific object or type so in this
25:56 - case I can print out just bars with
25:58 - nothing and when I do that it gives me
25:59 - all of the globally accessible variables
26:01 - which we've already kind of looked at if
26:04 - we do VAR and then list it's going to
26:05 - give us all the attributes associated
26:07 - with this list type and if we call this
26:09 - on our custom class then same thing all
26:12 - of the attributes associated with the
26:13 - custom class so when I run this here
26:15 - notice that we get a bunch of stuff
26:18 - printing out right so we get name doc
26:20 - all this kind of stuff and then on our
26:21 - own custom object we get all of the
26:24 - default uh kind of implemented stuff
26:26 - right I know seems a little bit weird
26:28 - but there you go that is how vars works
26:31 - now moving on to our final function
26:32 - which is zip now what zip allows us to
26:35 - do is actually group multiple iterable
26:37 - objects together into separate tuples or
26:40 - separate pairing now the way this works
26:42 - is you pass whatever iterable objects
26:44 - you want and then it's going to Loop
26:46 - through and essentially take all of the
26:48 - associated indices and put them together
26:50 - in a tuple so let me just show you what
26:52 - I mean if we start here we can see that
26:55 - we have a zip object so it gives us a
26:57 - zip iterable we can also just convert
26:59 - this to a list but notice I have four
27:01 - five five three six one seven two two
27:03 - three one one and those are all of the
27:05 - indexes that associate with each other
27:08 - now we can call this on stuff that is
27:10 - different lengths or different types
27:11 - when we do that it's only going to go up
27:13 - to the length of the smallest object so
27:16 - in this case I only have three elements
27:17 - whereas here I have five so you see that
27:19 - we get H1 E2 and L3 so very useful and
27:23 - you want to group multiple iterable
27:25 - objects together you can also call this
27:27 - with three values or four or as many as
27:29 - you want so if I do this with widths now
27:32 - notice that I get kind of triplets right
27:34 - in a tuple all right so with that said
27:36 - I'm gonna wrap up the video here I hope
27:38 - this was helpful to you and that you
27:39 - learned some new python functions and
27:41 - some new python syntax if you enjoyed
27:43 - make sure you leave a like subscribe to
27:45 - the channel check out
27:46 - programmingexpert.io and I will see you
27:48 - in another YouTube video
27:50 - [Music]
27:53 - foreign
27:54 - [Music]

Cleaned transcript:

foreign python function explained in part one I shared with you about 30 functions in this part I'm going to share with you the rest of them I'm going to throw the definition up on this screen I'm going to give you a quick example of how each function works and by the end of this you will know some new python functions and I guarantee you that you will learn something with that said if you haven't checked out part one I will leave that on the screen I will also put it in the description and make sure you check out programmingexpert.io that's my programming course if you want to get better at coding Master python learn go learn about software engineering tools and software design it really is one of the best places to become a software engineer with that said let's dive into the video alright so let's dive in here with the first function which is Hash now hashing is used specifically for dictionaries and comparing dictionary keys so whenever you pass a key to a dictionary or you try to access an object you're going to Hash whatever that key is and then compare that with any hashes that currently exist in the dictionary if there's a match then you're going to get the value returned by that hash otherwise you're not right you're going to get a key error anyways I can show you how it works here though we have a random string and we just have a tuple which is a hashable object and if I run this you see we get kind of random strings here random numbers which are the hash of these values now one thing to note here is that you can only hash things that are mutable so I cannot Hash a list like this it just doesn't work right I cannot Hash a list now can I Hash a set let's try this so one two and I cannot hash set but I can hash a tuple so if you ever need some kind of pairing to be used in a dictionary then you're going to use a tuple rather than a list or a set or something like that because a tuple is immutable and hence we can hash it alright so the next function that I have here is len now this stands for length you can use this on any iterable object you can see that we can get the Elena of a list we can get the Len of a string of a dictionary or of a set now we can do this for a few other types as well and we we can also Implement our own Len Dunder method on any of our custom objects so what happens when you actually use this Len function is it calls the Len Dunder method and whatever's returned from that method is what you get when calling lens so in this case we'll get five when we print this out for C so if I run this you can see we get five and then of course the appropriate lengths for the other objects moving on we have list now this is really just the Constructor for the list data type in Python it allows us to convert something to a list now to convert something to a list we need an iterable object so something like a dictionary a set a string a tuple and we simply pass that object to the list Constructor now if we're converting a dictionary to a list that's going to give us all of the keys so we'll give us one two and three not the strings but the keys if we're doing a set is just going to give us all of the unique objects in the set if we're doing a string then we're going to get every single individual character if we're doing a tuple then we're going to get each element that's in this huffle so if I run this you see we get one two three one two three four we get every single character character in our string including the space and then we get all the elements in our Tuple now it's worth noting here that you cannot be certain that your elements are going to be the in the order in which you have them in your dictionary or your set so imagine you have a very large dictionary like we're not just writing out all the values here you're not necessarily going to get sorted values or the values in the order in which you inserted them in the dictionary it could be in potentially a random order alright so moving on we have locals now locals is going to give you information about all of the local variables that you have access to here in the file so if I run this code here you can see that I get this big dictionary containing all of the different variables as well as their value so we have the name of this file which is main we have a few other things that we don't really need to look at and then you can see here that I've printed out like the location of the file so you can see it's on my users Tim desktop every python function part two and then locals.pi now I've just accessed that from the dictionary returned by locals but I also could just use the special name here in Python which is underscore underscore file underscore score underscore alright so moving on we have the map function now the map function allows us to map all of the values in an iterable sequence using a function so what I can do is create a sequence like this I can use my map function I pass a function here now I'm passing an anonymous function but you can pass an actual function if you wanted to and if you were going to pass a function you defined you would just pass the name of the function you would not call the function by putting parentheses so I'm passing a function here which takes one argument which is X and then it's going to raise that to the exponent 2. then I'm going to pass by sequence what's going to happen is each element from my sequence will be passed to this function and get added into a new map object and then what we can do is convert that map object to a list sorry and now we'll get the squares of every single element from our sequence now you can do the same thing here with a dictionary so I've created kind of a more advanced example I guess we have a function what this function does is it takes items which is this array or this list at whatever key is passed to the phone function and then it multiplies it by the key now in this case we're going to have string multiplication and you'll see what kind of happens in this example so if I run this we get all of the squares from 1 to 10 and then we get a BBB and then four C's now the reason we get that result down here is because when you iterate over a dictionary you're going to get every single key that's what's going to be passed to your map function so we pass the key we get the value associated with the key and then we multiply that by the key since the key is a string that's then going to give a string multiplication and that's why we get four C's Three B's and one a moving on we have the max function this allows us to get the maximum value out of an iterable sequence or of multiple arguments there's different ways you can call this first of all we can pass like a list and this is just going to give us the maximum value in this list we can also pass numbers or arguments individually so I've done that here we can do the same with strings now when we're comparing strings we're going to be looking at the ASCII value of each character starting at the first character so we'd start by comparing each string using the first character if two strings have the same first character then we will look at the second character and use the ASCII value of that character next we have just passing multiple iterable sequences here now whenever you pass multiple values so like multiple parameters to this function they need to be the same type so in this case I'm passing three lists and what it's going to do to compare the list is actually use the first element of these lists so it will have this being the maximum element because this list has the greatest first element in it so just like comparing the strings it works the same for a list we can also use this on like a custom type so I have a custom type here and I can pass the key function or the key parameter sorry to my map function and now we're going to be using this to compare so we'll pass every single value to this key function and then whatever the result of that key function is we'll use to pick the largest value so let me run this and notice we get 34 9 yes we get 2 1 as I said and then we get a custom object if I were to print that out you would see that we would get C3 because the value returned by C3 is the largest alright so the next function is a member review this is a little bit complicated but you can use this on bytes types and a few other types while here in Python to kind of dig into the representation of this object so I have a memory view of my variable X which is a byte type that's what the b stands for here and I can look at for example the first index which would correspond with B now notice that when I print this out the first value I get is 98 so it's actually stored in memory for the character B is 98 and 98 is the ASCII representation of this character so if I then convert that ASCII representation to a character notice I get B and so I'm looking at this character here at index one or position one if I try to print out a slice of the memory I can do this and I'm going to get a memory view object or what I can do is convert this slice to a bytes type and now I'm going to get BCD right so if I'm going from one to four that would be here so I'm getting BCD when I actually convert that to bytes if I don't convert to bytes and of course I get the memory representation of that bytes object all right moving on we have the Min function now this is identical to the max function just the minimum value I don't really need to go through this note that you can use the keyword here as well and no pun intended but you can use key as a keyword and then that allows you to select the minimum based on the return value of this function now next we're talking about the next function now this is similar to the annex function that we saw in part one except this is for regular iterators not asynchronous iterators what this will do is give you the next value in an iterable sequence assuming that whatever you're calling this on is an iterator so I have my custom iterator object here notice that I Implement my inner method as well as my next method and now what I can do is create an enter or iterator sorry from my custom object so I create an iterator and then I can call next on it and I will get the next value in the iterable sequence and I can do the same thing using like a builtin object right so if I have a list I can actually get an iterator for this list and then I can call next on that list iterator and get the next value so let me show you this we have one two three ABC again very similar to the annex function just for regular iterators not asynchronous iterators alright so moving on we have the object function this is going to create an empty object for you if you didn't know every single class in Python by default inherits from object so it has some prebuilt functionality it's not super useful but I'll run the code and show you that we can print out an object of type object and we can view all of the kind of builtin Behavior default behavior for this type moving on we have the oct function which stands for octal it's going to give us the base 8 representation of a base 10 number so if I print these out you can see that that's what we're getting really you want to be looking at the part after the zero o and notice that you get a negative zero o whenever you have a negative octal value don't need to go through this too much more but this gives you the octal value alright the next function I have for you is open now what this does is open a new file now I've put all of the different modes so you can use when opening a file here I'm not going to go through them feel free to pause the video and read them if you want but let's look at this example down here so I import the Json module just to show you how we can kind of save Json data anyways what I can do is use this open object to open a file in read mode or in write mode or whatever the other modes are so you put the name of the file and then the mode you want to open it in in this case lend dot Pi is a file that does exist then if I wanted to read all of the lines I can use the file object returned by open to say f dot read lines this will give me a list of all of the lines that exist I can print those out and then I can close the file object now the better approach to do this is to use this width which really is going to give you a context manager when you're kind of using this open function so you say with open as F lines equals F dot read lines and then print lines and now you don't need to manually close the file because as soon as you escape this with Block it's automatically going to close the file for you continuing I just wanted to show you how we can save Json data so I'm saying data is equal to and then some dictionary then I'm going to open a new Json file that doesn't already exist so data.json in W mode which stands for write mode I open this as F and then I can say json.dump and then data which is my dictionary and then into the file F and this will create a new file that has that content so if I run this code here you can see that I'm just printing out the contents of the lender apply file but now if we look here I have this data.json file that I created using the open function moving on we have the pal function now what pal will do is raise a base to an exponent we also have the option to get the modulus of a base raised to an exponent if we want so if we use the pound normally we just pass our base and our exponent and we can get 100 and we can also get 0.01 here if we pass like a negative 2 as the exponent continuing we have Pow with Mod now if you pass a third argument here to the pal function you're going to raise the base to the exponent then modulus it by whatever this is so mod 6 and in this case you can see this is kind of the order of operations we raise 11 to exponent 3 that gives us this value we then mod 6 that's going to give us five so when I print this out I get 100 0.01 and 5. moving on we have the print function now I'm sure many of you know how this works but we can pass multiple arguments here to the print function they do not need to be strings and they will all be printed out separated by a space by default now if you want to override the default separator you can pass this sep keyword so if I use a pipe now hello enrolled will be separated by a pipe there will not be a space alternatively you can use this end keyword you can also use it in combination with sep and now this means at the end so once this print statement is done rather than printing the default which is an escape character so backslash n you're going to be printing this so usually what would happen is okay would be printed on the next line but since now we're not printing this backslash n which forces the terminal to go to the next line you're going to see that this will be printed directly after hello so let's do this and notice we got hello world one hello Pipe World and then hello end and then okay that's because again we didn't have this backslash n now if I manually add the backslash n in here and I print this out now you notice that we move down to the next one alright so moving on we have property now this allows us to protect an attribute by assigning a getter Setter and deleter you can see I have those here then I have my property function and I pass my getter Setter and deleter you do not need to pass a delete function and you do not need to pass this optional uh what do you call this description of the property so now that I've done this whenever I try to access X on my CClass it's going to use the getter function to return the value to me when I try to set using an assignment like this it's going to use the setter function and pass my assigned value to Value inside of this function if I tried to delete same thing it would use my delete method or my delete function alright so that's that now we can also use a newer syntax which is The Decorator syntax so I can decorate a function which is is the name of my property then I can have a Setter deleter and getter and this works the exact same as just using the function plainly like this this is probably the preferred approach right now it's kind of modern python but you can use this property as well so just to show you here when I print out var.x you're going to see that since I haven't assigned a value to X it's going to give me 1 because that's what the getter says when I set X to 10.2 it's going to round that off to be 10 so then when I print it a second time we should just get 10. so we should get 1 10 and then down here we'll get the same thing so if I run this I get 110 and then 110 this is the exact same example I've just used the decorator syntax alright so the next function I have for you is range now range is useful for for Loops or just generating some range that has a start stop and step value you can pass a start and stop you can just pass a stop or you can pass a start stop and step so the basic rules are the first value you pass is going to be your start the second value is a stop if you have two values if you only pass one value this is going to be your stopping point explain what this means in a second if you pass three values this is going to be the start this is going to be the stop this is going to be the step so you would start at one step by two so you go one three five nine and then you would not go to 11 because that is greater than 10. now this stopping value here is exclusive meaning if I put a 10 here I'm going to stop at 9. so I stop as soon as I hit this value and do not include this value in my range now here when we just put 10 this means start at 0 and go to 10 so we're going to have 0 through 9 as our sequence and we when we do something with negative here which is valid we're starting at negative one going to negative 10 stepping by negative 2. so let me print this out and you can see that these are the sequences that we get all right so moving on we have the wrapper function which stands for representation this gives you the internal representation of a python object now the way wrapper works is it looks for this underscore underscore wrapper method if that exists then it will return to you whatever is is returned from that so here I have my pet class I have implemented the rapper Dunder method and now if I run this notice yet pet name equals Billy and pet name equals Sally now the point of this is that this is a debuggable object or debuggable output which makes it easier for me to read than maybe a string representation now a string representation may just say something like my name is Billy or Sally it may be whatever you want to show to the user or kind of a cleaner nicer looking output whereas wrapper is meant to be something that is your internal representation useful for debugging alright so the next function I have is reversed this is simply going to reverse an iterable sequence and give you a reversed iterator now this will give you a new object it will not modify the existing object so I get one two three it's going to give me three two one however it's going to give me this reversed object so if I want to view it then I need to use list now if you're just going to Loop through it that'd be fine because this is an iterator so you can just Loop over the Reversed object return from here but in our case we want to print it out so I'm just converting it to a list so notice I can do this with a list with a tuple with a string with a few other objects but there you go that is how reversed Works alright so the next function I have here is round now round is simply going to round a number for you in this case if you don't pass a second argument it will round to the nearest whole number so we should get 11 here if you do pass a second argument this will be the level of precision so we'll round to the fourth decimal place if you pass 10 same thing to the 10th decimal place so when I print this out notice I get 10 10.2342 and then 0.828 notice that it is not adding a bunch of zeros here uh when we do 10. there is ways to do that but not with the round function alright so moving on we have the set function now this is the Constructor for the set data type it allows you to pass an iterable sequence and it will create a set from that so it's useful if you want to get all of the unique elements in something like a list now one thing to note here is if you try to do something like s is equal to and then you do curly braces you may think this is going to create a new you set because this is an empty set however this is actually going to make a dictionary because both a set and a dictionary use the syntax so if you want to make an empty set you have to do a new set like this that will give you an empty set that you can then add elements into okay so we can do this with our list I just kind of showed a fancy way of initializing a set here pass a few different elements and then I am unpacking the list and putting all those inside of the set and then printing that out so this is another way to initialize a set we can make a new set and then as I was saying notice there's a new dictionary so if I go here we get our set our set and then class set and class dictionary again if you just use the curly braces gives you a dictionary not a set alright next function I have for you is set attribute or set Adder now what this will do is simply set an attribute on an instance of a class so I create my custom instance I say set Adder C and then I'm going to say the attribute name is X notice I'm putting that in a string I'm going to set that to one and if I print C dot X it's going to give me one there we go alright so next function we have here is slice now what slice does is give you a slice object which you can use to access parts of a list I don't actually know why you would use this over just using the standard slice syntax but you'll see here that when I print LST at s it's kind of injecting this as a slice so the first argument here is going to be your start the second is your stop and the last will be your step now just like the range function if you don't include a first argument it's just a stop if you include two then it's your start and your stop and if you include three then it's your start stop and step so when I do one three start at index one go to but do not include index three so I should get four and six when I do one five and two start at index one go to five which is the end of the list but don't include it step by two so I should get four and eight sorry so if I round this notice 4 6 and 4 8 again kind of weird but this gives you a slice that you can kind of inject or use when you're accessing a list or any other iterable object all right moving on we have the sorted function now this is going to return a sorted iterable for you you can use this on lists on strings on dictionaries uh on say nested lists there's all kinds of things you can do so what I've done here is just sorted this by default it's going to sort in ascending order but you can do this in descending now this is going to return a new sequence for you or a new iterable it will not modify the existing object you're calling it on all right uh continuing here we can do this on a dictionary now if we do this on a dictionary by default it's going to use all of the keys so we'll give us a sorted list of the keys and if we want to do this descending then we pass reverse equals true and this will sort in descending order not ascending now I can also pass a key function here and when I do this it's then going to sort every single element that we have based on the key so when I pass something like sum it's going to sum all of the pairs that I have here and then sort by the result of the sum so whatever sum is higher will be I guess at the end because we're sorting in ascending order here okay so let's print this and notice that I get my first list I get my string I get my dictionary keys I get my descending order and then I get my pairs sorted by these alright so next function I have for you here is static method really this is a decorator this allows you to create a static method inside of a Class A static method is one that does not have access to the class or to the instance it's really just like a utility or helper function that kind of belongs with or is associated with a class so notice that I can call this in multiple ways I can use the dot notation on the class name or I can create an instance and then call it directly on the instance when I do this there's no self keyword so I don't have access to the instance or the class because there's no CLS keyword so if I run this I get five and three there you go that is static method alright so moving on I have the string function now the string function will return the string representation of an object useful for converting numbers to Strings or just anything else that you want now one thing to note here is that when you call the print function it's actually actually going to by default call the stringdunder method or the string function on every single object that you pass as an argument so if I pass my list here to print this is the exact same thing as me converting this to a string first and then printing it out so kind of an interesting note but whenever you print something it calls the stringdunder method on that object and then whatever that result is is what it actually prints out so we can convert many different things to Strings we can convert a set to a string we can also convert our own custom object by implementing the stringdunder method so if I run this notice I get the string representation of my list of my integer of my what is this a set and then of my custom object which is something that I've implemented moving on here we have the sum function now this is pretty straightforward but this is going to sum all of the values in an iterable sequence one thing you can do here that's cool with the sum function is pass a start value now when you do this you're going to be adding whatever the start is to the sum so kind of would save you an additional step of doing something like you know five plus all right let's have a look here when I sum this I get 37.3 42.3 even though it's the same list because I add this 5 and then I sum my set which will be all of the unique elements and that gives me 50. next we have the super function this allows us to access attributes or methods from the parent class directly so when I have class parent here and then I inherit from that in my child class and now super is going to reference all of the stuff inside of the parent class if you have multiple inheritance it gets a bit complicated I won't get into that here but super is referencing your parent or parents class so what I can do with my initialization here is I can call the parent Constructor by saying super dot underscore underscore knit underscore underscore and then passing any value that's required to initialize the parent class I also can do something like super dot Funk and when I do that I'm now calling the Funk from the parent class as opposed to the funk that I have inside of my child class so notice here when I call c.funk it will call this when I do call parents it's going to call self.funk which will be this and then Super dot Funk which will be this alright so let's run and notice I got child child and then parent so moving on we have the Tuple function this is going to convert something to a tuple if I do something like convert a list of pairs then it's simply going to replace the list with a tuple and make this an immutable sequence so if I run this notice I get a tuple it does not convert all the objects inside of my list to a tuple just the object itself now if I use this on something like a string then I get all of the individual characters in my Tuple in the order in which they occurred in the string alright so the next function we have is type now type can be used in a very simple sense you just get the type of an object we also can use type though to create our own classes now I know this seems a bit weird I won't get into it too much but I can actually use it in this Advanced kind of use case to create my own class so I pass the class name I pass anything I want to inherit from and then I pass a dictionary containing all of the attributes or functions associated with my class so when I say attribute I am an attribute now it creates an attribute on this class and when I do add one it now creates an add one function because I'm passing a function here so if I do C equals class name now I can use this just like a class I can access the attribute I can call the add function so if I run this I get I'm an attribute N3 and notice I pass 2 it added one and well there you go now if we just use it in the SIM simple sense we get whatever the classes or the type of the object that we're calling it on alright so the next function I have here is Mars now vars is going to give you all of the variables or attributes associated with a specific object or type so in this case I can print out just bars with nothing and when I do that it gives me all of the globally accessible variables which we've already kind of looked at if we do VAR and then list it's going to give us all the attributes associated with this list type and if we call this on our custom class then same thing all of the attributes associated with the custom class so when I run this here notice that we get a bunch of stuff printing out right so we get name doc all this kind of stuff and then on our own custom object we get all of the default uh kind of implemented stuff right I know seems a little bit weird but there you go that is how vars works now moving on to our final function which is zip now what zip allows us to do is actually group multiple iterable objects together into separate tuples or separate pairing now the way this works is you pass whatever iterable objects you want and then it's going to Loop through and essentially take all of the associated indices and put them together in a tuple so let me just show you what I mean if we start here we can see that we have a zip object so it gives us a zip iterable we can also just convert this to a list but notice I have four five five three six one seven two two three one one and those are all of the indexes that associate with each other now we can call this on stuff that is different lengths or different types when we do that it's only going to go up to the length of the smallest object so in this case I only have three elements whereas here I have five so you see that we get H1 E2 and L3 so very useful and you want to group multiple iterable objects together you can also call this with three values or four or as many as you want so if I do this with widths now notice that I get kind of triplets right in a tuple all right so with that said I'm gonna wrap up the video here I hope this was helpful to you and that you learned some new python functions and some new python syntax if you enjoyed make sure you leave a like subscribe to the channel check out programmingexpert.io and I will see you in another YouTube video foreign
