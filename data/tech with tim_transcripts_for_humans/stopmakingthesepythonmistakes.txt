With timestamps:

00:02 - [Music]
00:08 - if you're watching this video and you
00:10 - write code in python then chances are
00:12 - you're familiar with what a unique
00:13 - language it is and you utilize some of
00:15 - the awesome features that python
00:17 - provides now this is great and python is
00:19 - an awesome language but because it is
00:21 - pretty unique and it's not like a lot of
00:24 - the traditional programming languages
00:26 - there's a lot of ways that you can make
00:27 - mistakes in python without really
00:29 - realizing it python is as i said a
00:32 - unique and kind of quirky language it
00:34 - allows you to do a ton of stuff and it's
00:35 - very flexible but with that flexibility
00:38 - it allows you to make a bunch of
00:39 - mistakes that are really hard to catch
00:42 - if you haven't watched a video like this
00:44 - so with that said let's get into this
00:46 - video and i'm gonna walk you through
00:47 - some mistakes that you're probably
00:49 - making in python and that you can easily
00:51 - fix by going through these tips so the
00:53 - first mistake that i'm sure many of you
00:55 - are making is that you haven't checked
00:56 - out my programming course yet called
00:57 - programming expert i'll leave it in the
00:59 - description this is a unique course that
01:01 - teaches python specifically some more
01:03 - advanced features of python and we
01:05 - recently added go to it as a second
01:07 - language so don't make that mistake
01:09 - check that out from the link in the
01:10 - description but in all seriousness here
01:12 - the first mistake that you're probably
01:13 - making is something called name
01:15 - shadowing now name shadowing occurs when
01:17 - you name your variable parameter
01:19 - function really anything you're defining
01:21 - a name for a built-in function some
01:24 - built-in name or something in the
01:26 - current scope that's already defined so
01:28 - for example here if we have this
01:30 - function called get database record we
01:32 - have a parameter here called id now this
01:35 - is a shadowed name and the reason this
01:37 - is shadowed is because you're naming
01:38 - this a built-in function so in python we
01:41 - actually have a built-in function here
01:43 - called id many people don't know about
01:45 - this function and so they'll do
01:47 - something like this where they write a
01:48 - function and then they name this
01:50 - parameter they give a parameter name of
01:52 - id now you'll notice here when i write
01:54 - id i'm getting the syntax highlighting
01:57 - as if it was a function because that's
01:58 - what python knows to do but this is not
02:01 - going to be treated as a function it's
02:02 - going to be treated as the parameter so
02:04 - that is the intended behavior when we're
02:06 - looking at a function like this but it
02:07 - can be really confusing if you're
02:09 - familiar with the built-in functions and
02:11 - you have kind of a long function or a
02:13 - long class or something like that when
02:15 - you're reading shadowed names so really
02:17 - you want to avoid name shadowing as much
02:19 - as you can and one of the only ways to
02:20 - do that in python is just to ensure that
02:22 - you're not naming your parameters
02:24 - functions etc a built-in name so
02:27 - something like id uh maybe something
02:29 - like max that's a really common one
02:31 - something like min you want to avoid
02:33 - those names because again they are built
02:35 - in functions and if you do name
02:36 - something that in the current scope so
02:38 - in this function you can no longer use
02:40 - this as the function so if i try to do
02:42 - something like id here let's just call
02:45 - this function so get database record
02:47 - let's pass in one notice it says the int
02:50 - object is not callable because i've
02:51 - overridden the id function by shadowing
02:54 - its name now this can occur when you
02:56 - have nested functions as well and all
02:58 - and in all kinds of other scenarios
03:00 - another really common thing here is when
03:02 - you shadow a name from the global scope
03:04 - so for example
03:06 - if i make my parameter here named
03:08 - database or i accept maybe like id and
03:11 - database like that again if you have a
03:13 - longer function it can be confusing when
03:15 - i'm reading this code if i'm referring
03:17 - to the database parameter if i spelled
03:19 - that correctly or the database variable
03:21 - in the global scope so obviously this
03:23 - isn't always avoidable the main thing
03:25 - here is just don't name your parameters
03:27 - or variables a built-in name like max
03:30 - min id not only because it's confusing
03:32 - but because you also now make it so you
03:34 - can no longer use those functions inside
03:37 - of wherever you've given that name so
03:38 - another mistake that you are likely
03:40 - unintentionally making in python is
03:42 - using a mutable object as the default
03:45 - value for an optional parameter now i
03:47 - know that's a mouthful but if you look
03:49 - here at this function it's called
03:50 - mutable parameter and we have an
03:52 - optional parameter we know it's optional
03:54 - because we have it assigned to a default
03:56 - value if you don't pass it it gets the
03:57 - default value and the default value is a
03:59 - mutable object which is a list
04:02 - now let me show you why this is bad
04:04 - by running the code so when i run the
04:06 - code we actually get an unexpected
04:08 - output if you're from another
04:09 - programming language where we get one
04:11 - two one two one two and then one two one
04:13 - two one two now the reason this occurs
04:16 - is because this is mutable that means we
04:18 - can actually mutate it we can change it
04:20 - in place so when i do something like
04:22 - lst.pen1 and lst.pen2 i'm actually
04:26 - mutating this list right here which is
04:28 - the same list that's going to be the
04:30 - default value for the next call to this
04:33 - function so you can see on every
04:35 - consecutive call we're actually adding
04:37 - elements to this same list this list
04:39 - does not get recreated every single time
04:42 - the function is called it gets created
04:44 - one time when we define the function
04:47 - that's the way that the the default
04:48 - value works here so if you want to avoid
04:50 - this and you do want to actually have a
04:53 - mutable value or immutable object as
04:55 - your default parameter you should do
04:57 - something like this instead
04:59 - and then manually check inside of the
05:00 - function if this is none so i'm going to
05:02 - say if lst
05:05 - is none then i will say lst is equal to
05:08 - and make that a list so now if i run
05:10 - this notice we don't get that error
05:12 - anymore because i'm recreating a new
05:14 - list object every function call as a
05:17 - post using the same one that's only
05:19 - created one time when my program is
05:21 - actually kind of initialized in the
05:23 - function is read by the interpreter
05:25 - hopefully that makes a bit of sense try
05:26 - not to make this issue or try not to
05:28 - make this mistake this also happens if
05:30 - you use dictionaries if you use sets and
05:32 - any other mutable object so the next
05:34 - mistake i have here is a more general
05:36 - one this could apply to any programming
05:38 - language and this is modifying an
05:40 - iterable object while you're iterating
05:42 - through it so in this case i have
05:44 - something that's iterable which is a
05:45 - list just means i can loop through it
05:47 - right using a for loop in this case and
05:49 - i have 4i comma value in a numerator
05:51 - list so it's going to give me the value
05:52 - as well as the index of each element and
05:54 - i'm saying if the index is divisible by
05:57 - 2 then i'm going to pop this index from
06:00 - my list
06:01 - now if you're looking at this here and
06:02 - you just kind of take all the indices
06:04 - and apply this to it we should be
06:06 - popping one we should be popping three
06:08 - because that's index two we should be
06:10 - popping five that's index four popping
06:12 - seven and then popping nine however when
06:16 - i run this notice that i get kind of a
06:17 - weird result i get two 235689
06:20 - [Music]
06:21 - kind of strange why i'm getting that but
06:24 - the reason is because i'm modifying this
06:26 - iterable object while i'm looping
06:28 - through it so if i have a look here and
06:30 - i print out i
06:31 - value and actually let's not print out
06:33 - value let's print out i and lst and
06:35 - let's have a look at it at every
06:36 - iteration we see i zero and then one two
06:40 - three four five all the way up until six
06:42 - and what happens is we don't actually
06:44 - end up iterating through every unique
06:46 - element in the list because we're
06:47 - popping it as we go and the enumerate
06:50 - function works a little bit differently
06:51 - than the range function in python and to
06:53 - show you this let's do another example
06:56 - so
06:57 - let's change this now to say 4i and this
06:59 - is going to be in
07:01 - range and then this will be the len of
07:03 - lst so you would imagine we just get the
07:05 - exact same result here but when i run
07:07 - this notice now we get pop index out of
07:10 - range well the issue here is that we're
07:12 - reducing the length of the list while
07:14 - we're iterating through it and the range
07:17 - function has kind of a constant range
07:19 - that we're going to be iterating through
07:21 - so as soon as i define that i'm going to
07:23 - iterate through the range of 0 to 9 that
07:25 - doesn't change the whole time i'm going
07:27 - through this for loop so even if i
07:28 - modify the length of the list this
07:30 - hasn't changed because i put a constant
07:31 - value here whereas when we have the
07:33 - enumerate this will actually change
07:35 - based on the length of the list and
07:37 - again that's why you get that weird
07:38 - result so that's what i wanted to share
07:40 - with you don't do this it causes a lot
07:42 - of headaches only do this if you really
07:45 - understand what you're doing if you want
07:46 - to make a modification to a list while
07:49 - you're iterating through it usually what
07:51 - i like to do is store the modifications
07:53 - i want to make somewhere else iterate
07:55 - through the list entirely one time and
07:57 - then run a for loop and just make those
07:59 - specific iterations that i want to
08:02 - hopefully that makes a bit of sense but
08:03 - that is mistake number three so the next
08:05 - mistake i have to share with you is one
08:07 - that is super tricky to figure out if
08:09 - you've never seen this before and this
08:11 - is called name clashing now this happens
08:14 - when you name your python file which
08:16 - we're going to refer to as a module here
08:18 - the name of a built-in module in python
08:21 - or a third-party module that you've
08:23 - installed using something like pip so
08:25 - looking at this example here i have a
08:27 - little script where i import pi game pi
08:29 - game is a third party python module i
08:31 - installed this on my system and this
08:33 - lets me build 2d games you guys have
08:35 - probably seen this on my channel before
08:37 - anyways i have pi game now when i run
08:39 - this i get an error and it says this is
08:41 - most likely due to a circular import but
08:44 - this is only happening in this file if i
08:46 - throw this in another file this code
08:48 - will work completely fine so what's
08:49 - going on here well the issue is i've
08:51 - named my python module pygame so i've
08:54 - named it the thing that i'm trying to
08:55 - import so what happens is when i try to
08:57 - import pygame i'm trying to import the
09:00 - module that i'm currently working in
09:01 - myself and then i get this error and
09:03 - it's saying it doesn't have the
09:04 - attribute so to show you how you would
09:06 - fix this you would rename the file so
09:07 - let's call this pi game one now
09:10 - and when i run this code notice we no
09:12 - longer get that error and actually pops
09:13 - up a little pi game screen obviously
09:15 - goes away because i haven't coded
09:16 - anything else out so be careful about
09:18 - that do not name your python modules
09:21 - your python files a built-in module or a
09:24 - module that you're going to be importing
09:25 - or using in your program so moving on
09:28 - the next mistake i have for you is using
09:30 - a naked accept now here i have a try
09:33 - accept block and this exception or this
09:35 - except block is going to accept any
09:37 - exception so if anything happens in here
09:39 - that's an error that crashes the program
09:41 - we're going to go in here and print i
09:43 - crashed now that's great it's useful
09:45 - that we have this feature the issue is
09:48 - this accepts anything which means i
09:50 - don't know why i crashed when i'm
09:52 - reading this code and i see this message
09:54 - being printed out now this is really bad
09:57 - practice because it makes it really hard
09:58 - to debug your code and you just really
10:01 - shouldn't do this you should handle each
10:03 - individual exception as opposed to just
10:05 - any general exception kind of for
10:07 - obvious reasons but in this case i have
10:09 - two things inside of here that could
10:11 - fail right this could fail trying to
10:13 - open a file in read mode because if the
10:14 - file doesn't exist we'll get an
10:16 - exception and then dividing one by zero
10:18 - well zero division that's an error no
10:20 - matter what so two things that could
10:22 - fail and when i run the code here
10:24 - all i get is i crashed so i don't know
10:26 - if it was because i was unable to open
10:28 - the file or because i divided by zero
10:30 - and now if i delete the file that
10:31 - currently exists so tim.txt i have that
10:34 - there and i run this again i get i
10:35 - crashed so of course the solution here
10:37 - is to accept a specific exception and
10:40 - multiple of them if you want to so you
10:42 - kind of just need to know what the names
10:44 - of these are you can look them up you
10:45 - also can just crash your program and see
10:47 - what the exception is but for now let's
10:49 - accept the zero division error so the
10:51 - zero division error is simply called
10:53 - zero division error you should also get
10:54 - some syntax highlighting for it and now
10:57 - i can say i
10:59 - tried to divide
11:00 - by zero
11:02 - dot dot okay
11:03 - now let's just comment this line out
11:05 - let's run this and then we get i tried
11:07 - to divide by zero if i uncomment that
11:09 - and make my new file so let's save this
11:12 - as tim.txt
11:14 - yes put test inside of there save and
11:17 - run
11:18 - notice that i get i tried to divide by
11:20 - zero because i'm accepting the zero
11:22 - division error this obviously did not
11:24 - have an exception all right now though
11:26 - if we want to handle both of these
11:28 - exceptions we can write multiple except
11:30 - blocks
11:31 - so i can do accept and then i can accept
11:33 - i think this is the file not found error
11:36 - and i can print out i could
11:39 - not find the file dot dot
11:42 - so now if i delete the file again let's
11:45 - delete that let's run this then i get i
11:47 - could not find the file one last thing i
11:49 - will throw in here before i leave
11:51 - you also can have as e or as something
11:54 - now when i do that it will actually give
11:56 - me access to the error in this scope so
11:58 - i can do something like print e let's
12:01 - just comment this out now and then you
12:02 - can actually view what the exception
12:04 - string message is so keep that in mind
12:06 - that sometimes can be useful but please
12:09 - when you're writing your except blocks
12:10 - accept a specific exception it will help
12:12 - you later on so moving on to my next
12:15 - mistake and this one is using the wrong
12:18 - data structure now this is common and
12:20 - you could do this in any programming
12:21 - language but this is very important in
12:23 - python because there's a lot of
12:24 - operations that you can perform on a
12:26 - data structure that are very inefficient
12:28 - and that if you were to use a different
12:30 - data structure you'd have a much more
12:32 - efficient algorithm now if you're
12:33 - unfamiliar with time complexity don't
12:35 - worry that's kind of what i'm referring
12:37 - to here really what we're talking about
12:39 - is how fast can you perform an operation
12:41 - and which data structure or built-in
12:43 - type is going to be the best for what it
12:46 - is that you're doing so in python we
12:48 - have really three core data structures
12:49 - you should understand and that's going
12:51 - to be list set in dictionary we have
12:53 - string as well but i won't put that in
12:55 - here
12:56 - anyways the point is if we're looking at
12:58 - something like a list a list is used
13:00 - when you care about a ordered collection
13:03 - of elements so if the order and the
13:05 - frequency of elements that you have is
13:07 - important then you use a list there's
13:09 - not really another way to get around
13:10 - that if you want to store something
13:12 - ordered and you care about the frequency
13:14 - you use a list moving on we have a set
13:16 - now a set is used when you do not care
13:18 - about the frequency or the order of
13:20 - elements you only care about the
13:22 - presence of elements so you care if
13:24 - something is in the set or if it's not
13:26 - in the set now these two structures have
13:28 - drastically different time complexities
13:30 - in a list if i wanted to determine if
13:32 - something's inside of it that's what's
13:34 - known as a big o of n time operation and
13:37 - that essentially means that i have to
13:39 - look through at most every element in
13:41 - the list and there could be millions of
13:42 - elements to determine if something is
13:44 - there whereas with a set it's actually
13:47 - pretty much an instant or constant time
13:49 - operation for me to determine if an
13:51 - element is in there so if there's 10
13:52 - million elements or 100 elements it's
13:54 - going to take relatively the same amount
13:56 - of time for me to determine if an
13:58 - element's in the set so it's very fast
14:00 - for doing lookups right and then you
14:02 - have a dictionary this is kind of a
14:03 - hybrid what this allows you to do is
14:05 - store key value pairs but similarly to a
14:08 - set
14:09 - this allows you to have constant time
14:11 - lookup and access to an element so i can
14:14 - access an element add a key pretty much
14:16 - instantly and i can check if an element
14:18 - is in the dictionary those are the three
14:19 - different data structures and you want
14:21 - to use them appropriately because of
14:22 - what i'm about to show you
14:24 - so i have a list here for example and
14:26 - i'll get to these in one second by the
14:27 - way and with this list i can perform all
14:30 - kinds of operations on it some are going
14:32 - to be much more efficient than others
14:33 - though for example if i want to remove
14:35 - the very last element i can do dot pop
14:39 - and that just removes last element and
14:40 - this is a constant time operation
14:42 - happens very quickly time doesn't change
14:44 - depending on the size of the list
14:46 - however if i want to remove the first
14:48 - element this is a big o of end time
14:50 - operation and this could take a very
14:52 - long amount of time depending on how
14:54 - long the list is
14:56 - so in this situation if you know you
14:58 - need to have an order collection of
14:59 - elements and you want to be say popping
15:01 - something from the middle of the list or
15:03 - the beginning of the list or something
15:05 - along those lines you should use one of
15:07 - the two data structures i have up here
15:09 - and sorry that's from collections so
15:11 - python has a built-in module it's called
15:13 - collections and inside of it it has
15:15 - something called a deck and a queue i
15:17 - believe it also has a heap it has a ton
15:18 - of other data structures that you can
15:20 - use now a deck or a dq however you say
15:23 - this is a double ended queue and a queue
15:26 - is essentially a first in first out data
15:28 - structure it acts uh kind of like a cue
15:31 - that you'd have when you're on the phone
15:32 - like waiting on hold or something like
15:34 - that but a double ending queue
15:36 - essentially all you need to know about
15:37 - the double ended queue is it allows you
15:39 - to remove something from the beginning
15:40 - and the end of it in constant time so if
15:43 - you know you want to pop something from
15:44 - say the beginning of a list instead of
15:46 - using a list just use a q it has very
15:48 - similar properties to the list but it
15:50 - allows you to actually remove elements
15:52 - from the front and from the back of it
15:54 - in constant time i'm not going to do a
15:56 - whole tutorial on these i actually think
15:58 - i have some on my channel way way back
16:01 - just wanted to mention though that there
16:02 - is these built-in data structures they
16:04 - are much more efficient for specific
16:06 - operations and just be careful which one
16:08 - you're using based on what it is that
16:10 - you actually want to do so moving on
16:11 - here to my final mistake and this one is
16:14 - using the global keyword and global
16:16 - variables now if you watch this channel
16:18 - you should be familiar with why you
16:19 - should not do that i have an entire
16:21 - video that i posted talking about why
16:23 - not to do this but i will quickly
16:24 - summarize it here so this program very
16:27 - simple i have a global variable called
16:28 - global var i have two functions bar and
16:31 - foo in the first function i say global
16:33 - global var that means that i'm going to
16:35 - access or whenever i access this name
16:38 - i'm going to treat it as the global
16:39 - variable so when i print global var i'm
16:41 - going to print this when i say global
16:43 - var is equal to x i'm going to print
16:44 - this in fact let me just say print
16:46 - and let's go with global var down here
16:50 - anyways you get the point that's what's
16:51 - happening then i have foo and inside of
16:53 - here i print global var i define global
16:55 - var equal to x and then i print global
16:57 - var now first of all just say guess what
16:59 - you think the output of this program is
17:00 - going to be pause the video if you need
17:02 - to i'm about to run the code and then
17:04 - i'll talk about kind of the weird stuff
17:05 - that we're getting
17:06 - so when i run this you see that we get
17:08 - 10
17:09 - 20 and then we get an exception
17:11 - now let's talk about this so what's
17:13 - happening is i'm calling bar the bar
17:16 - function actually executes fine and what
17:18 - it does is it prints out 10 and 20. so
17:21 - i'm printing the value of the global
17:23 - variable
17:24 - and then changing global var to be equal
17:25 - to x which i pass in here as 20 and then
17:28 - i'm printing it again
17:30 - and of course i'm getting 20 because
17:31 - i've changed this in the global scope
17:33 - however when i then go and call foo
17:36 - what happens here is i get this
17:38 - exception it says unbounded local error
17:41 - or local variable global var reference
17:42 - before assignment now that is on this
17:45 - line right here so line 10
17:48 - and the reason i'm getting this is
17:50 - because i have actually defined a local
17:52 - variable global var
17:54 - inside of this function and it's kind of
17:57 - weird how python does this but
17:59 - essentially since this is defined down
18:01 - here when i try to print global var even
18:04 - though i have a global variable with
18:06 - that name it's not going to reference
18:08 - that it's going to reference the one in
18:09 - the local scope and since it's not yet
18:12 - defined i get an exception i know kind
18:15 - of weird one of the reasons again you
18:16 - don't really want to be using global
18:18 - variables is because if you try to write
18:20 - a local version of that inside of the
18:23 - function you're going to get these weird
18:24 - errors when you try to access that value
18:27 - above in the function now if i were to
18:29 - do this
18:30 - this would work fine i wouldn't get any
18:32 - issues with that however again since i'm
18:34 - doing this before i am defining this
18:37 - variable i get that error so hopefully
18:39 - it makes a bit of sense as to why that
18:41 - is occurring again really it's because i
18:43 - have a local version of my global
18:45 - variable whenever i have that in a
18:47 - function that's what i'm going to be
18:48 - accessing when i use that name so when i
18:50 - try to access it here it's not yet to
18:52 - find it well that causes an exception
18:54 - anyways that was my final mistake for
18:56 - you guys i wanted to keep this video
18:57 - nice and short and just quickly give you
18:59 - a few things to help you improve your
19:01 - python coding if you enjoyed make sure
19:02 - leave a like subscribe the channel and i
19:05 - hope to see you in another youtube video
19:08 - [Music]
19:15 - you

Cleaned transcript:

if you're watching this video and you write code in python then chances are you're familiar with what a unique language it is and you utilize some of the awesome features that python provides now this is great and python is an awesome language but because it is pretty unique and it's not like a lot of the traditional programming languages there's a lot of ways that you can make mistakes in python without really realizing it python is as i said a unique and kind of quirky language it allows you to do a ton of stuff and it's very flexible but with that flexibility it allows you to make a bunch of mistakes that are really hard to catch if you haven't watched a video like this so with that said let's get into this video and i'm gonna walk you through some mistakes that you're probably making in python and that you can easily fix by going through these tips so the first mistake that i'm sure many of you are making is that you haven't checked out my programming course yet called programming expert i'll leave it in the description this is a unique course that teaches python specifically some more advanced features of python and we recently added go to it as a second language so don't make that mistake check that out from the link in the description but in all seriousness here the first mistake that you're probably making is something called name shadowing now name shadowing occurs when you name your variable parameter function really anything you're defining a name for a builtin function some builtin name or something in the current scope that's already defined so for example here if we have this function called get database record we have a parameter here called id now this is a shadowed name and the reason this is shadowed is because you're naming this a builtin function so in python we actually have a builtin function here called id many people don't know about this function and so they'll do something like this where they write a function and then they name this parameter they give a parameter name of id now you'll notice here when i write id i'm getting the syntax highlighting as if it was a function because that's what python knows to do but this is not going to be treated as a function it's going to be treated as the parameter so that is the intended behavior when we're looking at a function like this but it can be really confusing if you're familiar with the builtin functions and you have kind of a long function or a long class or something like that when you're reading shadowed names so really you want to avoid name shadowing as much as you can and one of the only ways to do that in python is just to ensure that you're not naming your parameters functions etc a builtin name so something like id uh maybe something like max that's a really common one something like min you want to avoid those names because again they are built in functions and if you do name something that in the current scope so in this function you can no longer use this as the function so if i try to do something like id here let's just call this function so get database record let's pass in one notice it says the int object is not callable because i've overridden the id function by shadowing its name now this can occur when you have nested functions as well and all and in all kinds of other scenarios another really common thing here is when you shadow a name from the global scope so for example if i make my parameter here named database or i accept maybe like id and database like that again if you have a longer function it can be confusing when i'm reading this code if i'm referring to the database parameter if i spelled that correctly or the database variable in the global scope so obviously this isn't always avoidable the main thing here is just don't name your parameters or variables a builtin name like max min id not only because it's confusing but because you also now make it so you can no longer use those functions inside of wherever you've given that name so another mistake that you are likely unintentionally making in python is using a mutable object as the default value for an optional parameter now i know that's a mouthful but if you look here at this function it's called mutable parameter and we have an optional parameter we know it's optional because we have it assigned to a default value if you don't pass it it gets the default value and the default value is a mutable object which is a list now let me show you why this is bad by running the code so when i run the code we actually get an unexpected output if you're from another programming language where we get one two one two one two and then one two one two one two now the reason this occurs is because this is mutable that means we can actually mutate it we can change it in place so when i do something like lst.pen1 and lst.pen2 i'm actually mutating this list right here which is the same list that's going to be the default value for the next call to this function so you can see on every consecutive call we're actually adding elements to this same list this list does not get recreated every single time the function is called it gets created one time when we define the function that's the way that the the default value works here so if you want to avoid this and you do want to actually have a mutable value or immutable object as your default parameter you should do something like this instead and then manually check inside of the function if this is none so i'm going to say if lst is none then i will say lst is equal to and make that a list so now if i run this notice we don't get that error anymore because i'm recreating a new list object every function call as a post using the same one that's only created one time when my program is actually kind of initialized in the function is read by the interpreter hopefully that makes a bit of sense try not to make this issue or try not to make this mistake this also happens if you use dictionaries if you use sets and any other mutable object so the next mistake i have here is a more general one this could apply to any programming language and this is modifying an iterable object while you're iterating through it so in this case i have something that's iterable which is a list just means i can loop through it right using a for loop in this case and i have 4i comma value in a numerator list so it's going to give me the value as well as the index of each element and i'm saying if the index is divisible by 2 then i'm going to pop this index from my list now if you're looking at this here and you just kind of take all the indices and apply this to it we should be popping one we should be popping three because that's index two we should be popping five that's index four popping seven and then popping nine however when i run this notice that i get kind of a weird result i get two 235689 kind of strange why i'm getting that but the reason is because i'm modifying this iterable object while i'm looping through it so if i have a look here and i print out i value and actually let's not print out value let's print out i and lst and let's have a look at it at every iteration we see i zero and then one two three four five all the way up until six and what happens is we don't actually end up iterating through every unique element in the list because we're popping it as we go and the enumerate function works a little bit differently than the range function in python and to show you this let's do another example so let's change this now to say 4i and this is going to be in range and then this will be the len of lst so you would imagine we just get the exact same result here but when i run this notice now we get pop index out of range well the issue here is that we're reducing the length of the list while we're iterating through it and the range function has kind of a constant range that we're going to be iterating through so as soon as i define that i'm going to iterate through the range of 0 to 9 that doesn't change the whole time i'm going through this for loop so even if i modify the length of the list this hasn't changed because i put a constant value here whereas when we have the enumerate this will actually change based on the length of the list and again that's why you get that weird result so that's what i wanted to share with you don't do this it causes a lot of headaches only do this if you really understand what you're doing if you want to make a modification to a list while you're iterating through it usually what i like to do is store the modifications i want to make somewhere else iterate through the list entirely one time and then run a for loop and just make those specific iterations that i want to hopefully that makes a bit of sense but that is mistake number three so the next mistake i have to share with you is one that is super tricky to figure out if you've never seen this before and this is called name clashing now this happens when you name your python file which we're going to refer to as a module here the name of a builtin module in python or a thirdparty module that you've installed using something like pip so looking at this example here i have a little script where i import pi game pi game is a third party python module i installed this on my system and this lets me build 2d games you guys have probably seen this on my channel before anyways i have pi game now when i run this i get an error and it says this is most likely due to a circular import but this is only happening in this file if i throw this in another file this code will work completely fine so what's going on here well the issue is i've named my python module pygame so i've named it the thing that i'm trying to import so what happens is when i try to import pygame i'm trying to import the module that i'm currently working in myself and then i get this error and it's saying it doesn't have the attribute so to show you how you would fix this you would rename the file so let's call this pi game one now and when i run this code notice we no longer get that error and actually pops up a little pi game screen obviously goes away because i haven't coded anything else out so be careful about that do not name your python modules your python files a builtin module or a module that you're going to be importing or using in your program so moving on the next mistake i have for you is using a naked accept now here i have a try accept block and this exception or this except block is going to accept any exception so if anything happens in here that's an error that crashes the program we're going to go in here and print i crashed now that's great it's useful that we have this feature the issue is this accepts anything which means i don't know why i crashed when i'm reading this code and i see this message being printed out now this is really bad practice because it makes it really hard to debug your code and you just really shouldn't do this you should handle each individual exception as opposed to just any general exception kind of for obvious reasons but in this case i have two things inside of here that could fail right this could fail trying to open a file in read mode because if the file doesn't exist we'll get an exception and then dividing one by zero well zero division that's an error no matter what so two things that could fail and when i run the code here all i get is i crashed so i don't know if it was because i was unable to open the file or because i divided by zero and now if i delete the file that currently exists so tim.txt i have that there and i run this again i get i crashed so of course the solution here is to accept a specific exception and multiple of them if you want to so you kind of just need to know what the names of these are you can look them up you also can just crash your program and see what the exception is but for now let's accept the zero division error so the zero division error is simply called zero division error you should also get some syntax highlighting for it and now i can say i tried to divide by zero dot dot okay now let's just comment this line out let's run this and then we get i tried to divide by zero if i uncomment that and make my new file so let's save this as tim.txt yes put test inside of there save and run notice that i get i tried to divide by zero because i'm accepting the zero division error this obviously did not have an exception all right now though if we want to handle both of these exceptions we can write multiple except blocks so i can do accept and then i can accept i think this is the file not found error and i can print out i could not find the file dot dot so now if i delete the file again let's delete that let's run this then i get i could not find the file one last thing i will throw in here before i leave you also can have as e or as something now when i do that it will actually give me access to the error in this scope so i can do something like print e let's just comment this out now and then you can actually view what the exception string message is so keep that in mind that sometimes can be useful but please when you're writing your except blocks accept a specific exception it will help you later on so moving on to my next mistake and this one is using the wrong data structure now this is common and you could do this in any programming language but this is very important in python because there's a lot of operations that you can perform on a data structure that are very inefficient and that if you were to use a different data structure you'd have a much more efficient algorithm now if you're unfamiliar with time complexity don't worry that's kind of what i'm referring to here really what we're talking about is how fast can you perform an operation and which data structure or builtin type is going to be the best for what it is that you're doing so in python we have really three core data structures you should understand and that's going to be list set in dictionary we have string as well but i won't put that in here anyways the point is if we're looking at something like a list a list is used when you care about a ordered collection of elements so if the order and the frequency of elements that you have is important then you use a list there's not really another way to get around that if you want to store something ordered and you care about the frequency you use a list moving on we have a set now a set is used when you do not care about the frequency or the order of elements you only care about the presence of elements so you care if something is in the set or if it's not in the set now these two structures have drastically different time complexities in a list if i wanted to determine if something's inside of it that's what's known as a big o of n time operation and that essentially means that i have to look through at most every element in the list and there could be millions of elements to determine if something is there whereas with a set it's actually pretty much an instant or constant time operation for me to determine if an element is in there so if there's 10 million elements or 100 elements it's going to take relatively the same amount of time for me to determine if an element's in the set so it's very fast for doing lookups right and then you have a dictionary this is kind of a hybrid what this allows you to do is store key value pairs but similarly to a set this allows you to have constant time lookup and access to an element so i can access an element add a key pretty much instantly and i can check if an element is in the dictionary those are the three different data structures and you want to use them appropriately because of what i'm about to show you so i have a list here for example and i'll get to these in one second by the way and with this list i can perform all kinds of operations on it some are going to be much more efficient than others though for example if i want to remove the very last element i can do dot pop and that just removes last element and this is a constant time operation happens very quickly time doesn't change depending on the size of the list however if i want to remove the first element this is a big o of end time operation and this could take a very long amount of time depending on how long the list is so in this situation if you know you need to have an order collection of elements and you want to be say popping something from the middle of the list or the beginning of the list or something along those lines you should use one of the two data structures i have up here and sorry that's from collections so python has a builtin module it's called collections and inside of it it has something called a deck and a queue i believe it also has a heap it has a ton of other data structures that you can use now a deck or a dq however you say this is a double ended queue and a queue is essentially a first in first out data structure it acts uh kind of like a cue that you'd have when you're on the phone like waiting on hold or something like that but a double ending queue essentially all you need to know about the double ended queue is it allows you to remove something from the beginning and the end of it in constant time so if you know you want to pop something from say the beginning of a list instead of using a list just use a q it has very similar properties to the list but it allows you to actually remove elements from the front and from the back of it in constant time i'm not going to do a whole tutorial on these i actually think i have some on my channel way way back just wanted to mention though that there is these builtin data structures they are much more efficient for specific operations and just be careful which one you're using based on what it is that you actually want to do so moving on here to my final mistake and this one is using the global keyword and global variables now if you watch this channel you should be familiar with why you should not do that i have an entire video that i posted talking about why not to do this but i will quickly summarize it here so this program very simple i have a global variable called global var i have two functions bar and foo in the first function i say global global var that means that i'm going to access or whenever i access this name i'm going to treat it as the global variable so when i print global var i'm going to print this when i say global var is equal to x i'm going to print this in fact let me just say print and let's go with global var down here anyways you get the point that's what's happening then i have foo and inside of here i print global var i define global var equal to x and then i print global var now first of all just say guess what you think the output of this program is going to be pause the video if you need to i'm about to run the code and then i'll talk about kind of the weird stuff that we're getting so when i run this you see that we get 10 20 and then we get an exception now let's talk about this so what's happening is i'm calling bar the bar function actually executes fine and what it does is it prints out 10 and 20. so i'm printing the value of the global variable and then changing global var to be equal to x which i pass in here as 20 and then i'm printing it again and of course i'm getting 20 because i've changed this in the global scope however when i then go and call foo what happens here is i get this exception it says unbounded local error or local variable global var reference before assignment now that is on this line right here so line 10 and the reason i'm getting this is because i have actually defined a local variable global var inside of this function and it's kind of weird how python does this but essentially since this is defined down here when i try to print global var even though i have a global variable with that name it's not going to reference that it's going to reference the one in the local scope and since it's not yet defined i get an exception i know kind of weird one of the reasons again you don't really want to be using global variables is because if you try to write a local version of that inside of the function you're going to get these weird errors when you try to access that value above in the function now if i were to do this this would work fine i wouldn't get any issues with that however again since i'm doing this before i am defining this variable i get that error so hopefully it makes a bit of sense as to why that is occurring again really it's because i have a local version of my global variable whenever i have that in a function that's what i'm going to be accessing when i use that name so when i try to access it here it's not yet to find it well that causes an exception anyways that was my final mistake for you guys i wanted to keep this video nice and short and just quickly give you a few things to help you improve your python coding if you enjoyed make sure leave a like subscribe the channel and i hope to see you in another youtube video you
