With timestamps:

00:00 - so i've got an exciting video for you
00:01 - guys today where i'm going to be
00:03 - reacting to my google
00:04 - coding interview so back in december of
00:07 - 2019
00:08 - i filmed this video with my friend
00:10 - clement now clement is an
00:11 - ex-google engineer he worked there for
00:14 - about two years
00:15 - and at the time i reached out to him and
00:16 - i said hey i'm currently preparing for
00:19 - interviews at microsoft shopify and a
00:21 - bunch of other large tech companies
00:23 - would you mind conducting a mock google
00:25 - coding interview with me
00:26 - we can film it you can post it to your
00:28 - youtube channel and well will be some
00:29 - great practice for myself
00:30 - of course clement agreed to this and he
00:33 - went ahead and we filmed this coding
00:35 - interview
00:36 - so just to give you some context here at
00:38 - the time of filming this video
00:39 - i was in my second year of university i
00:42 - had never done a coding interview before
00:44 - other than
00:45 - one phone screen which wasn't really
00:47 - like a proper coding interview
00:48 - and while i was extremely nervous for
00:50 - this video i had been preparing for the
00:52 - past few weeks even just for this video
00:55 - by answering about 40 or 50 questions on
00:57 - the algo expert platform
00:59 - in case any of you are wondering what
01:00 - that is clement runs this awesome
01:02 - business it's called
01:03 - algo expert essentially it's an
01:05 - interview prep platform and it's what i
01:07 - actually ended up using
01:08 - pretty much solely for my preparation
01:10 - for my microsoft and shopify interviews
01:13 - which i ended up
01:14 - passing so if you guys do want to check
01:15 - that out i do have a discount code it's
01:17 - tech with tim you can get 10
01:18 - off i'll leave the link in the
01:20 - description but anyways i was using his
01:22 - platform and he had told me before the
01:24 - video
01:24 - hey you know if you want to prepare for
01:26 - this practice doing easy
01:28 - medium and hard questions so i did about
01:30 - 50 questions between those three
01:32 - categories most of them being in the
01:34 - medium and hard category
01:35 - and just so you're aware algo expert has
01:37 - a very hard and extremely hard category
01:40 - as well so i was kind of doing you know
01:41 - middle of the pack questions what you
01:43 - would commonly get
01:44 - so of course i get to the interview and
01:46 - what does clement do
01:48 - he gives me a very hard question to
01:50 - answer
01:51 - so immediately i'm a little nervous i'm
01:52 - like okay i've never done anything at
01:54 - this
01:54 - rated difficulty before but let's give
01:57 - it a shot and let's see how it goes
01:59 - so anyways that's all i kind of want to
02:00 - talk about and spoil before we get into
02:02 - this interview
02:03 - my reaction aspect of this is going to
02:05 - be me just kind of popping in every few
02:06 - minutes and talking about how
02:08 - i'm feeling in a specific situation if i
02:10 - did something wrong if i feel like i
02:11 - maybe
02:12 - did something well just kind of giving
02:14 - you guys maybe my thoughts on the
02:16 - interview but i will kind of let it play
02:17 - most of the time
02:18 - just so that i'm not interrupting
02:20 - constantly and you guys can actually
02:21 - enjoy it if you haven't seen the
02:22 - original video
02:23 - so anyways with that being said let's
02:25 - get started and get into the google
02:27 - coding interview
02:37 - all right so i'm on the computer i'm
02:38 - about to start the interview i'm gonna
02:40 - leave it for a few minutes just so you
02:41 - guys can hear the question you can see
02:43 - kind of what's going on
02:44 - and then as soon as there's some silence
02:46 - or i make a mistake or something like
02:47 - that happens i'll kind of jump in
02:49 - you know discuss that a little bit and
02:50 - then we'll move on all right so uh enjoy
02:53 - all right so tim when we tried to get
02:57 - this to happen this mock coding
02:58 - interview we naturally had to
03:00 - put something on the calendar right we
03:02 - have to find a time that worked for both
03:04 - of us
03:04 - and you know give ourselves 45 minutes
03:06 - or an hour to make sure that we had uh
03:09 - enough time to record this so i want you
03:12 - to write an algorithm that is going to
03:15 - basically take
03:16 - two people's calendars you can imagine
03:19 - google calendars
03:20 - and it's gonna basically return free
03:23 - slots of time
03:25 - during which these two people could have
03:27 - a meeting now here i'm gonna add a few
03:29 - other things to make sure that we're
03:31 - we're really on the same page here you
03:33 - can imagine that our calendars
03:35 - are going to basically be in the format
03:38 - of
03:39 - starting like they're going to be lists
03:41 - of tuples
03:42 - or lists of lists of length two
03:46 - so it's going to be something like you
03:47 - know one calendar
03:49 - would look like this where it might be
03:52 - noon
03:53 - to uh let's say 1pm
03:56 - then it might be 3pm to
04:00 - 4 30 p.m something like that it would
04:02 - actually be in military time so it'd be
04:03 - 15
04:04 - to okay 16 30. yeah exactly okay and so
04:08 - this would be one calendar maybe mine
04:10 - this means that i have
04:11 - meetings between noon and 1 between 3
04:14 - and 4 30. i'm going to give you a second
04:17 - calendar which is going to be your
04:18 - calendar
04:19 - and then i'm also going to give you some
04:21 - daily bounds because you can imagine
04:23 - that
04:24 - you might not want to have meetings
04:25 - before let's say 8 am or you might not
04:28 - want to have meetings after let's say
04:30 - 6 pm so i'll also give you something
04:32 - like daily bounds
04:35 - equals let's say 8 8 am and let's say
04:39 - 6 pm which would be 18 so this means
04:41 - that you not only have
04:43 - these meetings here but you also don't
04:46 - want to schedule meetings before 8
04:48 - or after 6 pm okay okay
04:51 - so given so yeah given
04:54 - two calendars and two daily bounds and
04:57 - i'll give you a sample input in a second
04:59 - and a meeting duration so in our example
05:02 - you know we need about an
05:03 - hour for this interview but the meeting
05:05 - duration could be any duration
05:07 - i want you to return a list of
05:10 - availabilities
05:11 - during which we could schedule our
05:12 - meeting so here's an example and then
05:14 - feel free to ask me anything you want
05:22 - okay
05:24 - all right okay so sorry i'm just looking
05:26 - at that now i thought you were actually
05:26 - going to continue that's why i was
05:28 - saying no
05:28 - no problem um okay yeah so can we assume
05:31 - that any like time you give me for a
05:34 - meeting is within the bounds you gave me
05:38 - what do you mean by that so for example
05:40 - say like say you said
05:42 - like you know person one says they have
05:44 - a meeting for like they only want to
05:45 - book meetings from 9am
05:47 - until in this case i guess we'll say you
05:48 - know 20 what is that 8pm
05:50 - then all the meetings you give me will
05:52 - be within those bounds right there'll be
05:53 - no meeting that starts at like
05:55 - 8 30 or 8 45 or something yes
05:58 - and they'll be all like we can assume
06:00 - all valid input right and these are okay
06:02 - so these are strings that's interesting
06:03 - as well okay
06:04 - yep they're all valid inputs they're all
06:06 - strings and they're all in military time
06:09 - so you know okay 3pm
06:12 - is 15. and so it looks like these are
06:16 - sorted right now i'm going to assume
06:18 - they're not necessarily sorted
06:20 - no you actually can't assume that they
06:22 - are sorted you can almost imagine
06:24 - that like when you open your google
06:26 - calendar you kind of see the meetings
06:29 - in sorted order you know in descending
06:30 - order from the beginning of the day to
06:32 - the end you can imagine that that's the
06:34 - order they're going to be given in
06:36 - okay and last thing here so for example
06:38 - you'd be saying i'm looking at input
06:40 - tail highlighted so you can see here
06:42 - um 10 to 11 30 so then 11 30 is the end
06:46 - 12 30 is the start so i can obviously
06:49 - say that
06:50 - i could have a meeting from 11 30 to 12
06:53 - 30 right like that would be
06:54 - i know this says 30 but that would be
06:56 - valid 11 30 to 12 30.
06:58 - 11 30 to 11 30 to 12 30 would indeed be
07:02 - a valid block
07:03 - during which you could schedule a
07:04 - 30-minute meeting but
07:07 - because of the top here you have this
07:08 - person or in this case
07:11 - who has a 12 pm meeting as you can see
07:13 - in the answer
07:14 - the block that we would be able to
07:16 - schedule would only be until 12.
07:18 - okay so okay so yeah okay so obviously
07:20 - that makes sense but um
07:22 - yeah i'm just trying to figure out you
07:24 - know if we if the meeting ends at 11 30
07:27 - the next meeting can start at 11 30 and
07:29 - then if
07:30 - the meeting ends at 12 30 the next
07:32 - meeting can start at 12 30 so i don't
07:33 - have to do like 12 31 or something like
07:35 - that
07:36 - yes yeah exactly okay awesome okay so i
07:39 - think
07:39 - um my initial kind of idea here is i'm
07:42 - going to look
07:43 - at one person's calendar to all right so
07:46 - i'm going to pause it for one second and
07:47 - quickly just talk to you about what i
07:49 - actually just did in case some of you
07:50 - don't realize why i did that
07:52 - the first thing that i always try to do
07:53 - in coding interviews and what i've kind
07:55 - of
07:55 - learned is that you always want to even
07:57 - if you completely understand the problem
07:59 - ask a ton of questions so i was
08:01 - literally sitting there trying to think
08:03 - of
08:03 - every question i could ask that would
08:06 - tell them that you know i'm thinking
08:08 - about the ambiguity in this problem
08:10 - and trying to get everything down as
08:11 - specific as possible so i don't start
08:13 - solving the problem before i completely
08:15 - understand it
08:16 - so that's why i ask you know maybe
08:17 - potentially some silly questions
08:19 - just to make sure i'm clarifying
08:21 - everything and make sure that i really
08:22 - understand
08:23 - okay first of all these are strings you
08:24 - know i don't have to start at say 11 31
08:26 - i can start at 11
08:27 - 30. oh am i going to get valid input is
08:30 - there going to be stuff that i have to
08:31 - look for in terms of edge cases
08:32 - that's kind of where i'm starting from
08:34 - and that's why i went through that so
08:35 - anyways let's continue and let's see
08:36 - what i do next
08:38 - is i'm going to look at one person's
08:40 - calendar to start
08:41 - and i actually only really care about
08:44 - the end
08:44 - times because the start time
08:48 - i obviously i can't start and hm
08:51 - actually i do care about the start times
08:52 - but the end times are what i want to
08:54 - start by looking at so essentially i'll
08:55 - look at the end time 11
08:56 - 30 and then i'll look at the next start
08:59 - time
09:00 - and say okay if there is enough time
09:02 - within that block for whatever this
09:05 - meeting duration is so in this case when
09:07 - i'm looking at 11 30 and i'm looking at
09:08 - 12 30 i know i have an
09:10 - hour so that's an hour of free time that
09:13 - i could technically book a meeting
09:15 - so what i would want to do then is check
09:18 - in the other person's calendar if they
09:20 - have time available between
09:22 - 11 30 and 12 30. so in this instance
09:26 - what i would do is say okay so between
09:29 - 11 30 i'll add
09:30 - 30 to that if i can book something
09:34 - in that time so between 11 30 and 12
09:36 - that's about because that's kind of like
09:38 - the naive approach i think to do that
09:39 - now because this is sorted
09:41 - like i feel like i could search in this
09:44 - a more effective way to find whether
09:47 - they have
09:48 - a valid meeting time uh right now i'm
09:50 - just sorry i'm just kind of talking out
09:52 - loud trying to explore
09:53 - yeah for myself and get an idea of how i
09:55 - want to do this okay
09:57 - so yeah so i think that initial approach
10:01 - is going to be to look in one person's
10:02 - meeting this will be kind of my step one
10:04 - of the algorithm
10:04 - and figure out essentially all the spare
10:07 - times that they have
10:08 - because if i can figure out the spare
10:10 - blocks of times they have that's step
10:11 - one that's going to help me towards the
10:13 - final solution which is then just
10:14 - comparing those spare blocks of time
10:16 - to this next person's input so how do i
10:18 - figure out the spare blocks of time
10:20 - well i look at the ending time of one
10:23 - block and i look at the starting time
10:24 - of the next block and then essentially
10:27 - if
10:28 - i have time in between that then i can
10:31 - make another list and say
10:33 - okay so i have an availability and this
10:35 - person's scheduled between 11
10:36 - 30 and 12 30. then i could go
10:39 - continually so here
10:40 - 4 30 okay so there's no time here so now
10:43 - i'm going to look at the end block here
10:44 - which is 15 the start block here which
10:46 - is 16
10:47 - that means i now have an hour available
10:50 - there so between 15 and 16 i could book
10:52 - a meeting
10:52 - then i'll look at 17 and when i actually
10:54 - get to the end block here
10:56 - what i can say is well that will go to
10:58 - whatever our bound is
11:00 - so in this case 1830 i technically would
11:02 - have availability from 17 o'clock
11:04 - until 1830 because that's the bound that
11:08 - you gave me there
11:08 - and then same thing here at the front i
11:10 - could treat this as the end time of say
11:13 - you know another block and say okay well
11:15 - from 10
11:16 - to 10 well obviously i can't do anything
11:19 - there because that's the bound okay
11:20 - so once i can do that aspect then what i
11:24 - need to do
11:24 - is compare it to this block here so if i
11:27 - have and i'm just gonna
11:29 - sorry i'm just gonna write some lists
11:30 - down here so let's say i can generate
11:33 - my lists that look like 11 30
11:37 - so i have an availability i know in
11:38 - person two schedule and i guess
11:40 - it doesn't really matter which person i
11:42 - do this for but let's just do person two
11:43 - for now
11:44 - at 11 30 to 12 30 i don't have anything
11:46 - at the upper bound because 10 is that
11:48 - upper bound i have an availability from
11:50 - 15 to 16.
11:51 - so let's do this 15.
11:54 - that should be a string but that's okay
11:56 - if you want you can remove the quotes
11:57 - for now
11:57 - if it's too if it's annoying yeah it's
11:59 - okay it's just it's just a habit of mine
12:01 - to
12:01 - to do it like that and then i would have
12:03 - an availability because now the ocd is
12:05 - going to kick in if i don't do it every
12:06 - time
12:07 - 17 to 18 30. okay okay
12:10 - so so these are my list of available
12:13 - times
12:13 - from this schedule and i think i i mean
12:16 - correct me if i did that wrong but i'm
12:17 - pretty sure that is
12:18 - right for the available times that
12:19 - person two has for person
12:21 - what i should yeah for person two so now
12:24 - what i want to do
12:25 - is compare this to person one so how do
12:28 - i do that
12:29 - so this person has their bounds of nine
12:32 - to ten oh
12:33 - so what i think i should probably do is
12:36 - actually the same thing
12:37 - for person two and i'll already have a
12:39 - function that can do this for me
12:41 - so that will actually mean i'm not going
12:42 - to be repeating really any logic and
12:44 - actually now i'm going to go no quotes
12:45 - so in this case 9 to 10 30 i have a time
12:48 - from
12:50 - 10 30. to 12
12:53 - available and then i have a time
12:56 - from 13 to what is it 16
13:01 - and then i have a time from 18 to 20.
13:06 - so sorry i forget what oh so the output
13:09 - is
13:10 - all the times that they could possibly
13:12 - have a meeting okay so
13:13 - although all the available blocks of
13:16 - time so it's not necessarily
13:17 - all the 30 minute increments it's
13:19 - basically okay all the
13:21 - free blocks of time during which you can
13:23 - schedule a meeting
13:25 - okay so what i think now i need to do
13:29 - is say okay so my start time i have
13:32 - between 11 30 and 12 30.
13:34 - so now what i'm gonna do is look at the
13:36 - end oh
13:38 - because now all right so i'm gonna jump
13:41 - in here for one second
13:42 - so if you guys can't already tell what
13:44 - i'm focusing on really heavily right now
13:46 - is just trying to come up with some kind
13:48 - of solution and test it with some kind
13:50 - of input
13:50 - to make sure i'm on the right track
13:52 - before i actually go ahead and start
13:53 - coding
13:54 - these problems for me at least are
13:56 - usually much easier to program than they
13:58 - are to understand
13:59 - so i usually try to take as much time as
14:01 - i can at the beginning even if that is
14:03 - in this case say 10 minutes because i
14:04 - had 45 minutes from the start
14:06 - to really digest the problem understand
14:08 - it and make sure i come up with some
14:10 - kind of thorough approach that i know is
14:11 - going to work
14:12 - before i start actually going ahead and
14:14 - coding the last thing i want is to write
14:16 - all of the code and then get to the end
14:18 - of it try some sample input on it
14:20 - and have that code break so right now
14:22 - you can tell i'm kind of struggling a
14:23 - little bit
14:24 - i've come up with a solution that's
14:26 - somewhat kind of working i feel like i'm
14:28 - on a decent track to getting there but i
14:30 - still don't know if this is going to be
14:32 - the exact right answer
14:33 - so of course i wish i could think faster
14:35 - and just immediately come up with the
14:36 - solution
14:37 - but we're 10 minutes in i'm kind of on
14:39 - one route right now
14:40 - you'll see in a second that clem kind of
14:42 - redirects me almost
14:44 - but let's have a look at what i do now
14:45 - just wanted to clarify kind of why i'm
14:46 - taking so much time at the beginning and
14:48 - not even writing any code
14:50 - i got to figure out what time so this
14:52 - there's an availability here from 10 30
14:54 - to 12 30. so maybe what i can do
14:55 - is say if 11 30 is in between
14:59 - these two blocks and i have half an hour
15:02 - between
15:03 - this end time ah see now i'm kind of
15:05 - confusing myself a bit because now i
15:07 - have to get i got to get all the
15:08 - available blocks
15:10 - not just the 30 minute intervals
15:13 - okay sorry just give me one second yeah
15:16 - no problem
15:17 - no problem yeah okay
15:20 - 11 13.
15:24 - hmm
15:28 - so 11 30 is the earliest possible time
15:31 - i could have a meeting and then if the
15:34 - earliest possible time
15:35 - is 10 30 and it goes to 12
15:38 - then i guess i could have a meeting from
15:40 - 10 30 to 12.
15:41 - so what i'm thinking is find the
15:44 - beginning time
15:45 - here uh oh okay because
15:48 - what i'm think what's where i'm getting
15:50 - hung up here is like what if i had
15:51 - something like
15:52 - 11 because i guess i could have this
15:54 - like 11 58.
15:55 - yeah technically this this wouldn't be
15:57 - enough time to have a meeting right
15:59 - so what i might what i would do then i
16:01 - guess is just
16:02 - strictly remove that because i can't
16:05 - have a meeting within that block of time
16:07 - so if i can do that first so essentially
16:10 - remove
16:10 - any blocks of time that are less than
16:13 - half an hour
16:14 - then that's going to help me a little
16:15 - bit more towards the final solution so
16:17 - let's say that's another step so
16:18 - we're going to start by building all of
16:20 - the blocks of available time
16:22 - that either person could have yeah and
16:24 - then what i'm going to do is remove
16:26 - any blocks that are invalid so if it's
16:28 - less than half an hour in between
16:30 - then get rid of them because there's no
16:31 - point we can't even we can't book a
16:33 - meeting in that or
16:33 - half an hour for this example but
16:35 - whatever that time is okay uh and this
16:36 - will be
16:37 - sorry this will be in minutes right so
16:38 - this will be this would be
16:40 - 30. so 30 would represent 30 minutes if
16:43 - it were one hour it would be 60.
16:46 - okay it could be 90 minutes and then
16:50 - okay all right so what's once i remove
16:52 - that
16:53 - then what i need to do is say okay so i
16:55 - have blocked from 10 30 to 12
16:57 - so now i'll look at this first block
16:58 - because these will be still in sorted
16:59 - order based on just the property of what
17:01 - i'm adding them in
17:03 - and i'll say if 15 is in between these
17:05 - two blocks let's check if we can do a
17:07 - meeting
17:07 - okay it's not in between these two
17:08 - blocks so let's move to the next block
17:10 - okay so 15
17:12 - is in between this next block i know
17:14 - that i have enough time in here to do a
17:16 - 30 minute meeting because i know that
17:17 - this is a valid range so now i check
17:20 - since 15 is in between these two blocks
17:22 - of time
17:23 - if there's half an hour to the end time
17:26 - or whatever that time is so here i'll
17:28 - find 15
17:29 - then i'll compare it to the end time and
17:30 - i'll figure out what the difference
17:32 - between those two
17:32 - are if that is greater than half an hour
17:36 - then what i'll simply do is go 15
17:40 - to the end time i think yeah and that
17:43 - looks like that works based on this
17:46 - 15 to the end time if the end time is
17:48 - greater than half an hour because at any
17:50 - point in there i could
17:51 - book a meeting but as an example a quick
17:54 - question
17:55 - sorry to cut you off imagine that here
17:57 - you had had
17:58 - a bunch of other uh availabilities
18:00 - basically here
18:02 - from like person two let's suppose if
18:04 - this was person two
18:05 - you had had something like you know 12
18:08 - 30
18:09 - to i don't know to 14
18:12 - or or rather let's say you you start
18:14 - over from the beginning let's say you
18:15 - had had
18:16 - you know seven to eight then you had had
18:20 - um you know nine to ten
18:24 - then you had had eleven to noon
18:28 - and so on and so forth how would you how
18:30 - would you know that this
18:32 - 15 to 16 here sort of yeah
18:35 - corresponds or can be kind of merged
18:38 - into this
18:38 - 13 to 16.
18:42 - okay so well the reason i'm saying that
18:44 - is because the 15 is
18:45 - in between these two numbers so in this
18:47 - instance when i have 11
18:49 - 12 well obviously 15 isn't in between
18:52 - those two numbers
18:53 - so i know i can't book anything in here
18:55 - because well 15 is
18:57 - is greater than the end time right um
18:59 - okay
19:00 - so if it's in between these two values
19:02 - which it
19:04 - and i think that's like a valid
19:05 - comparison um just to check you know
19:08 - if it's less than whatever um then if
19:10 - it's in between the two values which it
19:12 - is here
19:12 - i can look at the end time specifically
19:14 - and figure out the difference between
19:16 - my start time and this end time then
19:19 - what i can actually do i think is
19:21 - take the minimum of whatever the end
19:22 - time is here
19:24 - and whatever the end time end time is
19:26 - here and that is a valid block to book
19:28 - a meeting in and then i've eliminated
19:30 - now from this list
19:32 - this block here i've figured out that i
19:34 - can have a meeting
19:35 - based on this time from i guess what is
19:38 - it 15 to 16 so now i can move to my next
19:40 - block which is 17
19:42 - to 8 30. okay so now that i'm not now
19:45 - does that does that like answer your
19:46 - question what i was saying
19:49 - okay okay great so now that i'm at 17
19:52 - and 8 30 what i'll do is i'll figure out
19:53 - if 17
19:55 - is in between any of these values so now
19:58 - i've actually i know
19:59 - that the last one was in between here so
20:01 - i can actually just start looking from
20:03 - here right because i know this is sorted
20:04 - so i don't even need to bother
20:06 - looking at the rest of the list but
20:07 - that's kind of an optimization technique
20:08 - that i will focus more on later
20:11 - so i'll look i'll start looking here
20:12 - i'll say 17 is not in between these two
20:14 - numbers
20:15 - but 17 is in between 18 and
20:18 - 17 is not in between 18 and 20. ah okay
20:21 - so that's where that falls apart if i'm
20:23 - just looking at
20:24 - the start time okay
20:27 - so 17 18. so if i just look at the start
20:31 - time that doesn't work
20:32 - i need to look at i think maybe the
20:35 - start time
20:36 - and the end time and see if they're in
20:38 - between those two values because
20:39 - if the end time is in between the two
20:41 - values which in this case is
20:44 - 1830
20:47 - so tim let's take a quick step back
20:49 - because i think that you're
20:50 - you're on the right track here you have
20:51 - the you have the idea but now you're at
20:53 - this step
20:54 - of of having to kind of figure out where
20:57 - you can kind of
20:57 - merge these availabilities yeah right so
21:00 - exactly yeah
21:01 - if we take a step back the first thing
21:03 - that you did you even said that you
21:04 - would have this
21:05 - reusable function is you transformed for
21:08 - each person
21:09 - you transformed their calendar into a
21:12 - new calendar of blocks of time when the
21:15 - person is available
21:17 - right yes like these times here
21:19 - represent
21:20 - chunks of time where the person is
21:21 - available and
21:24 - you filtered these and you said remove
21:26 - any
21:27 - chunk of time that's less than our
21:29 - meeting duration correct
21:31 - exactly yes so basically what you did is
21:34 - you you almost
21:35 - answered the question but just for one
21:38 - calendar in the first step
21:39 - exactly right okay so now let's see if
21:43 - we could if we could
21:44 - simplify the approach that you're going
21:46 - with which i think could work
21:48 - but might be you might have a little bit
21:49 - more complication when you're trying to
21:51 - merge the things
21:52 - imagine you could have imagine you could
21:54 - have instead of at the beginning when
21:56 - you took a calendar like you took this
21:58 - calendar of unavailabilities right
22:00 - or meetings and you went you calculated
22:03 - the in betweens
22:04 - right you took the things in between and
22:06 - these were your availabilities and then
22:07 - you filtered them
22:09 - imagine you had in this calendar
22:12 - you had a mixture of both calendars so
22:15 - you basically you
22:16 - you you do the opposite of what you did
22:18 - instead of first finding
22:20 - the availabilities imagine you had first
22:23 - merged
22:24 - both of these meetings or both of these
22:26 - calendars rather
22:27 - you merged both of them when when you
22:30 - have the meetings
22:32 - you you kind of you mix them such that
22:34 - you have all of the
22:36 - blocks of time when one or both of the
22:39 - individuals
22:40 - aren't available right one or both are
22:42 - unavailable
22:43 - and then you do your step of calculating
22:45 - the in-betweens
22:46 - which at that point essentially gives
22:48 - you the answer does that make sense
22:50 - ah okay i know exactly what you're
22:51 - saying so all right so i'm going to take
22:53 - a pause
22:54 - there quickly so you can see clement
22:55 - gave me a pretty big hint there
22:57 - now a lot of people will say that's
22:59 - cheating or you know you shouldn't do
23:00 - that
23:01 - i can say from experience doing my
23:03 - coding interviews
23:04 - a lot of the time what i'm able to get
23:06 - the person to do and this isn't just me
23:07 - trying to be you know sneaky and
23:09 - strategic
23:09 - is i'm able to get them to give me a
23:11 - hint because i talk about
23:13 - everything that i'm thinking about so
23:15 - notice here that even though i'm kind of
23:16 - on the right track and the approach that
23:18 - i'm doing would potentially work it'd
23:20 - just be a really difficult
23:21 - implementation
23:22 - to do clemence heard my entire thought
23:24 - process
23:25 - he knows that i'm kind of on the right
23:26 - track and he figures that it's going to
23:28 - be easier if he simply tells me to merge
23:30 - the two calendars
23:31 - and then continue doing what i'm going
23:32 - to do so just kind of a piece of advice
23:34 - that when you're in these coding
23:35 - interviews
23:36 - talk about literally everything because
23:38 - even if you're completely wrong or
23:40 - you're like somewhat on the right track
23:42 - you know your interviewer may be nice
23:44 - they may be kind of rooting for you
23:45 - because they think you're going to be
23:46 - able to get it and they'll give you a
23:47 - hint
23:48 - like commented and like i said almost
23:50 - all my interviews that i did
23:52 - not necessarily that i needed a hint i
23:54 - probably could solve it without the hint
23:56 - but they gave me a hint and it made it a
23:58 - lot easier to continue going and they
24:00 - wanted to give the hint if that make any
24:02 - made any sense just because of the way
24:03 - that i was explaining
24:04 - anyways we'll jump back in here you'll
24:06 - see that i'm about to kind of go down
24:08 - the correct path
24:09 - but think to yourself right now there's
24:11 - one thing that i haven't done that i
24:13 - don't do this entire interview with the
24:16 - input that would make it a lot easier
24:17 - see if you can figure out what that is
24:20 - what you're saying so you're saying i'm
24:22 - i'm doing this
24:23 - two times and then trying to merge why
24:25 - don't i just make one big list
24:27 - do it once and then i don't need to even
24:29 - bother with this merge step which is
24:30 - obviously going to be very complicated
24:31 - based on what i've been talking about
24:33 - perhaps is that okay yeah perhaps so i'm
24:36 - thinking
24:37 - what i so if i can actually i want to
24:39 - write like a merged
24:40 - version of this so i need to merge them
24:43 - in sorted order
24:44 - so to do that i can do it's almost like
24:47 - you would do it in merge sort right
24:48 - where i'm going to just
24:49 - insert this one then i'll check in here
24:52 - if i can insert it if i can i'll insert
24:54 - it then we'll go to the next one
24:56 - then we'll insert so i know how to do
24:57 - that so i can insert this in sorted
24:58 - order so now if i have one that's
25:00 - in sorted order then i can calculate the
25:03 - in between times
25:04 - then i can filter and then whatever
25:06 - blocks of time i have
25:08 - in my remain like what in my filtered
25:11 - list are the times that they should be
25:12 - available i
25:14 - think that makes sense i really i just
25:16 - want to write these
25:17 - um yeah like as one if you want to write
25:20 - exactly write that merged
25:22 - thing that you just mentioned yeah
25:24 - because i mean i think that makes sense
25:25 - but i got to visualize this first to be
25:27 - able to figure it out right
25:28 - because okay so now it gets a little bit
25:30 - complicated just because
25:32 - this goes from 9 to 10 30 and then this
25:34 - is 10 to 11 30 right
25:36 - so that's to merge them is going to be a
25:39 - bit of a different process than what i
25:40 - had come up with before
25:42 - but we will sort them by start times uh
25:45 - okay so let's go 16 18. and by the way
25:48 - sorry how much time do i have
25:49 - you still have 25 minutes and don't
25:51 - worry about it for now just you're doing
25:53 - good okay yeah okay great um
25:56 - yeah i just really want to understand
25:57 - the problem before i start doing a
25:59 - massive code right
26:01 - um okay so what i think
26:04 - now so now that i have these together
26:06 - now i gotta come up with a better way
26:08 - to figure out which blocks of time are
26:10 - available because there will be some
26:11 - overlaps and some of the times whereas
26:13 - in the other ones there would have been
26:14 - overlaps that would have been easier
26:16 - so here we start at 9 we go to 10 30. so
26:19 - what i can do is actually
26:20 - look at so i'll say 10 30 is my end time
26:23 - my next start time is
26:25 - 10. so what i'll actually do is make
26:27 - this
26:28 - the next start time if
26:32 - this start time is less than the end
26:34 - time
26:35 - then that way i know i'll have the
26:38 - availability
26:39 - from 10 30 uh oh actually 10
26:42 - so yeah so if i could change so say i
26:44 - could change this
26:45 - to be 10 30 then that makes a little bit
26:49 - easier because then now i know from
26:50 - 11 30 to 12 is fine and then okay so
26:53 - this is greater than this so if i could
26:55 - change this to be
26:57 - 13 this should be giving me valid i'm
27:00 - just going to change that to make sure
27:01 - it makes sense
27:01 - and here if here tim i would almost
27:03 - argue do you even need to do that or can
27:05 - you even
27:06 - just some no i don't i delete this i
27:08 - don't need to
27:10 - and and just merge the two times
27:12 - together that's
27:14 - exactly that would probably make more
27:15 - sense so essentially if if i could go
27:17 - back to what i had so if i have
27:18 - this if this time is greater than this
27:22 - time
27:22 - then merge these two entries so i think
27:24 - that'll be my first
27:26 - step in the process so then we now have
27:29 - this new list so now this is my last end
27:31 - time
27:31 - this is my newest start time so now
27:35 - i have from here to here since this
27:38 - entry
27:38 - is less than this i'll check if this
27:42 - block of time is the amount of allotted
27:43 - time we need
27:45 - and if it is i can add that into this
27:48 - output
27:49 - next we go from 12 to 13 and then since
27:52 - these times are the same
27:54 - i can merge them so i can go like that
27:58 - and now what i can do is now look since
28:00 - these times are the same
28:01 - i can merge them again okay so let's
28:03 - merge them
28:05 - like that and now okay so this is less
28:08 - than this
28:09 - so is it more than half an hour it is
28:11 - okay so let's add
28:12 - 15 and 16 to our output okay
28:15 - now let's look at 18 16. oh this is
28:18 - greater than this one so what can i do
28:20 - i can merge them okay and i get
28:24 - 18 17 and now what i need to do actually
28:27 - sorry like this
28:28 - uh 18 so that okay so this is where it's
28:31 - a little bit confusing for me it's
28:33 - because
28:33 - these are the same start times and then
28:36 - this
28:37 - end time is actually greater than this
28:39 - end time right so since this is greater
28:41 - than this i need to check if this
28:44 - is greater than the end time two because
28:47 - if it's greater than which one anytime
28:49 - then really
28:50 - then i would take the max obviously
28:53 - would you take the max or the min
28:56 - well if i'm available from if i'm not a
28:59 - oh this is sorry this is a list of my
29:03 - no this is a list of my non-available
29:05 - times
29:06 - yeah this is when this is when one of
29:08 - the two people is booked
29:10 - yeah so this is when they're booked so
29:12 - if i'm booked from 16 to 18
29:14 - well then this doesn't this isn't really
29:17 - even relevant because i'm booked from 16
29:18 - to 18 which means i'd be booked from 16
29:20 - to 17 anyway so i would take the max
29:22 - yup i would definitely take the max okay
29:24 - i'm sorry you just confused me a little
29:25 - bit with that
29:26 - that's okay i i totally didn't just get
29:28 - confused myself
29:30 - okay all right you're good
29:34 - okay great yeah so just taking a sip of
29:36 - water now
29:37 - what i will do is look at the bounds
29:39 - that i have
29:41 - so what i can do with the bounds is
29:43 - simply take the min
29:44 - of whatever these bounds are so in this
29:46 - case i'll take oh
29:48 - sorry i need to take the max
29:52 - on the yeah will it be the max on the
29:55 - left side the min on the right side i
29:58 - think that makes sense
30:00 - um yeah so max on left side min on right
30:02 - side
30:03 - so in this case this would be the bounds
30:04 - i want to look at 10 to 8 30
30:06 - and then i could just see um
30:09 - then i need to look at the first entry
30:12 - in my list
30:13 - and i will i actually need to merge that
30:15 - again so these bounds now
30:17 - are getting me a little bit uh tricky as
30:20 - well so if i have like
30:22 - do and i do like 10 like that i would
30:25 - just i think
30:25 - what i can actually do is just compare
30:27 - 10 to whatever this first
30:29 - start time is yep and then
30:32 - i can just change this almost to be just
30:35 - 10
30:36 - but if for example this said 930
30:40 - then i would just need to scrap this
30:41 - whole thing so actually what i think i
30:43 - could do is probably just compare all
30:44 - these blocks of times
30:46 - to whatever the bounds that i have and
30:48 - if they don't fall within the bounds
30:50 - i'll modify them or remove them
30:53 - and for now for now let's let's actually
30:56 - just keep the bounds even aside because
30:58 - i think
30:58 - i understand where you're getting at but
31:00 - let's even yeah forget about the bounce
31:02 - for a second let's not complicate
31:03 - ourselves
31:05 - yeah okay so i think maybe now is
31:07 - probably actually a decent time
31:09 - to start writing something all right so
31:11 - i'll take a break here quickly so you
31:13 - can see
31:13 - that now we're probably what like 25 26
31:16 - minutes in
31:16 - something like that and i'm just about
31:18 - to start coding so usually i would be a
31:21 - little bit nervous in this situation
31:23 - because
31:23 - i don't want to take half the time to
31:26 - digest the problem
31:27 - if that's necessary obviously i'm going
31:29 - to do that like i did here
31:30 - as you guys can tell you know i was
31:32 - confusing myself you know like there's a
31:34 - lot of
31:34 - different input and time stuff going on
31:36 - on the screen here but i think at this
31:38 - point i kind of have a clear idea of
31:40 - what i want to do
31:41 - obviously clement has helped a little
31:43 - bit but again the reason he's able to
31:45 - help me is because
31:46 - i'm constantly talking out loud and even
31:49 - if i'm thinking something that's
31:50 - incorrect i'm still
31:51 - saying it just to kind of see how he
31:53 - reacts to it
31:54 - and see if because he knows the answer
31:56 - to the problem if i am on the right
31:58 - track so there is a little bit of kind
31:59 - of confirming with your interviewer that
32:01 - they understand where your head's at
32:02 - and they're not going to let you kind of
32:04 - jump into the code and do something
32:06 - horribly wrong
32:07 - so at least you have the opportunity to
32:08 - kind of get checked a little bit and say
32:10 - okay am i on the right path
32:11 - yes i am okay let's keep going so
32:13 - anyways i'll jump back in here but now
32:14 - i'm about to start coding
32:16 - and again think about that thing that i
32:18 - should have done to the input
32:19 - that i haven't done and that i'm not
32:20 - going to end up doing in this interview
32:22 - that would make things a lot easier for
32:24 - me
32:24 - when it comes to comparing these
32:26 - different values which is like the main
32:27 - step
32:28 - of all of the processes i've talked
32:29 - about to start writing something
32:31 - so i'll run through this one more time
32:33 - just to make sure that i'm refreshed
32:34 - what i'm going to do
32:35 - is insert insorted order into a large
32:38 - list
32:38 - both the availability or the i guess the
32:40 - busy times of person
32:42 - one and of person two yep i'm going to
32:44 - ignore these bounds for now because
32:45 - those we'll talk about later i guess
32:47 - um and then what i'm going to do is do
32:49 - those comparisons that i talked about
32:52 - so i'm going to compare you know not so
32:54 - i'm going to compare the end time
32:56 - to this end time and i'm going to say
32:58 - okay well if this is
32:59 - greater than this i'll merge them
33:02 - together
33:03 - but if this end time in the other list
33:06 - is
33:06 - less than the end time here i can
33:09 - actually just remove
33:10 - this entry altogether um
33:13 - because that will just give me because
33:14 - i'll be busy during that time yep
33:16 - then i'll i'll do the same thing for the
33:19 - next one so i'll look
33:20 - at 12 to 13. oh this will be a big list
33:23 - so we'll do that all together
33:25 - and then when i get to the end of that
33:26 - what i can do is literally just compare
33:28 - what i talked about for the end time to
33:30 - the next
33:30 - start time if there's enough time there
33:32 - i'll add that to the output
33:34 - yep same thing here right if there's
33:36 - enough time here i'll add that to output
33:37 - okay
33:38 - so let's start doing this um okay
33:41 - and again the capitals here are going to
33:42 - be weird don't worry google docs so
33:44 - define don't worry about the capitals
33:46 - yeah don't worry about the
33:46 - the auto caps and all that define is
33:49 - there a name for this
33:50 - calendar i'll just call it a veil for
33:53 - now i don't know
33:54 - that's fine okay calendar avail um
33:57 - i'll just i'll ignore the uh the bounds
33:59 - for now in my input we can change them
34:01 - later so i'll say
34:02 - person one schedule
34:07 - uh person2 schedule
34:10 - uh and then what else do i need i need
34:13 - time
34:14 - so we'll do that and i time is i'm going
34:16 - to write this in python so time is
34:18 - actually fine as a keyword
34:19 - okay so now what i need to do is i need
34:21 - to insert these into sort orders so that
34:22 - means i need to make a list so i'm going
34:24 - to say
34:24 - and by the way feel free to feel free to
34:27 - simplify the variables if it's too
34:29 - annoying to type out up to you
34:34 - okay there we go we'll do that so and
34:36 - yeah just case sense okay so book time
34:38 - so quick side note whenever i make
34:40 - variables just kind of a tip i've heard
34:42 - is to make them really readable not only
34:44 - does that make it easier for myself when
34:46 - i go back i can see
34:48 - what i'm doing with all these variables
34:49 - but clement can also understand what i'm
34:51 - trying to do with those
34:52 - so typically it's good to have variable
34:54 - names that are pretty descriptive but
34:56 - obviously in this situation i'm kind of
34:58 - running low in time
34:59 - i probably only have about 20 minutes
35:01 - left before this interview is actually
35:02 - going to be done
35:03 - so obviously in the name of time it
35:05 - probably does make sense to simplify
35:06 - these a little bit but we'll see how
35:08 - stubborn we are with that
35:09 - and if i end up actually you know
35:11 - simplifying all these variable names
35:12 - just for
35:13 - case sense okay so book times so now i
35:15 - need to get into the issue of how am i
35:17 - going to compare these
35:18 - string numbers so i almost want to make
35:19 - a function just to compare these to tell
35:21 - me
35:22 - um i'm going to do it like i would
35:24 - actually do it in java and get like the
35:25 - 1 negative 1
35:26 - 0 based on if it's greater than or less
35:27 - than for comparison so i'm going to say
35:29 - define compare times i'm going to say
35:33 - time 1 time 2.
35:37 - now we need to get our hours so we need
35:38 - to get our minutes so i'm going to say
35:40 - hour 1 equals and in this case it's
35:43 - going to be
35:44 - time one dot splits
35:48 - coin and i think i can actually do
35:52 - hour one minute one is going to be time
35:56 - one dot split
35:57 - that should actually decompose that
35:59 - because i know and i'm guaranteed that
36:00 - i'm gonna have these zero zeros and will
36:02 - i have
36:03 - uh yeah so that should be fine because i
36:04 - can split up the colon yeah and you can
36:06 - assume
36:07 - assume that these strings are gonna be
36:09 - in such a way that your math here is
36:11 - correct then you don't need to do fancy
36:13 - edge case handling or anything
36:16 - okay good because that was gonna make it
36:18 - a lot more complicated for not even
36:20 - really part of the problem okay
36:21 - so now we'll have our one minute one so
36:23 - we can start by saying
36:27 - if and actually i could literally just
36:28 - convert these to minutes and then do the
36:30 - comparison so i could just do hour 1
36:32 - times 60 plus
36:32 - okay so let's actually do that uh it's
36:35 - going to be
36:36 - powerful all right so here i've given
36:38 - away what i should have just done to the
36:40 - entire
36:40 - input so you can see i'm writing this
36:42 - kind of complicated function that's
36:43 - going to compare
36:44 - you know string times and return a one
36:46 - if it's greater
36:47 - zero if they're the same and negative
36:49 - one if they're different when in reality
36:51 - rather than having to even write this
36:52 - compare times function
36:54 - what i could have done is just converted
36:56 - the entire input into minutes
36:58 - and then that way it would have been way
37:00 - easier for me to do everything you're
37:02 - about to see
37:03 - but of course i didn't consider that
37:05 - when i was in this problem i
37:06 - definitely should have but you'll see
37:09 - that if it was in minutes that
37:10 - immediately makes this problem so much
37:12 - easier and that's something that i just
37:14 - didn't end up doing
37:15 - uh it's gonna be hour one minute one
37:19 - yeah that's fine okay so we're gonna
37:20 - just say
37:22 - time one i'm going to change that to my
37:24 - initial variable is going to be
37:26 - int hour 1 multiplied by
37:29 - 60 plus minute 1
37:33 - and then time 2 equals int and that
37:36 - should be actually an int as well
37:38 - minute 1 and we'll say int hour 2
37:42 - time 60 plus
37:45 - int minute 2 and do a quick check here i
37:49 - think that should hopefully just give me
37:50 - kind of the amount of time
37:52 - in minutes because 18 times 60 since
37:54 - it's 24 hour time that should be right
37:56 - plus int minute yeah i think that's
37:59 - right
38:00 - and then what what i'm going to say is
38:02 - if
38:03 - time one is greater than time two
38:08 - return one one will stand for
38:13 - greater than and then we'll say l if
38:16 - time 1 is less than time
38:19 - 2 return
38:25 - this would be negative 1 which will be
38:28 - less than and then
38:29 - else return 0 which will mean that it's
38:32 - the same
38:33 - so i'm just kind of stealing that from
38:34 - the compareto method in java that they
38:36 - usually use so we'll just say this would
38:37 - be
38:38 - same okay and now what i need
38:41 - is to create this kind of schedule thing
38:44 - so how do i insert these times in sorted
38:47 - order well i'm going to have to use
38:48 - those comparisons okay so we'll start by
38:51 - just comparing
38:52 - the start times i guess and just
38:54 - inserting essentially what the earliest
38:56 - start times it are into our list
38:57 - so i'm just going to say 4 oh i need
39:00 - actually
39:02 - i'm going to say p1 which is going to
39:04 - stand for pointer 1
39:06 - and p2 would be 0 0.
39:09 - i'm going to say while p1 is less than
39:13 - the length of p1 and i'm actually just
39:16 - going to make it p1s
39:18 - i know this is like not the best way to
39:19 - name them but it's just going to save me
39:20 - a bit of time because i have no problem
39:22 - running a bit low
39:23 - while p1 time is less than that or
39:26 - p2 is less than the line
39:29 - of p2s we're going to say
39:33 - if in this case p1s
39:39 - at pointer one
39:43 - start time which will be zero yep so we
39:46 - have to say if
39:47 - compare times
39:50 - p1s and then p2
39:55 - s at pointer to
39:59 - zero so that should actually compare our
40:01 - time so if that equals equals one which
40:03 - is
40:03 - actually we're going to say negative one
40:06 - this will mean that we are
40:07 - less than so p1 less than p2
40:10 - yep so then we'll insert that into our
40:12 - book time so we'll say booked underscore
40:14 - times
40:15 - dot append and then this should be
40:18 - p p one s
40:22 - p one i hate reading this but that's
40:24 - okay uh
40:25 - and then we'll say p1 plus equals one so
40:28 - p1
40:29 - plus equals one so that should increment
40:31 - our pointers um
40:32 - so p1 i think yeah i think that actually
40:36 - will work and we'll say otherwise
40:38 - then we can just insert the other one
40:39 - soon as it booked the square times
40:42 - dot append and if they're the same we're
40:44 - just going to default to insert the
40:45 - other one i guess
40:46 - just fine so we'll say p times dot
40:48 - append
40:50 - p2s p2
40:54 - so quick note here that it probably
40:55 - would have been easier if i simply put
40:57 - like p1 time p2 time as variables
41:00 - notice here that i have like p1sp1 at
41:03 - index 0 and then i'm writing like all of
41:05 - these indexes multiple times
41:07 - so you know usually it's better to throw
41:09 - those into a variable it just makes it
41:11 - cleaner and that's typically better you
41:12 - know coding practice
41:13 - anyways we'll continue and then
41:17 - p2 plus equals one okay so
41:20 - after this is done assuming i didn't
41:23 - make any mistakes
41:24 - then this should actually give me that
41:26 - sorted list now i'm kind of doing this
41:28 - the way that you do it like in merge
41:29 - sort where you just compare
41:31 - like you know this one to this one and
41:34 - then you know
41:34 - our next pointers up at this one if we
41:36 - insert this first one
41:37 - and then i compare it this one to this
41:39 - one then i insert this then my next
41:41 - pointer's here
41:42 - then i compare it to this one i insert
41:44 - that my next pointer's here
41:46 - compare this one to this one answer that
41:48 - so i think
41:49 - you're following me with that right that
41:50 - makes sense yep
41:54 - so did you guys catch the bug you can
41:57 - pause it and try to find it
41:58 - i can tell you right now that if you
42:00 - have a look at this or that will
42:01 - probably give it away to you
42:03 - essentially what's going to happen here
42:05 - is i need to actually throw in a clause
42:07 - in this while statement
42:08 - that says you know if p1 reaches the
42:10 - maximum length then just add all the
42:11 - values from p2 if p2
42:13 - reaches the maximum length like the
42:14 - pointer then i add all the values from
42:16 - p1
42:17 - i not sure if i do that afterwards we'll
42:19 - actually see
42:20 - if that happens but if i put an and
42:22 - instead of the or
42:23 - then that means that i will end up
42:25 - adding all of them assuming assuming i
42:27 - have that kind of like clause in the
42:28 - while statement or that condition in the
42:30 - wall statement
42:30 - anyways i hope that makes sense but see
42:32 - if you can catch that bug
42:36 - okay so now that we have that now it's
42:39 - time to do
42:40 - that kind of parsing through with the
42:42 - which is going to be a little bit more
42:43 - complicated like we talked about before
42:45 - so i'm going to say 4 i'll just do
42:49 - 4i in range the lan
42:53 - of booked underscore times
42:56 - okay i thought you still have 12 minutes
42:59 - so you're good on time
43:01 - okay great so for iron range the line of
43:04 - book times and
43:05 - let's see but while we're up here we're
43:06 - going to say i'm just going to call this
43:09 - a veil you know what i feel like i'm
43:12 - going to spell that wrong so let's just
43:13 - call this
43:14 - output okay was that so we can store our
43:16 - stuff in there
43:17 - for iron range the lan of booked times
43:21 - now i want to go through my thing one
43:22 - more time so essentially what i'm going
43:25 - to do is compare
43:26 - the ending time of entry one uh to the
43:29 - start time of entry two
43:31 - if this time is greater than this then
43:34 - we can mush them together
43:35 - but if this time here is um
43:40 - what do you call if this time here is
43:41 - actually less than the other
43:43 - time then i can straight up just remove
43:45 - this entire entry
43:47 - okay i think that makes sense uh okay so
43:50 - i'm
43:50 - still debating whether or not that's
43:52 - perfect but i think that's okay so for
43:54 - eyeliner book time since we're going to
43:55 - compare to the one
43:57 - above but i could actually technically
43:59 - be removing stuff
44:00 - so i almost just want to say do a while
44:03 - loop
44:05 - because if i'm going to be removing
44:06 - stuff from the loop that from the list
44:08 - that i'm looping in
44:09 - that's going to cause issues so i almost
44:12 - want to use a while loop instead
44:13 - and then if i remove something just
44:15 - leave the pointer or whatever the index
44:17 - it was out before
44:18 - um yes let's do that i'm going to say i
44:21 - do you need to
44:22 - do you need to mutate this booked times
44:24 - list or can you mutate
44:26 - maybe the output list i mean up to you
44:28 - whatever you feel more comfortable
44:30 - writing yeah um
44:34 - i don't think i need to mute like i
44:36 - definitely don't need to mutate the book
44:38 - times less
44:38 - but kind of the way i'm thinking about
44:40 - it right now i don't have like a better
44:42 - idea
44:43 - okay for how to not mutate it although i
44:45 - think actually like i can probably come
44:47 - up with the output in this
44:48 - for in one loop while i'm looping
44:50 - through i don't think i actually need to
44:53 - even change this or do another loop
44:54 - which is kind of what i was planning to
44:56 - do
44:57 - but i might confuse myself a bit while
44:58 - i'm coding that um
45:00 - in the interest of time i would probably
45:02 - go with well there are two arguments
45:04 - here but i would probably go with what's
45:06 - least confusing to you yeah
45:09 - okay so let's say i equals zero while i
45:11 - is less than
45:12 - the lan of and this line will update
45:14 - every time so that should be good
45:16 - elen of booked underscore times
45:20 - i'm going to say now i need to compare
45:22 - the end time of
45:23 - entry whatever to the next entry which
45:26 - actually means that this should be a
45:28 - negative one
45:29 - here okay so now we're gonna say
45:32 - start one or actually
45:36 - and i'll just say end one
45:39 - equals in this case booked underscore
45:42 - times i
45:47 - one and then we'll say start
45:50 - two equals booked underscore times
45:54 - i zero
45:59 - now what we need to do is say if and one
46:02 - is greater than now i need to use my
46:05 - compare times method
46:06 - yeah if compare times
46:10 - and one start two
46:13 - i gotta remember what i wanted to do
46:15 - there so if
46:17 - the end here is greater than
46:21 - the start here i need to
46:24 - modify the list otherwise i think i can
46:27 - actually just
46:28 - look at the distance between this and
46:30 - the start time
46:32 - and figure out what that should be okay
46:35 - so if this time is 1
46:38 - so that essentially means if the end of
46:40 - my other one is greater than the start
46:41 - of my other one
46:42 - now what i want to do is figure out what
46:43 - the end of the other one was so i'm
46:44 - going to say n2
46:46 - equals in this case booked underscore
46:49 - times
46:50 - this should be and this needs to be i
46:53 - plus one
46:54 - on that i plus one and this needs to be
46:57 - one now i want to figure out
47:02 - what i should do here um actually i
47:05 - don't even think i think i could just
47:07 - like skip to the next entry if this
47:10 - if it's the case that the other end is
47:13 - greater
47:14 - yeah so if i'm looking here and i do
47:17 - let's
47:17 - find an example here like i'm kind of
47:20 - mad that i've
47:21 - got rid of my example if i did like 15
47:24 - what is it 17 yeah so if this is greater
47:27 - than this
47:28 - yeah but this
47:31 - is greater than this one
47:34 - then what i need to do is put 18 here
47:36 - but if this is say 16
47:38 - 30 then what i can do is
47:41 - literally just skip over this entry i
47:44 - think
47:45 - because there will be no availability in
47:47 - that time so i should go
47:48 - i plus two maybe um
47:52 - i think that works if i just skip past
47:55 - that
47:55 - i plus equals two rather than i plus
47:57 - equals one because if
47:58 - the end time is greater so if
48:02 - and if
48:05 - compare times in this case n2
48:09 - uh in this game just go end one
48:13 - equals equals one so that should mean
48:15 - that the end time of the other one is
48:16 - greater than this end time
48:17 - then i could skip over it yep otherwise
48:26 - so if the compare times actually so if
48:29 - it is
48:29 - isn't the case that i have that edge
48:31 - case so let's say we have the example
48:32 - here 11
48:33 - 30 12 30 because that'll be what i get
48:35 - into the else statement
48:36 - then what i can do is calculate the
48:38 - difference in time
48:39 - if that is greater than whatever that
48:41 - value is that passed me
48:43 - i can just send that into the output
48:45 - list as that should be an
48:46 - answer because i should be able to book
48:47 - a time between that end time and between
48:49 - the next start time
48:51 - i think that's logical so
48:54 - otherwise if so now i actually need to
48:58 - figure out the difference in times
49:00 - i'm just going gonna write like a pseudo
49:02 - function that says like difference in
49:03 - time and like i'll
49:05 - i can code it later five times i'll say
49:07 - if diff
49:09 - in time and we'll go between
49:14 - end one start two
49:17 - is greater than or equal to what did i
49:19 - call that variable
49:20 - but here here tim by by doing this
49:24 - i i get that you're trying to you're
49:25 - kind of like trying to skip ahead here
49:27 - and
49:27 - basically get an answer right off the
49:29 - bat but
49:30 - in the case above here you won't have
49:33 - done this
49:34 - so will you not basically be like by
49:37 - doing
49:38 - by trying to get the answer immediately
49:40 - in this else will you not be sometimes
49:42 - skipping
49:43 - getting the answer when you're in this
49:45 - situation
49:47 - but the i think the the thing here
49:51 - is if i'm in oh yeah because you're
49:53 - right because i'm going to skip over two
49:54 - so maybe i just won't even bother doing
49:55 - this and i'll just
49:57 - do the yeah so i do actually need to
49:59 - mutate the list then i guess from what i
50:00 - was doing because i was trying to go
50:01 - back to the other approach but i guess
50:02 - i'll just mute the list so rather than
50:04 - skipping over one
50:05 - what i'll do is just remove the next
50:07 - entry
50:09 - in this instance and then merge the
50:10 - times otherwise i'll do something else
50:13 - so we'll say else
50:16 - then what i need to do is literally say
50:19 - in this case i can just remove that next
50:21 - entry
50:21 - so i could say booked underscore times
50:25 - dot remove um actually
50:29 - dot pop uh this is gonna be i plus one
50:33 - because i don't need that entry
50:34 - otherwise then i'll merge the start time
50:36 - and
50:37 - in the end time so i can actually just
50:38 - say booked underscore
50:40 - times i
50:45 - one equals and two
50:49 - uh yes yes
50:52 - okay so now i've done this let's just i
50:54 - mean assuming
50:55 - this is right i've generated a list and
50:58 - now what i can do is literally just do
50:59 - the
51:00 - blocks in between and then add them to
51:02 - the output assuming that's right again
51:04 - not 100 but i think it's okay
51:08 - so now we'll just loop through again uh
51:10 - oh and i need to make sure i increment i
51:11 - otherwise that's not going to be very
51:13 - good is it i
51:15 - plus equals 1. i think that's fine
51:19 - because if i remove
51:20 - the entry then i shouldn't increment
51:24 - i but if i don't remove the entry
51:28 - then i should and i should
51:31 - i'm sorry here at tim yeah sorry yeah
51:34 - can you hear me
51:35 - are you let me just pause the timer one
51:37 - second are you still typing in the dock
51:40 - uh yeah okay just okay i'm restarting
51:43 - the timer because it had just freaked
51:45 - out on my end but now i see it
51:46 - all right okay yeah yeah no worries uh
51:49 - yeah i just got a reconnecting but worse
51:50 - like i have all the recording on my okay
51:52 - perfect so it's fine yep okay uh so
51:55 - actually what i've just done sorry
51:56 - in case you missed that is i did i minus
51:57 - one i plus one because now what i'm
51:59 - going to do is if i
52:00 - pop the entry i need to stay on whatever
52:02 - that current entry is to compare it to
52:04 - the next one because i've just removed
52:05 - it
52:06 - um but otherwise i'll increment my
52:09 - counter i plus one so that i can move to
52:10 - the next one then start doing that
52:12 - um since this is getting long i'm going
52:13 - to go down
52:15 - onto the next page
52:19 - okay and now we'll do this next while
52:21 - loop where i'm going to do
52:22 - the comparison thing that i just wanted
52:24 - to pop in here quickly and say i hope
52:25 - you guys can appreciate how difficult it
52:27 - is to code
52:28 - in google docs with like the auto
52:30 - indentation tab
52:32 - issues with like the auto complete
52:34 - capitals that was really throwing me off
52:36 - but anyways
52:36 - just wanted to note that that this is a
52:38 - lot more difficult than say writing on
52:40 - the whiteboard
52:41 - i've done both and writing on a
52:42 - whiteboard is way easier than this
52:44 - there's something that i talked about
52:46 - before like the difference in between
52:48 - so i'll say wow and i guess we're going
52:49 - to go i equals 0 again
52:52 - or i could probably just do a for loop
52:54 - to be honest i don't think i need to do
52:56 - a while
52:56 - say in range
53:01 - booked underscore times um
53:04 - what are you doing in this final four
53:06 - loop this final for loop what i'm gonna
53:08 - do is
53:10 - figure out uh the output so essentially
53:12 - the difference between the end time and
53:13 - the start time of the next entry
53:16 - and then if that time is enough i will
53:18 - simply add
53:19 - that block so the start time and end
53:21 - time of the other entry to the output
53:22 - list
53:23 - and then that should be good so i need
53:24 - to do -1 there because uh
53:26 - when i compare to the last element i
53:27 - have i plus one i don't have an index
53:29 - error okay i'm going to say if
53:31 - in this case diff between and we're just
53:34 - going to assume that i've written this
53:35 - function but for now
53:36 - i've not uh is equals one so
53:40 - actually sorry is greater than or equal
53:42 - to not 30
53:44 - time so if the difference between this
53:47 - is going to be
53:49 - let's go just to make this a little bit
53:51 - cleaner uh
53:52 - end one is going to be equal to booked
53:55 - underscore
53:56 - times i one yep and
54:00 - start two is gonna be equal to booked
54:03 - underscore time i plus one
54:07 - zero yep so in that instance we can say
54:11 - if the difference between
54:12 - start end one
54:17 - start two and we'll assume this gives us
54:18 - an absolute value difference that that's
54:20 - not gonna be negative
54:21 - um then what we'll say is add that block
54:24 - otherwise don't even bother okay so then
54:26 - we'll say output
54:29 - dot append and in this case we should
54:31 - just do end one
54:34 - start one start two and then
54:38 - return
54:41 - output now i'm like almost 100 sure that
54:44 - this probably doesn't work just because
54:46 - i think i've confused myself a lot
54:47 - throughout like what i was doing here
54:49 - but
54:50 - the logic for my solution i think makes
54:52 - sense but i don't think this code
54:54 - will be a hundred percent just i feel
54:55 - like i should say that do you
54:57 - do you mind running me through the uh
54:59 - complexity analysis
55:02 - uh yeah oh sure the complex analysis
55:04 - okay so in this instance
55:06 - we're going to run this loop will run i
55:08 - guess it's going to be
55:09 - o n plus m where we're going to have
55:13 - nbp 1s and mbps p2s
55:16 - yep then for this time this booked list
55:19 - will be the same thing so this will be o
55:21 - n plus m um i minus one
55:24 - skip in it alright so i will quickly
55:26 - pause here before i let myself continue
55:27 - with the complexity analysis here
55:29 - you can see i've just gone over time and
55:32 - clearly this problem was you know
55:34 - more difficult than i've been used to i
55:36 - spent a lot of time at the beginning
55:38 - trying to understand exactly what i
55:39 - needed to do and of course you know that
55:41 - left me with just the amount of time to
55:43 - kind of scrape by
55:44 - with the solution that as i've noted
55:46 - myself probably won't fully be
55:47 - functioning but the general kind of idea
55:50 - behind it is somewhat correct
55:51 - anyways i'll let myself continue with
55:53 - the complexity analysis but clement is
55:55 - nice enough to give me an extra i think
55:56 - we have like five minutes or something
55:58 - to go through the complexity analysis
56:00 - i'm not sure if i make a fix or not so
56:01 - we'll see
56:02 - um if that happens but remember there is
56:05 - one big bug in this program that
56:06 - happened at the very beginning that i
56:08 - think i already went through
56:09 - one skipping it no that's fine so this
56:11 - will be o n plus m
56:13 - and then for this last one this will be
56:15 - om plus m again
56:16 - as max so this should be an o n plus
56:19 - m complex unless i'm missing something
56:22 - uh oh the compare times that this will
56:24 - run constant time
56:26 - my difference between over and constant
56:27 - time i don't think i've done any
56:29 - interior loops inside book times that
56:32 - append that append
56:33 - actually the pop here sorry where's my
56:35 - pop because i know that pop will not run
56:36 - in constant time
56:37 - um this pop here pretty sure will run in
56:41 - on
56:42 - so i could actually have o n squared m
56:45 - because this pop i'm pretty sure
56:47 - doesn't run in constant time i don't
56:48 - know but since it's a list and it has to
56:50 - potentially move something
56:52 - it would have to potentially shift every
56:53 - element in the list over depending on
56:54 - where i pop from
56:55 - yeah that could be n this my average
56:57 - case i think is still going to be m plus
56:58 - m but
56:59 - uh worst case would be n square plus m
57:01 - so that would make the overall time
57:02 - complex the n squared plus
57:03 - m including this pop but pop usually is
57:06 - pretty fast operation implemented
57:08 - in python so that should give me average
57:10 - time and plus m i think that's right uh
57:12 - space complexity and there's another pop
57:14 - in here i'm pretty certain that pop
57:15 - runs in o n of course i could go through
57:19 - this in more detail and discuss
57:20 - when i'm popping and how many elements i
57:22 - would potentially be shifting but the
57:23 - reason i'm classifying that as big o of
57:25 - n is because technically if i pop the
57:27 - first element of a list
57:28 - the entire rest of the list i would need
57:30 - to shift into that position
57:32 - so that would run in o and time if you
57:34 - understand time complexity you probably
57:36 - understand what i'm getting at but of
57:37 - course i wanted to make that clear
57:39 - in the interview bass complexity i'm
57:41 - going to have
57:42 - n plus m and then output will be i guess
57:44 - yeah so i guess that's constant so n
57:46 - plus m okay
57:47 - so yeah i think we just ran out of time
57:49 - sometimes you know interviewers will go
57:51 - a little bit over time so maybe maybe i
57:53 - would ask
57:53 - you you know very quickly how confident
57:55 - you feel about your code but you
57:57 - sort of told me yeah um yeah if you want
57:59 - let's spend actually like
58:01 - two more minutes going over the code and
58:02 - then we will get into the debrief and
58:04 - sort of end the interview but out of
58:06 - curiosity
58:07 - if you very briefly walk through the
58:09 - code do you see any place where you
58:11 - think you have
58:12 - a bug for sure okay so my first main
58:16 - piece of logic i'm fairly confident in
58:18 - although i would like to debug it a bit
58:19 - to obviously make sure
58:21 - this is just going to essentially build
58:23 - that
58:24 - sorted list of all the times that both
58:26 - people are booked
58:27 - so the way this logic works is
58:29 - essentially the same way that merge sort
58:30 - works
58:31 - so what i'm going to do is compare the
58:33 - entry in my first list at pointer one
58:35 - to the entry in my second list at
58:37 - pointer two and then
58:38 - based on whatever that is so if my
58:40 - pointer one
58:42 - in my first list is less than the
58:44 - pointer
58:45 - point or two in the next list i'll pin
58:46 - that in otherwise i'll pin the other one
58:48 - so this one should technically build
58:50 - that sorted list
58:51 - since i have these two pointers i won't
58:53 - add the same element
58:54 - twice because what i'll end up doing is
58:56 - like once i get to the end of list one
58:58 - then this will always be like greater
59:01 - than
59:02 - the other one so it'll always add until
59:04 - we get to pointer two and then this
59:05 - i think like this condition works fine
59:07 - yeah i think i understand what you mean
59:09 - i guess here here i think you would
59:11 - probably have to add something here
59:12 - compare times
59:14 - to handle that because like what you
59:16 - just said about this
59:17 - once you reach the end of one of the
59:19 - lists this will always be bigger or
59:21 - something
59:21 - yeah not really because you will
59:23 - eventually one of the lists will
59:25 - finish so to speak before the other one
59:27 - and your condition
59:28 - will still run so you'll be accessing
59:30 - values past the list
59:33 - uh no i actually i won't because i won't
59:35 - increment this pointer
59:37 - unless this specific condition is true
59:40 - so what'll end up happening is if i
59:42 - insert this because it's oh if i insert
59:44 - that because it's less than okay you're
59:46 - actually sorry you are actually are
59:47 - correct yeah i'd have to do something
59:48 - like
59:49 - i don't know why i thought that was
59:50 - gonna work if pointer one is
59:52 - you know greater than or i guess is
59:55 - equal to the line of
59:57 - p1s minus one then i would just add
60:00 - pointer two and then same thing with the
60:02 - other way around
60:02 - yeah something like that you know i'm
60:04 - saying that okay exactly yeah assuming
60:05 - that okay so that's like
60:06 - that's a good bug to catch i was kind of
60:07 - speeding through this one okay so now
60:09 - this piece of logic here is essentially
60:11 - trying to kind of mutate that list to
60:14 - find
60:14 - the blocks that we can use for the next
60:16 - part of logic which i'll talk about so
60:17 - what this one is going to do
60:19 - is compare the start time and the end
60:22 - time of the blocks that are beside each
60:24 - other because we know that they're
60:25 - sorted
60:26 - so what that that will allow me to do is
60:28 - essentially i'm going to create
60:30 - block like the largest blocks of time
60:32 - that i can that are beside each other if
60:33 - that makes sense so like say
60:35 - i have nine to like 12 30 and this is 12
60:37 - to 7 and that would be 9 to 17 o'clock
60:39 - right that's what that's doing or at
60:40 - least
60:41 - i'm trying to do in this block of code
60:44 - so i'm comparing the times
60:45 - if the end time is greater than the
60:48 - start time of the other one
60:49 - then what i'll do is compare the end
60:51 - times yep if the end time of
60:53 - the other one so the one further right
60:54 - in the list is less than
60:57 - the end time so actually i think that
60:59 - needs to be
61:00 - yeah because here you compared you
61:01 - compared n two to n one so yeah
61:04 - yeah i realized i think i did that
61:06 - backwards yeah so if n2
61:08 - is less than n one then you are popping
61:11 - the value the next values you are d
61:15 - okay that makes sense you're
61:16 - decrementing i and then you still
61:18 - increment it after to basically like
61:20 - keep moving forward
61:21 - exactly exactly yeah and then here this
61:24 - is just
61:24 - this is just mutating that list so it's
61:26 - moving the n2 over okay so yeah so that
61:27 - negative one was needed to there
61:28 - that's what happens when i guess you
61:29 - speed through okay that last part i
61:31 - think is is fine
61:32 - uh let's jump into the debrief uh why
61:35 - don't you start by telling me like how
61:36 - you feel right now yeah all right so
61:38 - we're at the debrief section i will let
61:40 - myself
61:41 - continue here it's funny i'm
61:42 - interrupting myself but as you can see
61:44 - there you know we kind of went through
61:45 - it at the end
61:46 - usually what i would do if i had
61:48 - adequate time is before i
61:50 - you know say i feel confident i feel
61:52 - like the solution is good i would do
61:53 - what i just did i would walk through the
61:55 - entire code
61:56 - i would try you know a test example on
61:58 - it and and make sure that it's actually
62:00 - functioning properly
62:01 - obviously in this situation i didn't
62:03 - have enough time where i could actually
62:05 - run through a sample
62:06 - input and make sure my code would
62:07 - perform but that's usually what i
62:09 - always do whenever i finish these coding
62:11 - questions again in this situation i was
62:13 - kind of running low on time so it was a
62:15 - big rush at the end
62:16 - and i can kind of credit some of these
62:18 - you know silly mistakes to the fact that
62:20 - i was rushing
62:20 - anyways i guess i will let myself tell
62:23 - you guys how i felt
62:24 - you feel right now yeah for sure i mean
62:26 - obviously guys like you can probably
62:27 - tell based on kind of my mood and what
62:29 - we're going through
62:30 - i don't feel great about this solution
62:31 - this problem was challenging for me to
62:33 - kind of
62:34 - comprehend just because even like this
62:35 - string input was like there was a lot of
62:37 - stuff that was just like a lot of
62:39 - details to deal with at once
62:40 - like i kind of confused myself a little
62:42 - bit as i went through the different
62:43 - paths i'm happy i came up with a logical
62:45 - solution that makes sense
62:47 - i think the time complexity is actually
62:48 - pretty decent i didn't do anything too
62:50 - crazy with
62:51 - i mean i have this n squared but that's
62:53 - just because of that pop but i didn't do
62:54 - anything too crazy with the complexity
62:56 - so that's okay
62:57 - i felt i explained my logic pretty well
62:59 - i asked decent clarifying questions but
63:01 - like just
63:02 - you gave me a little bit of hints for
63:03 - the solution i think maybe if i had more
63:05 - time or if i'd
63:06 - done a little bit more prep on something
63:07 - maybe this diff more this difficult
63:09 - i would have been able to come up with a
63:11 - little bit faster and a little bit
63:12 - cleaner
63:13 - you kind of get my like vibe from that
63:15 - yeah yeah so
63:16 - so listen i'll give you my input i think
63:18 - you did really well
63:19 - i think your your your assessment is
63:21 - probably how i would feel if i were you
63:23 - like you're kind of like oh i feel like
63:24 - i sort of got it but at the same time
63:26 - it's like not
63:27 - you know it's not picture perfect but
63:29 - yeah what you should take away from this
63:31 - because again from my point of view you
63:32 - actually did very well
63:34 - i would have to you know take a little
63:35 - bit of time to grade you so to speak
63:37 - following the actual
63:38 - criteria that we're given but you would
63:40 - probably get something along the lines
63:41 - of a higher or a strong higher decision
63:44 - here at least from me okay
63:45 - based on what i'm seeing the main reason
63:47 - is this first of all
63:49 - this is a very difficult question this
63:50 - is actually a question that we have on
63:52 - our go expert i know for a fact that you
63:53 - didn't do it based on the questions yeah
63:55 - you did do but so this is a very hard
63:57 - question on algoexpert
63:58 - the reason that it's very hard is
64:01 - exactly what you said
64:02 - first of all there's a lot of
64:04 - information there are a lot of inputs
64:06 - there's a lot of different like types of
64:08 - inputs you saw that they're strings
64:10 - they're not numbers they're military
64:12 - time
64:12 - you have these daily bounds which by the
64:14 - way the daily bounds
64:16 - you can simplify the problem by just
64:18 - creating artificial meetings
64:20 - at the beginning and end of each
64:22 - person's calendar
64:23 - using the daily balance if that makes
64:24 - sense that's kind of what i figured yeah
64:26 - that's what i figured out that's kind of
64:27 - what i was trying to figure out at the
64:28 - beginning and then i was running low on
64:29 - time and then that was just another
64:31 - piece so we just skipped by but yeah i
64:32 - did
64:32 - kind of think of that exactly but but
64:34 - but even that like it's an additional
64:36 - piece of just complicatedness or
64:38 - complexity and then the thing that's
64:40 - difficult about this problem is
64:41 - not so much the algorithm because the
64:43 - algorithm or the logic
64:45 - is is fairly intuitive and i think you
64:48 - you came up with a version at the very
64:49 - beginning that i think would have worked
64:51 - fine i just pushed you in a slightly
64:53 - different direction that i think is a
64:54 - little bit simpler but you were doing
64:55 - just the
64:56 - the opposite order of operations but
64:58 - then the coding the coding is difficult
65:00 - yes transcribing this into code is
65:02 - difficult and i think you did a very
65:03 - good job
65:04 - like you pointed out the part of the
65:06 - code that's probably the the
65:08 - most shaky is this middle part here with
65:10 - the popping
65:11 - yeah and the the fact that you're kind
65:13 - of overwriting this
65:14 - this thing and there's a way to do this
65:16 - without the popping that we don't need
65:18 - to get into here
65:19 - but i think that you you explained your
65:21 - logic soundly
65:23 - and you managed to transcribe it into
65:25 - something that you know seems like it's
65:27 - getting
65:27 - you know it's getting close to working
65:28 - probably there are edge cases here that
65:30 - aren't handled but
65:31 - it's getting close to working you also
65:32 - did a good job of using helper functions
65:34 - and that kind of thing
65:35 - to your advantage like compare times
65:37 - like this is the kind of thing where
65:39 - a must to do something along these lines
65:41 - is the the the diff between
65:43 - here absolute must you know otherwise
65:46 - like you're going to get a
65:47 - gross algorithm you did have a little
65:49 - bug in the in the merging but that was
65:51 - you you caught it near the end and again
65:53 - it's like this is the kind of problem
65:54 - where
65:55 - it would be a lot to ask to expect a
65:57 - candidate to code this entire solution
65:59 - perfectly in just 45 minutes all the
66:02 - while solving it
66:04 - so this is like this is more than what i
66:06 - would expect especially if you're
66:07 - if you're going for an intern position
66:09 - where we don't necessarily you know have
66:11 - the
66:12 - same bar as let's say a senior position
66:14 - full-time senior position
66:16 - so yeah overall i think you you did a
66:17 - good job okay
66:19 - well i mean that's okay that's great
66:20 - feedback definitely makes me feel a
66:21 - little bit better because yeah i was
66:22 - kind of thinking about
66:23 - all right so i'm gonna cut myself off
66:25 - there i know what happens at the end of
66:26 - this interview it's not too interesting
66:28 - but there you go that's clement's
66:29 - feedback for me i mean do you guys agree
66:32 - do you disagree he's done a bunch of
66:34 - coding interviews with you know like
66:35 - literally hundreds of people
66:37 - at google so i trust his word and this
66:39 - was really great practice for me
66:41 - going into like my microsoft interview
66:43 - and my shopify interview
66:45 - because i did not get questions that
66:46 - were this difficult so like clement said
66:48 - this is a difficult question
66:50 - yes some of you will probably look at
66:52 - this and say oh you know i could answer
66:53 - that this way
66:54 - but i can guarantee you it is a lot more
66:56 - difficult when you're on a google docs
66:58 - you can't see the guy's face because we
66:59 - were on like
67:00 - just a call right have my earbuds in and
67:02 - you're just going and trying to do it in
67:04 - 45 minutes
67:05 - so anyways that has kind of been the
67:07 - mock coding interview
67:09 - looking back at this now i will give
67:10 - kind of a summary of my thoughts
67:12 - i think that generally i did a decent
67:14 - job i stuck with what i always try to do
67:16 - which is
67:17 - explain myself as well as possible and
67:19 - you saw the benefits that i gained from
67:21 - that clement gave me a few hints
67:23 - you know i was able to catch some of the
67:25 - bugs i was able to figure out the flaw
67:26 - in my own thinking simply because i was
67:28 - kind of speaking out loud
67:29 - and i always find it's easier to have
67:31 - someone to kind of rebound ideas off of
67:33 - because then you can very quickly
67:35 - determine based on you know even just
67:37 - little things that they say whether or
67:38 - not you're on the right track or not
67:41 - in terms of things for improvement i
67:43 - think definitely the coding was a little
67:44 - bit sloppy
67:45 - uh looking at it now this wouldn't be
67:47 - the standard that i would hold myself to
67:49 - i've just been coding longer
67:51 - coding more in the industry so i would
67:52 - have liked to see you know some
67:54 - better variables just things a little
67:55 - bit more split up easier to read
67:58 - i would have liked if i'd converted the
68:00 - entire input into numbers first or in
68:02 - two minutes
68:03 - sorry so that i wouldn't have had to use
68:05 - say the compare times thing and deal
68:06 - with strings and all of that
68:08 - but overall decent interview and you
68:10 - know this is really good for me looking
68:11 - back to see kind of how far i've come
68:14 - and how i might approach this problem
68:15 - differently now so anyways i hope you
68:18 - guys enjoyed if you have any questions
68:19 - any comments about this please do leave
68:21 - that down below
68:22 - the original video if you're looking for
68:24 - no cuts or for some reason you want to
68:26 - see it is on clement's channel which i
68:28 - will link down below
68:29 - with that being said if you enjoyed make
68:30 - sure you leave a like subscribe to the
68:32 - channel and of course i will see you
68:33 - guys again in another
68:34 - youtube video
68:39 - [Music]
68:43 - you

Cleaned transcript:

so i've got an exciting video for you guys today where i'm going to be reacting to my google coding interview so back in december of 2019 i filmed this video with my friend clement now clement is an exgoogle engineer he worked there for about two years and at the time i reached out to him and i said hey i'm currently preparing for interviews at microsoft shopify and a bunch of other large tech companies would you mind conducting a mock google coding interview with me we can film it you can post it to your youtube channel and well will be some great practice for myself of course clement agreed to this and he went ahead and we filmed this coding interview so just to give you some context here at the time of filming this video i was in my second year of university i had never done a coding interview before other than one phone screen which wasn't really like a proper coding interview and while i was extremely nervous for this video i had been preparing for the past few weeks even just for this video by answering about 40 or 50 questions on the algo expert platform in case any of you are wondering what that is clement runs this awesome business it's called algo expert essentially it's an interview prep platform and it's what i actually ended up using pretty much solely for my preparation for my microsoft and shopify interviews which i ended up passing so if you guys do want to check that out i do have a discount code it's tech with tim you can get 10 off i'll leave the link in the description but anyways i was using his platform and he had told me before the video hey you know if you want to prepare for this practice doing easy medium and hard questions so i did about 50 questions between those three categories most of them being in the medium and hard category and just so you're aware algo expert has a very hard and extremely hard category as well so i was kind of doing you know middle of the pack questions what you would commonly get so of course i get to the interview and what does clement do he gives me a very hard question to answer so immediately i'm a little nervous i'm like okay i've never done anything at this rated difficulty before but let's give it a shot and let's see how it goes so anyways that's all i kind of want to talk about and spoil before we get into this interview my reaction aspect of this is going to be me just kind of popping in every few minutes and talking about how i'm feeling in a specific situation if i did something wrong if i feel like i maybe did something well just kind of giving you guys maybe my thoughts on the interview but i will kind of let it play most of the time just so that i'm not interrupting constantly and you guys can actually enjoy it if you haven't seen the original video so anyways with that being said let's get started and get into the google coding interview all right so i'm on the computer i'm about to start the interview i'm gonna leave it for a few minutes just so you guys can hear the question you can see kind of what's going on and then as soon as there's some silence or i make a mistake or something like that happens i'll kind of jump in you know discuss that a little bit and then we'll move on all right so uh enjoy all right so tim when we tried to get this to happen this mock coding interview we naturally had to put something on the calendar right we have to find a time that worked for both of us and you know give ourselves 45 minutes or an hour to make sure that we had uh enough time to record this so i want you to write an algorithm that is going to basically take two people's calendars you can imagine google calendars and it's gonna basically return free slots of time during which these two people could have a meeting now here i'm gonna add a few other things to make sure that we're we're really on the same page here you can imagine that our calendars are going to basically be in the format of starting like they're going to be lists of tuples or lists of lists of length two so it's going to be something like you know one calendar would look like this where it might be noon to uh let's say 1pm then it might be 3pm to 4 30 p.m something like that it would actually be in military time so it'd be 15 to okay 16 30. yeah exactly okay and so this would be one calendar maybe mine this means that i have meetings between noon and 1 between 3 and 4 30. i'm going to give you a second calendar which is going to be your calendar and then i'm also going to give you some daily bounds because you can imagine that you might not want to have meetings before let's say 8 am or you might not want to have meetings after let's say 6 pm so i'll also give you something like daily bounds equals let's say 8 8 am and let's say 6 pm which would be 18 so this means that you not only have these meetings here but you also don't want to schedule meetings before 8 or after 6 pm okay okay so given so yeah given two calendars and two daily bounds and i'll give you a sample input in a second and a meeting duration so in our example you know we need about an hour for this interview but the meeting duration could be any duration i want you to return a list of availabilities during which we could schedule our meeting so here's an example and then feel free to ask me anything you want okay all right okay so sorry i'm just looking at that now i thought you were actually going to continue that's why i was saying no no problem um okay yeah so can we assume that any like time you give me for a meeting is within the bounds you gave me what do you mean by that so for example say like say you said like you know person one says they have a meeting for like they only want to book meetings from 9am until in this case i guess we'll say you know 20 what is that 8pm then all the meetings you give me will be within those bounds right there'll be no meeting that starts at like 8 30 or 8 45 or something yes and they'll be all like we can assume all valid input right and these are okay so these are strings that's interesting as well okay yep they're all valid inputs they're all strings and they're all in military time so you know okay 3pm is 15. and so it looks like these are sorted right now i'm going to assume they're not necessarily sorted no you actually can't assume that they are sorted you can almost imagine that like when you open your google calendar you kind of see the meetings in sorted order you know in descending order from the beginning of the day to the end you can imagine that that's the order they're going to be given in okay and last thing here so for example you'd be saying i'm looking at input tail highlighted so you can see here um 10 to 11 30 so then 11 30 is the end 12 30 is the start so i can obviously say that i could have a meeting from 11 30 to 12 30 right like that would be i know this says 30 but that would be valid 11 30 to 12 30. 11 30 to 11 30 to 12 30 would indeed be a valid block during which you could schedule a 30minute meeting but because of the top here you have this person or in this case who has a 12 pm meeting as you can see in the answer the block that we would be able to schedule would only be until 12. okay so okay so yeah okay so obviously that makes sense but um yeah i'm just trying to figure out you know if we if the meeting ends at 11 30 the next meeting can start at 11 30 and then if the meeting ends at 12 30 the next meeting can start at 12 30 so i don't have to do like 12 31 or something like that yes yeah exactly okay awesome okay so i think um my initial kind of idea here is i'm going to look at one person's calendar to all right so i'm going to pause it for one second and quickly just talk to you about what i actually just did in case some of you don't realize why i did that the first thing that i always try to do in coding interviews and what i've kind of learned is that you always want to even if you completely understand the problem ask a ton of questions so i was literally sitting there trying to think of every question i could ask that would tell them that you know i'm thinking about the ambiguity in this problem and trying to get everything down as specific as possible so i don't start solving the problem before i completely understand it so that's why i ask you know maybe potentially some silly questions just to make sure i'm clarifying everything and make sure that i really understand okay first of all these are strings you know i don't have to start at say 11 31 i can start at 11 30. oh am i going to get valid input is there going to be stuff that i have to look for in terms of edge cases that's kind of where i'm starting from and that's why i went through that so anyways let's continue and let's see what i do next is i'm going to look at one person's calendar to start and i actually only really care about the end times because the start time i obviously i can't start and hm actually i do care about the start times but the end times are what i want to start by looking at so essentially i'll look at the end time 11 30 and then i'll look at the next start time and say okay if there is enough time within that block for whatever this meeting duration is so in this case when i'm looking at 11 30 and i'm looking at 12 30 i know i have an hour so that's an hour of free time that i could technically book a meeting so what i would want to do then is check in the other person's calendar if they have time available between 11 30 and 12 30. so in this instance what i would do is say okay so between 11 30 i'll add 30 to that if i can book something in that time so between 11 30 and 12 that's about because that's kind of like the naive approach i think to do that now because this is sorted like i feel like i could search in this a more effective way to find whether they have a valid meeting time uh right now i'm just sorry i'm just kind of talking out loud trying to explore yeah for myself and get an idea of how i want to do this okay so yeah so i think that initial approach is going to be to look in one person's meeting this will be kind of my step one of the algorithm and figure out essentially all the spare times that they have because if i can figure out the spare blocks of times they have that's step one that's going to help me towards the final solution which is then just comparing those spare blocks of time to this next person's input so how do i figure out the spare blocks of time well i look at the ending time of one block and i look at the starting time of the next block and then essentially if i have time in between that then i can make another list and say okay so i have an availability and this person's scheduled between 11 30 and 12 30. then i could go continually so here 4 30 okay so there's no time here so now i'm going to look at the end block here which is 15 the start block here which is 16 that means i now have an hour available there so between 15 and 16 i could book a meeting then i'll look at 17 and when i actually get to the end block here what i can say is well that will go to whatever our bound is so in this case 1830 i technically would have availability from 17 o'clock until 1830 because that's the bound that you gave me there and then same thing here at the front i could treat this as the end time of say you know another block and say okay well from 10 to 10 well obviously i can't do anything there because that's the bound okay so once i can do that aspect then what i need to do is compare it to this block here so if i have and i'm just gonna sorry i'm just gonna write some lists down here so let's say i can generate my lists that look like 11 30 so i have an availability i know in person two schedule and i guess it doesn't really matter which person i do this for but let's just do person two for now at 11 30 to 12 30 i don't have anything at the upper bound because 10 is that upper bound i have an availability from 15 to 16. so let's do this 15. that should be a string but that's okay if you want you can remove the quotes for now if it's too if it's annoying yeah it's okay it's just it's just a habit of mine to to do it like that and then i would have an availability because now the ocd is going to kick in if i don't do it every time 17 to 18 30. okay okay so so these are my list of available times from this schedule and i think i i mean correct me if i did that wrong but i'm pretty sure that is right for the available times that person two has for person what i should yeah for person two so now what i want to do is compare this to person one so how do i do that so this person has their bounds of nine to ten oh so what i think i should probably do is actually the same thing for person two and i'll already have a function that can do this for me so that will actually mean i'm not going to be repeating really any logic and actually now i'm going to go no quotes so in this case 9 to 10 30 i have a time from 10 30. to 12 available and then i have a time from 13 to what is it 16 and then i have a time from 18 to 20. so sorry i forget what oh so the output is all the times that they could possibly have a meeting okay so although all the available blocks of time so it's not necessarily all the 30 minute increments it's basically okay all the free blocks of time during which you can schedule a meeting okay so what i think now i need to do is say okay so my start time i have between 11 30 and 12 30. so now what i'm gonna do is look at the end oh because now all right so i'm gonna jump in here for one second so if you guys can't already tell what i'm focusing on really heavily right now is just trying to come up with some kind of solution and test it with some kind of input to make sure i'm on the right track before i actually go ahead and start coding these problems for me at least are usually much easier to program than they are to understand so i usually try to take as much time as i can at the beginning even if that is in this case say 10 minutes because i had 45 minutes from the start to really digest the problem understand it and make sure i come up with some kind of thorough approach that i know is going to work before i start actually going ahead and coding the last thing i want is to write all of the code and then get to the end of it try some sample input on it and have that code break so right now you can tell i'm kind of struggling a little bit i've come up with a solution that's somewhat kind of working i feel like i'm on a decent track to getting there but i still don't know if this is going to be the exact right answer so of course i wish i could think faster and just immediately come up with the solution but we're 10 minutes in i'm kind of on one route right now you'll see in a second that clem kind of redirects me almost but let's have a look at what i do now just wanted to clarify kind of why i'm taking so much time at the beginning and not even writing any code i got to figure out what time so this there's an availability here from 10 30 to 12 30. so maybe what i can do is say if 11 30 is in between these two blocks and i have half an hour between this end time ah see now i'm kind of confusing myself a bit because now i have to get i got to get all the available blocks not just the 30 minute intervals okay sorry just give me one second yeah no problem no problem yeah okay 11 13. hmm so 11 30 is the earliest possible time i could have a meeting and then if the earliest possible time is 10 30 and it goes to 12 then i guess i could have a meeting from 10 30 to 12. so what i'm thinking is find the beginning time here uh oh okay because what i'm think what's where i'm getting hung up here is like what if i had something like 11 because i guess i could have this like 11 58. yeah technically this this wouldn't be enough time to have a meeting right so what i might what i would do then i guess is just strictly remove that because i can't have a meeting within that block of time so if i can do that first so essentially remove any blocks of time that are less than half an hour then that's going to help me a little bit more towards the final solution so let's say that's another step so we're going to start by building all of the blocks of available time that either person could have yeah and then what i'm going to do is remove any blocks that are invalid so if it's less than half an hour in between then get rid of them because there's no point we can't even we can't book a meeting in that or half an hour for this example but whatever that time is okay uh and this will be sorry this will be in minutes right so this will be this would be 30. so 30 would represent 30 minutes if it were one hour it would be 60. okay it could be 90 minutes and then okay all right so what's once i remove that then what i need to do is say okay so i have blocked from 10 30 to 12 so now i'll look at this first block because these will be still in sorted order based on just the property of what i'm adding them in and i'll say if 15 is in between these two blocks let's check if we can do a meeting okay it's not in between these two blocks so let's move to the next block okay so 15 is in between this next block i know that i have enough time in here to do a 30 minute meeting because i know that this is a valid range so now i check since 15 is in between these two blocks of time if there's half an hour to the end time or whatever that time is so here i'll find 15 then i'll compare it to the end time and i'll figure out what the difference between those two are if that is greater than half an hour then what i'll simply do is go 15 to the end time i think yeah and that looks like that works based on this 15 to the end time if the end time is greater than half an hour because at any point in there i could book a meeting but as an example a quick question sorry to cut you off imagine that here you had had a bunch of other uh availabilities basically here from like person two let's suppose if this was person two you had had something like you know 12 30 to i don't know to 14 or or rather let's say you you start over from the beginning let's say you had had you know seven to eight then you had had um you know nine to ten then you had had eleven to noon and so on and so forth how would you how would you know that this 15 to 16 here sort of yeah corresponds or can be kind of merged into this 13 to 16. okay so well the reason i'm saying that is because the 15 is in between these two numbers so in this instance when i have 11 12 well obviously 15 isn't in between those two numbers so i know i can't book anything in here because well 15 is is greater than the end time right um okay so if it's in between these two values which it and i think that's like a valid comparison um just to check you know if it's less than whatever um then if it's in between the two values which it is here i can look at the end time specifically and figure out the difference between my start time and this end time then what i can actually do i think is take the minimum of whatever the end time is here and whatever the end time end time is here and that is a valid block to book a meeting in and then i've eliminated now from this list this block here i've figured out that i can have a meeting based on this time from i guess what is it 15 to 16 so now i can move to my next block which is 17 to 8 30. okay so now that i'm not now does that does that like answer your question what i was saying okay okay great so now that i'm at 17 and 8 30 what i'll do is i'll figure out if 17 is in between any of these values so now i've actually i know that the last one was in between here so i can actually just start looking from here right because i know this is sorted so i don't even need to bother looking at the rest of the list but that's kind of an optimization technique that i will focus more on later so i'll look i'll start looking here i'll say 17 is not in between these two numbers but 17 is in between 18 and 17 is not in between 18 and 20. ah okay so that's where that falls apart if i'm just looking at the start time okay so 17 18. so if i just look at the start time that doesn't work i need to look at i think maybe the start time and the end time and see if they're in between those two values because if the end time is in between the two values which in this case is 1830 so tim let's take a quick step back because i think that you're you're on the right track here you have the you have the idea but now you're at this step of of having to kind of figure out where you can kind of merge these availabilities yeah right so exactly yeah if we take a step back the first thing that you did you even said that you would have this reusable function is you transformed for each person you transformed their calendar into a new calendar of blocks of time when the person is available right yes like these times here represent chunks of time where the person is available and you filtered these and you said remove any chunk of time that's less than our meeting duration correct exactly yes so basically what you did is you you almost answered the question but just for one calendar in the first step exactly right okay so now let's see if we could if we could simplify the approach that you're going with which i think could work but might be you might have a little bit more complication when you're trying to merge the things imagine you could have imagine you could have instead of at the beginning when you took a calendar like you took this calendar of unavailabilities right or meetings and you went you calculated the in betweens right you took the things in between and these were your availabilities and then you filtered them imagine you had in this calendar you had a mixture of both calendars so you basically you you you do the opposite of what you did instead of first finding the availabilities imagine you had first merged both of these meetings or both of these calendars rather you merged both of them when when you have the meetings you you kind of you mix them such that you have all of the blocks of time when one or both of the individuals aren't available right one or both are unavailable and then you do your step of calculating the inbetweens which at that point essentially gives you the answer does that make sense ah okay i know exactly what you're saying so all right so i'm going to take a pause there quickly so you can see clement gave me a pretty big hint there now a lot of people will say that's cheating or you know you shouldn't do that i can say from experience doing my coding interviews a lot of the time what i'm able to get the person to do and this isn't just me trying to be you know sneaky and strategic is i'm able to get them to give me a hint because i talk about everything that i'm thinking about so notice here that even though i'm kind of on the right track and the approach that i'm doing would potentially work it'd just be a really difficult implementation to do clemence heard my entire thought process he knows that i'm kind of on the right track and he figures that it's going to be easier if he simply tells me to merge the two calendars and then continue doing what i'm going to do so just kind of a piece of advice that when you're in these coding interviews talk about literally everything because even if you're completely wrong or you're like somewhat on the right track you know your interviewer may be nice they may be kind of rooting for you because they think you're going to be able to get it and they'll give you a hint like commented and like i said almost all my interviews that i did not necessarily that i needed a hint i probably could solve it without the hint but they gave me a hint and it made it a lot easier to continue going and they wanted to give the hint if that make any made any sense just because of the way that i was explaining anyways we'll jump back in here you'll see that i'm about to kind of go down the correct path but think to yourself right now there's one thing that i haven't done that i don't do this entire interview with the input that would make it a lot easier see if you can figure out what that is what you're saying so you're saying i'm i'm doing this two times and then trying to merge why don't i just make one big list do it once and then i don't need to even bother with this merge step which is obviously going to be very complicated based on what i've been talking about perhaps is that okay yeah perhaps so i'm thinking what i so if i can actually i want to write like a merged version of this so i need to merge them in sorted order so to do that i can do it's almost like you would do it in merge sort right where i'm going to just insert this one then i'll check in here if i can insert it if i can i'll insert it then we'll go to the next one then we'll insert so i know how to do that so i can insert this in sorted order so now if i have one that's in sorted order then i can calculate the in between times then i can filter and then whatever blocks of time i have in my remain like what in my filtered list are the times that they should be available i think that makes sense i really i just want to write these um yeah like as one if you want to write exactly write that merged thing that you just mentioned yeah because i mean i think that makes sense but i got to visualize this first to be able to figure it out right because okay so now it gets a little bit complicated just because this goes from 9 to 10 30 and then this is 10 to 11 30 right so that's to merge them is going to be a bit of a different process than what i had come up with before but we will sort them by start times uh okay so let's go 16 18. and by the way sorry how much time do i have you still have 25 minutes and don't worry about it for now just you're doing good okay yeah okay great um yeah i just really want to understand the problem before i start doing a massive code right um okay so what i think now so now that i have these together now i gotta come up with a better way to figure out which blocks of time are available because there will be some overlaps and some of the times whereas in the other ones there would have been overlaps that would have been easier so here we start at 9 we go to 10 30. so what i can do is actually look at so i'll say 10 30 is my end time my next start time is 10. so what i'll actually do is make this the next start time if this start time is less than the end time then that way i know i'll have the availability from 10 30 uh oh actually 10 so yeah so if i could change so say i could change this to be 10 30 then that makes a little bit easier because then now i know from 11 30 to 12 is fine and then okay so this is greater than this so if i could change this to be 13 this should be giving me valid i'm just going to change that to make sure it makes sense and here if here tim i would almost argue do you even need to do that or can you even just some no i don't i delete this i don't need to and and just merge the two times together that's exactly that would probably make more sense so essentially if if i could go back to what i had so if i have this if this time is greater than this time then merge these two entries so i think that'll be my first step in the process so then we now have this new list so now this is my last end time this is my newest start time so now i have from here to here since this entry is less than this i'll check if this block of time is the amount of allotted time we need and if it is i can add that into this output next we go from 12 to 13 and then since these times are the same i can merge them so i can go like that and now what i can do is now look since these times are the same i can merge them again okay so let's merge them like that and now okay so this is less than this so is it more than half an hour it is okay so let's add 15 and 16 to our output okay now let's look at 18 16. oh this is greater than this one so what can i do i can merge them okay and i get 18 17 and now what i need to do actually sorry like this uh 18 so that okay so this is where it's a little bit confusing for me it's because these are the same start times and then this end time is actually greater than this end time right so since this is greater than this i need to check if this is greater than the end time two because if it's greater than which one anytime then really then i would take the max obviously would you take the max or the min well if i'm available from if i'm not a oh this is sorry this is a list of my no this is a list of my nonavailable times yeah this is when this is when one of the two people is booked yeah so this is when they're booked so if i'm booked from 16 to 18 well then this doesn't this isn't really even relevant because i'm booked from 16 to 18 which means i'd be booked from 16 to 17 anyway so i would take the max yup i would definitely take the max okay i'm sorry you just confused me a little bit with that that's okay i i totally didn't just get confused myself okay all right you're good okay great yeah so just taking a sip of water now what i will do is look at the bounds that i have so what i can do with the bounds is simply take the min of whatever these bounds are so in this case i'll take oh sorry i need to take the max on the yeah will it be the max on the left side the min on the right side i think that makes sense um yeah so max on left side min on right side so in this case this would be the bounds i want to look at 10 to 8 30 and then i could just see um then i need to look at the first entry in my list and i will i actually need to merge that again so these bounds now are getting me a little bit uh tricky as well so if i have like do and i do like 10 like that i would just i think what i can actually do is just compare 10 to whatever this first start time is yep and then i can just change this almost to be just 10 but if for example this said 930 then i would just need to scrap this whole thing so actually what i think i could do is probably just compare all these blocks of times to whatever the bounds that i have and if they don't fall within the bounds i'll modify them or remove them and for now for now let's let's actually just keep the bounds even aside because i think i understand where you're getting at but let's even yeah forget about the bounce for a second let's not complicate ourselves yeah okay so i think maybe now is probably actually a decent time to start writing something all right so i'll take a break here quickly so you can see that now we're probably what like 25 26 minutes in something like that and i'm just about to start coding so usually i would be a little bit nervous in this situation because i don't want to take half the time to digest the problem if that's necessary obviously i'm going to do that like i did here as you guys can tell you know i was confusing myself you know like there's a lot of different input and time stuff going on on the screen here but i think at this point i kind of have a clear idea of what i want to do obviously clement has helped a little bit but again the reason he's able to help me is because i'm constantly talking out loud and even if i'm thinking something that's incorrect i'm still saying it just to kind of see how he reacts to it and see if because he knows the answer to the problem if i am on the right track so there is a little bit of kind of confirming with your interviewer that they understand where your head's at and they're not going to let you kind of jump into the code and do something horribly wrong so at least you have the opportunity to kind of get checked a little bit and say okay am i on the right path yes i am okay let's keep going so anyways i'll jump back in here but now i'm about to start coding and again think about that thing that i should have done to the input that i haven't done and that i'm not going to end up doing in this interview that would make things a lot easier for me when it comes to comparing these different values which is like the main step of all of the processes i've talked about to start writing something so i'll run through this one more time just to make sure that i'm refreshed what i'm going to do is insert insorted order into a large list both the availability or the i guess the busy times of person one and of person two yep i'm going to ignore these bounds for now because those we'll talk about later i guess um and then what i'm going to do is do those comparisons that i talked about so i'm going to compare you know not so i'm going to compare the end time to this end time and i'm going to say okay well if this is greater than this i'll merge them together but if this end time in the other list is less than the end time here i can actually just remove this entry altogether um because that will just give me because i'll be busy during that time yep then i'll i'll do the same thing for the next one so i'll look at 12 to 13. oh this will be a big list so we'll do that all together and then when i get to the end of that what i can do is literally just compare what i talked about for the end time to the next start time if there's enough time there i'll add that to the output yep same thing here right if there's enough time here i'll add that to output okay so let's start doing this um okay and again the capitals here are going to be weird don't worry google docs so define don't worry about the capitals yeah don't worry about the the auto caps and all that define is there a name for this calendar i'll just call it a veil for now i don't know that's fine okay calendar avail um i'll just i'll ignore the uh the bounds for now in my input we can change them later so i'll say person one schedule uh person2 schedule uh and then what else do i need i need time so we'll do that and i time is i'm going to write this in python so time is actually fine as a keyword okay so now what i need to do is i need to insert these into sort orders so that means i need to make a list so i'm going to say and by the way feel free to feel free to simplify the variables if it's too annoying to type out up to you okay there we go we'll do that so and yeah just case sense okay so book time so quick side note whenever i make variables just kind of a tip i've heard is to make them really readable not only does that make it easier for myself when i go back i can see what i'm doing with all these variables but clement can also understand what i'm trying to do with those so typically it's good to have variable names that are pretty descriptive but obviously in this situation i'm kind of running low in time i probably only have about 20 minutes left before this interview is actually going to be done so obviously in the name of time it probably does make sense to simplify these a little bit but we'll see how stubborn we are with that and if i end up actually you know simplifying all these variable names just for case sense okay so book times so now i need to get into the issue of how am i going to compare these string numbers so i almost want to make a function just to compare these to tell me um i'm going to do it like i would actually do it in java and get like the 1 negative 1 0 based on if it's greater than or less than for comparison so i'm going to say define compare times i'm going to say time 1 time 2. now we need to get our hours so we need to get our minutes so i'm going to say hour 1 equals and in this case it's going to be time one dot splits coin and i think i can actually do hour one minute one is going to be time one dot split that should actually decompose that because i know and i'm guaranteed that i'm gonna have these zero zeros and will i have uh yeah so that should be fine because i can split up the colon yeah and you can assume assume that these strings are gonna be in such a way that your math here is correct then you don't need to do fancy edge case handling or anything okay good because that was gonna make it a lot more complicated for not even really part of the problem okay so now we'll have our one minute one so we can start by saying if and actually i could literally just convert these to minutes and then do the comparison so i could just do hour 1 times 60 plus okay so let's actually do that uh it's going to be powerful all right so here i've given away what i should have just done to the entire input so you can see i'm writing this kind of complicated function that's going to compare you know string times and return a one if it's greater zero if they're the same and negative one if they're different when in reality rather than having to even write this compare times function what i could have done is just converted the entire input into minutes and then that way it would have been way easier for me to do everything you're about to see but of course i didn't consider that when i was in this problem i definitely should have but you'll see that if it was in minutes that immediately makes this problem so much easier and that's something that i just didn't end up doing uh it's gonna be hour one minute one yeah that's fine okay so we're gonna just say time one i'm going to change that to my initial variable is going to be int hour 1 multiplied by 60 plus minute 1 and then time 2 equals int and that should be actually an int as well minute 1 and we'll say int hour 2 time 60 plus int minute 2 and do a quick check here i think that should hopefully just give me kind of the amount of time in minutes because 18 times 60 since it's 24 hour time that should be right plus int minute yeah i think that's right and then what what i'm going to say is if time one is greater than time two return one one will stand for greater than and then we'll say l if time 1 is less than time 2 return this would be negative 1 which will be less than and then else return 0 which will mean that it's the same so i'm just kind of stealing that from the compareto method in java that they usually use so we'll just say this would be same okay and now what i need is to create this kind of schedule thing so how do i insert these times in sorted order well i'm going to have to use those comparisons okay so we'll start by just comparing the start times i guess and just inserting essentially what the earliest start times it are into our list so i'm just going to say 4 oh i need actually i'm going to say p1 which is going to stand for pointer 1 and p2 would be 0 0. i'm going to say while p1 is less than the length of p1 and i'm actually just going to make it p1s i know this is like not the best way to name them but it's just going to save me a bit of time because i have no problem running a bit low while p1 time is less than that or p2 is less than the line of p2s we're going to say if in this case p1s at pointer one start time which will be zero yep so we have to say if compare times p1s and then p2 s at pointer to zero so that should actually compare our time so if that equals equals one which is actually we're going to say negative one this will mean that we are less than so p1 less than p2 yep so then we'll insert that into our book time so we'll say booked underscore times dot append and then this should be p p one s p one i hate reading this but that's okay uh and then we'll say p1 plus equals one so p1 plus equals one so that should increment our pointers um so p1 i think yeah i think that actually will work and we'll say otherwise then we can just insert the other one soon as it booked the square times dot append and if they're the same we're just going to default to insert the other one i guess just fine so we'll say p times dot append p2s p2 so quick note here that it probably would have been easier if i simply put like p1 time p2 time as variables notice here that i have like p1sp1 at index 0 and then i'm writing like all of these indexes multiple times so you know usually it's better to throw those into a variable it just makes it cleaner and that's typically better you know coding practice anyways we'll continue and then p2 plus equals one okay so after this is done assuming i didn't make any mistakes then this should actually give me that sorted list now i'm kind of doing this the way that you do it like in merge sort where you just compare like you know this one to this one and then you know our next pointers up at this one if we insert this first one and then i compare it this one to this one then i insert this then my next pointer's here then i compare it to this one i insert that my next pointer's here compare this one to this one answer that so i think you're following me with that right that makes sense yep so did you guys catch the bug you can pause it and try to find it i can tell you right now that if you have a look at this or that will probably give it away to you essentially what's going to happen here is i need to actually throw in a clause in this while statement that says you know if p1 reaches the maximum length then just add all the values from p2 if p2 reaches the maximum length like the pointer then i add all the values from p1 i not sure if i do that afterwards we'll actually see if that happens but if i put an and instead of the or then that means that i will end up adding all of them assuming assuming i have that kind of like clause in the while statement or that condition in the wall statement anyways i hope that makes sense but see if you can catch that bug okay so now that we have that now it's time to do that kind of parsing through with the which is going to be a little bit more complicated like we talked about before so i'm going to say 4 i'll just do 4i in range the lan of booked underscore times okay i thought you still have 12 minutes so you're good on time okay great so for iron range the line of book times and let's see but while we're up here we're going to say i'm just going to call this a veil you know what i feel like i'm going to spell that wrong so let's just call this output okay was that so we can store our stuff in there for iron range the lan of booked times now i want to go through my thing one more time so essentially what i'm going to do is compare the ending time of entry one uh to the start time of entry two if this time is greater than this then we can mush them together but if this time here is um what do you call if this time here is actually less than the other time then i can straight up just remove this entire entry okay i think that makes sense uh okay so i'm still debating whether or not that's perfect but i think that's okay so for eyeliner book time since we're going to compare to the one above but i could actually technically be removing stuff so i almost just want to say do a while loop because if i'm going to be removing stuff from the loop that from the list that i'm looping in that's going to cause issues so i almost want to use a while loop instead and then if i remove something just leave the pointer or whatever the index it was out before um yes let's do that i'm going to say i do you need to do you need to mutate this booked times list or can you mutate maybe the output list i mean up to you whatever you feel more comfortable writing yeah um i don't think i need to mute like i definitely don't need to mutate the book times less but kind of the way i'm thinking about it right now i don't have like a better idea okay for how to not mutate it although i think actually like i can probably come up with the output in this for in one loop while i'm looping through i don't think i actually need to even change this or do another loop which is kind of what i was planning to do but i might confuse myself a bit while i'm coding that um in the interest of time i would probably go with well there are two arguments here but i would probably go with what's least confusing to you yeah okay so let's say i equals zero while i is less than the lan of and this line will update every time so that should be good elen of booked underscore times i'm going to say now i need to compare the end time of entry whatever to the next entry which actually means that this should be a negative one here okay so now we're gonna say start one or actually and i'll just say end one equals in this case booked underscore times i one and then we'll say start two equals booked underscore times i zero now what we need to do is say if and one is greater than now i need to use my compare times method yeah if compare times and one start two i gotta remember what i wanted to do there so if the end here is greater than the start here i need to modify the list otherwise i think i can actually just look at the distance between this and the start time and figure out what that should be okay so if this time is 1 so that essentially means if the end of my other one is greater than the start of my other one now what i want to do is figure out what the end of the other one was so i'm going to say n2 equals in this case booked underscore times this should be and this needs to be i plus one on that i plus one and this needs to be one now i want to figure out what i should do here um actually i don't even think i think i could just like skip to the next entry if this if it's the case that the other end is greater yeah so if i'm looking here and i do let's find an example here like i'm kind of mad that i've got rid of my example if i did like 15 what is it 17 yeah so if this is greater than this yeah but this is greater than this one then what i need to do is put 18 here but if this is say 16 30 then what i can do is literally just skip over this entry i think because there will be no availability in that time so i should go i plus two maybe um i think that works if i just skip past that i plus equals two rather than i plus equals one because if the end time is greater so if and if compare times in this case n2 uh in this game just go end one equals equals one so that should mean that the end time of the other one is greater than this end time then i could skip over it yep otherwise so if the compare times actually so if it is isn't the case that i have that edge case so let's say we have the example here 11 30 12 30 because that'll be what i get into the else statement then what i can do is calculate the difference in time if that is greater than whatever that value is that passed me i can just send that into the output list as that should be an answer because i should be able to book a time between that end time and between the next start time i think that's logical so otherwise if so now i actually need to figure out the difference in times i'm just going gonna write like a pseudo function that says like difference in time and like i'll i can code it later five times i'll say if diff in time and we'll go between end one start two is greater than or equal to what did i call that variable but here here tim by by doing this i i get that you're trying to you're kind of like trying to skip ahead here and basically get an answer right off the bat but in the case above here you won't have done this so will you not basically be like by doing by trying to get the answer immediately in this else will you not be sometimes skipping getting the answer when you're in this situation but the i think the the thing here is if i'm in oh yeah because you're right because i'm going to skip over two so maybe i just won't even bother doing this and i'll just do the yeah so i do actually need to mutate the list then i guess from what i was doing because i was trying to go back to the other approach but i guess i'll just mute the list so rather than skipping over one what i'll do is just remove the next entry in this instance and then merge the times otherwise i'll do something else so we'll say else then what i need to do is literally say in this case i can just remove that next entry so i could say booked underscore times dot remove um actually dot pop uh this is gonna be i plus one because i don't need that entry otherwise then i'll merge the start time and in the end time so i can actually just say booked underscore times i one equals and two uh yes yes okay so now i've done this let's just i mean assuming this is right i've generated a list and now what i can do is literally just do the blocks in between and then add them to the output assuming that's right again not 100 but i think it's okay so now we'll just loop through again uh oh and i need to make sure i increment i otherwise that's not going to be very good is it i plus equals 1. i think that's fine because if i remove the entry then i shouldn't increment i but if i don't remove the entry then i should and i should i'm sorry here at tim yeah sorry yeah can you hear me are you let me just pause the timer one second are you still typing in the dock uh yeah okay just okay i'm restarting the timer because it had just freaked out on my end but now i see it all right okay yeah yeah no worries uh yeah i just got a reconnecting but worse like i have all the recording on my okay perfect so it's fine yep okay uh so actually what i've just done sorry in case you missed that is i did i minus one i plus one because now what i'm going to do is if i pop the entry i need to stay on whatever that current entry is to compare it to the next one because i've just removed it um but otherwise i'll increment my counter i plus one so that i can move to the next one then start doing that um since this is getting long i'm going to go down onto the next page okay and now we'll do this next while loop where i'm going to do the comparison thing that i just wanted to pop in here quickly and say i hope you guys can appreciate how difficult it is to code in google docs with like the auto indentation tab issues with like the auto complete capitals that was really throwing me off but anyways just wanted to note that that this is a lot more difficult than say writing on the whiteboard i've done both and writing on a whiteboard is way easier than this there's something that i talked about before like the difference in between so i'll say wow and i guess we're going to go i equals 0 again or i could probably just do a for loop to be honest i don't think i need to do a while say in range booked underscore times um what are you doing in this final four loop this final for loop what i'm gonna do is figure out uh the output so essentially the difference between the end time and the start time of the next entry and then if that time is enough i will simply add that block so the start time and end time of the other entry to the output list and then that should be good so i need to do 1 there because uh when i compare to the last element i have i plus one i don't have an index error okay i'm going to say if in this case diff between and we're just going to assume that i've written this function but for now i've not uh is equals one so actually sorry is greater than or equal to not 30 time so if the difference between this is going to be let's go just to make this a little bit cleaner uh end one is going to be equal to booked underscore times i one yep and start two is gonna be equal to booked underscore time i plus one zero yep so in that instance we can say if the difference between start end one start two and we'll assume this gives us an absolute value difference that that's not gonna be negative um then what we'll say is add that block otherwise don't even bother okay so then we'll say output dot append and in this case we should just do end one start one start two and then return output now i'm like almost 100 sure that this probably doesn't work just because i think i've confused myself a lot throughout like what i was doing here but the logic for my solution i think makes sense but i don't think this code will be a hundred percent just i feel like i should say that do you do you mind running me through the uh complexity analysis uh yeah oh sure the complex analysis okay so in this instance we're going to run this loop will run i guess it's going to be o n plus m where we're going to have nbp 1s and mbps p2s yep then for this time this booked list will be the same thing so this will be o n plus m um i minus one skip in it alright so i will quickly pause here before i let myself continue with the complexity analysis here you can see i've just gone over time and clearly this problem was you know more difficult than i've been used to i spent a lot of time at the beginning trying to understand exactly what i needed to do and of course you know that left me with just the amount of time to kind of scrape by with the solution that as i've noted myself probably won't fully be functioning but the general kind of idea behind it is somewhat correct anyways i'll let myself continue with the complexity analysis but clement is nice enough to give me an extra i think we have like five minutes or something to go through the complexity analysis i'm not sure if i make a fix or not so we'll see um if that happens but remember there is one big bug in this program that happened at the very beginning that i think i already went through one skipping it no that's fine so this will be o n plus m and then for this last one this will be om plus m again as max so this should be an o n plus m complex unless i'm missing something uh oh the compare times that this will run constant time my difference between over and constant time i don't think i've done any interior loops inside book times that append that append actually the pop here sorry where's my pop because i know that pop will not run in constant time um this pop here pretty sure will run in on so i could actually have o n squared m because this pop i'm pretty sure doesn't run in constant time i don't know but since it's a list and it has to potentially move something it would have to potentially shift every element in the list over depending on where i pop from yeah that could be n this my average case i think is still going to be m plus m but uh worst case would be n square plus m so that would make the overall time complex the n squared plus m including this pop but pop usually is pretty fast operation implemented in python so that should give me average time and plus m i think that's right uh space complexity and there's another pop in here i'm pretty certain that pop runs in o n of course i could go through this in more detail and discuss when i'm popping and how many elements i would potentially be shifting but the reason i'm classifying that as big o of n is because technically if i pop the first element of a list the entire rest of the list i would need to shift into that position so that would run in o and time if you understand time complexity you probably understand what i'm getting at but of course i wanted to make that clear in the interview bass complexity i'm going to have n plus m and then output will be i guess yeah so i guess that's constant so n plus m okay so yeah i think we just ran out of time sometimes you know interviewers will go a little bit over time so maybe maybe i would ask you you know very quickly how confident you feel about your code but you sort of told me yeah um yeah if you want let's spend actually like two more minutes going over the code and then we will get into the debrief and sort of end the interview but out of curiosity if you very briefly walk through the code do you see any place where you think you have a bug for sure okay so my first main piece of logic i'm fairly confident in although i would like to debug it a bit to obviously make sure this is just going to essentially build that sorted list of all the times that both people are booked so the way this logic works is essentially the same way that merge sort works so what i'm going to do is compare the entry in my first list at pointer one to the entry in my second list at pointer two and then based on whatever that is so if my pointer one in my first list is less than the pointer point or two in the next list i'll pin that in otherwise i'll pin the other one so this one should technically build that sorted list since i have these two pointers i won't add the same element twice because what i'll end up doing is like once i get to the end of list one then this will always be like greater than the other one so it'll always add until we get to pointer two and then this i think like this condition works fine yeah i think i understand what you mean i guess here here i think you would probably have to add something here compare times to handle that because like what you just said about this once you reach the end of one of the lists this will always be bigger or something yeah not really because you will eventually one of the lists will finish so to speak before the other one and your condition will still run so you'll be accessing values past the list uh no i actually i won't because i won't increment this pointer unless this specific condition is true so what'll end up happening is if i insert this because it's oh if i insert that because it's less than okay you're actually sorry you are actually are correct yeah i'd have to do something like i don't know why i thought that was gonna work if pointer one is you know greater than or i guess is equal to the line of p1s minus one then i would just add pointer two and then same thing with the other way around yeah something like that you know i'm saying that okay exactly yeah assuming that okay so that's like that's a good bug to catch i was kind of speeding through this one okay so now this piece of logic here is essentially trying to kind of mutate that list to find the blocks that we can use for the next part of logic which i'll talk about so what this one is going to do is compare the start time and the end time of the blocks that are beside each other because we know that they're sorted so what that that will allow me to do is essentially i'm going to create block like the largest blocks of time that i can that are beside each other if that makes sense so like say i have nine to like 12 30 and this is 12 to 7 and that would be 9 to 17 o'clock right that's what that's doing or at least i'm trying to do in this block of code so i'm comparing the times if the end time is greater than the start time of the other one then what i'll do is compare the end times yep if the end time of the other one so the one further right in the list is less than the end time so actually i think that needs to be yeah because here you compared you compared n two to n one so yeah yeah i realized i think i did that backwards yeah so if n2 is less than n one then you are popping the value the next values you are d okay that makes sense you're decrementing i and then you still increment it after to basically like keep moving forward exactly exactly yeah and then here this is just this is just mutating that list so it's moving the n2 over okay so yeah so that negative one was needed to there that's what happens when i guess you speed through okay that last part i think is is fine uh let's jump into the debrief uh why don't you start by telling me like how you feel right now yeah all right so we're at the debrief section i will let myself continue here it's funny i'm interrupting myself but as you can see there you know we kind of went through it at the end usually what i would do if i had adequate time is before i you know say i feel confident i feel like the solution is good i would do what i just did i would walk through the entire code i would try you know a test example on it and and make sure that it's actually functioning properly obviously in this situation i didn't have enough time where i could actually run through a sample input and make sure my code would perform but that's usually what i always do whenever i finish these coding questions again in this situation i was kind of running low on time so it was a big rush at the end and i can kind of credit some of these you know silly mistakes to the fact that i was rushing anyways i guess i will let myself tell you guys how i felt you feel right now yeah for sure i mean obviously guys like you can probably tell based on kind of my mood and what we're going through i don't feel great about this solution this problem was challenging for me to kind of comprehend just because even like this string input was like there was a lot of stuff that was just like a lot of details to deal with at once like i kind of confused myself a little bit as i went through the different paths i'm happy i came up with a logical solution that makes sense i think the time complexity is actually pretty decent i didn't do anything too crazy with i mean i have this n squared but that's just because of that pop but i didn't do anything too crazy with the complexity so that's okay i felt i explained my logic pretty well i asked decent clarifying questions but like just you gave me a little bit of hints for the solution i think maybe if i had more time or if i'd done a little bit more prep on something maybe this diff more this difficult i would have been able to come up with a little bit faster and a little bit cleaner you kind of get my like vibe from that yeah yeah so so listen i'll give you my input i think you did really well i think your your your assessment is probably how i would feel if i were you like you're kind of like oh i feel like i sort of got it but at the same time it's like not you know it's not picture perfect but yeah what you should take away from this because again from my point of view you actually did very well i would have to you know take a little bit of time to grade you so to speak following the actual criteria that we're given but you would probably get something along the lines of a higher or a strong higher decision here at least from me okay based on what i'm seeing the main reason is this first of all this is a very difficult question this is actually a question that we have on our go expert i know for a fact that you didn't do it based on the questions yeah you did do but so this is a very hard question on algoexpert the reason that it's very hard is exactly what you said first of all there's a lot of information there are a lot of inputs there's a lot of different like types of inputs you saw that they're strings they're not numbers they're military time you have these daily bounds which by the way the daily bounds you can simplify the problem by just creating artificial meetings at the beginning and end of each person's calendar using the daily balance if that makes sense that's kind of what i figured yeah that's what i figured out that's kind of what i was trying to figure out at the beginning and then i was running low on time and then that was just another piece so we just skipped by but yeah i did kind of think of that exactly but but but even that like it's an additional piece of just complicatedness or complexity and then the thing that's difficult about this problem is not so much the algorithm because the algorithm or the logic is is fairly intuitive and i think you you came up with a version at the very beginning that i think would have worked fine i just pushed you in a slightly different direction that i think is a little bit simpler but you were doing just the the opposite order of operations but then the coding the coding is difficult yes transcribing this into code is difficult and i think you did a very good job like you pointed out the part of the code that's probably the the most shaky is this middle part here with the popping yeah and the the fact that you're kind of overwriting this this thing and there's a way to do this without the popping that we don't need to get into here but i think that you you explained your logic soundly and you managed to transcribe it into something that you know seems like it's getting you know it's getting close to working probably there are edge cases here that aren't handled but it's getting close to working you also did a good job of using helper functions and that kind of thing to your advantage like compare times like this is the kind of thing where a must to do something along these lines is the the the diff between here absolute must you know otherwise like you're going to get a gross algorithm you did have a little bug in the in the merging but that was you you caught it near the end and again it's like this is the kind of problem where it would be a lot to ask to expect a candidate to code this entire solution perfectly in just 45 minutes all the while solving it so this is like this is more than what i would expect especially if you're if you're going for an intern position where we don't necessarily you know have the same bar as let's say a senior position fulltime senior position so yeah overall i think you you did a good job okay well i mean that's okay that's great feedback definitely makes me feel a little bit better because yeah i was kind of thinking about all right so i'm gonna cut myself off there i know what happens at the end of this interview it's not too interesting but there you go that's clement's feedback for me i mean do you guys agree do you disagree he's done a bunch of coding interviews with you know like literally hundreds of people at google so i trust his word and this was really great practice for me going into like my microsoft interview and my shopify interview because i did not get questions that were this difficult so like clement said this is a difficult question yes some of you will probably look at this and say oh you know i could answer that this way but i can guarantee you it is a lot more difficult when you're on a google docs you can't see the guy's face because we were on like just a call right have my earbuds in and you're just going and trying to do it in 45 minutes so anyways that has kind of been the mock coding interview looking back at this now i will give kind of a summary of my thoughts i think that generally i did a decent job i stuck with what i always try to do which is explain myself as well as possible and you saw the benefits that i gained from that clement gave me a few hints you know i was able to catch some of the bugs i was able to figure out the flaw in my own thinking simply because i was kind of speaking out loud and i always find it's easier to have someone to kind of rebound ideas off of because then you can very quickly determine based on you know even just little things that they say whether or not you're on the right track or not in terms of things for improvement i think definitely the coding was a little bit sloppy uh looking at it now this wouldn't be the standard that i would hold myself to i've just been coding longer coding more in the industry so i would have liked to see you know some better variables just things a little bit more split up easier to read i would have liked if i'd converted the entire input into numbers first or in two minutes sorry so that i wouldn't have had to use say the compare times thing and deal with strings and all of that but overall decent interview and you know this is really good for me looking back to see kind of how far i've come and how i might approach this problem differently now so anyways i hope you guys enjoyed if you have any questions any comments about this please do leave that down below the original video if you're looking for no cuts or for some reason you want to see it is on clement's channel which i will link down below with that being said if you enjoyed make sure you leave a like subscribe to the channel and of course i will see you guys again in another youtube video you
