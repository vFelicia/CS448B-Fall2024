With timestamps:

00:00 - hey guys and welcome back to another
00:02 - weekly programming problem now in
00:04 - today's video what we're gonna be doing
00:06 - is implementing what's known as a tree
00:07 - data structure and we're gonna be doing
00:09 - this to simulate a dictionary in Python
00:12 - except we're gonna be programming all of
00:14 - the different methods and things that we
00:16 - need so we're essentially gonna be like
00:17 - writing our own dictionary in Python
00:21 - using what's known as a tree data
00:22 - structure now I'm gonna talk exactly
00:24 - about what a tree data structure is and
00:26 - the main like problem solving aspect of
00:28 - this video is it involves a little bit
00:31 - of recursion and kind of thinking to
00:33 - figure out how we would actually go
00:35 - about implementing what I'm going to
00:36 - show you in code now I've kind of
00:38 - designed like the main layout of the
00:40 - class in terms of the different methods
00:43 - that we're gonna need and this node
00:45 - class which we'll talk about after but
00:46 - essentially if you think about a
00:47 - dictionary in Python this key value
00:51 - pairs so you have for example the key
00:53 - maybe like a correspond to a value of
00:56 - eight you have the keys Ed corresponds
00:58 - to something so we're gonna be
01:00 - simulating bats in a tree data structure
01:03 - today so let's talk about what a a tree
01:07 - data structure is quickly so essentially
01:10 - a tree data structure and in this case
01:12 - we're gonna be setting ours up as a
01:13 - binary tree is something that kind of
01:16 - cascades down so it starts with a root
01:19 - so we'll call this our for root and then
01:22 - there's branches that go off the roots
01:24 - of two branches for a binary tree and
01:26 - there's some nodes okay so all of these
01:29 - things are called nodes that I put
01:31 - little lines on and each node can have
01:34 - at most two children and one parent okay
01:39 - so this would be known as the parent to
01:41 - these two child nodes here okay so on
01:45 - each child node again we can have up to
01:47 - two branches so we can branch off again
01:50 - into a few other nodes here and we can
01:54 - just keep going and keep going and keep
01:56 - going into infinity now the way that a
02:00 - binary tree works in terms of computing
02:02 - at least when we're using numbers is
02:05 - something like this so the way that I'm
02:08 - gonna set up my binary tree is the root
02:10 - is going to be the first element that's
02:12 - added
02:13 - to our tree so for example if we have
02:15 - like the element a it goes there now the
02:18 - way that the child nodes work is that
02:20 - the child node to the left of any given
02:23 - node is always going to be smaller then
02:26 - what he called that node itself so for
02:28 - example it's hard to do with letters
02:30 - maybe let's just use numbers actually if
02:32 - I do like if I put 3 here only numbers
02:35 - that are less than 3 can go on the left
02:37 - side here of this node so if I want to
02:40 - add 2 I can put it here but if I want to
02:42 - add the number 4 it has to go to the
02:44 - right of this node so the left and right
02:47 - side of each what do you call it like
02:50 - branch coming off the note actually
02:51 - matter and it's what's going to allow us
02:53 - to do some operations very quickly on
02:55 - our data and you'll see what I mean by
02:57 - that in a second so for example we have
02:59 - 3 we have 4 if we want to add now 5 into
03:02 - this tree data structure well we have to
03:05 - follow the same rule as before where we
03:07 - can't actually put anything that is
03:09 - greater than 3 to the left of it has to
03:12 - go to the right side so what we do is
03:14 - you say okay well we can't go here in
03:16 - this empty node so we go to the right
03:18 - and we check if a node exists there this
03:20 - node exists we're not going to move it
03:22 - but what we're gonna do is we're now
03:24 - going to branch off from this node and
03:26 - add our next number and we want to add 5
03:29 - in this case so we have to follow the
03:31 - rule and we say that what we can't add 4
03:33 - on the left side because 5 is greater
03:36 - than 4 so we have to add 5 on the right
03:38 - side so now we've added 3 4 5 and we
03:41 - have to blank nodes like these don't
03:43 - actually I'm just putting them here so
03:44 - you can see that they won't actually be
03:46 - in our in our program yet until we add
03:49 - another number but now let's say we add
03:51 - the number I probably should use some
03:54 - different numbers so I could add
03:55 - something here let's say we add the
03:56 - number 2 if I add the number 2 what I
03:59 - would do now is two would go here
04:01 - because well obviously 2 is less than 3
04:03 - so it goes on the left side and then we
04:05 - can add it there now let's say I want to
04:07 - add the number 2.5 well 2.5 is less than
04:11 - 3 so we go to the left where now we're
04:13 - at this node so we check 2.5 we say is
04:16 - that less than 2 no it's not it's
04:17 - greater than there so now we add another
04:20 - node and we put 2.5 here and this is the
04:23 - tree data structure that I want to
04:24 - simulate inside
04:26 - my Python code and the reason I want to
04:28 - do this is because if I'm looking for a
04:30 - certain node so I'm looking for for I
04:32 - can find it much faster than if I just
04:34 - had everything set up in a straight line
04:36 - so for example if I had like two three
04:39 - four five like this okay and I want to
04:42 - find five I have to look at two three
04:44 - and four before I can get there right
04:46 - but now if I have my things set up in a
04:50 - tree data structure what I can do is I
04:52 - start at the root which is three so I'm
04:54 - go to three and then I hit four and then
04:56 - I'm at five so I've now skipped one
04:58 - operation obviously this is a bad
05:00 - example to show you how fast it runs
05:02 - there's only four nodes but when you're
05:03 - dealing with millions of nodes if you
05:05 - know to move to the right or left based
05:07 - on the value because everything's kind
05:09 - of sorted in here right then you can
05:11 - find values very quickly you can modify
05:13 - them quickly and you can add things
05:15 - quickly rather than having to look
05:17 - through each single node in your list
05:20 - which is just not efficient okay so this
05:23 - is what we need to simulate so there's a
05:24 - few things we need to think about we
05:26 - have to think about how we're gonna add
05:28 - something into here so we have to follow
05:29 - that procedure if we want to add a new
05:31 - node we have to think about how we would
05:33 - find a node and get like the value
05:35 - associated with that node we have to
05:37 - think about how we can figure out how
05:39 - many different nodes are in our tree and
05:41 - how we could possibly get all of them
05:43 - and look through the entire thing right
05:44 - so what if we want to print all the
05:46 - different nodes that we have in here
05:47 - that's another problem that we have to
05:49 - figure out how to do so let's now go
05:52 - into implementing this and start writing
05:54 - some code so I'll try to explain it as
05:57 - we go through but I mean it's not super
06:00 - complex it just requires a little bit of
06:01 - thinking so the first thing that we're
06:04 - gonna do is contains now contains is
06:08 - essentially is a certain key inside of
06:11 - our tree so remember we're gonna do this
06:13 - as a dictionary which means we're gonna
06:15 - store node objects and each node object
06:17 - has a value of right which is gonna be
06:19 - the right child left which is gonna be
06:22 - the left child and then a key and a
06:24 - value and the key will be what we store
06:26 - in the tree and then the value will be
06:30 - mapped by each key right and just the
06:31 - way a dictionary works so given a key we
06:35 - need to figure out if it's inside of our
06:37 - tree data structure so to do that
06:39 - we have to look through our data
06:42 - structure and traverse it and find that
06:43 - key now what makes this easier to do now
06:46 - is that we know that everything in our
06:48 - data structures in that specific order
06:50 - we know that everything to the right of
06:53 - a certain node has to be larger than it
06:54 - so we can use that fact to find our key
06:57 - way faster than just looking through
06:59 - every single what do you call a key or
07:01 - node inside our tree so to do this I'm
07:04 - just going to set up a few variables I'm
07:06 - going to say found equals false and
07:08 - current equals self got root now
07:12 - whenever we set up a tree data structure
07:13 - we have to start with what's known as a
07:15 - root and that root is the only thing in
07:19 - our tree that doesn't have something
07:21 - above it so like the root of the tree
07:23 - essentially right what's holding it
07:25 - together is that root so we start by
07:27 - defining a root that's equal to none
07:29 - because we don't have anything in our
07:31 - tree when so I'm just using a class
07:32 - obviously to do this so what we're gonna
07:35 - say is current is equal to sell fruit
07:37 - and we're gonna change this variable
07:39 - current and keep moving down a certain
07:41 - path on our tree until we find the value
07:44 - we're looking for or until we don't find
07:45 - the value we're looking for so now what
07:48 - I'm gonna say is I'm going to say Wow
07:50 - current does not equal none and three
07:54 - co-found equals equals false
07:57 - so essentially until we reach a point
08:00 - where we don't have any left or right
08:02 - branch or until we have when we found
08:06 - element we're looking for keep looking
08:08 - through the tree because we're gonna
08:09 - look through the tree in here and you
08:10 - guys will see how this works in a second
08:12 - so what we're gonna start by doing is
08:13 - gonna say if current dot key because
08:16 - current is gonna be equal to one of
08:18 - these node objects and you guys I'll see
08:20 - how that works in a second if current
08:22 - Aki is equal equal to key then what
08:25 - we're gonna do is simply say found
08:26 - equals true because we don't actually
08:29 - care about the value associated with the
08:31 - key we just care if it exists so we'll
08:33 - simply now we can even skip down to the
08:35 - bottom of our method here and just
08:37 - return found so if we make it out of
08:40 - this loop and found is equal to true
08:42 - then we will return that right all right
08:45 - so our next thing now is if the current
08:47 - key that we're looking at so right now
08:49 - in this case just the root isn't equal
08:51 - to the key that we have are though we're
08:53 - checking
08:53 - we have to see where to look for this
08:55 - key next so what we're gonna do is we're
08:58 - gonna check the current key that we're
08:59 - looking at so in this case the root and
09:01 - determine whether we want to move left
09:03 - or whether we want to move right and I
09:04 - know I just did that reverse for you
09:06 - guys but for me I guess left and then
09:08 - right okay so what we do now is we're
09:11 - gonna check if the current key will
09:14 - actually we'll check if our key is less
09:17 - than current key okay and this will work
09:21 - all the less than operator just assuming
09:23 - that the keys are gonna be the same type
09:25 - or we're gonna assume that each key that
09:27 - we put in here is gonna be the same type
09:28 - so I guess straying and and something
09:29 - like that so if that's the case then we
09:32 - will move left and what we'll do to do
09:33 - that is we'll say current is equal to
09:35 - current dot left because remember each
09:39 - node is gonna be a node object and they
09:41 - all have a left and right value and
09:43 - these left and right values are going to
09:45 - be other node objects that are their
09:47 - child's right so we'll move to the left
09:49 - and then we'll say otherwise so I guess
09:53 - we can just do else we will say current
09:56 - equals current dot right so now what
10:01 - we'll do is we'll traverse through the
10:03 - structure and try to determine whether
10:05 - or not some certain key exists and we
10:08 - can do this very efficiently because we
10:10 - know whether or not to move right or
10:12 - left based on the fact and the way that
10:15 - our tree works right so let's do a quick
10:17 - example of traversing this so for
10:19 - example if we're looking for the number
10:20 - five right under strong with my mouse
10:22 - right now so give me a break
10:23 - but what we're gonna do is we're going
10:24 - to check this root node first and we're
10:26 - gonna say okay so is 5 greater than or
10:28 - less than 3 it's greater than so let's
10:30 - go to the right so now the current node
10:32 - we're looking at is this one so node 4
10:34 - okay now what we're gonna do is we're
10:36 - gonna say okay well is node 4 does it
10:39 - have a value yes it does so let's keep
10:40 - looking
10:41 - we'll say so it's 5 greater than or is
10:44 - it less than 4 it's greater than so
10:46 - let's go to the right now we check 5 we
10:49 - say oh this is equal to the node we're
10:50 - looking for and there we go we're done
10:52 - we found it ok pretty basic example
10:54 - let's say now we're looking for the node
10:56 - 7 ok what we'll do is we'll go to 3
11:00 - we'll say we greater than or less than 3
11:02 - we're greater than okay so we go to 4
11:04 - are we greater than or less than we're
11:06 - greater we
11:07 - five and then we say are we greater than
11:08 - yes we are so we try to go to this node
11:11 - here right but no node exists so that
11:14 - means that seven does not exist in our
11:16 - tree because if you did exist it would
11:18 - be further down on the right branch and
11:20 - obviously there's nothing on the right
11:22 - branch past five so we know that seven
11:24 - doesn't exist and that's how we Traverse
11:26 - and see if something exists inside of
11:28 - our tree down structure and it's gonna
11:31 - be the same similar idea in terms of
11:34 - adding things and getting values of
11:36 - certain items as well okay so the next
11:38 - thing we need to do is update so update
11:41 - is going to add a node into our tree
11:45 - data structure so to do this we need to
11:47 - first check or there's a few different
11:50 - cases so the first case is that our tree
11:52 - data structure is empty in which case we
11:54 - need to define the node we're adding as
11:56 - the root node other cases are the node
11:58 - already exists or the node doesn't exist
12:00 - so in those cases there it's a similar
12:03 - solution but let's do the first case
12:04 - which is that no nodes exist and the
12:07 - root node is empty so in that case we'll
12:09 - say if self dot root equals equals none
12:12 - then what we're gonna do is we're just
12:13 - gonna say self dot root equals and in
12:15 - this cave case node key about you
12:19 - because our node object takes a key and
12:21 - a value and that's it for that case
12:23 - otherwise what we're gonna do similar to
12:27 - this is traverse our list until we get
12:30 - to a point where we need to add our node
12:32 - in there so what we'll do is we'll
12:34 - literally copy this with current and
12:36 - everything and we'll just get rid of
12:38 - this and found a thing because we don't
12:40 - need that and now what we're gonna say
12:43 - is well this actually handles all of our
12:46 - different cases because if you think
12:49 - about it well if the current dot key is
12:53 - equal to the key that means we've just
12:55 - found where that our node exists right
12:58 - and we need to now update that value
13:00 - because if you have a dictionary and you
13:02 - redefine a key with a new value it's
13:05 - just gonna override that key so in this
13:07 - case if current dog key is equal to key
13:10 - instead of saying found equals true what
13:12 - we'll say is we'll say current dot value
13:14 - equals value and then we'll just break
13:18 - that now these next cases moving the
13:21 - left and moving rights again already
13:23 - handled for us because we'll just keep
13:25 - moving left and moving right but what we
13:28 - should check in here is if there is a
13:30 - left node or if there is a right node
13:32 - because if we try to move to the left
13:33 - and there's nothing there that actually
13:35 - means that that is where our object
13:38 - needs to go right so if we go back to
13:40 - our example and we're trying to add for
13:42 - example 7 into this into here well what
13:45 - we'll do is we're gonna look for 7 right
13:47 - we're gonna keep going and find a place
13:50 - where 7 should go so we go 3 we go to 4
13:53 - we go to 5 and then we're gonna keep
13:55 - trying to go past 5 to see if there's
13:57 - anywhere better to put 7 and in the case
13:59 - where there's nothing there that means
14:01 - that that's actually where we should
14:03 - insert our element so we need to check
14:05 - that so to do that what we're gonna do
14:08 - is simply say if current dot left equals
14:12 - equals none then what we'll put in here
14:15 - is well just say current dot left equals
14:19 - node and we'll say key value like that
14:24 - and just break and we'll take the same
14:27 - thing here and we'll put it here and
14:30 - instead of current dot left we're gonna
14:31 - say current dot right and that is it for
14:35 - adding elements into our tree data
14:38 - structure that's how we do it using this
14:40 - simple method now to get an element
14:42 - we're literally gonna copy this exact
14:44 - same thing from contains we're gonna put
14:47 - it here and we're just gonna remove
14:48 - found and in this case what we'll do is
14:51 - instead of saying found equals so let
14:53 - move found term here as well instead of
14:55 - saying found equals true we're simply
14:57 - just going to return current dot value
15:01 - because when we ask when we say let's
15:03 - get this key we want the value
15:05 - associated with that key so in this case
15:07 - we'll just return the value and then say
15:09 - we get to the end and we haven't found
15:11 - that key well we'll just return none
15:13 - because that key didn't exist in our
15:15 - data structure okay sweet so now it's
15:19 - time to get keys and values and this is
15:21 - a little bit more difficult and where
15:23 - the recursion comes in so essentially we
15:26 - need to look through every single
15:29 - element in our tree data structure
15:31 - because that's what we want to do here
15:32 - we want to get every single key and
15:34 - every single value in our data structure
15:37 - so how can we do that well to do that we
15:41 - need to take every single possible
15:42 - branch and essentially add all of those
15:45 - nodes or all those keys and values into
15:47 - an array and return them or into a list
15:49 - and return them so what we need to do is
15:52 - we need to go on every left branch and
15:54 - every right branch of every single node
15:56 - so we gotta exercise or we not exercise
15:58 - we got to traverse through every single
16:01 - node so how do we do that
16:02 - well there's a few different ways to do
16:04 - it but we're gonna do it recursively and
16:06 - we're gonna use this function traverse
16:07 - to do so so inside of my keys what I'm
16:10 - gonna say let me say air R equals this
16:12 - and I'm gonna say Traverse oops
16:17 - Traverse like this but I think we need
16:19 - to do self thought Traverse my bad self
16:21 - dot Traverse and then here we're going
16:23 - to do self dot root AR now I'm just
16:27 - gonna pass it the route that we want to
16:29 - start traversing at and then an array
16:31 - which is gonna be here where it's gonna
16:33 - add all of the nodes it finds into that
16:36 - array so that we can then return that
16:38 - array which will have all of the keys
16:40 - okay so inside of Traverse how do we
16:45 - traverse every single left and right
16:47 - branch well it's actually pretty
16:49 - straightforward the first thing we need
16:51 - to check is if we've reached a dead end
16:53 - so for example if we start traversing
16:56 - through this right here and we get to
17:00 - here well we've reached a dead end so we
17:03 - don't want to go left and we don't want
17:05 - to go right anymore and that's actually
17:06 - our base case for recursion which we're
17:08 - about to do is once we reach a node that
17:10 - doesn't exist so we try to go left and
17:13 - we end up having none well that means
17:15 - that we can't go left or right any more
17:16 - so go back and do the next step that's
17:18 - what we need to do so if I go back to
17:21 - sup line here what we'll do to do this
17:25 - is we'll start by checking to make sure
17:26 - that the node or past is not equal to
17:28 - none so if current does not equal none
17:31 - okay now if it doesn't equal none what
17:35 - we'll do is we'll get whatever that node
17:36 - is and we'll add that value or the key
17:39 - into the array so to do that we'll say
17:41 - array dot append
17:44 - current dot key first step very
17:48 - straightforward and then what we'll do
17:50 - is we'll try to go left and we'll try to
17:52 - go right so we'll say self dot Traverse
17:55 - and what we'll do is we'll say current
17:59 - dot left and we'll pass it the array and
18:03 - then we'll copy this and we'll do the
18:05 - same thing except we'll try to go to the
18:07 - right so this is our recursive call and
18:10 - this is actually all we need for this
18:12 - function but essentially the way this is
18:14 - going to work is we start by calling it
18:15 - here on the root node we give it an
18:17 - empty array or list sorry and what
18:20 - happens is we're gonna check to make
18:22 - sure the node we're given is not blank
18:23 - so in this case we'll start at the root
18:25 - we'll say is does the root exists yes it
18:27 - does
18:27 - okay so what we'll do is we'll add that
18:29 - roots key into our tray and notice it's
18:31 - actually gonna change this array because
18:33 - arrays are immutable objects and this is
18:35 - a nice clean kind of way to do this and
18:37 - then what we'll do is we'll try to go
18:40 - left and we'll try to go right so say
18:41 - okay so let's so that node wasn't blank
18:44 - which means it should have a left then
18:45 - it should have a right so let's try to
18:46 - go to the left and we'll pass that same
18:49 - array so we try to go to the left so
18:50 - what we'll do now is we'll say okay so
18:52 - now current is equal to the roots left
18:55 - node and now we say all right so does
18:58 - this node it doesn't exist is there
18:59 - something here if there is we'll add
19:01 - that node into what do you call it the
19:04 - array and then we'll try to go to the
19:06 - left of that node and to the right of
19:08 - that node so if I show you on the
19:10 - diagram here there's now I got all this
19:13 - stuff everywhere but essentially let's
19:16 - change to red so I can actually will
19:17 - start here we'll say is this blank so no
19:20 - it's not so what we're gonna do is we're
19:21 - gonna try to go here and we're gonna try
19:23 - to go here so we'll start now we're on
19:26 - this left node so what we do is you say
19:28 - okay so we'll add this into the array
19:30 - and now we're gonna try to go here and
19:31 - try to go here well both of these are
19:33 - dead ends so that means all right we're
19:36 - done now
19:36 - recursively checking this path so now
19:39 - the next call on our stack is here it's
19:42 - 4 right because that's what we were
19:43 - gonna call after we traverse through all
19:45 - of the nodes onto so we do is we go to 4
19:47 - we say okay we're gonna try to go left
19:49 - we're gonna try to go right we start by
19:51 - going left we notice that this is a dead
19:53 - end so we stop going that direction and
19:55 - now we go right and now we say oh well
19:58 - there's an
19:58 - that exists here so add that into the
20:00 - array and now we're gonna try to go left
20:02 - we're gonna try to go right okay there's
20:04 - nothing left but there is something
20:06 - right let's add this to the array and
20:08 - then we try to go left we try to go
20:09 - right and it's empty on both of here so
20:12 - now we're done all of our recursive
20:14 - calls because there's nothing more being
20:16 - called and we've traversed through the
20:18 - entire tree data structure and added all
20:20 - of those elements into our array so now
20:22 - we can return the array and get all the
20:24 - keys
20:24 - very straightforward now values is
20:27 - really easy we've pretty much already
20:29 - done it so this is giving us all the
20:30 - different keys but if we want the values
20:32 - let's just say um keys equals self self
20:37 - dot keys I don't even know if I can
20:40 - actually call it keys it's might be an
20:42 - issue let's say let's just say KS equals
20:45 - self dog keys and then what we'll do is
20:48 - we'll simply say return a list where
20:51 - we're gonna say what is it self dot get
20:56 - and we'll say K for K in KS which means
21:02 - that we're gonna get all of the
21:03 - different keys and then for all those
21:05 - keys let's get the values associated
21:06 - with those keys and return that so I've
21:09 - added a few little tests here just to
21:10 - add a C and then B and then to change B
21:13 - to the value 4 to print out the keys the
21:16 - values and then try to get the value of
21:18 - B just to make sure that our data
21:20 - structure is working so if I want to run
21:22 - this I'm just gonna go into my command
21:23 - prompt and just go Python problem 8 top
21:25 - I and we noticed that we get the three
21:28 - keys that we had added there so if I
21:29 - scroll down which are a Seabee I know
21:32 - they're not in order but that's fine we
21:34 - could sort them if we wanted to and then
21:36 - we get to four four which are the
21:37 - Associated values with those keys so we
21:40 - have essentially set up our own
21:42 - dictionary in a tree data structure by
21:44 - using two classes so a node and a tree
21:47 - and we found a way to reverse through
21:49 - the entire data structure recursively
21:51 - and the main advantages of this data
21:53 - structure are it's way easier to find
21:55 - certain things because we know
21:57 - automatically to go left or right so it
22:00 - becomes almost instant to find certain
22:02 - elements in our data structure obviously
22:03 - depending on how many there are and it's
22:06 - way faster for some operations than just
22:09 - having for example a linked list or a
22:11 - standard list
22:12 - just like this so anyways that has been
22:15 - it for this kind of tree data structure
22:17 - problem I know this wasn't really a
22:19 - programming problem but to be honest
22:21 - with you I need to study for my computer
22:23 - science exam which is in two days and
22:25 - this is one of the main topics on it so
22:27 - that's kind of why I'm making this video
22:28 - right now to kill two birds with one
22:30 - stone but anyways I hope you guys
22:32 - enjoyed if you have any questions make
22:33 - sure to let me know in the comments down
22:35 - below and I will see you in another
22:36 - video
22:37 - [Music]

Cleaned transcript:

hey guys and welcome back to another weekly programming problem now in today's video what we're gonna be doing is implementing what's known as a tree data structure and we're gonna be doing this to simulate a dictionary in Python except we're gonna be programming all of the different methods and things that we need so we're essentially gonna be like writing our own dictionary in Python using what's known as a tree data structure now I'm gonna talk exactly about what a tree data structure is and the main like problem solving aspect of this video is it involves a little bit of recursion and kind of thinking to figure out how we would actually go about implementing what I'm going to show you in code now I've kind of designed like the main layout of the class in terms of the different methods that we're gonna need and this node class which we'll talk about after but essentially if you think about a dictionary in Python this key value pairs so you have for example the key maybe like a correspond to a value of eight you have the keys Ed corresponds to something so we're gonna be simulating bats in a tree data structure today so let's talk about what a a tree data structure is quickly so essentially a tree data structure and in this case we're gonna be setting ours up as a binary tree is something that kind of cascades down so it starts with a root so we'll call this our for root and then there's branches that go off the roots of two branches for a binary tree and there's some nodes okay so all of these things are called nodes that I put little lines on and each node can have at most two children and one parent okay so this would be known as the parent to these two child nodes here okay so on each child node again we can have up to two branches so we can branch off again into a few other nodes here and we can just keep going and keep going and keep going into infinity now the way that a binary tree works in terms of computing at least when we're using numbers is something like this so the way that I'm gonna set up my binary tree is the root is going to be the first element that's added to our tree so for example if we have like the element a it goes there now the way that the child nodes work is that the child node to the left of any given node is always going to be smaller then what he called that node itself so for example it's hard to do with letters maybe let's just use numbers actually if I do like if I put 3 here only numbers that are less than 3 can go on the left side here of this node so if I want to add 2 I can put it here but if I want to add the number 4 it has to go to the right of this node so the left and right side of each what do you call it like branch coming off the note actually matter and it's what's going to allow us to do some operations very quickly on our data and you'll see what I mean by that in a second so for example we have 3 we have 4 if we want to add now 5 into this tree data structure well we have to follow the same rule as before where we can't actually put anything that is greater than 3 to the left of it has to go to the right side so what we do is you say okay well we can't go here in this empty node so we go to the right and we check if a node exists there this node exists we're not going to move it but what we're gonna do is we're now going to branch off from this node and add our next number and we want to add 5 in this case so we have to follow the rule and we say that what we can't add 4 on the left side because 5 is greater than 4 so we have to add 5 on the right side so now we've added 3 4 5 and we have to blank nodes like these don't actually I'm just putting them here so you can see that they won't actually be in our in our program yet until we add another number but now let's say we add the number I probably should use some different numbers so I could add something here let's say we add the number 2 if I add the number 2 what I would do now is two would go here because well obviously 2 is less than 3 so it goes on the left side and then we can add it there now let's say I want to add the number 2.5 well 2.5 is less than 3 so we go to the left where now we're at this node so we check 2.5 we say is that less than 2 no it's not it's greater than there so now we add another node and we put 2.5 here and this is the tree data structure that I want to simulate inside my Python code and the reason I want to do this is because if I'm looking for a certain node so I'm looking for for I can find it much faster than if I just had everything set up in a straight line so for example if I had like two three four five like this okay and I want to find five I have to look at two three and four before I can get there right but now if I have my things set up in a tree data structure what I can do is I start at the root which is three so I'm go to three and then I hit four and then I'm at five so I've now skipped one operation obviously this is a bad example to show you how fast it runs there's only four nodes but when you're dealing with millions of nodes if you know to move to the right or left based on the value because everything's kind of sorted in here right then you can find values very quickly you can modify them quickly and you can add things quickly rather than having to look through each single node in your list which is just not efficient okay so this is what we need to simulate so there's a few things we need to think about we have to think about how we're gonna add something into here so we have to follow that procedure if we want to add a new node we have to think about how we would find a node and get like the value associated with that node we have to think about how we can figure out how many different nodes are in our tree and how we could possibly get all of them and look through the entire thing right so what if we want to print all the different nodes that we have in here that's another problem that we have to figure out how to do so let's now go into implementing this and start writing some code so I'll try to explain it as we go through but I mean it's not super complex it just requires a little bit of thinking so the first thing that we're gonna do is contains now contains is essentially is a certain key inside of our tree so remember we're gonna do this as a dictionary which means we're gonna store node objects and each node object has a value of right which is gonna be the right child left which is gonna be the left child and then a key and a value and the key will be what we store in the tree and then the value will be mapped by each key right and just the way a dictionary works so given a key we need to figure out if it's inside of our tree data structure so to do that we have to look through our data structure and traverse it and find that key now what makes this easier to do now is that we know that everything in our data structures in that specific order we know that everything to the right of a certain node has to be larger than it so we can use that fact to find our key way faster than just looking through every single what do you call a key or node inside our tree so to do this I'm just going to set up a few variables I'm going to say found equals false and current equals self got root now whenever we set up a tree data structure we have to start with what's known as a root and that root is the only thing in our tree that doesn't have something above it so like the root of the tree essentially right what's holding it together is that root so we start by defining a root that's equal to none because we don't have anything in our tree when so I'm just using a class obviously to do this so what we're gonna say is current is equal to sell fruit and we're gonna change this variable current and keep moving down a certain path on our tree until we find the value we're looking for or until we don't find the value we're looking for so now what I'm gonna say is I'm going to say Wow current does not equal none and three cofound equals equals false so essentially until we reach a point where we don't have any left or right branch or until we have when we found element we're looking for keep looking through the tree because we're gonna look through the tree in here and you guys will see how this works in a second so what we're gonna start by doing is gonna say if current dot key because current is gonna be equal to one of these node objects and you guys I'll see how that works in a second if current Aki is equal equal to key then what we're gonna do is simply say found equals true because we don't actually care about the value associated with the key we just care if it exists so we'll simply now we can even skip down to the bottom of our method here and just return found so if we make it out of this loop and found is equal to true then we will return that right all right so our next thing now is if the current key that we're looking at so right now in this case just the root isn't equal to the key that we have are though we're checking we have to see where to look for this key next so what we're gonna do is we're gonna check the current key that we're looking at so in this case the root and determine whether we want to move left or whether we want to move right and I know I just did that reverse for you guys but for me I guess left and then right okay so what we do now is we're gonna check if the current key will actually we'll check if our key is less than current key okay and this will work all the less than operator just assuming that the keys are gonna be the same type or we're gonna assume that each key that we put in here is gonna be the same type so I guess straying and and something like that so if that's the case then we will move left and what we'll do to do that is we'll say current is equal to current dot left because remember each node is gonna be a node object and they all have a left and right value and these left and right values are going to be other node objects that are their child's right so we'll move to the left and then we'll say otherwise so I guess we can just do else we will say current equals current dot right so now what we'll do is we'll traverse through the structure and try to determine whether or not some certain key exists and we can do this very efficiently because we know whether or not to move right or left based on the fact and the way that our tree works right so let's do a quick example of traversing this so for example if we're looking for the number five right under strong with my mouse right now so give me a break but what we're gonna do is we're going to check this root node first and we're gonna say okay so is 5 greater than or less than 3 it's greater than so let's go to the right so now the current node we're looking at is this one so node 4 okay now what we're gonna do is we're gonna say okay well is node 4 does it have a value yes it does so let's keep looking we'll say so it's 5 greater than or is it less than 4 it's greater than so let's go to the right now we check 5 we say oh this is equal to the node we're looking for and there we go we're done we found it ok pretty basic example let's say now we're looking for the node 7 ok what we'll do is we'll go to 3 we'll say we greater than or less than 3 we're greater than okay so we go to 4 are we greater than or less than we're greater we five and then we say are we greater than yes we are so we try to go to this node here right but no node exists so that means that seven does not exist in our tree because if you did exist it would be further down on the right branch and obviously there's nothing on the right branch past five so we know that seven doesn't exist and that's how we Traverse and see if something exists inside of our tree down structure and it's gonna be the same similar idea in terms of adding things and getting values of certain items as well okay so the next thing we need to do is update so update is going to add a node into our tree data structure so to do this we need to first check or there's a few different cases so the first case is that our tree data structure is empty in which case we need to define the node we're adding as the root node other cases are the node already exists or the node doesn't exist so in those cases there it's a similar solution but let's do the first case which is that no nodes exist and the root node is empty so in that case we'll say if self dot root equals equals none then what we're gonna do is we're just gonna say self dot root equals and in this cave case node key about you because our node object takes a key and a value and that's it for that case otherwise what we're gonna do similar to this is traverse our list until we get to a point where we need to add our node in there so what we'll do is we'll literally copy this with current and everything and we'll just get rid of this and found a thing because we don't need that and now what we're gonna say is well this actually handles all of our different cases because if you think about it well if the current dot key is equal to the key that means we've just found where that our node exists right and we need to now update that value because if you have a dictionary and you redefine a key with a new value it's just gonna override that key so in this case if current dog key is equal to key instead of saying found equals true what we'll say is we'll say current dot value equals value and then we'll just break that now these next cases moving the left and moving rights again already handled for us because we'll just keep moving left and moving right but what we should check in here is if there is a left node or if there is a right node because if we try to move to the left and there's nothing there that actually means that that is where our object needs to go right so if we go back to our example and we're trying to add for example 7 into this into here well what we'll do is we're gonna look for 7 right we're gonna keep going and find a place where 7 should go so we go 3 we go to 4 we go to 5 and then we're gonna keep trying to go past 5 to see if there's anywhere better to put 7 and in the case where there's nothing there that means that that's actually where we should insert our element so we need to check that so to do that what we're gonna do is simply say if current dot left equals equals none then what we'll put in here is well just say current dot left equals node and we'll say key value like that and just break and we'll take the same thing here and we'll put it here and instead of current dot left we're gonna say current dot right and that is it for adding elements into our tree data structure that's how we do it using this simple method now to get an element we're literally gonna copy this exact same thing from contains we're gonna put it here and we're just gonna remove found and in this case what we'll do is instead of saying found equals so let move found term here as well instead of saying found equals true we're simply just going to return current dot value because when we ask when we say let's get this key we want the value associated with that key so in this case we'll just return the value and then say we get to the end and we haven't found that key well we'll just return none because that key didn't exist in our data structure okay sweet so now it's time to get keys and values and this is a little bit more difficult and where the recursion comes in so essentially we need to look through every single element in our tree data structure because that's what we want to do here we want to get every single key and every single value in our data structure so how can we do that well to do that we need to take every single possible branch and essentially add all of those nodes or all those keys and values into an array and return them or into a list and return them so what we need to do is we need to go on every left branch and every right branch of every single node so we gotta exercise or we not exercise we got to traverse through every single node so how do we do that well there's a few different ways to do it but we're gonna do it recursively and we're gonna use this function traverse to do so so inside of my keys what I'm gonna say let me say air R equals this and I'm gonna say Traverse oops Traverse like this but I think we need to do self thought Traverse my bad self dot Traverse and then here we're going to do self dot root AR now I'm just gonna pass it the route that we want to start traversing at and then an array which is gonna be here where it's gonna add all of the nodes it finds into that array so that we can then return that array which will have all of the keys okay so inside of Traverse how do we traverse every single left and right branch well it's actually pretty straightforward the first thing we need to check is if we've reached a dead end so for example if we start traversing through this right here and we get to here well we've reached a dead end so we don't want to go left and we don't want to go right anymore and that's actually our base case for recursion which we're about to do is once we reach a node that doesn't exist so we try to go left and we end up having none well that means that we can't go left or right any more so go back and do the next step that's what we need to do so if I go back to sup line here what we'll do to do this is we'll start by checking to make sure that the node or past is not equal to none so if current does not equal none okay now if it doesn't equal none what we'll do is we'll get whatever that node is and we'll add that value or the key into the array so to do that we'll say array dot append current dot key first step very straightforward and then what we'll do is we'll try to go left and we'll try to go right so we'll say self dot Traverse and what we'll do is we'll say current dot left and we'll pass it the array and then we'll copy this and we'll do the same thing except we'll try to go to the right so this is our recursive call and this is actually all we need for this function but essentially the way this is going to work is we start by calling it here on the root node we give it an empty array or list sorry and what happens is we're gonna check to make sure the node we're given is not blank so in this case we'll start at the root we'll say is does the root exists yes it does okay so what we'll do is we'll add that roots key into our tray and notice it's actually gonna change this array because arrays are immutable objects and this is a nice clean kind of way to do this and then what we'll do is we'll try to go left and we'll try to go right so say okay so let's so that node wasn't blank which means it should have a left then it should have a right so let's try to go to the left and we'll pass that same array so we try to go to the left so what we'll do now is we'll say okay so now current is equal to the roots left node and now we say all right so does this node it doesn't exist is there something here if there is we'll add that node into what do you call it the array and then we'll try to go to the left of that node and to the right of that node so if I show you on the diagram here there's now I got all this stuff everywhere but essentially let's change to red so I can actually will start here we'll say is this blank so no it's not so what we're gonna do is we're gonna try to go here and we're gonna try to go here so we'll start now we're on this left node so what we do is you say okay so we'll add this into the array and now we're gonna try to go here and try to go here well both of these are dead ends so that means all right we're done now recursively checking this path so now the next call on our stack is here it's 4 right because that's what we were gonna call after we traverse through all of the nodes onto so we do is we go to 4 we say okay we're gonna try to go left we're gonna try to go right we start by going left we notice that this is a dead end so we stop going that direction and now we go right and now we say oh well there's an that exists here so add that into the array and now we're gonna try to go left we're gonna try to go right okay there's nothing left but there is something right let's add this to the array and then we try to go left we try to go right and it's empty on both of here so now we're done all of our recursive calls because there's nothing more being called and we've traversed through the entire tree data structure and added all of those elements into our array so now we can return the array and get all the keys very straightforward now values is really easy we've pretty much already done it so this is giving us all the different keys but if we want the values let's just say um keys equals self self dot keys I don't even know if I can actually call it keys it's might be an issue let's say let's just say KS equals self dog keys and then what we'll do is we'll simply say return a list where we're gonna say what is it self dot get and we'll say K for K in KS which means that we're gonna get all of the different keys and then for all those keys let's get the values associated with those keys and return that so I've added a few little tests here just to add a C and then B and then to change B to the value 4 to print out the keys the values and then try to get the value of B just to make sure that our data structure is working so if I want to run this I'm just gonna go into my command prompt and just go Python problem 8 top I and we noticed that we get the three keys that we had added there so if I scroll down which are a Seabee I know they're not in order but that's fine we could sort them if we wanted to and then we get to four four which are the Associated values with those keys so we have essentially set up our own dictionary in a tree data structure by using two classes so a node and a tree and we found a way to reverse through the entire data structure recursively and the main advantages of this data structure are it's way easier to find certain things because we know automatically to go left or right so it becomes almost instant to find certain elements in our data structure obviously depending on how many there are and it's way faster for some operations than just having for example a linked list or a standard list just like this so anyways that has been it for this kind of tree data structure problem I know this wasn't really a programming problem but to be honest with you I need to study for my computer science exam which is in two days and this is one of the main topics on it so that's kind of why I'm making this video right now to kill two birds with one stone but anyways I hope you guys enjoyed if you have any questions make sure to let me know in the comments down below and I will see you in another video
