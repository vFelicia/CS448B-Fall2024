With timestamps:

00:02 - [Music]
00:08 - hello everybody and welcome to another
00:10 - youtube video
00:11 - so in today's video i'm going to be
00:13 - discussing the global keyword in python
00:16 - why it's generally recommended that you
00:18 - do not use it now the reason i'm making
00:20 - this video
00:20 - is quite often people like myself will
00:23 - just mention or will say something like
00:24 - never use the global keyword now it's
00:27 - quite frustrating especially for someone
00:28 - who's a beginner
00:29 - because usually we don't explain
00:30 - ourselves we don't discuss why
00:32 - we don't even really talk about what the
00:33 - global keyword does so a lot of people
00:36 - will find out about this keyword and
00:37 - then get told
00:38 - never to use it without any rationale
00:40 - behind that so i want to demystify that
00:42 - for you talk about why you actually
00:44 - shouldn't use it and explain to you how
00:46 - exactly it works because that's going to
00:47 - help with this explanation
00:49 - so let's get started i'm going to start
00:50 - by explaining the global keywords the
00:52 - first thing i'm going to do is define a
00:53 - variable called x
00:54 - this is going to be equal to 0 then i'm
00:56 - going to find a function called foo
00:58 - inside of here i'm going to say x equals
00:59 - 4. then i'm going to print
01:01 - x i'm going to call foo i'm going to
01:05 - print x
01:05 - once more now take a guess i'm going to
01:08 - run this program
01:09 - what do you think the output is going to
01:11 - be so when i run this
01:12 - i get 0 0. now some of you may have
01:15 - guessed and rightfully so because this
01:16 - seems intuitive
01:17 - that we were actually going to get 0 and
01:19 - then 4. and the rationale behind that
01:21 - might have been something like well
01:23 - x is defined up here so we'll print x
01:25 - equals zero then we call the function
01:27 - that changes x to be equal to four
01:29 - so then we should print x equals to four
01:31 - or x is four
01:32 - now the reason that is not the case is
01:34 - because we have what's known as global
01:36 - and local variables x is what's known as
01:39 - a global variable the reason it is a
01:41 - global variable
01:42 - is because it is defined within the
01:43 - scope of this file
01:45 - and x is what's known as a local
01:47 - variable because it is defined within
01:48 - the scope of this
01:49 - function so anything defined within the
01:51 - main line of our file so not within a
01:53 - function or within a class
01:55 - is what's known as global anything in
01:58 - this entire file can access this global
02:01 - variable
02:01 - because it was defined just within the
02:04 - file not within anything specific
02:06 - in the file whereas x equals 4 on line 4
02:09 - here well this
02:10 - is local to the function foo it is only
02:13 - accessible
02:14 - and usable within this function now to
02:16 - show you what i mean if i go inside of
02:18 - here
02:19 - and i print x now you're going to see
02:21 - that we're going to get 0
02:22 - 4 0 printing out the reason we get that
02:25 - is because when we print x
02:26 - here we are talking about the local
02:29 - variable x
02:30 - the x that is defined within the scope
02:32 - of this function
02:34 - you don't really have to worry about
02:35 - what the name scope actually means
02:37 - but it pretty much just tells us where
02:39 - something is defined and where we should
02:41 - be looking for specific values
02:43 - now what makes this even more confusing
02:45 - though is if
02:46 - i remove these two print statements i
02:48 - remove x equals 4
02:50 - and then i call this function when i
02:52 - call this function
02:53 - now we get 0 printing out now why is
02:56 - that the case
02:57 - why does this actually work well the
02:59 - reason this works is not because
03:00 - obviously we have a local variable x
03:02 - defined
03:02 - it's because this x right here is global
03:05 - this was defined within the global scope
03:07 - it was just defined
03:08 - on the main line of our file so any
03:10 - function
03:11 - anything that is also defined within the
03:13 - scope of this file
03:14 - this function is defined within the
03:15 - scope of this file can access
03:18 - this variable x so we can see x and we
03:20 - can find it but now of course
03:22 - when i change x and i say x equals 8
03:25 - like that
03:26 - we're getting the value 8. the reason
03:28 - for this is when i do this
03:30 - our print statement is going to look at
03:32 - this x not at this
03:33 - x because this is the closest this is
03:36 - the most local
03:37 - to this function right here so hopefully
03:40 - that's clear but when i say
03:41 - x equals 8 i am not changing this x up
03:45 - here
03:45 - i'm actually creating a new variable
03:47 - which is also named x
03:49 - but which is local and defined within
03:51 - the scope
03:52 - of this function and that is again why i
03:54 - cannot access this value or i don't get
03:57 - the value 8
03:58 - when i print x outside of the function
04:01 - either before or after i call it now
04:04 - hopefully that's clear but that is the
04:05 - difference between local and global
04:07 - variables anything defined within the
04:08 - main line
04:09 - is typically known as global anything
04:11 - defined within a function or a class
04:13 - pretty much when it's indented but not
04:15 - within like an if statement or for loop
04:17 - that's an exception obviously
04:19 - then that is going to be a local
04:20 - variable to whatever function or
04:22 - whatever class
04:23 - it's defined in so actually before i get
04:25 - into the global keyword i'm kind of
04:26 - backtracking here
04:27 - i'm going to do something that is kind
04:29 - of weird if you haven't seen this before
04:31 - but just trust me this is valid python
04:33 - code
04:33 - but will really illustrate what i mean
04:35 - by local and what i mean by global
04:37 - and what i mean when i'm talking about
04:38 - these scopes right because this seems
04:40 - like kind of a confusing
04:41 - topic so i'm going to say x equals 2 on
04:43 - line 4.
04:44 - i'm going to define a function inside of
04:47 - this function this is totally valid to
04:49 - do i can do this no problem
04:50 - i'm going to say this is called bar and
04:53 - inside of here
04:54 - i am going to say x is equal to 7
04:57 - and then i'm going to print x like that
05:00 - now outside of here i'm just going to
05:02 - call the bar function
05:04 - and then i'm going to print x after i
05:06 - call the bar function
05:07 - so in case you haven't seen the syntax
05:09 - before this seems confusing i'm just
05:11 - defining a function
05:12 - inside of my other function what that
05:14 - means is this function is what's known
05:15 - as a local
05:16 - to this function so i cannot actually
05:19 - call this var function from
05:20 - outside of the function i have to call
05:22 - it from within which is what i'm doing
05:23 - here
05:24 - so bar is included or the call to bar is
05:27 - with inside of the foo function
05:28 - and the function bar is defined within
05:30 - the foo function anyways i have x
05:32 - equals 2 at the top my foo function
05:34 - inside of bar i say x
05:36 - equals 7 i print x then i call bar and i
05:38 - print x
05:39 - then i'm just going to call foo and i'm
05:41 - going to print x
05:42 - after i call foo i just want to show you
05:45 - what we're actually going to get for the
05:46 - output here
05:47 - and we see we get 3 different values 7 2
05:50 - and 0.
05:50 - and this just goes again to illustrate
05:52 - what i mean by global and local
05:54 - so x here is global right so when i
05:56 - print x
05:57 - i'm referencing this x then inside of
06:00 - here i say x equals 2
06:01 - i define the bar function i call the bar
06:03 - function we print
06:04 - 7 because well 7 is what is it called
06:08 - well 7 will be the first thing we print
06:09 - because we just called that function
06:11 - first
06:11 - 7 is local to the bar function so we
06:14 - print 7.
06:15 - then we print x after we call bar well x
06:18 - is equal to 2
06:19 - because this is within the foo function
06:22 - x is local to 2 so we print 2.
06:24 - then we print x here and again i already
06:27 - discussed that that was the global
06:28 - variable x
06:29 - so it's kind of weird because i have to
06:30 - say the same words a million times to
06:32 - explain this
06:32 - but now let's make this even more
06:34 - confusing remove x equals 7
06:36 - and i'm just going to print x inside of
06:37 - the bar function now
06:39 - take a guess at what you think is going
06:40 - to print out am i going to print this
06:42 - x or am i going to print this x it's a
06:44 - good question or is this going to error
06:45 - out what's going to happen
06:46 - so let's run this and notice we get 2 2
06:49 - and then 0. so we print 2
06:51 - we print 2 and then we print 0. now this
06:54 - is a really good example
06:55 - to show you how we actually look for
06:57 - global variables or variables that are
06:59 - not defined within our current scope
07:01 - so when i try to print x here inside of
07:03 - bar the first thing that our computer
07:05 - does
07:05 - is it looks within the scope of this bar
07:08 - function anything defined in this bar
07:09 - function
07:10 - and says do we have a variable x if we
07:13 - do
07:14 - what it does is it uses that value for x
07:16 - because that is the most
07:17 - local to where we called this statement
07:19 - from but if it does not find an x it
07:22 - says okay there's no x here
07:23 - but there might be one outside so what
07:26 - it does is it goes to the scope that's
07:28 - containing it which is the foo
07:29 - function because bar is defined within
07:32 - the foo function
07:33 - and then what we do is we look for any x
07:35 - defined in that scope
07:37 - we do find one we find x is equal to 2
07:39 - and so we print or use that value of x
07:42 - there you go but now if i remove x from
07:45 - here
07:46 - and i do this let's run it we get 0 0 0.
07:49 - so what happens in this print statement
07:51 - is we look within this scope we don't
07:53 - find any x's so we look within the scope
07:55 - that this is the find in
07:56 - and we find the x so then we use x which
07:59 - is a value of 0.
08:00 - same thing inside of the foo function we
08:01 - look in the foo function don't find any
08:03 - x's we look in the global or the file i
08:06 - guess the main line
08:07 - and we find x equals 0 and we use that
08:09 - as the value
08:10 - so hopefully that explains to you scope
08:12 - and how we actually reference or access
08:14 - variables
08:15 - now let's talk about the global keyword
08:17 - so i'm going to go back to that previous
08:18 - example i had
08:20 - we'll keep the print statements and
08:22 - we'll say x equals 2
08:23 - and then x equals 7. now what i'm going
08:25 - to do is inside
08:27 - of the foo function i'm going to say
08:29 - globalx
08:31 - now this is what you do when you want to
08:32 - define a global variable
08:34 - you put global at the top of the
08:35 - function and then you can put multiple
08:37 - variables here like i could do x comma y
08:39 - if i wanted to
08:40 - and this pretty much tells our function
08:43 - that what we should do
08:44 - is treat any variable called x as a
08:46 - global
08:47 - variable now remember global variables
08:50 - are anything defined within the main
08:51 - line
08:52 - of the file so what that means is we're
08:54 - going to treat x here the same as
08:56 - x up here so when i say x equals 2
08:59 - what this is going to do you know what
09:01 - i'm just going to remove the bar
09:02 - function because this would be
09:03 - a bit too advanced if i leave that in
09:04 - there for right now what this will do is
09:06 - it will say let's treat x as a global
09:08 - variable so when i say x equals 2
09:10 - i will actually change the value of x
09:12 - here
09:13 - so when i run this you see we get 2 2
09:16 - because this actually does
09:17 - change the value of x so that's kind of
09:20 - the basis on how that works if i remove
09:22 - x from up here and i call my function
09:25 - foo with global x
09:26 - the same thing is going to happen we get
09:28 - 2 2. the reason for that is even though
09:30 - i didn't define
09:31 - x as a global variable above like i
09:33 - didn't say x equals 2
09:35 - since i said that it is global that
09:38 - means that we are going to create it
09:39 - in the global scope so anything after
09:42 - this variable is created so after we
09:43 - call the function foo
09:44 - can access the variable x now you may
09:47 - already start to see
09:48 - why this global keyword could cause some
09:50 - issues because this seems a little bit
09:52 - confusing and you can make it even more
09:53 - confusing when you do something like
09:55 - this
09:55 - define bar and then inside of here
09:58 - let's say x equals 7 and let's call the
10:01 - function bar
10:02 - what do we think is going to happen now
10:04 - when i do this well let's run this
10:05 - and we see that we get the same thing so
10:08 - x
10:08 - equals 7 even though we called the bar
10:11 - function
10:12 - did not globally change x the reason it
10:15 - did not globally change x
10:17 - is because x is local to the function
10:19 - bar we did not define
10:21 - in the bar function which we could
10:23 - global x like that
10:24 - that we should change the global value
10:26 - of x and if we do
10:27 - do that inside of here then will that
10:30 - change the value of x out here or will
10:32 - it change the value of x here that's the
10:33 - question right
10:34 - are we going to get 7 printing out here
10:36 - what are all the print statements going
10:37 - to say in fact let's print
10:39 - x inside of here so let's do this and
10:42 - let's run it
10:43 - and we see we get 7 everywhere so when i
10:45 - do this
10:46 - what this does is it actually changes
10:48 - the value of x
10:49 - for the global context so not for just
10:52 - the simply the function above us
10:54 - for all of them now to make this more
10:55 - clear i know this is confusing
10:57 - let's do this so let's just have the
10:59 - function foo
11:01 - we're not going to define anything
11:02 - inside of foo other than the bar
11:03 - function then we'll just call the bar
11:05 - function
11:05 - then we'll print x here and we'll print
11:07 - x here let's run this
11:09 - and we get the same thing 7 7. so all
11:11 - i'm saying is what the global keyword
11:13 - does
11:13 - is it tells us to treat any variable
11:15 - with the name that we've defined as
11:17 - global
11:17 - as a global variable for the entire file
11:21 - not just for the scope above the current
11:24 - scope that we're defined in
11:25 - i know it's starting to get confusing
11:26 - but i do need to explain this just to
11:28 - make sure it's really clear on how
11:30 - scopes work how you look for variables
11:31 - and all that i think it's valuable to
11:32 - understand
11:33 - so that is what the global keyword does
11:35 - now why is this an issue why would you
11:37 - not
11:38 - want to use it now there's many
11:39 - potential answers to this question you
11:41 - can probably come up with a huge list of
11:43 - why global is really bad
11:45 - but one of them is that it adds hidden
11:47 - side effects
11:48 - to our functions now what i mean by that
11:50 - is that if i decide to say you know
11:53 - take this function here and i put it in
11:55 - a new file let's just imagine that the
11:56 - new file doesn't have the call to foo
11:58 - and it doesn't have the print statement
11:59 - okay i just make this function or i want
12:01 - to reuse it i just throw it into a new
12:03 - file
12:04 - now all of a sudden this function is
12:06 - modifying a global variable called
12:08 - x so let's say in my other file i'm
12:12 - using a variable called x and i have x
12:14 - storing some you know really important
12:15 - information maybe it's equal to hello or
12:16 - something like that it's not even equal
12:18 - to a number
12:19 - all of a sudden i throw this function in
12:21 - that file and now it's going to break
12:23 - my entire program as soon as i call it
12:25 - the reason it's going to break that
12:27 - is because we have global x defined and
12:29 - well
12:30 - we didn't know we have no way of knowing
12:32 - inside of this function if x
12:33 - is already defined outside well this is
12:36 - going to override
12:37 - x so it's going to change x which is
12:39 - storing some really important
12:40 - information
12:41 - to be equal to 7 and well we might not
12:42 - necessarily want that
12:44 - now you could say well tim let's just
12:46 - not throw this function into another
12:47 - file
12:48 - okay that's great but now you're
12:50 - removing one of the great aspects of a
12:52 - function
12:52 - the part that it is reusable and
12:54 - typically when we write a function
12:56 - we want to be able to reuse it multiple
12:58 - times and not just from one specific
13:00 - file we might want to have like a
13:02 - library of math functions or a bunch of
13:04 - things like that
13:04 - that we can use in any program that we
13:07 - want and ideally when we create a
13:08 - function
13:09 - it should do one thing and it should do
13:11 - one thing very well
13:12 - all of a sudden when we say global x
13:15 - what we are doing now is we are
13:16 - modifying something
13:17 - outside of this function and it's very
13:19 - hard for us to actually figure out that
13:21 - we're doing this
13:22 - especially if we have a very large
13:24 - function because if we just don't see
13:26 - this global keyword
13:27 - we have no idea why some random variable
13:31 - in our file is getting modified right
13:33 - so just to go through some of those
13:34 - reasons i'll show you some more examples
13:36 - it removes the reusability aspect of our
13:39 - function from other files
13:40 - it also just makes it way harder to
13:42 - figure out if something's going wrong so
13:44 - it makes it hard to debug
13:45 - because now we have some global value
13:47 - some global variable and we're
13:49 - potentially changing
13:50 - other variables defined other places
13:52 - within our function or sorry within our
13:54 - file so makes it hard to debug and hard
13:57 - to reuse which are already two very good
13:59 - reasons not to use it but let's talk
14:00 - about some more
14:02 - so let's actually define a function that
14:04 - uses the global keyword that might seem
14:06 - to make sense
14:06 - so let's say define um you know let's go
14:10 - add underscore seven like that
14:14 - we'll take some variable called x and
14:16 - what we're going to do
14:17 - is we're going to set a global variable
14:19 - so we'll say global
14:21 - um i don't know let's say result
14:24 - and this is going to be equal to x plus
14:27 - 7 like that okay so we just say result
14:30 - uh
14:30 - is i guess equal to x plus seven and now
14:33 - what i'm going to do is i'm going to
14:34 - define
14:35 - the function i'm going to call the
14:36 - function i'll say add underscore seven
14:39 - we'll call it with the value six and
14:41 - then we'll just print out the variable
14:43 - result right that's
14:44 - an instance in which we could use the
14:45 - global keyword so let's do this and now
14:47 - we go ahead and we get
14:48 - 13. but now of course the issue arises
14:52 - when we define some result variable here
14:54 - we say result is equal to you know 65 or
14:57 - whatever
14:58 - and now all of a sudden after we call
15:00 - add seven we're
15:01 - changing results right if we run this
15:04 - we're getting uh 13.
15:05 - even though result is defined as 65.
15:08 - let's imagine you couldn't see this
15:09 - function
15:10 - or it was like you just didn't think to
15:12 - look in this function for an error
15:14 - all of a sudden you have no idea why
15:16 - when you're printing results
15:18 - you are getting 13 and you are not
15:19 - getting 65.
15:21 - so the alternative approach to doing
15:22 - this and this is obviously what most of
15:24 - you would probably do
15:26 - would be to do something like this
15:27 - result equals add underscore 7
15:30 - and rather than setting result you just
15:32 - return the value so you say
15:34 - return like that you get rid of the
15:36 - global makes your function cleaner and
15:38 - easier
15:39 - and now if we say something like result
15:42 - there
15:42 - and i don't know let's i'm trying to
15:45 - think of another way that we could use
15:46 - results that would make sense
15:48 - but regardless this is just easier and
15:50 - this is much better now it doesn't
15:52 - matter what i
15:53 - call the variable that's storing this
15:54 - result right i didn't call it result one
15:56 - like that boom we're good to go so that
15:58 - is just an alternative approach to using
16:00 - the global keyword now
16:01 - the reason a lot of people like to use a
16:03 - global keyword is they say i don't want
16:05 - to be passing a ton of parameters
16:07 - to my function and they say it's easier
16:09 - if i just make all of these variables
16:11 - global
16:11 - because then i can set all these
16:12 - variables and it's just better now if
16:14 - you're doing that if you are setting a
16:17 - bunch of values or changing a bunch of
16:18 - things
16:19 - globally from a function you're already
16:21 - making a big mistake you should not be
16:23 - doing that
16:24 - when you have a function it should do
16:25 - one thing and it should do one thing
16:27 - very well
16:27 - as soon as you start modifying global
16:30 - variables from within side of your
16:32 - function
16:32 - that should be a clue that your function
16:34 - is not behaving the way that it ideally
16:37 - should in terms of following best
16:38 - practices
16:39 - and again based on the reasons i just
16:41 - discussed it makes it very difficult to
16:42 - debug your program
16:44 - especially if you call this function
16:46 - multiple times because it's going to
16:47 - keep
16:47 - resetting global variables and if you
16:49 - ever use that variable again
16:52 - globally then it's just going to be a
16:53 - huge headache and a huge mess
16:55 - so i could go on and on and show you a
16:57 - bunch of examples but i just want to
16:58 - give you two really quick reasons why
17:00 - you shouldn't use the global keyword it
17:02 - just makes things very confusing hard to
17:04 - debug
17:04 - and it's just really not a thing that
17:06 - you ever need to do
17:07 - if you find yourself and you say i have
17:09 - to use the global keyword
17:11 - re-evaluate the way you're trying to
17:12 - solve this problem and think about how
17:14 - you can make a function that can take
17:16 - some inputs
17:17 - and give you some output like i just did
17:19 - right here and rather than setting the
17:20 - global variable inside of here
17:22 - get the results from the function and
17:24 - then define or reset the global variable
17:27 - from the global context where it makes
17:29 - sense to do so
17:30 - so hopefully this was helpful i
17:32 - apologize if i not did not get into too
17:34 - many reasons on why you shouldn't use
17:35 - the global keyword
17:36 - again it's hard to illustrate this with
17:38 - just a small example but hopefully this
17:40 - explained to you scope
17:41 - explained to you how this worked and
17:43 - well i guess yeah this was helpful
17:44 - so if it was make sure you leave a like
17:46 - subscribe to the channel and of course i
17:48 - will see you in another
17:49 - youtube video

Cleaned transcript:

hello everybody and welcome to another youtube video so in today's video i'm going to be discussing the global keyword in python why it's generally recommended that you do not use it now the reason i'm making this video is quite often people like myself will just mention or will say something like never use the global keyword now it's quite frustrating especially for someone who's a beginner because usually we don't explain ourselves we don't discuss why we don't even really talk about what the global keyword does so a lot of people will find out about this keyword and then get told never to use it without any rationale behind that so i want to demystify that for you talk about why you actually shouldn't use it and explain to you how exactly it works because that's going to help with this explanation so let's get started i'm going to start by explaining the global keywords the first thing i'm going to do is define a variable called x this is going to be equal to 0 then i'm going to find a function called foo inside of here i'm going to say x equals 4. then i'm going to print x i'm going to call foo i'm going to print x once more now take a guess i'm going to run this program what do you think the output is going to be so when i run this i get 0 0. now some of you may have guessed and rightfully so because this seems intuitive that we were actually going to get 0 and then 4. and the rationale behind that might have been something like well x is defined up here so we'll print x equals zero then we call the function that changes x to be equal to four so then we should print x equals to four or x is four now the reason that is not the case is because we have what's known as global and local variables x is what's known as a global variable the reason it is a global variable is because it is defined within the scope of this file and x is what's known as a local variable because it is defined within the scope of this function so anything defined within the main line of our file so not within a function or within a class is what's known as global anything in this entire file can access this global variable because it was defined just within the file not within anything specific in the file whereas x equals 4 on line 4 here well this is local to the function foo it is only accessible and usable within this function now to show you what i mean if i go inside of here and i print x now you're going to see that we're going to get 0 4 0 printing out the reason we get that is because when we print x here we are talking about the local variable x the x that is defined within the scope of this function you don't really have to worry about what the name scope actually means but it pretty much just tells us where something is defined and where we should be looking for specific values now what makes this even more confusing though is if i remove these two print statements i remove x equals 4 and then i call this function when i call this function now we get 0 printing out now why is that the case why does this actually work well the reason this works is not because obviously we have a local variable x defined it's because this x right here is global this was defined within the global scope it was just defined on the main line of our file so any function anything that is also defined within the scope of this file this function is defined within the scope of this file can access this variable x so we can see x and we can find it but now of course when i change x and i say x equals 8 like that we're getting the value 8. the reason for this is when i do this our print statement is going to look at this x not at this x because this is the closest this is the most local to this function right here so hopefully that's clear but when i say x equals 8 i am not changing this x up here i'm actually creating a new variable which is also named x but which is local and defined within the scope of this function and that is again why i cannot access this value or i don't get the value 8 when i print x outside of the function either before or after i call it now hopefully that's clear but that is the difference between local and global variables anything defined within the main line is typically known as global anything defined within a function or a class pretty much when it's indented but not within like an if statement or for loop that's an exception obviously then that is going to be a local variable to whatever function or whatever class it's defined in so actually before i get into the global keyword i'm kind of backtracking here i'm going to do something that is kind of weird if you haven't seen this before but just trust me this is valid python code but will really illustrate what i mean by local and what i mean by global and what i mean when i'm talking about these scopes right because this seems like kind of a confusing topic so i'm going to say x equals 2 on line 4. i'm going to define a function inside of this function this is totally valid to do i can do this no problem i'm going to say this is called bar and inside of here i am going to say x is equal to 7 and then i'm going to print x like that now outside of here i'm just going to call the bar function and then i'm going to print x after i call the bar function so in case you haven't seen the syntax before this seems confusing i'm just defining a function inside of my other function what that means is this function is what's known as a local to this function so i cannot actually call this var function from outside of the function i have to call it from within which is what i'm doing here so bar is included or the call to bar is with inside of the foo function and the function bar is defined within the foo function anyways i have x equals 2 at the top my foo function inside of bar i say x equals 7 i print x then i call bar and i print x then i'm just going to call foo and i'm going to print x after i call foo i just want to show you what we're actually going to get for the output here and we see we get 3 different values 7 2 and 0. and this just goes again to illustrate what i mean by global and local so x here is global right so when i print x i'm referencing this x then inside of here i say x equals 2 i define the bar function i call the bar function we print 7 because well 7 is what is it called well 7 will be the first thing we print because we just called that function first 7 is local to the bar function so we print 7. then we print x after we call bar well x is equal to 2 because this is within the foo function x is local to 2 so we print 2. then we print x here and again i already discussed that that was the global variable x so it's kind of weird because i have to say the same words a million times to explain this but now let's make this even more confusing remove x equals 7 and i'm just going to print x inside of the bar function now take a guess at what you think is going to print out am i going to print this x or am i going to print this x it's a good question or is this going to error out what's going to happen so let's run this and notice we get 2 2 and then 0. so we print 2 we print 2 and then we print 0. now this is a really good example to show you how we actually look for global variables or variables that are not defined within our current scope so when i try to print x here inside of bar the first thing that our computer does is it looks within the scope of this bar function anything defined in this bar function and says do we have a variable x if we do what it does is it uses that value for x because that is the most local to where we called this statement from but if it does not find an x it says okay there's no x here but there might be one outside so what it does is it goes to the scope that's containing it which is the foo function because bar is defined within the foo function and then what we do is we look for any x defined in that scope we do find one we find x is equal to 2 and so we print or use that value of x there you go but now if i remove x from here and i do this let's run it we get 0 0 0. so what happens in this print statement is we look within this scope we don't find any x's so we look within the scope that this is the find in and we find the x so then we use x which is a value of 0. same thing inside of the foo function we look in the foo function don't find any x's we look in the global or the file i guess the main line and we find x equals 0 and we use that as the value so hopefully that explains to you scope and how we actually reference or access variables now let's talk about the global keyword so i'm going to go back to that previous example i had we'll keep the print statements and we'll say x equals 2 and then x equals 7. now what i'm going to do is inside of the foo function i'm going to say globalx now this is what you do when you want to define a global variable you put global at the top of the function and then you can put multiple variables here like i could do x comma y if i wanted to and this pretty much tells our function that what we should do is treat any variable called x as a global variable now remember global variables are anything defined within the main line of the file so what that means is we're going to treat x here the same as x up here so when i say x equals 2 what this is going to do you know what i'm just going to remove the bar function because this would be a bit too advanced if i leave that in there for right now what this will do is it will say let's treat x as a global variable so when i say x equals 2 i will actually change the value of x here so when i run this you see we get 2 2 because this actually does change the value of x so that's kind of the basis on how that works if i remove x from up here and i call my function foo with global x the same thing is going to happen we get 2 2. the reason for that is even though i didn't define x as a global variable above like i didn't say x equals 2 since i said that it is global that means that we are going to create it in the global scope so anything after this variable is created so after we call the function foo can access the variable x now you may already start to see why this global keyword could cause some issues because this seems a little bit confusing and you can make it even more confusing when you do something like this define bar and then inside of here let's say x equals 7 and let's call the function bar what do we think is going to happen now when i do this well let's run this and we see that we get the same thing so x equals 7 even though we called the bar function did not globally change x the reason it did not globally change x is because x is local to the function bar we did not define in the bar function which we could global x like that that we should change the global value of x and if we do do that inside of here then will that change the value of x out here or will it change the value of x here that's the question right are we going to get 7 printing out here what are all the print statements going to say in fact let's print x inside of here so let's do this and let's run it and we see we get 7 everywhere so when i do this what this does is it actually changes the value of x for the global context so not for just the simply the function above us for all of them now to make this more clear i know this is confusing let's do this so let's just have the function foo we're not going to define anything inside of foo other than the bar function then we'll just call the bar function then we'll print x here and we'll print x here let's run this and we get the same thing 7 7. so all i'm saying is what the global keyword does is it tells us to treat any variable with the name that we've defined as global as a global variable for the entire file not just for the scope above the current scope that we're defined in i know it's starting to get confusing but i do need to explain this just to make sure it's really clear on how scopes work how you look for variables and all that i think it's valuable to understand so that is what the global keyword does now why is this an issue why would you not want to use it now there's many potential answers to this question you can probably come up with a huge list of why global is really bad but one of them is that it adds hidden side effects to our functions now what i mean by that is that if i decide to say you know take this function here and i put it in a new file let's just imagine that the new file doesn't have the call to foo and it doesn't have the print statement okay i just make this function or i want to reuse it i just throw it into a new file now all of a sudden this function is modifying a global variable called x so let's say in my other file i'm using a variable called x and i have x storing some you know really important information maybe it's equal to hello or something like that it's not even equal to a number all of a sudden i throw this function in that file and now it's going to break my entire program as soon as i call it the reason it's going to break that is because we have global x defined and well we didn't know we have no way of knowing inside of this function if x is already defined outside well this is going to override x so it's going to change x which is storing some really important information to be equal to 7 and well we might not necessarily want that now you could say well tim let's just not throw this function into another file okay that's great but now you're removing one of the great aspects of a function the part that it is reusable and typically when we write a function we want to be able to reuse it multiple times and not just from one specific file we might want to have like a library of math functions or a bunch of things like that that we can use in any program that we want and ideally when we create a function it should do one thing and it should do one thing very well all of a sudden when we say global x what we are doing now is we are modifying something outside of this function and it's very hard for us to actually figure out that we're doing this especially if we have a very large function because if we just don't see this global keyword we have no idea why some random variable in our file is getting modified right so just to go through some of those reasons i'll show you some more examples it removes the reusability aspect of our function from other files it also just makes it way harder to figure out if something's going wrong so it makes it hard to debug because now we have some global value some global variable and we're potentially changing other variables defined other places within our function or sorry within our file so makes it hard to debug and hard to reuse which are already two very good reasons not to use it but let's talk about some more so let's actually define a function that uses the global keyword that might seem to make sense so let's say define um you know let's go add underscore seven like that we'll take some variable called x and what we're going to do is we're going to set a global variable so we'll say global um i don't know let's say result and this is going to be equal to x plus 7 like that okay so we just say result uh is i guess equal to x plus seven and now what i'm going to do is i'm going to define the function i'm going to call the function i'll say add underscore seven we'll call it with the value six and then we'll just print out the variable result right that's an instance in which we could use the global keyword so let's do this and now we go ahead and we get 13. but now of course the issue arises when we define some result variable here we say result is equal to you know 65 or whatever and now all of a sudden after we call add seven we're changing results right if we run this we're getting uh 13. even though result is defined as 65. let's imagine you couldn't see this function or it was like you just didn't think to look in this function for an error all of a sudden you have no idea why when you're printing results you are getting 13 and you are not getting 65. so the alternative approach to doing this and this is obviously what most of you would probably do would be to do something like this result equals add underscore 7 and rather than setting result you just return the value so you say return like that you get rid of the global makes your function cleaner and easier and now if we say something like result there and i don't know let's i'm trying to think of another way that we could use results that would make sense but regardless this is just easier and this is much better now it doesn't matter what i call the variable that's storing this result right i didn't call it result one like that boom we're good to go so that is just an alternative approach to using the global keyword now the reason a lot of people like to use a global keyword is they say i don't want to be passing a ton of parameters to my function and they say it's easier if i just make all of these variables global because then i can set all these variables and it's just better now if you're doing that if you are setting a bunch of values or changing a bunch of things globally from a function you're already making a big mistake you should not be doing that when you have a function it should do one thing and it should do one thing very well as soon as you start modifying global variables from within side of your function that should be a clue that your function is not behaving the way that it ideally should in terms of following best practices and again based on the reasons i just discussed it makes it very difficult to debug your program especially if you call this function multiple times because it's going to keep resetting global variables and if you ever use that variable again globally then it's just going to be a huge headache and a huge mess so i could go on and on and show you a bunch of examples but i just want to give you two really quick reasons why you shouldn't use the global keyword it just makes things very confusing hard to debug and it's just really not a thing that you ever need to do if you find yourself and you say i have to use the global keyword reevaluate the way you're trying to solve this problem and think about how you can make a function that can take some inputs and give you some output like i just did right here and rather than setting the global variable inside of here get the results from the function and then define or reset the global variable from the global context where it makes sense to do so so hopefully this was helpful i apologize if i not did not get into too many reasons on why you shouldn't use the global keyword again it's hard to illustrate this with just a small example but hopefully this explained to you scope explained to you how this worked and well i guess yeah this was helpful so if it was make sure you leave a like subscribe to the channel and of course i will see you in another youtube video
