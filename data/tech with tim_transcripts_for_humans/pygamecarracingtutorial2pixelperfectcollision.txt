With timestamps:

00:02 - [Music]
00:08 - all right so i am back with video 2 in
00:10 - this series in this video we're going to
00:12 - be talking about collision and handling
00:14 - pixel perfect collision actually anyways
00:17 - first thing i want to do is actually
00:18 - make it so our car can move backwards
00:20 - because well we didn't do that in the
00:22 - last video and i meant to show that so
00:23 - let's do that now so to move backwards
00:25 - is very easy in fact it's the exact same
00:27 - as moving forwards except we just need
00:29 - to modify
00:30 - the velocity and everything a little bit
00:32 - so we're going to go and make another
00:33 - method here and this is going to be
00:34 - called move backward and inside of here
00:36 - we're going to say self.bell is equal to
00:38 - the maximum
00:40 - of and this is going to be self.velocity
00:42 - minus self.acceleration when we move
00:44 - backwards we need to subtract the
00:46 - acceleration because we're trying to go
00:48 - in the opposite direction so we want a
00:50 - negative velocity to be moving backwards
00:52 - because it's like the reverse gear in
00:54 - your car you don't turn around and go
00:55 - backwards you can just rotate the wheels
00:57 - in the other direction which is what
00:58 - we're going to do here and then this
01:00 - needs to be
01:02 - self.max val over 2. i don't know why i
01:05 - deleted that the idea of this is that we
01:08 - want
01:08 - sorry this needs to be negative is that
01:10 - we want the
01:12 - maximum possible negative velocity to be
01:16 - half of the velocity going forward the
01:18 - reverse gear in your car you cannot go
01:20 - up to 100 miles per hour right you can
01:21 - only go a certain speed there's a top
01:23 - speed in that so same thing here we're
01:24 - going to make it so when you go in
01:26 - reverse you're going slower than when
01:27 - you are going forward
01:29 - i don't know why that's super important
01:30 - but that's what we're doing so
01:32 - self.velocity minus self.acceleration
01:34 - and then negative self.max velocity over
01:37 - two just splitting that in half i think
01:40 - that's pretty self-explanatory let's now
01:42 - make it so we have a key that does that
01:45 - so we're just going to copy this
01:47 - and i'm just going to change this now to
01:48 - key
01:49 - this is going to be s s will go
01:51 - backwards and then we'll change this to
01:54 - be backward like that notice i have
01:55 - moved equals true we need that to make
01:58 - sure we don't reduce our speed as we are
02:00 - going backwards
02:01 - perfect
02:02 - now that we have that let's run the code
02:04 - and let's check if the reverse gear
02:06 - works so now i can move backwards and
02:08 - notice i cannot go backwards at the same
02:10 - speed that i can go forwards right i can
02:12 - go at half the speed great there you go
02:14 - backwards is working if you try to turn
02:16 - when you're going backwards you'll
02:17 - notice that the turning works and you
02:18 - actually should be turning in the
02:20 - inverse direction which is correct and
02:23 - that's why we set up all this stuff so
02:24 - that it just works when we add other
02:26 - things in the future
02:28 - great so what i want to do is just clean
02:29 - up the code a little bit here i want to
02:31 - take all of this stuff so keys moved all
02:33 - of the stuff related to moving my player
02:36 - and i want to make a function here
02:38 - and i'm going to call this move
02:40 - underscore player
02:41 - now inside of here
02:43 - we will just take the
02:45 - player card so we'll say
02:47 - player underscore car like that and then
02:50 - we could perform all of this stuff
02:52 - simply using player car okay so again
02:54 - just trying to clean this up so now
02:56 - inside of here i'm going to say move
02:58 - underscore player and i'm going to pass
02:59 - my player car
03:01 - and this will handle all the movement
03:03 - let me just get rid of that let's run
03:05 - this
03:06 - and let's make sure it's still working
03:08 - and it is we are all good okay one more
03:10 - small refactor i want to do is i just
03:12 - want to go and grab this reduce speed
03:15 - method here and put this inside of my
03:17 - car class
03:18 - reason being that my computer which is
03:21 - going to inherit from this abstract car
03:23 - class as well does not need to be able
03:25 - to reduce its speed it's going to be the
03:26 - same speed the whole time and so it
03:28 - makes sense to have this in the class
03:30 - where it's actually going to be used
03:31 - because it's not going to be used by
03:32 - anything else that implements the
03:34 - abstract car class
03:36 - you could leave it in there there's
03:37 - arguments for both but i am just going
03:39 - to move it here
03:40 - great so everything will continue to
03:41 - work we don't need to test that moving
03:43 - forward though the next thing i want to
03:45 - do is collision
03:47 - so this is where we need to talk about
03:48 - masks and we need to talk about how you
03:51 - actually
03:52 - handle collision of different objects in
03:55 - python so what i'm going to do is open
03:56 - up paint here
03:58 - we're going to start talking about masks
04:00 - all right so i'm inside of paint here
04:01 - and i'm gonna explain to you masks and
04:03 - how we do pixel perfect collision so
04:06 - let's start with traditional collision
04:07 - and then we can explain pixel perfect
04:09 - collision so let's say we have some
04:11 - object and let's just make it a circle
04:13 - for simplicity now remember i told you
04:15 - that every single surface in pi game is
04:17 - really a rectangle so even if this is
04:19 - all that we're showing we actually have
04:21 - a rectangle around this circle here so
04:24 - we might not see the rectangle and the
04:26 - reason we wouldn't see it is because all
04:27 - of these pixels here would be
04:29 - transparent pixels they wouldn't show up
04:31 - on the screen but they're still there
04:32 - it's still rectangle so let's say we
04:34 - have another image and let's just do it
04:36 - like this and maybe inside of here i
04:38 - don't know we have some green whatever
04:40 - okay this is what this image looks like
04:42 - point being is that these two rectangles
04:44 - the rectangles containing these two
04:46 - images are overlapping this is the
04:48 - overlapping area right here however if
04:50 - we're looking at these two images remove
04:52 - the rectangles they're not colliding
04:54 - with each other right the pixels that
04:56 - are present in both of the these images
04:58 - are not touching each other but if we
05:00 - were to use traditional collision which
05:02 - is just rectangular collision you just
05:04 - check if two rectangles are lying inside
05:06 - of each other then it would say
05:08 - that these two objects are colliding
05:10 - and this is the overlapping area but
05:12 - again the pixels in the images are not
05:14 - actually colliding so how do we fix this
05:16 - because i don't want it to show me that
05:18 - two objects are colliding unless the
05:20 - pixels on the screen actually look like
05:22 - they are colliding this is where we use
05:24 - something known as a mask
05:26 - now what a mask is is an array of values
05:29 - representing whether or not a pixel in
05:32 - an image is transparent or present
05:34 - whether it just exists it's not a
05:35 - transparent pixel now the point of a
05:37 - mask is that rather than performing
05:39 - rectangular collision like this we can
05:42 - simply check if pixels that are not
05:44 - transparent are overlapping into
05:47 - rectangular regions so let's clear all
05:50 - of this and now let's look at an example
05:52 - of a mask let's say we have a very
05:54 - simple image okay i'm going to just go
05:56 - with a rectangle because it's easier
05:58 - here
05:58 - and we have maybe something like this
06:01 - okay
06:02 - we have pixels all in here
06:04 - pixels all in here and then inside of
06:07 - the other two regions is transparent
06:08 - okay and now we have another image
06:10 - and let's just do something like this
06:12 - and maybe we only have pixels inside of
06:15 - this bottom left hand corner well the
06:18 - mask for these two images would look
06:20 - like this it's just going to be an array
06:21 - so we'd have a large array it's going to
06:23 - be a two-dimensional array and we would
06:25 - have one comma zero
06:27 - okay and again excuse me i'm using the
06:29 - mouse here and then zero comma one
06:32 - like that now for this image it would be
06:35 - similar but we're going to have nothing
06:37 - in the first row because we have no
06:39 - non-transparent pixels and then we would
06:41 - go here and we would have 0 comma 1 like
06:44 - that
06:45 - okay
06:46 - now let's imagine these masks are
06:48 - directly on top of each other the two
06:49 - objects are completely on top of each
06:51 - other then what we would do is we would
06:53 - just compare values in these arrays and
06:55 - see if two ones are at the same position
06:57 - right
06:58 - so we check here
06:59 - so okay there's no one here so we're not
07:01 - colliding
07:02 - in this region okay then we go here
07:05 - so okay there's no ones there so we're
07:06 - not colliding there we go here okay no
07:08 - ones we're not colliding
07:10 - and boom we find two ones which means
07:12 - we're colliding in this region right
07:14 - here and so we would say okay yes we are
07:16 - colliding because two pixels that are
07:17 - not transparent are touching each other
07:20 - there you go perfect that's all you need
07:21 - to know however it gets a little bit
07:23 - more complicated because we need to know
07:26 - the location of both of these masks
07:28 - before we can do this comparison in the
07:31 - example i just showed you we just
07:32 - imagine they were on top of each other
07:34 - so if i select this
07:36 - and i grab it it's going to be a bit
07:38 - rough but we imagine this mask was right
07:40 - on top of the other one and in that case
07:42 - it was really easy to check if they were
07:43 - colliding but what if the mask is
07:45 - sitting somewhere like this or sitting
07:47 - here or sitting up here well we need to
07:50 - know that and that's known as the offset
07:52 - so we have something and actually let's
07:54 - make a new file here we have something
07:56 - known as our calling mask and then i
07:58 - guess the mask that it's being called on
08:00 - so let's say that this here is our
08:02 - calling mask and then this is the mask
08:05 - that this mask is being called on well
08:07 - we need to determine
08:09 - the difference between the top left hand
08:11 - coordinates so that we can overlap these
08:14 - masks in the appropriate region to
08:16 - determine if pixels are collide so i
08:19 - want to calculate the displacement in x
08:21 - and the displacement in y so then i know
08:23 - the total displacement and then i can
08:25 - align these masks properly before i do
08:27 - the collision so if this is my calling
08:30 - mask and this is the mask that i want to
08:32 - find the offset on well i just need to
08:34 - find that i'll show you how we do that
08:35 - in code and then that's one of the
08:37 - values that we need to pass to kind of
08:39 - our mass collision function so that we
08:41 - can overlap these masks in the correct
08:43 - area
08:44 - all right that's my explanation of masks
08:46 - hopefully that was good enough for you
08:48 - now we are going to actually do this
08:50 - first thing we need to do though is
08:51 - create masks
08:53 - so to do this we're going to say track
08:55 - underscore border underscore mask now
08:58 - this is the whole point of having this
09:00 - track border is that we're going to use
09:01 - this border let's go to it quickly here
09:03 - as our mask this will be one mask and
09:06 - then we will compare this to the car our
09:08 - player car and we will see if these two
09:10 - masks are colliding with each other and
09:13 - this is actually really easy to use
09:14 - because its corner is zero zero right
09:16 - its top position is zero zero which
09:18 - actually just makes it way simpler for
09:19 - us to do the offset calculation so i'm
09:22 - not going to do scale image i'm going to
09:23 - do high game dot and this is going to be
09:27 - mask dot from underscore surface and
09:30 - we're just going to pass in here the
09:31 - surface we want the mask of which is our
09:33 - track board easy enough that's how you
09:35 - get a mask
09:36 - okay so we have that mask
09:38 - now what i want to do is make a method
09:41 - inside of my abstract car class it will
09:43 - go inside of abstract car because this
09:45 - is going to be for both the computer and
09:47 - my player and i will call this collide
09:49 - now we're going to take in self mask x
09:51 - equals 0 and y equals 0.
09:55 - with the point being we're going to pass
09:57 - some other mask here we'll generate a
09:58 - mask for our own image we'll then have
10:01 - the x and the y of the other mask we
10:02 - obviously already have the x and the y
10:04 - of the car we will determine if two
10:06 - masks are colliding in here so i'm going
10:08 - to start by saying
10:09 - car underscore mask is equal to pygame
10:12 - dot mask dot from underscore surface and
10:16 - this will be self.img so whatever image
10:18 - we're using for this car
10:20 - then we are going to calculate the
10:21 - offset now the offset needs to be
10:24 - integer values so keep that in mind so
10:26 - i'm just going to say int int like this
10:28 - and the reason we need that is because
10:30 - we could get some floating value when we
10:31 - do the subtraction we need to calculate
10:34 - the offset x and the offset y now the
10:37 - offset is relative to the calling mask
10:39 - in this case we're going to say
10:42 - i guess
10:43 - collision or actually go with poi which
10:46 - stands for point of intersection is
10:48 - equal to and then this will be mask dot
10:51 - and i believe this is called overlap
10:54 - of the car mask
10:56 - with the offset so we're going to use
10:58 - the other mask as the calling mask which
11:00 - is going to dictate how we calculate the
11:02 - overlap if we did the other way we need
11:04 - to flip the over or the
11:05 - not the overlap the offset sorry okay
11:08 - inside of int i'm going to say
11:10 - we're going to go with x minus self.x
11:14 - and y
11:15 - minus self.y or is the other way around
11:18 - let's see of course i've done it
11:19 - incorrectly it's going to be the other
11:20 - way around self.x
11:22 - minus x
11:24 - and self.y minus y
11:27 - okay so the reason why we're using this
11:29 - as our offset again is because the
11:31 - calling mask is the other mask that
11:34 - we're passing so we're going to take
11:35 - whatever our current x position is
11:37 - whatever our current y position is and
11:40 - we're going to subtract that
11:42 - from the x and the y of the other mask
11:45 - now that will give us the displacement
11:47 - between the two masks if we did this the
11:49 - other way around that'd be fine but we
11:51 - would then have to swap this and say the
11:53 - car mask is calling the uh
11:56 - the other mask okay so that's how that
11:57 - would work
11:58 - hopefully that makes a bit of sense the
12:00 - reason we're converting this in again is
12:01 - because we need integer values for the
12:03 - offset we cannot have floating points
12:05 - and our self.x and self.y can be
12:07 - floating point values
12:09 - okay so now that we have that this is
12:11 - going to return to us the point of
12:12 - intersection between these two masks if
12:15 - there is one now we don't actually care
12:17 - what that point is at least not right
12:19 - now we're just going to return
12:21 - the poi
12:23 - now what we can do to determine if two
12:24 - objects have collided is we can see if
12:27 - the poi is equal to none or not if there
12:29 - is no poi the two objects didn't collide
12:32 - if there was a poi then they did collide
12:34 - so now we have collide so i'm going to
12:37 - go inside of here and i'm going to check
12:39 - for this collision so i'm going to say
12:41 - if we're going to go car underscore
12:43 - player
12:45 - dot collide and we're going to do this
12:48 - with what mask was it this was going to
12:50 - be the track border mask
12:53 - and notice that i don't actually need to
12:55 - password an x and a y here because the
12:57 - track border is positioned at 0 0. now
13:00 - we actually haven't even drawn the track
13:03 - border but that's fine because
13:06 - we don't need to we don't need to draw
13:08 - the track border right now
13:09 - because we just know that it's going to
13:11 - be at the exact same position as where
13:13 - our current track is on the screen
13:15 - because the track border and the track
13:17 - are the exact same size they're pretty
13:19 - much the same image except one is just
13:20 - the border the other is not so we don't
13:22 - need to draw it but we can still use the
13:23 - mask and we know its location is going
13:25 - to be zero zero
13:26 - okay so we have that if player
13:28 - underscore car.collide track border we
13:31 - can say does not equal none there then
13:33 - what we can do right now is we can just
13:34 - print collide
13:37 - and that way it's really easy for us to
13:38 - see if we actually have collided we can
13:40 - just look in our console and see if well
13:42 - we had a clyde so let's run this and
13:46 - pygame.surfaceobject has no attribute
13:48 - overlap
13:49 - okay let me go here uh okay car mask pie
13:53 - game dot mask surface mask dot overlap
13:57 - ah i realized what i did here i passed
13:59 - the track border when i meant to pass
14:01 - the track border mask okay so make sure
14:04 - you've actually passed the mask that was
14:05 - the point of creating it
14:06 - let's run this now
14:08 - and okay we're all good so now watch
14:10 - what happens when i go into the wall
14:12 - notice i get a bunch of collisions and
14:14 - then when i get off the wall it stops
14:16 - for a second and if i go back to the
14:18 - wall it continues printing glide now you
14:20 - can't really see it because my whole
14:22 - console's filled with collide but let's
14:24 - quit this and
14:26 - clear and run again
14:28 - and i'll show you let's turn
14:30 - and let's go here and then we get a
14:32 - bunch of clients as soon as we hit the
14:34 - one okay so that is the idea behind the
14:37 - collision
14:38 - that's really all you need to know for
14:40 - calculating collision
14:41 - now that we have done that we need to do
14:43 - something when we hit the wall we can't
14:45 - let our car drive through the wall so
14:47 - what i'm going to implement now is a
14:49 - bounce so if you hit the wall you're
14:50 - going to bounce off the wall with the
14:52 - same velocity that you hit the wall with
14:55 - right i guess we could go into the laws
14:57 - of uh physics laws of physics laws of
14:59 - motion maybe is what it's called if you
15:01 - hit something with a certain velocity
15:03 - then you're gonna go back in that same
15:05 - direction right just like when you throw
15:06 - a ball off of a wall it comes back and
15:08 - you're gonna lose a bit of velocity but
15:10 - point being you know law of physics i
15:12 - want to explain more than that so inside
15:14 - of my player car i'm going to implement
15:17 - a method which is going to be bounce i'm
15:19 - going to say define bounce
15:21 - self now all i need to do inside of
15:23 - bounce is i just need to reverse the
15:25 - velocity so i'm going to say self.bell
15:27 - is equal to negative self.vel now this
15:30 - will work if we're going backwards or
15:32 - forwards because if we're going
15:33 - backwards the velocity is already
15:34 - negative so this will then make it
15:36 - positive so we go forward and if the
15:38 - velocity is positive then it just makes
15:40 - it negative right and then of course
15:41 - we'll just say self.move so we start
15:43 - moving as soon as we reverse the
15:45 - velocity so now all we need to do
15:48 - is here say
15:50 - self.bounce
15:52 - and now if we hit a wall we just bounce
15:54 - and sorry this is not self this is going
15:55 - to be player underscore car
15:57 - so if we hit a wall we collide we just
15:59 - bounce backwards and we'll go in the
16:01 - same well actually the complete opposite
16:03 - direction as the one that we hit the
16:04 - wall so we will continue in one second
16:07 - but i need to quickly thank the sponsor
16:08 - of this video and this series which is
16:10 - i'll go expert i'll go expert is the
16:12 - best platform to use when preparing for
16:14 - your software engineering coding
16:15 - interviews they have over 160 coding
16:18 - interview questions in many different
16:20 - categories they have heaps they have
16:21 - arrays they have linked lists everything
16:23 - that you could imagine and that you need
16:25 - to prepare for your software engineering
16:26 - interviews is available at algo expert
16:29 - check them out from the link in the
16:30 - description and use the code tech with
16:31 - tim for a discount on the platform okay
16:34 - so now that we have that let's run the
16:35 - code and see if this is working
16:38 - and let's try it out and notice that i
16:40 - am bouncing off the walls
16:42 - there you go that is what i would expect
16:44 - now this is a little bit glitchy i won't
16:46 - lie this isn't always going to work
16:47 - perfectly every single time and you'll
16:49 - notice that sometimes you will kind of
16:51 - hit a wall even though you don't really
16:52 - see a wall that's just because my image
16:54 - is
16:55 - kind of messed up a little bit the way
16:57 - that i had it and so you might be
16:58 - hitting some pixels that you can't
17:00 - actually really see
17:01 - anyways this is working good enough for
17:03 - me i'm i'm happy with the bounce and so
17:05 - we're going to move on to the next thing
17:07 - okay so we have now handled the
17:09 - collision with our walls and you'll
17:10 - actually notice now that you can't go
17:12 - outside of those bounds because well you
17:14 - just can't right if you hit any of the
17:15 - walls then you're going to bounce back
17:16 - inside so now we need to make it so that
17:18 - you can hit the finish line right so
17:21 - let's start drawing the finish line on
17:23 - the screen let's handle collision with
17:25 - the finish line but you'll notice that
17:27 - this is a little bit trickier than it
17:28 - seems because we have to know what
17:30 - direction we cross the finish line from
17:32 - because if the finish line is where we
17:34 - start right kind of starting line finish
17:35 - line
17:36 - if we just drive directly backwards we
17:38 - can't say that we've won the race we
17:40 - have to hit it from the other direction
17:41 - so we have to handle that
17:43 - okay let's go here though
17:45 - we have finish
17:46 - now let me see if i need to scale this
17:48 - rather than just messing around with it
17:50 - let's see if i did scale it in my
17:53 - my code previously
17:55 - looks like i did not scale it so that's
17:58 - good we can just leave it where it is
17:59 - but i do need to determine the position
18:01 - of the finish line
18:03 - so i'm going to say finish underscore
18:04 - position
18:05 - is equal to and i've already figured
18:07 - this out for you it's going to be 130
18:09 - and 250. so now let's just draw this in
18:12 - that position and let's see what it
18:14 - looks like so i'm going to go to my
18:15 - images here and i'm going to add that as
18:17 - one of the images
18:19 - so i'm going to say finish i'm going to
18:20 - draw this at the finish
18:22 - underscore
18:24 - position like that
18:25 - so now let's run the code and let's see
18:28 - what we get notice the finish line is
18:29 - right here all right so there you go the
18:31 - finish line is up now this looks fine
18:33 - however we can see it is kind of
18:35 - overlapping with our track
18:37 - so what i'm going to do is just draw the
18:39 - track border over top of this so that
18:42 - way we get rid of any of these edges
18:44 - that are being cut off so this is kind
18:46 - of a neat solution that we can go with
18:48 - here what i'm going to do is just add
18:51 - inside of my images here
18:53 - and make sure you do it after the finish
18:55 - line by the way otherwise it won't go
18:56 - over top of the finish line i'm going to
18:58 - say track underscore border and we'll
19:00 - just draw this at position 0 0
19:04 - not 0 m 0 0
19:06 - make sure we add our last bracket there
19:08 - and let's run this now and parentheses
19:11 - does not match did i
19:14 - mess something up okay that looks good
19:16 - all right so now let's see this and
19:17 - notice that now the finish line is no
19:19 - longer overlapping the reason for that
19:22 - is it is actually overlapping but we're
19:23 - just drawing over top of it just the
19:25 - track border
19:26 - so that way everything looks good and
19:28 - then there you go our car is now moving
19:30 - around let's see if we bounce and we do
19:32 - sweet
19:33 - okay so that is good
19:35 - now that we have done that we want to
19:36 - handle colliding with the finish line
19:39 - so
19:40 - now we're going to do another thing down
19:41 - here
19:42 - we're going to say if player underscore
19:44 - car
19:45 - dot collide and now we need to get a
19:48 - uh sorry what is this a mask for the
19:50 - finish line so let's generate a mask for
19:53 - the finish line we'll do that from
19:55 - up here
19:57 - where is the finish line right here
20:00 - okay we're going to say finish
20:02 - underscore mask is equal
20:04 - to pie game dot mask dot from surface
20:07 - and then finish okay we now have the
20:10 - finish mask so now we're gonna say
20:12 - playercard.collide
20:14 - we're gonna go with finish underscore
20:15 - mask
20:16 - and then we need to pass
20:18 - the finish position
20:20 - but with an asterisk what this does
20:23 - is split the tuple that is storing this
20:25 - position so x and y into two individual
20:28 - coordinates and passes this to the uh
20:31 - the function as two arguments so if you
20:33 - do asterisk finished position this is
20:35 - the same as passing 130 and 250. okay
20:39 - they're identical but i figured i would
20:40 - show this to you because it's
20:41 - interesting python syntax anyways we're
20:44 - going to say again if that is not equal
20:46 - to a none then what we want to do now is
20:49 - just print
20:52 - finish okay
20:53 - so now let's see if we can check for
20:55 - collision with the finish line so i'm
20:56 - just going to go backwards and notice we
20:58 - get a bunch of finishes and then if i go
20:59 - up here
21:00 - we get finishes again
21:02 - so the thing is as i was saying
21:04 - we don't want to be able to just drive
21:07 - backwards and say oh yeah you finished
21:09 - in fact if we drive backwards we don't
21:11 - want to be able to go past the finish
21:12 - line we should only be able to go
21:13 - forward on the track we shouldn't be
21:15 - able to go backwards and cross the
21:16 - finish line
21:17 - so this is where i'm actually going to
21:19 - use the point of intersection to
21:21 - determine what direction i hit the
21:23 - finish line from so rather than just
21:26 - printing finish here i'm actually going
21:27 - to store this
21:29 - and i'm going to say
21:30 - finish
21:31 - poi
21:32 - collide
21:34 - uh yeah i guess that makes sense finish
21:35 - point of interest collide is equal to
21:37 - that and then instead of all this we'll
21:40 - just say
21:41 - finish
21:42 - poi collide and we will print out
21:46 - the finished poi collide okay so let's
21:49 - run this and now let's go backwards and
21:52 - notice that we get a bunch of zeros as
21:54 - we're going backwards right so if i keep
21:57 - going back here
21:58 - let's go back back back
22:00 - let's just go slow here notice all of
22:02 - these are zero zero zero zero okay and
22:04 - then as soon as
22:06 - i guess the top of my car kind of gets
22:09 - to the middle of the finish line here we
22:11 - get some actual values for the y
22:13 - coordinate so what we can do is we can
22:15 - just check if the y coordinate of the
22:17 - point of intersection is zero and if
22:19 - it's zero that means we hit it from the
22:21 - top so coming down if it's not that
22:23 - means we hit it from the bottom and we
22:25 - actually finished meaning we went all
22:26 - the way around the track
22:28 - so let me show you what i mean
22:29 - we're going to say
22:31 - if
22:32 - the finished poi collide at index 1 is
22:35 - equal to 0
22:36 - then car.bounce
22:39 - so just like when we hit the wall this
22:41 - is actually going to be
22:42 - playercard.bounce we're just going to
22:43 - bounce meaning we're going to bounce
22:44 - ourselves kind of up i guess if we're
22:46 - going backwards trying to hit the finish
22:48 - line
22:48 - let's run this
22:50 - notice when i go backwards now i bounce
22:52 - forwards because i'm trying to cross the
22:54 - finish line from the wrong direction
22:56 - now let's go all the way around
22:58 - and this will take a second here but
23:00 - let's see if we bounce when we go from
23:02 - the other direction
23:03 - okay we got to slowly make our way
23:05 - through the track
23:07 - we can just test my driving skills here
23:09 - while i
23:10 - try to fill in the silence because
23:12 - there's nothing to talk about
23:14 - okay
23:15 - looks good so far
23:17 - maybe we need to increase the speed of
23:18 - this car for debugging because this this
23:20 - could take a long time if i leave it at
23:23 - the speed of four
23:24 - okay almost there
23:26 - last two bends here
23:28 - all right coming around and
23:32 - notice we only bounce when we hit the
23:34 - top of the finish line right like i can
23:36 - go on to the finish line like that it's
23:38 - only when i get to the top that i'm
23:40 - actually bouncing so that's exactly what
23:41 - we wanted
23:42 - now we can just implement what happens
23:44 - if we cross the finish line from the
23:45 - correct direction so i'm just going to
23:47 - put an else here
23:49 - because if we collided with the finish
23:51 - line but our y coordinate was not zero
23:53 - that means we actually finished so in
23:54 - this case we will just
23:56 - print finish and i'll actually implement
23:58 - kind of the finish behavior in the next
24:01 - video but for now we can add a few more
24:03 - methods to our cars
24:05 - so i'm going to go to my abstract car
24:08 - class here and i'm just going to define
24:10 - another method i'm going to call this
24:11 - reset now what this is going to do is
24:13 - reset our car position so kind of
24:15 - preparing for the next level right so
24:17 - all we'll do is we'll say self.x self.y
24:21 - is equal to self.start underscore
24:23 - position
24:24 - we then need to reset the angle so
24:26 - self.angle is equal to zero we need to
24:29 - say self.velocity is equal to 0 as well
24:32 - and then is there anything else that we
24:33 - need to reset
24:35 - i don't think so let's see
24:38 - rotation velocity max velocity no that
24:40 - looks good to me we can just do that
24:42 - okay so now how about we say that if we
24:45 - cross the finish we'll reset the car
24:47 - we'll set flare
24:48 - underscore car
24:50 - dot reset i'm just going to increase the
24:52 - speed of my car so let's make this a
24:54 - speed of 8 and we'll go with rotational
24:56 - velocity of 8 as well just so that we
24:57 - can turn at the same speed we can move
24:59 - forward and let's run this and let's see
25:02 - if we go any faster
25:03 - okay so we can indeed go faster but we
25:05 - do have to wait to accelerate and oh
25:07 - gosh that's a crazy balance okay maybe
25:09 - we should make the bounce a little less
25:11 - harsh
25:12 - and maybe the lower speed was was better
25:14 - oh my gosh okay
25:16 - all right all right
25:18 - let's uh
25:20 - try to get around this bend here
25:23 - okay yeah so i think the speed of eight
25:24 - maybe is is too fast uh we also could
25:27 - just try spawning the car right before
25:29 - the finish line that would probably be
25:30 - easier too but you guys can just watch
25:32 - me struggle here
25:34 - okay let's go and you're noticing that
25:36 - sometimes we're hitting like a wall
25:37 - that's not actually there again kind of
25:39 - unavoidable but as you saw there as i
25:41 - hit the finish line we spawned on top of
25:44 - the finish line we reset the car and
25:45 - everything was good
25:47 - great so with that that pretty much
25:49 - covers everything i need to go through
25:51 - in this video i'm trying to think if
25:52 - there's anything else i can show you but
25:54 - i think for now that is fine in the next
25:57 - video we're going to implement the
25:58 - computer car all right so the computer
26:00 - car moving around and as i said in the
26:02 - last video we'll do all of the kind of
26:03 - logic of starting the different levels
26:05 - moving the speed of the computer car
26:07 - faster you know that nice fancy text on
26:10 - the screen and really making the game an
26:12 - actual playable game anyways i hope you
26:14 - all enjoyed if you did make sure to
26:15 - leave a like subscribe the channel i
26:17 - will see you in another one
26:20 - [Music]
26:26 - you

Cleaned transcript:

all right so i am back with video 2 in this series in this video we're going to be talking about collision and handling pixel perfect collision actually anyways first thing i want to do is actually make it so our car can move backwards because well we didn't do that in the last video and i meant to show that so let's do that now so to move backwards is very easy in fact it's the exact same as moving forwards except we just need to modify the velocity and everything a little bit so we're going to go and make another method here and this is going to be called move backward and inside of here we're going to say self.bell is equal to the maximum of and this is going to be self.velocity minus self.acceleration when we move backwards we need to subtract the acceleration because we're trying to go in the opposite direction so we want a negative velocity to be moving backwards because it's like the reverse gear in your car you don't turn around and go backwards you can just rotate the wheels in the other direction which is what we're going to do here and then this needs to be self.max val over 2. i don't know why i deleted that the idea of this is that we want sorry this needs to be negative is that we want the maximum possible negative velocity to be half of the velocity going forward the reverse gear in your car you cannot go up to 100 miles per hour right you can only go a certain speed there's a top speed in that so same thing here we're going to make it so when you go in reverse you're going slower than when you are going forward i don't know why that's super important but that's what we're doing so self.velocity minus self.acceleration and then negative self.max velocity over two just splitting that in half i think that's pretty selfexplanatory let's now make it so we have a key that does that so we're just going to copy this and i'm just going to change this now to key this is going to be s s will go backwards and then we'll change this to be backward like that notice i have moved equals true we need that to make sure we don't reduce our speed as we are going backwards perfect now that we have that let's run the code and let's check if the reverse gear works so now i can move backwards and notice i cannot go backwards at the same speed that i can go forwards right i can go at half the speed great there you go backwards is working if you try to turn when you're going backwards you'll notice that the turning works and you actually should be turning in the inverse direction which is correct and that's why we set up all this stuff so that it just works when we add other things in the future great so what i want to do is just clean up the code a little bit here i want to take all of this stuff so keys moved all of the stuff related to moving my player and i want to make a function here and i'm going to call this move underscore player now inside of here we will just take the player card so we'll say player underscore car like that and then we could perform all of this stuff simply using player car okay so again just trying to clean this up so now inside of here i'm going to say move underscore player and i'm going to pass my player car and this will handle all the movement let me just get rid of that let's run this and let's make sure it's still working and it is we are all good okay one more small refactor i want to do is i just want to go and grab this reduce speed method here and put this inside of my car class reason being that my computer which is going to inherit from this abstract car class as well does not need to be able to reduce its speed it's going to be the same speed the whole time and so it makes sense to have this in the class where it's actually going to be used because it's not going to be used by anything else that implements the abstract car class you could leave it in there there's arguments for both but i am just going to move it here great so everything will continue to work we don't need to test that moving forward though the next thing i want to do is collision so this is where we need to talk about masks and we need to talk about how you actually handle collision of different objects in python so what i'm going to do is open up paint here we're going to start talking about masks all right so i'm inside of paint here and i'm gonna explain to you masks and how we do pixel perfect collision so let's start with traditional collision and then we can explain pixel perfect collision so let's say we have some object and let's just make it a circle for simplicity now remember i told you that every single surface in pi game is really a rectangle so even if this is all that we're showing we actually have a rectangle around this circle here so we might not see the rectangle and the reason we wouldn't see it is because all of these pixels here would be transparent pixels they wouldn't show up on the screen but they're still there it's still rectangle so let's say we have another image and let's just do it like this and maybe inside of here i don't know we have some green whatever okay this is what this image looks like point being is that these two rectangles the rectangles containing these two images are overlapping this is the overlapping area right here however if we're looking at these two images remove the rectangles they're not colliding with each other right the pixels that are present in both of the these images are not touching each other but if we were to use traditional collision which is just rectangular collision you just check if two rectangles are lying inside of each other then it would say that these two objects are colliding and this is the overlapping area but again the pixels in the images are not actually colliding so how do we fix this because i don't want it to show me that two objects are colliding unless the pixels on the screen actually look like they are colliding this is where we use something known as a mask now what a mask is is an array of values representing whether or not a pixel in an image is transparent or present whether it just exists it's not a transparent pixel now the point of a mask is that rather than performing rectangular collision like this we can simply check if pixels that are not transparent are overlapping into rectangular regions so let's clear all of this and now let's look at an example of a mask let's say we have a very simple image okay i'm going to just go with a rectangle because it's easier here and we have maybe something like this okay we have pixels all in here pixels all in here and then inside of the other two regions is transparent okay and now we have another image and let's just do something like this and maybe we only have pixels inside of this bottom left hand corner well the mask for these two images would look like this it's just going to be an array so we'd have a large array it's going to be a twodimensional array and we would have one comma zero okay and again excuse me i'm using the mouse here and then zero comma one like that now for this image it would be similar but we're going to have nothing in the first row because we have no nontransparent pixels and then we would go here and we would have 0 comma 1 like that okay now let's imagine these masks are directly on top of each other the two objects are completely on top of each other then what we would do is we would just compare values in these arrays and see if two ones are at the same position right so we check here so okay there's no one here so we're not colliding in this region okay then we go here so okay there's no ones there so we're not colliding there we go here okay no ones we're not colliding and boom we find two ones which means we're colliding in this region right here and so we would say okay yes we are colliding because two pixels that are not transparent are touching each other there you go perfect that's all you need to know however it gets a little bit more complicated because we need to know the location of both of these masks before we can do this comparison in the example i just showed you we just imagine they were on top of each other so if i select this and i grab it it's going to be a bit rough but we imagine this mask was right on top of the other one and in that case it was really easy to check if they were colliding but what if the mask is sitting somewhere like this or sitting here or sitting up here well we need to know that and that's known as the offset so we have something and actually let's make a new file here we have something known as our calling mask and then i guess the mask that it's being called on so let's say that this here is our calling mask and then this is the mask that this mask is being called on well we need to determine the difference between the top left hand coordinates so that we can overlap these masks in the appropriate region to determine if pixels are collide so i want to calculate the displacement in x and the displacement in y so then i know the total displacement and then i can align these masks properly before i do the collision so if this is my calling mask and this is the mask that i want to find the offset on well i just need to find that i'll show you how we do that in code and then that's one of the values that we need to pass to kind of our mass collision function so that we can overlap these masks in the correct area all right that's my explanation of masks hopefully that was good enough for you now we are going to actually do this first thing we need to do though is create masks so to do this we're going to say track underscore border underscore mask now this is the whole point of having this track border is that we're going to use this border let's go to it quickly here as our mask this will be one mask and then we will compare this to the car our player car and we will see if these two masks are colliding with each other and this is actually really easy to use because its corner is zero zero right its top position is zero zero which actually just makes it way simpler for us to do the offset calculation so i'm not going to do scale image i'm going to do high game dot and this is going to be mask dot from underscore surface and we're just going to pass in here the surface we want the mask of which is our track board easy enough that's how you get a mask okay so we have that mask now what i want to do is make a method inside of my abstract car class it will go inside of abstract car because this is going to be for both the computer and my player and i will call this collide now we're going to take in self mask x equals 0 and y equals 0. with the point being we're going to pass some other mask here we'll generate a mask for our own image we'll then have the x and the y of the other mask we obviously already have the x and the y of the car we will determine if two masks are colliding in here so i'm going to start by saying car underscore mask is equal to pygame dot mask dot from underscore surface and this will be self.img so whatever image we're using for this car then we are going to calculate the offset now the offset needs to be integer values so keep that in mind so i'm just going to say int int like this and the reason we need that is because we could get some floating value when we do the subtraction we need to calculate the offset x and the offset y now the offset is relative to the calling mask in this case we're going to say i guess collision or actually go with poi which stands for point of intersection is equal to and then this will be mask dot and i believe this is called overlap of the car mask with the offset so we're going to use the other mask as the calling mask which is going to dictate how we calculate the overlap if we did the other way we need to flip the over or the not the overlap the offset sorry okay inside of int i'm going to say we're going to go with x minus self.x and y minus self.y or is the other way around let's see of course i've done it incorrectly it's going to be the other way around self.x minus x and self.y minus y okay so the reason why we're using this as our offset again is because the calling mask is the other mask that we're passing so we're going to take whatever our current x position is whatever our current y position is and we're going to subtract that from the x and the y of the other mask now that will give us the displacement between the two masks if we did this the other way around that'd be fine but we would then have to swap this and say the car mask is calling the uh the other mask okay so that's how that would work hopefully that makes a bit of sense the reason we're converting this in again is because we need integer values for the offset we cannot have floating points and our self.x and self.y can be floating point values okay so now that we have that this is going to return to us the point of intersection between these two masks if there is one now we don't actually care what that point is at least not right now we're just going to return the poi now what we can do to determine if two objects have collided is we can see if the poi is equal to none or not if there is no poi the two objects didn't collide if there was a poi then they did collide so now we have collide so i'm going to go inside of here and i'm going to check for this collision so i'm going to say if we're going to go car underscore player dot collide and we're going to do this with what mask was it this was going to be the track border mask and notice that i don't actually need to password an x and a y here because the track border is positioned at 0 0. now we actually haven't even drawn the track border but that's fine because we don't need to we don't need to draw the track border right now because we just know that it's going to be at the exact same position as where our current track is on the screen because the track border and the track are the exact same size they're pretty much the same image except one is just the border the other is not so we don't need to draw it but we can still use the mask and we know its location is going to be zero zero okay so we have that if player underscore car.collide track border we can say does not equal none there then what we can do right now is we can just print collide and that way it's really easy for us to see if we actually have collided we can just look in our console and see if well we had a clyde so let's run this and pygame.surfaceobject has no attribute overlap okay let me go here uh okay car mask pie game dot mask surface mask dot overlap ah i realized what i did here i passed the track border when i meant to pass the track border mask okay so make sure you've actually passed the mask that was the point of creating it let's run this now and okay we're all good so now watch what happens when i go into the wall notice i get a bunch of collisions and then when i get off the wall it stops for a second and if i go back to the wall it continues printing glide now you can't really see it because my whole console's filled with collide but let's quit this and clear and run again and i'll show you let's turn and let's go here and then we get a bunch of clients as soon as we hit the one okay so that is the idea behind the collision that's really all you need to know for calculating collision now that we have done that we need to do something when we hit the wall we can't let our car drive through the wall so what i'm going to implement now is a bounce so if you hit the wall you're going to bounce off the wall with the same velocity that you hit the wall with right i guess we could go into the laws of uh physics laws of physics laws of motion maybe is what it's called if you hit something with a certain velocity then you're gonna go back in that same direction right just like when you throw a ball off of a wall it comes back and you're gonna lose a bit of velocity but point being you know law of physics i want to explain more than that so inside of my player car i'm going to implement a method which is going to be bounce i'm going to say define bounce self now all i need to do inside of bounce is i just need to reverse the velocity so i'm going to say self.bell is equal to negative self.vel now this will work if we're going backwards or forwards because if we're going backwards the velocity is already negative so this will then make it positive so we go forward and if the velocity is positive then it just makes it negative right and then of course we'll just say self.move so we start moving as soon as we reverse the velocity so now all we need to do is here say self.bounce and now if we hit a wall we just bounce and sorry this is not self this is going to be player underscore car so if we hit a wall we collide we just bounce backwards and we'll go in the same well actually the complete opposite direction as the one that we hit the wall so we will continue in one second but i need to quickly thank the sponsor of this video and this series which is i'll go expert i'll go expert is the best platform to use when preparing for your software engineering coding interviews they have over 160 coding interview questions in many different categories they have heaps they have arrays they have linked lists everything that you could imagine and that you need to prepare for your software engineering interviews is available at algo expert check them out from the link in the description and use the code tech with tim for a discount on the platform okay so now that we have that let's run the code and see if this is working and let's try it out and notice that i am bouncing off the walls there you go that is what i would expect now this is a little bit glitchy i won't lie this isn't always going to work perfectly every single time and you'll notice that sometimes you will kind of hit a wall even though you don't really see a wall that's just because my image is kind of messed up a little bit the way that i had it and so you might be hitting some pixels that you can't actually really see anyways this is working good enough for me i'm i'm happy with the bounce and so we're going to move on to the next thing okay so we have now handled the collision with our walls and you'll actually notice now that you can't go outside of those bounds because well you just can't right if you hit any of the walls then you're going to bounce back inside so now we need to make it so that you can hit the finish line right so let's start drawing the finish line on the screen let's handle collision with the finish line but you'll notice that this is a little bit trickier than it seems because we have to know what direction we cross the finish line from because if the finish line is where we start right kind of starting line finish line if we just drive directly backwards we can't say that we've won the race we have to hit it from the other direction so we have to handle that okay let's go here though we have finish now let me see if i need to scale this rather than just messing around with it let's see if i did scale it in my my code previously looks like i did not scale it so that's good we can just leave it where it is but i do need to determine the position of the finish line so i'm going to say finish underscore position is equal to and i've already figured this out for you it's going to be 130 and 250. so now let's just draw this in that position and let's see what it looks like so i'm going to go to my images here and i'm going to add that as one of the images so i'm going to say finish i'm going to draw this at the finish underscore position like that so now let's run the code and let's see what we get notice the finish line is right here all right so there you go the finish line is up now this looks fine however we can see it is kind of overlapping with our track so what i'm going to do is just draw the track border over top of this so that way we get rid of any of these edges that are being cut off so this is kind of a neat solution that we can go with here what i'm going to do is just add inside of my images here and make sure you do it after the finish line by the way otherwise it won't go over top of the finish line i'm going to say track underscore border and we'll just draw this at position 0 0 not 0 m 0 0 make sure we add our last bracket there and let's run this now and parentheses does not match did i mess something up okay that looks good all right so now let's see this and notice that now the finish line is no longer overlapping the reason for that is it is actually overlapping but we're just drawing over top of it just the track border so that way everything looks good and then there you go our car is now moving around let's see if we bounce and we do sweet okay so that is good now that we have done that we want to handle colliding with the finish line so now we're going to do another thing down here we're going to say if player underscore car dot collide and now we need to get a uh sorry what is this a mask for the finish line so let's generate a mask for the finish line we'll do that from up here where is the finish line right here okay we're going to say finish underscore mask is equal to pie game dot mask dot from surface and then finish okay we now have the finish mask so now we're gonna say playercard.collide we're gonna go with finish underscore mask and then we need to pass the finish position but with an asterisk what this does is split the tuple that is storing this position so x and y into two individual coordinates and passes this to the uh the function as two arguments so if you do asterisk finished position this is the same as passing 130 and 250. okay they're identical but i figured i would show this to you because it's interesting python syntax anyways we're going to say again if that is not equal to a none then what we want to do now is just print finish okay so now let's see if we can check for collision with the finish line so i'm just going to go backwards and notice we get a bunch of finishes and then if i go up here we get finishes again so the thing is as i was saying we don't want to be able to just drive backwards and say oh yeah you finished in fact if we drive backwards we don't want to be able to go past the finish line we should only be able to go forward on the track we shouldn't be able to go backwards and cross the finish line so this is where i'm actually going to use the point of intersection to determine what direction i hit the finish line from so rather than just printing finish here i'm actually going to store this and i'm going to say finish poi collide uh yeah i guess that makes sense finish point of interest collide is equal to that and then instead of all this we'll just say finish poi collide and we will print out the finished poi collide okay so let's run this and now let's go backwards and notice that we get a bunch of zeros as we're going backwards right so if i keep going back here let's go back back back let's just go slow here notice all of these are zero zero zero zero okay and then as soon as i guess the top of my car kind of gets to the middle of the finish line here we get some actual values for the y coordinate so what we can do is we can just check if the y coordinate of the point of intersection is zero and if it's zero that means we hit it from the top so coming down if it's not that means we hit it from the bottom and we actually finished meaning we went all the way around the track so let me show you what i mean we're going to say if the finished poi collide at index 1 is equal to 0 then car.bounce so just like when we hit the wall this is actually going to be playercard.bounce we're just going to bounce meaning we're going to bounce ourselves kind of up i guess if we're going backwards trying to hit the finish line let's run this notice when i go backwards now i bounce forwards because i'm trying to cross the finish line from the wrong direction now let's go all the way around and this will take a second here but let's see if we bounce when we go from the other direction okay we got to slowly make our way through the track we can just test my driving skills here while i try to fill in the silence because there's nothing to talk about okay looks good so far maybe we need to increase the speed of this car for debugging because this this could take a long time if i leave it at the speed of four okay almost there last two bends here all right coming around and notice we only bounce when we hit the top of the finish line right like i can go on to the finish line like that it's only when i get to the top that i'm actually bouncing so that's exactly what we wanted now we can just implement what happens if we cross the finish line from the correct direction so i'm just going to put an else here because if we collided with the finish line but our y coordinate was not zero that means we actually finished so in this case we will just print finish and i'll actually implement kind of the finish behavior in the next video but for now we can add a few more methods to our cars so i'm going to go to my abstract car class here and i'm just going to define another method i'm going to call this reset now what this is going to do is reset our car position so kind of preparing for the next level right so all we'll do is we'll say self.x self.y is equal to self.start underscore position we then need to reset the angle so self.angle is equal to zero we need to say self.velocity is equal to 0 as well and then is there anything else that we need to reset i don't think so let's see rotation velocity max velocity no that looks good to me we can just do that okay so now how about we say that if we cross the finish we'll reset the car we'll set flare underscore car dot reset i'm just going to increase the speed of my car so let's make this a speed of 8 and we'll go with rotational velocity of 8 as well just so that we can turn at the same speed we can move forward and let's run this and let's see if we go any faster okay so we can indeed go faster but we do have to wait to accelerate and oh gosh that's a crazy balance okay maybe we should make the bounce a little less harsh and maybe the lower speed was was better oh my gosh okay all right all right let's uh try to get around this bend here okay yeah so i think the speed of eight maybe is is too fast uh we also could just try spawning the car right before the finish line that would probably be easier too but you guys can just watch me struggle here okay let's go and you're noticing that sometimes we're hitting like a wall that's not actually there again kind of unavoidable but as you saw there as i hit the finish line we spawned on top of the finish line we reset the car and everything was good great so with that that pretty much covers everything i need to go through in this video i'm trying to think if there's anything else i can show you but i think for now that is fine in the next video we're going to implement the computer car all right so the computer car moving around and as i said in the last video we'll do all of the kind of logic of starting the different levels moving the speed of the computer car faster you know that nice fancy text on the screen and really making the game an actual playable game anyways i hope you all enjoyed if you did make sure to leave a like subscribe the channel i will see you in another one you
