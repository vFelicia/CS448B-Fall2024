With timestamps:

00:00 - python is a fascinating language that
00:02 - contains a ton of hidden yet extremely
00:04 - useful and Powerful features in this
00:07 - video I'll share with you five of them
00:08 - that you need to understand if you want
00:10 - to fully grasp the language and come
00:12 - across as a professional now another way
00:14 - to come across as a professional is to
00:16 - join something like course careers
00:17 - software development program not only do
00:20 - we teach you all of the essential skills
00:22 - but we run you through in-depth career
00:24 - preparation more on that later now let's
00:26 - dive into the features the first feature
00:28 - to look at here is the anonymous
00:30 - variable now this is simply the
00:32 - underscore and this is used as a
00:33 - placeholder when you need to declare a
00:35 - variable but you don't care about the
00:37 - value of that variable so to give you a
00:39 - quick example let's say we want to do
00:41 - something 10 times what we could
00:43 - probably do is just create a for Loop
00:45 - and say 4 I in range and then we can
00:47 - type this correctly and put 10 and we
00:50 - can do you know print and then do this
00:53 - okay so this is valid this will run and
00:55 - we'll see do this 10 times but notice
00:57 - here that we're not actually using the
00:59 - value Val of the variable I it's not a
01:01 - huge problem this code is still going to
01:03 - run what we can do is replace this with
01:05 - an anonymous variable which is simply
01:07 - the underscore now this code will work
01:09 - perfectly fine now why would we do this
01:11 - well in some programs you actually have
01:13 - a linter or in some idees and you'll get
01:15 - kind of squiggly lines under your unused
01:17 - variables telling you to use them some
01:19 - code bases won't actually allow you to
01:21 - even push code if you have any linting
01:23 - errors and a lot of times it's just a
01:25 - little bit easier when you're not using
01:27 - a variable to Simply use the underscore
01:29 - inp place of it so that you don't get a
01:31 - syntax error and you don't have any
01:32 - confusion about what this variable is
01:34 - doing now as well as using this in a for
01:36 - Loop we can use it in a lot of other
01:37 - situations so here you see I have a
01:39 - coordinate now what I might want to
01:41 - actually do is unpack this coordinate
01:43 - and just get maybe the x or y value so
01:46 - traditionally I could do something like
01:47 - X comma Y is equal to my coordinate X
01:50 - will now be equal to 5 and Y will be
01:52 - equal to 10 however if I'm not going to
01:54 - use either of these values what I can do
01:57 - is replace them with an underscore now
01:59 - I'm still able to unpack this because I
02:01 - have something where the Y value would
02:03 - go but I don't need to declare a
02:05 - variable that I'm not going to end up
02:06 - using now same thing works if we're
02:08 - trying to unpack say the larger
02:10 - coordinate so if we copy this and paste
02:13 - this here we could do something like X
02:16 - comma underscore comma Z and now we're
02:18 - able to get the X and Zed values which
02:20 - we might need to use but we don't need
02:22 - to have an unused variable for the value
02:24 - y now similarly if we're doing something
02:25 - like a list comprehension so let's do
02:28 - something like second elements let's
02:29 - let's say I just want to get the second
02:31 - value out of all of these different
02:33 - pairs in this list well I can do this in
02:35 - a few different ways but if I do a list
02:36 - comprehension I could say second element
02:38 - equals B for underscore comma B in and
02:42 - then list of pairs and now if we go
02:44 - ahead and print out the second elements
02:47 - and we run our code you see that we get
02:49 - b d and f and we didn't have to declare
02:52 - a variable a that we don't end up using
02:54 - now believe it or not this next feature
02:56 - I didn't learn about until I was writing
02:58 - python code for over 3 years now this is
03:01 - the lse statement associated with a four
03:03 - or a w Loop now a lot of times when
03:05 - we're iterating over some type of
03:06 - structure what we're trying to do is
03:08 - find if some criteria is true or if it's
03:11 - False A lot of times we might be looking
03:12 - for an item or trying to see if the list
03:15 - satisfies some criteria now if that's
03:17 - the case we often want to do something
03:20 - with the list afterwards if it did or
03:22 - didn't satisfy that criteria and that
03:24 - means we need to actually have some kind
03:25 - of flag that tells us how we exited the
03:28 - loop what I mean by this is we could
03:30 - exit early because the criteria was true
03:33 - or we could exit after we iterated
03:35 - through all of the different items so
03:36 - let me give you a quick example to show
03:38 - you what I mean in this instance we have
03:40 - a wall Loop we iterate over this list
03:42 - and we try to see if the item B exists
03:45 - inside of the list now if we didn't have
03:47 - this flag that I'm setting here found
03:49 - equal to True when we reach the end of
03:51 - this wall Loop here we won't know why we
03:54 - exited we could have exited because we
03:56 - broke out of the loop by finding the
03:57 - item or because I became equal to the
04:00 - length of the items so we need to
04:02 - include this flag here and then we use
04:04 - the flag to do some type of operation
04:06 - however we actually don't need to
04:07 - include the flag because of this while
04:10 - else and for else syntax so let's remove
04:13 - this flag and let me show you how we
04:14 - could write this alternatively so rather
04:16 - than having if not found we can simply
04:19 - just put the else statement here now
04:21 - this is completely valid syntax and what
04:23 - this will do is print out do something
04:25 - here if we don't exit the loop from a
04:28 - break statement so let me just make this
04:30 - really clear this else statement will
04:32 - run if we don't break out of the loop
04:35 - now this works for both four or while
04:37 - loops and we can look at a quick example
04:38 - here so let's just do a print and just
04:41 - say found it and let's run the code and
04:44 - you'll see that we get found it now if I
04:46 - change this is something that's not in
04:48 - the list so say the value Zed and we
04:50 - rerun the code you see that we get do
04:52 - something here so the L statement will
04:54 - be triggered if you don't break out of
04:56 - the loop that it's associated with now
04:58 - we can easily switch this to a for loop
05:00 - as well so we can just say four and this
05:02 - will be item in items we can remove this
05:07 - and we'll see the exact same thing works
05:09 - if I run my code we get do something
05:11 - here so really some useful syntax
05:13 - whenever you're trying to determine
05:14 - whether you broke out because you found
05:16 - some criteria and Ed the break keyword
05:18 - or if you reach the very end of the list
05:21 - then what you can do is use this else
05:23 - syntax now before we get into this third
05:25 - feature I do want to let you know that I
05:26 - recently teamed up with some of the top
05:28 - software development instructors online
05:30 - for example one of them is webdev
05:32 - simplified we've created literally the
05:34 - best course online to help you land a
05:36 - software development job not only do we
05:39 - teach you all of the skills you need and
05:40 - run you through in-depth specializations
05:42 - in your desired topics so front end
05:44 - backend or devops we have a huge focus
05:47 - on your career so setting you up with
05:49 - the best templates for your resume
05:52 - interview prep how you answer specific
05:54 - questions what jobs to apply for how to
05:56 - optimize your LinkedIn we have literally
05:58 - everything in the course where the sole
06:00 - purpose is to help you land a job as
06:02 - quickly as possible if you're interested
06:04 - you can check it out from the link in
06:05 - the description we've got a free
06:07 - introduction course and obviously a no
06:09 - obligation 14-day money back guarantee
06:11 - so if you're not interested you can of
06:13 - course just refund the course no
06:14 - questions asked no risk we've already
06:16 - had a ton of success and I can't wait to
06:18 - see you guys there so the next feature
06:20 - to show you is something known as the
06:22 - wallrus operator now this was released
06:24 - in Python version 3.8 so make sure
06:26 - you're at minimum using that version now
06:28 - the wall operator looks like this it's a
06:30 - colon and an equal sign and it allows
06:33 - you to actually Define a value while
06:35 - using it as part of a condition really
06:38 - cool and I'm going to show you how we
06:39 - can use it to write more readable and
06:41 - clean code so I actually have a fairly
06:43 - complex example in front of me that's
06:44 - using something known as a generator now
06:46 - you don't need to worry too much about
06:48 - how the generator works but the idea
06:50 - here is that you see that this is
06:51 - looking a little bit messy what I'm
06:53 - doing is I'm defining a generator object
06:55 - and I'm saying data is equal to the next
06:58 - value that my generator is going to give
07:00 - me so it's going to yield me values and
07:01 - just keep giving me values until it runs
07:03 - out now what I say is while the data is
07:05 - not equal to1 which is the last value
07:08 - yielded I'm going to process this data
07:10 - and then I'm going to get the next value
07:12 - so this is something you might have seen
07:13 - before where you're continually getting
07:15 - some value processing it and then
07:17 - getting the next value but you're
07:19 - actually using the result of that as
07:21 - part of the condition in the wall Loop
07:23 - if this doesn't make sense don't worry
07:24 - I'm going to show you a few other
07:25 - examples so in this case it works but
07:27 - it's a little bit messy so the way we
07:29 - can clean this up is the following we
07:31 - can actually use the walrus operator so
07:33 - I'm going to put a set of parentheses
07:34 - and I'm going to say data colon equal to
07:37 - the next value from our generator and
07:40 - I'm going to say well this does not
07:42 - equal -1 now what this allows me to do
07:45 - is remove both of these lines and I'll
07:47 - just quickly show you that when I run
07:48 - the code this works as my code worked
07:51 - before so what exactly are we doing here
07:53 - well what we're doing is saying okay I
07:55 - want some variable data I need to use
07:57 - this variable later in my Loop but I
07:59 - also want the result of it to be a part
08:02 - of this condition in the W Loop so I say
08:04 - data colon equal to this is the wall
08:07 - operator sorry and then the next value
08:09 - from my generator and then I take
08:11 - whatever the result of this is and I say
08:13 - that does not equal to -1 now this
08:16 - allows me to use whatever the current
08:18 - value of data is inside of my Loop
08:20 - without having to Define it or reprocess
08:22 - it multiple times as well as have it be
08:25 - a part of this condition all right so
08:26 - here's another quick example of where we
08:28 - could use the wall operator to get some
08:30 - better and actually in this case more
08:31 - efficient code so let's imagine we have
08:33 - some function f ofx and let's say this
08:35 - is a pretty complicated function it
08:37 - might actually take a fair amount of
08:38 - time to run and it performs some
08:40 - operation on some numeric input now
08:42 - maybe what we want to do is we want to
08:44 - Loop through all of the numbers from 1
08:46 - to 10 we want to pass them to this
08:47 - function and we want to get the result
08:49 - of the function only if it gives us some
08:53 - certain criteria so in this case if the
08:54 - result is greater than three well what
08:56 - I'm doing right now is I'm saying okay
08:58 - I'm going to Loop through through the
08:59 - values from 0 to 9 and if f with the
09:03 - value so if we pass that value to F and
09:05 - it gives us something that's greater
09:06 - than three then I actually want to take
09:08 - whatever that result is and put that
09:10 - inside of my list this is a list
09:12 - comprehension in Python and what we're
09:14 - doing here is actually Computing the
09:15 - same value two times the reason we're
09:18 - doing that is because we have F ofx
09:20 - called twice so what we can actually do
09:22 - is clean this up using the walrus
09:24 - operator let me show you that example so
09:26 - you can see now we have some equivalent
09:28 - code but that's actually much more
09:29 - efficient and only calling the function
09:31 - one time what we've done is said okay
09:33 - we're going to use a variable result so
09:35 - we're going to say 4X in range 10 if and
09:38 - then we use the wallrus operator so we
09:40 - say result colon equal to F ofx we've
09:42 - now defined the result is equal to this
09:45 - computation or to this result we check
09:48 - if it's greater than three and if it is
09:50 - we use whatever that result is to
09:52 - populate our list this way we're only
09:54 - calling the function once this is much
09:56 - more efficient so moving on to feature
09:58 - number four we have argument and
10:00 - parameter unpacking this is super
10:03 - powerful and you're probably going to
10:04 - see this syntax quite a bit especially
10:06 - in more professional python code so
10:08 - let's have a look at this example here
10:10 - let's say we have some function that
10:11 - takes in four values a b c d could take
10:14 - in any number of values but in this case
10:15 - it takes in four and we have some list
10:17 - that has the corresponding values that
10:19 - we want to pass into this function so
10:22 - what we need to do if we want to pass
10:23 - those values access the first value the
10:25 - second value the third value and the
10:27 - fourth value we got to write them all
10:29 - now it's not a huge deal if we're just
10:31 - passing four five values whatever but if
10:32 - we got to pass a bunch of them it can be
10:34 - tedious and there's a better way to do
10:36 - this what we can use is something known
10:39 - as the asterisk or unpack operator I can
10:42 - actually write asteris LST and you'll
10:44 - see that if I run this code it operates
10:46 - as I'd expect I get 1 2 3 4 now what
10:50 - this asterisk operator will do is what I
10:52 - said it will unpack the values in an
10:54 - iterable object so this doesn't just
10:56 - work for lists it works for any type of
10:58 - object that's iterable and what it will
11:00 - do is take all of the values and pass
11:03 - them as the corresponding positional
11:04 - arguments inside of this function so it
11:07 - will pass one for a two for B three for
11:10 - C four for D Etc now this will work if
11:13 - we did a tle as well so if we simply
11:15 - change this to a tupple exact same thing
11:18 - will work and if we change this to like
11:20 - a string as long as it has the exact
11:22 - number of characters let's not do that
11:24 - one let's do uh okay oops I was going to
11:27 - do hello you see that we get oh k a y so
11:30 - anything that's iterable this will work
11:31 - for and just make sure that you have the
11:33 - correct number of values because if I do
11:35 - okay with two y's you'll see that we get
11:37 - an error here where it's trying to pass
11:39 - Five positional arguments but only four
11:41 - were listed now in the same way that
11:43 - that works we can actually do this for
11:45 - keyword arguments as well or for
11:47 - dictionaries so you can see here that we
11:49 - have a dictionary it contains key and
11:51 - Target equal to 5 and 10 now these are
11:53 - the corresponding parameter values that
11:55 - we have inside of our function now again
11:58 - similarly to before if we wanted to
12:00 - actually pass these values we need to
12:02 - say values key values Target like that
12:05 - to pass them in so if we run this you
12:07 - see it works and we print out five and
12:09 - 10 let's just clear this here however we
12:12 - can actually use a kind of double unpack
12:15 - or keyword unpack whatever you want to
12:16 - call this with the double asterisk
12:18 - operator on our dictionary so we can say
12:21 - asterisk a asterisk Sate values and what
12:24 - this will do is it will pass as keyword
12:26 - arguments the key equal to the value so
12:29 - what I can do is run this and you see
12:31 - that we get 510 and what's interesting
12:33 - if I were to change the order around
12:35 - here and go Target and key this is still
12:38 - going to work we still get five and 10
12:41 - really what this code is equivalent to
12:43 - is taking whatever the key values are so
12:45 - both key and Target writing those as
12:47 - keyword arguments and then making them
12:49 - equal to whatever their values are
12:51 - associated with so when I do ASX ASX
12:53 - value it's as if I WR wrote key equals 5
12:57 - and Target equals 10 which works really
12:59 - well for keyword arguments you just need
13:01 - to make sure the name of the keys match
13:03 - the name of the arguments that you have
13:05 - or the name of the parameter sorry you
13:06 - have inside your function so just
13:08 - remember the single asteris is when
13:10 - you're unpacking erable objects and the
13:12 - double asteris is when you're unpacking
13:14 - a dictionary and you're going to be
13:16 - passing these as keyword arguments so
13:18 - our final feature to go over here is
13:20 - something called the default dictionary
13:23 - now before we look at that let's look at
13:24 - a quick example of how we typically use
13:26 - a normal dictionary so the key thing to
13:29 - keep in mind here is when you try to
13:30 - access a key that does not exist in a
13:32 - dictionary you get an error now there's
13:34 - a few ways to handle that with normal
13:36 - dictionaries but it makes our code a
13:38 - little bit more messy and we have to
13:39 - handle a few different edge cases so
13:42 - here we have some dictionary character
13:43 - count and we're counting the frequency
13:45 - of all the characters in The String
13:47 - pretty famous problem so we Loop through
13:49 - the string and the first thing we need
13:50 - to do is check if the given character is
13:53 - not in the character count so it's not
13:55 - one of the existing keys if it's not we
13:57 - then assign its value to zero so that
14:00 - way when we go to access the key down
14:02 - here and increment it by one we don't
14:04 - get an error if I remove this line here
14:07 - and we run the code you'll see that I
14:09 - get a key error a because I try to
14:11 - access a key that doesn't exist in the
14:12 - dictionary so how can we get around this
14:15 - without having to have that syntax that
14:17 - I just showed you well python has a
14:19 - really interesting Library called
14:21 - collections what I can do is say from
14:26 - collections import the default
14:29 - dictionary Now the default dictionary is
14:31 - what's known as a subass of the normal
14:34 - dictionary that has some slightly
14:36 - different behavior sorate that allows us
14:38 - to automatically assign a default value
14:40 - when we access a key that doesn't yet
14:42 - exist so we can write default dictionary
14:45 - here rather than the normal dictionary
14:47 - syntax and what we need to pass to this
14:49 - is something known as the default
14:51 - Factory now this is simply a function
14:54 - that Returns what the default value
14:55 - should be so I'm going to say Define
14:58 - default
14:59 - okay and then here I'm simply going to
15:01 - return zero and then I'm going to put
15:04 - defaults like this but notice I don't
15:05 - call the function I just write the
15:07 - function name I know this is a bit
15:09 - strange but what's required is that we
15:11 - pass some function that when called will
15:14 - return a value that will be the default
15:16 - value for the dictionary when a key does
15:19 - not exist so what I can do now is run
15:21 - this code and you see we get the exact
15:23 - same result so we have all of the
15:25 - characters counted and we don't get a
15:26 - key error like we had before four so
15:29 - just to really recap this here this
15:31 - function is going to be called every
15:33 - single time we try to access a key that
15:36 - doesn't exist so as we iterate through
15:38 - this string we see the key a when we see
15:41 - the key a so we say Char count at a plus
15:43 - equal 1 we try to access the existing
15:46 - value to increment it by one but it
15:48 - doesn't exist so we call this default
15:50 - function it Returns the value zero that
15:53 - becomes the default value we then add
15:55 - one to that we repeat the process
15:57 - eventually we get get to B same thing we
16:00 - use zero as the default value and we
16:02 - keep going now one thing to note this
16:04 - default function does not take in any
16:06 - parameters it simply returns whatever
16:08 - the default value should be we could
16:10 - return a string we could return a list
16:12 - we can return really anything we want it
16:14 - could be another dictionary but you just
16:15 - need to put it inside a function then
16:18 - put the name of the function that you
16:19 - want to be that default Factory so with
16:22 - that said that's going to wrap up this
16:23 - video If you enjoyed make sure you leave
16:25 - a like and check out my channel for more
16:27 - python videos like these
16:30 - [Music]
16:36 - ones

Cleaned transcript:

python is a fascinating language that contains a ton of hidden yet extremely useful and Powerful features in this video I'll share with you five of them that you need to understand if you want to fully grasp the language and come across as a professional now another way to come across as a professional is to join something like course careers software development program not only do we teach you all of the essential skills but we run you through indepth career preparation more on that later now let's dive into the features the first feature to look at here is the anonymous variable now this is simply the underscore and this is used as a placeholder when you need to declare a variable but you don't care about the value of that variable so to give you a quick example let's say we want to do something 10 times what we could probably do is just create a for Loop and say 4 I in range and then we can type this correctly and put 10 and we can do you know print and then do this okay so this is valid this will run and we'll see do this 10 times but notice here that we're not actually using the value Val of the variable I it's not a huge problem this code is still going to run what we can do is replace this with an anonymous variable which is simply the underscore now this code will work perfectly fine now why would we do this well in some programs you actually have a linter or in some idees and you'll get kind of squiggly lines under your unused variables telling you to use them some code bases won't actually allow you to even push code if you have any linting errors and a lot of times it's just a little bit easier when you're not using a variable to Simply use the underscore inp place of it so that you don't get a syntax error and you don't have any confusion about what this variable is doing now as well as using this in a for Loop we can use it in a lot of other situations so here you see I have a coordinate now what I might want to actually do is unpack this coordinate and just get maybe the x or y value so traditionally I could do something like X comma Y is equal to my coordinate X will now be equal to 5 and Y will be equal to 10 however if I'm not going to use either of these values what I can do is replace them with an underscore now I'm still able to unpack this because I have something where the Y value would go but I don't need to declare a variable that I'm not going to end up using now same thing works if we're trying to unpack say the larger coordinate so if we copy this and paste this here we could do something like X comma underscore comma Z and now we're able to get the X and Zed values which we might need to use but we don't need to have an unused variable for the value y now similarly if we're doing something like a list comprehension so let's do something like second elements let's let's say I just want to get the second value out of all of these different pairs in this list well I can do this in a few different ways but if I do a list comprehension I could say second element equals B for underscore comma B in and then list of pairs and now if we go ahead and print out the second elements and we run our code you see that we get b d and f and we didn't have to declare a variable a that we don't end up using now believe it or not this next feature I didn't learn about until I was writing python code for over 3 years now this is the lse statement associated with a four or a w Loop now a lot of times when we're iterating over some type of structure what we're trying to do is find if some criteria is true or if it's False A lot of times we might be looking for an item or trying to see if the list satisfies some criteria now if that's the case we often want to do something with the list afterwards if it did or didn't satisfy that criteria and that means we need to actually have some kind of flag that tells us how we exited the loop what I mean by this is we could exit early because the criteria was true or we could exit after we iterated through all of the different items so let me give you a quick example to show you what I mean in this instance we have a wall Loop we iterate over this list and we try to see if the item B exists inside of the list now if we didn't have this flag that I'm setting here found equal to True when we reach the end of this wall Loop here we won't know why we exited we could have exited because we broke out of the loop by finding the item or because I became equal to the length of the items so we need to include this flag here and then we use the flag to do some type of operation however we actually don't need to include the flag because of this while else and for else syntax so let's remove this flag and let me show you how we could write this alternatively so rather than having if not found we can simply just put the else statement here now this is completely valid syntax and what this will do is print out do something here if we don't exit the loop from a break statement so let me just make this really clear this else statement will run if we don't break out of the loop now this works for both four or while loops and we can look at a quick example here so let's just do a print and just say found it and let's run the code and you'll see that we get found it now if I change this is something that's not in the list so say the value Zed and we rerun the code you see that we get do something here so the L statement will be triggered if you don't break out of the loop that it's associated with now we can easily switch this to a for loop as well so we can just say four and this will be item in items we can remove this and we'll see the exact same thing works if I run my code we get do something here so really some useful syntax whenever you're trying to determine whether you broke out because you found some criteria and Ed the break keyword or if you reach the very end of the list then what you can do is use this else syntax now before we get into this third feature I do want to let you know that I recently teamed up with some of the top software development instructors online for example one of them is webdev simplified we've created literally the best course online to help you land a software development job not only do we teach you all of the skills you need and run you through indepth specializations in your desired topics so front end backend or devops we have a huge focus on your career so setting you up with the best templates for your resume interview prep how you answer specific questions what jobs to apply for how to optimize your LinkedIn we have literally everything in the course where the sole purpose is to help you land a job as quickly as possible if you're interested you can check it out from the link in the description we've got a free introduction course and obviously a no obligation 14day money back guarantee so if you're not interested you can of course just refund the course no questions asked no risk we've already had a ton of success and I can't wait to see you guys there so the next feature to show you is something known as the wallrus operator now this was released in Python version 3.8 so make sure you're at minimum using that version now the wall operator looks like this it's a colon and an equal sign and it allows you to actually Define a value while using it as part of a condition really cool and I'm going to show you how we can use it to write more readable and clean code so I actually have a fairly complex example in front of me that's using something known as a generator now you don't need to worry too much about how the generator works but the idea here is that you see that this is looking a little bit messy what I'm doing is I'm defining a generator object and I'm saying data is equal to the next value that my generator is going to give me so it's going to yield me values and just keep giving me values until it runs out now what I say is while the data is not equal to1 which is the last value yielded I'm going to process this data and then I'm going to get the next value so this is something you might have seen before where you're continually getting some value processing it and then getting the next value but you're actually using the result of that as part of the condition in the wall Loop if this doesn't make sense don't worry I'm going to show you a few other examples so in this case it works but it's a little bit messy so the way we can clean this up is the following we can actually use the walrus operator so I'm going to put a set of parentheses and I'm going to say data colon equal to the next value from our generator and I'm going to say well this does not equal 1 now what this allows me to do is remove both of these lines and I'll just quickly show you that when I run the code this works as my code worked before so what exactly are we doing here well what we're doing is saying okay I want some variable data I need to use this variable later in my Loop but I also want the result of it to be a part of this condition in the W Loop so I say data colon equal to this is the wall operator sorry and then the next value from my generator and then I take whatever the result of this is and I say that does not equal to 1 now this allows me to use whatever the current value of data is inside of my Loop without having to Define it or reprocess it multiple times as well as have it be a part of this condition all right so here's another quick example of where we could use the wall operator to get some better and actually in this case more efficient code so let's imagine we have some function f ofx and let's say this is a pretty complicated function it might actually take a fair amount of time to run and it performs some operation on some numeric input now maybe what we want to do is we want to Loop through all of the numbers from 1 to 10 we want to pass them to this function and we want to get the result of the function only if it gives us some certain criteria so in this case if the result is greater than three well what I'm doing right now is I'm saying okay I'm going to Loop through through the values from 0 to 9 and if f with the value so if we pass that value to F and it gives us something that's greater than three then I actually want to take whatever that result is and put that inside of my list this is a list comprehension in Python and what we're doing here is actually Computing the same value two times the reason we're doing that is because we have F ofx called twice so what we can actually do is clean this up using the walrus operator let me show you that example so you can see now we have some equivalent code but that's actually much more efficient and only calling the function one time what we've done is said okay we're going to use a variable result so we're going to say 4X in range 10 if and then we use the wallrus operator so we say result colon equal to F ofx we've now defined the result is equal to this computation or to this result we check if it's greater than three and if it is we use whatever that result is to populate our list this way we're only calling the function once this is much more efficient so moving on to feature number four we have argument and parameter unpacking this is super powerful and you're probably going to see this syntax quite a bit especially in more professional python code so let's have a look at this example here let's say we have some function that takes in four values a b c d could take in any number of values but in this case it takes in four and we have some list that has the corresponding values that we want to pass into this function so what we need to do if we want to pass those values access the first value the second value the third value and the fourth value we got to write them all now it's not a huge deal if we're just passing four five values whatever but if we got to pass a bunch of them it can be tedious and there's a better way to do this what we can use is something known as the asterisk or unpack operator I can actually write asteris LST and you'll see that if I run this code it operates as I'd expect I get 1 2 3 4 now what this asterisk operator will do is what I said it will unpack the values in an iterable object so this doesn't just work for lists it works for any type of object that's iterable and what it will do is take all of the values and pass them as the corresponding positional arguments inside of this function so it will pass one for a two for B three for C four for D Etc now this will work if we did a tle as well so if we simply change this to a tupple exact same thing will work and if we change this to like a string as long as it has the exact number of characters let's not do that one let's do uh okay oops I was going to do hello you see that we get oh k a y so anything that's iterable this will work for and just make sure that you have the correct number of values because if I do okay with two y's you'll see that we get an error here where it's trying to pass Five positional arguments but only four were listed now in the same way that that works we can actually do this for keyword arguments as well or for dictionaries so you can see here that we have a dictionary it contains key and Target equal to 5 and 10 now these are the corresponding parameter values that we have inside of our function now again similarly to before if we wanted to actually pass these values we need to say values key values Target like that to pass them in so if we run this you see it works and we print out five and 10 let's just clear this here however we can actually use a kind of double unpack or keyword unpack whatever you want to call this with the double asterisk operator on our dictionary so we can say asterisk a asterisk Sate values and what this will do is it will pass as keyword arguments the key equal to the value so what I can do is run this and you see that we get 510 and what's interesting if I were to change the order around here and go Target and key this is still going to work we still get five and 10 really what this code is equivalent to is taking whatever the key values are so both key and Target writing those as keyword arguments and then making them equal to whatever their values are associated with so when I do ASX ASX value it's as if I WR wrote key equals 5 and Target equals 10 which works really well for keyword arguments you just need to make sure the name of the keys match the name of the arguments that you have or the name of the parameter sorry you have inside your function so just remember the single asteris is when you're unpacking erable objects and the double asteris is when you're unpacking a dictionary and you're going to be passing these as keyword arguments so our final feature to go over here is something called the default dictionary now before we look at that let's look at a quick example of how we typically use a normal dictionary so the key thing to keep in mind here is when you try to access a key that does not exist in a dictionary you get an error now there's a few ways to handle that with normal dictionaries but it makes our code a little bit more messy and we have to handle a few different edge cases so here we have some dictionary character count and we're counting the frequency of all the characters in The String pretty famous problem so we Loop through the string and the first thing we need to do is check if the given character is not in the character count so it's not one of the existing keys if it's not we then assign its value to zero so that way when we go to access the key down here and increment it by one we don't get an error if I remove this line here and we run the code you'll see that I get a key error a because I try to access a key that doesn't exist in the dictionary so how can we get around this without having to have that syntax that I just showed you well python has a really interesting Library called collections what I can do is say from collections import the default dictionary Now the default dictionary is what's known as a subass of the normal dictionary that has some slightly different behavior sorate that allows us to automatically assign a default value when we access a key that doesn't yet exist so we can write default dictionary here rather than the normal dictionary syntax and what we need to pass to this is something known as the default Factory now this is simply a function that Returns what the default value should be so I'm going to say Define default okay and then here I'm simply going to return zero and then I'm going to put defaults like this but notice I don't call the function I just write the function name I know this is a bit strange but what's required is that we pass some function that when called will return a value that will be the default value for the dictionary when a key does not exist so what I can do now is run this code and you see we get the exact same result so we have all of the characters counted and we don't get a key error like we had before four so just to really recap this here this function is going to be called every single time we try to access a key that doesn't exist so as we iterate through this string we see the key a when we see the key a so we say Char count at a plus equal 1 we try to access the existing value to increment it by one but it doesn't exist so we call this default function it Returns the value zero that becomes the default value we then add one to that we repeat the process eventually we get get to B same thing we use zero as the default value and we keep going now one thing to note this default function does not take in any parameters it simply returns whatever the default value should be we could return a string we could return a list we can return really anything we want it could be another dictionary but you just need to put it inside a function then put the name of the function that you want to be that default Factory so with that said that's going to wrap up this video If you enjoyed make sure you leave a like and check out my channel for more python videos like these ones
