With timestamps:

00:00 - hello everybody and welcome to part
00:01 - seven of this tutorial Series where
00:03 - we'll be getting into the architecture
00:05 - of cartei and talking about this more in
00:08 - depth compared to what we've gone over
00:09 - in previous videos now I'm going to
00:11 - start by giving you a general overview
00:13 - and summary of the main components that
00:15 - we're already familiar with just to make
00:17 - sure everyone is up to speed and
00:18 - remembers it then we're going to dive
00:20 - into some of the more complex components
00:22 - for example we're going to talk about
00:24 - consensus and we're going to talk about
00:25 - how cartez rollups are different than
00:28 - other types of Roll-Ups and why that's
00:30 - important for you to understand so let's
00:31 - begin by going through a highlevel
00:33 - overview of the main components of a
00:35 - caresia application so we have cares
00:37 - rollups caresi machine the DAP backend
00:40 - and the DAP front end now as we've seen
00:42 - here and we've looked at this diagram
00:44 - before what we're responsible for
00:45 - building is the front end and the back
00:47 - end the rest of the components are
00:49 - already built for us and they make up
00:50 - kind of the caresi rollups framework now
00:53 - as we saw in the previous video caresi
00:55 - rollups itself is a set of onchain and
00:58 - offchain components that implement ment
01:00 - the optimistic rollup solution now the
01:02 - onchain components include smart
01:04 - contracts right so for example input box
01:07 - part of caresia rollups our dap Factory
01:09 - again we need to deploy that onto the
01:11 - target Network then we have the caresan
01:14 - machine now this as we know is a virtual
01:16 - machine running an entire Linux
01:18 - operating system in which the dap's
01:20 - backend is executed now there's some
01:22 - more details related to this for example
01:24 - it runs a risk 5 architecture which is
01:27 - actually able to be hashed allows us
01:29 - full trans parency and gives us some
01:31 - features of the Cartesian machine which
01:32 - are important and actually kind of go
01:35 - into the security and details
01:37 - implementation Etc which we can talk
01:38 - about later regardless the caresan
01:40 - machine is where we run the daps backend
01:43 - now this is where we have the state and
01:45 - verifiable logic which corresponds to
01:47 - the smart contract this is what we wrote
01:49 - in Python and what we can write in
01:51 - pretty much any programming language
01:52 - that runs as a Linux application then we
01:55 - have the front end works the same as any
01:57 - other front end for a decentralized
01:58 - application we built this in react and
02:01 - JavaScript so here is the general
02:03 - architecture that we're already familiar
02:05 - with all right so now let's dive a
02:06 - little bit deeper into cesi nodes now
02:09 - the caresi node itself is the L2
02:11 - component that consists of the
02:12 - combination of the cartez machine that's
02:14 - what runs our backend and some specific
02:16 - middleware now what this middleware does
02:18 - is actually manage and controls the
02:20 - communication between the onchain
02:22 - components and the offchain components
02:24 - so this middleware what it does is read
02:27 - data from the L1 smart contract this is
02:29 - what's running onchain and this would be
02:31 - the inputs for example that are sent to
02:33 - the cazan machine and it's then sending
02:35 - them to the machine to be processed then
02:37 - whatever the caresan machine spits out
02:39 - so a voucher a notice report Etc it can
02:42 - then publish that result back to the
02:44 - blockchain so that's kind of the basic
02:46 - idea on how the Cartesian node works you
02:48 - have the middleware which is actually
02:50 - communicating with the layer one smart
02:52 - contracts and then you have the caresan
02:54 - machine itself which is running the back
02:55 - end in an isolated environment now as we
02:58 - see here in practice there two different
03:00 - types of our caresi notes user and
03:03 - validator notes now each of these
03:05 - interact with the onchain rollups in a
03:06 - different way and thus run different
03:08 - types of Cartesian notes so the user or
03:11 - reader notes now these are the most
03:13 - basic and what these are doing is just
03:15 - advancing the state of the offchain
03:17 - machine and making that state publicly
03:19 - available now anyone can run a user or
03:22 - reader node whoever is interested in the
03:24 - state of the decentralized application
03:26 - is able to run one and that way they can
03:28 - always have up information about the
03:31 - cartei DAP they also could use one that
03:33 - was made publicly available then we have
03:35 - a validator node now the validator node
03:37 - is doing something a little bit
03:39 - differently what this is doing is not
03:41 - only uh keeping track of and advancing
03:43 - the state of the offchain machine it's
03:45 - instance of the offchain machine it's
03:47 - also trying to fight dishonest
03:49 - validators so pretty much what it will
03:51 - be doing is checking at every single
03:54 - Epoch if the state that was submitted to
03:56 - the blockchain matches the state that it
03:59 - has so so a bunch of these different
04:00 - validator nodes will run they'll all
04:02 - come up with what they think the state
04:03 - of the Cartesian machine currently is or
04:05 - what it should be next and then if
04:07 - there's some kind of dispute they will
04:09 - resolve that dispute by taking part in
04:11 - some kind of verification game we'll
04:13 - talk about that later on but the idea is
04:15 - just like we have nodes or we have
04:17 - miners that are running on ethereum we
04:19 - can have the same thing but specifically
04:20 - for our cartez dap so we can run as many
04:24 - validator nodes as we want anyone else
04:26 - can run a validator node and that means
04:28 - we have our own set of infrastructure
04:30 - for our specific decentralized
04:32 - application that still is decentralized
04:35 - Right anyone can run a usern node anyone
04:37 - can run a validator node and these
04:39 - validator nodes are going to be
04:40 - checkpointing State updates on the
04:42 - blockchain and ensuring that all of the
04:44 - states that are being receive from the
04:46 - other validator nodes are indeed correct
04:48 - so very similar to how a normal
04:50 - blockchain network works in this case
04:52 - it's just for our specific decentralized
04:54 - app which we'll talk about a bit later
04:56 - now this leads us a little bit into EPO
04:59 - so pretty much much what we want to
05:00 - avoid doing here is constantly
05:02 - interacting with the blockchain if we
05:04 - don't have to so what we do is we have
05:06 - these validator nodes that do not
05:08 - checkpoint every new state update what
05:10 - they do is they're updating or
05:12 - checkpointing batches of State updates
05:14 - at the end of a specific Epoch so as you
05:17 - can see here it says in order to end an
05:19 - Epoch all validators need to reach a
05:21 - consensus about the state of the machine
05:23 - after processing all of the batched
05:25 - inputs so validator 1 takes all of the
05:27 - batched inputs in this Epoch and
05:29 - determines that at the end of all of
05:31 - these inputs the state of the machine is
05:32 - X then you have validator 2 if they come
05:36 - to the same agreement okay we're going
05:37 - to go ahead and checkpoint what the
05:39 - state was at this point in time however
05:42 - if they were to disagree then they have
05:43 - to take part in some kind of
05:45 - verification game and they have to
05:46 - dispute this by actually running some
05:48 - computations on the blockchain which
05:50 - we're going to get into in a new section
05:52 - so that's kind of an overview of the
05:54 - main things we already know now let's
05:56 - also just talk a little bit about
05:58 - sending requests so the the advance and
06:00 - the inspect now we already know how
06:02 - these work because we've used these
06:03 - quite a bit but there's two ways we
06:05 - interact with the cartei machine we have
06:07 - advance and we have inspect now when we
06:10 - advance what we're doing is we are
06:12 - sending an input using the blockchain
06:14 - network to our decentralized application
06:17 - the important thing here is that all of
06:18 - our inputs are logged on the blockchain
06:20 - so they are managed securely by layer
06:22 - one now these will be batched and
06:25 - they'll be processed by our validators
06:27 - and by the caresan nodes but the idea is
06:29 - anytime we want to advance or modify the
06:31 - state we do need to send a transaction
06:33 - and we do that by sending an input now
06:36 - if you're interested in exactly how this
06:37 - works we're using a Json RPC call to the
06:39 - input box contract we don't need to get
06:42 - into that too much but again the
06:44 - advantage here is that we don't need to
06:45 - actually execute all of the logic on the
06:47 - blockchain in a smart contract like we
06:49 - normally would we can send whatever data
06:52 - or whatever um Advance request we want
06:55 - through this input box contract and then
06:57 - all of the processing which can be quite
06:59 - large as we have seen can be handled
07:01 - offchain and then logged on chain then
07:04 - we have the inspect request now this is
07:06 - an external HTTP API very simple it's a
07:09 - call to the Cartesian node to Simply
07:11 - read what the state of that machine is
07:14 - now we can see that there is a video
07:15 - here it kind of goes through how this
07:16 - works so feel free to watch that and it
07:18 - kind of talks you through how you
07:20 - actually add an input how you do an
07:22 - inspect Etc so if we want to advance the
07:25 - state what we need to do is actually
07:26 - send a request using our blockchain
07:28 - Network so in this case the ethereum
07:29 - node we trigger the advanced State
07:31 - request and then that hits the cartez
07:33 - node so we have this in between step
07:35 - where we need to actually go to layer
07:37 - one however if we want to send an
07:39 - inspect we can go directly to the
07:41 - caresan node because no State update can
07:43 - be invoked with an inspect request only
07:46 - with an advance request so inspect very
07:48 - fast you go directly to the node
07:50 - advancing you still need to go through
07:51 - layer one and you need to have that
07:53 - input stored on layer one it will then
07:55 - get batched into an Epoch and it will be
07:57 - validated by the valid validator nodes
08:00 - that are running on the cartei network
08:02 - or for your cartei dap sorry all right
08:04 - so now let's dive into the cartei
08:05 - machine itself and talk about this a
08:07 - little bit in more detail so if we were
08:09 - running a normal decentralized
08:10 - application that wasn't using caresia
08:12 - and wasn't running on layer 2 then what
08:14 - we would be doing is relying exclusively
08:16 - on Smart contracts that are on layer one
08:20 - now these face severe constraints on the
08:21 - amount of data they can manipulate and
08:23 - on the complexity of the computations
08:25 - they can perform now these limitations
08:27 - manifest themselves as exuberant trans
08:29 - action costs and even if such costs
08:31 - could someh be overcome it's extremely
08:33 - long to run different computations if
08:35 - you don't believe me go and try to write
08:37 - a simple smart contract that does
08:38 - something like 100,000 Loops okay pretty
08:42 - trivial to do that on a standard
08:43 - computer try to do that on the
08:44 - blockchain and see what happens anyways
08:47 - the idea here is that in comparison our
08:48 - decentralized apps running inside the
08:50 - caresan machine can process relatively
08:52 - unlimited amounts of data at a pace of
08:54 - over four orders of magnitude faster now
08:57 - this is possible because they're running
08:59 - offchain so they are free of the
09:01 - overhead imposed by the consensus
09:02 - mechanisms used by blockchains which is
09:05 - really what slows them down now the
09:07 - double-edged sword here is that the
09:08 - consensus mechanism is also what keeps
09:10 - them secure when it comes to doing
09:11 - computations and running applications
09:13 - not just logging transaction data it
09:16 - causes things to be very slow and very
09:18 - expensive now in a typical scenario
09:21 - what's going to happen is our
09:22 - decentralized application will execute
09:24 - the Cartesian machine offchain and
09:26 - report it results to the blockchain
09:29 - different parties do not need to trust
09:30 - each other because the cartei platform
09:32 - includes an automatic dispute mechanism
09:34 - for the cartei machines any interested
09:36 - party can read the computations that are
09:38 - happening offchain and if they don't
09:40 - agree on the result of those
09:42 - computations so essentially the state
09:44 - update of the machine they can enter
09:45 - into a dispute and this mechanism
09:47 - guarantees that it will always be won by
09:49 - an honest party obviously there's a lot
09:52 - of math that goes into this but the
09:53 - reason why this is able to work is
09:55 - because of the three main properties of
09:57 - cartei machines first first of all they
09:59 - are self-contained second of all they
10:01 - are reproducible and they are
10:03 - transparent so that means given the same
10:06 - set of inputs the cartisian machine will
10:09 - always reach the same state or the same
10:11 - output so that's important because that
10:13 - means it doesn't matter when you run
10:15 - your cartisian machine who's running it
10:17 - in what environment Etc it's always
10:19 - going to reach the exact same output and
10:21 - it's verifiable that given a certain uh
10:24 - set of inputs this output was reached
10:27 - and we're going to talk about that by
10:28 - going into something thing known as the
10:29 - state hash which is kind of the main
10:32 - idea here behind the caresan machine now
10:34 - obviously there's a lot more information
10:36 - that we could dive into here and you can
10:38 - see that there's some pretty in-depth
10:39 - documentation about the cartisian
10:41 - machine but I think the thing that will
10:43 - uh kind of bring this full circle for
10:45 - you is looking at something known as the
10:47 - hash view or the state hash okay so hash
10:50 - view of state so one of the goals of
10:52 - moving computations offchain is to allow
10:54 - them to manipulate vast amounts of data
10:56 - so much data that it becomes
10:58 - economically prohibitive to explicitly
11:00 - store them in the blockchain
11:02 - nevertheless for smart contracts to
11:03 - delegate computations offchain they must
11:05 - be able to specify the computations
11:07 - their inputs and then reason over their
11:09 - outputs so this is key to solving the
11:12 - contradictory goals in the clever use of
11:13 - cryptographic hashes now the basic idea
11:16 - here is that the cartez machine itself
11:18 - is transparent so that means everything
11:20 - from the ROM the ram The Flash driv
11:23 - general purpose registers all of this
11:25 - complex computer architecture stuff that
11:27 - I don't know that much about is
11:29 - available for anyone to see now what
11:32 - that also means is that at any point in
11:33 - time we can take all of this information
11:36 - we can run it through a hash function
11:39 - and we can generate a unique
11:40 - cryptographic value that essentially
11:42 - encrypts or encodes the entire state of
11:45 - the machine now obviously I am
11:47 - oversimplifying this and I highly
11:48 - recommend you read this for more
11:50 - information on how it works but the idea
11:52 - is at any point in time I can go to my
11:54 - caresan machine and I can ask it to give
11:57 - me a hash of the state
11:59 - now only this specific state will
12:02 - generate the hash that it gives me and
12:04 - this hash is the main security feature
12:06 - that we use so for example if we have a
12:08 - certain set of inputs those inputs will
12:11 - lead us to a specific State we can then
12:13 - hash that state and we have essentially
12:15 - an encoding or a representation of what
12:17 - it is with very little amount of
12:19 - information that we need to store be
12:20 - transmitting we don't need to actually
12:22 - tell someone what all the ROM is the ram
12:24 - is the flash drives what could be
12:26 - multiple gigabytes of data we just take
12:28 - a hash of all of this information and
12:30 - that encodes this state so now another
12:33 - cartez machine or another cartez node
12:35 - can actually check the state of its
12:37 - machine and it can see if it matches the
12:39 - state that we have it can do that
12:41 - without having to have all of this
12:43 - information it simply needs the hash of
12:45 - the state so let me hop over to the
12:47 - Whiteboard here and I'll explain more
12:49 - about what I'm talking about all right
12:50 - so I'm on the drawing tablet here and
12:52 - I'm going to go through a bit more of
12:53 - how this hash view of the state works
12:55 - and then talk to you very briefly about
12:58 - the verific AED game now keep in mind
13:00 - this is very very high level grossly
13:03 - oversimplified so I just want to make
13:04 - sure that's clear if you are really
13:06 - interested in this please read through
13:08 - the white paper and some more of the
13:09 - documentation that I will link in the
13:10 - description so first of all let's say
13:13 - that we have a blockchain okay so this
13:15 - will be B this is our blockchain Network
13:18 - then we may have say two cartez nodes
13:22 - which are running on Layer Two and are
13:24 - keeping track of the state of our
13:26 - decentralized application now this
13:28 - blockchain itself is tracking all of the
13:31 - inputs that are sent to our
13:33 - decentralized app so it might have input
13:35 - one input two input three these are all
13:38 - actually logged on the blockchain now
13:41 - what will happen is these inputs will
13:43 - get sent over to our cartez nodes and
13:46 - they'll be executed by the cartez
13:48 - machine so these machines here will be
13:50 - keeping track of the current state of
13:53 - the machine and they'll be updating the
13:55 - state after each input comes in so input
13:57 - one gets sent over to machine one and
13:59 - then updates it state to represent the
14:02 - change after input one same thing
14:04 - happens here input one gets sent to
14:06 - machine number two and machine number
14:08 - two updates its state now after an Epoch
14:11 - so a certain batch of these inputs has
14:13 - been sent what's going to happen is both
14:14 - of these nodes assuming their validator
14:16 - nodes are going to report what their
14:18 - current state is back to the blockchain
14:21 - now they can do this efficiently because
14:23 - they can take whatever the state is so
14:25 - let's imagine all these lines here are
14:26 - the state they can effectively bundle it
14:29 - up and they can take a hash of this
14:32 - state so it can hash the entire State
14:34 - and then they can actually submit the
14:35 - hash of that state to the blockchain now
14:38 - this is valid because only one given
14:41 - state will generate one given hash and
14:43 - it's infeasible to find what the hash of
14:46 - the correct state would be I'm not going
14:48 - to dive into this too much this has to
14:49 - do with hash functions and cryptography
14:51 - but the basic idea is they're going to
14:53 - log after an Epoch what they believe the
14:56 - current state of the caresan machine is
14:58 - and they can do that using the hash view
15:00 - of the state now what will happen let's
15:03 - say that this guy logs you know the hash
15:05 - 1 2 3 and this guy logs the hash 456 in
15:08 - practice it be much larger than this I'm
15:10 - just using simple numbers is at this
15:12 - point they've disagreed on what the
15:15 - state of the carian machine should be
15:17 - after this batch of inputs so what needs
15:20 - to happen is we need to have a dispute
15:22 - resolution where we figure out what the
15:24 - real State should actually be now what
15:27 - would have been happening is the
15:28 - application beforehand so the smart
15:30 - contracts running our cartez dap would
15:32 - be logging what the state is after every
15:35 - single Epoch so it would say something
15:37 - like Epoch 1 and the state is equal to
15:41 - you know XYZ right Epoch 2 same thing
15:45 - you get the idea and it's keeping track
15:47 - of all of these states that have been
15:50 - agreed upon that had a consensus from
15:52 - these caresi notes so what we do is we
15:55 - don't need to process every single
15:57 - transaction that's ever been inv
15:58 - involved in our cartez dap we simply go
16:01 - to where we know we had finality so
16:04 - where we know the state was agreed upon
16:05 - and there was consensus and then we
16:07 - start processing the inputs that are not
16:10 - agreed upon so the state update that was
16:12 - not agreed upon on the blockchain so let
16:14 - me just really clarify this again
16:16 - because I know it's a little bit
16:17 - confusing pretty much these caresan
16:20 - notes here are constantly keeping track
16:23 - of the state of our decentralized
16:25 - application they're logging that back to
16:27 - the blockchain and when they both agree
16:29 - they say okay well that's good the state
16:31 - is final now we can move on and we can
16:33 - process the next set of inputs now the
16:36 - blockchain itself will just assume that
16:39 - everything that's sent from these nodes
16:40 - is correct so long as they reach
16:42 - consensus on that it doesn't need to
16:44 - actually process any of the computations
16:47 - unless there is a dispute so at this
16:49 - point where there is a dispute where
16:51 - these two hashes or these two State
16:52 - updates don't match what we do is rather
16:55 - than processing the computation offchain
16:58 - we actually process part of the
17:00 - computation on chain now this is more
17:02 - expensive and it takes longer but we
17:04 - utilize the security components of layer
17:07 - one to ensure that the state update that
17:10 - we're about to log onto the blockchain
17:12 - is indeed correct so again basic idea is
17:15 - when these two things do not agree so
17:18 - when our nodes do not have a consensus
17:20 - on what the state update should be we
17:22 - actually push the computation onto the
17:24 - blockchain and we compute the new state
17:28 - of update directly on the blockchain so
17:30 - we ensure that since it's computed there
17:32 - on the blockchain that it's going to be
17:34 - correct and valid and then we log what
17:36 - the next state update actually should be
17:39 - so that is the very very very high level
17:41 - overview of how the kind of uh
17:44 - verification or dispute process is done
17:47 - whenever we disagree on what the state
17:50 - of the caresan machine should be these
17:53 - two parties will play something known as
17:54 - a verification game they're going to
17:56 - interact with the blockchain the
17:57 - blockchain is is going to determine
17:59 - where the last known state that valid
18:02 - was it's going to start from there
18:03 - pretty much and it's going to take
18:05 - whatever the new inputs were that have
18:07 - not been agreed upon so the state after
18:09 - those inputs and it's going to process a
18:11 - partial computation on the blockchain to
18:14 - ensure it gets the correct State it's
18:16 - then going to log that on the blockchain
18:18 - and then we're going to continue moving
18:19 - on to the next Epoch so one of the main
18:22 - advantages of this system that you're
18:24 - seeing here is that we're only
18:26 - performing computations on the
18:28 - blockchain when they need to be
18:30 - performed to essentially resolve a
18:33 - dispute and we're only doing a partial
18:35 - computation which is much quicker and
18:37 - faster to execute rather than rerunning
18:40 - the entire caresan machine for example
18:42 - directly on the blockchain again this is
18:45 - a bit more complicated to really
18:46 - understand how this works at a deeper
18:48 - level but the idea is we already know
18:51 - what a final state was at a certain
18:52 - point in time we can essentially start
18:54 - from there just compute the part of the
18:57 - computation that was dis disputed and
18:59 - then we can log that result directly on
19:00 - the blockchain and we can have that
19:02 - immutability component where the
19:03 - blockchain says Hey at this point after
19:05 - these inputs this is the state and we
19:07 - keep going and we move to the next Epoch
19:09 - now another Advantage here is that we
19:11 - only need to have consensus among the
19:13 - involved parties so rather than the
19:15 - entire network verifying every
19:17 - computation the consensus is just
19:19 - reached among the parties that are
19:21 - directly involved in the transaction for
19:23 - example if two users are interacting in
19:25 - a cartez based application only those
19:28 - two need to reach an agreement on the
19:29 - outcome of their interaction it doesn't
19:31 - concern the entire ethereum network for
19:34 - example so that's a little bit about how
19:36 - the verification actually works here on
19:39 - carteia and the dispute mechanism again
19:41 - this all has to do with those main
19:43 - properties of the cartez machine and the
19:45 - fact that we can actually hash the
19:46 - entire State we then can use the
19:49 - blockchain when we need to actually
19:50 - resolve a dispute and we can have the
19:53 - finality there of a batch of
19:55 - transactions which is our Epoch okay now
19:58 - let's head back over to the computer and
20:00 - talk about the last few components so
20:02 - the last thing I want to go over here is
20:03 - something known as application specific
20:05 - rollups which is what caresia implements
20:08 - but in order to understand that we'll
20:09 - quickly just recap a blockchain rollup
20:11 - now this is a scalability solution that
20:13 - pushes complex computations offchain
20:16 - this means they run in a separate
20:17 - Computing environment outside of the
20:19 - main or base layer such as ethereum now
20:22 - when we use rollups the blockchain's
20:24 - role is simply to receive receive
20:27 - transactions sorry and to log them and
20:29 - as we saw on occasions where there is a
20:31 - dispute or a disagreement then we can
20:33 - actually execute the computation onchain
20:36 - but we don't need to do the entire thing
20:38 - it can be a partial computation where we
20:40 - can verify on the blockchain network
20:42 - with the correct State should be now
20:45 - doing this uh really drastically
20:47 - improves the scalability of our
20:49 - applications because we're able to
20:51 - compress data and we can increase the
20:53 - number of transactions that the
20:55 - blockchain can process because we're
20:56 - taking those heavy Compu mutations and
20:58 - moving those off chain when we're just
21:01 - using the blockchain for the sole
21:03 - purpose of logging transactions it can
21:05 - handle much more data much faster than
21:07 - if we were executing all of the
21:09 - computations directly on chain okay so
21:12 - how does a rollup work users interact
21:14 - with the rollup through transactions on
21:16 - the base layer they send messages in
21:18 - this case they're called inputs to the
21:19 - rollup onchain smart contract to define
21:22 - a computation that they want to be
21:24 - processed in this case it could be an
21:25 - advanced request of the Computing in
21:28 - environment then interested parties run
21:30 - an offchain component in our case a node
21:32 - that watches the blockchain for inputs
21:35 - understanding and executing their State
21:36 - updates once in a while the state of the
21:38 - machine is checkpointed on the
21:40 - blockchain at which point the state is
21:42 - considered to be finalized so once the
21:44 - state is finalized that's when we can
21:46 - actually say that a notice is correct
21:48 - and we can execute something like a
21:49 - voucher from caresan now there's two
21:52 - main types of rollups that we use zero
21:54 - knowledge Roll-Ups ZK rollups or
21:56 - optimistic rollups now now a zero
21:58 - knowledge rollup uses something known as
22:00 - a validity proof what this pretty much
22:02 - means is that with every single
22:04 - transaction it submits to the blockchain
22:06 - so every rollup it's going to actually
22:09 - produce a validity proof that can be
22:11 - used to verify that what information is
22:13 - submitting is correct this takes a
22:15 - little bit more time it's a bit more
22:17 - complex but the benefit here is that we
22:20 - have instant finality so as soon as
22:22 - something is submitted to the blockchain
22:23 - we can immediately say that it is indeed
22:26 - correct however it can be a bit
22:28 - expensive to actually verify these uh
22:31 - rollups because you have to do those on
22:32 - chain and it can be difficult to produce
22:35 - validity proofs then we have optimistic
22:38 - rollups now optimistic rollups use
22:40 - something known as a fraud proof and
22:42 - really the general idea behind an
22:44 - optimistic rollup is that we're going to
22:46 - assume that everything single state
22:48 - update that is sent to the blockchain so
22:50 - those kind of batched checkpoints are
22:52 - valid unless they are challenged so
22:54 - rather than requiring people to always
22:56 - kind of submit a proof and verify that
22:58 - what they're submitting is correct we
23:00 - just optimistically assume that whatever
23:02 - is submitted to us is indeed correct and
23:04 - then we only challenge that or we only
23:07 - verify that story if it is challenged so
23:09 - this actually removes a lot of the load
23:11 - from the blockchain because we're only
23:13 - utilizing the chain for computations
23:16 - when we have some kind of challenge or
23:17 - when parties disagree which ideally will
23:19 - not be too often now the way that this
23:21 - actually reinforce is by using Financial
23:24 - incentives that reward honest Behavior
23:26 - we don't need to get into that in this
23:27 - video video but that's the basic idea so
23:29 - moving into cte's version of optimistic
23:31 - rollups this uses something known as an
23:33 - interactive fraud proof now the idea
23:36 - here is that we are hardly ever actually
23:38 - having to do computations on the
23:40 - blockchain because either there are no
23:42 - disputes and no computation takes place
23:44 - or if a dispute occurs it only needs to
23:46 - compute a single instruction to
23:48 - distinguish between misbehavior and
23:50 - honesty in either case the results
23:52 - themselves are always computed offchain
23:54 - and as a consequence the computation
23:55 - involved can be massive that's that's
23:57 - kind of what I was talking about we only
23:59 - need to do a partial computation I don't
24:01 - want to get into that too much because
24:02 - it's a little bit complicated on how
24:04 - that works but the idea is what we're
24:06 - doing on chain is very limited and if a
24:08 - dispute does occur it's not that
24:10 - expensive to resolve so now we can touch
24:12 - on something known as application
24:14 - specific rollups which is exactly what
24:16 - cartez implements so normal rollups say
24:19 - like optimism arbitrum Etc at least the
24:22 - ones you might be familiar with are kind
24:23 - of a one siiz fits-all solution and they
24:26 - still actually suffer from a lot of the
24:28 - traditional computation issues with a
24:30 - normal blockchain Network now they
24:32 - actually are really limiting in terms of
24:34 - how you can build your applications and
24:36 - they're good generally speaking for a
24:38 - lot of different types of applications
24:40 - but they're not great for a specific
24:42 - type now caresia itself has application
24:45 - specific rollups which means that you
24:47 - can create your rollup however you want
24:49 - for the specific type of application
24:51 - that you are building so this allows you
24:53 - to optimize performance functionality
24:56 - Etc and just gives you more efficiency
24:58 - and flexibility than a standard RPS
25:00 - framework now a lot of the reason why
25:02 - this works is because of the caresan
25:04 - machine the cont consensus mechanism Etc
25:07 - but cartez has this integration with
25:09 - Linux right as we know that's why we're
25:11 - able to write our smart contract in
25:12 - python or really any language that we
25:14 - want and it gives us the ability to be
25:16 - very Dynamic and flexible with how we
25:18 - design our application as you saw we can
25:21 - design our own protocol we can specify
25:23 - what we want to do with inputs how we're
25:24 - going to handle inspect requests and we
25:26 - can do this in a very familiar
25:28 - development environment now part of the
25:30 - reason why this works is because we have
25:32 - off-chain computations with onchain
25:35 - security so as you saw caresia enables
25:37 - the complex computations to be performed
25:40 - offchain while still maintaining the
25:42 - security guarantee of the blockchain now
25:44 - this balance is achieved through the
25:46 - dispute resolution mechanism which we've
25:48 - talked about which differs from the
25:49 - general approach of other rollups where
25:51 - computations are simplified to fit the
25:53 - blockchain constraints so in other types
25:56 - of rollups you have to write your
25:58 - computations in a way where they could
25:59 - be executed on the blockchain with
26:02 - cartei you don't need to do that because
26:04 - of the way that the computations are
26:06 - verified we can write them however we
26:09 - want as you've seen using our
26:10 - traditional program languages and then
26:12 - they can still be verified on the
26:14 - blockchain using a partial computation
26:16 - that is executed on there so with all
26:18 - that said it just makes web 3
26:19 - development a lot more accessible
26:21 - because again you're designing something
26:23 - for your specific application needs
26:25 - you're not trying to fit into the
26:27 - constraint of a blockchain network or of
26:29 - a pre-built solution you can do really
26:31 - whatever you want so with that said
26:33 - that's kind of going to wrap up this
26:34 - video I know there's a lot of stuff here
26:36 - I went through a lot of complex topics
26:38 - and I didn't make it 100% clear but I
26:41 - wanted to give you something to chew on
26:42 - something to think about and kind of
26:44 - encourage you to go to the caresia
26:46 - documentation if you're interested read
26:48 - more go through the white paper and
26:50 - really understand how all of this stuff
26:51 - works I think it's really interesting
26:53 - I'm still really just getting familiar
26:55 - with some of the more complex
26:56 - mathematical Concepts but I think it's
26:58 - really interesting how cartei differs
27:00 - from some of the other rollups
27:01 - Frameworks and the type of applications
27:03 - you can build with it as you've seen in
27:05 - this series and as we've kind of gone
27:07 - through this documentation it's really
27:09 - unlimited the type of apps you can build
27:11 - because of this Linux environment and
27:13 - the unique way that carteia handles
27:15 - rollups in the interaction with the
27:17 - blockchain so with that said I'm going
27:18 - to wrap it up here I hope you found this
27:20 - helpful and I look forward to seeing you
27:21 - in the next
27:23 - [Music]
27:26 - video
27:30 - oh

Cleaned transcript:

hello everybody and welcome to part seven of this tutorial Series where we'll be getting into the architecture of cartei and talking about this more in depth compared to what we've gone over in previous videos now I'm going to start by giving you a general overview and summary of the main components that we're already familiar with just to make sure everyone is up to speed and remembers it then we're going to dive into some of the more complex components for example we're going to talk about consensus and we're going to talk about how cartez rollups are different than other types of RollUps and why that's important for you to understand so let's begin by going through a highlevel overview of the main components of a caresia application so we have cares rollups caresi machine the DAP backend and the DAP front end now as we've seen here and we've looked at this diagram before what we're responsible for building is the front end and the back end the rest of the components are already built for us and they make up kind of the caresi rollups framework now as we saw in the previous video caresi rollups itself is a set of onchain and offchain components that implement ment the optimistic rollup solution now the onchain components include smart contracts right so for example input box part of caresia rollups our dap Factory again we need to deploy that onto the target Network then we have the caresan machine now this as we know is a virtual machine running an entire Linux operating system in which the dap's backend is executed now there's some more details related to this for example it runs a risk 5 architecture which is actually able to be hashed allows us full trans parency and gives us some features of the Cartesian machine which are important and actually kind of go into the security and details implementation Etc which we can talk about later regardless the caresan machine is where we run the daps backend now this is where we have the state and verifiable logic which corresponds to the smart contract this is what we wrote in Python and what we can write in pretty much any programming language that runs as a Linux application then we have the front end works the same as any other front end for a decentralized application we built this in react and JavaScript so here is the general architecture that we're already familiar with all right so now let's dive a little bit deeper into cesi nodes now the caresi node itself is the L2 component that consists of the combination of the cartez machine that's what runs our backend and some specific middleware now what this middleware does is actually manage and controls the communication between the onchain components and the offchain components so this middleware what it does is read data from the L1 smart contract this is what's running onchain and this would be the inputs for example that are sent to the cazan machine and it's then sending them to the machine to be processed then whatever the caresan machine spits out so a voucher a notice report Etc it can then publish that result back to the blockchain so that's kind of the basic idea on how the Cartesian node works you have the middleware which is actually communicating with the layer one smart contracts and then you have the caresan machine itself which is running the back end in an isolated environment now as we see here in practice there two different types of our caresi notes user and validator notes now each of these interact with the onchain rollups in a different way and thus run different types of Cartesian notes so the user or reader notes now these are the most basic and what these are doing is just advancing the state of the offchain machine and making that state publicly available now anyone can run a user or reader node whoever is interested in the state of the decentralized application is able to run one and that way they can always have up information about the cartei DAP they also could use one that was made publicly available then we have a validator node now the validator node is doing something a little bit differently what this is doing is not only uh keeping track of and advancing the state of the offchain machine it's instance of the offchain machine it's also trying to fight dishonest validators so pretty much what it will be doing is checking at every single Epoch if the state that was submitted to the blockchain matches the state that it has so so a bunch of these different validator nodes will run they'll all come up with what they think the state of the Cartesian machine currently is or what it should be next and then if there's some kind of dispute they will resolve that dispute by taking part in some kind of verification game we'll talk about that later on but the idea is just like we have nodes or we have miners that are running on ethereum we can have the same thing but specifically for our cartez dap so we can run as many validator nodes as we want anyone else can run a validator node and that means we have our own set of infrastructure for our specific decentralized application that still is decentralized Right anyone can run a usern node anyone can run a validator node and these validator nodes are going to be checkpointing State updates on the blockchain and ensuring that all of the states that are being receive from the other validator nodes are indeed correct so very similar to how a normal blockchain network works in this case it's just for our specific decentralized app which we'll talk about a bit later now this leads us a little bit into EPO so pretty much much what we want to avoid doing here is constantly interacting with the blockchain if we don't have to so what we do is we have these validator nodes that do not checkpoint every new state update what they do is they're updating or checkpointing batches of State updates at the end of a specific Epoch so as you can see here it says in order to end an Epoch all validators need to reach a consensus about the state of the machine after processing all of the batched inputs so validator 1 takes all of the batched inputs in this Epoch and determines that at the end of all of these inputs the state of the machine is X then you have validator 2 if they come to the same agreement okay we're going to go ahead and checkpoint what the state was at this point in time however if they were to disagree then they have to take part in some kind of verification game and they have to dispute this by actually running some computations on the blockchain which we're going to get into in a new section so that's kind of an overview of the main things we already know now let's also just talk a little bit about sending requests so the the advance and the inspect now we already know how these work because we've used these quite a bit but there's two ways we interact with the cartei machine we have advance and we have inspect now when we advance what we're doing is we are sending an input using the blockchain network to our decentralized application the important thing here is that all of our inputs are logged on the blockchain so they are managed securely by layer one now these will be batched and they'll be processed by our validators and by the caresan nodes but the idea is anytime we want to advance or modify the state we do need to send a transaction and we do that by sending an input now if you're interested in exactly how this works we're using a Json RPC call to the input box contract we don't need to get into that too much but again the advantage here is that we don't need to actually execute all of the logic on the blockchain in a smart contract like we normally would we can send whatever data or whatever um Advance request we want through this input box contract and then all of the processing which can be quite large as we have seen can be handled offchain and then logged on chain then we have the inspect request now this is an external HTTP API very simple it's a call to the Cartesian node to Simply read what the state of that machine is now we can see that there is a video here it kind of goes through how this works so feel free to watch that and it kind of talks you through how you actually add an input how you do an inspect Etc so if we want to advance the state what we need to do is actually send a request using our blockchain Network so in this case the ethereum node we trigger the advanced State request and then that hits the cartez node so we have this in between step where we need to actually go to layer one however if we want to send an inspect we can go directly to the caresan node because no State update can be invoked with an inspect request only with an advance request so inspect very fast you go directly to the node advancing you still need to go through layer one and you need to have that input stored on layer one it will then get batched into an Epoch and it will be validated by the valid validator nodes that are running on the cartei network or for your cartei dap sorry all right so now let's dive into the cartei machine itself and talk about this a little bit in more detail so if we were running a normal decentralized application that wasn't using caresia and wasn't running on layer 2 then what we would be doing is relying exclusively on Smart contracts that are on layer one now these face severe constraints on the amount of data they can manipulate and on the complexity of the computations they can perform now these limitations manifest themselves as exuberant trans action costs and even if such costs could someh be overcome it's extremely long to run different computations if you don't believe me go and try to write a simple smart contract that does something like 100,000 Loops okay pretty trivial to do that on a standard computer try to do that on the blockchain and see what happens anyways the idea here is that in comparison our decentralized apps running inside the caresan machine can process relatively unlimited amounts of data at a pace of over four orders of magnitude faster now this is possible because they're running offchain so they are free of the overhead imposed by the consensus mechanisms used by blockchains which is really what slows them down now the doubleedged sword here is that the consensus mechanism is also what keeps them secure when it comes to doing computations and running applications not just logging transaction data it causes things to be very slow and very expensive now in a typical scenario what's going to happen is our decentralized application will execute the Cartesian machine offchain and report it results to the blockchain different parties do not need to trust each other because the cartei platform includes an automatic dispute mechanism for the cartei machines any interested party can read the computations that are happening offchain and if they don't agree on the result of those computations so essentially the state update of the machine they can enter into a dispute and this mechanism guarantees that it will always be won by an honest party obviously there's a lot of math that goes into this but the reason why this is able to work is because of the three main properties of cartei machines first first of all they are selfcontained second of all they are reproducible and they are transparent so that means given the same set of inputs the cartisian machine will always reach the same state or the same output so that's important because that means it doesn't matter when you run your cartisian machine who's running it in what environment Etc it's always going to reach the exact same output and it's verifiable that given a certain uh set of inputs this output was reached and we're going to talk about that by going into something thing known as the state hash which is kind of the main idea here behind the caresan machine now obviously there's a lot more information that we could dive into here and you can see that there's some pretty indepth documentation about the cartisian machine but I think the thing that will uh kind of bring this full circle for you is looking at something known as the hash view or the state hash okay so hash view of state so one of the goals of moving computations offchain is to allow them to manipulate vast amounts of data so much data that it becomes economically prohibitive to explicitly store them in the blockchain nevertheless for smart contracts to delegate computations offchain they must be able to specify the computations their inputs and then reason over their outputs so this is key to solving the contradictory goals in the clever use of cryptographic hashes now the basic idea here is that the cartez machine itself is transparent so that means everything from the ROM the ram The Flash driv general purpose registers all of this complex computer architecture stuff that I don't know that much about is available for anyone to see now what that also means is that at any point in time we can take all of this information we can run it through a hash function and we can generate a unique cryptographic value that essentially encrypts or encodes the entire state of the machine now obviously I am oversimplifying this and I highly recommend you read this for more information on how it works but the idea is at any point in time I can go to my caresan machine and I can ask it to give me a hash of the state now only this specific state will generate the hash that it gives me and this hash is the main security feature that we use so for example if we have a certain set of inputs those inputs will lead us to a specific State we can then hash that state and we have essentially an encoding or a representation of what it is with very little amount of information that we need to store be transmitting we don't need to actually tell someone what all the ROM is the ram is the flash drives what could be multiple gigabytes of data we just take a hash of all of this information and that encodes this state so now another cartez machine or another cartez node can actually check the state of its machine and it can see if it matches the state that we have it can do that without having to have all of this information it simply needs the hash of the state so let me hop over to the Whiteboard here and I'll explain more about what I'm talking about all right so I'm on the drawing tablet here and I'm going to go through a bit more of how this hash view of the state works and then talk to you very briefly about the verific AED game now keep in mind this is very very high level grossly oversimplified so I just want to make sure that's clear if you are really interested in this please read through the white paper and some more of the documentation that I will link in the description so first of all let's say that we have a blockchain okay so this will be B this is our blockchain Network then we may have say two cartez nodes which are running on Layer Two and are keeping track of the state of our decentralized application now this blockchain itself is tracking all of the inputs that are sent to our decentralized app so it might have input one input two input three these are all actually logged on the blockchain now what will happen is these inputs will get sent over to our cartez nodes and they'll be executed by the cartez machine so these machines here will be keeping track of the current state of the machine and they'll be updating the state after each input comes in so input one gets sent over to machine one and then updates it state to represent the change after input one same thing happens here input one gets sent to machine number two and machine number two updates its state now after an Epoch so a certain batch of these inputs has been sent what's going to happen is both of these nodes assuming their validator nodes are going to report what their current state is back to the blockchain now they can do this efficiently because they can take whatever the state is so let's imagine all these lines here are the state they can effectively bundle it up and they can take a hash of this state so it can hash the entire State and then they can actually submit the hash of that state to the blockchain now this is valid because only one given state will generate one given hash and it's infeasible to find what the hash of the correct state would be I'm not going to dive into this too much this has to do with hash functions and cryptography but the basic idea is they're going to log after an Epoch what they believe the current state of the caresan machine is and they can do that using the hash view of the state now what will happen let's say that this guy logs you know the hash 1 2 3 and this guy logs the hash 456 in practice it be much larger than this I'm just using simple numbers is at this point they've disagreed on what the state of the carian machine should be after this batch of inputs so what needs to happen is we need to have a dispute resolution where we figure out what the real State should actually be now what would have been happening is the application beforehand so the smart contracts running our cartez dap would be logging what the state is after every single Epoch so it would say something like Epoch 1 and the state is equal to you know XYZ right Epoch 2 same thing you get the idea and it's keeping track of all of these states that have been agreed upon that had a consensus from these caresi notes so what we do is we don't need to process every single transaction that's ever been inv involved in our cartez dap we simply go to where we know we had finality so where we know the state was agreed upon and there was consensus and then we start processing the inputs that are not agreed upon so the state update that was not agreed upon on the blockchain so let me just really clarify this again because I know it's a little bit confusing pretty much these caresan notes here are constantly keeping track of the state of our decentralized application they're logging that back to the blockchain and when they both agree they say okay well that's good the state is final now we can move on and we can process the next set of inputs now the blockchain itself will just assume that everything that's sent from these nodes is correct so long as they reach consensus on that it doesn't need to actually process any of the computations unless there is a dispute so at this point where there is a dispute where these two hashes or these two State updates don't match what we do is rather than processing the computation offchain we actually process part of the computation on chain now this is more expensive and it takes longer but we utilize the security components of layer one to ensure that the state update that we're about to log onto the blockchain is indeed correct so again basic idea is when these two things do not agree so when our nodes do not have a consensus on what the state update should be we actually push the computation onto the blockchain and we compute the new state of update directly on the blockchain so we ensure that since it's computed there on the blockchain that it's going to be correct and valid and then we log what the next state update actually should be so that is the very very very high level overview of how the kind of uh verification or dispute process is done whenever we disagree on what the state of the caresan machine should be these two parties will play something known as a verification game they're going to interact with the blockchain the blockchain is is going to determine where the last known state that valid was it's going to start from there pretty much and it's going to take whatever the new inputs were that have not been agreed upon so the state after those inputs and it's going to process a partial computation on the blockchain to ensure it gets the correct State it's then going to log that on the blockchain and then we're going to continue moving on to the next Epoch so one of the main advantages of this system that you're seeing here is that we're only performing computations on the blockchain when they need to be performed to essentially resolve a dispute and we're only doing a partial computation which is much quicker and faster to execute rather than rerunning the entire caresan machine for example directly on the blockchain again this is a bit more complicated to really understand how this works at a deeper level but the idea is we already know what a final state was at a certain point in time we can essentially start from there just compute the part of the computation that was dis disputed and then we can log that result directly on the blockchain and we can have that immutability component where the blockchain says Hey at this point after these inputs this is the state and we keep going and we move to the next Epoch now another Advantage here is that we only need to have consensus among the involved parties so rather than the entire network verifying every computation the consensus is just reached among the parties that are directly involved in the transaction for example if two users are interacting in a cartez based application only those two need to reach an agreement on the outcome of their interaction it doesn't concern the entire ethereum network for example so that's a little bit about how the verification actually works here on carteia and the dispute mechanism again this all has to do with those main properties of the cartez machine and the fact that we can actually hash the entire State we then can use the blockchain when we need to actually resolve a dispute and we can have the finality there of a batch of transactions which is our Epoch okay now let's head back over to the computer and talk about the last few components so the last thing I want to go over here is something known as application specific rollups which is what caresia implements but in order to understand that we'll quickly just recap a blockchain rollup now this is a scalability solution that pushes complex computations offchain this means they run in a separate Computing environment outside of the main or base layer such as ethereum now when we use rollups the blockchain's role is simply to receive receive transactions sorry and to log them and as we saw on occasions where there is a dispute or a disagreement then we can actually execute the computation onchain but we don't need to do the entire thing it can be a partial computation where we can verify on the blockchain network with the correct State should be now doing this uh really drastically improves the scalability of our applications because we're able to compress data and we can increase the number of transactions that the blockchain can process because we're taking those heavy Compu mutations and moving those off chain when we're just using the blockchain for the sole purpose of logging transactions it can handle much more data much faster than if we were executing all of the computations directly on chain okay so how does a rollup work users interact with the rollup through transactions on the base layer they send messages in this case they're called inputs to the rollup onchain smart contract to define a computation that they want to be processed in this case it could be an advanced request of the Computing in environment then interested parties run an offchain component in our case a node that watches the blockchain for inputs understanding and executing their State updates once in a while the state of the machine is checkpointed on the blockchain at which point the state is considered to be finalized so once the state is finalized that's when we can actually say that a notice is correct and we can execute something like a voucher from caresan now there's two main types of rollups that we use zero knowledge RollUps ZK rollups or optimistic rollups now now a zero knowledge rollup uses something known as a validity proof what this pretty much means is that with every single transaction it submits to the blockchain so every rollup it's going to actually produce a validity proof that can be used to verify that what information is submitting is correct this takes a little bit more time it's a bit more complex but the benefit here is that we have instant finality so as soon as something is submitted to the blockchain we can immediately say that it is indeed correct however it can be a bit expensive to actually verify these uh rollups because you have to do those on chain and it can be difficult to produce validity proofs then we have optimistic rollups now optimistic rollups use something known as a fraud proof and really the general idea behind an optimistic rollup is that we're going to assume that everything single state update that is sent to the blockchain so those kind of batched checkpoints are valid unless they are challenged so rather than requiring people to always kind of submit a proof and verify that what they're submitting is correct we just optimistically assume that whatever is submitted to us is indeed correct and then we only challenge that or we only verify that story if it is challenged so this actually removes a lot of the load from the blockchain because we're only utilizing the chain for computations when we have some kind of challenge or when parties disagree which ideally will not be too often now the way that this actually reinforce is by using Financial incentives that reward honest Behavior we don't need to get into that in this video video but that's the basic idea so moving into cte's version of optimistic rollups this uses something known as an interactive fraud proof now the idea here is that we are hardly ever actually having to do computations on the blockchain because either there are no disputes and no computation takes place or if a dispute occurs it only needs to compute a single instruction to distinguish between misbehavior and honesty in either case the results themselves are always computed offchain and as a consequence the computation involved can be massive that's that's kind of what I was talking about we only need to do a partial computation I don't want to get into that too much because it's a little bit complicated on how that works but the idea is what we're doing on chain is very limited and if a dispute does occur it's not that expensive to resolve so now we can touch on something known as application specific rollups which is exactly what cartez implements so normal rollups say like optimism arbitrum Etc at least the ones you might be familiar with are kind of a one siiz fitsall solution and they still actually suffer from a lot of the traditional computation issues with a normal blockchain Network now they actually are really limiting in terms of how you can build your applications and they're good generally speaking for a lot of different types of applications but they're not great for a specific type now caresia itself has application specific rollups which means that you can create your rollup however you want for the specific type of application that you are building so this allows you to optimize performance functionality Etc and just gives you more efficiency and flexibility than a standard RPS framework now a lot of the reason why this works is because of the caresan machine the cont consensus mechanism Etc but cartez has this integration with Linux right as we know that's why we're able to write our smart contract in python or really any language that we want and it gives us the ability to be very Dynamic and flexible with how we design our application as you saw we can design our own protocol we can specify what we want to do with inputs how we're going to handle inspect requests and we can do this in a very familiar development environment now part of the reason why this works is because we have offchain computations with onchain security so as you saw caresia enables the complex computations to be performed offchain while still maintaining the security guarantee of the blockchain now this balance is achieved through the dispute resolution mechanism which we've talked about which differs from the general approach of other rollups where computations are simplified to fit the blockchain constraints so in other types of rollups you have to write your computations in a way where they could be executed on the blockchain with cartei you don't need to do that because of the way that the computations are verified we can write them however we want as you've seen using our traditional program languages and then they can still be verified on the blockchain using a partial computation that is executed on there so with all that said it just makes web 3 development a lot more accessible because again you're designing something for your specific application needs you're not trying to fit into the constraint of a blockchain network or of a prebuilt solution you can do really whatever you want so with that said that's kind of going to wrap up this video I know there's a lot of stuff here I went through a lot of complex topics and I didn't make it 100% clear but I wanted to give you something to chew on something to think about and kind of encourage you to go to the caresia documentation if you're interested read more go through the white paper and really understand how all of this stuff works I think it's really interesting I'm still really just getting familiar with some of the more complex mathematical Concepts but I think it's really interesting how cartei differs from some of the other rollups Frameworks and the type of applications you can build with it as you've seen in this series and as we've kind of gone through this documentation it's really unlimited the type of apps you can build because of this Linux environment and the unique way that carteia handles rollups in the interaction with the blockchain so with that said I'm going to wrap it up here I hope you found this helpful and I look forward to seeing you in the next video oh
