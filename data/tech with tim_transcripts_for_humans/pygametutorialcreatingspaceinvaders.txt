With timestamps:

00:02 - [Music]
00:05 - hello everybody and welcome back to
00:08 - their PI game tutorial now it's been a
00:10 - long time since I've done one of these
00:11 - but you guys know that the foundation of
00:13 - tech whatin my youtube channel was
00:15 - really built around making all kinds of
00:17 - fun little PI games like I've made
00:18 - Tetris snake some platformer games stuff
00:21 - like that which you guys can check out
00:23 - as well if you wanted to see those and I
00:25 - wanted to bring another one back here to
00:26 - all the old subscribers and just show
00:28 - you guys you know this is another cool
00:29 - PI game we can make especially with
00:31 - quarantine happening PI game is just
00:33 - such a great module for making some fun
00:35 - 2d games that don't take you that long
00:37 - to kind of get up and spinning and of
00:39 - course you know we can use Python for
00:40 - this which is a great and pretty fast
00:42 - language to write code in so the game
00:45 - that we're gonna be creating today is a
00:46 - space shooter game now this is inspired
00:48 - or kind of based off of that old
00:50 - original Atari game where you have those
00:52 - spaceships coming down the screen and
00:54 - you're this big shooter and you're
00:55 - trying to shoot them all of the sky I
00:56 - know that that version is a lot
00:58 - different than what I'm gonna show you
00:59 - here but this is the inspiration now
01:02 - stick with me here for another minute or
01:03 - two I need to give you this introduction
01:05 - so you really have all the tools you
01:07 - need to work through this project the
01:09 - first thing I'm gonna say is these
01:10 - videos take me a really long time to
01:11 - make and I really want to make sure that
01:13 - you guys are able to actually create the
01:14 - game so please do me a favor go like the
01:17 - video and make sure you're subscribed to
01:19 - the channel if you're not just show your
01:20 - support if you guys really want to give
01:22 - me an extra big thank you and show your
01:23 - appreciation I'd really appreciate it if
01:26 - you go subscribe to my new youtube
01:27 - channel which is called time out with
01:29 - Tim that's where I'm gonna be posting a
01:31 - weekly podcast where I talk about tech
01:33 - programming finance just myself
01:35 - lifestyle stuff like that and I would
01:37 - really appreciate it even if you guys
01:38 - don't want to watch that you just go
01:39 - over and subscribe and support me over
01:42 - there so anyways let's demo the game and
01:43 - as I demo the game I'll talk about some
01:45 - other important things for this tutorial
01:47 - series so first of all all the assets
01:49 - you see here those little pixelated
01:50 - assets are available from the
01:52 - description down below I've made a
01:54 - really easy link on my website so all
01:56 - you have to do is just click it and it
01:57 - will automatically just download a zip
01:58 - folder that has all the game assets and
02:00 - the code as well I get comments all the
02:03 - time with common problems which I'm
02:04 - gonna go over at the beginning of this
02:06 - video to hopefully make sure you guys
02:07 - don't run into those but if you're
02:09 - running into problems just click that
02:11 - link the code will download
02:13 - you can open up that code and you can
02:14 - steal whatever code you need and
02:16 - reference it and make sure that you know
02:17 - it really was my mistake maybe uh-huh
02:20 - and not yours and that you can see if
02:21 - anything's going wrong but this code
02:23 - that I'm showing here is what we're
02:24 - gonna be recreating I already have it
02:26 - written full disclaimer on the left hand
02:28 - side of my screen so if you see me
02:30 - looking over there during this long
02:31 - tutorial that's what I'm doing just
02:32 - making sure I haven't messed anything up
02:34 - so the idea behind this game is that
02:36 - you're this ship you know you can shoot
02:37 - bullets and you want to just make sure
02:39 - that these little ships here don't get
02:41 - to the end of the screen and if they do
02:43 - you lose a life the idea behind what
02:45 - I've created here is this is kind of a
02:47 - basic guideline it's setting up the main
02:49 - functionality and then what you guys can
02:51 - do is add your own features to it and
02:53 - I'll talk about some extensions you can
02:54 - put on so you guys can make this game as
02:57 - custom as you want so the idea is to
02:59 - give you the core functionality show you
03:00 - how to do everything and then you guys
03:02 - can add and make it your own game
03:04 - afterwards so with that being said I
03:06 - think that has pretty much been it for
03:08 - this introduction what we're gonna do
03:09 - now is actually get into coding and just
03:11 - do a little setup for the project and
03:13 - then obviously start writing some code
03:14 - alright so the first thing we need to do
03:16 - for this project is actually install the
03:18 - module called PI game now PI game is
03:21 - this third party module once what we're
03:23 - gonna use to make this space shooter
03:24 - game and you do need to install it now a
03:27 - lot of people have difficulties with
03:28 - this this is probably the most difficult
03:29 - part of the tutorial for someone who
03:31 - doesn't work in Python very often
03:33 - doesn't understand how all this works so
03:35 - what you need to do if you're having
03:36 - troubles with the steps I'm about to
03:38 - show you here is click the card in the
03:39 - top right hand corner or click the link
03:42 - in the description that says how to
03:43 - install PI game that's an older video
03:45 - but it goes through exactly how to
03:47 - install PI game all of the common issues
03:49 - and problems and you should after
03:51 - watching that be able to come back here
03:53 - and follow along with no problem so what
03:55 - we're gonna do and just first of all
03:56 - obviously we need Python downloaded and
03:58 - installed I'm using Python version 3.7
04:01 - and the text editor that I'm gonna be
04:03 - using is sublime text now you can use
04:06 - whatever you want you can use the
04:08 - standard Python IDE you can see I have
04:10 - that installed on my computer as well
04:11 - doesn't matter
04:12 - what you write in but just because I get
04:14 - asked all the time I'm using sublime
04:15 - text
04:16 - now obviously download Python if you
04:18 - don't have that 3.8 should work if
04:20 - you're having issues at 3.8 download 3.7
04:23 - and then what we need to to do is use
04:25 - pip 2 and
04:26 - stall Piegan no pip stands for package
04:29 - installer Python believer Python yeah I
04:31 - think that's what it is
04:32 - anyways that comes by default with your
04:36 - Python installation so usually what you
04:38 - can do is open up a command prompt
04:40 - window if you're on terminal or open up
04:42 - a terminal window if you are on Mac or
04:46 - Linux and type pip install PI game like
04:51 - that now if you hit enter and you see
04:53 - something like this like requirement
04:55 - already satisfied or a finding module
04:57 - installing module you're good you
04:58 - install PI game you're ready to go
05:00 - that's all you need to do if you see an
05:03 - error that says PIP is not a recognized
05:04 - command go watch that video it'll show
05:07 - you how to install pip properly now if
05:10 - you're on Linux and if you're on Mac
05:12 - what you might introduce type of pip 3
05:14 - pip 3 stands for pip Python version 3
05:16 - because on those distributions or on
05:19 - those I guess operating systems they
05:20 - have Python 2 built in automatically so
05:23 - when you type pip that actually accesses
05:25 - the Python 2 interpreter not the Python
05:28 - 3 interpreter so try pip 3 try pip if
05:32 - this doesn't work again watch that video
05:34 - I have one for Mac and for Windows which
05:35 - I'll link in the description and once
05:38 - you get that what we're gonna do is just
05:39 - type Python in here or open up your ID
05:43 - le wherever you usually do your Python
05:46 - stuff just try to import the module of
05:48 - Pi game like that and if it works and
05:51 - you get this welcome message then you're
05:53 - ready to go and we're gonna get into the
05:54 - video right now so once we've done that
05:56 - what we're gonna do is actually a nun
05:58 - close this now set up a project
06:00 - directory or a folder on our computer
06:02 - where we're gonna store all of this
06:03 - stuff for this project so what I've done
06:05 - is I've made a folder I've called its
06:07 - space shooter tutorial and you can see
06:09 - I've already dragged in the image assets
06:11 - here so what you need to do if you don't
06:13 - have these assets which you won't use go
06:15 - to the description hit the link that
06:17 - says download image assets it will
06:19 - download a zip folder so you'll see I'll
06:21 - put this into a compressed one so that
06:23 - everyone can follow along here if we go
06:25 - what does it send to compressed zipped
06:27 - folder it'll be in a zip folder like
06:29 - this what you need to do is unzip it
06:31 - take this folder out so extract it and
06:34 - put it into the directory that we're
06:36 - gonna work in it's very important that
06:38 - when we do this the
06:39 - Python file we create is in the same
06:41 - directory as the folder that has the
06:43 - assets the assets are the images you can
06:46 - see I have things like this yellow ship
06:48 - which I'll bring up onto my other screen
06:50 - here we have the green ship the red ship
06:52 - and all of that ok so just make sure
06:54 - that you do that otherwise that's not
06:57 - gonna work ok so once we do that what
06:59 - we're gonna do is open up a Python
07:01 - window where we can write code so in
07:03 - this case I have sublime text but if you
07:05 - want you can open up ideally like that
07:07 - an ID le is perfectly fine to write code
07:11 - in as well but this is sublime text
07:12 - which is just a nicer editor so what I'm
07:15 - gonna do in here is make a new file and
07:16 - I'm gonna call this main dot pi now very
07:19 - very very important do not name this
07:22 - file PI game if you name this Python
07:25 - file PI game or any file in this
07:27 - directory is named PI game you your
07:30 - script will not work I learned this the
07:31 - hard way when I forgot to tell people
07:32 - that in the previous tutorial and I got
07:34 - a hundred comments do not name it PI
07:36 - game I know it's a tempting name just do
07:38 - not do that now again what we're gonna
07:39 - do to make sure everything's working
07:40 - here is just import PI game now
07:42 - fortunately for me in subline text I can
07:45 - click ctrl + the B key to run my script
07:48 - so that's what I'm doing here but for
07:49 - you guys if you need to run your script
07:51 - in your in IDL you
07:52 - obviously hit f5 or you can use the
07:54 - terminal window on back Linux whatever
07:56 - and do Python 3 or python the name your
07:59 - file when you're in the correct
08:00 - directory ok so once we import PI game
08:02 - what we're gonna do is import a few
08:04 - other things we're gonna import OS we're
08:05 - gonna import time and we're gonna import
08:08 - random so now we're actually ready to
08:10 - start writing some code so let's get
08:12 - into it
08:12 - all right so the first thing we need to
08:14 - do is actually load all of our image
08:15 - assets into our script so that we can
08:18 - use them and display them on the screen
08:19 - because the first thing I'm gonna do
08:21 - after we load these images in is
08:23 - actually start setting up the PI game
08:25 - window and talking a bit about some
08:26 - basic PI game syntax and how all those
08:28 - things work because obviously this is a
08:30 - module which means now we have some
08:32 - different syntax and some different
08:33 - tools we can use that aren't native to
08:35 - the Python language so notice again that
08:37 - this main dot Pi file is in the same
08:40 - folder where this assets folder is I
08:42 - don't have all these images inside
08:45 - directly with the main dot I the main
08:46 - dot pi is in the same level as assets
08:49 - that's really important and that's a big
08:50 - mistake if you don't have that
08:52 - so make sure you're listening pay
08:53 - attention and do that the first thing
08:55 - we're gonna do is load all these images
08:56 - so I'm gonna make a comment you don't
08:58 - have to do the comments if you don't
08:59 - want but this is just to make a little
09:00 - bit cleaner we're gonna load the images
09:02 - what I'm gonna do is use all capitals
09:04 - for my variable names gonna miss a red
09:05 - spaceship equals in this case PI game
09:08 - and not in all capitals hi game dot
09:12 - image dot load and I'll go through this
09:14 - after so don't worry if you're confused
09:15 - os path join and we're gonna do assets
09:20 - in here and then in here what we're
09:23 - gonna do is what was this file called I
09:26 - need to look at my other screen pixel
09:28 - underscores ship underscore red
09:31 - underscore small dot PNG okay so what
09:35 - this is doing this line of code and
09:36 - we're gonna do a bunch of these lines of
09:37 - code which I'll speed through in a
09:38 - second is we're saying from the PI game
09:40 - module use the image dot load method and
09:43 - then in here we're gonna load the image
09:46 - which is located at OS path join this is
09:50 - the name of the folder that our images
09:52 - are in notice that's assets right here
09:54 - on the left hand side of my screen and
09:56 - the name of the file is pixel ship read
09:59 - small PNG so if you look inside of here
10:02 - we can see we have pixel ship read small
10:04 - about PNG this is what it looks like a
10:06 - very basic you know five pixel thing and
10:08 - you can see that that's how we load this
10:10 - if we want to add a folder name to a
10:13 - file name cuz we're loading from a
10:15 - folder we can use OS path giant although
10:17 - note I could completely omit this line
10:20 - and some of you might be like well why
10:21 - aren't you doing this this is just the
10:22 - proper way to do it is to do assets
10:24 - slash and then the name of the file like
10:26 - that that works but we're gonna use OS
10:28 - path ajayan to make sure everything's
10:30 - clean so I'm gonna copy this a few times
10:32 - because we're gonna need to load all
10:33 - these files in rain they're gonna have
10:35 - to have all their file names so we have
10:37 - red spaceship we need green we need blue
10:40 - and we need yellow right so the yellow
10:43 - is gonna be our main player so I'll tab
10:45 - it down and say Claire ship like that
10:50 - just so we know and all we need to do
10:52 - for these ones up here is change red to
10:54 - the appropriate color so in this case
10:55 - that's gonna be green that's gonna be
10:57 - blue and I believe this one is just
10:59 - pixel ship yellow it doesn't have that
11:03 - small afterwards so pixel ship
11:05 - we can check that just by looking here
11:07 - yep there we go we got it and just make
11:09 - sure that you have that PNG extension
11:11 - otherwise obviously that's not gonna
11:13 - work
11:13 - so what we're gonna do now is we're
11:15 - going to install or not install sir a
11:17 - load in the bullets and the other asset
11:18 - so we need to load in the background and
11:20 - we need to load in at the bullet so
11:22 - let's say lasers is what I'm gonna call
11:24 - them and we'll say red underscore laser
11:27 - equals this case we'll copy this line up
11:30 - here paste it in and assets in this case
11:34 - I believe it's something like laser
11:36 - underscore red or something so let's
11:38 - look at this pixel laser ret yes okay so
11:42 - pixel underscore laser underscore red
11:45 - PNG let's copy this a few times and of
11:48 - course just change the colors to what
11:49 - they need to be so red green blue and
11:55 - yellow let's make sure that's all
11:58 - capitals let's change the file names now
12:01 - so pixel laser green pixel laser blue
12:07 - and pixel laser yellow okay so let's
12:11 - spell that correctly and now let's load
12:13 - in the background image let's say VG or
12:15 - background I'm just gonna call this one
12:18 - BG notice I spelt that comments wrong
12:21 - and BG is gonna be equal to in this case
12:23 - hi game image download OS poundage Orion
12:27 - assets and then what is this called
12:29 - background - black PNG so let's punch
12:31 - that in background - black PNG okay so
12:35 - now assuming we spelt all this correctly
12:37 - we have loaded in all these images to
12:39 - make sure this works we can run the code
12:40 - we don't get any errors this was
12:42 - successful
12:43 - now I'm if any of you have like
12:44 - corrupted images or something like that
12:46 - just try redownload encompasses it can't
12:49 - open the file even though it does exist
12:51 - but make sure again that they're in the
12:52 - correct folder their name the right
12:54 - thing and you're loading them in like
12:55 - this if you want to use your own image
12:57 - assets put them inside the assets folder
12:59 - and then you know name them what you
13:01 - need to name them and load them in like
13:02 - this okay so now that we have all of
13:04 - these loaded in what we're actually
13:06 - gonna do is set up our PI game window so
13:09 - the first thing we do when we're working
13:10 - in PI game is we create a width and
13:12 - height for our screen we set a name for
13:14 - the display and we just run it and make
13:15 - sure that it's working fine so the
13:17 - standard and the reason I've named these
13:19 - all cow
13:19 - by the way is because these are gonna be
13:20 - constants they're not changing and the
13:22 - convention in Python is to named
13:23 - constants with a capital what we're
13:25 - gonna do to make our window is we're
13:27 - going to say win equals PI game dot
13:29 - display dot set underscore mode and
13:32 - inside here we're gonna put a couple
13:34 - with a width and a height now we're
13:38 - gonna define the width height up here
13:39 - like this so width height equals in this
13:41 - case we're gonna do 750 by 750 you feel
13:44 - free to change this if you want and
13:46 - that's how we're gonna get started so
13:48 - width height equals 750 750 this just
13:50 - means with the 750 high to 750 we're
13:53 - gonna say win which stands for the
13:55 - window is equal to PI game dot display
13:58 - don't set underscore mode width height
14:00 - and width height just tells it this is
14:03 - how big our window is gonna be once we
14:05 - do that we're gonna set the caption or
14:07 - the name of our window so we can do that
14:09 - by saying tie game dot display dot set
14:12 - underscore caption and inside here we're
14:14 - just gonna call this space shooter and
14:17 - in my version I'm just gonna call it
14:18 - tutorial you guys can call it whatever
14:20 - you want so there we go space shooter
14:22 - tutorial now if we run the script we
14:24 - will see that a pie in window pops up
14:26 - and then just disappears because we're
14:27 - not doing anything else so if we've got
14:29 - that successfully things are looking
14:31 - good
14:32 - again feel free to change these numbers
14:33 - I'm on a 4k display so it's gonna look a
14:35 - lot smaller on my display than it is on
14:38 - yours if you're on 1080p right 750 by
14:40 - 750 will take on most of your screen if
14:42 - you're on a 1080p display but I'm on 4k
14:44 - so it's gonna be you know 1/4 the size
14:46 - is that how it works I think so maybe
14:48 - something like that alright quick water
14:52 - break there and now let's get into the
14:54 - next stuff that we need to do which is
14:56 - actually drawing and getting our main
14:58 - loop kind of set up so whenever we're
15:00 - working in PI game what we need to do is
15:02 - create a main loop which is gonna be
15:04 - kind of what handles all our events so
15:06 - it's gonna be what handles collision
15:08 - it's gonna be what calls things to be
15:10 - drawn on the screen it's gonna be what
15:12 - allows us to quit the game to move a
15:14 - character stuff like that so what I
15:16 - usually do is I define a function I'm
15:17 - gonna call this man which stands for
15:19 - main loop and inside here I'm gonna set
15:21 - up a few variables we're gonna need for
15:22 - the game so the first one we're gonna
15:24 - need is run run equals true is just
15:26 - gonna dictate whether this while loop is
15:28 - gonna run or not and then what I mean
15:30 - do is create an FPS which stands for
15:33 - frames per second and set that equal to
15:35 - 60 now of course you can change this to
15:37 - whatever you want the higher this number
15:39 - the faster your games gonna run the
15:41 - slower this number or the lower this
15:43 - number the slower game's gonna run now
15:45 - just keep in mind you don't want to make
15:46 - this number too low because if you do
15:48 - then that means that you're only gonna
15:50 - be checking for collision and checking
15:52 - for events once every whatever this
15:55 - number is so in this case we say 50
15:57 - frames per second what that means is
15:59 - we're gonna show 50 frames ever sorry 60
16:02 - frames every second and that means that
16:04 - we're gonna check collision we're gonna
16:06 - check if we're moving the character once
16:08 - or 60 times every second so the way that
16:12 - we can set that up in PI game is by
16:14 - making a clock object so we're gonna say
16:16 - clonk equals PI game dot time clock with
16:22 - a capital C like that and inside of here
16:25 - we're gonna say clock dot tick and make
16:27 - sure this is at the top of your while
16:28 - loop fps so we're essentially saying
16:31 - we're gonna tick this clock based on
16:34 - this frames per second rate so 60 FPS
16:36 - and what this allows us to do is make
16:38 - sure our game stays consistent on any
16:40 - device that we give it to so if we run
16:42 - this on a really fast computer or a
16:44 - really slow computer it doesn't matter
16:46 - it's gonna run at the same speed because
16:47 - we've set that clock speed of 60 FPS now
16:50 - what we typically do inside of here is
16:52 - start drawing stuff on the screen and
16:54 - start checking for events so what we
16:56 - need to do first is check for events and
16:58 - the first thing we actually want to do
16:59 - is check if the user has quit our window
17:02 - so to do that we're gonna say for event
17:04 - in high game dot event dot get and what
17:08 - this is essentially saying is every time
17:10 - we run this loop so once every or 60
17:13 - times every second we're gonna loop
17:15 - through all the events that PI game
17:17 - knows and we're gonna check if an event
17:18 - has occurred if that event occurs do
17:21 - something right so an example of event
17:23 - is like pressing a key is pressing the
17:25 - quit button is pressing the mouse button
17:27 - something like that you can look up the
17:29 - events from the PI game website if
17:30 - you're trying to do something different
17:32 - but most of what I show you is pretty
17:33 - much all you'll need so now what I'm
17:35 - going to say is if event dot type equals
17:38 - equals PI game like this if I could
17:41 - spell correctly dot quit with all
17:44 - capitalist then we're gonna say is run
17:46 - equals false so what this means is
17:49 - pygame quit is if we press that top
17:52 - right the X in the top right hand corner
17:54 - of our screen quit the screen like quit
17:57 - PI games stop running so that's why
18:03 - you'll notice I said run equal to false
18:05 - so the next time we get to the top of
18:06 - this loop we won't loop anymore because
18:09 - we quit right and that's the idea behind
18:11 - that so we could check for other events
18:13 - in here in fact I'll show you another
18:14 - common type of event so if a vente type
18:17 - equals equals pi game talk key down what
18:20 - that means as we press some key
18:22 - downwards if we did that will trigger an
18:24 - event that's what this means now we're
18:26 - not gonna use that inside the event li
18:28 - because i'm gonna show us a different
18:29 - way to move things around but this is
18:31 - the basic loop that we need right now so
18:33 - let's actually go ahead and call this
18:35 - function and run it and just make sure
18:36 - that the quit button is working and show
18:38 - you what I mean so you can see that it
18:39 - pops up now our window we have space
18:42 - shooter tutorial and we can click the X
18:43 - button and if we do that it exits the
18:46 - window if you don't have this event here
18:49 - it will not exert the window when you
18:51 - press the quit button so that's just
18:52 - something to keep in mind you need to
18:54 - make sure that you make run equals false
18:56 - and eggs and out of our infinite loop
18:58 - that's gonna happen here that's running
18:59 - the entire game its handling collision
19:01 - movement all of that when that starts
19:03 - happening okay so now that we have that
19:06 - we should probably start drawing some
19:07 - things under the screen and the first
19:09 - thing that comes to mind for me is the
19:10 - background so I'm gonna do something
19:12 - that might seem a little bit confusing
19:14 - to you guys try to look past um you know
19:16 - really the inner workings of how this
19:18 - works and just understand that this is
19:21 - possible I'm gonna make a function
19:23 - inside of this main function that I'm
19:25 - gonna call redraw window now the idea
19:28 - behind this is that when we do things
19:30 - like in games and just in programming in
19:32 - general we typically want to separate
19:35 - things out into their own functions and
19:37 - create small pieces of logic that do
19:39 - things quite well they do one or two
19:41 - things like just one thing quite well so
19:43 - it rather than drawn all the different
19:45 - things because we're gonna have to draw
19:46 - a lot of different things within this
19:48 - while loop we're gonna put it in a
19:49 - function that's inside of a function and
19:52 - just call that when we need to use it so
19:54 - just treat this like a regular function
19:56 - but just understand
19:57 - that since it's indented and it's
19:59 - defined inside of this main function we
20:01 - can only call it when we're in this
20:03 - function and that's totally fine that's
20:05 - all we need to do but this is going to
20:06 - allow us to access all of these
20:08 - variables defined inside of the function
20:10 - rather than making it its own function
20:12 - and having to pass them all through as
20:14 - parameters which can get quite annoying
20:16 - when we have a lot of things that we
20:17 - want to pass so again yeah the idea is
20:19 - that this is gonna draw everything for
20:21 - us on the screen it's gonna handle all
20:23 - our drawing anything that needs to be
20:24 - rendered stuff like that so he can just
20:27 - be in its own separate piece so if
20:28 - something goes wrong with drawing we
20:29 - know right away where that is it's in
20:31 - redraw window so the first thing we need
20:33 - to do is do PI game display dot update
20:37 - and in fact what this does is refresh
20:40 - the display so the way PI game works is
20:43 - we have a bunch of things called
20:44 - surfaces now these surfaces can be drawn
20:47 - on we can blit things onto them which
20:49 - means like put an image onto them or
20:51 - something like that
20:52 - and the way that it works ideally is we
20:56 - have this one surface and every time
20:58 - that we loop so we run one of these
21:00 - while loops so 60 times a second we're
21:02 - gonna redraw everything onto the screen
21:05 - and then refresh it so that it has the
21:08 - updated version so the first thing we
21:10 - need to do since we're gonna be
21:11 - redrawing everything is draw a
21:14 - background image as our first thing so
21:16 - what that will do is it will cover any
21:18 - stuff that was behind or drawn before
21:20 - and then we draw everything on top of
21:22 - that background image that's gonna be
21:24 - shown for the next frame and you
21:25 - understand what I mean in a second but
21:27 - just bear with me here so what we're
21:29 - gonna do is do win job blitt BG comma
21:34 - zero zero now what this is saying is win
21:38 - is a surface right it's this PI game
21:40 - surface that we've set up as our main PI
21:42 - game window at the top of our screen so
21:44 - a method that's available on this is
21:46 - called blit now what blitt does is take
21:48 - one of these images so one of these PI
21:50 - game images it can be some other things
21:52 - as well
21:52 - which really have been turned into
21:55 - what's called a surface in PI game and
21:57 - draws it to the window at the location
22:00 - that we defined here now an interesting
22:03 - thing with PI game is the way that we
22:05 - actually use a coordinate system so I'm
22:07 - gonna bring up my drawing tablet here to
22:09 - show you what I mean
22:10 - cut some networking stuff on there and
22:12 - show you what I mean by the coordinate
22:14 - system so let's say this our PI game
22:15 - window and just excuse me cuz I am
22:16 - drawing with my mouse we know we have an
22:19 - x and y right so this is our x-axis this
22:21 - is our y-axis and typically we think
22:24 - that zero zero is the bottom left well
22:27 - that's actually wrong or different in Pi
22:30 - game in fact zero zero is the top left
22:32 - so what that means is that our x
22:35 - coordinates are the same as we would
22:36 - assume if we want to increase X we're
22:38 - going to the right or if we want to go
22:40 - to the right we increase X so X goes
22:41 - like that but Y actually goes down which
22:45 - means that if you set something at
22:47 - position y 0 it's at the very top of the
22:50 - screen and if you want it to go
22:52 - downwards you need to increment the Y so
22:54 - let's say I want to move a character
22:55 - down I need to increase its Y value
22:58 - that's what I'm getting at here now this
23:00 - is the same for objects so let's say we
23:02 - have a little square and we want to draw
23:03 - it on the screen well the top left hand
23:06 - corner is where we're gonna draw this
23:09 - object from so if I say I'm drawing a
23:11 - square at 25 25 what that means is that
23:15 - I'm gonna draw this square starting at
23:17 - the top left position of 25 25 so if the
23:20 - width of our square is say 30 if I can't
23:23 - draw a 3 this pen size is too thick
23:25 - let's see if we go let's do 20
23:28 - that's my rough version of a 20 that's a
23:30 - 2 if the width is 20 and we draw it at
23:34 - 25 that means that this corner here
23:36 - right so this right corner is actually
23:38 - gonna be a quick math 45 right so that's
23:41 - what we need to understand top left hand
23:43 - corner is the coordinate system for
23:45 - pygame so just keep that in mind when
23:46 - I'm drawing things so when I say wind up
23:49 - lit background at 0 0 that means take
23:51 - that background image and draw it at 0 0
23:54 - in the top left hand corner of our
23:55 - screen and since we're gonna draw the
23:57 - image starting at the top left hand
23:59 - corner it will fill the entire screen
24:01 - now the only thing is though we're gonna
24:03 - see when we run this well actually if if
24:06 - we wind up lit if we call this function
24:09 - one second sorry so let's call this
24:10 - function now from inside of here so
24:13 - redraw window so just inside this main
24:16 - loop we're gonna go clock tick
24:17 - immediately call the redraw window in
24:19 - here it just splits the background and
24:21 - updates the display so let's run this
24:23 - notice that the background is not the
24:25 - correct size so what we're gonna do is
24:27 - actually scale this background up you
24:28 - can see it's about 1/4 the size it
24:30 - really needs to be so we're gonna make
24:32 - it 2 times bigger just about said it
24:34 - fills the entire screen so to do that
24:36 - we're gonna go up to where we loaded it
24:38 - in on background and we're gonna use
24:41 - another method so we're gonna say pygame
24:42 - dot transform dot scale and what we're
24:46 - gonna do now is put this entire image so
24:48 - this whole line we had before as the
24:50 - first argument and then as the second
24:52 - argument we're gonna put what we want to
24:54 - scale this image to so the dimensions so
24:56 - in this case it's gonna be width height
24:58 - where width height is those variables we
25:00 - defined earlier for the width and height
25:02 - of the screen so if we run this now
25:04 - notice that it fills the entire screen
25:06 - because we scaled that image and then
25:09 - we're drawing the scaled image onto the
25:11 - screen now you can see we get some
25:12 - little pixelated stars and some fun
25:13 - stuff like that
25:15 - okay so I guess the next thing to do is
25:18 - to actually deal with drawing a few
25:20 - things else on the screen we'll get into
25:21 - characters and stuff in a second but
25:24 - like the score the level were on things
25:27 - like that so let's do that first
25:28 - we're gonna say score watch the eyes
25:30 - it's not score we're just gonna have
25:31 - level and lives
25:33 - so we'll say level starts on level 1 and
25:35 - we'll say lives starts on 5 feel free to
25:38 - increment that if you want doesn't
25:39 - really matter to me and I'll show you
25:41 - how we can draw those to the window so
25:43 - how can we actually draw text so you saw
25:45 - I had lives and I had level at the top
25:49 - right and left hand corner screen how do
25:50 - we do that
25:51 - well what the first thing we need to do
25:53 - is actually create a font in PI game so
25:56 - a font allows us to kind of render that
25:59 - font so for example Comic Sans is what
26:00 - I'm gonna use we need to create the font
26:03 - object and then use that font object to
26:05 - actually render the text to the screen
26:07 - so that the annoying thing in Pi game is
26:09 - that you need to initialize fonts for
26:11 - them to work so that's pretty easy but
26:12 - at the top of our program right after we
26:14 - import PI game here we're gonna say PI
26:16 - game fonts dot and yet this just tells
26:19 - PI game kick get setup get the font
26:21 - ready to go so that there's no issues
26:22 - when we want to start using it so that's
26:24 - what we'll do PI game dot font done it
26:26 - and now inside of our main here I'm
26:28 - gonna define main underscore font so
26:32 - that's a variable name is equal to in
26:34 - this game
26:35 - pi game font
26:37 - . sys font and here we're going to name
26:41 - the fonts there's all kinds i'm not
26:43 - going to go through them but the one
26:44 - that i usually use is comic sans and
26:46 - then the size of this font so the size
26:49 - i'm gonna use is fifty make it smaller
26:51 - bigger depending on what you want and
26:53 - now i'm gonna show you how we can use
26:55 - this to actually draw the lives and the
26:58 - level on the screen so here I'm gonna
27:00 - make a comment I'm gonna say draw you
27:03 - know text like that and the first thing
27:05 - we need to do is make a label and then
27:07 - blit that label to the screen so you saw
27:09 - how i blitt this surface which is the
27:11 - background to the screen what i need to
27:13 - do is turn some text into a surface and
27:16 - then put it on the screen so i'm gonna
27:18 - say do i guess this would be lives
27:21 - underscore and label is equal to main
27:24 - underscore font which we've defined up
27:26 - here which is comic sans size fifty dot
27:29 - render and here i'm gonna type what i
27:32 - want to render so in this case i want to
27:34 - render an f string if you're not
27:35 - familiar with f strings what this allows
27:37 - you to do is embed variables inside of
27:39 - brackets like this so left brace rice
27:42 - right brace at the curly brackets so i
27:44 - can do something like level : level and
27:47 - what this will do is take the value of
27:49 - the variable level here and just show
27:50 - that and so that's with an f preceding
27:53 - this string now that only works in
27:57 - Python 3.6 and above so just keep that
28:00 - in mind when you're running through this
28:01 - okay so then our next arguments are 1
28:04 - and color so 1 stands for anti aliased
28:08 - you can see that's popping up here I'm
28:10 - not gonna explain really what that is
28:11 - you're just pretty much always gonna use
28:13 - one if you're bleeding something or
28:14 - rendering texturing and then color is an
28:17 - RGB color so RGB stands for red green
28:20 - blue it's a value between 0 and 255
28:23 - inclusively that means you can use 0 and
28:25 - you can use the value 255 and if you
28:28 - wanted to make say red well it's red
28:30 - green blue so you say I'm gonna use the
28:32 - maximum amount of red the minimum amount
28:35 - of green and the minimum amount of blue
28:38 - that would give you red if you wanted
28:40 - RGB if you want to blue then you would
28:42 - do 0 0 255 if you want white funny
28:46 - enough it's 255 255 255 because white is
28:50 - actually a combination of all
28:51 - colors so that's why or combination all
28:53 - of red green blue that's what you do
28:55 - like that if you wanted black it'd be
28:57 - zero zero zero and you know you can look
28:59 - up RGB color codes and find them quite
29:01 - easily on the Internet
29:02 - so limes label will be that will say
29:04 - level oh I just realized I called this
29:06 - level it should be lives my bad so lives
29:09 - lives
29:11 - let's do level label so level label
29:13 - equals main underscore font dot render
29:18 - do an F string again not a D string and
29:20 - F string and we will do level colon and
29:26 - this time we'll do level and then we'll
29:29 - do one two fifty five two five two five
29:32 - so to summarize this has created text
29:34 - which is white anti-aliasing of one that
29:37 - has these contents and now we need to
29:38 - put on the screen so I put on the screen
29:40 - we're gonna say win double its first one
29:43 - what do you want the lives label okay
29:45 - lives underscored label and the position
29:48 - that we want to put it on we need to
29:49 - pick an XY I want it in the top left
29:52 - hand corner of my screen but not like
29:54 - directly in the top left-hand corner
29:55 - just a little bit offset so I'm gonna
29:57 - say ten ten so ten pixels down ten
30:00 - pixels right is where the top left-hand
30:02 - corner of the label will sit so it will
30:05 - sit just barely offset from the top of
30:07 - the screen and then we're gonna win da
30:09 - blitz be level label of course and here
30:13 - for our XY z-- can be a little bit
30:14 - different I want this on the right hand
30:16 - corner of the screen so I'm gonna take a
30:18 - guess that's actually you know what
30:20 - let's do the mathematical way cuz we're
30:22 - going through some in-depth explanations
30:24 - here anyways if I want this to be ten
30:26 - pixels from the right-hand corner of the
30:29 - screen what I need to do is determine
30:30 - the top left-hand corner of the label so
30:33 - where should I put that right let's say
30:35 - like I want the label to sit so that the
30:37 - edge of the label is only ten pixels
30:39 - from the far right hand right hand side
30:42 - of the screen so to do that I need to
30:44 - figure out the top left hand corner
30:46 - position well what I can do is find the
30:49 - width of this label I can find the width
30:52 - of the window and then I can take my
30:55 - padding whatever I want the padding to
30:56 - be and use some mathematical equation to
30:58 - figure out where that should be
30:59 - so thinking off the top of my head here
31:02 - it's gonna be width which is the width
31:03 - of the when
31:05 - to itself so whip - in this case it's
31:09 - gonna be level underscore label dot get
31:12 - underscore wit so we've got underscore
31:15 - width is a method you can use on
31:16 - surfaces that tells you the width of
31:18 - that surface so since I don't know the
31:20 - width of this level label because I
31:21 - don't know how big or how long this text
31:23 - is gonna be I need to call that method
31:25 - and then I'm gonna subtract another ten
31:27 - pixels because if I left it at this that
31:29 - would mean that it would be right on the
31:31 - edge so like the L or like whatever this
31:33 - level number is would be squished right
31:35 - on the edge so we'll subtract ten pixels
31:37 - to move it off and then we'll pick a
31:39 - y-value which is gonna be the same as
31:41 - what we used before as ten and blitt
31:43 - that to the screen so let's look at this
31:45 - now and notice we get lives five level
31:47 - one perfectly in the right position I
31:50 - mean say that you know we had we changed
31:52 - the width so actually let's do that
31:53 - let's change the width to be 800 so
31:56 - let's go
31:57 - like this if we change the width
32:00 - everything works fine and in fact I can
32:02 - change any numbers I want because we've
32:04 - done this in a dynamic fashion
32:06 - everything will stay consistent it will
32:08 - stay totally fine so we'll put him back
32:09 - to 750 750
32:11 - but that's why I've been doing things
32:12 - maybe in a more tedious way rather than
32:14 - just hard coding because I want this to
32:16 - work for any width height that I choose
32:18 - so let's zoom out a tiny bit there let's
32:20 - move that over and now it's getting to
32:22 - some more stuff so we've displayed the
32:23 - lives displayed the level now we need to
32:25 - make a character and in fact we want to
32:28 - move a character around the screen so
32:30 - the first thing I'm gonna do is set up a
32:32 - ship class so I'm gonna say class ship
32:35 - this is gonna be what we call an
32:36 - abstract class which means we're not
32:39 - actually gonna use this class we're
32:41 - gonna inherit from it later because keep
32:44 - in mind we have enemy ships and we have
32:46 - player ships right those are the two
32:48 - parts of our game really right and
32:50 - they're interacting with each other so
32:51 - the enemy ship probably has some similar
32:54 - properties to the player ship so we can
32:56 - share that in one kind of upper level
32:58 - class and you'll understand how this
33:00 - works more but just follow along with me
33:02 - for now so we're gonna make in an it
33:03 - method we're gonna say okay so what are
33:06 - some properties of a ship that we want
33:08 - to store in this game
33:09 - well we need the x position and the y
33:11 - position the ship so where is the ship
33:12 - starting is it starting at the top is it
33:14 - on the left is it in the middle so let's
33:16 - go X Y like that
33:18 - what color is this ship that's something
33:20 - that's important right so what color and
33:21 - what about the health does this ship
33:23 - have a specific amount of health in fact
33:25 - I'll make this an optional parameter of
33:26 - a hundred which just says that our
33:28 - default ship has a health of a hundred
33:30 - right so the reason we need to put color
33:33 - here is because when we have an enemy
33:35 - ship we don't know what color it's
33:37 - really gonna be right
33:38 - so that's what we'll define with this
33:40 - color parameter when we create a new
33:41 - ship is it red is it green or is it blue
33:44 - it can't be yellow because yellow is
33:45 - gonna be the main ship the one that
33:47 - we're using to to shoot out the other
33:49 - ship right alright so actually what I'm
33:51 - gonna do is remove this color parameter
33:52 - for now just because since this is a
33:54 - general ship class for our player ship
33:57 - we already know what color that's gonna
33:59 - be it's only the enemy ship that will
34:01 - you know change its color on
34:02 - initialization so we'll define that
34:04 - later but let's let's just just ignore
34:06 - if that confused you at all
34:07 - the color aspect that I was talking
34:09 - about so we have self-taught x equals x
34:12 - and something like was y these are
34:14 - setting up attributes for the class so
34:16 - that each ship we create can store you
34:19 - know it's x value and it's y value right
34:21 - and i'm gonna try to go through basics
34:23 - of up here like give you a little bit of
34:25 - an explanation in case some of you
34:26 - aren't familiar with the syntax but just
34:28 - follow along and understand that what
34:29 - i've done is made of ship what this
34:31 - class allows me to do is make objects of
34:34 - it so i can have multiple ships that all
34:37 - have these attributes so they all have
34:39 - an X they all have a Y and they all have
34:41 - a health that's what the class is
34:42 - letting me do is later we'll create an
34:44 - instance of it which means that we can
34:46 - have multiple instances of a ship that
34:48 - all store their own health value their
34:50 - own X in their own Y and they all move
34:52 - on their own kind of terms right and
34:53 - that's the idea here we're gonna have
34:55 - multiple things so let's put it into
34:56 - objects in classes okay so we've done
34:59 - that I'm gonna say slash ship underscore
35:02 - image equals none talk about this in a
35:04 - second slash laser underscore image
35:07 - equals none and self-thought lasers
35:10 - equals blank and self dot cool down
35:14 - counter equals zero now the idea behind
35:18 - this is that when we start shooting
35:20 - lasers we want to make sure that we
35:23 - can't just spam the lasers so I'm going
35:24 - to define a cool-down counter here which
35:27 - essentially means we're going to count
35:29 - and we're going to wait
35:30 - like half a second before we let the
35:31 - user shoot another laser well get a lot
35:34 - more later but you know we're just
35:35 - starting to class these things out
35:36 - just so that we have that okay so we
35:39 - have that now defined ship and what we
35:42 - can actually do in here is define a few
35:44 - methods so the first one that I want to
35:45 - do is draw so actually let me go back
35:48 - here for a second just because I feel
35:50 - like some people might be confused on
35:51 - this so self that ship image and self
35:53 - thought laser image are what is actually
35:56 - going to allow us to draw the ship and
35:57 - draw the laser so we need to pick what
36:00 - image from the ones up here that we've
36:01 - loaded in are we gonna use for this
36:03 - specific ship since this is a general
36:06 - class and it's not gonna be instantiate
36:09 - I'll show you what I mean in a second we
36:11 - just define them as as none for now but
36:13 - when we actually set up our own ship
36:14 - later and start creating ships we'll
36:16 - define those images so that we'll be
36:18 - able to use them okay so we have draw so
36:21 - draw is gonna be important for now and
36:23 - what I actually want to do cuz I just
36:24 - want to show you guys how we can move
36:25 - around the ship before we get into
36:26 - anything too complicated is just draw a
36:28 - rectangle for now so I'm gonna say we're
36:30 - gonna take a window in the parameter so
36:32 - this is gonna tell us where do we draw
36:34 - this like where are we putting this
36:36 - we're gonna say window and that's no
36:40 - Noblet we're gonna say pygame dot Rex
36:43 - sorry PI ChemDraw dot rect what this
36:46 - says is PI game use the draw module dot
36:48 - draw rectangle
36:49 - we're gonna pick where so we're gonna
36:51 - draw that on the window we're gonna pick
36:53 - a color let's make this red for now so
36:55 - to 3500 for red we need to put a rect
36:58 - in here now this is a X Y width height
37:01 - which tells us how big is this rectangle
37:04 - and where is it on the screen so where's
37:06 - it gonna be well it's gonna be at self
37:07 - dot X self-thought Y because that's the
37:09 - position of this ship and how wide is it
37:12 - gonna be well for now since we're just
37:14 - testing things let's make it 50 by 50
37:16 - now if we wanted the rectangle to not be
37:19 - filled in we could define a width so
37:21 - let's say we define a width of 2 that's
37:23 - gonna give us a hollow rectangle with
37:24 - two pixel size for the pen size around
37:27 - but if we want to be filled in we can
37:29 - leave it as nothing or put zero
37:30 - explicitly which tells us that that
37:32 - means this is a filled in rectangle okay
37:35 - so now that we have that I'm going to
37:37 - show you how we can use this ship and
37:40 - then we'll start getting into some more
37:41 - advanced things but I do I want to show
37:43 - moving around first so let's make a
37:45 - shift let's say ship equals ship and
37:47 - here we need to pick an x and a y value
37:50 - to start the ship at so I want to start
37:52 - it near the bottom of the screen so what
37:54 - I'm gonna do is pick like 300 by 650 and
37:58 - then what we'll do we don't need to
38:01 - define a health because that's an
38:02 - optional parameter right we've already
38:03 - had that to find is inside of my redraw
38:06 - window I want to draw this ship so what
38:09 - I'm gonna do is a ship dot draw window
38:14 - now the idea behind this is that this
38:16 - draw method draws the rectangle for us
38:18 - all it needs is a window so what we can
38:21 - do is just call that draw method if
38:23 - there's any more advanced stuff that
38:24 - needs to happen we don't need to deal
38:25 - with it here the ship can deal with that
38:27 - itself in its own draw method so let's
38:29 - just call it with the window now we'll
38:31 - see the ship so let's run this and we
38:32 - notice that I've made a mistake let's
38:35 - see what this make window is not defined
38:37 - my bad we need to put capital win in
38:39 - their window is the parameter name I'm
38:41 - messing it up so let's do win we run
38:43 - this we get this red red rectangle
38:45 - popping up at the bottom of the screen
38:46 - so if I want to much start moving this
38:49 - rectangle around now I need to modify
38:51 - its X&Y position based on what keys I
38:55 - press let's do that now so to do that
38:57 - we're gonna set up a way to track what
39:00 - keys are being pressed by the person now
39:02 - I could show you how to do it inside
39:04 - this event loop but the issue with that
39:06 - is it only registers one key press at a
39:08 - time so let's say I press like the side
39:10 - key and the top key at the same time it
39:12 - won't move both ways it will only move
39:15 - one of them whatever one you hit first I
39:17 - want it so I can move diagonally as well
39:20 - so I can move at the same time by just
39:21 - holding down keys so we'll be allowed to
39:23 - do that by pressing both keys at the
39:26 - same time with this method so what I'm
39:28 - gonna do them SI keys equals PI game key
39:32 - don't get underscore pressed what this
39:35 - does is return a dictionary of all of
39:38 - the keys and tells you whether they are
39:40 - pressed or not at the current time so
39:43 - since this runs once or 60 times every
39:45 - second I'm gonna mess that up every time
39:47 - I say it so just get used to it
39:49 - we'll check you 60 times every second if
39:52 - we're pressing a key if we are we'll
39:54 - move in a certain direction if we're not
39:56 - we
39:56 - so let's say if keys and here
40:00 - tie game dot k underscore so k
40:04 - underscore is just the prefix for what
40:06 - keys you can use so you do PI game and
40:08 - then there are keys since it's a
40:10 - dictionary we're gonna access the value
40:12 - and see if it's true pi game dot K
40:15 - underscore and then whatever key it is
40:17 - that you want so if you want a you type
40:19 - a lowercase a if you want to check if
40:21 - the left arrow key is being pressed you
40:23 - do left if you want enter it's actually
40:25 - gonna be returned if you want space it's
40:27 - all capital space you see I have this
40:30 - nice autocomplete that's telling me but
40:31 - ideally you can kind of guess with just
40:33 - lowercase letters and anything that's
40:35 - like a full word like enter or something
40:37 - or return is gonna be all capitals so if
40:40 - one move left we're in say if keys PI
40:42 - game can underscore a and then we'll go
40:44 - hash tag left I'm just gonna do a
40:46 - comment so that tells me we're moving
40:47 - left and to move left I need to subtract
40:50 - from the x value of my player so I'm
40:52 - gonna say ship dot X minus equals one
40:57 - now minus equals one means we're gonna
41:00 - move one pixel to the left now ideally
41:02 - what I should do actually is define a
41:04 - velocity variable which tells me how
41:06 - fast I'm allowed to move in every
41:08 - direction so let's do that
41:10 - at the top here I'm gonna say player
41:13 - underscore Val equals and let's pick
41:16 - some number I'm gonna pick five what
41:18 - this means is every time I press this
41:20 - key I can move five pixels so you can
41:23 - you'll figure out how fast that is when
41:25 - we start testing the game but that will
41:26 - also be dependent on your clock speed
41:28 - right so if you had a lower clock speed
41:30 - you probably want a higher velocity
41:32 - because this loop is only running so
41:34 - often so if I held down my key with a
41:37 - higher clock speed I'm gonna move more
41:39 - because this is gonna trigger and happen
41:41 - more times and move me more to the left
41:44 - right so let's do minus equal ship on
41:46 - your score Val or player underscore Val
41:48 - like that and now let's do the other key
41:50 - so I'll go a little bit faster here if
41:52 - keys as I say I'm going faster makes a
41:55 - bunch of mistakes pi game K underscore D
41:59 - so this is to the right like that make
42:02 - sure I don't forget that cool in there
42:03 - then we'll say ship dot X plus equals
42:07 - player underscore bail
42:09 - if keys pygame k underscore and this is
42:15 - gonna be double use for up we're gonna
42:16 - go up like that and then ship oops
42:20 - ship dot y minus equals player dot
42:24 - velka's remember moving up so we need to
42:26 - subtract the velocity because the
42:27 - starting position is zero zero and the
42:29 - top left and we're gonna say if keys pi
42:33 - game k underscore s which is gonna be
42:36 - down notice I'm using WASD you could use
42:39 - the arrow keys if you want by changing
42:40 - this to be all capital left all capital
42:43 - right all capital L capital down but
42:45 - let's do this we'll do it down then ship
42:48 - duck y plus equals player under squared
42:52 - bail okay so now that we have that what
42:55 - this will do is move our player so let's
42:58 - run this and let's have a look so if I
42:59 - use my WASD you can see that this cube
43:02 - now moves around the screen so let's now
43:05 - start restricting how this cube can move
43:07 - because notice I'm gonna go completely
43:08 - off the screen I can go any direction of
43:10 - I want right and maybe you might think
43:11 - this is a bit too fast as well so let's
43:13 - make sure that we can't move off the
43:15 - screen so to do that what I'm gonna do
43:18 - is say if keys PI game duck a underscore
43:21 - s and ship dot y plus player bail is
43:30 - less than height so what this is saying
43:34 - is if I add sorry not Val what am I
43:37 - saying player underscore bail if I add
43:39 - this player velocity value to the
43:41 - current value of my why will I be off
43:44 - the screen if I'm not off the screen
43:47 - let me move because I'm less than height
43:49 - which means I'm not off the screen so
43:50 - I'm trying to move down right otherwise
43:52 - don't that's what that's saying so
43:54 - that's that's that line so now let's see
43:55 - the other ones and ship got Y minus
43:59 - player underscore bail is greater than
44:02 - zero because we're moving up so we want
44:04 - to make sure that we're not going to be
44:05 - less than zero when we're doing that and
44:08 - for right we'll say and ship dot X plus
44:14 - player bail is less than width right and
44:20 - we'll say and
44:21 - ship dot in this case x- player
44:27 - underscore bail is greater than zero so
44:30 - now if we run this you'll notice that I
44:33 - can't go down while I can but it stops
44:36 - me I can't go left right if I try to go
44:39 - up I can't go up if I try to go right
44:41 - though I can go all the way off but just
44:43 - not like only here now the reason why I
44:46 - can go this far off is because the top
44:49 - left-hand corner is what I'm checking so
44:51 - right now
44:52 - technically the constraint that I've
44:54 - plugged in here that's in my code is
44:55 - valid because the top left is still in a
44:58 - valid position what I need to check
44:59 - though is if the edge of this cube is
45:02 - hit so the way I do that is by getting
45:05 - the win right so what I can do is a
45:07 - quick fix here is say if I'm moving to
45:10 - the right let's add 50 because that's
45:12 - the wick of the cube and make sure that
45:14 - the top left-hand corner is further
45:17 - enough to the left such that you know
45:19 - even if I'm adding this width it won't
45:21 - go off so that's the idea here with
45:23 - going rights and now same thing with the
45:25 - bottom so if I add 50 to the bottom so
45:28 - when I'm going down I want to make sure
45:30 - that the bottom edge doesn't go off the
45:32 - screen so that's how you do that is you
45:33 - just add the width to that equation so
45:35 - now notice I can't go any further than
45:37 - that and if I go to the right I can't go
45:38 - any further than that now obviously
45:40 - we're gonna change this because we're
45:42 - gonna use like proper graphics in a
45:44 - second but I wanted to show you how to
45:45 - move first in a more fundamental aspect
45:47 - so you understand the mechanics behind
45:49 - what I'm doing okay so now that we've
45:51 - done that let's actually make a proper
45:53 - ship so let's make a proper player ship
45:55 - rather that that has the proper graphics
45:57 - rather than what I've just done right
45:58 - here so in draw what I'm actually gonna
46:01 - do here is go window blitz and I'm gonna
46:04 - say ship or self dot ship underscore
46:09 - image this is just how I reference the
46:11 - attributes that are specific to this
46:13 - ship so the one that's being drawn I'm
46:15 - gonna draw this at self dot X self dot y
46:18 - like that so draw window tuplets self
46:21 - that ship self that excel taught why
46:23 - we'll get into the laser stuff later but
46:24 - that's like further on once we have the
46:26 - graphics working okay
46:28 - so we'll do that and now what I'm gonna
46:29 - do is to find a new class and then call
46:31 - this flare now the player is going to
46:33 - inherit
46:34 - from ship which means that it's gonna
46:36 - take this initialization it's gonna take
46:38 - this draw method and use it we're gonna
46:40 - add more stuff to the ship class later
46:42 - that will make this make more sense this
46:44 - inheritance but for now just understand
46:46 - that any methods in here because I've
46:49 - defined this inheritance means I can now
46:51 - use them inside a player so what I'm
46:53 - gonna do is to find the net inside of
46:55 - player so define undescribed square net
46:57 - self XY health like that health will be
47:01 - a default parameter of 100 once again
47:03 - and what I'll just do immediately is
47:05 - called ish this initialization method
47:08 - from inside of here so to do that I'm
47:10 - gonna say super dot underscore
47:11 - underscore net underscore underscore
47:13 - self XY health like that I don't know if
47:18 - this takes self I don't actually think
47:20 - it does I think it's just XY health what
47:22 - this says is super is this parent class
47:25 - ship let's use ships initialization
47:27 - method on this so we define our own
47:30 - initialization method because we're
47:32 - gonna need to change a few things in
47:33 - here which I'll show you in a second but
47:35 - let's use the super method so it creates
47:37 - all of these different variables that we
47:39 - need and it initializes things right it
47:40 - just runs that code and now let's add
47:42 - our extension we're gonna say self dot
47:44 - ship underscore image equals yellow ship
47:48 - and self the laser underscore image
47:50 - equals yellow laser so we've defined how
47:54 - these two non parameters so now we have
47:56 - those we're good to go and what we need
47:58 - to do next is create what's called a
47:59 - mask so what a mask is gonna let us do
48:02 - is do pixel perfect collision so you may
48:05 - notice in other games where there's like
48:06 - weird hit boxes and if you hit like the
48:09 - edge of something but there's actually
48:10 - not a pixel there it still counts
48:12 - because it just does a square hit box
48:13 - well pygame has this thing called masks
48:16 - which lets do pixel perfect collision
48:17 - which we'll get into later but we need
48:19 - to define a mask so we're gonna say a
48:20 - self dot mask equals Pi game dot mask
48:23 - dot from surface from surface self dot
48:27 - ship image now what that means is okay
48:30 - take this surface which is the ship
48:32 - image and make a mask of it this mask
48:35 - just tells us where pixels are and where
48:37 - they aren't in this image so that when
48:39 - we do collision we know if we actually
48:41 - hit a pixel or not then what we're gonna
48:43 - do is say self dot Max underscore health
48:46 - because we're gonna add a health bar
48:47 - later
48:47 - is equal to 100 are not hundreds re is
48:49 - equal to hell so whatever health we
48:51 - start with is the maximum health we can
48:54 - have as a player now the reason we need
48:57 - that is because we're gonna decrement
48:58 - the players health rate because we
49:00 - define health up here but we need to
49:01 - still store what it started with so that
49:03 - we can figure out what its maximum
49:05 - health was when we want to draw the
49:06 - health bar and figure out the percentage
49:08 - to decrement it by so there we go we
49:10 - have the player and now I think that's
49:14 - actually be okay for drawing so let's
49:16 - just change everything from ship now to
49:19 - player now an easy way to do this and
49:22 - sub-line taxes do command each and find
49:25 - any ways to ship make sure it's case
49:27 - sensitive and replace that with player
49:30 - like that so we're gonna say ship player
49:32 - which means now all these things that
49:34 - are highlighted or and you can see them
49:35 - it's not highlighting the capitals will
49:37 - change to player so player will be equal
49:40 - to well that'll have to change by names
49:42 - you get the idea
49:43 - so let's hit replace all and now all of
49:46 - those are changed to player so player
49:48 - dot x player doubt why all that and
49:50 - let's now change instead of ship the
49:53 - Xena State player
49:54 - so we're gonna initialize a new player
49:56 - which is equal to a player objects
49:58 - starting at three hundred six fifty and
49:59 - then we've changed all that so now we'll
50:01 - draw the player so let's run this and
50:03 - notice now I have the ship and it's
50:05 - moving around now no fancy animations
50:08 - here but that's fine we're I'm gonna do
50:10 - an animations in this specific video
50:11 - let's fix this now so that we can't go
50:14 - off the screen of the ship so to do that
50:16 - what I'm gonna define in ship is
50:18 - actually a way to get the be height and
50:22 - the width of the ship so I'm gonna
50:23 - define inside a player actually let's do
50:26 - it inside a ship because this will be
50:28 - fine let's define gets underscore width
50:31 - like that so this is a method and what
50:33 - we're gonna do is return in here
50:35 - self-thought ship underscore image dot
50:37 - get underscore whip so remember whenever
50:42 - we have a surface we can call get width
50:44 - and get height on it and it'll give us
50:46 - that so here also define get underscore
50:49 - height self return self dot ship image
50:55 - gets underscore Heights like that okay
50:58 - so these are two methods there's getters
51:00 - they're literally just
51:01 - turning a value to us because we're
51:02 - gonna want those in the main loop I've
51:04 - defined this in ship not player because
51:07 - player inheritance from ship and we're
51:10 - gonna want to use these inside of the
51:12 - enemy ships which we create later so
51:14 - let's just go ahead and add them to this
51:15 - you know base class that we had above
51:17 - okay so now that we've done that rather
51:20 - than +50 all we need to do is go player
51:23 - dot get underscore in this case this is
51:27 - height and player dot get underscore wit
51:31 - so before we had fifty there because
51:34 - fifty was the height and width of our
51:35 - rectangle but now since we have the
51:37 - actual image we need to get the height
51:39 - and width of that image and use that as
51:41 - the offsetting value in this equation
51:43 - right so that's why we're adding those
51:45 - into there so let's run this and now
51:46 - notice that I can no longer go off the
51:48 - screen to the right I can't go down
51:49 - can't go left cannot go up you may be a
51:53 - global why is it only like on this sides
51:55 - a little bit different than this side
51:57 - all of that you can modify those numbers
51:59 - like I had a few pixels if you want it's
52:01 - just based on where you start so like
52:02 - says start at some location right well
52:05 - moving to the left
52:06 - I don't really it's hard to explain this
52:09 - but if you start at pixel value eleven
52:12 - and then you can move back five right so
52:14 - you're at six but if you go so you can
52:18 - move back even more from six and you go
52:19 - to one pixel you can't go any further
52:21 - than that but if you're going to the
52:22 - right say the boundary is at like 20
52:24 - then you can go to sixteen but you can't
52:26 - go further than that because if you're
52:27 - at sixteen and you add five which is the
52:29 - velocity
52:30 - you'll be greater than the width which
52:32 - is 20 pixels in that example so you
52:33 - can't move that far over so I get that
52:35 - question sometimes like why is it
52:37 - different on the left and right side I
52:38 - don't think it's a big deal but some
52:40 - people do it's just based on where you
52:42 - start the object and you're subtracting
52:44 - a certain pixel value of like five or
52:47 - four so you're only gonna be able to
52:48 - move in a certain direction so far I
52:50 - hope that makes sense that explanation
52:52 - okay so now that we have that the ships
52:54 - moving around like we're we're making
52:55 - pretty good progress here let's do the
52:58 - enemy ship so let's let's get that one
52:59 - running so we have player so let's
53:01 - define enemy so class enemy ship like
53:05 - that it'll inherit from ship and in fact
53:08 - we don't really need to call it enemy
53:09 - ship we just call it enemy like that and
53:11 - inside of here we'll say define
53:13 - underscore underscore net underscore
53:14 - underscore self X Y we're actually gonna
53:19 - put a color parameter here remember I
53:20 - was talking about that before and then
53:22 - health equals behind so inside here
53:25 - we're new same thing we've done before
53:26 - I'll go through this slowly after but I
53:28 - just like to type it so that you don't
53:29 - hear my keyboard the entire time that
53:30 - I'm talking and then we'll pass X Y
53:33 - hello okay so what I've done is I've
53:37 - defined a new initialization I've said
53:39 - this time we need to pass a color
53:40 - because our enemy ship will be different
53:42 - colors or it'll be red green blue I
53:43 - won't not BL and will pass the health as
53:46 - well and we'll call the super
53:48 - constructor so this one right here to
53:53 - set everything up and then we will add
53:54 - our own images and stuff after so what
53:57 - I'm actually gonna do in here is make a
53:59 - class variable and I'm gonna call this
54:02 - ship I'm actually gonna call it color
54:06 - underscore map now the idea behind this
54:08 - is that what I want to do is make a
54:10 - dictionary where a specific string
54:12 - because what I'm gonna do is pass a
54:14 - color as a string so like will pass the
54:16 - string like red green or blue based on
54:22 - what color it is we want so if they hit
54:24 - red I need it so it gives me the red
54:26 - images so this enemy will have the red
54:28 - images right if they give me green I
54:30 - need them to have the green images so
54:32 - I'm gonna make a map which is just a
54:33 - dictionary that says okay if we type red
54:36 - right so if we do red then what that
54:39 - maps to is the red spaceship image and
54:43 - the red laser so if we have the red ship
54:46 - it's gonna use the red spaceship image
54:47 - and the red laser right if we have green
54:51 - then what this is gonna give us is the
54:53 - green spaceship and the green laser
54:56 - right and same thing for blue so if we
54:58 - go blue so be blue
55:02 - spaceship and blue laser now that's like
55:06 - pretty straightforward I'll you make
55:07 - sure I add commas here because it's a
55:09 - dictionary let's hit enter one more time
55:11 - so that's proper and now what I can do
55:13 - is just use this map so I can say
55:16 - something like self dot ship underscore
55:18 - image self dot laser image is equal to
55:24 - self dot color map
55:26 - cut so all I need to do is just pass
55:29 - that color the parameter that we passed
55:31 - in to this map and then that will return
55:34 - to me the images that we're gonna use so
55:36 - that's what we have so we'll do self dot
55:38 - ship image self the laser image is equal
55:39 - to self the color map it's not really
55:42 - much more I can do to explain that that
55:44 - that's the basic concept behind that
55:46 - okay so once we have that we need to
55:48 - make a mask so to make the mask gonna
55:50 - say self dot mask is equal to in this
55:54 - case tie game mask dot from surface like
55:58 - we did before except this time well
55:59 - actually I using me the same thing self
56:01 - dot ship image like that so we have the
56:04 - mask we have the color setup we have the
56:07 - images and all we need to do now
56:08 - actually I don't even think as much we
56:10 - have to do here we're gonna implement a
56:12 - method that allows us to move the ship
56:14 - but I think that's all we really need
56:15 - for the enemy so let's hop move and
56:17 - let's have Val and what this is gonna do
56:19 - because the enemy ship will only be
56:21 - moving downwards right it's gonna start
56:22 - at the top of the screen and move down
56:24 - this is just gonna say okay self thought
56:26 - why plus equals Val so if we pass a
56:30 - velocity to this move method we'll move
56:32 - the ship downwards okay so looking at my
56:35 - other screening that's all we need for
56:36 - the enemy ship so let's now figure out
56:38 - how we can start spawning enemy ships
56:40 - and have them moving down the screen and
56:42 - then we'll do lasers will do collision a
56:45 - main menu and I guess an end screen like
56:48 - if you lose and will pretty much be done
56:49 - with this application although that is
56:51 - in a little bit because the lasers are
56:53 - the more complicated part of this so
56:55 - let's start moving the enemies so what
56:56 - we're gonna do is make a list here I'm
56:59 - gonna call this enemies I say enemies
57:01 - equals blank list what this is gonna do
57:04 - is store where all of our enemies are
57:06 - and in fact I'm gonna another very well
57:07 - I'm gonna say oops not staticmethod I'm
57:09 - gonna say wave length is equal to five
57:14 - so we're going to start with the wave
57:15 - length of five and then we're gonna
57:17 - increment that every time and in fact
57:19 - I'm gonna set level equal to zero
57:20 - because I didn't do something cool in
57:22 - the second you'll see why I'm doing that
57:23 - but what I want to do is every time that
57:26 - we get to the next level generate a
57:28 - whole new batch of enemies and have them
57:30 - start moving down the screen so every
57:32 - level we generate a new wave that wave
57:34 - will be in random positions and then
57:36 - they'll start moving down slowly based
57:38 - on a certain be lost
57:39 - which is gonna be called the enemy fell
57:42 - I set that equal to one pixel so they
57:44 - move quite slowly downwards on the
57:46 - screen and what we'll see how this works
57:48 - so that's the idea here
57:50 - what I'm actually gonna do is I'm gonna
57:52 - get ahead of ourselves a bit inside of
57:54 - the redraw window function I'm gonna say
57:56 - for enemy in enemy's enemy dot draw win
58:03 - the reason this works Rex you like well
58:06 - I don't have a draw method insan enemy
58:07 - the reason I can do that is because this
58:10 - inherits from ship ship has a draw
58:13 - method where it draws the ship image and
58:16 - we've defined a ship image here so we
58:19 - can draw them before the enemy right
58:20 - based on whatever color it is that that
58:22 - enemy is so for each enemy let's draw it
58:26 - onto the screen that's what this says in
58:27 - fact I'm gonna make sure that I draw
58:29 - them behind the player just let's say an
58:34 - enemy and a player in the same position
58:35 - the players overtop and the enemy
58:37 - because ideally you want to see your own
58:38 - character not the enemy if you're
58:41 - overlapping so that's the idea behind
58:42 - that okay so now that we have that we
58:45 - need to move the enemy and spawn them so
58:48 - the first thing I'm gonna do is actually
58:49 - move this redraw window to the bottom we
58:52 - might be moving around quite a bit
58:53 - throughout this but let's put at the
58:55 - bottom now to keep it kind of out of the
58:56 - way and at the top I'm gonna say if the
59:00 - Len of enemies equals equals zero level
59:05 - plus equals one so essentially as soon
59:08 - as no more enemies are on the screen
59:10 - because once they hit the bottom once
59:11 - they're off the screen this list is
59:13 - gonna be empty that represents our
59:14 - enemies because we're gonna delete them
59:16 - and I'll show you how that works in a
59:17 - second let's increment the level because
59:19 - we beat the current wave of enemies
59:21 - let's increment the amount of enemies
59:23 - we're gonna have so let's say cur
59:24 - underscore wave or wave length ya plus
59:28 - equals five so if we start with a wave
59:30 - like the five every time let's add five
59:32 - more enemies that's what I'm gonna go
59:33 - with but you guys can add as many or as
59:35 - few as you want and then let's now
59:37 - create this many enemies so let's say
59:40 - for I in range wave length like that
59:46 - let's spawn some new enemies and append
59:48 - them to the enemy list and start moving
59:49 - them down so what I want to do when I
59:52 - spawn these enemies
59:53 - is pick positions for them so they don't
59:55 - all come down at the same time ideally I
59:57 - want them to come down so I want to
59:59 - spawn all of them here I want to create
60:00 - all of them here but I want them to move
60:02 - down and look like they're coming at
60:04 - different times so to do that I'm gonna
60:07 - pick random positions for them that's
60:09 - way above the screen so the idea is I'll
60:13 - go to my drawing tablet here to show you
60:14 - quickly if this is our screen right and
60:17 - I want my enemies to all be moving at a
60:20 - consistent rate
60:21 - I want to spawn them all at once but I
60:22 - want them to look like they're moving at
60:23 - a different duration I can put them
60:26 - above the screen in a negative position
60:28 - and move them down slowly so what
60:31 - happens is these will all move at the
60:33 - same time right they'll move at the
60:34 - exact same velocity downwards but since
60:38 - they started at different heights it
60:39 - will look like some of them started
60:42 - coming down before the other ones when
60:44 - in reality they just started higher up
60:45 - so that's the concept that I'm gonna use
60:47 - here is I'm gonna randomly spawn them at
60:49 - different heights and different xvalues
60:51 - they might overlap with each other
60:53 - that's just the principle of random
60:55 - there is ways to fix that but we're not
60:56 - gonna do that here so that they look
60:58 - like they're coming down at different
60:59 - speeds or different areas right so
61:02 - that's the idea so let's do that so what
61:04 - I mean new is I'm gonna say enemy equals
61:06 - enemy here we need an X and a Y so
61:09 - random rand range remember I imported
61:12 - random at the top the range that I want
61:15 - for the x position is gonna be 100 and
61:20 - width minus 100 so this is pretty much
61:23 - saying I want to spawn my enemies at a
61:25 - maximum left side of 100 actually let's
61:29 - make this 50 and a maximum right side so
61:32 - they're top x position or top left x
61:35 - position at with minus hundred that's
61:37 - just to make sure they don't go off the
61:38 - screen right and then we need a Y value
61:41 - so soo random dot R and range in here we
61:45 - need a Y so I want these to start in
61:48 - negative so they start off the screen so
61:50 - my first value is gonna be the smallest
61:51 - value that I want them to start at which
61:53 - is gonna be 1500 and the next value will
61:56 - be the closest so I want them to start
61:58 - between negative 15 hundred and negative
62:01 - 100 now you could in theory have the
62:04 - possibility that they all start at the
62:05 - same level because
62:06 - this is random but the idea is that they
62:08 - probably won't do that because it's such
62:10 - a large range so some will be up higher
62:11 - some will be down lower and they should
62:13 - be in kind of relatively different
62:15 - positions so that they come down at
62:17 - different times now you can change the
62:18 - way you spawn these if you want but this
62:20 - is my idea this is what I want to use
62:22 - but again guys do whatever you want this
62:24 - is your game so random because now that
62:26 - we've done the X&Y position we need a
62:28 - cutter so let's do random dot choice and
62:32 - inside of here we're gonna make a list
62:33 - of color so in this it's gonna be red
62:35 - blue green
62:37 - now what random not choice does is
62:39 - randomly chooses one element from a list
62:41 - pretty straightforward so this is the
62:43 - list of colors that we want that are
62:45 - valid red blue green so randomly pick
62:47 - one from that for the that's just
62:49 - cuz I want some variety I want some
62:51 - different ship colors if you want to
62:52 - have like red ships have more health or
62:54 - something go ahead feel free to do that
62:56 - but I'm not gonna do that for this I'm
62:58 - just gonna make them all the same but
63:00 - just different colors right so it spawns
63:02 - them and now what I need to do is just
63:03 - add them to the enemy list so enemies
63:06 - dot append enemy like that and now that
63:11 - I've done that they're in the enemy list
63:13 - and I can start accessing the enemy list
63:15 - to move my enemies so we've done that
63:17 - we've spawned them in if the enemies the
63:20 - letta enemies is zero we'll increment
63:22 - the level increment the way by five
63:24 - spawn all the enemies that we need and
63:26 - then you know move forward now you could
63:29 - say all right well if we get to a really
63:30 - high up level this might be slightly
63:32 - flawed because you can have so many
63:33 - enemies within this smaller range so you
63:35 - could do something like negative fifteen
63:38 - hundred times level over five or
63:42 - something like you can change this value
63:43 - if you want a level over five will be a
63:46 - bit of an issue but you can do like a
63:49 - more dynamic approach to this range if
63:51 - you want to multiply by some constant
63:52 - value or something like that but that's
63:55 - just I'm just starting that idea out
63:56 - there in case you guys want that so if
63:58 - you want to move these enemies
63:59 - essentially what we're gonna do is every
64:00 - time that they're on the screen so
64:02 - there's any enemies in our list well
64:03 - move them down by their velocity you're
64:04 - pretty easy we're gonna say four enemy
64:06 - and enemy's enemy don't move and in this
64:10 - case it's just gonna be enemy velocity
64:12 - like that now you see how neat and nice
64:15 - our code is reading right now because
64:16 - we've implemented these methods keep
64:18 - that in mind that you know
64:19 - that's the nice thing about making
64:21 - classes and methods is that when we use
64:22 - a main line like this it's really easy
64:24 - to read because we have these nice
64:26 - methods that literally are reading out
64:28 - and telling us what it is we're doing so
64:30 - I think that your work let's run this
64:32 - code what's the issue here what have I
64:35 - done wrong uh to do random dot choice
64:40 - kierra green ah so it would help if I
64:42 - spelt everything correctly so the green
64:44 - needs to ease the issue there was I
64:46 - spelt that wrong so when it tried to
64:47 - greet an enemy that was gren not green
64:50 - it couldn't do that let's run this now
64:51 - and see that if we wait a second cuz it
64:53 - is they spawn quite high right now all
64:56 - these enemies start coming in now you
64:57 - know we got unlucky here they kind of
64:58 - came in a batch but we can again do
65:01 - whatever we want if we want to spawn
65:02 - them like every 100 pixels upwards you
65:05 - guys can figure out how to do that but
65:07 - the issue we see we're seeing
65:08 - immediately is we're not losing any
65:09 - lives when these enemies go off the
65:12 - screen and they're not actually being
65:13 - removed from the list which means that
65:15 - we're never gonna make new enemies once
65:18 - all the enemies are off the screens what
65:19 - we need to do now is every time we move
65:22 - the enemy make sure that they are not
65:24 - off the screen and if they are decrement
65:26 - the lives and remove them from the list
65:28 - to show hey this enemy is gone so to do
65:31 - that we're just gonna check the position
65:33 - of the enemy so if enemy dot y + enemy
65:38 - dot get underscore height notice we've
65:40 - used this method now that we needed plus
65:43 - actually it's not plus because we
65:45 - already moved them so we'll just check
65:46 - is greater than Heights then what we'll
65:49 - say is lives minus equals one because we
65:52 - lost alive they hit the checkpoint at
65:54 - the end of the level let's delete them
65:55 - then so if we want to delete them since
65:58 - we're looping through this list I need
66:00 - to make this a copy of the enemy list
66:01 - and just do enemy dot remove or not
66:06 - enemies or enemies start remove enemy
66:10 - what this does is remove the object
66:13 - which is this enemy from the enemies
66:15 - list I've made a copy here so that it
66:18 - doesn't modify the list we're looping
66:19 - through because sometimes that leads to
66:21 - issues and that will mean that then once
66:24 - all the enemies have gone off the screen
66:25 - there'll be none left in the list so
66:27 - we're able to hit this Len equals zero
66:30 - you know condition increment the level
66:32 - and ink
66:32 - the wave so let's do that and let's run
66:34 - this and let's see if they actually go
66:36 - off the screen
66:37 - I guess I'll fast forward and we'll go
66:39 - through this okay so we can see that the
66:40 - lives now obviously we're going negative
66:42 - because you know we've lost at this
66:44 - point but just notice that once we get
66:46 - to negative five because we started with
66:48 - ten the level increments and now more
66:50 - enemies start coming onto the screen in
66:52 - different positions and these seem to be
66:54 - working fairly well now obviously what
66:56 - we need to do is make sure that we don't
66:57 - have a negative live square so we'll
66:59 - implement something that will fix that
67:01 - for us which is just gonna tell us if we
67:03 - lost and then we'll get into shooting
67:05 - the lasers and after we do the lasers
67:07 - and the collision with the lasers I
67:09 - think that's pretty much all we'll need
67:11 - for this game so let's let's do the
67:14 - thing if we lose down so essentially if
67:17 - lives is less than zero or I guess less
67:21 - than or equal to zero and in this case
67:24 - I'm actually going to say or Claire dot
67:27 - health is less than or equal to 0
67:29 - because we are gonna implement a health
67:31 - bar that's the doctor about we'll need
67:32 - to do that next with the with the player
67:33 - then we'll say that we lost so we'll
67:35 - just a loss equals true we'll define a
67:37 - lost variable up here we'll say I lost
67:40 - equals false like that and now forgets
67:44 - about lost correctly what we'll do is if
67:46 - lost is equal to true we're gonna
67:49 - increment some kind of counter system
67:52 - that essentially says we're gonna show a
67:54 - lost message on the screen for a certain
67:56 - amount of time and then once that lost
67:59 - message is done we'll go back to like
68:00 - the main menu which we're gonna create
68:02 - later so lost equals true let's actually
68:05 - just do something inside of redraw
68:06 - window here so we'll say at the bottom
68:10 - if lost
68:12 - so if lost is equal to true we can
68:14 - access that because it's up here what
68:16 - we'll do is we'll say lost font which
68:19 - we're gonna make need to make a new font
68:20 - for so so the main font will say lost
68:23 - font like that make this a font size of
68:26 - 60 s there's a bit bigger a bit more
68:28 - emphasis and we'll say lost underscore
68:31 - label equals lost font dot render in
68:36 - this case the text is gonna say you lost
68:40 - exclamation point exclamation point one
68:42 - color that'll be white 255 to five to 85
68:46 - then say wind judge blitz lost label and
68:52 - if we want to put this perfectly Center
68:54 - in the screen I'll show you some math
68:56 - magic to do that that's gonna be width /
68:59 - 2 - explain this in a second don't worry
69:01 - lost underscore label get underscore
69:05 - width / - so the idea behind this and
69:08 - let's put it at a Y position of 350 is
69:10 - that if we want this to be in the center
69:12 - the center of the screen is the width /
69:14 - 2 but since this has a width like the
69:17 - text itself and we draw from the top
69:19 - left we need to make sure that we're
69:21 - drawing so that B width right when we
69:23 - include that width will still be Center
69:25 - so if we do with / - and then we
69:27 - subtract from that to go left so that we
69:29 - account for the extra width half of the
69:32 - width of the text
69:33 - that'll be perfectly centered because
69:35 - that's like I don't know a really great
69:37 - way to explain it but essentially if we
69:38 - have Center here if we draw it's gonna
69:40 - come all the way over to one side or all
69:42 - the way over to one side so if we can
69:43 - move this position over slightly so that
69:46 - it's half of where the width is then
69:48 - it'll be perfectly Center in the middle
69:49 - of the screen
69:50 - that's my somewhat visualization using
69:53 - my hands hopefully that made sense but
69:55 - that's the math there - put that in the
69:56 - middle and there you go
69:58 - so now we'll check what happens if we do
70:01 - lose I'll show you that the game is
70:02 - gonna still run when it says you lost
70:05 - which we'll fix in a second but the idea
70:08 - here is that it's just like you know
70:10 - it's gonna say that we lost so let's
70:13 - speed this up we'll get through it and
70:14 - I'll show you case we're coming out in
70:16 - one life we see you lost now pops up in
70:18 - the middle of the screen obviously the
70:20 - game keeps running but I'll show you how
70:21 - we fix that now so to fix this we need
70:24 - to increment some kind of like timer
70:25 - that tells us how long to show the lost
70:28 - message for before we just reset the
70:30 - game and also pause the game right so it
70:33 - doesn't keep moving and decrementing the
70:35 - lives once we lose we want to just pause
70:37 - the game once we lose so we're gonna say
70:39 - after lost we're gonna say a lost
70:41 - underscore count equals zero and what
70:45 - we're gonna do now is if we've lost
70:47 - write lost equals true will say lost
70:51 - lost underscore count + equals one so
70:55 - increment one every time and then down
70:57 - here was say if
70:59 - lost like that say if lost underscore
71:03 - count is greater than in this case we're
71:07 - gonna do 60 because that's our FPS so
71:09 - actually will do FPS multiplied by five
71:11 - so if we wanted to say show the message
71:13 - for five seconds we would do FPS
71:15 - multiplied by 5 because FPS is how many
71:17 - frames we show per second you know and
71:20 - then how many seconds who want to in
71:21 - this case let's do three so if it's
71:23 - greater than that then what we'll do is
71:26 - we'll break this while loop so set run
71:28 - equals false and we'll quit the game
71:30 - otherwise so else we'll continue now
71:35 - what this is saying essentially and
71:36 - we're gonna have to move this redraw
71:38 - window to actually be at the very
71:40 - beginning of the loop so I show left it
71:41 - there but that's okay what this is
71:44 - saying is if we've lost so if lives is
71:47 - less than you go to zero or playerhealth
71:48 - is less than zero loss equals true lost
71:51 - count plus equals one and then we say if
71:53 - lost so if we have lost if the lost
71:56 - count is greater than FPS times three
71:58 - then run equals false which means we've
72:01 - now got past our three-second timer
72:02 - let's quit the game if it's not so if
72:06 - it's still looping we're still waiting
72:07 - to hit three seconds continue which
72:09 - means don't do any of this don't let us
72:12 - move don't move anything go back to the
72:15 - beginning this while loop and keep
72:17 - running and then we're redrawing the
72:19 - window every time so we'll look like
72:21 - that lost just sits there for three
72:24 - seconds and nothing else happens let's
72:25 - run the associate what I mean so again
72:28 - I'll speed up we'll get to when we lost
72:29 - and I will show you okay so we're
72:31 - getting down to it here we can see two
72:32 - one
72:33 - you lost boom level freezes wait two
72:35 - three boom game ends okay so that is how
72:38 - that works we've got the lost counter
72:41 - going here we can add a main menu pretty
72:43 - easily later on but now time for
72:45 - collision and lasers now the lasers and
72:48 - the bullets are a little bit more
72:50 - complex in terms of how they move
72:51 - because we need to shoot them from the
72:53 - enemy ship we're from the player but
72:55 - we'll get into that I guess right now
72:57 - alright so the first thing we need to do
72:59 - if we're going to be shooting lasers is
73:01 - we need to create some kind of laser
73:02 - object so in this case what I'm actually
73:04 - gonna do is make a new class called
73:06 - laser so let's type this out class laser
73:10 - we're gonna do in a knit and what
73:11 - this is gonna represent just one laser
73:13 - object now the idea is that we're gonna
73:16 - have multiple lasers being shot from
73:19 - each player right so if I shoot a laser
73:21 - going upwards I need to make sure that
73:23 - it keeps going in that same upwards
73:25 - angle right it's not following what the
73:28 - player is moving cuz a common issue
73:30 - people do is they'll make like the laser
73:32 - follow the exposition of the player
73:34 - which means that if I press the left
73:36 - arrow key once I've shot the laser the
73:38 - laser moves to the left which is not
73:40 - what we want to do right we want to make
73:42 - sure each of these items are independent
73:44 - of the person or the player or the enemy
73:47 - or whatever it is so that they can kind
73:48 - of act on their own they can collide
73:50 - with things on their own
73:50 - and they're their own entity so that's
73:52 - the idea so what we're gonna do here is
73:54 - have a laser it's gonna have an X Y it
73:57 - needs an image we're gonna pass that
73:59 - image from the ship class so the idea is
74:02 - that when we make a new laser object so
74:05 - when we shoot this laser the player will
74:08 - create the laser object add it to it
74:10 - it's Laser list you guys we have lasers
74:13 - here and then it will control how those
74:15 - lasers are moved so that's kind of the
74:17 - concept but we'll get into that sighs so
74:18 - let's say self that x equals x self the
74:21 - y equals y self-thought IMG equals
74:25 - IMG and of course you need to make a
74:27 - mask for this as well because this is
74:29 - what's gonna be colliding with different
74:31 - things so self dot mask equals Pi game
74:34 - mask dot from surface self IMG note you
74:39 - could put IMG there as well doesn't
74:41 - really matter but we're gonna do that so
74:42 - now what we're gonna do is make a draw
74:44 - method so the draw method will take
74:46 - self.window like before and we'll say
74:48 - window judge belitz self dot IMG and
74:54 - then self dot x self dot y now what
75:00 - we'll do is we'll do define move so
75:02 - define move self Bell which will move
75:05 - this with the velocity so the velocity
75:07 - will be going upwards or downwards based
75:09 - on what we pass in here so in this case
75:10 - we'll just say self dot y plus equals
75:13 - vel if we want to go down will give a
75:15 - positive l if you want to go up will
75:17 - give a negative L as the parameter and
75:19 - if we add a negative value obviously
75:20 - that means we go up so we have move
75:23 - let's define a few our methods we're
75:24 - going to find
75:25 - underscores screen which is gonna tell
75:28 - us if these lasers off the screen based
75:31 - off the height of the screen so we're
75:33 - just gonna return from this return
75:36 - self-thought y is less than height and
75:42 - yeah and self-thought y is greater than
75:46 - zero I will do greater than equal to
75:48 - less than equal to as well I guess and
75:51 - that should be good for this right now
75:53 - we're gonna find one more method which
75:55 - is gonna say collision which is gonna
75:57 - tell us if this collides with an object
75:59 - so laser collide object and what this is
76:02 - gonna do is call a function that we've
76:04 - yet to define but we'll define in a
76:05 - second called collide so all this will
76:08 - do is return the collide of object
76:11 - itself now let's actually go ahead and
76:14 - create this collide method because our
76:16 - yeah collide function I guess because
76:19 - what we're gonna need to do is check if
76:20 - things are colliding when removing the
76:22 - lasers so it makes sense to do that
76:23 - before we start actually moving the
76:25 - lasers but essentially what we're gonna
76:27 - do with the collide is use these masks
76:30 - to determine if two objects are
76:32 - overlapping if the pixels between them
76:34 - are overlapping and if they are then
76:36 - we'll say yes these two objects are
76:37 - colliding so I'm gonna define a function
76:40 - here called collide it's gonna take
76:42 - object 1 actually we'll just do obj one
76:44 - and obj two and what we need to do here
76:48 - is use something in PI game or use this
76:50 - mask property called actually I got a
76:53 - look over here to see exactly what it's
76:55 - called because I'm blanking on its right
76:57 - now I believe it's like overlap yeah
76:59 - that's what's called it's called overlap
77:01 - so what we need to do when we call an
77:04 - overlap and actually let me go to my
77:05 - drawing tablet if I give you my
77:07 - beautiful drawing skills with my mouse
77:08 - again to show you what I mean so what a
77:10 - mask is is essentially if we have like
77:12 - this right so this is my object an
77:15 - object has a width and a height now we
77:18 - know that when we're drawing these
77:20 - objects only some of the object is
77:22 - actually taken up with pixels right so
77:23 - in the example of our ship we have
77:26 - something this is going to be my very
77:26 - crudd ship right this is like my rocket
77:29 - ship say it looks something like that
77:30 - maybe it has like a little tail but the
77:32 - idea here is that these are where the
77:34 - pixels are and all of this blank space
77:36 - here is not where any pixels
77:38 - but based on the way that we've loaded
77:40 - this object in if something hits like
77:43 - right here we'll say that it's hit the
77:45 - object because it's inside of this width
77:48 - height hitbox like this WH hitbox I'm
77:51 - not sure if if I explained this before
77:52 - but essentially let's say we bring in a
77:54 - circle like we left it's really hard to
77:56 - draw with this mouse let's say we bring
77:58 - in a circle right well what actually
78:00 - happens is it makes a square around this
78:02 - circle and that is what the surface of
78:04 - the circle is it's rectangular because
78:06 - it's very difficult to have circular
78:08 - objects in computer graphics like when
78:11 - we're rendering and drawing things or
78:12 - creating services so the idea is that we
78:14 - have this circle but really it's
78:17 - represented by a square where all these
78:19 - other things are here a transparent but
78:22 - the actual circle itself is the pixels
78:23 - right so we want to make sure that when
78:25 - something hits our object we're not
78:28 - saying it hit unless it actually hits
78:30 - some of the pixels of our object not the
78:33 - transparent background that may exist
78:34 - that's a part of that object and you
78:37 - will see this quite often when you load
78:38 - in sprites as it'll load in with with
78:40 - height right like say we load a little
78:42 - character it'll load in like this like
78:44 - this will be our character and if you
78:45 - hit this side like anywhere on this box
78:47 - it will say we hit the character even
78:49 - though it's not touching the pixels so
78:51 - it's misleading to the player so the way
78:53 - that this mask thing works is if we have
78:56 - two let's say objects like this and
78:58 - they're overlapping like this what we do
79:01 - is we ask pygame we say okay so if
79:03 - there's like pixels here here here here
79:05 - here here and there's pixels here here
79:07 - here and there's pixels in the same area
79:09 - so there's pixels inside of this inside
79:12 - of this overlap in both objects we'll
79:14 - say that this collided if there's not
79:16 - we'll say it didn't collided or we it
79:19 - did not collide because these two
79:20 - objects are not overlapping where their
79:22 - pixels exist I think that makes sense
79:25 - but like the idea is if we have you know
79:27 - stickman right and he has his thing like
79:31 - this and then we have you know I don't
79:33 - know say a laser like that maybe the
79:35 - lasers hitbox is something like that
79:37 - even though these two boxes are
79:39 - colliding we're not gonna say they
79:41 - collide unless the pixels hit the other
79:43 - pixels so the way that we need to do
79:46 - this though is we have these two masks
79:49 - which represent where pixels are that's
79:51 - why we created that mask
79:52 - object but in order to determine if
79:54 - they're overlapping we need to come up
79:56 - with something which that's called an
79:57 - offset the offset essentially tells us
80:00 - the distance between the top left hand
80:02 - corner of both of these objects we need
80:05 - to know that because given that
80:07 - information we'll be able to determine
80:09 - if they are actually colliding with each
80:11 - other and where their point of
80:12 - intersection actually is because what
80:15 - the overlap method will do in masks
80:16 - which we'll use in a second is tell us
80:18 - where these two objects collide so the
80:21 - point of intersection between them now
80:23 - we don't really need that but we're just
80:24 - gonna see if we get a point of
80:26 - intersection and if we do we'll say yes
80:28 - these objects collided if we don't they
80:30 - did not but the idea is we need this
80:32 - offset which tells us how far away
80:34 - object 2 is from object 1 based on their
80:37 - top left-hand corner coordinates so to
80:39 - calculate that what we're gonna say is
80:41 - obg 1 actually have to say offset
80:46 - underscore X equals obj 2 dot X - not -
80:52 - equal sorry - obj 1 dot X this will tell
80:57 - us the distance from object 1 to object
81:00 - - it's fine if this value is negative
81:01 - which it may be sometimes depending on
81:03 - the coordinates but that's how we do
81:05 - that for offset X now offset Y is gonna
81:08 - be equal to obj - why - obj1 obj2 I so
81:17 - again that just tells us the difference
81:18 - between them since this is X Y I mean
81:20 - you can consider that a vector with two
81:22 - components we need to do these
81:24 - separately and subtract like that so now
81:26 - that we have that what we can just do is
81:28 - return obg 1 dot mask dot I believe this
81:35 - is overlap yeah I've said that so many
81:36 - times dot overlap and then here we're
81:39 - gonna say obj - so is object 1
81:42 - overlapping object 2 with the offset of
81:45 - offset X offset Y so that's what this
81:50 - collide function will tell us is given
81:52 - two masks right so give an object one
81:54 - and object two if they both have a mask
81:56 - so mask here and sorry this needs to be
81:58 - Audra - mask if these masks are
82:01 - overlapping based on the offset that
82:03 - we've given between the difference of
82:05 - their
82:05 - top left coordinates then we'll return
82:09 - true otherwise we'll return false and
82:10 - actually what this needs to be is return
82:12 - does not equal none because if they're
82:14 - not overlapping this whole thing that
82:17 - I'm highlighting here will return none
82:18 - if they are it will return to us
82:20 - actually at a polar tuple that looks
82:23 - like this XY that tells us the point of
82:25 - intersection so hopefully that wasn't
82:27 - too confusing and I didn't go too crazy
82:29 - facet is kind of hard to explain masks
82:31 - without my drawing tablet out which I
82:33 - don't really want to get out right now
82:34 - but I think that's good enough
82:35 - explanation for the collision so if we
82:37 - go back to where we actually called that
82:39 - which is here we can see that all this
82:42 - is doing is returning the value of this
82:44 - collide function now the reason I've
82:54 - called self here is because I want to
82:56 - see if the object is colliding with
82:58 - myself right and I could call it in the
83:00 - other method or the other order which is
83:02 - self obj but all self does is give
83:06 - access to this specific instance so in
83:10 - this case it'll be a specific laser so
83:12 - we'll just pass those two things in so
83:14 - the self which is this object and then
83:17 - the object that's giving us here that we
83:19 - want to check if there's a collision
83:20 - with and then that will return to us if
83:22 - it's collided or not okay so now what
83:24 - we're gonna need to do is implement a
83:26 - few things inside of the enemy and
83:28 - player class in terms of creating a
83:30 - laser as well as creating a cool-down
83:33 - for the laser so we can't shoot it too
83:35 - fast so the first thing I'm gonna do is
83:37 - implement a shoot method inside of this
83:39 - base class ship because both of our
83:42 - methods or both of our classes will be
83:44 - able to use this so define shoot self
83:48 - we're gonna say Val like that is it felt
83:52 - no I think we literally just need so I
83:54 - think we literally just have shoot self
83:56 - and then what we're gonna do is say if
83:58 - self dot cooldown counter equals equals
84:02 - zero which means we're not in the
84:04 - process of counting up to a specific
84:06 - cooldown or keeping track of how long
84:08 - until the next shot then what we will do
84:10 - is create a new laser and add it to the
84:12 - laser list so we'll say laser equals in
84:16 - this case
84:17 - laser we'll give it our XY value so XY
84:21 - and then what else does the laser need
84:22 - it needs an image so the image will pass
84:24 - is self dot laser image because laser
84:28 - image is what we're storing here as the
84:30 - image for the laser then we'll say in
84:32 - this case self dots oops
84:36 - lasers dot append laser like that and
84:42 - the next thing we'll do is reset the
84:45 - cooldown counter so that it starts
84:47 - counting so I'm gonna say or not reset
84:49 - will start the cooldown counter so it
84:50 - starts counting up so self dot cooldown
84:52 - counter equals one so the idea behind
84:54 - this is that we will make sure that we
84:58 - are at zero for the cooldown counter so
85:00 - it's not as certain value like waiting
85:02 - to go down are waiting to go up or
85:03 - whatever it's gonna be and if it is will
85:06 - create a new laser at this current
85:08 - location which will move later on we'll
85:10 - add it to the lasers list and then we'll
85:12 - set the cooldown counter to start
85:14 - counting up now what I'm gonna do here
85:16 - is say define cooldown and what this is
85:21 - gonna do is just handle counting the
85:24 - cooldown so we're gonna say if cooldown
85:26 - counter so if self cool-down counter is
85:29 - greater than or equal to in this self
85:32 - cool-down all capitals I'm going to
85:34 - define that as a class variable up here
85:37 - so cool down equals 30 so that's half a
85:40 - second because the FPS is 60 right so if
85:43 - that's greater than self a cool-down
85:45 - self the cooldown counter equals zero
85:48 - say else self the cooldown counter plus
85:53 - equals one and we will only increment
85:56 - this cooldown counter if sorry not else
86:00 - say if self cool down counter so LF
86:03 - self-taught codec on earth greater than
86:05 - zero so essentially if this cooldown
86:08 - counter is zero we're not doing anything
86:09 - right because it's not greater than or
86:11 - equal to self duck cool done and it's
86:13 - not greater than equal to zero but if it
86:15 - is greater than zero and it's not past
86:18 - the time limit incremented by one okay
86:21 - so now we need a way to draw and to move
86:24 - our lasers so the idea is that we're
86:26 - gonna call this shoot method that
86:28 - creates the laser from
86:31 - down here so essentially if we hit the
86:33 - spacebar we'll call shoot which will
86:35 - create a new blazer object so actually
86:37 - let's implement that now let's say if
86:38 - keys in this PI game dot K underscore
86:44 - space we're gonna use the spacebar then
86:46 - we'll say is player dot shoot so I will
86:49 - call that method and we'll create new
86:51 - laser now remember this is only gonna
86:52 - create a new laser if the cooldown
86:54 - counter is equal to zero otherwise it
86:56 - just won't do anything that's fine we
86:57 - can hit space as much we want but if
86:58 - we're on cooldown it's not gonna work
87:00 - so what we're now need to do is have a
87:03 - method that can move these lasers
87:04 - because right now if we do that is just
87:06 - gonna make them and they're gonna stand
87:07 - still and in fact right now we don't
87:09 - even see them because we're not drawing
87:10 - them so first actually I'll just draw
87:12 - the laser so inside this draw method I'm
87:14 - gonna say for laser in self dot lasers
87:19 - like that and then we'll literally just
87:22 - do laser draw window so that will draw
87:26 - all of our lasers we have a draw method
87:28 - on our lasers that just draws them here
87:30 - so that's totally fine to call that no
87:32 - issue there now we're gonna define a new
87:34 - method this will be called move lasers
87:36 - so define move lasers self Bell and then
87:44 - OBJ's now the reason I've had obj is
87:48 - here so vel makes sense because that's
87:49 - like how fast are we going to move the
87:51 - lasers to the velocity but obj stands
87:53 - for objects and the idea here is that
87:55 - when I move these lasers I want to check
87:57 - for collision with all of these objects
87:59 - so to do that I need the objects that I
88:03 - want to check collision with which are
88:04 - here so we're gonna move all the lasers
88:07 - by this velocity so I'm gonna say for
88:08 - laser in self dot lasers and before we
88:15 - do that we're actually gonna increment
88:16 - the cooldown counter by calling self up
88:18 - cool down so every time we move the
88:20 - lasers we're gonna call this once a
88:22 - frame which means that we'll increment
88:23 - the cooldown counter when we move the
88:25 - lasers right so we can track if we can
88:27 - send another laser or not and then we'll
88:30 - loop through all of the lasers and what
88:32 - we'll do in here gonna check here is go
88:33 - laser move the velocity so we'll move it
88:37 - by the velocity and we'll say if laser
88:40 - dot off-screen which we've made that
88:42 - method here will delete the laser
88:44 - with laser it off screen height will say
88:48 - if that's off the screen then we'll go
88:50 - self thought lasers don't remove laser
88:56 - like that and it shouldn't be a problem
88:57 - with that now otherwise if laser dot
89:01 - collision with an object and watching
89:05 - need to implement another for loop in
89:07 - here in a second I'll tell you that
89:08 - guess take a step back here so I think
89:11 - I'm gonna confuse myself a little bit so
89:12 - I just want to step back and make sure
89:13 - everyone understands so first of all
89:15 - I've changed this parameter from OBJ's
89:17 - with an ass to obj the idea being that
89:20 - actually what I'm gonna do in this
89:22 - specific move lasers method is check if
89:26 - each laser has hit the player so the
89:29 - idea behind this is that this is gonna
89:31 - be used for the player and for the enemy
89:34 - but inside the player what I'll actually
89:37 - do cuz this is the base class right
89:39 - we're inside a ship is I will implement
89:42 - a new method called move lasers but
89:44 - rather than checking if we hit the
89:46 - player will check if we hit any enemies
89:48 - so that's kind of the idea we need to
89:51 - separate move laser methods one for
89:53 - checking if all of the lasers shot by
89:56 - the enemies have hit the player and one
89:58 - for checking if all the lasers hit by
90:00 - the player have hit the enemy so that's
90:02 - the idea since there's only one player
90:04 - we only need one object here which means
90:07 - for each laser we can do if laser dot
90:09 - collision object then we can reduce the
90:14 - health of that object which will be our
90:15 - player so we can say obj dot health
90:18 - minus equals let's say they lose ten
90:21 - health so we can change this value to be
90:23 - whatever we want but I'm just gonna keep
90:24 - it at ten for now and I think that that
90:26 - is pretty much good except that we're
90:30 - gonna need to delete this laser so
90:31 - self-taught lasers Dutch remove laser
90:36 - like that so yes so that's what this is
90:39 - doing call the cool down which goes
90:41 - through and says okay you know we're
90:42 - gonna increment this cool down based on
90:44 - what we've defined here so if we can
90:46 - shoot or not
90:47 - then we're gonna for each laser that
90:49 - we've shot that exists currently in our
90:51 - list we'll move it down the screen by
90:53 - the velocity we'll check if it's off the
90:56 - screen if it's off the screen we'll
90:57 - remove it if it's not
90:59 - the screen but it's collided with one of
91:01 - our objects in this case this object
91:03 - will be the player that we pass to it
91:05 - will do object l - equals 10 which is
91:08 - the player right - equals 10 and then
91:10 - we'll say self dot lasers don't remove
91:12 - lasers so remove that because when it
91:14 - hits them we don't want it to keep going
91:15 - down afterwards and it potentially hit
91:17 - them a bunch of times if it keeps
91:18 - colliding with the player so that's the
91:21 - move lasers here I'm gonna copy this and
91:24 - we're gonna change it a bit inside a
91:25 - player so let's put this inside a player
91:27 - this is gonna override that parent class
91:29 - 1 and we'll do the same thing so it'll
91:31 - call self cool down again and we'll say
91:34 - for laser and self dot lasers laser
91:35 - don't move but now what I'll do is I'll
91:39 - say L if actually yeah laser to
91:42 - off-screen height will change this to
91:44 - OBJ's then we'll put an else and inside
91:47 - of here we're gonna put another four
91:48 - loops we're gonna say 4 in this case
91:51 - obj in OBJ's then do this and say if
91:58 - laser collision obj and then we could do
92:02 - obj dot health - equals 10 but since
92:04 - what I'm gonna pass in here is a list of
92:06 - all of the enemies because we want to
92:08 - check if the player's lasers have hit
92:09 - any enemies we're just gonna remove that
92:13 - enemy from the OBJ's list so we're gonna
92:15 - say we'll remove the laser obviously
92:18 - we'll say Oh BJ's don't remove obj okay
92:23 - so I think that makes sense so we have
92:25 - the player what this is doing is I'm
92:27 - gonna pass to here and this gonna make a
92:28 - lot more sense when I start actually
92:30 - passing from the main loop it's just I
92:32 - always confusing now cuz it's kind of an
92:33 - abstract concept but for each laser that
92:36 - the player has move the laser lasers off
92:39 - the screen remove it if it's not off the
92:41 - screen for each object in the object
92:44 - list if the laser has collided with that
92:47 - object remove it so delete that object
92:49 - otherwise remove the late or not
92:52 - otherwise but remove the laser after
92:53 - that happens as well so that's all we
92:55 - need for player and ship for moving the
92:57 - laser so now what we need to do is for
92:59 - each player will our player and for each
93:01 - ship or each enemy ship we need to move
93:04 - their lasers each loop so for enemy and
93:06 - enemies we also need to call enemy dump
93:10 - move lays
93:11 - right with a velocity which is gonna be
93:13 - the I guess what was the velocity the
93:16 - laser velocity do we have laser velocity
93:18 - as a as a variable we do not so I'm
93:21 - gonna define that and I say laser
93:22 - underscore Val equals four then here
93:27 - we'll do move it by laser underscore
93:30 - bail and check if it's hit the player so
93:33 - we pass the player object there that's
93:35 - the idea behind that then down here
93:38 - we're gonna say player
93:40 - don't move lasers pass in this case the
93:43 - laser Val and the entire list of enemies
93:47 - so self dot enemies so this will now
93:50 - check if the laser has collided with any
93:53 - of the enemies so that's the idea behind
93:56 - this is that what is the move lasers
93:58 - method is doing there's easier ways to
94:00 - do this probably but this is the way
94:02 - that I came up with it that seems to
94:03 - make the most amount of sense so let's
94:05 - run this now and say self is not defined
94:08 - so so this shouldn't be self that I mean
94:10 - I've had this should be enemies long
94:12 - session of recording starting to get
94:13 - tired here so let's run this in check
94:15 - now so if I press space okay so name X
94:17 - is not defined where is that so I've
94:21 - made a mistake somewhere here let's have
94:22 - a look so laser XY self dot laser image
94:26 - okay so that should be eighty three and
94:29 - shoot so I know what the issue is
94:30 - immediately but I'll break it down for
94:32 - you so I made a mistake here in the
94:34 - shoot method by calling XY when really
94:36 - this should be self dot X self dot why
94:38 - won't be surprised we get a few more
94:40 - errors like that so let's run this in
94:42 - press space when I press space nothing's
94:45 - happening
94:46 - aha so I determine the issue so you saw
94:50 - that none of the leases were showing up
94:52 - now there's a few problems I'm gonna go
94:53 - through I want to summarize what we've
94:54 - done so far and then fix this issue so
94:57 - what we just did was create these move
94:59 - lasers and I'm sure I apologize in
95:01 - advance if this was really confusing
95:02 - because I was kind of confusing myself
95:03 - was well I was going through this but
95:05 - the ideas again these are moving the
95:07 - lasers so we call this every loop on all
95:09 - our enemies and on all our players or
95:12 - art player so that they can handle the
95:15 - movement of their own lasers notice that
95:17 - in the draw we're drawing all the laser
95:19 - so this should show up on the screen
95:20 - what we do is inside of cooldown we're
95:23 - making sure
95:24 - we're not shooting too fast and that we
95:26 - have at least a half a second delay
95:28 - before we can shoot that's what this
95:29 - does here we make sure that the cooldown
95:32 - counter is equal to zero then we make a
95:34 - laser and add it to the list if we press
95:38 - space right if we call this method if we
95:40 - shoot so then we set the cooldown
95:42 - counter to 1 the cooldown counter goes
95:44 - through does its loop and then it lets
95:46 - us shoot again once it resets to zero so
95:49 - here this is the move laser for the
95:50 - player this is a little bit different
95:53 - what this is doing is checking if the
95:55 - laser collides with every single enemy
95:56 - which we pass in as OBJ's right if it
96:00 - does we remove that objects remove that
96:02 - enemy and we remove the laser now the
96:04 - issue I was having is this right here if
96:07 - laser off-screen Heights then remove the
96:10 - laser what I did in off-screen was a
96:13 - little bit of a mistake so this actually
96:15 - needs to say not this so what this is
96:18 - telling me here is if this is on the
96:20 - screen that's what this value is so I
96:22 - need to negate that to not to make sure
96:25 - that I actually get what I'm looking for
96:27 - is if this is off the screen I get true
96:29 - and if it's not off the screen I get
96:30 - false whereas before if it was off the
96:32 - screen I was getting false and if it was
96:34 - on the screen I was getting true so just
96:36 - immediately being deleted so let's go
96:38 - ahead and run this now and notice and
96:40 - I'll show you this mistake as well when
96:42 - I press this bullets going backwards now
96:44 - the issue with that and let's just
96:46 - actually just test if this even works so
96:48 - it does if I if the laser hits them it
96:50 - deletes them the reason that's happening
96:53 - is because I haven't made the velocity
96:55 - negative to make it go upwards so what I
96:57 - need to do is here in laser valve for
97:00 - players I need to make that negative the
97:02 - reason for that is I want to make sure
97:04 - that I'm going up not down because if I
97:07 - pass a positive velocity and I add a
97:09 - positive velocity to my bullet or my
97:11 - laser it's gonna go down or it's not
97:12 - upwards so let's negate that or change
97:15 - that to negative and now notice my
97:16 - bullets are going up now if you don't
97:18 - like the speed of these bullets you want
97:20 - to increase them I I agree with you I
97:22 - think they might need to be a little bit
97:23 - faster let's make them 5 like that and
97:26 - we will notice a slightly substantial
97:29 - difference in terms of the speed of
97:30 - these bullets but notice that that
97:32 - collision was working and now all we
97:34 - need to do is make it so that the
97:36 - enemies start shooting at us
97:37 - once the enemy starts shooting at us
97:39 - we'll implement the health bar and then
97:41 - will pretty much be done with with this
97:43 - well we obviously need to do though we
97:45 - have you lost screen actually but we
97:47 - need to add like a little bit of a menu
97:48 - and stuff but we're pretty much almost
97:49 - done once we do that so let's do that
97:52 - now I let's make the enemy start
97:54 - shooting Anna okay so what we need to do
97:55 - now to actually have the enemy shoot a
97:57 - bullet is pick some probability that
98:00 - they're gonna shoot each frame so
98:02 - ideally what we're gonna do is something
98:03 - like if random thought rand range
98:06 - between zero and some number is equal to
98:09 - one then have the enemy shoot so what
98:12 - number do we pick though is the question
98:14 - so let's say you want every second your
98:17 - enemy to have a probability of 50% of
98:20 - shooting so every second you want a 50%
98:23 - chance that your enemies gonna shoot so
98:25 - in theory every two seconds your enemy
98:27 - should shoot a bullet and that's gonna
98:28 - apply to every single enemy well you
98:31 - need to take that probability which is
98:32 - one over two right which would mean you
98:34 - just put two here and multiply it by
98:36 - sixty because you have 60 frames per
98:38 - second so if you want the probability to
98:40 - be that they have a 50% chance of
98:43 - shooting every second then you make this
98:45 - number 120 because 60 times two is equal
98:48 - to that and in fact if you want to keep
98:50 - this easier for yourself you can do
98:51 - something like four multiplied by 60
98:53 - even though we know that's 240 just so
98:55 - you can change this to have it equate to
98:58 - the amount of seconds before you want
99:00 - the enemy to shoot now you can hard code
99:03 - like every two seconds have the enemy
99:05 - shoot but I just like to have some
99:06 - degree of randomness to make the game a
99:08 - bit more difficult I don't know if this
99:10 - probabilities gonna be too low or too
99:11 - high let's leave it on to for now and
99:13 - just mess with this number and see if
99:15 - it's good or not for you right so now
99:17 - that we have that though let's run this
99:19 - and hopefully our enemy should start
99:21 - shooting once they get on to the screen
99:22 - so let's have a look at this and they do
99:24 - you can see that they're starting to
99:25 - shoot some of them are shooting more
99:27 - frequently than others of course
99:29 - obviously this is rent right now notice
99:31 - that I can run through my enemies so
99:34 - we're gonna fix that so that we can
99:36 - actually if we hit the enemies we lose
99:37 - health but also I can be hit by the
99:40 - bullets or disappearing these things can
99:43 - hit me and you might notice that the
99:45 - bullets are shooting slightly offset
99:46 - from the center of the enemies it's
99:48 - quite easy to fix that you can just
99:50 - subtract Oh
99:51 - fix it for you guys right now you can
99:53 - just subtract the x-value of where
99:55 - you're gonna start shooting the bullet
99:57 - from so in this case if we go to enemy
100:00 - hmm
100:01 - where are we here and shoot where shoot
100:05 - shoot to mean to find the shoot method
100:08 - if we override the shoot method in enemy
100:11 - so let us take that and move that here
100:15 - what we'll do is we'll just offset where
100:17 - this is being created so I'm overriding
100:19 - this in the enemy I'm gonna say self dot
100:21 - X minus like 10 pixels so now if you
100:24 - look at this it they shouldn't be or
100:26 - they should be shooting more from the
100:28 - middle because we just offset it where
100:29 - the bullets start by 10 pixels so that
100:32 - one clearly didn't do that much for us
100:34 - let's move it over even more let's move
100:37 - it over like 20 pixels and see if that
100:39 - makes a bigger difference let's have a
100:41 - look here waiting for some enemies come
100:44 - on the screen it's wait for this guy to
100:46 - shoot his green bullets so that's
100:47 - slightly to the left that's okay with me
100:48 - I'm fine if they're like that far to the
100:50 - left I want to see these blue guys
100:52 - shooting now though give me the bullet
100:54 - okay so that's fairly in the center so
100:55 - for me that's fine I mean if you wanted
100:57 - to be perfectly centered you have to use
100:58 - a little bit more math there but this is
101:00 - the probability of them shooting I think
101:02 - it might be a little bit too high right
101:04 - now but again we can mess with that
101:06 - number and change it around but now
101:07 - let's do the collision between the
101:08 - spaceship and the other ships and then a
101:10 - health bar a main menu and we're pretty
101:12 - much done so to do the collision between
101:14 - a the player and all the other ships all
101:17 - we have to do inside of here is say if
101:21 - enemy actually sorry if collide enemy
101:26 - and in this case this is gonna be player
101:29 - then we'll just say player dot health
101:33 - minus equals 10 and then remove the
101:37 - enemy so enemies remove and a me like
101:40 - that and me if we spell that correctly
101:43 - okay so let's put that at the top though
101:46 - because we want to make sure we don't
101:48 - remove the enemy before we check that so
101:50 - we'll do that right after the enemy
101:51 - shoots like that and then we'll put this
101:54 - as an L if actually just to make sure
101:57 - that we're not gonna check if you know
101:59 - the enemy is off the screen if it's
102:00 - already collided with the player so
102:02 - that's the idea there we have this
102:04 - random sha
102:05 - we have this collision with the player
102:06 - that will remove the enemy and will
102:08 - reduce ten help from our player now we
102:10 - need to add a health bar which is pretty
102:12 - easy to do actually and then the main
102:14 - menu and we're pretty much done so let's
102:15 - do the health bar to do the health bar
102:17 - what I'm gonna do is just implement a
102:18 - function inside a player so I'm gonna
102:20 - say define health bar like that human
102:25 - takes self and all I'm gonna do in here
102:27 - is draw rectangles that are red and
102:29 - green based on the health of my player
102:31 - so the first rectangle I'm gonna draw is
102:34 - gonna be red it's gonna be the length of
102:36 - my player and then I'm gonna draw a
102:38 - green rectangle that goes on top of that
102:40 - red rectangle but will be only the
102:43 - length of the health right so if it's
102:44 - like say we have 50% health we have 50
102:47 - out of 100 health it'll be 50 percent of
102:49 - the length of the red rectangle but on
102:51 - top of it so that it shows like half
102:53 - green half rent it's kind of a cool
102:55 - trick I'll show you exactly how that
102:57 - works let me just get this because there
102:59 - is a little bit of an equation that goes
103:00 - into doing this that I had to come up
103:02 - with so here what we're gonna do is
103:04 - gonna say PI game
103:06 - doctor all dot rect we're gonna draw
103:10 - that so we need to draw the health but I
103:13 - guess so it's gonna be a window let's
103:15 - take that on the window rectangle we
103:18 - need a color we're gonna draw a red
103:19 - first to pay five zero zero then we need
103:23 - the rectangle so self dot X self dot Y
103:28 - if I get suppose self-taught y plus self
103:32 - dot image so self that ship image dot
103:35 - get underscore height Y is my typing so
103:39 - horrible today so if that height plus
103:42 - ten let's finish off those brackets
103:44 - there so the idea behind this is that we
103:46 - want to make sure the health bar is
103:47 - below our player so we want to get the Y
103:50 - value of the player add the height of
103:52 - the ship add ten pixels and then start
103:54 - drawing that there and the self dot X
103:56 - can draw where we usually draw the X and
103:58 - that's fine now for the width what we'll
103:59 - do is self thought ship image right dot
104:03 - gets underscore width so it's the same
104:05 - width as the ship and for the height
104:08 - I'll just make it ten pixels and you can
104:10 - make that as much as you want but we'll
104:11 - just do ten now let's copy this and
104:14 - we'll do the exact same thing now in
104:16 - green except just a little bit
104:18 - for the rectangle whip so it's gonna be
104:20 - the exact same stuff except the only
104:22 - thing that's gonna change is the width
104:23 - and the color so zero so red green blue
104:27 - so 0 255 zero and what we need to do now
104:30 - is essentially determine what percentage
104:32 - of the width we should draw so if we
104:35 - want the width to be this or
104:36 - self-thought ship under square image
104:38 - don't get with we're gonna multiply this
104:39 - by some fraction that will essentially
104:42 - tell us how much width we want to put so
104:45 - to do that we're gonna multiply that by
104:47 - 1 - in this case max underscore health -
104:54 - self dot health and actually think that
104:57 - should be self dot health and then
104:59 - that's gonna be divided by here self dot
105:03 - max health now I think I might have made
105:07 - this math equation way more difficult
105:09 - than it needs to be but let's just think
105:11 - about this for one second so I want to
105:13 - multiply the width by 1 - this don't
105:17 - need as many said oh yeah I think these
105:19 - brackets are correct 1 minus the maximum
105:22 - health - the self dot health would
105:24 - you'll essentially tell us okay so how
105:27 - much difference is there between the
105:29 - maximum health and the health we have
105:30 - right now and then divide that by the
105:33 - max health to get the percentage health
105:35 - that we're down and we're gonna subtract
105:37 - 1 from that although I think an easier
105:40 - way to do this would just be to multiply
105:42 - by self dot health yeah this is gonna be
105:44 - easier by self dot health over self that
105:47 - max out so I'm glad that I took the
105:49 - initiative to fix that there yeah so
105:51 - this is the image width multiplied by
105:53 - the health over the maximum health which
105:55 - is just telling us what percentage of
105:57 - health were currently at so since we
105:59 - know this is gonna go in increments of
106:01 - negative 10 this is fine to do like we
106:03 - won't get a decimal value here but you
106:06 - know sometimes we might so just keep
106:08 - that in mind but yeah I think that's the
106:09 - equation I think that makes sense
106:10 - hopefully that makes sense to you guys
106:12 - I'm just trying to figure out what
106:13 - percentage of width that we should draw
106:15 - the green rectangle at so that if we
106:17 - lose 10 health that goes down a little
106:20 - bit right and we can do that variably
106:21 - using that kind of equation that I just
106:23 - drew so we have health bars so let's
106:25 - implement that now into the draw method
106:27 - of the player shifts so let's define the
106:29 - draw again so define draw
106:32 - do self.window we're gonna call the
106:35 - super draw method so super dot
106:38 - underscore underscore sorry one peg done
106:41 - it super draw will pass that the window
106:44 - and then we'll just call self dot health
106:46 - bar so self that health bar with the
106:49 - window so I'm just overridden the method
106:51 - from the parent class which is this one
106:54 - here which has the draw I called the
106:56 - parents draw method with the super and
106:59 - then I'm calling the health bar for the
107:00 - window
107:01 - or with the window which now should draw
107:03 - the health bar for me so let's have a
107:04 - look what's the issue here let's see has
107:10 - no attribute get ah so I've added an
107:13 - extra dot accidentally here this should
107:14 - be a get underscore height gets
107:17 - underscore Heights I'm sure most of you
107:19 - probably noticed that so get underscore
107:21 - height let's run this now what's the
107:23 - issue here I made another mistake rect
107:26 - argument is invalid I think I forgot to
107:29 - add the 10 yes I did
107:32 - so multiplied there let's see if this is
107:36 - the correct bracket yeah so I think I'm
107:39 - just messing up a bracket here I think
107:42 - that goes there and I think now we
107:43 - should be good no we're not let's see
107:47 - what's going on with the brackets here
107:48 - give me one sec guys
107:49 - okay so I did fix it yeah issue as I
107:52 - just had all these brackets messed up in
107:54 - here I just need to add two at the end
107:56 - there the code will be in the
107:57 - description if you guys are getting
107:58 - confused with what I'm doing because
107:59 - we're here well you can see when we load
108:00 - in the health bar is off the screen we
108:02 - can fix that if we want quite easily in
108:04 - fact let's actually do that now just
108:05 - before we forget go down to where we're
108:09 - allowed to sponsor first of all where we
108:10 - spawn the person in and make it so he
108:13 - spawns at six-thirty and let's just add
108:15 - 10 pixels to where this guy can move so
108:19 - if we go player get height plus 10 this
108:25 - is just to make sure that the health bar
108:27 - will be able to be shown if we add 10
108:28 - pixels there will insure the health bar
108:30 - will be shown up so let's do that
108:32 - now we can see the health bar shows up
108:34 - in fact it cuts off a little bit so
108:36 - let's make this 15 pixels and now let's
108:40 - run this and we can see that the health
108:41 - bar will stay perfectly on the screen so
108:43 - there we go the health bars on the
108:44 - screen let's watch what happens if we
108:46 - one of these guys you can see the health
108:47 - bar does decrement it goes down and that
108:50 - is a strategy I guess in this game if
108:51 - you want to waste your health and hit
108:53 - one of the things to like sacrifice
108:55 - yourself for that you can do that
108:56 - so yeah that's uh that's how the health
108:59 - bar works so I guess now all this really
109:02 - left to do is the the main menu so let's
109:05 - go ahead and do that
109:06 - okay so main menu what we want to do
109:09 - essentially is just habit so it says
109:10 - like press any key to begin and when you
109:12 - press that key you can begin and that
109:14 - way if you die it'll bring you back to
109:15 - the main menu and you can choose when
109:17 - you want to start playing again I'll do
109:19 - the nap though the main functionality of
109:21 - this game is pretty much done so let's
109:23 - implement a main menu so let's define
109:26 - main underscore menu this is gonna be
109:29 - quite simple I'll go fairly fast we're
109:31 - gonna say run equals true while run try
109:37 - to say for event in PI game dot event
109:42 - get if vent dot type equals equals PI
109:47 - game so I quit like that then we will
109:50 - say is run equals false okay and then in
109:55 - here we're gonna say just draw this on
109:58 - the screen and actually sorry I need
110:00 - today if event type equals equals PI
110:04 - game stop mouse button down colon me so
110:12 - what this is saying is if we press any
110:14 - of the mouse buttons enter this main
110:17 - loop and start playing the game if we
110:20 - press the X button set run equal false
110:23 - we're gonna quit here so let's say hi
110:27 - game talk quit like that in fact we can
110:31 - actually just use the quit method - it's
110:33 - up to you whatever method you'd like to
110:34 - use but this is saying if we press any
110:36 - mouse button call the main function if
110:38 - we press quit quit but what I want to do
110:40 - is just draw like some text that says
110:42 - press any key to begin or press you know
110:44 - the mouse button to start something like
110:46 - that so the first thing we'll do is also
110:48 - say win top lit BG notice I'm just doing
110:52 - it in line here because it's just gonna
110:54 - be short for the main menu so we'll blit
110:56 - the background will say pi game
110:59 - dot display dot updates and then we'll
111:04 - create a font up here so we'll say title
111:06 - underscore font go spy game it's off
111:10 - font dot sys font Comic Sans
111:14 - let's do size 7d and then we'll render
111:18 - something onto the screens will say
111:19 - title label equals title font dot render
111:26 - press the mouse to begin dot dot try to
111:32 - that one let's render that white so two
111:34 - five two five two three five and then
111:36 - let's say win da blitz title label let's
111:42 - split this in the middle of the screen
111:43 - we remember that shortcut I showed us so
111:45 - that's width / 2 - title label dot get
111:51 - underscore width / - that'll put that in
111:55 - the middle and then here for the Y let's
111:58 - put that at 350 and then that should be
112:00 - good so now that we have that what this
112:03 - loop will do so rather than calling main
112:05 - we need to call main underscore menu and
112:07 - let's have a look at how this works so
112:09 - we're getting an error it's funny enough
112:12 - + 15 s so I've accidentally pressed s
112:15 - that's what happens when I try to save
112:16 - too frequently apparently what's the
112:19 - issue now tie game duck quit mean menu
112:23 - let's have a look here PI game duck
112:25 - quits
112:27 - inconsistent use of tabs and spaces love
112:30 - when I get that issue so for me to fix
112:33 - that I usually just do this converting
112:35 - donación to spaces so that should work
112:36 - now and let's run this win is not
112:40 - defined so win needs to be capital
112:43 - that's let's run this and there we go
112:46 - okay so I'll go through this in a second
112:47 - I'll summarize I just want to show you
112:48 - now it says press the mouse key to begin
112:50 - if we exit out so press the mouse button
112:53 - to begin
112:54 - if I hit X it brings me back here I'll
112:56 - show you how to fix that if you don't
112:57 - want that to be the case but when I
112:59 - press the mouse the game begins we can
113:01 - start playing and you know when we exit
113:04 - it'll reset like it should normally do
113:07 - so that's how that works
113:08 - if we want to fix it so when we press
113:10 - the X it doesn't bring us back to the
113:12 - main menu
113:12 - what we can do is just in so saying run
113:14 - equals false in here we can do quit what
113:17 - that's gonna do is quit the entire
113:19 - Python program which will just end this
113:22 - whole thing for us if we press the X so
113:24 - that's the idea
113:25 - now main manual summarize quickly what I
113:27 - did here literally just setup the exact
113:30 - same thing that we had before except for
113:31 - a main menu so I made a main loop with a
113:34 - run equals treat variable I defined a
113:36 - font I said in here we'll draw what's
113:38 - gonna be on the screen for the main menu
113:40 - which is just these two things right so
113:42 - the label and the background then I'll
113:45 - do an event lupus okay so for each event
113:47 - notice I didn't put a clock in here
113:49 - because I don't care about the clock
113:50 - speed for the main menu that that's
113:52 - irrelevant we're not moving anything
113:53 - around that's fine so I don't need a
113:54 - clock so we just have an event loop you
113:57 - press quit it and it ends the game and
114:00 - if you press the mouse button down it
114:01 - starts the game and it will always bring
114:03 - you back to this main menu function
114:05 - because since we call main here without
114:07 - setting run equal to false when main
114:09 - exits right when main is done we exit
114:11 - out of this while loop here we go back
114:14 - into main menu and wait until we hit the
114:17 - X button to stop playing the game so
114:18 - that's the idea behind this and that is
114:20 - pretty much this game okay so we ran
114:23 - into an issue here at least our remove X
114:25 - X is not in the list so let's just fix
114:28 - that here so 111 in move lasers so we
114:31 - ran into a quick bug let's try to find
114:34 - that 111 111 in removed laser if laser
114:38 - doc collision object objects are removed
114:40 - obj
114:41 - self-taught lasers don't remove laser so
114:45 - I guess what we should do is make sure
114:47 - this laser is in the list before we
114:49 - remove it because I guess it could have
114:51 - been removed in a different situation so
114:53 - in that case we'll just say if self dot
114:56 - laser I guess we'll say if laser in self
115:02 - thought lasers then we'll remove it
115:06 - otherwise we won't so this is the fix
115:08 - here just to make sure that if this
115:10 - laser is in the list but you can remove
115:13 - it otherwise we will not so let's run
115:14 - this and see now cuz I hit something and
115:17 - I ran to that bug so I want to make sure
115:18 - that we don't get that again okay so
115:20 - that seems to be working you know one
115:23 - thing to note is if you hit a if you hit
115:25 - something and
115:25 - has a laser shooting that laser will
115:27 - disappear just because we delete the
115:29 - object itself there's not really an easy
115:31 - way to fix that the way that we've
115:32 - implemented it I don't think is a huge
115:34 - deal I think that's part of the strategy
115:35 - the game is like if you want to remove
115:37 - someone's laser go in and shoot them
115:39 - like I think that is a decent strategy
115:41 - or that's something that can be
115:42 - incorporated and yeah that is pretty
115:45 - much it for this tutorial so again I
115:47 - hope you guys enjoyed if you did make
115:48 - sure you leave a like go subscribe to my
115:51 - podcast YouTube channel time out with
115:52 - ten that would really mean the world to
115:53 - me if you guys did that and of course
115:55 - although code everything isn't available
115:57 - in the description and if you need help
115:59 - let me know in the comments down below

Cleaned transcript:

hello everybody and welcome back to their PI game tutorial now it's been a long time since I've done one of these but you guys know that the foundation of tech whatin my youtube channel was really built around making all kinds of fun little PI games like I've made Tetris snake some platformer games stuff like that which you guys can check out as well if you wanted to see those and I wanted to bring another one back here to all the old subscribers and just show you guys you know this is another cool PI game we can make especially with quarantine happening PI game is just such a great module for making some fun 2d games that don't take you that long to kind of get up and spinning and of course you know we can use Python for this which is a great and pretty fast language to write code in so the game that we're gonna be creating today is a space shooter game now this is inspired or kind of based off of that old original Atari game where you have those spaceships coming down the screen and you're this big shooter and you're trying to shoot them all of the sky I know that that version is a lot different than what I'm gonna show you here but this is the inspiration now stick with me here for another minute or two I need to give you this introduction so you really have all the tools you need to work through this project the first thing I'm gonna say is these videos take me a really long time to make and I really want to make sure that you guys are able to actually create the game so please do me a favor go like the video and make sure you're subscribed to the channel if you're not just show your support if you guys really want to give me an extra big thank you and show your appreciation I'd really appreciate it if you go subscribe to my new youtube channel which is called time out with Tim that's where I'm gonna be posting a weekly podcast where I talk about tech programming finance just myself lifestyle stuff like that and I would really appreciate it even if you guys don't want to watch that you just go over and subscribe and support me over there so anyways let's demo the game and as I demo the game I'll talk about some other important things for this tutorial series so first of all all the assets you see here those little pixelated assets are available from the description down below I've made a really easy link on my website so all you have to do is just click it and it will automatically just download a zip folder that has all the game assets and the code as well I get comments all the time with common problems which I'm gonna go over at the beginning of this video to hopefully make sure you guys don't run into those but if you're running into problems just click that link the code will download you can open up that code and you can steal whatever code you need and reference it and make sure that you know it really was my mistake maybe uhhuh and not yours and that you can see if anything's going wrong but this code that I'm showing here is what we're gonna be recreating I already have it written full disclaimer on the left hand side of my screen so if you see me looking over there during this long tutorial that's what I'm doing just making sure I haven't messed anything up so the idea behind this game is that you're this ship you know you can shoot bullets and you want to just make sure that these little ships here don't get to the end of the screen and if they do you lose a life the idea behind what I've created here is this is kind of a basic guideline it's setting up the main functionality and then what you guys can do is add your own features to it and I'll talk about some extensions you can put on so you guys can make this game as custom as you want so the idea is to give you the core functionality show you how to do everything and then you guys can add and make it your own game afterwards so with that being said I think that has pretty much been it for this introduction what we're gonna do now is actually get into coding and just do a little setup for the project and then obviously start writing some code alright so the first thing we need to do for this project is actually install the module called PI game now PI game is this third party module once what we're gonna use to make this space shooter game and you do need to install it now a lot of people have difficulties with this this is probably the most difficult part of the tutorial for someone who doesn't work in Python very often doesn't understand how all this works so what you need to do if you're having troubles with the steps I'm about to show you here is click the card in the top right hand corner or click the link in the description that says how to install PI game that's an older video but it goes through exactly how to install PI game all of the common issues and problems and you should after watching that be able to come back here and follow along with no problem so what we're gonna do and just first of all obviously we need Python downloaded and installed I'm using Python version 3.7 and the text editor that I'm gonna be using is sublime text now you can use whatever you want you can use the standard Python IDE you can see I have that installed on my computer as well doesn't matter what you write in but just because I get asked all the time I'm using sublime text now obviously download Python if you don't have that 3.8 should work if you're having issues at 3.8 download 3.7 and then what we need to to do is use pip 2 and stall Piegan no pip stands for package installer Python believer Python yeah I think that's what it is anyways that comes by default with your Python installation so usually what you can do is open up a command prompt window if you're on terminal or open up a terminal window if you are on Mac or Linux and type pip install PI game like that now if you hit enter and you see something like this like requirement already satisfied or a finding module installing module you're good you install PI game you're ready to go that's all you need to do if you see an error that says PIP is not a recognized command go watch that video it'll show you how to install pip properly now if you're on Linux and if you're on Mac what you might introduce type of pip 3 pip 3 stands for pip Python version 3 because on those distributions or on those I guess operating systems they have Python 2 built in automatically so when you type pip that actually accesses the Python 2 interpreter not the Python 3 interpreter so try pip 3 try pip if this doesn't work again watch that video I have one for Mac and for Windows which I'll link in the description and once you get that what we're gonna do is just type Python in here or open up your ID le wherever you usually do your Python stuff just try to import the module of Pi game like that and if it works and you get this welcome message then you're ready to go and we're gonna get into the video right now so once we've done that what we're gonna do is actually a nun close this now set up a project directory or a folder on our computer where we're gonna store all of this stuff for this project so what I've done is I've made a folder I've called its space shooter tutorial and you can see I've already dragged in the image assets here so what you need to do if you don't have these assets which you won't use go to the description hit the link that says download image assets it will download a zip folder so you'll see I'll put this into a compressed one so that everyone can follow along here if we go what does it send to compressed zipped folder it'll be in a zip folder like this what you need to do is unzip it take this folder out so extract it and put it into the directory that we're gonna work in it's very important that when we do this the Python file we create is in the same directory as the folder that has the assets the assets are the images you can see I have things like this yellow ship which I'll bring up onto my other screen here we have the green ship the red ship and all of that ok so just make sure that you do that otherwise that's not gonna work ok so once we do that what we're gonna do is open up a Python window where we can write code so in this case I have sublime text but if you want you can open up ideally like that an ID le is perfectly fine to write code in as well but this is sublime text which is just a nicer editor so what I'm gonna do in here is make a new file and I'm gonna call this main dot pi now very very very important do not name this file PI game if you name this Python file PI game or any file in this directory is named PI game you your script will not work I learned this the hard way when I forgot to tell people that in the previous tutorial and I got a hundred comments do not name it PI game I know it's a tempting name just do not do that now again what we're gonna do to make sure everything's working here is just import PI game now fortunately for me in subline text I can click ctrl + the B key to run my script so that's what I'm doing here but for you guys if you need to run your script in your in IDL you obviously hit f5 or you can use the terminal window on back Linux whatever and do Python 3 or python the name your file when you're in the correct directory ok so once we import PI game what we're gonna do is import a few other things we're gonna import OS we're gonna import time and we're gonna import random so now we're actually ready to start writing some code so let's get into it all right so the first thing we need to do is actually load all of our image assets into our script so that we can use them and display them on the screen because the first thing I'm gonna do after we load these images in is actually start setting up the PI game window and talking a bit about some basic PI game syntax and how all those things work because obviously this is a module which means now we have some different syntax and some different tools we can use that aren't native to the Python language so notice again that this main dot Pi file is in the same folder where this assets folder is I don't have all these images inside directly with the main dot I the main dot pi is in the same level as assets that's really important and that's a big mistake if you don't have that so make sure you're listening pay attention and do that the first thing we're gonna do is load all these images so I'm gonna make a comment you don't have to do the comments if you don't want but this is just to make a little bit cleaner we're gonna load the images what I'm gonna do is use all capitals for my variable names gonna miss a red spaceship equals in this case PI game and not in all capitals hi game dot image dot load and I'll go through this after so don't worry if you're confused os path join and we're gonna do assets in here and then in here what we're gonna do is what was this file called I need to look at my other screen pixel underscores ship underscore red underscore small dot PNG okay so what this is doing this line of code and we're gonna do a bunch of these lines of code which I'll speed through in a second is we're saying from the PI game module use the image dot load method and then in here we're gonna load the image which is located at OS path join this is the name of the folder that our images are in notice that's assets right here on the left hand side of my screen and the name of the file is pixel ship read small PNG so if you look inside of here we can see we have pixel ship read small about PNG this is what it looks like a very basic you know five pixel thing and you can see that that's how we load this if we want to add a folder name to a file name cuz we're loading from a folder we can use OS path giant although note I could completely omit this line and some of you might be like well why aren't you doing this this is just the proper way to do it is to do assets slash and then the name of the file like that that works but we're gonna use OS path ajayan to make sure everything's clean so I'm gonna copy this a few times because we're gonna need to load all these files in rain they're gonna have to have all their file names so we have red spaceship we need green we need blue and we need yellow right so the yellow is gonna be our main player so I'll tab it down and say Claire ship like that just so we know and all we need to do for these ones up here is change red to the appropriate color so in this case that's gonna be green that's gonna be blue and I believe this one is just pixel ship yellow it doesn't have that small afterwards so pixel ship we can check that just by looking here yep there we go we got it and just make sure that you have that PNG extension otherwise obviously that's not gonna work so what we're gonna do now is we're going to install or not install sir a load in the bullets and the other asset so we need to load in the background and we need to load in at the bullet so let's say lasers is what I'm gonna call them and we'll say red underscore laser equals this case we'll copy this line up here paste it in and assets in this case I believe it's something like laser underscore red or something so let's look at this pixel laser ret yes okay so pixel underscore laser underscore red PNG let's copy this a few times and of course just change the colors to what they need to be so red green blue and yellow let's make sure that's all capitals let's change the file names now so pixel laser green pixel laser blue and pixel laser yellow okay so let's spell that correctly and now let's load in the background image let's say VG or background I'm just gonna call this one BG notice I spelt that comments wrong and BG is gonna be equal to in this case hi game image download OS poundage Orion assets and then what is this called background black PNG so let's punch that in background black PNG okay so now assuming we spelt all this correctly we have loaded in all these images to make sure this works we can run the code we don't get any errors this was successful now I'm if any of you have like corrupted images or something like that just try redownload encompasses it can't open the file even though it does exist but make sure again that they're in the correct folder their name the right thing and you're loading them in like this if you want to use your own image assets put them inside the assets folder and then you know name them what you need to name them and load them in like this okay so now that we have all of these loaded in what we're actually gonna do is set up our PI game window so the first thing we do when we're working in PI game is we create a width and height for our screen we set a name for the display and we just run it and make sure that it's working fine so the standard and the reason I've named these all cow by the way is because these are gonna be constants they're not changing and the convention in Python is to named constants with a capital what we're gonna do to make our window is we're going to say win equals PI game dot display dot set underscore mode and inside here we're gonna put a couple with a width and a height now we're gonna define the width height up here like this so width height equals in this case we're gonna do 750 by 750 you feel free to change this if you want and that's how we're gonna get started so width height equals 750 750 this just means with the 750 high to 750 we're gonna say win which stands for the window is equal to PI game dot display don't set underscore mode width height and width height just tells it this is how big our window is gonna be once we do that we're gonna set the caption or the name of our window so we can do that by saying tie game dot display dot set underscore caption and inside here we're just gonna call this space shooter and in my version I'm just gonna call it tutorial you guys can call it whatever you want so there we go space shooter tutorial now if we run the script we will see that a pie in window pops up and then just disappears because we're not doing anything else so if we've got that successfully things are looking good again feel free to change these numbers I'm on a 4k display so it's gonna look a lot smaller on my display than it is on yours if you're on 1080p right 750 by 750 will take on most of your screen if you're on a 1080p display but I'm on 4k so it's gonna be you know 1/4 the size is that how it works I think so maybe something like that alright quick water break there and now let's get into the next stuff that we need to do which is actually drawing and getting our main loop kind of set up so whenever we're working in PI game what we need to do is create a main loop which is gonna be kind of what handles all our events so it's gonna be what handles collision it's gonna be what calls things to be drawn on the screen it's gonna be what allows us to quit the game to move a character stuff like that so what I usually do is I define a function I'm gonna call this man which stands for main loop and inside here I'm gonna set up a few variables we're gonna need for the game so the first one we're gonna need is run run equals true is just gonna dictate whether this while loop is gonna run or not and then what I mean do is create an FPS which stands for frames per second and set that equal to 60 now of course you can change this to whatever you want the higher this number the faster your games gonna run the slower this number or the lower this number the slower game's gonna run now just keep in mind you don't want to make this number too low because if you do then that means that you're only gonna be checking for collision and checking for events once every whatever this number is so in this case we say 50 frames per second what that means is we're gonna show 50 frames ever sorry 60 frames every second and that means that we're gonna check collision we're gonna check if we're moving the character once or 60 times every second so the way that we can set that up in PI game is by making a clock object so we're gonna say clonk equals PI game dot time clock with a capital C like that and inside of here we're gonna say clock dot tick and make sure this is at the top of your while loop fps so we're essentially saying we're gonna tick this clock based on this frames per second rate so 60 FPS and what this allows us to do is make sure our game stays consistent on any device that we give it to so if we run this on a really fast computer or a really slow computer it doesn't matter it's gonna run at the same speed because we've set that clock speed of 60 FPS now what we typically do inside of here is start drawing stuff on the screen and start checking for events so what we need to do first is check for events and the first thing we actually want to do is check if the user has quit our window so to do that we're gonna say for event in high game dot event dot get and what this is essentially saying is every time we run this loop so once every or 60 times every second we're gonna loop through all the events that PI game knows and we're gonna check if an event has occurred if that event occurs do something right so an example of event is like pressing a key is pressing the quit button is pressing the mouse button something like that you can look up the events from the PI game website if you're trying to do something different but most of what I show you is pretty much all you'll need so now what I'm going to say is if event dot type equals equals PI game like this if I could spell correctly dot quit with all capitalist then we're gonna say is run equals false so what this means is pygame quit is if we press that top right the X in the top right hand corner of our screen quit the screen like quit PI games stop running so that's why you'll notice I said run equal to false so the next time we get to the top of this loop we won't loop anymore because we quit right and that's the idea behind that so we could check for other events in here in fact I'll show you another common type of event so if a vente type equals equals pi game talk key down what that means as we press some key downwards if we did that will trigger an event that's what this means now we're not gonna use that inside the event li because i'm gonna show us a different way to move things around but this is the basic loop that we need right now so let's actually go ahead and call this function and run it and just make sure that the quit button is working and show you what I mean so you can see that it pops up now our window we have space shooter tutorial and we can click the X button and if we do that it exits the window if you don't have this event here it will not exert the window when you press the quit button so that's just something to keep in mind you need to make sure that you make run equals false and eggs and out of our infinite loop that's gonna happen here that's running the entire game its handling collision movement all of that when that starts happening okay so now that we have that we should probably start drawing some things under the screen and the first thing that comes to mind for me is the background so I'm gonna do something that might seem a little bit confusing to you guys try to look past um you know really the inner workings of how this works and just understand that this is possible I'm gonna make a function inside of this main function that I'm gonna call redraw window now the idea behind this is that when we do things like in games and just in programming in general we typically want to separate things out into their own functions and create small pieces of logic that do things quite well they do one or two things like just one thing quite well so it rather than drawn all the different things because we're gonna have to draw a lot of different things within this while loop we're gonna put it in a function that's inside of a function and just call that when we need to use it so just treat this like a regular function but just understand that since it's indented and it's defined inside of this main function we can only call it when we're in this function and that's totally fine that's all we need to do but this is going to allow us to access all of these variables defined inside of the function rather than making it its own function and having to pass them all through as parameters which can get quite annoying when we have a lot of things that we want to pass so again yeah the idea is that this is gonna draw everything for us on the screen it's gonna handle all our drawing anything that needs to be rendered stuff like that so he can just be in its own separate piece so if something goes wrong with drawing we know right away where that is it's in redraw window so the first thing we need to do is do PI game display dot update and in fact what this does is refresh the display so the way PI game works is we have a bunch of things called surfaces now these surfaces can be drawn on we can blit things onto them which means like put an image onto them or something like that and the way that it works ideally is we have this one surface and every time that we loop so we run one of these while loops so 60 times a second we're gonna redraw everything onto the screen and then refresh it so that it has the updated version so the first thing we need to do since we're gonna be redrawing everything is draw a background image as our first thing so what that will do is it will cover any stuff that was behind or drawn before and then we draw everything on top of that background image that's gonna be shown for the next frame and you understand what I mean in a second but just bear with me here so what we're gonna do is do win job blitt BG comma zero zero now what this is saying is win is a surface right it's this PI game surface that we've set up as our main PI game window at the top of our screen so a method that's available on this is called blit now what blitt does is take one of these images so one of these PI game images it can be some other things as well which really have been turned into what's called a surface in PI game and draws it to the window at the location that we defined here now an interesting thing with PI game is the way that we actually use a coordinate system so I'm gonna bring up my drawing tablet here to show you what I mean cut some networking stuff on there and show you what I mean by the coordinate system so let's say this our PI game window and just excuse me cuz I am drawing with my mouse we know we have an x and y right so this is our xaxis this is our yaxis and typically we think that zero zero is the bottom left well that's actually wrong or different in Pi game in fact zero zero is the top left so what that means is that our x coordinates are the same as we would assume if we want to increase X we're going to the right or if we want to go to the right we increase X so X goes like that but Y actually goes down which means that if you set something at position y 0 it's at the very top of the screen and if you want it to go downwards you need to increment the Y so let's say I want to move a character down I need to increase its Y value that's what I'm getting at here now this is the same for objects so let's say we have a little square and we want to draw it on the screen well the top left hand corner is where we're gonna draw this object from so if I say I'm drawing a square at 25 25 what that means is that I'm gonna draw this square starting at the top left position of 25 25 so if the width of our square is say 30 if I can't draw a 3 this pen size is too thick let's see if we go let's do 20 that's my rough version of a 20 that's a 2 if the width is 20 and we draw it at 25 that means that this corner here right so this right corner is actually gonna be a quick math 45 right so that's what we need to understand top left hand corner is the coordinate system for pygame so just keep that in mind when I'm drawing things so when I say wind up lit background at 0 0 that means take that background image and draw it at 0 0 in the top left hand corner of our screen and since we're gonna draw the image starting at the top left hand corner it will fill the entire screen now the only thing is though we're gonna see when we run this well actually if if we wind up lit if we call this function one second sorry so let's call this function now from inside of here so redraw window so just inside this main loop we're gonna go clock tick immediately call the redraw window in here it just splits the background and updates the display so let's run this notice that the background is not the correct size so what we're gonna do is actually scale this background up you can see it's about 1/4 the size it really needs to be so we're gonna make it 2 times bigger just about said it fills the entire screen so to do that we're gonna go up to where we loaded it in on background and we're gonna use another method so we're gonna say pygame dot transform dot scale and what we're gonna do now is put this entire image so this whole line we had before as the first argument and then as the second argument we're gonna put what we want to scale this image to so the dimensions so in this case it's gonna be width height where width height is those variables we defined earlier for the width and height of the screen so if we run this now notice that it fills the entire screen because we scaled that image and then we're drawing the scaled image onto the screen now you can see we get some little pixelated stars and some fun stuff like that okay so I guess the next thing to do is to actually deal with drawing a few things else on the screen we'll get into characters and stuff in a second but like the score the level were on things like that so let's do that first we're gonna say score watch the eyes it's not score we're just gonna have level and lives so we'll say level starts on level 1 and we'll say lives starts on 5 feel free to increment that if you want doesn't really matter to me and I'll show you how we can draw those to the window so how can we actually draw text so you saw I had lives and I had level at the top right and left hand corner screen how do we do that well what the first thing we need to do is actually create a font in PI game so a font allows us to kind of render that font so for example Comic Sans is what I'm gonna use we need to create the font object and then use that font object to actually render the text to the screen so that the annoying thing in Pi game is that you need to initialize fonts for them to work so that's pretty easy but at the top of our program right after we import PI game here we're gonna say PI game fonts dot and yet this just tells PI game kick get setup get the font ready to go so that there's no issues when we want to start using it so that's what we'll do PI game dot font done it and now inside of our main here I'm gonna define main underscore font so that's a variable name is equal to in this game pi game font . sys font and here we're going to name the fonts there's all kinds i'm not going to go through them but the one that i usually use is comic sans and then the size of this font so the size i'm gonna use is fifty make it smaller bigger depending on what you want and now i'm gonna show you how we can use this to actually draw the lives and the level on the screen so here I'm gonna make a comment I'm gonna say draw you know text like that and the first thing we need to do is make a label and then blit that label to the screen so you saw how i blitt this surface which is the background to the screen what i need to do is turn some text into a surface and then put it on the screen so i'm gonna say do i guess this would be lives underscore and label is equal to main underscore font which we've defined up here which is comic sans size fifty dot render and here i'm gonna type what i want to render so in this case i want to render an f string if you're not familiar with f strings what this allows you to do is embed variables inside of brackets like this so left brace rice right brace at the curly brackets so i can do something like level level and what this will do is take the value of the variable level here and just show that and so that's with an f preceding this string now that only works in Python 3.6 and above so just keep that in mind when you're running through this okay so then our next arguments are 1 and color so 1 stands for anti aliased you can see that's popping up here I'm not gonna explain really what that is you're just pretty much always gonna use one if you're bleeding something or rendering texturing and then color is an RGB color so RGB stands for red green blue it's a value between 0 and 255 inclusively that means you can use 0 and you can use the value 255 and if you wanted to make say red well it's red green blue so you say I'm gonna use the maximum amount of red the minimum amount of green and the minimum amount of blue that would give you red if you wanted RGB if you want to blue then you would do 0 0 255 if you want white funny enough it's 255 255 255 because white is actually a combination of all colors so that's why or combination all of red green blue that's what you do like that if you wanted black it'd be zero zero zero and you know you can look up RGB color codes and find them quite easily on the Internet so limes label will be that will say level oh I just realized I called this level it should be lives my bad so lives lives let's do level label so level label equals main underscore font dot render do an F string again not a D string and F string and we will do level colon and this time we'll do level and then we'll do one two fifty five two five two five so to summarize this has created text which is white antialiasing of one that has these contents and now we need to put on the screen so I put on the screen we're gonna say win double its first one what do you want the lives label okay lives underscored label and the position that we want to put it on we need to pick an XY I want it in the top left hand corner of my screen but not like directly in the top lefthand corner just a little bit offset so I'm gonna say ten ten so ten pixels down ten pixels right is where the top lefthand corner of the label will sit so it will sit just barely offset from the top of the screen and then we're gonna win da blitz be level label of course and here for our XY z can be a little bit different I want this on the right hand corner of the screen so I'm gonna take a guess that's actually you know what let's do the mathematical way cuz we're going through some indepth explanations here anyways if I want this to be ten pixels from the righthand corner of the screen what I need to do is determine the top lefthand corner of the label so where should I put that right let's say like I want the label to sit so that the edge of the label is only ten pixels from the far right hand right hand side of the screen so to do that I need to figure out the top left hand corner position well what I can do is find the width of this label I can find the width of the window and then I can take my padding whatever I want the padding to be and use some mathematical equation to figure out where that should be so thinking off the top of my head here it's gonna be width which is the width of the when to itself so whip in this case it's gonna be level underscore label dot get underscore wit so we've got underscore width is a method you can use on surfaces that tells you the width of that surface so since I don't know the width of this level label because I don't know how big or how long this text is gonna be I need to call that method and then I'm gonna subtract another ten pixels because if I left it at this that would mean that it would be right on the edge so like the L or like whatever this level number is would be squished right on the edge so we'll subtract ten pixels to move it off and then we'll pick a yvalue which is gonna be the same as what we used before as ten and blitt that to the screen so let's look at this now and notice we get lives five level one perfectly in the right position I mean say that you know we had we changed the width so actually let's do that let's change the width to be 800 so let's go like this if we change the width everything works fine and in fact I can change any numbers I want because we've done this in a dynamic fashion everything will stay consistent it will stay totally fine so we'll put him back to 750 750 but that's why I've been doing things maybe in a more tedious way rather than just hard coding because I want this to work for any width height that I choose so let's zoom out a tiny bit there let's move that over and now it's getting to some more stuff so we've displayed the lives displayed the level now we need to make a character and in fact we want to move a character around the screen so the first thing I'm gonna do is set up a ship class so I'm gonna say class ship this is gonna be what we call an abstract class which means we're not actually gonna use this class we're gonna inherit from it later because keep in mind we have enemy ships and we have player ships right those are the two parts of our game really right and they're interacting with each other so the enemy ship probably has some similar properties to the player ship so we can share that in one kind of upper level class and you'll understand how this works more but just follow along with me for now so we're gonna make in an it method we're gonna say okay so what are some properties of a ship that we want to store in this game well we need the x position and the y position the ship so where is the ship starting is it starting at the top is it on the left is it in the middle so let's go X Y like that what color is this ship that's something that's important right so what color and what about the health does this ship have a specific amount of health in fact I'll make this an optional parameter of a hundred which just says that our default ship has a health of a hundred right so the reason we need to put color here is because when we have an enemy ship we don't know what color it's really gonna be right so that's what we'll define with this color parameter when we create a new ship is it red is it green or is it blue it can't be yellow because yellow is gonna be the main ship the one that we're using to to shoot out the other ship right alright so actually what I'm gonna do is remove this color parameter for now just because since this is a general ship class for our player ship we already know what color that's gonna be it's only the enemy ship that will you know change its color on initialization so we'll define that later but let's let's just just ignore if that confused you at all the color aspect that I was talking about so we have selftaught x equals x and something like was y these are setting up attributes for the class so that each ship we create can store you know it's x value and it's y value right and i'm gonna try to go through basics of up here like give you a little bit of an explanation in case some of you aren't familiar with the syntax but just follow along and understand that what i've done is made of ship what this class allows me to do is make objects of it so i can have multiple ships that all have these attributes so they all have an X they all have a Y and they all have a health that's what the class is letting me do is later we'll create an instance of it which means that we can have multiple instances of a ship that all store their own health value their own X in their own Y and they all move on their own kind of terms right and that's the idea here we're gonna have multiple things so let's put it into objects in classes okay so we've done that I'm gonna say slash ship underscore image equals none talk about this in a second slash laser underscore image equals none and selfthought lasers equals blank and self dot cool down counter equals zero now the idea behind this is that when we start shooting lasers we want to make sure that we can't just spam the lasers so I'm going to define a cooldown counter here which essentially means we're going to count and we're going to wait like half a second before we let the user shoot another laser well get a lot more later but you know we're just starting to class these things out just so that we have that okay so we have that now defined ship and what we can actually do in here is define a few methods so the first one that I want to do is draw so actually let me go back here for a second just because I feel like some people might be confused on this so self that ship image and self thought laser image are what is actually going to allow us to draw the ship and draw the laser so we need to pick what image from the ones up here that we've loaded in are we gonna use for this specific ship since this is a general class and it's not gonna be instantiate I'll show you what I mean in a second we just define them as as none for now but when we actually set up our own ship later and start creating ships we'll define those images so that we'll be able to use them okay so we have draw so draw is gonna be important for now and what I actually want to do cuz I just want to show you guys how we can move around the ship before we get into anything too complicated is just draw a rectangle for now so I'm gonna say we're gonna take a window in the parameter so this is gonna tell us where do we draw this like where are we putting this we're gonna say window and that's no Noblet we're gonna say pygame dot Rex sorry PI ChemDraw dot rect what this says is PI game use the draw module dot draw rectangle we're gonna pick where so we're gonna draw that on the window we're gonna pick a color let's make this red for now so to 3500 for red we need to put a rect in here now this is a X Y width height which tells us how big is this rectangle and where is it on the screen so where's it gonna be well it's gonna be at self dot X selfthought Y because that's the position of this ship and how wide is it gonna be well for now since we're just testing things let's make it 50 by 50 now if we wanted the rectangle to not be filled in we could define a width so let's say we define a width of 2 that's gonna give us a hollow rectangle with two pixel size for the pen size around but if we want to be filled in we can leave it as nothing or put zero explicitly which tells us that that means this is a filled in rectangle okay so now that we have that I'm going to show you how we can use this ship and then we'll start getting into some more advanced things but I do I want to show moving around first so let's make a shift let's say ship equals ship and here we need to pick an x and a y value to start the ship at so I want to start it near the bottom of the screen so what I'm gonna do is pick like 300 by 650 and then what we'll do we don't need to define a health because that's an optional parameter right we've already had that to find is inside of my redraw window I want to draw this ship so what I'm gonna do is a ship dot draw window now the idea behind this is that this draw method draws the rectangle for us all it needs is a window so what we can do is just call that draw method if there's any more advanced stuff that needs to happen we don't need to deal with it here the ship can deal with that itself in its own draw method so let's just call it with the window now we'll see the ship so let's run this and we notice that I've made a mistake let's see what this make window is not defined my bad we need to put capital win in their window is the parameter name I'm messing it up so let's do win we run this we get this red red rectangle popping up at the bottom of the screen so if I want to much start moving this rectangle around now I need to modify its X&Y position based on what keys I press let's do that now so to do that we're gonna set up a way to track what keys are being pressed by the person now I could show you how to do it inside this event loop but the issue with that is it only registers one key press at a time so let's say I press like the side key and the top key at the same time it won't move both ways it will only move one of them whatever one you hit first I want it so I can move diagonally as well so I can move at the same time by just holding down keys so we'll be allowed to do that by pressing both keys at the same time with this method so what I'm gonna do them SI keys equals PI game key don't get underscore pressed what this does is return a dictionary of all of the keys and tells you whether they are pressed or not at the current time so since this runs once or 60 times every second I'm gonna mess that up every time I say it so just get used to it we'll check you 60 times every second if we're pressing a key if we are we'll move in a certain direction if we're not we so let's say if keys and here tie game dot k underscore so k underscore is just the prefix for what keys you can use so you do PI game and then there are keys since it's a dictionary we're gonna access the value and see if it's true pi game dot K underscore and then whatever key it is that you want so if you want a you type a lowercase a if you want to check if the left arrow key is being pressed you do left if you want enter it's actually gonna be returned if you want space it's all capital space you see I have this nice autocomplete that's telling me but ideally you can kind of guess with just lowercase letters and anything that's like a full word like enter or something or return is gonna be all capitals so if one move left we're in say if keys PI game can underscore a and then we'll go hash tag left I'm just gonna do a comment so that tells me we're moving left and to move left I need to subtract from the x value of my player so I'm gonna say ship dot X minus equals one now minus equals one means we're gonna move one pixel to the left now ideally what I should do actually is define a velocity variable which tells me how fast I'm allowed to move in every direction so let's do that at the top here I'm gonna say player underscore Val equals and let's pick some number I'm gonna pick five what this means is every time I press this key I can move five pixels so you can you'll figure out how fast that is when we start testing the game but that will also be dependent on your clock speed right so if you had a lower clock speed you probably want a higher velocity because this loop is only running so often so if I held down my key with a higher clock speed I'm gonna move more because this is gonna trigger and happen more times and move me more to the left right so let's do minus equal ship on your score Val or player underscore Val like that and now let's do the other key so I'll go a little bit faster here if keys as I say I'm going faster makes a bunch of mistakes pi game K underscore D so this is to the right like that make sure I don't forget that cool in there then we'll say ship dot X plus equals player underscore bail if keys pygame k underscore and this is gonna be double use for up we're gonna go up like that and then ship oops ship dot y minus equals player dot velka's remember moving up so we need to subtract the velocity because the starting position is zero zero and the top left and we're gonna say if keys pi game k underscore s which is gonna be down notice I'm using WASD you could use the arrow keys if you want by changing this to be all capital left all capital right all capital L capital down but let's do this we'll do it down then ship duck y plus equals player under squared bail okay so now that we have that what this will do is move our player so let's run this and let's have a look so if I use my WASD you can see that this cube now moves around the screen so let's now start restricting how this cube can move because notice I'm gonna go completely off the screen I can go any direction of I want right and maybe you might think this is a bit too fast as well so let's make sure that we can't move off the screen so to do that what I'm gonna do is say if keys PI game duck a underscore s and ship dot y plus player bail is less than height so what this is saying is if I add sorry not Val what am I saying player underscore bail if I add this player velocity value to the current value of my why will I be off the screen if I'm not off the screen let me move because I'm less than height which means I'm not off the screen so I'm trying to move down right otherwise don't that's what that's saying so that's that's that line so now let's see the other ones and ship got Y minus player underscore bail is greater than zero because we're moving up so we want to make sure that we're not going to be less than zero when we're doing that and for right we'll say and ship dot X plus player bail is less than width right and we'll say and ship dot in this case x player underscore bail is greater than zero so now if we run this you'll notice that I can't go down while I can but it stops me I can't go left right if I try to go up I can't go up if I try to go right though I can go all the way off but just not like only here now the reason why I can go this far off is because the top lefthand corner is what I'm checking so right now technically the constraint that I've plugged in here that's in my code is valid because the top left is still in a valid position what I need to check though is if the edge of this cube is hit so the way I do that is by getting the win right so what I can do is a quick fix here is say if I'm moving to the right let's add 50 because that's the wick of the cube and make sure that the top lefthand corner is further enough to the left such that you know even if I'm adding this width it won't go off so that's the idea here with going rights and now same thing with the bottom so if I add 50 to the bottom so when I'm going down I want to make sure that the bottom edge doesn't go off the screen so that's how you do that is you just add the width to that equation so now notice I can't go any further than that and if I go to the right I can't go any further than that now obviously we're gonna change this because we're gonna use like proper graphics in a second but I wanted to show you how to move first in a more fundamental aspect so you understand the mechanics behind what I'm doing okay so now that we've done that let's actually make a proper ship so let's make a proper player ship rather that that has the proper graphics rather than what I've just done right here so in draw what I'm actually gonna do here is go window blitz and I'm gonna say ship or self dot ship underscore image this is just how I reference the attributes that are specific to this ship so the one that's being drawn I'm gonna draw this at self dot X self dot y like that so draw window tuplets self that ship self that excel taught why we'll get into the laser stuff later but that's like further on once we have the graphics working okay so we'll do that and now what I'm gonna do is to find a new class and then call this flare now the player is going to inherit from ship which means that it's gonna take this initialization it's gonna take this draw method and use it we're gonna add more stuff to the ship class later that will make this make more sense this inheritance but for now just understand that any methods in here because I've defined this inheritance means I can now use them inside a player so what I'm gonna do is to find the net inside of player so define undescribed square net self XY health like that health will be a default parameter of 100 once again and what I'll just do immediately is called ish this initialization method from inside of here so to do that I'm gonna say super dot underscore underscore net underscore underscore self XY health like that I don't know if this takes self I don't actually think it does I think it's just XY health what this says is super is this parent class ship let's use ships initialization method on this so we define our own initialization method because we're gonna need to change a few things in here which I'll show you in a second but let's use the super method so it creates all of these different variables that we need and it initializes things right it just runs that code and now let's add our extension we're gonna say self dot ship underscore image equals yellow ship and self the laser underscore image equals yellow laser so we've defined how these two non parameters so now we have those we're good to go and what we need to do next is create what's called a mask so what a mask is gonna let us do is do pixel perfect collision so you may notice in other games where there's like weird hit boxes and if you hit like the edge of something but there's actually not a pixel there it still counts because it just does a square hit box well pygame has this thing called masks which lets do pixel perfect collision which we'll get into later but we need to define a mask so we're gonna say a self dot mask equals Pi game dot mask dot from surface from surface self dot ship image now what that means is okay take this surface which is the ship image and make a mask of it this mask just tells us where pixels are and where they aren't in this image so that when we do collision we know if we actually hit a pixel or not then what we're gonna do is say self dot Max underscore health because we're gonna add a health bar later is equal to 100 are not hundreds re is equal to hell so whatever health we start with is the maximum health we can have as a player now the reason we need that is because we're gonna decrement the players health rate because we define health up here but we need to still store what it started with so that we can figure out what its maximum health was when we want to draw the health bar and figure out the percentage to decrement it by so there we go we have the player and now I think that's actually be okay for drawing so let's just change everything from ship now to player now an easy way to do this and subline taxes do command each and find any ways to ship make sure it's case sensitive and replace that with player like that so we're gonna say ship player which means now all these things that are highlighted or and you can see them it's not highlighting the capitals will change to player so player will be equal to well that'll have to change by names you get the idea so let's hit replace all and now all of those are changed to player so player dot x player doubt why all that and let's now change instead of ship the Xena State player so we're gonna initialize a new player which is equal to a player objects starting at three hundred six fifty and then we've changed all that so now we'll draw the player so let's run this and notice now I have the ship and it's moving around now no fancy animations here but that's fine we're I'm gonna do an animations in this specific video let's fix this now so that we can't go off the screen of the ship so to do that what I'm gonna define in ship is actually a way to get the be height and the width of the ship so I'm gonna define inside a player actually let's do it inside a ship because this will be fine let's define gets underscore width like that so this is a method and what we're gonna do is return in here selfthought ship underscore image dot get underscore whip so remember whenever we have a surface we can call get width and get height on it and it'll give us that so here also define get underscore height self return self dot ship image gets underscore Heights like that okay so these are two methods there's getters they're literally just turning a value to us because we're gonna want those in the main loop I've defined this in ship not player because player inheritance from ship and we're gonna want to use these inside of the enemy ships which we create later so let's just go ahead and add them to this you know base class that we had above okay so now that we've done that rather than +50 all we need to do is go player dot get underscore in this case this is height and player dot get underscore wit so before we had fifty there because fifty was the height and width of our rectangle but now since we have the actual image we need to get the height and width of that image and use that as the offsetting value in this equation right so that's why we're adding those into there so let's run this and now notice that I can no longer go off the screen to the right I can't go down can't go left cannot go up you may be a global why is it only like on this sides a little bit different than this side all of that you can modify those numbers like I had a few pixels if you want it's just based on where you start so like says start at some location right well moving to the left I don't really it's hard to explain this but if you start at pixel value eleven and then you can move back five right so you're at six but if you go so you can move back even more from six and you go to one pixel you can't go any further than that but if you're going to the right say the boundary is at like 20 then you can go to sixteen but you can't go further than that because if you're at sixteen and you add five which is the velocity you'll be greater than the width which is 20 pixels in that example so you can't move that far over so I get that question sometimes like why is it different on the left and right side I don't think it's a big deal but some people do it's just based on where you start the object and you're subtracting a certain pixel value of like five or four so you're only gonna be able to move in a certain direction so far I hope that makes sense that explanation okay so now that we have that the ships moving around like we're we're making pretty good progress here let's do the enemy ship so let's let's get that one running so we have player so let's define enemy so class enemy ship like that it'll inherit from ship and in fact we don't really need to call it enemy ship we just call it enemy like that and inside of here we'll say define underscore underscore net underscore underscore self X Y we're actually gonna put a color parameter here remember I was talking about that before and then health equals behind so inside here we're new same thing we've done before I'll go through this slowly after but I just like to type it so that you don't hear my keyboard the entire time that I'm talking and then we'll pass X Y hello okay so what I've done is I've defined a new initialization I've said this time we need to pass a color because our enemy ship will be different colors or it'll be red green blue I won't not BL and will pass the health as well and we'll call the super constructor so this one right here to set everything up and then we will add our own images and stuff after so what I'm actually gonna do in here is make a class variable and I'm gonna call this ship I'm actually gonna call it color underscore map now the idea behind this is that what I want to do is make a dictionary where a specific string because what I'm gonna do is pass a color as a string so like will pass the string like red green or blue based on what color it is we want so if they hit red I need it so it gives me the red images so this enemy will have the red images right if they give me green I need them to have the green images so I'm gonna make a map which is just a dictionary that says okay if we type red right so if we do red then what that maps to is the red spaceship image and the red laser so if we have the red ship it's gonna use the red spaceship image and the red laser right if we have green then what this is gonna give us is the green spaceship and the green laser right and same thing for blue so if we go blue so be blue spaceship and blue laser now that's like pretty straightforward I'll you make sure I add commas here because it's a dictionary let's hit enter one more time so that's proper and now what I can do is just use this map so I can say something like self dot ship underscore image self dot laser image is equal to self dot color map cut so all I need to do is just pass that color the parameter that we passed in to this map and then that will return to me the images that we're gonna use so that's what we have so we'll do self dot ship image self the laser image is equal to self the color map it's not really much more I can do to explain that that that's the basic concept behind that okay so once we have that we need to make a mask so to make the mask gonna say self dot mask is equal to in this case tie game mask dot from surface like we did before except this time well actually I using me the same thing self dot ship image like that so we have the mask we have the color setup we have the images and all we need to do now actually I don't even think as much we have to do here we're gonna implement a method that allows us to move the ship but I think that's all we really need for the enemy so let's hop move and let's have Val and what this is gonna do because the enemy ship will only be moving downwards right it's gonna start at the top of the screen and move down this is just gonna say okay self thought why plus equals Val so if we pass a velocity to this move method we'll move the ship downwards okay so looking at my other screening that's all we need for the enemy ship so let's now figure out how we can start spawning enemy ships and have them moving down the screen and then we'll do lasers will do collision a main menu and I guess an end screen like if you lose and will pretty much be done with this application although that is in a little bit because the lasers are the more complicated part of this so let's start moving the enemies so what we're gonna do is make a list here I'm gonna call this enemies I say enemies equals blank list what this is gonna do is store where all of our enemies are and in fact I'm gonna another very well I'm gonna say oops not staticmethod I'm gonna say wave length is equal to five so we're going to start with the wave length of five and then we're gonna increment that every time and in fact I'm gonna set level equal to zero because I didn't do something cool in the second you'll see why I'm doing that but what I want to do is every time that we get to the next level generate a whole new batch of enemies and have them start moving down the screen so every level we generate a new wave that wave will be in random positions and then they'll start moving down slowly based on a certain be lost which is gonna be called the enemy fell I set that equal to one pixel so they move quite slowly downwards on the screen and what we'll see how this works so that's the idea here what I'm actually gonna do is I'm gonna get ahead of ourselves a bit inside of the redraw window function I'm gonna say for enemy in enemy's enemy dot draw win the reason this works Rex you like well I don't have a draw method insan enemy the reason I can do that is because this inherits from ship ship has a draw method where it draws the ship image and we've defined a ship image here so we can draw them before the enemy right based on whatever color it is that that enemy is so for each enemy let's draw it onto the screen that's what this says in fact I'm gonna make sure that I draw them behind the player just let's say an enemy and a player in the same position the players overtop and the enemy because ideally you want to see your own character not the enemy if you're overlapping so that's the idea behind that okay so now that we have that we need to move the enemy and spawn them so the first thing I'm gonna do is actually move this redraw window to the bottom we might be moving around quite a bit throughout this but let's put at the bottom now to keep it kind of out of the way and at the top I'm gonna say if the Len of enemies equals equals zero level plus equals one so essentially as soon as no more enemies are on the screen because once they hit the bottom once they're off the screen this list is gonna be empty that represents our enemies because we're gonna delete them and I'll show you how that works in a second let's increment the level because we beat the current wave of enemies let's increment the amount of enemies we're gonna have so let's say cur underscore wave or wave length ya plus equals five so if we start with a wave like the five every time let's add five more enemies that's what I'm gonna go with but you guys can add as many or as few as you want and then let's now create this many enemies so let's say for I in range wave length like that let's spawn some new enemies and append them to the enemy list and start moving them down so what I want to do when I spawn these enemies is pick positions for them so they don't all come down at the same time ideally I want them to come down so I want to spawn all of them here I want to create all of them here but I want them to move down and look like they're coming at different times so to do that I'm gonna pick random positions for them that's way above the screen so the idea is I'll go to my drawing tablet here to show you quickly if this is our screen right and I want my enemies to all be moving at a consistent rate I want to spawn them all at once but I want them to look like they're moving at a different duration I can put them above the screen in a negative position and move them down slowly so what happens is these will all move at the same time right they'll move at the exact same velocity downwards but since they started at different heights it will look like some of them started coming down before the other ones when in reality they just started higher up so that's the concept that I'm gonna use here is I'm gonna randomly spawn them at different heights and different xvalues they might overlap with each other that's just the principle of random there is ways to fix that but we're not gonna do that here so that they look like they're coming down at different speeds or different areas right so that's the idea so let's do that so what I mean new is I'm gonna say enemy equals enemy here we need an X and a Y so random rand range remember I imported random at the top the range that I want for the x position is gonna be 100 and width minus 100 so this is pretty much saying I want to spawn my enemies at a maximum left side of 100 actually let's make this 50 and a maximum right side so they're top x position or top left x position at with minus hundred that's just to make sure they don't go off the screen right and then we need a Y value so soo random dot R and range in here we need a Y so I want these to start in negative so they start off the screen so my first value is gonna be the smallest value that I want them to start at which is gonna be 1500 and the next value will be the closest so I want them to start between negative 15 hundred and negative 100 now you could in theory have the possibility that they all start at the same level because this is random but the idea is that they probably won't do that because it's such a large range so some will be up higher some will be down lower and they should be in kind of relatively different positions so that they come down at different times now you can change the way you spawn these if you want but this is my idea this is what I want to use but again guys do whatever you want this is your game so random because now that we've done the X&Y position we need a cutter so let's do random dot choice and inside of here we're gonna make a list of color so in this it's gonna be red blue green now what random not choice does is randomly chooses one element from a list pretty straightforward so this is the list of colors that we want that are valid red blue green so randomly pick one from that for the that's just cuz I want some variety I want some different ship colors if you want to have like red ships have more health or something go ahead feel free to do that but I'm not gonna do that for this I'm just gonna make them all the same but just different colors right so it spawns them and now what I need to do is just add them to the enemy list so enemies dot append enemy like that and now that I've done that they're in the enemy list and I can start accessing the enemy list to move my enemies so we've done that we've spawned them in if the enemies the letta enemies is zero we'll increment the level increment the way by five spawn all the enemies that we need and then you know move forward now you could say all right well if we get to a really high up level this might be slightly flawed because you can have so many enemies within this smaller range so you could do something like negative fifteen hundred times level over five or something like you can change this value if you want a level over five will be a bit of an issue but you can do like a more dynamic approach to this range if you want to multiply by some constant value or something like that but that's just I'm just starting that idea out there in case you guys want that so if you want to move these enemies essentially what we're gonna do is every time that they're on the screen so there's any enemies in our list well move them down by their velocity you're pretty easy we're gonna say four enemy and enemy's enemy don't move and in this case it's just gonna be enemy velocity like that now you see how neat and nice our code is reading right now because we've implemented these methods keep that in mind that you know that's the nice thing about making classes and methods is that when we use a main line like this it's really easy to read because we have these nice methods that literally are reading out and telling us what it is we're doing so I think that your work let's run this code what's the issue here what have I done wrong uh to do random dot choice kierra green ah so it would help if I spelt everything correctly so the green needs to ease the issue there was I spelt that wrong so when it tried to greet an enemy that was gren not green it couldn't do that let's run this now and see that if we wait a second cuz it is they spawn quite high right now all these enemies start coming in now you know we got unlucky here they kind of came in a batch but we can again do whatever we want if we want to spawn them like every 100 pixels upwards you guys can figure out how to do that but the issue we see we're seeing immediately is we're not losing any lives when these enemies go off the screen and they're not actually being removed from the list which means that we're never gonna make new enemies once all the enemies are off the screens what we need to do now is every time we move the enemy make sure that they are not off the screen and if they are decrement the lives and remove them from the list to show hey this enemy is gone so to do that we're just gonna check the position of the enemy so if enemy dot y + enemy dot get underscore height notice we've used this method now that we needed plus actually it's not plus because we already moved them so we'll just check is greater than Heights then what we'll say is lives minus equals one because we lost alive they hit the checkpoint at the end of the level let's delete them then so if we want to delete them since we're looping through this list I need to make this a copy of the enemy list and just do enemy dot remove or not enemies or enemies start remove enemy what this does is remove the object which is this enemy from the enemies list I've made a copy here so that it doesn't modify the list we're looping through because sometimes that leads to issues and that will mean that then once all the enemies have gone off the screen there'll be none left in the list so we're able to hit this Len equals zero you know condition increment the level and ink the wave so let's do that and let's run this and let's see if they actually go off the screen I guess I'll fast forward and we'll go through this okay so we can see that the lives now obviously we're going negative because you know we've lost at this point but just notice that once we get to negative five because we started with ten the level increments and now more enemies start coming onto the screen in different positions and these seem to be working fairly well now obviously what we need to do is make sure that we don't have a negative live square so we'll implement something that will fix that for us which is just gonna tell us if we lost and then we'll get into shooting the lasers and after we do the lasers and the collision with the lasers I think that's pretty much all we'll need for this game so let's let's do the thing if we lose down so essentially if lives is less than zero or I guess less than or equal to zero and in this case I'm actually going to say or Claire dot health is less than or equal to 0 because we are gonna implement a health bar that's the doctor about we'll need to do that next with the with the player then we'll say that we lost so we'll just a loss equals true we'll define a lost variable up here we'll say I lost equals false like that and now forgets about lost correctly what we'll do is if lost is equal to true we're gonna increment some kind of counter system that essentially says we're gonna show a lost message on the screen for a certain amount of time and then once that lost message is done we'll go back to like the main menu which we're gonna create later so lost equals true let's actually just do something inside of redraw window here so we'll say at the bottom if lost so if lost is equal to true we can access that because it's up here what we'll do is we'll say lost font which we're gonna make need to make a new font for so so the main font will say lost font like that make this a font size of 60 s there's a bit bigger a bit more emphasis and we'll say lost underscore label equals lost font dot render in this case the text is gonna say you lost exclamation point exclamation point one color that'll be white 255 to five to 85 then say wind judge blitz lost label and if we want to put this perfectly Center in the screen I'll show you some math magic to do that that's gonna be width / 2 explain this in a second don't worry lost underscore label get underscore width / so the idea behind this and let's put it at a Y position of 350 is that if we want this to be in the center the center of the screen is the width / 2 but since this has a width like the text itself and we draw from the top left we need to make sure that we're drawing so that B width right when we include that width will still be Center so if we do with / and then we subtract from that to go left so that we account for the extra width half of the width of the text that'll be perfectly centered because that's like I don't know a really great way to explain it but essentially if we have Center here if we draw it's gonna come all the way over to one side or all the way over to one side so if we can move this position over slightly so that it's half of where the width is then it'll be perfectly Center in the middle of the screen that's my somewhat visualization using my hands hopefully that made sense but that's the math there put that in the middle and there you go so now we'll check what happens if we do lose I'll show you that the game is gonna still run when it says you lost which we'll fix in a second but the idea here is that it's just like you know it's gonna say that we lost so let's speed this up we'll get through it and I'll show you case we're coming out in one life we see you lost now pops up in the middle of the screen obviously the game keeps running but I'll show you how we fix that now so to fix this we need to increment some kind of like timer that tells us how long to show the lost message for before we just reset the game and also pause the game right so it doesn't keep moving and decrementing the lives once we lose we want to just pause the game once we lose so we're gonna say after lost we're gonna say a lost underscore count equals zero and what we're gonna do now is if we've lost write lost equals true will say lost lost underscore count + equals one so increment one every time and then down here was say if lost like that say if lost underscore count is greater than in this case we're gonna do 60 because that's our FPS so actually will do FPS multiplied by five so if we wanted to say show the message for five seconds we would do FPS multiplied by 5 because FPS is how many frames we show per second you know and then how many seconds who want to in this case let's do three so if it's greater than that then what we'll do is we'll break this while loop so set run equals false and we'll quit the game otherwise so else we'll continue now what this is saying essentially and we're gonna have to move this redraw window to actually be at the very beginning of the loop so I show left it there but that's okay what this is saying is if we've lost so if lives is less than you go to zero or playerhealth is less than zero loss equals true lost count plus equals one and then we say if lost so if we have lost if the lost count is greater than FPS times three then run equals false which means we've now got past our threesecond timer let's quit the game if it's not so if it's still looping we're still waiting to hit three seconds continue which means don't do any of this don't let us move don't move anything go back to the beginning this while loop and keep running and then we're redrawing the window every time so we'll look like that lost just sits there for three seconds and nothing else happens let's run the associate what I mean so again I'll speed up we'll get to when we lost and I will show you okay so we're getting down to it here we can see two one you lost boom level freezes wait two three boom game ends okay so that is how that works we've got the lost counter going here we can add a main menu pretty easily later on but now time for collision and lasers now the lasers and the bullets are a little bit more complex in terms of how they move because we need to shoot them from the enemy ship we're from the player but we'll get into that I guess right now alright so the first thing we need to do if we're going to be shooting lasers is we need to create some kind of laser object so in this case what I'm actually gonna do is make a new class called laser so let's type this out class laser we're gonna do in a knit and what this is gonna represent just one laser object now the idea is that we're gonna have multiple lasers being shot from each player right so if I shoot a laser going upwards I need to make sure that it keeps going in that same upwards angle right it's not following what the player is moving cuz a common issue people do is they'll make like the laser follow the exposition of the player which means that if I press the left arrow key once I've shot the laser the laser moves to the left which is not what we want to do right we want to make sure each of these items are independent of the person or the player or the enemy or whatever it is so that they can kind of act on their own they can collide with things on their own and they're their own entity so that's the idea so what we're gonna do here is have a laser it's gonna have an X Y it needs an image we're gonna pass that image from the ship class so the idea is that when we make a new laser object so when we shoot this laser the player will create the laser object add it to it it's Laser list you guys we have lasers here and then it will control how those lasers are moved so that's kind of the concept but we'll get into that sighs so let's say self that x equals x self the y equals y selfthought IMG equals IMG and of course you need to make a mask for this as well because this is what's gonna be colliding with different things so self dot mask equals Pi game mask dot from surface self IMG note you could put IMG there as well doesn't really matter but we're gonna do that so now what we're gonna do is make a draw method so the draw method will take self.window like before and we'll say window judge belitz self dot IMG and then self dot x self dot y now what we'll do is we'll do define move so define move self Bell which will move this with the velocity so the velocity will be going upwards or downwards based on what we pass in here so in this case we'll just say self dot y plus equals vel if we want to go down will give a positive l if you want to go up will give a negative L as the parameter and if we add a negative value obviously that means we go up so we have move let's define a few our methods we're going to find underscores screen which is gonna tell us if these lasers off the screen based off the height of the screen so we're just gonna return from this return selfthought y is less than height and yeah and selfthought y is greater than zero I will do greater than equal to less than equal to as well I guess and that should be good for this right now we're gonna find one more method which is gonna say collision which is gonna tell us if this collides with an object so laser collide object and what this is gonna do is call a function that we've yet to define but we'll define in a second called collide so all this will do is return the collide of object itself now let's actually go ahead and create this collide method because our yeah collide function I guess because what we're gonna need to do is check if things are colliding when removing the lasers so it makes sense to do that before we start actually moving the lasers but essentially what we're gonna do with the collide is use these masks to determine if two objects are overlapping if the pixels between them are overlapping and if they are then we'll say yes these two objects are colliding so I'm gonna define a function here called collide it's gonna take object 1 actually we'll just do obj one and obj two and what we need to do here is use something in PI game or use this mask property called actually I got a look over here to see exactly what it's called because I'm blanking on its right now I believe it's like overlap yeah that's what's called it's called overlap so what we need to do when we call an overlap and actually let me go to my drawing tablet if I give you my beautiful drawing skills with my mouse again to show you what I mean so what a mask is is essentially if we have like this right so this is my object an object has a width and a height now we know that when we're drawing these objects only some of the object is actually taken up with pixels right so in the example of our ship we have something this is going to be my very crudd ship right this is like my rocket ship say it looks something like that maybe it has like a little tail but the idea here is that these are where the pixels are and all of this blank space here is not where any pixels but based on the way that we've loaded this object in if something hits like right here we'll say that it's hit the object because it's inside of this width height hitbox like this WH hitbox I'm not sure if if I explained this before but essentially let's say we bring in a circle like we left it's really hard to draw with this mouse let's say we bring in a circle right well what actually happens is it makes a square around this circle and that is what the surface of the circle is it's rectangular because it's very difficult to have circular objects in computer graphics like when we're rendering and drawing things or creating services so the idea is that we have this circle but really it's represented by a square where all these other things are here a transparent but the actual circle itself is the pixels right so we want to make sure that when something hits our object we're not saying it hit unless it actually hits some of the pixels of our object not the transparent background that may exist that's a part of that object and you will see this quite often when you load in sprites as it'll load in with with height right like say we load a little character it'll load in like this like this will be our character and if you hit this side like anywhere on this box it will say we hit the character even though it's not touching the pixels so it's misleading to the player so the way that this mask thing works is if we have two let's say objects like this and they're overlapping like this what we do is we ask pygame we say okay so if there's like pixels here here here here here here and there's pixels here here here and there's pixels in the same area so there's pixels inside of this inside of this overlap in both objects we'll say that this collided if there's not we'll say it didn't collided or we it did not collide because these two objects are not overlapping where their pixels exist I think that makes sense but like the idea is if we have you know stickman right and he has his thing like this and then we have you know I don't know say a laser like that maybe the lasers hitbox is something like that even though these two boxes are colliding we're not gonna say they collide unless the pixels hit the other pixels so the way that we need to do this though is we have these two masks which represent where pixels are that's why we created that mask object but in order to determine if they're overlapping we need to come up with something which that's called an offset the offset essentially tells us the distance between the top left hand corner of both of these objects we need to know that because given that information we'll be able to determine if they are actually colliding with each other and where their point of intersection actually is because what the overlap method will do in masks which we'll use in a second is tell us where these two objects collide so the point of intersection between them now we don't really need that but we're just gonna see if we get a point of intersection and if we do we'll say yes these objects collided if we don't they did not but the idea is we need this offset which tells us how far away object 2 is from object 1 based on their top lefthand corner coordinates so to calculate that what we're gonna say is obg 1 actually have to say offset underscore X equals obj 2 dot X not equal sorry obj 1 dot X this will tell us the distance from object 1 to object it's fine if this value is negative which it may be sometimes depending on the coordinates but that's how we do that for offset X now offset Y is gonna be equal to obj why obj1 obj2 I so again that just tells us the difference between them since this is X Y I mean you can consider that a vector with two components we need to do these separately and subtract like that so now that we have that what we can just do is return obg 1 dot mask dot I believe this is overlap yeah I've said that so many times dot overlap and then here we're gonna say obj so is object 1 overlapping object 2 with the offset of offset X offset Y so that's what this collide function will tell us is given two masks right so give an object one and object two if they both have a mask so mask here and sorry this needs to be Audra mask if these masks are overlapping based on the offset that we've given between the difference of their top left coordinates then we'll return true otherwise we'll return false and actually what this needs to be is return does not equal none because if they're not overlapping this whole thing that I'm highlighting here will return none if they are it will return to us actually at a polar tuple that looks like this XY that tells us the point of intersection so hopefully that wasn't too confusing and I didn't go too crazy facet is kind of hard to explain masks without my drawing tablet out which I don't really want to get out right now but I think that's good enough explanation for the collision so if we go back to where we actually called that which is here we can see that all this is doing is returning the value of this collide function now the reason I've called self here is because I want to see if the object is colliding with myself right and I could call it in the other method or the other order which is self obj but all self does is give access to this specific instance so in this case it'll be a specific laser so we'll just pass those two things in so the self which is this object and then the object that's giving us here that we want to check if there's a collision with and then that will return to us if it's collided or not okay so now what we're gonna need to do is implement a few things inside of the enemy and player class in terms of creating a laser as well as creating a cooldown for the laser so we can't shoot it too fast so the first thing I'm gonna do is implement a shoot method inside of this base class ship because both of our methods or both of our classes will be able to use this so define shoot self we're gonna say Val like that is it felt no I think we literally just need so I think we literally just have shoot self and then what we're gonna do is say if self dot cooldown counter equals equals zero which means we're not in the process of counting up to a specific cooldown or keeping track of how long until the next shot then what we will do is create a new laser and add it to the laser list so we'll say laser equals in this case laser we'll give it our XY value so XY and then what else does the laser need it needs an image so the image will pass is self dot laser image because laser image is what we're storing here as the image for the laser then we'll say in this case self dots oops lasers dot append laser like that and the next thing we'll do is reset the cooldown counter so that it starts counting so I'm gonna say or not reset will start the cooldown counter so it starts counting up so self dot cooldown counter equals one so the idea behind this is that we will make sure that we are at zero for the cooldown counter so it's not as certain value like waiting to go down are waiting to go up or whatever it's gonna be and if it is will create a new laser at this current location which will move later on we'll add it to the lasers list and then we'll set the cooldown counter to start counting up now what I'm gonna do here is say define cooldown and what this is gonna do is just handle counting the cooldown so we're gonna say if cooldown counter so if self cooldown counter is greater than or equal to in this self cooldown all capitals I'm going to define that as a class variable up here so cool down equals 30 so that's half a second because the FPS is 60 right so if that's greater than self a cooldown self the cooldown counter equals zero say else self the cooldown counter plus equals one and we will only increment this cooldown counter if sorry not else say if self cool down counter so LF selftaught codec on earth greater than zero so essentially if this cooldown counter is zero we're not doing anything right because it's not greater than or equal to self duck cool done and it's not greater than equal to zero but if it is greater than zero and it's not past the time limit incremented by one okay so now we need a way to draw and to move our lasers so the idea is that we're gonna call this shoot method that creates the laser from down here so essentially if we hit the spacebar we'll call shoot which will create a new blazer object so actually let's implement that now let's say if keys in this PI game dot K underscore space we're gonna use the spacebar then we'll say is player dot shoot so I will call that method and we'll create new laser now remember this is only gonna create a new laser if the cooldown counter is equal to zero otherwise it just won't do anything that's fine we can hit space as much we want but if we're on cooldown it's not gonna work so what we're now need to do is have a method that can move these lasers because right now if we do that is just gonna make them and they're gonna stand still and in fact right now we don't even see them because we're not drawing them so first actually I'll just draw the laser so inside this draw method I'm gonna say for laser in self dot lasers like that and then we'll literally just do laser draw window so that will draw all of our lasers we have a draw method on our lasers that just draws them here so that's totally fine to call that no issue there now we're gonna define a new method this will be called move lasers so define move lasers self Bell and then OBJ's now the reason I've had obj is here so vel makes sense because that's like how fast are we going to move the lasers to the velocity but obj stands for objects and the idea here is that when I move these lasers I want to check for collision with all of these objects so to do that I need the objects that I want to check collision with which are here so we're gonna move all the lasers by this velocity so I'm gonna say for laser in self dot lasers and before we do that we're actually gonna increment the cooldown counter by calling self up cool down so every time we move the lasers we're gonna call this once a frame which means that we'll increment the cooldown counter when we move the lasers right so we can track if we can send another laser or not and then we'll loop through all of the lasers and what we'll do in here gonna check here is go laser move the velocity so we'll move it by the velocity and we'll say if laser dot offscreen which we've made that method here will delete the laser with laser it off screen height will say if that's off the screen then we'll go self thought lasers don't remove laser like that and it shouldn't be a problem with that now otherwise if laser dot collision with an object and watching need to implement another for loop in here in a second I'll tell you that guess take a step back here so I think I'm gonna confuse myself a little bit so I just want to step back and make sure everyone understands so first of all I've changed this parameter from OBJ's with an ass to obj the idea being that actually what I'm gonna do in this specific move lasers method is check if each laser has hit the player so the idea behind this is that this is gonna be used for the player and for the enemy but inside the player what I'll actually do cuz this is the base class right we're inside a ship is I will implement a new method called move lasers but rather than checking if we hit the player will check if we hit any enemies so that's kind of the idea we need to separate move laser methods one for checking if all of the lasers shot by the enemies have hit the player and one for checking if all the lasers hit by the player have hit the enemy so that's the idea since there's only one player we only need one object here which means for each laser we can do if laser dot collision object then we can reduce the health of that object which will be our player so we can say obj dot health minus equals let's say they lose ten health so we can change this value to be whatever we want but I'm just gonna keep it at ten for now and I think that that is pretty much good except that we're gonna need to delete this laser so selftaught lasers Dutch remove laser like that so yes so that's what this is doing call the cool down which goes through and says okay you know we're gonna increment this cool down based on what we've defined here so if we can shoot or not then we're gonna for each laser that we've shot that exists currently in our list we'll move it down the screen by the velocity we'll check if it's off the screen if it's off the screen we'll remove it if it's not the screen but it's collided with one of our objects in this case this object will be the player that we pass to it will do object l equals 10 which is the player right equals 10 and then we'll say self dot lasers don't remove lasers so remove that because when it hits them we don't want it to keep going down afterwards and it potentially hit them a bunch of times if it keeps colliding with the player so that's the move lasers here I'm gonna copy this and we're gonna change it a bit inside a player so let's put this inside a player this is gonna override that parent class 1 and we'll do the same thing so it'll call self cool down again and we'll say for laser and self dot lasers laser don't move but now what I'll do is I'll say L if actually yeah laser to offscreen height will change this to OBJ's then we'll put an else and inside of here we're gonna put another four loops we're gonna say 4 in this case obj in OBJ's then do this and say if laser collision obj and then we could do obj dot health equals 10 but since what I'm gonna pass in here is a list of all of the enemies because we want to check if the player's lasers have hit any enemies we're just gonna remove that enemy from the OBJ's list so we're gonna say we'll remove the laser obviously we'll say Oh BJ's don't remove obj okay so I think that makes sense so we have the player what this is doing is I'm gonna pass to here and this gonna make a lot more sense when I start actually passing from the main loop it's just I always confusing now cuz it's kind of an abstract concept but for each laser that the player has move the laser lasers off the screen remove it if it's not off the screen for each object in the object list if the laser has collided with that object remove it so delete that object otherwise remove the late or not otherwise but remove the laser after that happens as well so that's all we need for player and ship for moving the laser so now what we need to do is for each player will our player and for each ship or each enemy ship we need to move their lasers each loop so for enemy and enemies we also need to call enemy dump move lays right with a velocity which is gonna be the I guess what was the velocity the laser velocity do we have laser velocity as a as a variable we do not so I'm gonna define that and I say laser underscore Val equals four then here we'll do move it by laser underscore bail and check if it's hit the player so we pass the player object there that's the idea behind that then down here we're gonna say player don't move lasers pass in this case the laser Val and the entire list of enemies so self dot enemies so this will now check if the laser has collided with any of the enemies so that's the idea behind this is that what is the move lasers method is doing there's easier ways to do this probably but this is the way that I came up with it that seems to make the most amount of sense so let's run this now and say self is not defined so so this shouldn't be self that I mean I've had this should be enemies long session of recording starting to get tired here so let's run this in check now so if I press space okay so name X is not defined where is that so I've made a mistake somewhere here let's have a look so laser XY self dot laser image okay so that should be eighty three and shoot so I know what the issue is immediately but I'll break it down for you so I made a mistake here in the shoot method by calling XY when really this should be self dot X self dot why won't be surprised we get a few more errors like that so let's run this in press space when I press space nothing's happening aha so I determine the issue so you saw that none of the leases were showing up now there's a few problems I'm gonna go through I want to summarize what we've done so far and then fix this issue so what we just did was create these move lasers and I'm sure I apologize in advance if this was really confusing because I was kind of confusing myself was well I was going through this but the ideas again these are moving the lasers so we call this every loop on all our enemies and on all our players or art player so that they can handle the movement of their own lasers notice that in the draw we're drawing all the laser so this should show up on the screen what we do is inside of cooldown we're making sure we're not shooting too fast and that we have at least a half a second delay before we can shoot that's what this does here we make sure that the cooldown counter is equal to zero then we make a laser and add it to the list if we press space right if we call this method if we shoot so then we set the cooldown counter to 1 the cooldown counter goes through does its loop and then it lets us shoot again once it resets to zero so here this is the move laser for the player this is a little bit different what this is doing is checking if the laser collides with every single enemy which we pass in as OBJ's right if it does we remove that objects remove that enemy and we remove the laser now the issue I was having is this right here if laser offscreen Heights then remove the laser what I did in offscreen was a little bit of a mistake so this actually needs to say not this so what this is telling me here is if this is on the screen that's what this value is so I need to negate that to not to make sure that I actually get what I'm looking for is if this is off the screen I get true and if it's not off the screen I get false whereas before if it was off the screen I was getting false and if it was on the screen I was getting true so just immediately being deleted so let's go ahead and run this now and notice and I'll show you this mistake as well when I press this bullets going backwards now the issue with that and let's just actually just test if this even works so it does if I if the laser hits them it deletes them the reason that's happening is because I haven't made the velocity negative to make it go upwards so what I need to do is here in laser valve for players I need to make that negative the reason for that is I want to make sure that I'm going up not down because if I pass a positive velocity and I add a positive velocity to my bullet or my laser it's gonna go down or it's not upwards so let's negate that or change that to negative and now notice my bullets are going up now if you don't like the speed of these bullets you want to increase them I I agree with you I think they might need to be a little bit faster let's make them 5 like that and we will notice a slightly substantial difference in terms of the speed of these bullets but notice that that collision was working and now all we need to do is make it so that the enemies start shooting at us once the enemy starts shooting at us we'll implement the health bar and then will pretty much be done with with this well we obviously need to do though we have you lost screen actually but we need to add like a little bit of a menu and stuff but we're pretty much almost done once we do that so let's do that now I let's make the enemy start shooting Anna okay so what we need to do now to actually have the enemy shoot a bullet is pick some probability that they're gonna shoot each frame so ideally what we're gonna do is something like if random thought rand range between zero and some number is equal to one then have the enemy shoot so what number do we pick though is the question so let's say you want every second your enemy to have a probability of 50% of shooting so every second you want a 50% chance that your enemies gonna shoot so in theory every two seconds your enemy should shoot a bullet and that's gonna apply to every single enemy well you need to take that probability which is one over two right which would mean you just put two here and multiply it by sixty because you have 60 frames per second so if you want the probability to be that they have a 50% chance of shooting every second then you make this number 120 because 60 times two is equal to that and in fact if you want to keep this easier for yourself you can do something like four multiplied by 60 even though we know that's 240 just so you can change this to have it equate to the amount of seconds before you want the enemy to shoot now you can hard code like every two seconds have the enemy shoot but I just like to have some degree of randomness to make the game a bit more difficult I don't know if this probabilities gonna be too low or too high let's leave it on to for now and just mess with this number and see if it's good or not for you right so now that we have that though let's run this and hopefully our enemy should start shooting once they get on to the screen so let's have a look at this and they do you can see that they're starting to shoot some of them are shooting more frequently than others of course obviously this is rent right now notice that I can run through my enemies so we're gonna fix that so that we can actually if we hit the enemies we lose health but also I can be hit by the bullets or disappearing these things can hit me and you might notice that the bullets are shooting slightly offset from the center of the enemies it's quite easy to fix that you can just subtract Oh fix it for you guys right now you can just subtract the xvalue of where you're gonna start shooting the bullet from so in this case if we go to enemy hmm where are we here and shoot where shoot shoot to mean to find the shoot method if we override the shoot method in enemy so let us take that and move that here what we'll do is we'll just offset where this is being created so I'm overriding this in the enemy I'm gonna say self dot X minus like 10 pixels so now if you look at this it they shouldn't be or they should be shooting more from the middle because we just offset it where the bullets start by 10 pixels so that one clearly didn't do that much for us let's move it over even more let's move it over like 20 pixels and see if that makes a bigger difference let's have a look here waiting for some enemies come on the screen it's wait for this guy to shoot his green bullets so that's slightly to the left that's okay with me I'm fine if they're like that far to the left I want to see these blue guys shooting now though give me the bullet okay so that's fairly in the center so for me that's fine I mean if you wanted to be perfectly centered you have to use a little bit more math there but this is the probability of them shooting I think it might be a little bit too high right now but again we can mess with that number and change it around but now let's do the collision between the spaceship and the other ships and then a health bar a main menu and we're pretty much done so to do the collision between a the player and all the other ships all we have to do inside of here is say if enemy actually sorry if collide enemy and in this case this is gonna be player then we'll just say player dot health minus equals 10 and then remove the enemy so enemies remove and a me like that and me if we spell that correctly okay so let's put that at the top though because we want to make sure we don't remove the enemy before we check that so we'll do that right after the enemy shoots like that and then we'll put this as an L if actually just to make sure that we're not gonna check if you know the enemy is off the screen if it's already collided with the player so that's the idea there we have this random sha we have this collision with the player that will remove the enemy and will reduce ten help from our player now we need to add a health bar which is pretty easy to do actually and then the main menu and we're pretty much done so let's do the health bar to do the health bar what I'm gonna do is just implement a function inside a player so I'm gonna say define health bar like that human takes self and all I'm gonna do in here is draw rectangles that are red and green based on the health of my player so the first rectangle I'm gonna draw is gonna be red it's gonna be the length of my player and then I'm gonna draw a green rectangle that goes on top of that red rectangle but will be only the length of the health right so if it's like say we have 50% health we have 50 out of 100 health it'll be 50 percent of the length of the red rectangle but on top of it so that it shows like half green half rent it's kind of a cool trick I'll show you exactly how that works let me just get this because there is a little bit of an equation that goes into doing this that I had to come up with so here what we're gonna do is gonna say PI game doctor all dot rect we're gonna draw that so we need to draw the health but I guess so it's gonna be a window let's take that on the window rectangle we need a color we're gonna draw a red first to pay five zero zero then we need the rectangle so self dot X self dot Y if I get suppose selftaught y plus self dot image so self that ship image dot get underscore height Y is my typing so horrible today so if that height plus ten let's finish off those brackets there so the idea behind this is that we want to make sure the health bar is below our player so we want to get the Y value of the player add the height of the ship add ten pixels and then start drawing that there and the self dot X can draw where we usually draw the X and that's fine now for the width what we'll do is self thought ship image right dot gets underscore width so it's the same width as the ship and for the height I'll just make it ten pixels and you can make that as much as you want but we'll just do ten now let's copy this and we'll do the exact same thing now in green except just a little bit for the rectangle whip so it's gonna be the exact same stuff except the only thing that's gonna change is the width and the color so zero so red green blue so 0 255 zero and what we need to do now is essentially determine what percentage of the width we should draw so if we want the width to be this or selfthought ship under square image don't get with we're gonna multiply this by some fraction that will essentially tell us how much width we want to put so to do that we're gonna multiply that by 1 in this case max underscore health self dot health and actually think that should be self dot health and then that's gonna be divided by here self dot max health now I think I might have made this math equation way more difficult than it needs to be but let's just think about this for one second so I want to multiply the width by 1 this don't need as many said oh yeah I think these brackets are correct 1 minus the maximum health the self dot health would you'll essentially tell us okay so how much difference is there between the maximum health and the health we have right now and then divide that by the max health to get the percentage health that we're down and we're gonna subtract 1 from that although I think an easier way to do this would just be to multiply by self dot health yeah this is gonna be easier by self dot health over self that max out so I'm glad that I took the initiative to fix that there yeah so this is the image width multiplied by the health over the maximum health which is just telling us what percentage of health were currently at so since we know this is gonna go in increments of negative 10 this is fine to do like we won't get a decimal value here but you know sometimes we might so just keep that in mind but yeah I think that's the equation I think that makes sense hopefully that makes sense to you guys I'm just trying to figure out what percentage of width that we should draw the green rectangle at so that if we lose 10 health that goes down a little bit right and we can do that variably using that kind of equation that I just drew so we have health bars so let's implement that now into the draw method of the player shifts so let's define the draw again so define draw do self.window we're gonna call the super draw method so super dot underscore underscore sorry one peg done it super draw will pass that the window and then we'll just call self dot health bar so self that health bar with the window so I'm just overridden the method from the parent class which is this one here which has the draw I called the parents draw method with the super and then I'm calling the health bar for the window or with the window which now should draw the health bar for me so let's have a look what's the issue here let's see has no attribute get ah so I've added an extra dot accidentally here this should be a get underscore height gets underscore Heights I'm sure most of you probably noticed that so get underscore height let's run this now what's the issue here I made another mistake rect argument is invalid I think I forgot to add the 10 yes I did so multiplied there let's see if this is the correct bracket yeah so I think I'm just messing up a bracket here I think that goes there and I think now we should be good no we're not let's see what's going on with the brackets here give me one sec guys okay so I did fix it yeah issue as I just had all these brackets messed up in here I just need to add two at the end there the code will be in the description if you guys are getting confused with what I'm doing because we're here well you can see when we load in the health bar is off the screen we can fix that if we want quite easily in fact let's actually do that now just before we forget go down to where we're allowed to sponsor first of all where we spawn the person in and make it so he spawns at sixthirty and let's just add 10 pixels to where this guy can move so if we go player get height plus 10 this is just to make sure that the health bar will be able to be shown if we add 10 pixels there will insure the health bar will be shown up so let's do that now we can see the health bar shows up in fact it cuts off a little bit so let's make this 15 pixels and now let's run this and we can see that the health bar will stay perfectly on the screen so there we go the health bars on the screen let's watch what happens if we one of these guys you can see the health bar does decrement it goes down and that is a strategy I guess in this game if you want to waste your health and hit one of the things to like sacrifice yourself for that you can do that so yeah that's uh that's how the health bar works so I guess now all this really left to do is the the main menu so let's go ahead and do that okay so main menu what we want to do essentially is just habit so it says like press any key to begin and when you press that key you can begin and that way if you die it'll bring you back to the main menu and you can choose when you want to start playing again I'll do the nap though the main functionality of this game is pretty much done so let's implement a main menu so let's define main underscore menu this is gonna be quite simple I'll go fairly fast we're gonna say run equals true while run try to say for event in PI game dot event get if vent dot type equals equals PI game so I quit like that then we will say is run equals false okay and then in here we're gonna say just draw this on the screen and actually sorry I need today if event type equals equals PI game stop mouse button down colon me so what this is saying is if we press any of the mouse buttons enter this main loop and start playing the game if we press the X button set run equal false we're gonna quit here so let's say hi game talk quit like that in fact we can actually just use the quit method it's up to you whatever method you'd like to use but this is saying if we press any mouse button call the main function if we press quit quit but what I want to do is just draw like some text that says press any key to begin or press you know the mouse button to start something like that so the first thing we'll do is also say win top lit BG notice I'm just doing it in line here because it's just gonna be short for the main menu so we'll blit the background will say pi game dot display dot updates and then we'll create a font up here so we'll say title underscore font go spy game it's off font dot sys font Comic Sans let's do size 7d and then we'll render something onto the screens will say title label equals title font dot render press the mouse to begin dot dot try to that one let's render that white so two five two five two three five and then let's say win da blitz title label let's split this in the middle of the screen we remember that shortcut I showed us so that's width / 2 title label dot get underscore width / that'll put that in the middle and then here for the Y let's put that at 350 and then that should be good so now that we have that what this loop will do so rather than calling main we need to call main underscore menu and let's have a look at how this works so we're getting an error it's funny enough + 15 s so I've accidentally pressed s that's what happens when I try to save too frequently apparently what's the issue now tie game duck quit mean menu let's have a look here PI game duck quits inconsistent use of tabs and spaces love when I get that issue so for me to fix that I usually just do this converting donación to spaces so that should work now and let's run this win is not defined so win needs to be capital that's let's run this and there we go okay so I'll go through this in a second I'll summarize I just want to show you now it says press the mouse key to begin if we exit out so press the mouse button to begin if I hit X it brings me back here I'll show you how to fix that if you don't want that to be the case but when I press the mouse the game begins we can start playing and you know when we exit it'll reset like it should normally do so that's how that works if we want to fix it so when we press the X it doesn't bring us back to the main menu what we can do is just in so saying run equals false in here we can do quit what that's gonna do is quit the entire Python program which will just end this whole thing for us if we press the X so that's the idea now main manual summarize quickly what I did here literally just setup the exact same thing that we had before except for a main menu so I made a main loop with a run equals treat variable I defined a font I said in here we'll draw what's gonna be on the screen for the main menu which is just these two things right so the label and the background then I'll do an event lupus okay so for each event notice I didn't put a clock in here because I don't care about the clock speed for the main menu that that's irrelevant we're not moving anything around that's fine so I don't need a clock so we just have an event loop you press quit it and it ends the game and if you press the mouse button down it starts the game and it will always bring you back to this main menu function because since we call main here without setting run equal to false when main exits right when main is done we exit out of this while loop here we go back into main menu and wait until we hit the X button to stop playing the game so that's the idea behind this and that is pretty much this game okay so we ran into an issue here at least our remove X X is not in the list so let's just fix that here so 111 in move lasers so we ran into a quick bug let's try to find that 111 111 in removed laser if laser doc collision object objects are removed obj selftaught lasers don't remove laser so I guess what we should do is make sure this laser is in the list before we remove it because I guess it could have been removed in a different situation so in that case we'll just say if self dot laser I guess we'll say if laser in self thought lasers then we'll remove it otherwise we won't so this is the fix here just to make sure that if this laser is in the list but you can remove it otherwise we will not so let's run this and see now cuz I hit something and I ran to that bug so I want to make sure that we don't get that again okay so that seems to be working you know one thing to note is if you hit a if you hit something and has a laser shooting that laser will disappear just because we delete the object itself there's not really an easy way to fix that the way that we've implemented it I don't think is a huge deal I think that's part of the strategy the game is like if you want to remove someone's laser go in and shoot them like I think that is a decent strategy or that's something that can be incorporated and yeah that is pretty much it for this tutorial so again I hope you guys enjoyed if you did make sure you leave a like go subscribe to my podcast YouTube channel time out with ten that would really mean the world to me if you guys did that and of course although code everything isn't available in the description and if you need help let me know in the comments down below
