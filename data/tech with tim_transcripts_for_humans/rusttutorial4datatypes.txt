With timestamps:

00:02 - [Music]
00:08 - hello everybody and welcome to video 4
00:11 - in this ros programming tutorial series
00:14 - in this video i'll be going over data
00:16 - types specifically the primitive data
00:18 - types in rust there's a lot more data
00:20 - types that i need to cover but i'm going
00:21 - to get to those in later videos for now
00:23 - we're going to look at the most basic
00:25 - ones which are known as primitive now
00:27 - before we dive in i will mention again i
00:29 - do have a programming course programming
00:30 - expert dot io check it out from the link
00:32 - in the description if you want to learn
00:34 - software engineering tools software
00:35 - design you want to learn how to
00:36 - programming go and python and have a ton
00:39 - of interactive practice questions
00:41 - assessments and projects to work on
00:43 - thank you guys very much if you do
00:44 - decide to purchase that course again
00:45 - link in the description with that said
00:47 - though let's get into this content so
00:50 - data types as i was saying we have
00:52 - primitive data types now these are the
00:53 - most basic data types we can kind of use
00:56 - them without having to do anything
00:57 - special and that's really what the
00:59 - primitive data types are just the most
01:00 - basic ones in a language so that's what
01:02 - we're going to look at here now rust has
01:04 - two categories of primitive data types
01:07 - we have a scalar type and then we have a
01:09 - compound or the types kind of fall into
01:11 - the categories of scalar and compound
01:13 - now scalar simply means a single value
01:16 - so something like an integer something
01:17 - like a boolean if you're familiar with
01:19 - data types whereas compound means
01:21 - multiple values so here we actually have
01:23 - an array and we have a tuple which we're
01:25 - going to look at in a minute for now
01:27 - though let's look at the scalar data
01:29 - types and how we use those in rus so as
01:32 - we know russ is a statically typed
01:33 - language that means it's very important
01:35 - for us to understand what type our
01:36 - variables are and we can implicitly have
01:38 - the type decided or we can explicitly
01:41 - define it when we declare a variable so
01:42 - if i do something like let x equals 2
01:45 - implicitly the compiler is going to say
01:47 - this is an integer
01:49 - however i can explicitly define the type
01:51 - by doing something like colon and then
01:53 - i32
01:54 - and what this means is that i am
01:56 - assigning the type of integer 32 to the
01:59 - variable x then i'm storing the value 2
02:01 - as this type i 32. so this is the first
02:04 - type right integer this stands for a
02:06 - signed integer that's using 32 bits to
02:09 - represent and store the number now the
02:11 - number of bits essentially tells you how
02:13 - large of a number you can store and the
02:15 - range of numbers that can be stored in a
02:17 - variable i'm not really going to get too
02:19 - much into binary here because that's
02:20 - beyond the scope of what i'm uh meaning
02:23 - to teach but 32 is actually the default
02:25 - value for an integer in rust so what i
02:28 - mean by that is if i do something like
02:29 - let x equals two by default the type of
02:32 - this variable is going to be i32 because
02:35 - this is an integer value and we could
02:37 - assign it to many different types but we
02:39 - default it to i32 okay so let's keep
02:41 - looking at integers
02:43 - so as you saw we had i32 this is the
02:45 - default but we also have multiple other
02:47 - types of integers
02:49 - we have i8 we have i 16
02:52 - like this i believe we have i 64 and i
02:54 - think we even have all the way up to i
02:56 - 128 now again these are the number of
02:58 - bits that's going to be used for all of
03:00 - these integers and in case you're
03:01 - unfamiliar with an integer this is any
03:03 - number that does not contain a decimal
03:05 - part so any whole number essentially
03:07 - something like eight something like
03:09 - negative nine something like
03:11 - 9727 negative ah that's totally fine and
03:14 - since we have a signed integer that's
03:16 - just what the default integer is that
03:18 - means we can use a negative sign for our
03:20 - value okay so those are the different
03:22 - types for our integers we then have the
03:24 - data type of uint now uint is unsigned
03:27 - integer and it's exactly the same as
03:29 - integer except you can't use negatives
03:31 - so if i do something like let x and then
03:33 - this is u32 i'm saying that i'm going to
03:36 - assign this variable the type of
03:38 - unsigned integer 32 and then give it the
03:41 - value of 972. now i can't assign
03:44 - anything to this variable that has a
03:46 - sign to it like i can't have a negative
03:48 - number here because this is an unsigned
03:50 - integer using 32 bits to store the
03:52 - number now i don't want to get too much
03:54 - into binary here in the different ranges
03:56 - and all of that but i'll just quickly
03:57 - mention that when we're looking at
03:58 - something like a u32 versus an i32 or we
04:01 - could even go even simpler with
04:02 - something like u8 and i8 these are able
04:05 - to represent the exact same number of
04:07 - unique values so using eight bits you're
04:09 - always able to represent two to the
04:11 - exponent eight unique values however the
04:14 - range of values that you can represent
04:16 - is different when you're using a u8
04:18 - versus an i8 for example with an
04:20 - unsigned integer you don't have to
04:21 - represent any negative numbers so the
04:23 - range of numbers you can represent is 0
04:25 - to 2 to the exponent eight minus one
04:28 - because you have eight bits you put
04:30 - eight here for the exponent and this is
04:32 - the range you can represent i believe
04:34 - from zero to uh this is going to be i
04:36 - think
04:37 - 128 or it's going to be oh sorry 255 my
04:40 - apology 0 to 255 that's the range of
04:43 - numbers you can represent with a u8
04:45 - however with an i8 this is going to
04:47 - change now you're going to be a negative
04:49 - to the exponent and then this is going
04:51 - to be 7 you have to reduce the exponent
04:53 - by 1 2 two to the exponent seven minus
04:57 - one so with i eight you're gonna have a
04:59 - range of negative 128 to 127 in terms of
05:04 - the numbers you can actually represent
05:06 - whereas this is going to be zero to
05:08 - 255
05:10 - hopefully that makes sense uh if it
05:12 - doesn't then i'd say refresh yourself on
05:14 - binary a little bit but i just wanted to
05:16 - quickly mention that okay so we've
05:17 - looked at signed integers and unsigned
05:19 - integers and the different quantities of
05:21 - course with u32 we have u64 uh with a
05:25 - lowercase and we'd have u 128
05:29 - as well if i spell that correctly okay
05:31 - so that is it for integers next we're
05:33 - going to look at floating point values
05:35 - so in rust we have two floating data
05:38 - types we have f32 and f64 and this means
05:42 - we're going to have a floating point
05:43 - value using 32 bits and we're going to
05:46 - have a floating point value using 64
05:48 - bits this is also known as single
05:50 - precision and double precision so let's
05:52 - have a look at one of those values we
05:53 - could do something like let let's go
05:55 - floating
05:57 - point and then we'll say the type of
05:58 - this is going to be f32 and this could
06:00 - be equal to something like 10.9 so as
06:03 - soon as we have this decimal component
06:05 - here now we know we're having a floating
06:07 - point value and we need to use the f32
06:09 - or 64 type now the default type if you
06:13 - don't actually explicitly define it is
06:15 - going to be f32 using single precision
06:18 - okay
06:19 - all right so i think that's really it
06:20 - for floats um those are the types f32
06:23 - f64 if you're not sure just use f32 now
06:26 - we can move on to booleans now a boolean
06:29 - is simply a true or false value or a
06:31 - zero or one value so for a boolean we
06:34 - could do something like let
06:36 - true
06:37 - or false equal and then this can be
06:40 - false notice we have it with lower cases
06:42 - there's no capital on the first letter
06:44 - like in python and this type here is
06:46 - simply the bool type now we also could
06:48 - make this a true
06:50 - but these are the two values this could
06:52 - store true or false now false is also
06:54 - represented by zero and true is
06:56 - represented by one sometimes you may see
06:58 - that so you can also use zero and one
07:00 - here again zero for false one for true
07:02 - okay so that is the bull type not much
07:04 - more to talk about there and lastly we
07:06 - have the char type or the character type
07:09 - for our scalar
07:10 - uh primitive data types so a character
07:14 - is gonna be something like this let's
07:15 - say let letter
07:16 - the type is going to be char not
07:18 - character just char and then we're going
07:20 - to use single quotation marks here
07:22 - and we can put any character on our
07:24 - keyboard so char just stores a single
07:26 - character we have eight uh we could do
07:29 - sorry not eight we have a we could do
07:30 - eight we could do nine we could do a
07:32 - bracket uh really any character you can
07:34 - represent as long as you're using single
07:36 - quotation marks okay so those are our
07:38 - four primitive data types again we have
07:40 - int and uh i'm kind of counting those as
07:42 - one unsigned integer and signed integer
07:44 - we have our floating point values with
07:46 - f32 or f64 we have our boolean values
07:50 - using bool and that's going to be true
07:51 - or false and then we have our characters
07:53 - using the char keyword and again you
07:55 - don't need to manually define any of
07:57 - these if you don't want to they will
07:58 - implicitly uh be set when the compiler
08:01 - is running through this cut
08:02 - okay so that's it for our scalar types
08:05 - now let's look at our compound types and
08:07 - then we can just i guess print a few
08:09 - things out and do some examples here
08:10 - with the types to make it a bit more
08:12 - clear okay so for our compound types we
08:14 - have a tuple i believe it's called tuple
08:16 - not tuple some people i think say like
08:18 - tuple or some weird pronunciation for it
08:21 - but it's called tuple spelt like this
08:23 - and we also have an array okay so a
08:26 - tuple is going to be a fixed length
08:29 - sequence of elements that is immutable
08:31 - so to create a tuple i'm going to do the
08:32 - following i'm going to say lattup
08:34 - standing for tuple and then i can make
08:36 - this equal to my parentheses here and
08:38 - inside of the parentheses i can put
08:40 - whatever values i want so i can do
08:42 - something like one true and then maybe
08:44 - put a character in here like s
08:46 - now the type of this tuple implicitly is
08:49 - actually gonna be what i'm gonna write
08:51 - out here which is
08:53 - an i 32
08:55 - a boolean and then a chart so that's
08:58 - actually what the type of this tuple
08:59 - would be now the tuple really is defined
09:02 - by what values it's storing so this is
09:04 - actually the type right this is not a
09:06 - tuple it is a tuple that has an i-32 a
09:09 - boolean and a char as the three values
09:11 - that's the specific type of this tuple
09:13 - if i make another tuple here so i do
09:15 - something like let top two and then i
09:17 - change this to something like i8 these
09:19 - are different types these tuples are not
09:21 - the same type i could not assign this to
09:23 - this tuple here that would not work
09:25 - because these are different types right
09:27 - this is an i8 as opposed to an i32 so
09:30 - just keep that in mind i know a lot of
09:31 - people get confused with this but the
09:33 - actual type
09:34 - is reliant on what elements are being
09:36 - stored inside of the tuple it's very
09:38 - specific okay so that is the basics on a
09:40 - tuple now tuples are immutable just like
09:42 - all our other variables by default you
09:44 - can of course use the mutt keyword if
09:47 - you want to make them mutable but let me
09:49 - show you how we access specific elements
09:51 - from our tuple so what i can do here is
09:54 - something like println exclamation point
09:56 - and if i try to just print out my tuple
09:58 - here you'll see that i get an error so
10:00 - let me go here and
10:02 - let's go back here and run this uh and
10:05 - notice that i get some problem let me
10:06 - make this a bit larger it's saying that
10:09 - uh print ln okay expected semicolon
10:12 - sorry let me add the semicolon first
10:13 - just so that we're not distracted by
10:15 - that error we'll rerun and we still get
10:18 - an error here and it is saying
10:20 - that uh we cannot format this with the
10:22 - default formatter so it's not possible
10:24 - to take this type here and format that
10:26 - using this so instead we'll just print
10:28 - out individual elements so to do that i
10:31 - can do something like tup dot and then
10:33 - i'm actually going to use the index of
10:35 - the element that i want to reference so
10:36 - if i wanted to reference the first
10:38 - element here i would use zero i know
10:40 - this looks a bit weird but top dot zero
10:42 - that's going to get me one if i wanted
10:43 - the second element i would do one if i
10:45 - wanted the last element i would do two
10:47 - the indices are just numbers
10:49 - representing each of our elements right
10:51 - so the first one is going to be zero
10:52 - second one one and then the last one two
10:55 - okay but if i do tup two here we should
10:56 - see that we get s printing out so let's
10:58 - clear and run
11:00 - and notice that we get s printed out to
11:02 - the screen if i do top of one we should
11:04 - get true so let's have a look at this
11:06 - here
11:07 - and notice that i get
11:08 - okay so there you go that is how you
11:10 - access the individual elements now
11:12 - continuing with tuples here let's have a
11:14 - look at how we can maybe mutate the
11:15 - tuple so let's change this to be mutable
11:18 - and now let's do something like this and
11:20 - actually just test if this works so top
11:22 - 0 is equal to and let's make this equal
11:25 - to 10 and let's print out top 0.
11:27 - okay so take a guess at what you think
11:29 - we're going to get here let's run the
11:31 - program and okay it keeps getting mad at
11:33 - me for the semicolons i keep forgetting
11:34 - those let's run this again and let's see
11:38 - and notice that i get 10 so i actually
11:40 - am able to modify using the indices when
11:43 - i add this mutable keyword however if i
11:45 - remove the mutt keyword and i go here
11:48 - and rerun notice that i get a problem
11:50 - it's saying cannot assign because this
11:52 - is not mutable so using the individual
11:54 - indexes we can assign to the value in
11:56 - the tuple and then if i make this
11:58 - mutable we should actually be able to
12:00 - change the tuple entirely as well so i
12:02 - can do something like top and i can
12:04 - change this to maybe 10
12:06 - false and then let's just go with a
12:09 - okay and let's run this
12:12 - and let's see what we get and notice
12:13 - that we get 10 and that is fine although
12:16 - it's giving us some warning here saying
12:18 - uh on by default
12:21 - what is it variable assigned to top is
12:22 - never read okay so it's saying there's
12:24 - no point in us writing this kind of like
12:26 - the warnings we were getting in the
12:27 - previous video okay so that's pretty
12:28 - much it for tuples there's some more i
12:30 - could show you but i think that's fine
12:31 - for right now uh one thing to note is
12:33 - that i can't add elements to the tuple
12:35 - right so if i try to do something like
12:37 - add a 10 here
12:38 - this isn't going to work i'm going to
12:39 - get an error because i'm trying to
12:41 - change the type of the tuple and i can't
12:43 - do that because the type only contains
12:45 - three elements so i can't add four okay
12:47 - that's it for that though let's quickly
12:48 - move on to arrays and then i'll wrap up
12:51 - the video by mentioning strings to you
12:53 - and then we'll move on to user input in
12:54 - the next one so to create an array i'll
12:56 - do something like let arr and then this
12:58 - can be equal to something like one two
13:00 - three four five now arrays have to have
13:02 - the same element inside of them so in
13:04 - this case they're all going to be into
13:06 - 32 by default and if i want to get index
13:09 - access here i can do this similarly to
13:11 - the tuples but this time we're going to
13:12 - use square brackets and i could do
13:14 - something like ar 0. that would
13:16 - reference 1. if i do a r4 that would
13:18 - reference 5 so on and so forth now just
13:21 - like our tuples an arrays type is
13:23 - defined by the type of elements as well
13:25 - as the number of elements in the array
13:27 - so unlike other languages i can't
13:29 - actually add elements into this array i
13:32 - would need to make a new array with a
13:34 - new type uh that has more kind of
13:36 - allocation or more space for different
13:38 - elements here i'm only able to have five
13:41 - elements in this array and they all have
13:42 - to be of the type int 32. now let's see
13:46 - if i can change this doing something ar4
13:48 - is equal to three and then we might as
13:50 - well print this out so print line
13:53 - and we'll do our formatter here and then
13:56 - arr at four
13:57 - let's give this a test so clear
14:00 - and run and notice we get a problem here
14:02 - it says we cannot assign because this is
14:04 - not mutable so just like the top line we
14:06 - need to change this to be mutable
14:08 - now if i go back here and run this
14:10 - everything is fine and we're printing
14:11 - out three because we assign that to the
14:13 - last element now let's have a look at
14:15 - how we explicitly define the type to do
14:18 - that here with our array we would go
14:19 - colon and then the type is going to be
14:21 - square brackets the type in your array
14:23 - so in this case i32 and then a semicolon
14:26 - followed by the number of elements
14:28 - exactly that you have in your array so
14:30 - in this case we have five so if i run
14:32 - this now
14:33 - let's go here and run and notice that it
14:35 - works fine uh we get what we need now
14:38 - let's just have a look at what happens
14:39 - here if we do something like this so we
14:41 - define an array without actually
14:43 - initializing the values so we're saying
14:45 - the type is i32 we're going to have
14:47 - exactly five elements let's see what
14:49 - happens if we try to access the last
14:50 - element here by running this and notice
14:53 - we get a problem here it says use of
14:54 - possibly uninitialized arr so unlike in
14:57 - other languages where you just get
14:58 - values automatically initialized in your
15:00 - array that does not occur here you do
15:02 - need to manually initialize it and if i
15:04 - try to do something like make this equal
15:06 - to an empty array we should get another
15:08 - compile time error here
15:10 - saying that we can't assign an empty
15:12 - array to an array of type i32 with five
15:14 - elements okay i know i went through a
15:17 - lot here this video was actually a lot
15:18 - longer than i was expecting it to be but
15:20 - i wanted to thoroughly walk you through
15:22 - all of the different data types here the
15:23 - primitive data types and show you how
15:25 - they work in rust hopefully this gave
15:27 - you a general idea of what these data
15:29 - types are how to use them what values
15:31 - correspond with which data types i did
15:33 - spend a lot of time again because this
15:35 - is very important you need to understand
15:36 - the types before we move any further now
15:39 - i will quickly show you that you have to
15:40 - be careful here with your types so if i
15:42 - do something like let x and i make this
15:44 - u8 and this is equal to a four
15:47 - let's see what happens if i try to say
15:49 - let y uh equal x
15:51 - okay so let's just see what happens if i
15:53 - go print ln exclamation point uh and we
15:56 - print out
15:58 - and we'll just print out y i'll also
16:00 - note you can print out multiple values
16:01 - so i could actually do something like x
16:03 - comma y uh and of course x will line up
16:05 - with that y will line up with that
16:07 - okay so let's go here
16:09 - let's clear and let's run and notice
16:11 - this is all fine now i'm going to ask
16:13 - you what is the type of y well some of
16:15 - you may say the type is u32 or i32 but
16:19 - actually the type of y is u8 and to
16:22 - prove that to you if i change this to be
16:24 - something like i32 which is the default
16:26 - you'll see that we get an error here
16:28 - when i run the code and the reason we
16:30 - get an error is because we cannot
16:32 - convert this u n data type here to an
16:35 - i32 or the uint8 type just isn't i32 so
16:39 - i'm saying this variable is of type i32
16:41 - and i'm assigning a u8 type to this
16:44 - variable
16:45 - however if i actually put a 4 here
16:47 - explicitly you'll see that i don't get
16:49 - any problem because 4 can be treated as
16:52 - an i32 but i can't use
16:54 - x which is of type u8 so you have to be
16:57 - careful with how that works you'll learn
16:59 - more as we go through and see kind of
17:00 - the features of a statically typed
17:02 - language but i wanted to quickly show
17:03 - that to you so with that said i will
17:05 - wrap up the video here i hope you
17:07 - enjoyed if you did make sure you like
17:08 - subscribe to the channel and i will see
17:10 - you in another one
17:13 - [Music]
17:19 - you

Cleaned transcript:

hello everybody and welcome to video 4 in this ros programming tutorial series in this video i'll be going over data types specifically the primitive data types in rust there's a lot more data types that i need to cover but i'm going to get to those in later videos for now we're going to look at the most basic ones which are known as primitive now before we dive in i will mention again i do have a programming course programming expert dot io check it out from the link in the description if you want to learn software engineering tools software design you want to learn how to programming go and python and have a ton of interactive practice questions assessments and projects to work on thank you guys very much if you do decide to purchase that course again link in the description with that said though let's get into this content so data types as i was saying we have primitive data types now these are the most basic data types we can kind of use them without having to do anything special and that's really what the primitive data types are just the most basic ones in a language so that's what we're going to look at here now rust has two categories of primitive data types we have a scalar type and then we have a compound or the types kind of fall into the categories of scalar and compound now scalar simply means a single value so something like an integer something like a boolean if you're familiar with data types whereas compound means multiple values so here we actually have an array and we have a tuple which we're going to look at in a minute for now though let's look at the scalar data types and how we use those in rus so as we know russ is a statically typed language that means it's very important for us to understand what type our variables are and we can implicitly have the type decided or we can explicitly define it when we declare a variable so if i do something like let x equals 2 implicitly the compiler is going to say this is an integer however i can explicitly define the type by doing something like colon and then i32 and what this means is that i am assigning the type of integer 32 to the variable x then i'm storing the value 2 as this type i 32. so this is the first type right integer this stands for a signed integer that's using 32 bits to represent and store the number now the number of bits essentially tells you how large of a number you can store and the range of numbers that can be stored in a variable i'm not really going to get too much into binary here because that's beyond the scope of what i'm uh meaning to teach but 32 is actually the default value for an integer in rust so what i mean by that is if i do something like let x equals two by default the type of this variable is going to be i32 because this is an integer value and we could assign it to many different types but we default it to i32 okay so let's keep looking at integers so as you saw we had i32 this is the default but we also have multiple other types of integers we have i8 we have i 16 like this i believe we have i 64 and i think we even have all the way up to i 128 now again these are the number of bits that's going to be used for all of these integers and in case you're unfamiliar with an integer this is any number that does not contain a decimal part so any whole number essentially something like eight something like negative nine something like 9727 negative ah that's totally fine and since we have a signed integer that's just what the default integer is that means we can use a negative sign for our value okay so those are the different types for our integers we then have the data type of uint now uint is unsigned integer and it's exactly the same as integer except you can't use negatives so if i do something like let x and then this is u32 i'm saying that i'm going to assign this variable the type of unsigned integer 32 and then give it the value of 972. now i can't assign anything to this variable that has a sign to it like i can't have a negative number here because this is an unsigned integer using 32 bits to store the number now i don't want to get too much into binary here in the different ranges and all of that but i'll just quickly mention that when we're looking at something like a u32 versus an i32 or we could even go even simpler with something like u8 and i8 these are able to represent the exact same number of unique values so using eight bits you're always able to represent two to the exponent eight unique values however the range of values that you can represent is different when you're using a u8 versus an i8 for example with an unsigned integer you don't have to represent any negative numbers so the range of numbers you can represent is 0 to 2 to the exponent eight minus one because you have eight bits you put eight here for the exponent and this is the range you can represent i believe from zero to uh this is going to be i think 128 or it's going to be oh sorry 255 my apology 0 to 255 that's the range of numbers you can represent with a u8 however with an i8 this is going to change now you're going to be a negative to the exponent and then this is going to be 7 you have to reduce the exponent by 1 2 two to the exponent seven minus one so with i eight you're gonna have a range of negative 128 to 127 in terms of the numbers you can actually represent whereas this is going to be zero to 255 hopefully that makes sense uh if it doesn't then i'd say refresh yourself on binary a little bit but i just wanted to quickly mention that okay so we've looked at signed integers and unsigned integers and the different quantities of course with u32 we have u64 uh with a lowercase and we'd have u 128 as well if i spell that correctly okay so that is it for integers next we're going to look at floating point values so in rust we have two floating data types we have f32 and f64 and this means we're going to have a floating point value using 32 bits and we're going to have a floating point value using 64 bits this is also known as single precision and double precision so let's have a look at one of those values we could do something like let let's go floating point and then we'll say the type of this is going to be f32 and this could be equal to something like 10.9 so as soon as we have this decimal component here now we know we're having a floating point value and we need to use the f32 or 64 type now the default type if you don't actually explicitly define it is going to be f32 using single precision okay all right so i think that's really it for floats um those are the types f32 f64 if you're not sure just use f32 now we can move on to booleans now a boolean is simply a true or false value or a zero or one value so for a boolean we could do something like let true or false equal and then this can be false notice we have it with lower cases there's no capital on the first letter like in python and this type here is simply the bool type now we also could make this a true but these are the two values this could store true or false now false is also represented by zero and true is represented by one sometimes you may see that so you can also use zero and one here again zero for false one for true okay so that is the bull type not much more to talk about there and lastly we have the char type or the character type for our scalar uh primitive data types so a character is gonna be something like this let's say let letter the type is going to be char not character just char and then we're going to use single quotation marks here and we can put any character on our keyboard so char just stores a single character we have eight uh we could do sorry not eight we have a we could do eight we could do nine we could do a bracket uh really any character you can represent as long as you're using single quotation marks okay so those are our four primitive data types again we have int and uh i'm kind of counting those as one unsigned integer and signed integer we have our floating point values with f32 or f64 we have our boolean values using bool and that's going to be true or false and then we have our characters using the char keyword and again you don't need to manually define any of these if you don't want to they will implicitly uh be set when the compiler is running through this cut okay so that's it for our scalar types now let's look at our compound types and then we can just i guess print a few things out and do some examples here with the types to make it a bit more clear okay so for our compound types we have a tuple i believe it's called tuple not tuple some people i think say like tuple or some weird pronunciation for it but it's called tuple spelt like this and we also have an array okay so a tuple is going to be a fixed length sequence of elements that is immutable so to create a tuple i'm going to do the following i'm going to say lattup standing for tuple and then i can make this equal to my parentheses here and inside of the parentheses i can put whatever values i want so i can do something like one true and then maybe put a character in here like s now the type of this tuple implicitly is actually gonna be what i'm gonna write out here which is an i 32 a boolean and then a chart so that's actually what the type of this tuple would be now the tuple really is defined by what values it's storing so this is actually the type right this is not a tuple it is a tuple that has an i32 a boolean and a char as the three values that's the specific type of this tuple if i make another tuple here so i do something like let top two and then i change this to something like i8 these are different types these tuples are not the same type i could not assign this to this tuple here that would not work because these are different types right this is an i8 as opposed to an i32 so just keep that in mind i know a lot of people get confused with this but the actual type is reliant on what elements are being stored inside of the tuple it's very specific okay so that is the basics on a tuple now tuples are immutable just like all our other variables by default you can of course use the mutt keyword if you want to make them mutable but let me show you how we access specific elements from our tuple so what i can do here is something like println exclamation point and if i try to just print out my tuple here you'll see that i get an error so let me go here and let's go back here and run this uh and notice that i get some problem let me make this a bit larger it's saying that uh print ln okay expected semicolon sorry let me add the semicolon first just so that we're not distracted by that error we'll rerun and we still get an error here and it is saying that uh we cannot format this with the default formatter so it's not possible to take this type here and format that using this so instead we'll just print out individual elements so to do that i can do something like tup dot and then i'm actually going to use the index of the element that i want to reference so if i wanted to reference the first element here i would use zero i know this looks a bit weird but top dot zero that's going to get me one if i wanted the second element i would do one if i wanted the last element i would do two the indices are just numbers representing each of our elements right so the first one is going to be zero second one one and then the last one two okay but if i do tup two here we should see that we get s printing out so let's clear and run and notice that we get s printed out to the screen if i do top of one we should get true so let's have a look at this here and notice that i get okay so there you go that is how you access the individual elements now continuing with tuples here let's have a look at how we can maybe mutate the tuple so let's change this to be mutable and now let's do something like this and actually just test if this works so top 0 is equal to and let's make this equal to 10 and let's print out top 0. okay so take a guess at what you think we're going to get here let's run the program and okay it keeps getting mad at me for the semicolons i keep forgetting those let's run this again and let's see and notice that i get 10 so i actually am able to modify using the indices when i add this mutable keyword however if i remove the mutt keyword and i go here and rerun notice that i get a problem it's saying cannot assign because this is not mutable so using the individual indexes we can assign to the value in the tuple and then if i make this mutable we should actually be able to change the tuple entirely as well so i can do something like top and i can change this to maybe 10 false and then let's just go with a okay and let's run this and let's see what we get and notice that we get 10 and that is fine although it's giving us some warning here saying uh on by default what is it variable assigned to top is never read okay so it's saying there's no point in us writing this kind of like the warnings we were getting in the previous video okay so that's pretty much it for tuples there's some more i could show you but i think that's fine for right now uh one thing to note is that i can't add elements to the tuple right so if i try to do something like add a 10 here this isn't going to work i'm going to get an error because i'm trying to change the type of the tuple and i can't do that because the type only contains three elements so i can't add four okay that's it for that though let's quickly move on to arrays and then i'll wrap up the video by mentioning strings to you and then we'll move on to user input in the next one so to create an array i'll do something like let arr and then this can be equal to something like one two three four five now arrays have to have the same element inside of them so in this case they're all going to be into 32 by default and if i want to get index access here i can do this similarly to the tuples but this time we're going to use square brackets and i could do something like ar 0. that would reference 1. if i do a r4 that would reference 5 so on and so forth now just like our tuples an arrays type is defined by the type of elements as well as the number of elements in the array so unlike other languages i can't actually add elements into this array i would need to make a new array with a new type uh that has more kind of allocation or more space for different elements here i'm only able to have five elements in this array and they all have to be of the type int 32. now let's see if i can change this doing something ar4 is equal to three and then we might as well print this out so print line and we'll do our formatter here and then arr at four let's give this a test so clear and run and notice we get a problem here it says we cannot assign because this is not mutable so just like the top line we need to change this to be mutable now if i go back here and run this everything is fine and we're printing out three because we assign that to the last element now let's have a look at how we explicitly define the type to do that here with our array we would go colon and then the type is going to be square brackets the type in your array so in this case i32 and then a semicolon followed by the number of elements exactly that you have in your array so in this case we have five so if i run this now let's go here and run and notice that it works fine uh we get what we need now let's just have a look at what happens here if we do something like this so we define an array without actually initializing the values so we're saying the type is i32 we're going to have exactly five elements let's see what happens if we try to access the last element here by running this and notice we get a problem here it says use of possibly uninitialized arr so unlike in other languages where you just get values automatically initialized in your array that does not occur here you do need to manually initialize it and if i try to do something like make this equal to an empty array we should get another compile time error here saying that we can't assign an empty array to an array of type i32 with five elements okay i know i went through a lot here this video was actually a lot longer than i was expecting it to be but i wanted to thoroughly walk you through all of the different data types here the primitive data types and show you how they work in rust hopefully this gave you a general idea of what these data types are how to use them what values correspond with which data types i did spend a lot of time again because this is very important you need to understand the types before we move any further now i will quickly show you that you have to be careful here with your types so if i do something like let x and i make this u8 and this is equal to a four let's see what happens if i try to say let y uh equal x okay so let's just see what happens if i go print ln exclamation point uh and we print out and we'll just print out y i'll also note you can print out multiple values so i could actually do something like x comma y uh and of course x will line up with that y will line up with that okay so let's go here let's clear and let's run and notice this is all fine now i'm going to ask you what is the type of y well some of you may say the type is u32 or i32 but actually the type of y is u8 and to prove that to you if i change this to be something like i32 which is the default you'll see that we get an error here when i run the code and the reason we get an error is because we cannot convert this u n data type here to an i32 or the uint8 type just isn't i32 so i'm saying this variable is of type i32 and i'm assigning a u8 type to this variable however if i actually put a 4 here explicitly you'll see that i don't get any problem because 4 can be treated as an i32 but i can't use x which is of type u8 so you have to be careful with how that works you'll learn more as we go through and see kind of the features of a statically typed language but i wanted to quickly show that to you so with that said i will wrap up the video here i hope you enjoyed if you did make sure you like subscribe to the channel and i will see you in another one you
