With timestamps:

00:00 - hello everybody and welcome to another
00:02 - Python tutorial where I'll be showing
00:04 - you how to build the game of 2048 in
00:07 - Python now this game was one of my
00:08 - favorite games as a kid and it's
00:10 - actually very interesting to code out I
00:12 - won't lie to you it is a little bit
00:14 - complex but I think that's what we
00:16 - actually make a great video I'll teach
00:18 - you some more advanced python techniques
00:20 - and how you can actually structure a
00:22 - game like this so we'll go through all
00:24 - of the steps coding out the grid
00:26 - combining the tiles Etc and by the end
00:28 - of this video you'll have a fully
00:30 - finished game and you will have learned
00:32 - quite a few python features last thing
00:34 - to mention this video is not designed
00:36 - for complete beginners you should have
00:38 - some knowledge of python already but
00:40 - don't worry if you don't know pame which
00:42 - is the graphics Library we'll be using
00:44 - here anyways with that said let's dive
00:46 - into the video and learn how to build
00:48 - 2048 in Python all right so let's begin
00:51 - here by just walking through at a high
00:53 - level exactly what it is that we need to
00:55 - do and kind of come up with a bit of a
00:57 - plan before we just jump into to the
00:59 - tutorial
01:00 - so as you can see here we have a grid
01:02 - right we actually have a 4x4 grid so we
01:05 - have at most 16 tiles that can be inside
01:08 - of the grid now these tiles can either
01:10 - be twos or fours we always start out
01:13 - with two twos on the screen and then
01:15 - anytime we make a move we will add one
01:17 - tile to the screen that will randomly be
01:19 - a two or a four when the tiles have the
01:22 - same values and they hit each other so
01:24 - in this case if I go down they'll merge
01:27 - so you can see that we had those fours
01:28 - turn into Eights
01:30 - pretty simple in terms of the rules here
01:32 - and eventually you will lose the game if
01:34 - there's no more room on the screen to
01:36 - add more tiles and you can't merge any
01:38 - of them together now this might seem
01:40 - like a simple game but it's actually a
01:42 - bit complicated because of the movement
01:44 - of these tiles and making it looks
01:46 - smooth and animated so what we'll Begin
01:48 - by doing is setting up the general grid
01:51 - we'll draw all of the lines we'll pick
01:53 - the different colors we'll start being
01:54 - able to generate some different tiles
01:56 - and then what it will get a little bit
01:58 - more difficult is when we need to move
02:00 - and merge the tiles together so for now
02:03 - let's start by setting up the screen we
02:05 - want to work on actually creating this
02:07 - grid system that you see here and then
02:09 - having some representation for our
02:11 - different tiles so we'll pick the
02:13 - different tile colors Etc kind of get
02:15 - the drawing and hook up some of the
02:17 - different functions once we've done that
02:19 - then we'll actually go over to the
02:20 - Whiteboard and I'll explain to you
02:21 - exactly how we do the movement of the
02:23 - tiles and some of the more complex logic
02:26 - which I think is really interesting and
02:27 - you guys will get some value from so
02:29 - let's hop in to our code editor here I
02:31 - am using visual studio code feel free to
02:33 - use whatever you would like now the
02:35 - first thing we need to do here is
02:36 - install the P game module which is what
02:38 - we're going to be using for all of our
02:40 - Graphics so we're going to go into our
02:42 - terminal and in this case I'm on Mac so
02:44 - I'm going to type pip 3 install py game
02:47 - obviously this assumes you already have
02:49 - python installed now that should install
02:51 - the py game Library I already have it
02:52 - installed so I'm not going to run this
02:54 - command if you're on Windows you can try
02:56 - pip install py game if you're on Linux
02:58 - it'll be pip 3 install P game and if
03:00 - none of those work you can try python
03:02 - hyphen M pip install P game or Python 3
03:05 - hyphen M pip install py game I also have
03:08 - two videos that I'll leave on the screen
03:09 - that will show you how to fix this pip
03:11 - import so for some reason it says pip is
03:13 - not a valid command follow those videos
03:15 - and they should show you how to install
03:17 - pame okay now that we have pame
03:18 - installed we just want to test this so
03:20 - I've opened up a new file here in vs
03:22 - code and we're going to start by just
03:24 - importing pame so we'll import pame and
03:26 - then we'll simply run our file and we'll
03:28 - just make sure that we don't get any
03:29 - errors here it says hello from the pame
03:31 - community which tells me that we are
03:33 - good to go okay so now that we've
03:36 - imported pame we'll import a few other
03:37 - modules that we're going to need to use
03:39 - so we're going to say import
03:41 - random and import math because we're
03:44 - going to need those and then we are
03:46 - going to say py game. anit this will
03:49 - just initialize all of the different
03:50 - features that we need now that we have
03:53 - this what I like to begin by doing is
03:54 - defining some different constants on my
03:56 - screen let me just make this a little
03:58 - bit bigger so we can read it it easier
04:00 - and these constants are values that are
04:02 - not going to change but that we'll need
04:03 - throughout the rest of the program so
04:05 - we'll Begin by writing those variables
04:06 - and we do these in capitals to represent
04:08 - that they're constant so first we're
04:11 - going to set the FPS now the FPS is the
04:13 - frames per second and this will allow us
04:15 - to dictate how quickly the game is
04:17 - running and to regulate the speed on
04:19 - different devices so we're going to type
04:21 - FPS equal 60 we then need to specify the
04:25 - width and the height so I'm going to say
04:26 - width comma height equals 800800 because
04:30 - I just want this to be a square we then
04:32 - are going to determine the row size so
04:34 - we're going to say rows is equal to four
04:36 - and columns are equal to four and what's
04:38 - nice about this approach here is later
04:40 - on we can very easily change the width
04:42 - and the height and we can adjust the
04:43 - number of rows and columns we want if we
04:45 - want to make the game more complex or a
04:46 - little bit different now the next thing
04:48 - we need to do is determine how large a
04:51 - tile is going to be or one of the
04:53 - rectangles is going to be that's inside
04:55 - of our grid so the way we do that is
04:58 - we'll say the with all capitals
05:01 - rectangular height is equal to the
05:03 - height of our screen divided by the
05:05 - number of rows that we have right in
05:07 - this case we have a height of 800 four
05:09 - rows meaning each tile will be 200
05:11 - pixels tall we're then going to say our
05:14 - rectangular width is equal to the width
05:16 - integer divided by The Columns the
05:18 - reason we're doing integer division is
05:20 - so that we get an integer rather than a
05:22 - floating point value now there's a few
05:25 - colors that we're going to Define that
05:26 - we'll need for right now so we're going
05:28 - to say our outline color
05:30 - is going to be equal to kind of a nice
05:32 - gray now I've already found these RGB
05:34 - colors so I'll just type them out and
05:35 - you can copy them with me so this is 187
05:38 - 173 160 whenever you're defining colors
05:40 - in pi game you have the option to use
05:42 - RGB which stands for red green blue
05:45 - first value is the amount of red second
05:47 - is the amount of green last is the
05:49 - amount of blue these values can be in
05:51 - the range of 0 to 255 if we had 0 0 0
05:54 - that would be black if we had 255 255
05:56 - 255 that would be white next we're going
05:59 - to say in all capitals again the outline
06:02 - thickness is equal to and then this will
06:06 - be 10 we can adjust this later this is
06:08 - how thick the lines will be on the
06:09 - screen and then we're going to have the
06:11 - background color and this will be equal
06:13 - to a different shade of gray which will
06:14 - be 205 192 180 don't worry too much
06:19 - about the colors again I already just
06:21 - found these next we're going to say font
06:23 - color this will be the color of the text
06:25 - on the tiles I'm going to go 119 110 and
06:29 - 101 for kind of a blackish grayish shade
06:32 - there okay so now that we've defined
06:35 - some of our constants we're going to
06:36 - create a py game window so whenever
06:38 - we're coding in P game we have a window
06:40 - the window is where we can draw objects
06:42 - and it's really representing the canvas
06:43 - of our screen so we're going to say in
06:46 - all capitals if I could toggle the Caps
06:49 - loocks button for some reason is not
06:52 - working okay window is equal to py
06:57 - game. display. set underscore modee and
07:00 - inside of here we're going to pass a
07:02 - tupple that contains the width and the
07:04 - height okay so this will actually create
07:06 - a pame window for us so again py game.
07:08 - display. setor mode then pass a tble
07:11 - make sure you don't forget the enclosing
07:13 - parenthesis there and by the way all of
07:15 - this code will be available from the
07:16 - link in the description in case you are
07:18 - getting confused or you want to copy a
07:20 - specific area next we're going to say py
07:22 - game. display. setor caption this will
07:25 - be the title of the window and I'm just
07:27 - going to call this 2048 which is the
07:29 - name the game okay last we have two more
07:31 - constants that we need we're going to
07:33 - have a font now a font is something that
07:35 - we can use to render text onto the
07:37 - screen so we're going to say font is
07:39 - equal to pame do font dot with a capital
07:44 - Sy font like that then we can put the
07:47 - name of the font I always use comic
07:49 - Sands we're going to put the size of the
07:51 - font which will'll go with as 60 for now
07:53 - and then we'll say bold equals true
07:55 - because we want the Bold version of the
07:57 - font lastly we're going to define a VAR
07:59 - variable here we'll use later called
08:00 - move velocity this is the speed at which
08:02 - the tiles will move and I'm going to go
08:04 - with 20 pixels per second okay so that
08:08 - is most of the constants that we need we
08:09 - Define our FPS width height rows calls
08:12 - rectangular height and width and then
08:13 - the different colors we need as well as
08:15 - set up the P game window just to make
08:17 - this a bit cleaner I'll move this down
08:19 - here so it's the last line we have our
08:21 - font and we have our move velocity and
08:23 - now we are ready to start coding out
08:24 - some more components of our game so the
08:26 - first thing we usually do when we're
08:28 - working with P game is we create
08:29 - something known as the main Loop now the
08:31 - main Loop is an event Loop that's going
08:33 - to run constantly and check for things
08:35 - like button presses exiting the screen
08:38 - it's essentially what will just run the
08:40 - game okay it's the main Loop that's
08:42 - handling all of the different events so
08:44 - we usually put that inside of a function
08:46 - so we'll simply say Define Main and then
08:48 - what we need to do is obviously call
08:50 - this function so we're going to go down
08:51 - to the bottom of the screen and we're
08:52 - going to say if underscore name is equal
08:54 - toore maincore uncore then call Main and
08:58 - what we're going to going to do is
09:00 - actually call this with the window
09:03 - object and we're going to take in window
09:06 - as a parameter here inside of the main
09:08 - function so we're just specifying okay
09:10 - where do we want to run the game well we
09:11 - want to run it on the window that we
09:13 - just defined as a variable here and if
09:15 - you're wondering what this does this
09:17 - simply means we are only going to
09:18 - execute this function if we are running
09:21 - this file directly I'm not sure if that
09:24 - makes a ton of sense but essentially if
09:25 - another file were to import this file
09:27 - this would not run whereas if we
09:29 - actually run this file directly which is
09:31 - what we'll be doing then this will be
09:32 - true and we'll run this window that's
09:34 - all this name equals main does just
09:36 - protects you in case you're reusing some
09:38 - functions in here and you don't want to
09:40 - actually run what's known as the main
09:41 - line okay so there we go we have main
09:45 - now inside of main we need to create a
09:48 - loop that's going to continue to run so
09:50 - the first thing we're going to do is set
09:51 - up a clock object this will allow us to
09:53 - regulate the speed of the loop so we're
09:55 - going to say pame do time with a
09:58 - capital. clock block we're then going to
10:00 - have a variable called run equals true
10:02 - which will set to false when we want to
10:04 - exit the loop we'll then say while run
10:07 - and we'll say clock. tick and then we're
10:10 - going to tick based on the frames per
10:12 - second which is this now this tick will
10:14 - just make it so this wall Loop is only
10:15 - going to run at most one time every 60
10:18 - seconds it could run less than that but
10:20 - the reason we put this here is so that
10:22 - people that are running on different
10:23 - speed of computers don't have the game
10:25 - running at a different speed if you
10:27 - didn't have this clock here what will
10:29 - happen is you'll simply run the loop at
10:31 - whatever the fastest speed is you can
10:33 - run it at which means someone on a
10:35 - really powerful computer is going to see
10:36 - the game a lot faster than someone on a
10:38 - slow computer so always good idea to
10:40 - have this clock now that we have the
10:42 - clock what we're going to do is create a
10:45 - simple event Loop that's just going to
10:46 - listen for all of the different key
10:48 - presses and events that could occur so
10:51 - to do that we're going to say for event
10:53 - impy game. event. get this will Loop
10:56 - through all of the events that have
10:58 - occurred and we can then then check the
10:59 - event and handle it so we're going to
11:01 - say if the event. type is equal to pame
11:05 - dot with all capitals quit then we will
11:08 - say run in lower
11:10 - cases is equal to false and we'll break
11:14 - out of this Loop now what that's going
11:16 - to do is simply say okay if we press the
11:19 - exit button that's what this quit event
11:21 - is we're going to set run equal to false
11:22 - so this Loop will stop running we're
11:24 - going to break immediately out of this
11:26 - event Loop so we don't handle it and
11:28 - then what will happen is we'll come
11:29 - outside of the loop and we'll run the
11:31 - command py game. quit which will simply
11:33 - quit the pame window for us so that is
11:36 - now the main Loop and what should happen
11:38 - is if we run this code we should
11:40 - actually see a window appearing and if
11:41 - we press the x button we should be able
11:43 - to cleanly exit so let's go ahead and
11:45 - try that and you can see we get 2048 we
11:47 - get the window of our size 800800 and I
11:50 - can click exit and I cleanly exit the
11:53 - code all right so now that we have that
11:54 - let's move on to doing some drawing
11:56 - operations so that we can actually see
11:58 - some stuff up here appearing on the
11:59 - screen now I typically like to separate
12:01 - the drawing from the event handling just
12:03 - so it's a little bit cleaner so the way
12:05 - I'll do that is I'll Define a function
12:07 - here called Draw you'll notice that in
12:09 - my code I'll write a lot of functions
12:11 - just to make sure everything is clean
12:12 - readable and easy to debug and we can
12:14 - quickly figure out where something's
12:16 - going wrong by just isolating it to a
12:18 - specific function this is good practice
12:20 - and something you can kind of take note
12:21 - of while I'm coding so in the draw
12:23 - function I'm going to take a window and
12:25 - what I'll do for now is simply set the
12:27 - background color and update the screen
12:30 - so I'm going to say
12:31 - window. fill and this allows you to fill
12:34 - the window completely with a background
12:37 - color so we're going to say window. fill
12:39 - and then background color if we look at
12:40 - background color here this is what it is
12:42 - so we're essentially just kind of
12:43 - painting the entire window this color
12:46 - then what we can do is say py game.
12:49 - display. update now the way the pame
12:52 - works is we do all of these drawing or
12:54 - paint events and then as soon as an
12:56 - update is called we'll actually apply
12:58 - all of those on onto the screen in the
13:00 - order in which we wrote them so what
13:02 - that means is that we're always going to
13:03 - fill the screen first because what that
13:05 - will typically do is it will actually
13:07 - override whatever was on the screen by
13:10 - before Sorry by painting over top of it
13:12 - then we'll do any other operations to
13:14 - draw the updated screen and then we'll
13:16 - update and then when we do the update
13:18 - we'll actually see that being performed
13:20 - on the screen I know it's a little bit
13:21 - abstract right now but it's just like we
13:23 - do all of these paint operations then we
13:25 - update then they're all applied at once
13:27 - rather than happening one at a time so
13:30 - now we just need to call that function
13:31 - so inside of this Loop make sure you're
13:33 - inside of the wall Loop here at the
13:35 - bottom we're going to say draw and we're
13:38 - going to pass that window object and now
13:40 - we should be getting the background
13:42 - color on our screen so let's try this
13:43 - out and you can see that now it fills
13:45 - with the background color okay great so
13:48 - now that we've done that we want to
13:49 - start drawing the grid so to draw the
13:52 - grid we're going to write a different
13:54 - function and we're just going to say
13:56 - draw underscore grid like like that okay
14:00 - and inside of here we'll take the window
14:02 - object again okay so for drawing the
14:05 - grid what we'll need to do is we'll need
14:07 - to draw horizontal and vertical lines to
14:10 - represent the separation between tiles
14:12 - and then we want to draw kind of a
14:13 - border around the entire screen so that
14:15 - we get that nice border effect so let's
14:18 - begin with the border to draw the Border
14:20 - we can simply draw a rectangle that's
14:22 - positioned at the edge of the screen so
14:23 - to draw a rectangle say pame do draw.
14:26 - rectangle like that with re C t for this
14:30 - we need to pass where we want to draw it
14:31 - so we want to draw it on the window we
14:33 - need to pass the color we'd like to draw
14:35 - it you can see I'm getting the auto
14:36 - complete here so we want the outline
14:38 - color and then we need to pass a
14:40 - rectangle that represents where we
14:41 - should draw the rectangle so the way
14:44 - that we pass a rectangle is we give the
14:46 - x coordinate y coordinate and then the
14:48 - width and the height of the rectangle
14:50 - now the X and the Y represent the top
14:52 - leftand corner where we want to start
14:54 - drawing the rectangle from now this will
14:56 - get into the Pam coordinate system which
14:58 - I'll discuss in a second but let's go 0
15:00 - 0 and then width and height now as well
15:04 - as that we have the option to either
15:06 - have the rectangle be filled completely
15:08 - in or to be an outline so in our case we
15:10 - want it to just be an outline we don't
15:12 - want it to fill in entirely we don't
15:14 - want to draw a s solid rectangle Sur we
15:16 - want one that's Hollow so what we'll do
15:18 - is pass what's known as the width or the
15:20 - thickness so I'm going to say width and
15:22 - then this is going to be the outline
15:24 - thickness which in our case I believe is
15:26 - 10 pixels so before we go any further
15:28 - let's draw this on the screen just so
15:30 - that we can see what it looks like so
15:32 - let's go here and in our draw after we
15:35 - draw the background we're going to say
15:37 - draw grid and we're going to pass the
15:41 - window so let's run this now and you
15:43 - should see that we're getting kind of
15:45 - this outline it's a little bit faint on
15:47 - my screen but I think you can probably
15:48 - see it maybe not with OBS recording but
15:51 - I can see it at least here and we do
15:52 - have an outline filling the screen okay
15:56 - so that's how that works now actually
15:57 - let's run this again one thing to note
15:59 - here when we're talking about
16:00 - coordinates and XY values in pi game we
16:03 - always start at 0 0 which is the top
16:05 - left hand corner of the screen so rather
16:07 - than starting at the middle which is
16:08 - typically 0 0 it's the top left meaning
16:11 - as you go to the right your x value
16:13 - increases and as you go down your y
16:16 - value increases so if we look at the
16:17 - bottom right hand corner that would be
16:20 - 800800 in terms of the coordinate grid
16:22 - in pi game so just keep that in mind um
16:25 - you you'll see as we go through here how
16:26 - we kind of do the positioning
16:29 - Okay so we've drawn that now we actually
16:31 - want to draw the outlines uh sorry so
16:33 - like the grid lines right so we can
16:35 - start by drawing the horizontal lines so
16:37 - we can say four row in range and then in
16:41 - all capitals rows so we're going to draw
16:43 - a line for every single row that we have
16:45 - and what we need to do here is simply
16:47 - calculate the y coordinate of the row or
16:50 - of the line Sur that we want to draw so
16:52 - we're going to say Y is equal to row
16:54 - multiplied by the rectangular height now
16:57 - the way this will work is we'll start
16:58 - start with row being equal to zero and
17:00 - then it'll become 1 2 3 and then it will
17:03 - not be equal to whatever the last row is
17:05 - which is fine and in fact we can
17:07 - actually do one comma rows because we
17:09 - don't need to draw the very top line
17:11 - because that will already have been
17:12 - drawn by the rectangular outline that we
17:15 - drew anyways what we're going to do here
17:17 - is draw a line the line will go from the
17:20 - x coordinate 0o to the width of the
17:22 - screen and then what we'll do is adjust
17:24 - the y-coordinate so we're moving the
17:26 - line down every time the loop happens so
17:28 - we take whatever the height of one tile
17:30 - is and we multiply that by the current
17:32 - row and that tells us the y-coordinate
17:34 - for this line so we're going to say pame
17:36 - do draw doline similarly here to the
17:39 - rectangle we're going to pass a window
17:41 - we're going to pass the outline color
17:43 - and then we're going to pass zero and
17:45 - then y y is our Dynamic value and when
17:47 - we draw a line we pass the starting
17:49 - position and the ending position so the
17:52 - two points essentially for the line to
17:54 - be drawn between so next we're going to
17:56 - say width and then y so so we're
17:59 - constantly always going to have the line
18:01 - starting at 0x and with X so that way
18:04 - we're filling the entire screen
18:06 - horizontally and we're just adjusting
18:07 - the y-coordinate so vertically where
18:10 - that Line's going to be drawn now again
18:12 - we need to specify the thickness we're
18:13 - going to put the outline thickness here
18:16 - also known as the width of that line so
18:18 - now if we actually go here and refresh
18:20 - you'll see that we get our vertical
18:21 - lines appearing or sorry horizontal
18:23 - lines so now we can copy this exact same
18:26 - thing and paste it here and just adjust
18:29 - it for the vertical lines so we're going
18:32 - to say for column in range one comma
18:36 - calls now this is going to be column
18:39 - times the
18:40 - rectangular width and we're going to
18:42 - change this to be X so now we're going
18:44 - to keep the Y values constant and adjust
18:46 - the X so this is going to become X and
18:49 - then zero and this is going to become
18:52 - X and height so you can see that we
18:55 - always have two fixed values right where
18:58 - we want to draw between and then what
18:59 - we're adjusting is the X position
19:01 - whereas here we were adjusting the Y
19:03 - position and where we make that change
19:04 - is with call and the rectangular width
19:07 - versus row and the rectangular height
19:09 - now in this case the rectangular height
19:11 - and width are the same uh however they
19:13 - could be different which is why I'm
19:15 - doing this in two Loops because if we
19:16 - wanted to have actual rectangles not
19:18 - squares then this code would adjust to
19:20 - that appropriately okay so let's run
19:23 - this and you'll see here that now we get
19:25 - our grid okay so now that we have our
19:28 - 4x4 grid what we want to start doing is
19:31 - actually representing tiles in those
19:33 - grids and then drawing the tiles on the
19:35 - screen once we're able to draw the tiles
19:37 - on the screen then we can start moving
19:38 - them on the screen again uh as I said
19:41 - this a bit more complicated so we're
19:43 - going to create a class here called tile
19:46 - now I want to use a class just because
19:47 - there's some methods related to each
19:49 - tile which will fit nicely inside of
19:51 - this object or inside of the class um so
19:53 - it just makes it a little bit cleaner so
19:55 - as a class variable I'm going to specify
19:57 - colors now what I'm going to do is paste
19:59 - a bunch of colors in here I don't want
20:00 - to write all of them out because it's a
20:01 - little bit tedious and these are the
20:03 - exact same colors that are used in the
20:04 - real 2048 game now these colors
20:07 - represent from like 2 4 8 16 32 64 Etc
20:12 - so as we go up it just multiples of two
20:14 - or whatever double the last value is
20:17 - okay so that's kind of how I'm doing it
20:19 - I'll show you how we index the colors in
20:20 - a second and if you want this list of
20:22 - colors obviously you can pause it and
20:24 - type it out or you can just view the
20:25 - code that's Linked In the description
20:27 - and rather than looking everything you
20:28 - can just copy this colors variable okay
20:31 - so again in the description you can find
20:32 - all of the code there should be a GitHub
20:34 - link and just go ahead and find the
20:36 - colors and paste them into your code if
20:37 - you're following along with me step by
20:39 - step so next we're going to define the
20:41 - initialization for our tiles so we're
20:43 - going to say Define uncore nit uncore
20:46 - uncore we're going to say
20:48 - self value row and column now for each
20:52 - tile we need to know what the value of
20:54 - the tile is so is it a two is it a four
20:55 - is it an 8 Etc we also need to know its
20:57 - position positioning in the grid so what
20:59 - row is it at what column is it at and
21:01 - that will allow us to determine the X
21:02 - and Y position of where we want to draw
21:05 - the tile it also allows us to know what
21:07 - tiles we can merge with so that's why
21:09 - we're storing that value so we're going
21:11 - to say self. Val equals value and create
21:14 - that attribute and we're going to say
21:15 - self. row is equal to row self. column
21:20 - is equal to column and then at the same
21:21 - time we're actually going to set what
21:23 - the X and Y coordinates are for drawing
21:26 - this specific time so we're going to say
21:28 - column times the
21:31 - rectangular width and
21:34 - self.y is equal to the row multiplied by
21:38 - the rectangular height now how does this
21:41 - work well if we were in row0 column Z
21:45 - then we would simply start drawing this
21:46 - tile at the position 0 0 right that's
21:49 - the very top left hand corner of the
21:50 - screen if we were in row 0o column 1
21:53 - then we would want to start drawing this
21:55 - from if I can calculate this correctly
21:58 - a y value of zero but an x value of 200
22:02 - because that's where we want to draw the
22:04 - tile that's in that First Column when I
22:07 - say First Column I really mean the
22:09 - second column it's because in
22:10 - programming we're starting indexing or
22:12 - starting counting at zero you'll see
22:14 - what I mean and actually I can just run
22:16 - this to explain it to you like if we
22:18 - want to draw a tile that's where my
22:19 - mouse is here I hope you can see it in
22:21 - the position 1 one so 1 one is you Row
22:25 - one column one as opposed to 0 0 here
22:28 - then what we're going to do is start
22:29 - drawing it at the top leftand Corner
22:31 - position of this which is what we're
22:33 - calculating when we're doing the X and Y
22:36 - so we multiply the column by the
22:37 - rectangular width which brings us over
22:39 - here we multiply the row by the
22:41 - rectangular height which brings us here
22:43 - and then we would draw the rectangle in
22:44 - this Square you'll see what I mean as we
22:46 - go through the code but hopefully that's
22:48 - an okay
22:49 - explanation okay so now that we have the
22:52 - initialization and we have some values
22:54 - that we need we want to start writing
22:55 - some other methods related to this
22:57 - object so before I write all of them
22:59 - we'll specify what they are so we're
23:01 - going to say well we want to be able to
23:02 - get the color that we're going to draw
23:04 - this tile in and that's going to be
23:05 - based on its value we also want to be
23:08 - able to draw this so we're going to say
23:10 - self and window because that's what we
23:12 - need to draw and what else do we need to
23:14 - do we need to be able to move this so
23:17 - we're going to take in and some Delta
23:19 - which is how much we would want to move
23:22 - this by and I don't know what just
23:24 - happened there on the screen and then
23:25 - lastly we'll have another method called
23:27 - set position which will allow us to
23:30 - actually determine let me just pass this
23:33 - here what position this uh tile is
23:36 - currently in while we're moving the tile
23:38 - we'll use some of these methods later on
23:39 - but I just like to stub them out so we
23:41 - know what we're about to write so let's
23:43 - begin by writing the get color and the
23:45 - draw methods which are the ones we'll
23:47 - use for now so again we need to be able
23:49 - to determine what color out of this list
23:51 - of colors we're going to use for the
23:53 - tile and that's going to be based on
23:55 - what the value of the tile is so we need
23:58 - to have some kind of function that can
24:00 - essentially give us the following values
24:02 - so we have a value of two we want to get
24:05 - the zeroth index which is the first
24:06 - color which is what the color of the
24:08 - value two should be when we have the
24:10 - value of four we want to get index one
24:13 - when we have the value of eight we want
24:15 - to get index 2 and when we have the
24:17 - value of 16 we want to get index 3 so
24:20 - you can follow this pattern here and you
24:21 - can actually come up with an equation
24:23 - which will allow you to get this
24:25 - specific mapping of value so anytime the
24:27 - value of X or the input doubles we want
24:29 - to then get the next value uh in our
24:32 - sequence hopefully that makes a bit of
24:34 - sense I'm sure this is bringing you back
24:35 - to math class well how do we do that
24:38 - well we have this wonderful thing called
24:40 - a logarithm which will actually allow us
24:43 - to figure out what the power is that's
24:46 - required passed on some value to get
24:49 - some other value right I'm sure you guys
24:51 - are familiar with logarithms I'm not
24:52 - going to explain how the logarithm works
24:53 - and that was pretty poor explanation but
24:56 - we're going to say the color index is
24:58 - equal to the math of log base 2 of our
25:01 - current value now if we look at the
25:04 - logarithm function we can see that if we
25:06 - pass F of two that actually gives us one
25:08 - however we want this instead to be zero
25:11 - so what we'll need to do is simply
25:13 - subtract one from whatever the value of
25:15 - the logarithm was that's returned now
25:17 - just to ensure we're always getting an
25:19 - integer value and not a floating point
25:21 - value we'll first convert the result of
25:22 - the logarithm to an integer it will
25:25 - always be a whole number anyways but
25:26 - this will just strip off any decimal
25:28 - point that might be there and then we'll
25:30 - subtract one so now we have a function
25:32 - that takes in whatever our values are
25:34 - and Maps it to the correct index in our
25:36 - colors list so now that we have the
25:38 - index we want to access the color so
25:40 - we'll say color equals self. colors
25:44 - at the col index okay and then we will
25:50 - return the color like that so this now
25:53 - will give us the correct color based on
25:55 - the value of this tile
25:58 - okay now we want to draw the tile on the
26:00 - screen now when we're drawing the tile
26:02 - on the screen what we need to do is draw
26:03 - a rectangle for that tile we also need
26:05 - to then draw on top of the rectangle the
26:08 - value of the tile so what we'll Begin by
26:10 - doing is drawing the rectangle and then
26:12 - we will draw the text on top of it so
26:15 - we're going to say that the color we
26:17 - want is equal to self. getet color and
26:20 - this is going to tell us the color that
26:22 - the rectangle should be we're then going
26:23 - to draw the rectangle so we're going to
26:25 - say pame do draw do rectangle and we're
26:28 - going to draw it on the window what
26:29 - color do we want to draw it well the
26:31 - color that we just got and then we want
26:33 - to draw this at the self.x position the
26:35 - self.y position and with the rectangular
26:38 - width and the
26:40 - rectangular height and that's it we want
26:42 - this to actually be a solid rectangle so
26:44 - this time we won't provide a width which
26:46 - means it will fill in the entire rect
26:48 - that we provided here now that we've
26:50 - done that we want to generate some text
26:52 - that we're going to draw in the middle
26:54 - of the rectangle so to do that we're
26:55 - going to use our font object so we're
26:57 - going to say say text is equal to font.
27:00 - render so the process whenever you want
27:02 - to draw text is you use this font object
27:05 - and you render some string into a
27:07 - surface is what it's called that you can
27:09 - then put onto the screen so we're going
27:11 - to say font. render and what we pass for
27:13 - this is the value so we're going to put
27:16 - an F string here or actually we can just
27:18 - do string of self. Val so we convert our
27:22 - numeric value into a string so that we
27:24 - can actually draw that we're going to
27:25 - pass one for something known as anti
27:27 - aliasing don't worry too much about that
27:29 - and then we need to specify the color
27:31 - now the color is going to be the font
27:33 - color that we specified earlier now that
27:36 - we have the text object what this has
27:38 - actually done is created a surface that
27:40 - contains the text and now we need to
27:42 - specify where on the screen we want to
27:44 - put the text so to do that we say
27:46 - window. blit blit is how you put a
27:49 - surface onto the screen so it's a bit
27:51 - different than drawing the rectangles
27:53 - now what we pass is what surface we want
27:55 - to put on the screen in this case I want
27:57 - to put the text surface and now we need
27:59 - to place this in the middle of the
28:02 - rectangle now to place this in the
28:03 - middle of the rectangle we need to
28:05 - determine the top leftand Corner
28:07 - position of where we should start
28:09 - drawing the um what do you call this
28:11 - here the text so in order to do this
28:14 - there's a little bit of math that we
28:16 - need to perform I don't know if I have a
28:18 - drawing tablet or maybe an ink thing
28:20 - that I can use here on Mac let's see if
28:23 - there's like a drawing surface or
28:24 - something okay I just found like an
28:26 - online drawing program that we'll
28:28 - quickly have a look at here just so that
28:30 - you can kind of see what I mean so let's
28:31 - say we have our rectangle right kind of
28:33 - a sketchy rectangle now we want to draw
28:36 - our number in the middle of the
28:38 - rectangle what we need to do is figure
28:40 - out the location that we want to draw it
28:41 - in now naively you might think okay well
28:44 - if I want to figure out the XY position
28:46 - let me just figure out whatever the XY
28:47 - position is of this and then we'll just
28:49 - take whatever the width of the rectangle
28:52 - and we'll start drawing it directly in
28:54 - the middle right so you'll just take
28:55 - okay we have W and we'll just take W
28:58 - over 2 and that's where we'll start
29:00 - drawing it the issue is if we do that
29:02 - then we're going to start drawing here
29:04 - and the number is going to go to the
29:05 - right because it's the top leftand
29:07 - Corner that we're drawing from so we
29:09 - actually need to do is offset this by
29:11 - the by half the width of the object that
29:14 - we're drawing so what I mean by that is
29:15 - we want to draw like this right so let's
29:17 - say the number is kind of in this box
29:20 - like in this bounding box we want to
29:22 - find this location that's where we want
29:24 - to start drawing the number from so the
29:26 - way we actually do that is let me just
29:28 - clean this up a little bit I know it's
29:29 - very messy here we have some W right
29:32 - this is the width of the rectangle so we
29:34 - start by taking W over 2 which is going
29:36 - to give us this position so w over 2 we
29:39 - then want to make sure that the number
29:41 - is perfectly centered so we say okay
29:43 - well we have the bounding box of the
29:45 - number and this has some width as well
29:47 - we can just call this uh I don't know a
29:50 - okay so what we actually do now is we
29:52 - take a over 2 and we subtract that from
29:55 - W over 2 and that gives us this position
29:58 - here which is the top leftand Corner
30:00 - position of where we want to start
30:01 - drawing this object from so quick
30:05 - clarification right we go to the middle
30:07 - of the screen we then subtract from half
30:09 - the width of the object we're going to
30:10 - be drawing and that means when we draw
30:12 - the object out it will be perfectly
30:13 - centered in the middle of the screen the
30:15 - same thing applies in the y direction so
30:17 - that's exactly what we're going to do
30:19 - here now I know that was really sketchy
30:20 - but hopefully that's an okay explanation
30:23 - all right so now that we have that let's
30:25 - start doing our little bit of
30:26 - calculation here so we're going to say
30:28 - okay well we'll start drawing this at
30:30 - the self. exposition of this current
30:32 - rectangle and then we're going to add to
30:34 - that what we just specified so we're
30:36 - going to take whatever the rectangular
30:38 - width is okay because that's the width
30:40 - of the rectangle that we're drawing
30:42 - inside of and we're going to divide that
30:43 - by two that gives us the middle of the
30:45 - rectangle but now we need that top
30:47 - leftand Corner position so we're going
30:49 - to say text. getet uncore width this
30:52 - gives us the width of the text object
30:54 - and then we're going to divide that by
30:55 - two this now specifies that this is the
30:57 - X position that we want to draw now next
31:00 - we're going to do the Y position so
31:01 - we're going to say self.y plus and this
31:04 - is going to be the
31:05 - rectangular height if we can get our cap
31:08 - locks to work some reason my caps locks
31:10 - button doesn't want to work very well so
31:12 - this is going to be the rectangular
31:13 - height over two minus the text.
31:17 - getor height over two okay and that's
31:21 - all that will actually blit this on to
31:23 - the screen for us okay so now we have
31:26 - the ability to draw our tiles now also
31:28 - notice the order in which we did this we
31:30 - first drew the rectangle and then we
31:31 - drew the text on top of the rectangle
31:34 - it's important you do it in this order
31:35 - otherwise the text will be hidden
31:37 - because you'll be drawing the rectangle
31:38 - after so now what we'll do is call that
31:41 - function so inside of our draw function
31:43 - we're now going to take in all of our
31:44 - tiles now we don't yet have any of those
31:46 - tiles but we will create them in a
31:48 - second and what we'll do is before we
31:50 - draw the grid we'll draw all of our our
31:52 - tiles and that way the grid lines Will
31:54 - Go On Top of the tiles and it will
31:56 - separate them and make make it uh pretty
31:58 - easy to see so we're just going to say
31:59 - for tile in tiles and then we'll just
32:03 - say tile. draw and tiles is actually
32:06 - going to be a dictionary so I'm just
32:07 - going to say tiles. values I know seems
32:10 - a bit weird because we haven't yet
32:12 - created the tiles but we'll just do a
32:13 - quick test and I'll show you kind of how
32:15 - it works all right so now we have that
32:17 - for drawing now we just need to make
32:19 - some tiles then pass those to our draw
32:21 - function so we're going to say tiles is
32:23 - equal to a dictionary the reason we're
32:25 - going to use a dictionary is that we
32:26 - want to be able to index or locate all
32:29 - of the tiles very quickly by their row
32:32 - and their column so there's multiple
32:34 - ways that we can go about indexing our
32:36 - tiles or storing them but what we want
32:38 - to come up with is a key that kind of
32:40 - represents the tile and then the value
32:42 - will be that tile class itself that we
32:44 - can index in here so to do that we'll
32:48 - simply say the following for now we're
32:50 - going to say 0 0 which is representing
32:53 - the row and the column so like you could
32:55 - have zero hyphen zero but in our case we
32:57 - know we're always going to have uh what
32:59 - do you call it less than 10 or on
33:01 - digigit rows and columns so we just go 0
33:04 - 0 so we'll say 0 0 colon and then we'll
33:07 - create a tile now for a tile we need a
33:09 - value a row and a column so let's go
33:11 - with a value of four and then let's go
33:14 - with a 0 0 for the row and for the
33:17 - column okay so now let me just change
33:21 - this to give you another example let's
33:22 - say we have the tile
33:24 - 128 now we want this to be at row two
33:27 - column Z so that would change this to be
33:29 - 20
33:30 - 0 okay the way this works again is that
33:33 - we have a two-digit string the first
33:36 - digit represents the row the second
33:38 - digit represents the column and then
33:39 - that's associated with the tile object
33:41 - itself that we actually want to be
33:43 - representing and drawing this way we can
33:45 - always index a tile given its row and
33:47 - column and we can find it instantly
33:49 - inside of the tile's dictionary this is
33:51 - opposed as if we made a list if we made
33:54 - a list and we wanted to locate a
33:55 - specific tile we need to potentially
33:57 - iterate through all of the tiles in the
33:59 - list and check the rows and columns to
34:01 - find the one that we want whereas here
34:03 - we can always have instant access to a
34:05 - tile so kind of an efficiency thing
34:08 - that's why we've written it this way
34:09 - okay now we're going to pass tiles to
34:12 - the draw function and just make sure
34:14 - they draw correctly on the screen so
34:15 - let's run this and we go on errow it
34:18 - says drawing is missing one uh required
34:19 - positional argument window okay so we're
34:22 - going to go here to tile. draw and pass
34:25 - window all right let's rerun this and
34:29 - now we should get our tiles on the
34:30 - screen and we get them at the positions
34:32 - we specified right so this was what 20
34:35 - and 0 0 we can do one more tile just as
34:38 - a test so let's go here and we'll say
34:41 - maybe 02 and this will be with a
34:46 - tile and this will be let's go
34:49 - 64 and then 02 okay let's run and you
34:53 - see now we get the 64 tile appearing in
34:56 - the correct position okay so that's
34:59 - great however we don't want to actually
35:01 - start our tiles with some fixed ones on
35:03 - the screen we want to randomly generate
35:05 - two tiles that have the value two that
35:07 - will begin as our tiles right so let's
35:10 - write a function that can do that let's
35:12 - say
35:14 - generate tiles now for this all we're
35:18 - going to do is just randomly pick two
35:20 - positions that we can put the tiles um
35:23 - in okay and we'll just make sure they're
35:25 - not the same so we're going to say tiles
35:26 - is equal to an empty dictionary we're
35:29 - going to say 4
35:30 - underscore in range two if you're
35:32 - unfamiliar with the underscore this is a
35:34 - placeholder value that we can use when
35:35 - we don't actually care about the
35:37 - variable we put here normally you do
35:39 - something like 4 I in range two but in
35:41 - my case I don't actually want to use I I
35:43 - just want to do something two times so
35:45 - I'll just say 4 underscore in range two
35:48 - we're now going to say row column is
35:50 - equal to and we're going to call a
35:51 - function which is get random
35:54 - position and we're going to pass our
35:56 - tiles
35:57 - and then we're going to say tiles we're
35:58 - going to do an F string and this is
36:00 - going to be at
36:02 - row column if we can do this is equal to
36:07 - a
36:08 - tile and then this is going to be two
36:11 - row call we're then going to return our
36:15 - tiles okay let me slow down a little bit
36:17 - to explain what we just did so we have
36:19 - an empty dictionary where we're going to
36:20 - store our tiles we're doing something
36:21 - two times and what we want to do is
36:23 - generate a random row and a random
36:25 - column to place our time inside of now
36:28 - we want to make sure that we're only
36:29 - doing this for a tile that does not yet
36:31 - exist right we don't want to create a
36:33 - tile that's in the place of another tile
36:35 - so that's where this function will come
36:37 - in which we'll write in a second it will
36:38 - make sure when we are randomly picking
36:40 - the row and column we don't pick one
36:42 - that already exists then what we're
36:44 - doing is saying okay tiles well this is
36:46 - a dictionary so we need to set the key
36:48 - the key is going to be equal to first
36:50 - whatever the row is and second whatever
36:52 - the column is so we use an F string
36:54 - available in Python 3.6 and above which
36:57 - allows us to embed inside of curly
36:59 - braces here any values that we want to
37:01 - be converted to a string so we're saying
37:03 - okay well we just want the row and the
37:04 - column which are numbers they're going
37:06 - to convert it to a string that's going
37:07 - to give us the correct key and then
37:09 - we're going to make that equal to a tile
37:10 - object which has the value of two
37:12 - because we always want to start with
37:13 - twos in the row and the column okay now
37:18 - let's write our get random position so
37:20 - we're going to say get underscore random
37:23 - underscore pause this needs to take in
37:25 - the tiles that we make sure sure that we
37:27 - are not placing this in a position that
37:29 - already exists so we're going to start
37:31 - by saying row equals none column equals
37:33 - none because we don't yet know what we
37:35 - want and now we're going to say while
37:37 - true and we're going to continue to
37:39 - randomly generate rows and columns or a
37:41 - position for this tile as long as this
37:44 - position already exists so what I mean
37:47 - by that is as soon as we find a position
37:48 - that does not yet already exist inside
37:50 - of our tiles then we will use that one
37:52 - otherwise we're just going to keep
37:53 - randomly generating positions so we're
37:55 - going to say row is equal to random.
37:59 - random range and this is going to be in
38:01 - the range zero to rows when we use Rand
38:03 - range it means we'll generate up to but
38:05 - not including whatever the value is here
38:07 - which is four so we'll generate a random
38:09 - value between 0o and three inclusively
38:12 - we're then going to say column is equal
38:13 - to random. Rand range and then zero
38:18 - columns okay so we're just picking what
38:20 - the random position is for what it
38:22 - should be what we're going to attempt
38:23 - and then we're going to say if and same
38:25 - thing we're going to do an string here
38:28 - row column is
38:31 - not in and then we can just say tiles
38:35 - like that then we're going to break now
38:38 - this is another advantage of using the
38:39 - dictionary we can instantly check
38:42 - whether or not this key exists inside of
38:45 - the dictionary because of that property
38:47 - of the dictionary we have instant access
38:49 - to see okay does this key so does this
38:51 - position row column already exist if it
38:54 - uh does not sorry which is what we're
38:56 - checking here then we're going to break
38:58 - right so then if we break we're going to
39:00 - return the row and the column from the
39:03 - function that we generated otherwise
39:05 - we're going to continue to do this until
39:07 - this condition is true allowing us to
39:08 - break out meaning we found a random
39:10 - position great okay so now that we've
39:13 - done that we will go over
39:17 - to our main and we'll say tiles is equal
39:21 - to generate tiles and that should
39:23 - generate two random tiles on the screen
39:25 - for us so let's try this now and you see
39:27 - that we get a randomly generated tiles
39:29 - let's run it again we get more randomly
39:31 - generated tiles Etc okay so there we go
39:35 - we've now generated the tiles and placed
39:37 - them on the screen okay so at this point
39:39 - we've written quite a bit of code and we
39:41 - have the main structure of the
39:42 - application setup now what we want to
39:44 - start doing is moving the tiles around
39:46 - so let me hop over to the drawing tablet
39:49 - and explain to you that process it is a
39:52 - little bit complicated then we'll begin
39:53 - implementing it all right so I'm on the
39:55 - drawing tablet now and I'm going to
39:57 - explain at a high level what it is that
39:59 - we're about to do now I can't cover
40:01 - everything conceptually here but I'll
40:03 - give you a sense of how to think about
40:05 - this problem now if you are someone who
40:06 - likes these problems feel free to try to
40:08 - solve it on your own uh first of all but
40:10 - you will see that it's a little bit
40:12 - complicated because of the fact that we
40:14 - actually want to animate the tiles and
40:15 - we want to move them on the screen so
40:18 - moving them is actually the difficult
40:19 - part doing the merges is not so hard to
40:22 - figure out what the new position should
40:23 - be it's more about getting to that new
40:25 - position and how we iterate and move so
40:28 - that it looks smooth anyways let's have
40:30 - a look here so we have a few different
40:32 - edge cases that we need to handle and we
40:34 - can go through them one by one so let's
40:36 - say we have the number two this is our
40:38 - tile and we decide to make a movement to
40:41 - the left keep in mind all the movements
40:43 - effectively are going to be handled the
40:44 - exact same so we can just look at a case
40:47 - in which we're moving to the left but
40:48 - the exact same thing would apply if
40:49 - we're moving to the right there's just a
40:51 - few variables that change so we're
40:53 - moving to the left and we have this tile
40:55 - now there's a few things that can happen
40:56 - the first thing that can happen is there
40:58 - can be nothing to the left and we can
41:00 - simply shift the tile that's the easiest
41:02 - case right there's nothing to the left
41:04 - of us so we just move the tile until we
41:07 - hit the Border pretty straightforward we
41:09 - take the X position and we just shift it
41:11 - over and then once it gets inside of
41:13 - this Square here we just change the
41:15 - tile's position so then rather than
41:17 - being at 1 one it's now at 1 Z okay so
41:22 - that's the important thing to also keep
41:23 - in mind here we have an X and A Y which
41:26 - is the location in which we're drawing
41:27 - the tile and we also have a row and a
41:30 - column which will represent with r and C
41:32 - which tells us the current location of
41:34 - the tile in the grid so these values are
41:37 - linked together however while we are
41:40 - moving the tile the r and the column is
41:42 - kind of in between right for example at
41:45 - one point in time my tile might be in
41:46 - between two rows and columns in that
41:49 - case we don't know its exact location
41:51 - and we need to wait until it reaches
41:53 - some kind of boundary point to then
41:55 - reset the row and column to be the
41:57 - correct position based on the X and Y
41:59 - value so I just want to say that one
42:01 - more time because I understand it's a
42:02 - little bit confusing we're going to have
42:04 - a tile that's going to be moving could
42:05 - be up right whatever while it's moving
42:09 - this row and column we don't necessarily
42:11 - know what the correct value is so at
42:13 - some point we need to adjust this so
42:15 - that it represents where its location
42:17 - actually is on the screen and that's
42:20 - typically when the tile is no longer
42:22 - moving okay so anyways that's kind of
42:24 - the basics there so this is the first
42:26 - case we just simply move the dial over
42:28 - to the left now the second case is when
42:30 - we have a blocking tile that is in the
42:33 - direction of which we're moving so again
42:35 - we're moving to the left that's where
42:37 - we've shifted and now we see that when
42:39 - we move to the left well this tile
42:42 - exists and it doesn't allow us to move
42:45 - so if that's the case we just simply
42:46 - stay put right there's no movement that
42:48 - occurs for either of these tiles now it
42:51 - gets a bit more complicated right where
42:53 - we have this tile here so now in this
42:55 - case we move until we reach a tile that
42:59 - is blocking us okay so obviously I think
43:02 - that makes a bit of sense now the next
43:04 - instance is when we are moving in a
43:06 - direction and we have a tile that
43:08 - contains the same value as us if that's
43:11 - the case we actually want to take this
43:13 - tile we want to move it so it kind of
43:15 - merges with this tile and then we need
43:17 - to update the value of the tile to the
43:19 - left so this becomes four and remove
43:22 - this tile so let's kind of do an X here
43:25 - so we no longer see it on the screen so
43:27 - this is the merge instance now the thing
43:30 - with this is that there's kind of two
43:32 - stages to this merge the first stage is
43:36 - while the tile is actually moving into
43:38 - the position of this tile so to keep
43:41 - things looking smooth we don't just want
43:43 - to instantly merge the two tiles as soon
43:45 - as we see that they are going to merge
43:47 - what we want to do instead is we want to
43:49 - take this tile and we want to kind of
43:51 - move it inside of the other tile and
43:54 - then as soon as it's fully uh emerged in
43:56 - that tile is when we remove it from the
43:59 - screen and then we simply update this
44:00 - one so it now becomes the new tile value
44:03 - so those are those two situations right
44:05 - the first situation okay we know we're
44:07 - going to merge we need to keep moving it
44:09 - so it looks smooth then the second
44:11 - situation is okay we've already moved it
44:12 - inside of the other tile so now we'll
44:14 - merge it together so those are pretty
44:18 - much all of the edge cases again we have
44:21 - a situation in which there's no tile to
44:23 - our left or in the direction of which
44:24 - we're moving we just move the tile we
44:27 - have a situation where there's a
44:28 - blocking tile where there's no movement
44:30 - that occurs and we have a situation in
44:32 - which there's a merging tile where
44:33 - there's two phases the first phase is to
44:35 - move into the square where the merging
44:37 - tile is and then to merge the two tiles
44:40 - and remove the other tile so that's what
44:42 - we need to handle however doing this is
44:46 - a little bit easier said than done
44:47 - because of all the things that could
44:48 - happen for example let's say we have
44:51 - something that looks like this right we
44:53 - have like 2 two 2 two well what we we
44:56 - need to do is actually make sure that we
44:57 - move the tiles in the correct order such
45:00 - that the merges happen appropriately so
45:02 - in this situation where we have four
45:04 - twos we want to ensure that we don't
45:06 - accidentally merge the two middle tiles
45:08 - because if we were to do that we would
45:10 - be left with a result of 2 42 which is
45:14 - incorrect what we want instead although
45:16 - I guess you could Define this behavior
45:18 - however you want is that after we do
45:20 - this Movement we end up with two fours
45:23 - right so we delete delete and we have 44
45:27 - so what that means is that we need to
45:28 - make sure that we're going to start
45:30 - moving the tiles from the direction in
45:33 - which we're moving so if I'm moving left
45:35 - we're going to check the first tile then
45:37 - the second tile then the third tile then
45:39 - the fourth tile and at one step at a
45:41 - time move them to the left rather than
45:43 - moving the tiles from the right first
45:45 - because if we move the ones on the right
45:46 - then we're going to merge in the wrong
45:47 - order so the merging order is important
45:51 - there's a lot of other factors we need
45:52 - to consider there but I think that's
45:54 - enough in terms of the high level EXP
45:55 - explanation so let us now get into the
45:58 - code and I'll start explaining it and
46:00 - again feel free to pause it Go reference
46:01 - some of the other code if anything's
46:03 - going wrong and ask any questions you
46:04 - have in the comments down below all
46:06 - right so we're back now and we're going
46:07 - to start handling the movement so what
46:09 - we'll do is we'll Define a function move
46:12 - tiles which is going to allow us to move
46:14 - them so we're going to say window tiles
46:17 - clock and Direction and this will be one
46:20 - function that will actually handle the
46:22 - movement of the tiles in all of the
46:23 - directions now we'll start by just doing
46:25 - One Direction dire so you get the gist
46:26 - of it and then we'll handle the other
46:28 - directions which are just slight variant
46:30 - of one of them right so what we're going
46:32 - to do is create a variable called
46:34 - updated equals true and we're going to
46:36 - create something called blocks which
46:38 - I'll Define in a second pretty much this
46:40 - blocks set is going to tell us which
46:43 - tiles have already merged in a movement
46:46 - because we don't want to be merging
46:47 - multiple sets of tiles I can show you an
46:50 - example of what I mean in a second when
46:51 - we actually run the code but we create
46:54 - this set here so that we know which
46:56 - tiles already had a merge operation
46:58 - occur so we don't allow them to merge
47:00 - again which means we don't get this like
47:02 - huge chain of tiles merging in a row
47:04 - which is not how the original game
47:06 - behaves you can obviously change the
47:07 - behavior if you want but that's not what
47:09 - I want to do here okay so now what we
47:11 - want to do is just handle what direction
47:13 - it is that we're moving so we'll just
47:15 - stub a little if statement here and
47:16 - we'll say if direction is equal to left
47:20 - we'll say l if the
47:22 - direction is equal to right
47:26 - and let's just do a pass here we'll say
47:28 - l if the direction is equal to up and
47:32 - we'll say l if after we pass just so
47:36 - that we have a stub there the direction
47:39 - is equal to down okay so now we're
47:43 - handling all of the directions the first
47:45 - Direction we'll go into is left so what
47:48 - we need to do is Define a few functions
47:51 - and variables that we'll use in the main
47:53 - kind of block of our code so this is
47:55 - going to seem very abstract right now
47:57 - when I write this out but just bear with
47:59 - me and I promise you it will start to
48:00 - make more sense so we're going to say
48:02 - our sort
48:03 - function and we're going to use
48:05 - something called a Lambda if I could
48:07 - type this so we're going to say Lambda X
48:10 - and then X do column now remember that
48:14 - we want to move the tiles when we're
48:15 - going left for example from left to
48:18 - right so the first tile we move is the
48:19 - one that's furthest on the left and then
48:21 - we go to the right and then move the
48:23 - tiles in that order that way we merge
48:25 - the correct order so we need to start
48:27 - actually moving from that left side so
48:29 - that means that we need to actually sort
48:31 - the tiles so that we know which tile we
48:34 - should move first because right now our
48:36 - tiles are stored in a dictionary and
48:38 - we're not going to necessarily have them
48:39 - in a sorted order so we're going to take
48:41 - the tiles and we're going to sort them
48:42 - into a list and then we're going to move
48:44 - all of the tiles so that's why I'm
48:47 - setting the key here equal to the column
48:49 - so I'm saying okay we're moving to the
48:50 - left which means we're going to sort the
48:52 - tiles by their column now if you're
48:54 - unfamiliar with this Lambda this is a
48:56 - oneline Anonymous function and it works
48:58 - the exact same as any other function so
49:00 - this that I just wrote right here is the
49:02 - exact same code as this uh oops not Funk
49:05 - Define Funk X and then return
49:11 - x.com okay it's the exact same thing
49:14 - it's just so you can write it in one
49:15 - line and you don't need to define a name
49:16 - for it when you don't need that name
49:19 - okay so that's kind of all that does
49:21 - this is like okay we're making a
49:22 - function this is our parameter and this
49:23 - is what we want to return from the
49:25 - function it only allows us one line but
49:27 - that's fine that's all we need okay then
49:29 - we're going to have reverse equals and
49:32 - this is going to be false now this is
49:33 - going to tell us whether or not we want
49:34 - to sort an ascending or descending order
49:38 - so we could actually change this to just
49:39 - be ASC like that standing for ascending
49:43 - uh or no that's going to look a little
49:44 - bit weird we'll do reverse instead sorry
49:46 - this is just again telling us okay do
49:48 - you want to sort in reverse order or
49:49 - correct order because when we're going
49:51 - to go in the right we want to sort again
49:53 - but we want to sort in reverse order so
49:54 - we start with the largest column
49:56 - Elements which are on the furthest to
49:58 - the right okay next we're going to have
50:00 - a Delta now the Delta is going to
50:02 - specify how much we want to move each
50:03 - tile by each frame in this movement
50:06 - function so the Delta is going to be
50:08 - negative move velocity and then zero so
50:11 - we're specifying how much in the X
50:13 - Direction and how much in the y
50:14 - direction we're going to move in this
50:16 - case I want to move negative in the X
50:18 - Direction which will move us to the left
50:20 - okay so reducing X moves to the left
50:23 - next we're going to have a boundary
50:24 - check
50:26 - now this is going to be a function again
50:27 - and this is going to be Lambda we're
50:28 - going to take in a tile and we're going
50:30 - to check if the tile. column is equal to
50:33 - zero now if the column of the tile is
50:35 - equal to zero that means it's already as
50:37 - far left as it can possibly go so we're
50:39 - not going to move it any further to the
50:41 - left because it's hit the bounds of the
50:43 - screen so again same thing Anonymous
50:45 - function just tells us okay have we hit
50:46 - the boundary or not next thing we need
50:49 - is a function that can get us the next
50:51 - tile so this is the tile to the left of
50:54 - the current tile we need to check that
50:56 - tile because based on its value we're
50:58 - either going to be blocked by it or we
51:00 - are going to merge into it so we're
51:02 - going to say get next tile is equal to a
51:06 - Lambda function and this is going to
51:08 - take in a tile and it's going to say
51:10 - tiles. get and we're going to say f and
51:13 - then row and then column minus one so
51:16 - what we're looking for and sorry this
51:19 - needs to be the tile. row and the tile.
51:23 - column so we're looking for or is the
51:25 - tile to our left the tile to our left is
51:28 - the tile that has a column that's one
51:30 - less than us now we do dot get because
51:33 - we don't know if this tile exists so we
51:35 - don't know if there's actually one to
51:36 - our left or not if there is one this
51:39 - will return that tile for us which
51:40 - allows us to use this indexing scheme
51:43 - otherwise it just returns none
51:46 - okay next we're going to have our merge
51:48 - check now this is a Lambda function
51:51 - again and we're going to take in our
51:53 - tile and our next tile now what this is
51:56 - essentially telling us is whether or not
51:58 - we should merge the tile based on the
52:00 - current movement of this tile because
52:02 - you'll see what we're doing is moving
52:04 - the x coordinate of our tiles until we
52:06 - reach a certain position in which case
52:08 - we then do the merge so we're going to
52:10 - say that the tile dox is greater than
52:14 - the next tile dox and then this is going
52:18 - to be plus the move velocity so what
52:22 - we're checking okay the tile that we
52:24 - currently have so the one that we're
52:26 - moving to the left we're going to check
52:28 - if its Exposition is greater than the
52:31 - next tile's Exposition plus the velocity
52:35 - that uh we're about to be subtracting as
52:38 - we move what this is telling us
52:41 - essentially is okay have we moved far
52:43 - enough left that it now looks like we're
52:46 - inside of that other tile if we have
52:49 - then we can go ahead and merge if we
52:51 - haven't which is actually what this is
52:52 - checking story then we'll keep moving
52:54 - the tile you'll see how we use it a
52:56 - second but this is checking okay are we
52:58 - in the position to merge or not that's
52:59 - pretty much what it's telling
53:01 - us okay next we're going to have a move
53:04 - check now this is going to be for when
53:06 - we're moving and there is a tile to the
53:08 - left of us however that tile is not the
53:11 - same value as the tile that um what do
53:15 - you call it that we're moving so this is
53:17 - going to be
53:18 - Lambda tile next tile and this is going
53:22 - to be tile dox is greater than the next
53:26 - Tilex plus this time the rectangular
53:29 - width plus the move
53:32 - velocity okay so why are we doing it
53:34 - like this now so in this instance if
53:36 - we're moving to the left and we have a
53:37 - next tile we want to stop moving as soon
53:39 - as we reach the border of that tile now
53:42 - the border of that tile is on the right
53:44 - side of the tile that's to the left of
53:46 - us so to get that position we take the
53:48 - next tile dox we add the width of that
53:51 - tile and then we add the velocity which
53:54 - we would be mov moving if we were to
53:56 - continue the move um again you'll see
54:00 - how this works in a second I know it's
54:01 - it's fairly abstract okay lastly we're
54:03 - going to have seal is equal to true now
54:06 - this essentially tells us whether or not
54:08 - we should round up or round down when
54:10 - we're determining the location of the
54:12 - tile after a move I know a lot of code
54:17 - very abstract but these are the
54:19 - different things that will be adjusted
54:21 - based on the direction that we're moving
54:23 - so you can imagine we're moving to the
54:24 - right some of these things are going to
54:26 - change right like the move check the
54:27 - merge check the sort function is going
54:29 - to be a little bit different the reverse
54:30 - function okay so that's kind of what
54:33 - we're doing here in terms of this and
54:35 - then we have some general code which
54:36 - we're about to write which will perform
54:38 - the move based on these functions so
54:41 - this is kind of the cleanest way to
54:42 - write this so what we're going to do is
54:44 - say while updated now the idea is while
54:47 - we've performed some kind of move update
54:50 - we need to kind of update the screen and
54:52 - redraw it so it looks like we're moving
54:55 - as soon as we're in a position where
54:57 - nothing has moved we're going to stop
54:59 - this W Loop so when no update has
55:01 - occurred which is what's going to be
55:02 - indicated by this variable here then
55:04 - we'll break out of the loop so now we're
55:06 - going to say clock. tick and then we're
55:09 - going to tick by FPS and we're going to
55:11 - say updated equals false so it's our
55:14 - responsibility as we go through this
55:16 - Loop to update this variable and make it
55:18 - equal to true if an update operation has
55:21 - occurred so now what we're going to do
55:23 - is we're going to sort the tiles so
55:24 - remember I said we need to get the tiles
55:26 - in a sorted order such that we're moving
55:28 - them in the correct um order so that we
55:30 - get the correct moves so we're going to
55:32 - say sorted
55:34 - tiles is equal to a sorted function of
55:38 - the tiles. values we don't care about
55:40 - the keys we just want the values and the
55:42 - key is going to be equal to a sort
55:46 - function okay like that and then reverse
55:50 - is equal to reverse so the sort function
55:54 - we defined here reverse we defined here
55:56 - we're now using these to sort the tiles
55:58 - in the correct order we're then going to
56:00 - say 4 I comma tile in enumerate and
56:04 - we're going to enumerate over the sorted
56:06 - tiles this simply means get the index of
56:08 - the tile as well as the tile object
56:10 - itself first thing we're going to check
56:12 - here is okay we want to be moving these
56:14 - tiles so we're doing this for every tile
56:15 - right we're going to check if the tile
56:18 - is at the boundary so if the boundary
56:20 - check of tile then simply continue
56:23 - because if we're at the boundary there's
56:24 - no movement that needs to occur for this
56:26 - specific tile so we can move forward
56:28 - next thing we need to do is get the next
56:30 - tile so we're going to say the next tile
56:33 - is equal to get next tile and we pass
56:36 - the current tile that's going to give us
56:38 - the tile that is in the way of which we
56:40 - want to move so we're now going to say
56:42 - okay well if we don't have a next tile
56:44 - so if there's no tile in our way then we
56:46 - can continue to move because we're not
56:48 - at the boundary and there's no tile next
56:50 - to us so let's just move our tile so
56:53 - we're going to say tile. move
56:56 - by our Delta and before I forget let's
56:58 - go and code out this function so move is
57:02 - right up here and the way we move is the
57:05 - following we say
57:07 - self.x plus equals Delta 0 and
57:10 - self.y plus equals Delta 1 and that's it
57:14 - very straightforward again if we go look
57:16 - at our Deltas here you can see that we
57:19 - just have the components of how much we
57:20 - want to move in this case we're just
57:21 - going to move backwards in the X
57:23 - Direction because if we add Z to the
57:25 - existing value here in y doesn't do
57:27 - anything okay so that is move now we get
57:30 - into the more complicated cases so we
57:32 - say all right well if there is a tile
57:34 - beside us we need to check something we
57:37 - need to check first of all is this tile
57:41 - the same value as us so we're going to
57:43 - say
57:44 - LF the tile. value is equal to the next
57:48 - tile do value if it is now we go into
57:52 - those two cases so I don't know what I
57:54 - just did there where we need to
57:55 - determine okay well if it's the same
57:57 - value we're either we're going to be
57:59 - merging with it right so we're either in
58:00 - the process of merging with it or we've
58:03 - just merged like we've moved the tile
58:04 - enough so we're going to say if merge
58:07 - check and then tile if we can type this
58:11 - correctly and next tile then we're going
58:15 - to say tile. move and then Delta so this
58:18 - is checking okay are we in the process
58:20 - of merging if we are we can continue to
58:22 - move the tile now if we are not then we
58:24 - need to do is actually perform the merge
58:26 - operation so the merge operation looks
58:28 - like this we're going to take the next
58:30 - tile we're going to get its value and
58:32 - we're going to multiply it by two we're
58:34 - then going to remove the tile that
58:36 - merged with it which is the one that
58:37 - we're moving so we're going to say
58:38 - sorted
58:39 - tiles. pop at index I which is the index
58:43 - of this tile in the sorted tiles list
58:46 - we're then going to say blocks. add and
58:49 - we're going to add the
58:52 - tile and we we are going to also add the
58:56 - next tile or sorry we don't need to add
58:59 - the tile cuz we just removed it we're
59:00 - just going to add the next tile now what
59:02 - this is doing here is saying okay well
59:04 - we've already okay so what this is doing
59:07 - here is simply saying all right well
59:08 - this tile just got merged with another
59:09 - tile so we want to make sure it doesn't
59:11 - merge again so we're just adding it into
59:13 - the blocks so that we can then use that
59:15 - set to ensure we don't do a kind of
59:17 - double merge operation now where we'll
59:19 - actually use that is right here we're
59:21 - going to say and tile not in blocks and
59:28 - the next underscore tile
59:30 - not in blocks when I save that we'll get
59:34 - the auto formatting but what we're doing
59:36 - here is making sure okay well if the
59:38 - tile. value is equal to the next tile.
59:40 - value so if it's the same and that tile
59:43 - and the current tile that we have has
59:45 - not merged with another tile go ahead
59:47 - and we can perform this operation now if
59:49 - it has merged with another tile we don't
59:51 - want to do this we don't want to merge
59:53 - with it so we're not going to initiate
59:54 - that operation okay next thing we're
59:57 - going to do is we're going to say LF the
60:00 - move check and this is going to be tile
60:03 - next tile then we're going to say tile.
60:06 - move by the Delta otherwise we're going
60:10 - to say continue all right so let me just
60:13 - quickly break this down here what we're
60:15 - doing is we're getting the next tile if
60:17 - we don't have a next tile we simply move
60:19 - now if we do have a next tile and that
60:23 - tile value is the same as this value
60:25 - we're going to go ahead and initiate the
60:27 - merge operation which we discussed now
60:29 - once we reach this LF we know okay we do
60:33 - have a x tile the next tile's value is
60:35 - not the same as ours so what that means
60:37 - is that we should move this tile until
60:40 - we reach the border of that next tile
60:43 - which is what's checked by this function
60:45 - so we move until this is false right
60:48 - until it you can no longer move we're
60:49 - going to continue to move otherwise if
60:52 - none of that is true then we just say
60:55 - continue and what that means is we're
60:56 - not going to do anything and when we
60:58 - don't do anything no update occurred so
61:01 - now we're going to go down here and
61:03 - we're going to say updated equal true so
61:05 - unless we were in this case or we were
61:08 - on the boundary we're going to reach
61:10 - this variable and we're going to say
61:11 - update equals true and that's going to
61:13 - tell us to initiate another loop here
61:15 - and continue the movement process
61:17 - because something did actually move as
61:19 - soon as this variable never becomes
61:21 - equal to true we stop the W Loop and we
61:23 - exit now there's a few other things that
61:25 - we need to do but that's a good start to
61:26 - our function all right so let's continue
61:28 - here as I was discussing while we move
61:31 - these tiles their row and column are
61:34 - going to be adjusted based on their X
61:36 - and Y position so based on where they're
61:37 - actually moving in the grid because as
61:39 - they move uh enough then they're going
61:41 - to be in a different row and a different
61:42 - column so we need to actually adjust
61:45 - that so to adjust that we're going to
61:47 - use this if we can write here set
61:50 - position function now the set position
61:52 - function or method whatever you'd prefer
61:53 - to call it is is simply going to look at
61:55 - the current X and Y position of this um
61:58 - what do you call it tile and then adjust
62:01 - it sorry adjust the row and call based
62:03 - on that X and Y position so we're going
62:05 - to say seal is equal to false and this
62:09 - is a variable that's going to tell us
62:10 - whether or not we should round up or we
62:11 - should round down which is going to be
62:13 - important based on the direction in
62:14 - which we're moving so we're going to say
62:16 - if ceiling so simply if we're rounding
62:19 - up then we're going to say self. row is
62:22 - equal to the math do seiling which is
62:25 - always rounds a value up and then we're
62:27 - going to take the
62:29 - self.y and we're going to divide that by
62:31 - the rectangular height so let's say the
62:34 - Y position is 600 right we're going to
62:36 - take six so let's say the Y position is
62:39 - 599 we're going to take 599 divided by
62:42 - the rectangular height which is 200
62:43 - that's going to give us like 2.9
62:45 - something we're then going to round that
62:46 - up to three telling us that we are
62:48 - currently still in the third row okay
62:51 - we're now going to say self. column is
62:53 - equal to math do
62:55 - ceiling
62:56 - self.x divided by the rectangular width
62:59 - and then for the else so if we're not
63:01 - rounding up we're going to round down so
63:03 - we're going to say self. row is equal to
63:05 - math. floor and then the exact same
63:08 - thing here right so this is going to be
63:10 - the Y value and then self.
63:14 - column is equal to math. floor self.x /
63:18 - by the rectangular width okay so that is
63:22 - just going to adjust the row and column
63:23 - as we move and what we're doing is we're
63:25 - essentially with this determining at
63:28 - what point will we move to the left or
63:29 - to the right that we want to set that
63:32 - row column value so when I go with
63:34 - ceiling that means as soon as I move
63:37 - fully past the bounding line or I'm
63:40 - right at it then I'm going to adjust
63:42 - this as I'm moving to the left whereas
63:44 - when I'm moving to the right it's
63:45 - actually going to be the opposite um
63:48 - because of the kind of directions in
63:50 - which we're moving it's it's difficult
63:51 - to explain this but you'll be able to
63:53 - see in the code here how we change this
63:55 - based on if we're moving to the left or
63:56 - to the right so that we know what row
63:58 - and column we're actually in to check
64:00 - for the next tile okay so now what we'll
64:04 - do is we'll go over here to updated and
64:09 - either before after updated doesn't
64:11 - actually matter the order in which we do
64:13 - it we're just going to set the tile
64:14 - position so we're going to say
64:18 - tile do set position and we're going to
64:22 - pass that ceiling value which we find
64:24 - here so we're moving to the left ceiling
64:26 - is true we're moving to the right it's
64:27 - going to be false okay now this is all
64:30 - good however you'll notice that we
64:32 - removed some tiles but we only removed
64:35 - them from the sorted tiles list now this
64:37 - is not actually where all of the tiles
64:39 - are stored it's just where they're
64:40 - temporarily stored while we're in this
64:42 - updated Loop so what we actually need to
64:45 - do now is adjust the tiles object itself
64:47 - which is passed in here to remove any
64:50 - tiles that were then removed from the
64:51 - sorted tiles um and to kind of adjust
64:54 - them so what we're going to do is inside
64:57 - of the wall Loop here but outside of the
64:59 - for Loop so make sure you have that
65:01 - indentation correct we're going to say
65:03 - update tiles and we're going to take the
65:06 - window the
65:08 - tiles and the sorted tiles now all this
65:11 - is going to do is essentially Loop
65:12 - through our tiles and it's just going to
65:14 - remove any of the sorted tiles that no
65:16 - longer exist from tiles so we're going
65:18 - to say
65:20 - Define
65:22 - update under _ tiles and we'll take in
65:26 - the window the tiles and the sorted
65:30 - tiles like that and we will go ahead and
65:33 - write that function so the way we can do
65:35 - this is we can just start by clearing
65:38 - all of the tiles so we're going to say
65:39 - tiles. CLE just removes everything from
65:41 - the dictionary and then we'll just say
65:44 - for tile in the sorted tiles and then
65:49 - we're going to say tiles and we'll
65:50 - create an F string
65:52 - again okay and this this is going to be
65:55 - tile. row tile. column is equal to the
66:00 - tile that's it and then we'll just do a
66:02 - draw operation here so we can actually
66:03 - see what's going on and we're going to
66:05 - draw the window and the tiles so update
66:07 - tiles is going to as I said update this
66:11 - tiles dictionary so it only contains the
66:12 - ones that are actually still there and
66:14 - it's going to draw all of the tiles on
66:16 - the screen as they move so we can
66:17 - actually see that movement operation
66:20 - occurring so I think that's okay last
66:23 - thing we'll do here is we're just going
66:25 - to call something known as end tiles now
66:28 - notice that this is happening outside of
66:30 - the wall Loop so as soon as we're no
66:32 - longer updating any tiles we're going to
66:34 - call this function so we're going to say
66:35 - Define end tiles like this this is going
66:39 - to take in the tiles and what this is
66:41 - going to do here is just check whether
66:43 - or not the game is over uh and kind of
66:46 - do that last cleanup operation so what
66:49 - do we want to do here actually let's
66:52 - call this end move cuz that makes a bit
66:54 - more
66:55 - sense okay and then inside of here we're
66:58 - going to say if the Len of tiles is
67:02 - equal to 16 then we're going to return
67:05 - lost so if after we did a move we have
67:08 - 16 tiles uh that means that we can't
67:11 - move anymore because the en entire board
67:13 - is well full of tiles uh and that way we
67:15 - lost so we'll just say we lost and then
67:17 - we can handle that later on if we want
67:19 - and then what we also want to do is we
67:21 - want to add a new tile to the screen
67:23 - right so every time we make a move a new
67:24 - tile gets added so we're going to say
67:26 - row column is equal to get random
67:29 - position and this is going to be tiles
67:31 - and then we're just going to say Tiles
67:33 - at the F string of row column is equal
67:38 - to tile and then what we need to do is
67:40 - randomly select whether or not we want
67:42 - the tile to be a two or a four so we're
67:44 - going to say random. Choice and then in
67:46 - an array two four just randomly pick
67:48 - between two and four then the position
67:50 - is going to be at row column and we'll
67:51 - just return continue so we know know
67:54 - that we can continue the game now from
67:55 - here we're also return and move and then
67:58 - what we'll do is we'll just go to main
68:00 - here and we'll actually start calling
68:03 - these functions that we wrote and then
68:05 - if we get a like end game returned then
68:08 - we'll simply end the game right we can
68:10 - send a message to the user we can do
68:11 - whatever we want in fact I'll actually
68:13 - let you guys handle that but we'll talk
68:15 - about that in a second okay so we've now
68:17 - handled moving left the other movements
68:18 - will be fairly straightforward I know
68:20 - that was kind of complicated let's
68:21 - actually test this though so what we
68:24 - want to do is we want to check for the
68:26 - different key presses right so if you're
68:28 - pressing Left Right Etc so we need to
68:30 - first check okay did we press a key so
68:32 - to do that we're going to say if event.
68:33 - type is equal to py game. key down so
68:37 - did we press a key down if we did we're
68:40 - going to say if event. key is equal to
68:45 - py game. Kore and we'll start with left
68:48 - so if we press the left key then we're
68:50 - going to say move tiles and we're going
68:51 - to pass window TI
68:54 - clock and the direction which is left
68:57 - okay so we're checking all right did we
68:58 - press key down if we did let's check the
69:00 - key that we pressed if it's equal to K
69:02 - left which is the left Arrow key you can
69:04 - also do like k a if you wanted to do the
69:07 - a key so Kore a but in our case we want
69:10 - the left Arrow key which is denoted by
69:12 - this then we're going to call the move
69:13 - tiles function pass the window pass the
69:15 - tiles pass the clock pass the direction
69:17 - of left let's copy this four times and
69:20 - handle the other directions Okay so if
69:24 - the key is right then we just change
69:27 - this to
69:28 - be right in lower cases otherwise we'll
69:33 - do
69:35 - up and down and then adjust this so
69:39 - that's up and that's down okay so now we
69:44 - have all of the directions however only
69:46 - left is going to work right now so let's
69:48 - go here and let's move left and you'll
69:52 - notice that they merge together and we
69:53 - saw a new four got added to the screen
69:55 - now when I press left you'll see that
69:57 - even though there's no movements
69:58 - happening a new thing will add onto the
70:00 - screen and you can see that as we move
70:02 - them they will move and they will merge
70:05 - accordingly okay so we can only
70:07 - currently move left and you'll see that
70:09 - now at this point the game's over
70:10 - because we can no longer move or merge
70:12 - any more tiles although I guess we could
70:13 - go up or down or whatever but in this
70:16 - case that's fine okay so that's it for
70:18 - left now we just need to handle the
70:20 - movement in the other directions and
70:21 - then we're done so to move in the other
70:23 - direction we pretty much just need to
70:24 - copy all of this and then adjust it for
70:26 - the different directions so let's go
70:28 - with right now so we're going to copy
70:30 - all that and paste this inside of here
70:32 - so to move right is going to be very
70:34 - similar we're going to keep the column
70:35 - key the same we're going to change this
70:38 - to be true because now we want to sort
70:39 - in reverse order the Delta now is going
70:42 - to be positive so moving in the right
70:44 - direction and the boundary check is
70:46 - going to be if the columns is equal to
70:47 - column minus one because that is going
70:50 - to be uh the kind of right boundary
70:52 - right if we're equal to whatever the
70:53 - number of columns is minus one well then
70:55 - we're in the last column now getting the
70:57 - next tile we're just going to add one
71:00 - not subtract one and now the merge check
71:02 - will look a little bit different so here
71:04 - we're going to change the sign to be
71:06 - less than and we're going to subtract
71:08 - the move velocity cuz now we're moving
71:10 - right and now for the move check again
71:12 - we're going to need to adjust that as
71:14 - well so this is going to be tile dox
71:17 - plus the rectangular width plus the move
71:21 - velocity is less than the next tile dox
71:26 - okay so we kind of just flip this around
71:27 - again because we're moving right that
71:29 - should now handle right and then we're
71:30 - going to say sealing is equal to false
71:33 - because we actually want to round down
71:34 - when we're moving to the right side okay
71:37 - let's run this and let's check left and
71:39 - right so we can now move to the right
71:41 - and we can merge as well as moving to
71:44 - the
71:45 - left okay looks pretty good obviously we
71:47 - could you know make the movement more
71:48 - fluid but I think this is actually
71:50 - pretty good so far okay let's see what
71:52 - happens if we go and merge and you see
71:54 - now that game is done all right so let
71:58 - us now do the up and the down okay so
72:04 - how do we do this well for up we're
72:06 - going to copy the exact same thing and
72:08 - actually we'll copy it from left because
72:11 - it's going to be a little bit more
72:12 - similar to that one and paste that here
72:16 - now for the sort function we're now
72:17 - moving up and down which means rather
72:19 - than using the column we're going to use
72:21 - the row now for reverse
72:24 - this is going to be false as well and
72:26 - for the Delta we're going to change this
72:27 - now so it's going to be zero and it's
72:28 - going to be negative move velocity
72:30 - because we're moving up in the y
72:32 - direction for the boundary check this
72:34 - now will be row not column so if we're
72:36 - at the zero with row that means we're at
72:38 - the top of the screen and when we get
72:40 - the next tile we're looking above so
72:42 - it's going to be row minus one and then
72:44 - the call will stay constant for the
72:46 - merge check now it's going to be similar
72:48 - but this time we're moving up right so
72:50 - rather than using X we're going to have
72:52 - to use y so we're going to say
72:55 - tiley is greater than next tile. Y and
72:58 - then this will be plus the move velocity
73:01 - for the move check similarly again we
73:03 - need this to be y so we're just going to
73:05 - adjust this so that rather than uh X
73:08 - it's Y and we're just going to change
73:10 - from rect width to rect height okay if
73:14 - we're sealing that's going to be true as
73:15 - well and now we're going to copy this
73:17 - and we're going to do the same thing for
73:19 - down okay so down this time reverse is
73:22 - going to be true cuz we're moving
73:24 - downwards the move velocity is going to
73:26 - be positive the boundar is going to be
73:28 - rows minus one when we look at the next
73:31 - tile we're looking down a row so we're
73:33 - going to add one and for the merge check
73:36 - again slightly more adjustments here so
73:38 - we're going to say tile. y we're going
73:40 - to change the sign and this is going to
73:42 - be less than the next tile. y minus the
73:45 - move velocity and for the move check
73:49 - same thing it's going to be next tile
73:51 - doy we're going to change the sign and
73:53 - and we're actually going to take this
73:55 - and we're going to put this on the other
73:57 - side okay so we're going to go like that
74:00 - plus the recti plus the move velocity
74:02 - less than the next tiley and the ceiling
74:05 - is going to be false okay now if we run
74:09 - this we should have a finished game so
74:12 - let's go ahead and do this and you can
74:14 - see that we can move up we can move down
74:16 - we can move to the right and we can
74:18 - merge our tiles and we can play the
74:21 - famous game of 2048 I don't know if if I
74:23 - quite know the strategy maybe as well as
74:25 - some of you guys but there you go
74:28 - functioning game now as I kind of play
74:31 - through this I will mention that there
74:32 - are a few like kind of tiny little bugs
74:35 - or things that you could adjust here for
74:37 - example it doesn't handle when the game
74:39 - is finished that's actually something I
74:40 - intentionally wanted to leave for you as
74:42 - homework we already kind of set it up so
74:44 - it should be fairly straightforward to
74:45 - add it and there's a few other like kind
74:47 - of small movement things that you might
74:49 - notice if you play this a long time but
74:51 - overall I think it's pretty good and
74:53 - it's not really worth it to fix them
74:54 - right now because it will add a
74:55 - significant amount of time to the video
74:57 - and I think most of you are going to be
74:58 - pretty happy with this implementation
75:01 - that we currently have now another thing
75:03 - to note is that if you get too high up
75:05 - you're going to run out of colors so if
75:07 - we look at this here I only added uh my
75:10 - quick math is what like 10 colors nine
75:12 - colors so that means we're only going to
75:13 - be able to go up to two to the exponent
75:15 - 9 or actually I think two the exponent
75:18 - yeah two the exponent 9 so you're going
75:19 - to need to add some more colors if you
75:21 - want to handle larger values than what
75:23 - ever two the exponent 9 is I don't
75:25 - actually remember what that value is so
75:28 - uh you can add more colorss you'll see
75:29 - that you'll get an index error if you go
75:31 - above that value but that's a pretty
75:32 - easy thing to fix okay a reminder all of
75:35 - the code will be available from the link
75:36 - in the description I hope you guys
75:38 - enjoyed this video if you did make sure
75:40 - to leave a like subscribe to the channel
75:42 - and I will see you in the next
75:44 - [Music]
75:51 - one

Cleaned transcript:

hello everybody and welcome to another Python tutorial where I'll be showing you how to build the game of 2048 in Python now this game was one of my favorite games as a kid and it's actually very interesting to code out I won't lie to you it is a little bit complex but I think that's what we actually make a great video I'll teach you some more advanced python techniques and how you can actually structure a game like this so we'll go through all of the steps coding out the grid combining the tiles Etc and by the end of this video you'll have a fully finished game and you will have learned quite a few python features last thing to mention this video is not designed for complete beginners you should have some knowledge of python already but don't worry if you don't know pame which is the graphics Library we'll be using here anyways with that said let's dive into the video and learn how to build 2048 in Python all right so let's begin here by just walking through at a high level exactly what it is that we need to do and kind of come up with a bit of a plan before we just jump into to the tutorial so as you can see here we have a grid right we actually have a 4x4 grid so we have at most 16 tiles that can be inside of the grid now these tiles can either be twos or fours we always start out with two twos on the screen and then anytime we make a move we will add one tile to the screen that will randomly be a two or a four when the tiles have the same values and they hit each other so in this case if I go down they'll merge so you can see that we had those fours turn into Eights pretty simple in terms of the rules here and eventually you will lose the game if there's no more room on the screen to add more tiles and you can't merge any of them together now this might seem like a simple game but it's actually a bit complicated because of the movement of these tiles and making it looks smooth and animated so what we'll Begin by doing is setting up the general grid we'll draw all of the lines we'll pick the different colors we'll start being able to generate some different tiles and then what it will get a little bit more difficult is when we need to move and merge the tiles together so for now let's start by setting up the screen we want to work on actually creating this grid system that you see here and then having some representation for our different tiles so we'll pick the different tile colors Etc kind of get the drawing and hook up some of the different functions once we've done that then we'll actually go over to the Whiteboard and I'll explain to you exactly how we do the movement of the tiles and some of the more complex logic which I think is really interesting and you guys will get some value from so let's hop in to our code editor here I am using visual studio code feel free to use whatever you would like now the first thing we need to do here is install the P game module which is what we're going to be using for all of our Graphics so we're going to go into our terminal and in this case I'm on Mac so I'm going to type pip 3 install py game obviously this assumes you already have python installed now that should install the py game Library I already have it installed so I'm not going to run this command if you're on Windows you can try pip install py game if you're on Linux it'll be pip 3 install P game and if none of those work you can try python hyphen M pip install P game or Python 3 hyphen M pip install py game I also have two videos that I'll leave on the screen that will show you how to fix this pip import so for some reason it says pip is not a valid command follow those videos and they should show you how to install pame okay now that we have pame installed we just want to test this so I've opened up a new file here in vs code and we're going to start by just importing pame so we'll import pame and then we'll simply run our file and we'll just make sure that we don't get any errors here it says hello from the pame community which tells me that we are good to go okay so now that we've imported pame we'll import a few other modules that we're going to need to use so we're going to say import random and import math because we're going to need those and then we are going to say py game. anit this will just initialize all of the different features that we need now that we have this what I like to begin by doing is defining some different constants on my screen let me just make this a little bit bigger so we can read it it easier and these constants are values that are not going to change but that we'll need throughout the rest of the program so we'll Begin by writing those variables and we do these in capitals to represent that they're constant so first we're going to set the FPS now the FPS is the frames per second and this will allow us to dictate how quickly the game is running and to regulate the speed on different devices so we're going to type FPS equal 60 we then need to specify the width and the height so I'm going to say width comma height equals 800800 because I just want this to be a square we then are going to determine the row size so we're going to say rows is equal to four and columns are equal to four and what's nice about this approach here is later on we can very easily change the width and the height and we can adjust the number of rows and columns we want if we want to make the game more complex or a little bit different now the next thing we need to do is determine how large a tile is going to be or one of the rectangles is going to be that's inside of our grid so the way we do that is we'll say the with all capitals rectangular height is equal to the height of our screen divided by the number of rows that we have right in this case we have a height of 800 four rows meaning each tile will be 200 pixels tall we're then going to say our rectangular width is equal to the width integer divided by The Columns the reason we're doing integer division is so that we get an integer rather than a floating point value now there's a few colors that we're going to Define that we'll need for right now so we're going to say our outline color is going to be equal to kind of a nice gray now I've already found these RGB colors so I'll just type them out and you can copy them with me so this is 187 173 160 whenever you're defining colors in pi game you have the option to use RGB which stands for red green blue first value is the amount of red second is the amount of green last is the amount of blue these values can be in the range of 0 to 255 if we had 0 0 0 that would be black if we had 255 255 255 that would be white next we're going to say in all capitals again the outline thickness is equal to and then this will be 10 we can adjust this later this is how thick the lines will be on the screen and then we're going to have the background color and this will be equal to a different shade of gray which will be 205 192 180 don't worry too much about the colors again I already just found these next we're going to say font color this will be the color of the text on the tiles I'm going to go 119 110 and 101 for kind of a blackish grayish shade there okay so now that we've defined some of our constants we're going to create a py game window so whenever we're coding in P game we have a window the window is where we can draw objects and it's really representing the canvas of our screen so we're going to say in all capitals if I could toggle the Caps loocks button for some reason is not working okay window is equal to py game. display. set underscore modee and inside of here we're going to pass a tupple that contains the width and the height okay so this will actually create a pame window for us so again py game. display. setor mode then pass a tble make sure you don't forget the enclosing parenthesis there and by the way all of this code will be available from the link in the description in case you are getting confused or you want to copy a specific area next we're going to say py game. display. setor caption this will be the title of the window and I'm just going to call this 2048 which is the name the game okay last we have two more constants that we need we're going to have a font now a font is something that we can use to render text onto the screen so we're going to say font is equal to pame do font dot with a capital Sy font like that then we can put the name of the font I always use comic Sands we're going to put the size of the font which will'll go with as 60 for now and then we'll say bold equals true because we want the Bold version of the font lastly we're going to define a VAR variable here we'll use later called move velocity this is the speed at which the tiles will move and I'm going to go with 20 pixels per second okay so that is most of the constants that we need we Define our FPS width height rows calls rectangular height and width and then the different colors we need as well as set up the P game window just to make this a bit cleaner I'll move this down here so it's the last line we have our font and we have our move velocity and now we are ready to start coding out some more components of our game so the first thing we usually do when we're working with P game is we create something known as the main Loop now the main Loop is an event Loop that's going to run constantly and check for things like button presses exiting the screen it's essentially what will just run the game okay it's the main Loop that's handling all of the different events so we usually put that inside of a function so we'll simply say Define Main and then what we need to do is obviously call this function so we're going to go down to the bottom of the screen and we're going to say if underscore name is equal toore maincore uncore then call Main and what we're going to going to do is actually call this with the window object and we're going to take in window as a parameter here inside of the main function so we're just specifying okay where do we want to run the game well we want to run it on the window that we just defined as a variable here and if you're wondering what this does this simply means we are only going to execute this function if we are running this file directly I'm not sure if that makes a ton of sense but essentially if another file were to import this file this would not run whereas if we actually run this file directly which is what we'll be doing then this will be true and we'll run this window that's all this name equals main does just protects you in case you're reusing some functions in here and you don't want to actually run what's known as the main line okay so there we go we have main now inside of main we need to create a loop that's going to continue to run so the first thing we're going to do is set up a clock object this will allow us to regulate the speed of the loop so we're going to say pame do time with a capital. clock block we're then going to have a variable called run equals true which will set to false when we want to exit the loop we'll then say while run and we'll say clock. tick and then we're going to tick based on the frames per second which is this now this tick will just make it so this wall Loop is only going to run at most one time every 60 seconds it could run less than that but the reason we put this here is so that people that are running on different speed of computers don't have the game running at a different speed if you didn't have this clock here what will happen is you'll simply run the loop at whatever the fastest speed is you can run it at which means someone on a really powerful computer is going to see the game a lot faster than someone on a slow computer so always good idea to have this clock now that we have the clock what we're going to do is create a simple event Loop that's just going to listen for all of the different key presses and events that could occur so to do that we're going to say for event impy game. event. get this will Loop through all of the events that have occurred and we can then then check the event and handle it so we're going to say if the event. type is equal to pame dot with all capitals quit then we will say run in lower cases is equal to false and we'll break out of this Loop now what that's going to do is simply say okay if we press the exit button that's what this quit event is we're going to set run equal to false so this Loop will stop running we're going to break immediately out of this event Loop so we don't handle it and then what will happen is we'll come outside of the loop and we'll run the command py game. quit which will simply quit the pame window for us so that is now the main Loop and what should happen is if we run this code we should actually see a window appearing and if we press the x button we should be able to cleanly exit so let's go ahead and try that and you can see we get 2048 we get the window of our size 800800 and I can click exit and I cleanly exit the code all right so now that we have that let's move on to doing some drawing operations so that we can actually see some stuff up here appearing on the screen now I typically like to separate the drawing from the event handling just so it's a little bit cleaner so the way I'll do that is I'll Define a function here called Draw you'll notice that in my code I'll write a lot of functions just to make sure everything is clean readable and easy to debug and we can quickly figure out where something's going wrong by just isolating it to a specific function this is good practice and something you can kind of take note of while I'm coding so in the draw function I'm going to take a window and what I'll do for now is simply set the background color and update the screen so I'm going to say window. fill and this allows you to fill the window completely with a background color so we're going to say window. fill and then background color if we look at background color here this is what it is so we're essentially just kind of painting the entire window this color then what we can do is say py game. display. update now the way the pame works is we do all of these drawing or paint events and then as soon as an update is called we'll actually apply all of those on onto the screen in the order in which we wrote them so what that means is that we're always going to fill the screen first because what that will typically do is it will actually override whatever was on the screen by before Sorry by painting over top of it then we'll do any other operations to draw the updated screen and then we'll update and then when we do the update we'll actually see that being performed on the screen I know it's a little bit abstract right now but it's just like we do all of these paint operations then we update then they're all applied at once rather than happening one at a time so now we just need to call that function so inside of this Loop make sure you're inside of the wall Loop here at the bottom we're going to say draw and we're going to pass that window object and now we should be getting the background color on our screen so let's try this out and you can see that now it fills with the background color okay great so now that we've done that we want to start drawing the grid so to draw the grid we're going to write a different function and we're just going to say draw underscore grid like like that okay and inside of here we'll take the window object again okay so for drawing the grid what we'll need to do is we'll need to draw horizontal and vertical lines to represent the separation between tiles and then we want to draw kind of a border around the entire screen so that we get that nice border effect so let's begin with the border to draw the Border we can simply draw a rectangle that's positioned at the edge of the screen so to draw a rectangle say pame do draw. rectangle like that with re C t for this we need to pass where we want to draw it so we want to draw it on the window we need to pass the color we'd like to draw it you can see I'm getting the auto complete here so we want the outline color and then we need to pass a rectangle that represents where we should draw the rectangle so the way that we pass a rectangle is we give the x coordinate y coordinate and then the width and the height of the rectangle now the X and the Y represent the top leftand corner where we want to start drawing the rectangle from now this will get into the Pam coordinate system which I'll discuss in a second but let's go 0 0 and then width and height now as well as that we have the option to either have the rectangle be filled completely in or to be an outline so in our case we want it to just be an outline we don't want it to fill in entirely we don't want to draw a s solid rectangle Sur we want one that's Hollow so what we'll do is pass what's known as the width or the thickness so I'm going to say width and then this is going to be the outline thickness which in our case I believe is 10 pixels so before we go any further let's draw this on the screen just so that we can see what it looks like so let's go here and in our draw after we draw the background we're going to say draw grid and we're going to pass the window so let's run this now and you should see that we're getting kind of this outline it's a little bit faint on my screen but I think you can probably see it maybe not with OBS recording but I can see it at least here and we do have an outline filling the screen okay so that's how that works now actually let's run this again one thing to note here when we're talking about coordinates and XY values in pi game we always start at 0 0 which is the top left hand corner of the screen so rather than starting at the middle which is typically 0 0 it's the top left meaning as you go to the right your x value increases and as you go down your y value increases so if we look at the bottom right hand corner that would be 800800 in terms of the coordinate grid in pi game so just keep that in mind um you you'll see as we go through here how we kind of do the positioning Okay so we've drawn that now we actually want to draw the outlines uh sorry so like the grid lines right so we can start by drawing the horizontal lines so we can say four row in range and then in all capitals rows so we're going to draw a line for every single row that we have and what we need to do here is simply calculate the y coordinate of the row or of the line Sur that we want to draw so we're going to say Y is equal to row multiplied by the rectangular height now the way this will work is we'll start start with row being equal to zero and then it'll become 1 2 3 and then it will not be equal to whatever the last row is which is fine and in fact we can actually do one comma rows because we don't need to draw the very top line because that will already have been drawn by the rectangular outline that we drew anyways what we're going to do here is draw a line the line will go from the x coordinate 0o to the width of the screen and then what we'll do is adjust the ycoordinate so we're moving the line down every time the loop happens so we take whatever the height of one tile is and we multiply that by the current row and that tells us the ycoordinate for this line so we're going to say pame do draw doline similarly here to the rectangle we're going to pass a window we're going to pass the outline color and then we're going to pass zero and then y y is our Dynamic value and when we draw a line we pass the starting position and the ending position so the two points essentially for the line to be drawn between so next we're going to say width and then y so so we're constantly always going to have the line starting at 0x and with X so that way we're filling the entire screen horizontally and we're just adjusting the ycoordinate so vertically where that Line's going to be drawn now again we need to specify the thickness we're going to put the outline thickness here also known as the width of that line so now if we actually go here and refresh you'll see that we get our vertical lines appearing or sorry horizontal lines so now we can copy this exact same thing and paste it here and just adjust it for the vertical lines so we're going to say for column in range one comma calls now this is going to be column times the rectangular width and we're going to change this to be X so now we're going to keep the Y values constant and adjust the X so this is going to become X and then zero and this is going to become X and height so you can see that we always have two fixed values right where we want to draw between and then what we're adjusting is the X position whereas here we were adjusting the Y position and where we make that change is with call and the rectangular width versus row and the rectangular height now in this case the rectangular height and width are the same uh however they could be different which is why I'm doing this in two Loops because if we wanted to have actual rectangles not squares then this code would adjust to that appropriately okay so let's run this and you'll see here that now we get our grid okay so now that we have our 4x4 grid what we want to start doing is actually representing tiles in those grids and then drawing the tiles on the screen once we're able to draw the tiles on the screen then we can start moving them on the screen again uh as I said this a bit more complicated so we're going to create a class here called tile now I want to use a class just because there's some methods related to each tile which will fit nicely inside of this object or inside of the class um so it just makes it a little bit cleaner so as a class variable I'm going to specify colors now what I'm going to do is paste a bunch of colors in here I don't want to write all of them out because it's a little bit tedious and these are the exact same colors that are used in the real 2048 game now these colors represent from like 2 4 8 16 32 64 Etc so as we go up it just multiples of two or whatever double the last value is okay so that's kind of how I'm doing it I'll show you how we index the colors in a second and if you want this list of colors obviously you can pause it and type it out or you can just view the code that's Linked In the description and rather than looking everything you can just copy this colors variable okay so again in the description you can find all of the code there should be a GitHub link and just go ahead and find the colors and paste them into your code if you're following along with me step by step so next we're going to define the initialization for our tiles so we're going to say Define uncore nit uncore uncore we're going to say self value row and column now for each tile we need to know what the value of the tile is so is it a two is it a four is it an 8 Etc we also need to know its position positioning in the grid so what row is it at what column is it at and that will allow us to determine the X and Y position of where we want to draw the tile it also allows us to know what tiles we can merge with so that's why we're storing that value so we're going to say self. Val equals value and create that attribute and we're going to say self. row is equal to row self. column is equal to column and then at the same time we're actually going to set what the X and Y coordinates are for drawing this specific time so we're going to say column times the rectangular width and self.y is equal to the row multiplied by the rectangular height now how does this work well if we were in row0 column Z then we would simply start drawing this tile at the position 0 0 right that's the very top left hand corner of the screen if we were in row 0o column 1 then we would want to start drawing this from if I can calculate this correctly a y value of zero but an x value of 200 because that's where we want to draw the tile that's in that First Column when I say First Column I really mean the second column it's because in programming we're starting indexing or starting counting at zero you'll see what I mean and actually I can just run this to explain it to you like if we want to draw a tile that's where my mouse is here I hope you can see it in the position 1 one so 1 one is you Row one column one as opposed to 0 0 here then what we're going to do is start drawing it at the top leftand Corner position of this which is what we're calculating when we're doing the X and Y so we multiply the column by the rectangular width which brings us over here we multiply the row by the rectangular height which brings us here and then we would draw the rectangle in this Square you'll see what I mean as we go through the code but hopefully that's an okay explanation okay so now that we have the initialization and we have some values that we need we want to start writing some other methods related to this object so before I write all of them we'll specify what they are so we're going to say well we want to be able to get the color that we're going to draw this tile in and that's going to be based on its value we also want to be able to draw this so we're going to say self and window because that's what we need to draw and what else do we need to do we need to be able to move this so we're going to take in and some Delta which is how much we would want to move this by and I don't know what just happened there on the screen and then lastly we'll have another method called set position which will allow us to actually determine let me just pass this here what position this uh tile is currently in while we're moving the tile we'll use some of these methods later on but I just like to stub them out so we know what we're about to write so let's begin by writing the get color and the draw methods which are the ones we'll use for now so again we need to be able to determine what color out of this list of colors we're going to use for the tile and that's going to be based on what the value of the tile is so we need to have some kind of function that can essentially give us the following values so we have a value of two we want to get the zeroth index which is the first color which is what the color of the value two should be when we have the value of four we want to get index one when we have the value of eight we want to get index 2 and when we have the value of 16 we want to get index 3 so you can follow this pattern here and you can actually come up with an equation which will allow you to get this specific mapping of value so anytime the value of X or the input doubles we want to then get the next value uh in our sequence hopefully that makes a bit of sense I'm sure this is bringing you back to math class well how do we do that well we have this wonderful thing called a logarithm which will actually allow us to figure out what the power is that's required passed on some value to get some other value right I'm sure you guys are familiar with logarithms I'm not going to explain how the logarithm works and that was pretty poor explanation but we're going to say the color index is equal to the math of log base 2 of our current value now if we look at the logarithm function we can see that if we pass F of two that actually gives us one however we want this instead to be zero so what we'll need to do is simply subtract one from whatever the value of the logarithm was that's returned now just to ensure we're always getting an integer value and not a floating point value we'll first convert the result of the logarithm to an integer it will always be a whole number anyways but this will just strip off any decimal point that might be there and then we'll subtract one so now we have a function that takes in whatever our values are and Maps it to the correct index in our colors list so now that we have the index we want to access the color so we'll say color equals self. colors at the col index okay and then we will return the color like that so this now will give us the correct color based on the value of this tile okay now we want to draw the tile on the screen now when we're drawing the tile on the screen what we need to do is draw a rectangle for that tile we also need to then draw on top of the rectangle the value of the tile so what we'll Begin by doing is drawing the rectangle and then we will draw the text on top of it so we're going to say that the color we want is equal to self. getet color and this is going to tell us the color that the rectangle should be we're then going to draw the rectangle so we're going to say pame do draw do rectangle and we're going to draw it on the window what color do we want to draw it well the color that we just got and then we want to draw this at the self.x position the self.y position and with the rectangular width and the rectangular height and that's it we want this to actually be a solid rectangle so this time we won't provide a width which means it will fill in the entire rect that we provided here now that we've done that we want to generate some text that we're going to draw in the middle of the rectangle so to do that we're going to use our font object so we're going to say say text is equal to font. render so the process whenever you want to draw text is you use this font object and you render some string into a surface is what it's called that you can then put onto the screen so we're going to say font. render and what we pass for this is the value so we're going to put an F string here or actually we can just do string of self. Val so we convert our numeric value into a string so that we can actually draw that we're going to pass one for something known as anti aliasing don't worry too much about that and then we need to specify the color now the color is going to be the font color that we specified earlier now that we have the text object what this has actually done is created a surface that contains the text and now we need to specify where on the screen we want to put the text so to do that we say window. blit blit is how you put a surface onto the screen so it's a bit different than drawing the rectangles now what we pass is what surface we want to put on the screen in this case I want to put the text surface and now we need to place this in the middle of the rectangle now to place this in the middle of the rectangle we need to determine the top leftand Corner position of where we should start drawing the um what do you call this here the text so in order to do this there's a little bit of math that we need to perform I don't know if I have a drawing tablet or maybe an ink thing that I can use here on Mac let's see if there's like a drawing surface or something okay I just found like an online drawing program that we'll quickly have a look at here just so that you can kind of see what I mean so let's say we have our rectangle right kind of a sketchy rectangle now we want to draw our number in the middle of the rectangle what we need to do is figure out the location that we want to draw it in now naively you might think okay well if I want to figure out the XY position let me just figure out whatever the XY position is of this and then we'll just take whatever the width of the rectangle and we'll start drawing it directly in the middle right so you'll just take okay we have W and we'll just take W over 2 and that's where we'll start drawing it the issue is if we do that then we're going to start drawing here and the number is going to go to the right because it's the top leftand Corner that we're drawing from so we actually need to do is offset this by the by half the width of the object that we're drawing so what I mean by that is we want to draw like this right so let's say the number is kind of in this box like in this bounding box we want to find this location that's where we want to start drawing the number from so the way we actually do that is let me just clean this up a little bit I know it's very messy here we have some W right this is the width of the rectangle so we start by taking W over 2 which is going to give us this position so w over 2 we then want to make sure that the number is perfectly centered so we say okay well we have the bounding box of the number and this has some width as well we can just call this uh I don't know a okay so what we actually do now is we take a over 2 and we subtract that from W over 2 and that gives us this position here which is the top leftand Corner position of where we want to start drawing this object from so quick clarification right we go to the middle of the screen we then subtract from half the width of the object we're going to be drawing and that means when we draw the object out it will be perfectly centered in the middle of the screen the same thing applies in the y direction so that's exactly what we're going to do here now I know that was really sketchy but hopefully that's an okay explanation all right so now that we have that let's start doing our little bit of calculation here so we're going to say okay well we'll start drawing this at the self. exposition of this current rectangle and then we're going to add to that what we just specified so we're going to take whatever the rectangular width is okay because that's the width of the rectangle that we're drawing inside of and we're going to divide that by two that gives us the middle of the rectangle but now we need that top leftand Corner position so we're going to say text. getet uncore width this gives us the width of the text object and then we're going to divide that by two this now specifies that this is the X position that we want to draw now next we're going to do the Y position so we're going to say self.y plus and this is going to be the rectangular height if we can get our cap locks to work some reason my caps locks button doesn't want to work very well so this is going to be the rectangular height over two minus the text. getor height over two okay and that's all that will actually blit this on to the screen for us okay so now we have the ability to draw our tiles now also notice the order in which we did this we first drew the rectangle and then we drew the text on top of the rectangle it's important you do it in this order otherwise the text will be hidden because you'll be drawing the rectangle after so now what we'll do is call that function so inside of our draw function we're now going to take in all of our tiles now we don't yet have any of those tiles but we will create them in a second and what we'll do is before we draw the grid we'll draw all of our our tiles and that way the grid lines Will Go On Top of the tiles and it will separate them and make make it uh pretty easy to see so we're just going to say for tile in tiles and then we'll just say tile. draw and tiles is actually going to be a dictionary so I'm just going to say tiles. values I know seems a bit weird because we haven't yet created the tiles but we'll just do a quick test and I'll show you kind of how it works all right so now we have that for drawing now we just need to make some tiles then pass those to our draw function so we're going to say tiles is equal to a dictionary the reason we're going to use a dictionary is that we want to be able to index or locate all of the tiles very quickly by their row and their column so there's multiple ways that we can go about indexing our tiles or storing them but what we want to come up with is a key that kind of represents the tile and then the value will be that tile class itself that we can index in here so to do that we'll simply say the following for now we're going to say 0 0 which is representing the row and the column so like you could have zero hyphen zero but in our case we know we're always going to have uh what do you call it less than 10 or on digigit rows and columns so we just go 0 0 so we'll say 0 0 colon and then we'll create a tile now for a tile we need a value a row and a column so let's go with a value of four and then let's go with a 0 0 for the row and for the column okay so now let me just change this to give you another example let's say we have the tile 128 now we want this to be at row two column Z so that would change this to be 20 0 okay the way this works again is that we have a twodigit string the first digit represents the row the second digit represents the column and then that's associated with the tile object itself that we actually want to be representing and drawing this way we can always index a tile given its row and column and we can find it instantly inside of the tile's dictionary this is opposed as if we made a list if we made a list and we wanted to locate a specific tile we need to potentially iterate through all of the tiles in the list and check the rows and columns to find the one that we want whereas here we can always have instant access to a tile so kind of an efficiency thing that's why we've written it this way okay now we're going to pass tiles to the draw function and just make sure they draw correctly on the screen so let's run this and we go on errow it says drawing is missing one uh required positional argument window okay so we're going to go here to tile. draw and pass window all right let's rerun this and now we should get our tiles on the screen and we get them at the positions we specified right so this was what 20 and 0 0 we can do one more tile just as a test so let's go here and we'll say maybe 02 and this will be with a tile and this will be let's go 64 and then 02 okay let's run and you see now we get the 64 tile appearing in the correct position okay so that's great however we don't want to actually start our tiles with some fixed ones on the screen we want to randomly generate two tiles that have the value two that will begin as our tiles right so let's write a function that can do that let's say generate tiles now for this all we're going to do is just randomly pick two positions that we can put the tiles um in okay and we'll just make sure they're not the same so we're going to say tiles is equal to an empty dictionary we're going to say 4 underscore in range two if you're unfamiliar with the underscore this is a placeholder value that we can use when we don't actually care about the variable we put here normally you do something like 4 I in range two but in my case I don't actually want to use I I just want to do something two times so I'll just say 4 underscore in range two we're now going to say row column is equal to and we're going to call a function which is get random position and we're going to pass our tiles and then we're going to say tiles we're going to do an F string and this is going to be at row column if we can do this is equal to a tile and then this is going to be two row call we're then going to return our tiles okay let me slow down a little bit to explain what we just did so we have an empty dictionary where we're going to store our tiles we're doing something two times and what we want to do is generate a random row and a random column to place our time inside of now we want to make sure that we're only doing this for a tile that does not yet exist right we don't want to create a tile that's in the place of another tile so that's where this function will come in which we'll write in a second it will make sure when we are randomly picking the row and column we don't pick one that already exists then what we're doing is saying okay tiles well this is a dictionary so we need to set the key the key is going to be equal to first whatever the row is and second whatever the column is so we use an F string available in Python 3.6 and above which allows us to embed inside of curly braces here any values that we want to be converted to a string so we're saying okay well we just want the row and the column which are numbers they're going to convert it to a string that's going to give us the correct key and then we're going to make that equal to a tile object which has the value of two because we always want to start with twos in the row and the column okay now let's write our get random position so we're going to say get underscore random underscore pause this needs to take in the tiles that we make sure sure that we are not placing this in a position that already exists so we're going to start by saying row equals none column equals none because we don't yet know what we want and now we're going to say while true and we're going to continue to randomly generate rows and columns or a position for this tile as long as this position already exists so what I mean by that is as soon as we find a position that does not yet already exist inside of our tiles then we will use that one otherwise we're just going to keep randomly generating positions so we're going to say row is equal to random. random range and this is going to be in the range zero to rows when we use Rand range it means we'll generate up to but not including whatever the value is here which is four so we'll generate a random value between 0o and three inclusively we're then going to say column is equal to random. Rand range and then zero columns okay so we're just picking what the random position is for what it should be what we're going to attempt and then we're going to say if and same thing we're going to do an string here row column is not in and then we can just say tiles like that then we're going to break now this is another advantage of using the dictionary we can instantly check whether or not this key exists inside of the dictionary because of that property of the dictionary we have instant access to see okay does this key so does this position row column already exist if it uh does not sorry which is what we're checking here then we're going to break right so then if we break we're going to return the row and the column from the function that we generated otherwise we're going to continue to do this until this condition is true allowing us to break out meaning we found a random position great okay so now that we've done that we will go over to our main and we'll say tiles is equal to generate tiles and that should generate two random tiles on the screen for us so let's try this now and you see that we get a randomly generated tiles let's run it again we get more randomly generated tiles Etc okay so there we go we've now generated the tiles and placed them on the screen okay so at this point we've written quite a bit of code and we have the main structure of the application setup now what we want to start doing is moving the tiles around so let me hop over to the drawing tablet and explain to you that process it is a little bit complicated then we'll begin implementing it all right so I'm on the drawing tablet now and I'm going to explain at a high level what it is that we're about to do now I can't cover everything conceptually here but I'll give you a sense of how to think about this problem now if you are someone who likes these problems feel free to try to solve it on your own uh first of all but you will see that it's a little bit complicated because of the fact that we actually want to animate the tiles and we want to move them on the screen so moving them is actually the difficult part doing the merges is not so hard to figure out what the new position should be it's more about getting to that new position and how we iterate and move so that it looks smooth anyways let's have a look here so we have a few different edge cases that we need to handle and we can go through them one by one so let's say we have the number two this is our tile and we decide to make a movement to the left keep in mind all the movements effectively are going to be handled the exact same so we can just look at a case in which we're moving to the left but the exact same thing would apply if we're moving to the right there's just a few variables that change so we're moving to the left and we have this tile now there's a few things that can happen the first thing that can happen is there can be nothing to the left and we can simply shift the tile that's the easiest case right there's nothing to the left of us so we just move the tile until we hit the Border pretty straightforward we take the X position and we just shift it over and then once it gets inside of this Square here we just change the tile's position so then rather than being at 1 one it's now at 1 Z okay so that's the important thing to also keep in mind here we have an X and A Y which is the location in which we're drawing the tile and we also have a row and a column which will represent with r and C which tells us the current location of the tile in the grid so these values are linked together however while we are moving the tile the r and the column is kind of in between right for example at one point in time my tile might be in between two rows and columns in that case we don't know its exact location and we need to wait until it reaches some kind of boundary point to then reset the row and column to be the correct position based on the X and Y value so I just want to say that one more time because I understand it's a little bit confusing we're going to have a tile that's going to be moving could be up right whatever while it's moving this row and column we don't necessarily know what the correct value is so at some point we need to adjust this so that it represents where its location actually is on the screen and that's typically when the tile is no longer moving okay so anyways that's kind of the basics there so this is the first case we just simply move the dial over to the left now the second case is when we have a blocking tile that is in the direction of which we're moving so again we're moving to the left that's where we've shifted and now we see that when we move to the left well this tile exists and it doesn't allow us to move so if that's the case we just simply stay put right there's no movement that occurs for either of these tiles now it gets a bit more complicated right where we have this tile here so now in this case we move until we reach a tile that is blocking us okay so obviously I think that makes a bit of sense now the next instance is when we are moving in a direction and we have a tile that contains the same value as us if that's the case we actually want to take this tile we want to move it so it kind of merges with this tile and then we need to update the value of the tile to the left so this becomes four and remove this tile so let's kind of do an X here so we no longer see it on the screen so this is the merge instance now the thing with this is that there's kind of two stages to this merge the first stage is while the tile is actually moving into the position of this tile so to keep things looking smooth we don't just want to instantly merge the two tiles as soon as we see that they are going to merge what we want to do instead is we want to take this tile and we want to kind of move it inside of the other tile and then as soon as it's fully uh emerged in that tile is when we remove it from the screen and then we simply update this one so it now becomes the new tile value so those are those two situations right the first situation okay we know we're going to merge we need to keep moving it so it looks smooth then the second situation is okay we've already moved it inside of the other tile so now we'll merge it together so those are pretty much all of the edge cases again we have a situation in which there's no tile to our left or in the direction of which we're moving we just move the tile we have a situation where there's a blocking tile where there's no movement that occurs and we have a situation in which there's a merging tile where there's two phases the first phase is to move into the square where the merging tile is and then to merge the two tiles and remove the other tile so that's what we need to handle however doing this is a little bit easier said than done because of all the things that could happen for example let's say we have something that looks like this right we have like 2 two 2 two well what we we need to do is actually make sure that we move the tiles in the correct order such that the merges happen appropriately so in this situation where we have four twos we want to ensure that we don't accidentally merge the two middle tiles because if we were to do that we would be left with a result of 2 42 which is incorrect what we want instead although I guess you could Define this behavior however you want is that after we do this Movement we end up with two fours right so we delete delete and we have 44 so what that means is that we need to make sure that we're going to start moving the tiles from the direction in which we're moving so if I'm moving left we're going to check the first tile then the second tile then the third tile then the fourth tile and at one step at a time move them to the left rather than moving the tiles from the right first because if we move the ones on the right then we're going to merge in the wrong order so the merging order is important there's a lot of other factors we need to consider there but I think that's enough in terms of the high level EXP explanation so let us now get into the code and I'll start explaining it and again feel free to pause it Go reference some of the other code if anything's going wrong and ask any questions you have in the comments down below all right so we're back now and we're going to start handling the movement so what we'll do is we'll Define a function move tiles which is going to allow us to move them so we're going to say window tiles clock and Direction and this will be one function that will actually handle the movement of the tiles in all of the directions now we'll start by just doing One Direction dire so you get the gist of it and then we'll handle the other directions which are just slight variant of one of them right so what we're going to do is create a variable called updated equals true and we're going to create something called blocks which I'll Define in a second pretty much this blocks set is going to tell us which tiles have already merged in a movement because we don't want to be merging multiple sets of tiles I can show you an example of what I mean in a second when we actually run the code but we create this set here so that we know which tiles already had a merge operation occur so we don't allow them to merge again which means we don't get this like huge chain of tiles merging in a row which is not how the original game behaves you can obviously change the behavior if you want but that's not what I want to do here okay so now what we want to do is just handle what direction it is that we're moving so we'll just stub a little if statement here and we'll say if direction is equal to left we'll say l if the direction is equal to right and let's just do a pass here we'll say l if the direction is equal to up and we'll say l if after we pass just so that we have a stub there the direction is equal to down okay so now we're handling all of the directions the first Direction we'll go into is left so what we need to do is Define a few functions and variables that we'll use in the main kind of block of our code so this is going to seem very abstract right now when I write this out but just bear with me and I promise you it will start to make more sense so we're going to say our sort function and we're going to use something called a Lambda if I could type this so we're going to say Lambda X and then X do column now remember that we want to move the tiles when we're going left for example from left to right so the first tile we move is the one that's furthest on the left and then we go to the right and then move the tiles in that order that way we merge the correct order so we need to start actually moving from that left side so that means that we need to actually sort the tiles so that we know which tile we should move first because right now our tiles are stored in a dictionary and we're not going to necessarily have them in a sorted order so we're going to take the tiles and we're going to sort them into a list and then we're going to move all of the tiles so that's why I'm setting the key here equal to the column so I'm saying okay we're moving to the left which means we're going to sort the tiles by their column now if you're unfamiliar with this Lambda this is a oneline Anonymous function and it works the exact same as any other function so this that I just wrote right here is the exact same code as this uh oops not Funk Define Funk X and then return x.com okay it's the exact same thing it's just so you can write it in one line and you don't need to define a name for it when you don't need that name okay so that's kind of all that does this is like okay we're making a function this is our parameter and this is what we want to return from the function it only allows us one line but that's fine that's all we need okay then we're going to have reverse equals and this is going to be false now this is going to tell us whether or not we want to sort an ascending or descending order so we could actually change this to just be ASC like that standing for ascending uh or no that's going to look a little bit weird we'll do reverse instead sorry this is just again telling us okay do you want to sort in reverse order or correct order because when we're going to go in the right we want to sort again but we want to sort in reverse order so we start with the largest column Elements which are on the furthest to the right okay next we're going to have a Delta now the Delta is going to specify how much we want to move each tile by each frame in this movement function so the Delta is going to be negative move velocity and then zero so we're specifying how much in the X Direction and how much in the y direction we're going to move in this case I want to move negative in the X Direction which will move us to the left okay so reducing X moves to the left next we're going to have a boundary check now this is going to be a function again and this is going to be Lambda we're going to take in a tile and we're going to check if the tile. column is equal to zero now if the column of the tile is equal to zero that means it's already as far left as it can possibly go so we're not going to move it any further to the left because it's hit the bounds of the screen so again same thing Anonymous function just tells us okay have we hit the boundary or not next thing we need is a function that can get us the next tile so this is the tile to the left of the current tile we need to check that tile because based on its value we're either going to be blocked by it or we are going to merge into it so we're going to say get next tile is equal to a Lambda function and this is going to take in a tile and it's going to say tiles. get and we're going to say f and then row and then column minus one so what we're looking for and sorry this needs to be the tile. row and the tile. column so we're looking for or is the tile to our left the tile to our left is the tile that has a column that's one less than us now we do dot get because we don't know if this tile exists so we don't know if there's actually one to our left or not if there is one this will return that tile for us which allows us to use this indexing scheme otherwise it just returns none okay next we're going to have our merge check now this is a Lambda function again and we're going to take in our tile and our next tile now what this is essentially telling us is whether or not we should merge the tile based on the current movement of this tile because you'll see what we're doing is moving the x coordinate of our tiles until we reach a certain position in which case we then do the merge so we're going to say that the tile dox is greater than the next tile dox and then this is going to be plus the move velocity so what we're checking okay the tile that we currently have so the one that we're moving to the left we're going to check if its Exposition is greater than the next tile's Exposition plus the velocity that uh we're about to be subtracting as we move what this is telling us essentially is okay have we moved far enough left that it now looks like we're inside of that other tile if we have then we can go ahead and merge if we haven't which is actually what this is checking story then we'll keep moving the tile you'll see how we use it a second but this is checking okay are we in the position to merge or not that's pretty much what it's telling us okay next we're going to have a move check now this is going to be for when we're moving and there is a tile to the left of us however that tile is not the same value as the tile that um what do you call it that we're moving so this is going to be Lambda tile next tile and this is going to be tile dox is greater than the next Tilex plus this time the rectangular width plus the move velocity okay so why are we doing it like this now so in this instance if we're moving to the left and we have a next tile we want to stop moving as soon as we reach the border of that tile now the border of that tile is on the right side of the tile that's to the left of us so to get that position we take the next tile dox we add the width of that tile and then we add the velocity which we would be mov moving if we were to continue the move um again you'll see how this works in a second I know it's it's fairly abstract okay lastly we're going to have seal is equal to true now this essentially tells us whether or not we should round up or round down when we're determining the location of the tile after a move I know a lot of code very abstract but these are the different things that will be adjusted based on the direction that we're moving so you can imagine we're moving to the right some of these things are going to change right like the move check the merge check the sort function is going to be a little bit different the reverse function okay so that's kind of what we're doing here in terms of this and then we have some general code which we're about to write which will perform the move based on these functions so this is kind of the cleanest way to write this so what we're going to do is say while updated now the idea is while we've performed some kind of move update we need to kind of update the screen and redraw it so it looks like we're moving as soon as we're in a position where nothing has moved we're going to stop this W Loop so when no update has occurred which is what's going to be indicated by this variable here then we'll break out of the loop so now we're going to say clock. tick and then we're going to tick by FPS and we're going to say updated equals false so it's our responsibility as we go through this Loop to update this variable and make it equal to true if an update operation has occurred so now what we're going to do is we're going to sort the tiles so remember I said we need to get the tiles in a sorted order such that we're moving them in the correct um order so that we get the correct moves so we're going to say sorted tiles is equal to a sorted function of the tiles. values we don't care about the keys we just want the values and the key is going to be equal to a sort function okay like that and then reverse is equal to reverse so the sort function we defined here reverse we defined here we're now using these to sort the tiles in the correct order we're then going to say 4 I comma tile in enumerate and we're going to enumerate over the sorted tiles this simply means get the index of the tile as well as the tile object itself first thing we're going to check here is okay we want to be moving these tiles so we're doing this for every tile right we're going to check if the tile is at the boundary so if the boundary check of tile then simply continue because if we're at the boundary there's no movement that needs to occur for this specific tile so we can move forward next thing we need to do is get the next tile so we're going to say the next tile is equal to get next tile and we pass the current tile that's going to give us the tile that is in the way of which we want to move so we're now going to say okay well if we don't have a next tile so if there's no tile in our way then we can continue to move because we're not at the boundary and there's no tile next to us so let's just move our tile so we're going to say tile. move by our Delta and before I forget let's go and code out this function so move is right up here and the way we move is the following we say self.x plus equals Delta 0 and self.y plus equals Delta 1 and that's it very straightforward again if we go look at our Deltas here you can see that we just have the components of how much we want to move in this case we're just going to move backwards in the X Direction because if we add Z to the existing value here in y doesn't do anything okay so that is move now we get into the more complicated cases so we say all right well if there is a tile beside us we need to check something we need to check first of all is this tile the same value as us so we're going to say LF the tile. value is equal to the next tile do value if it is now we go into those two cases so I don't know what I just did there where we need to determine okay well if it's the same value we're either we're going to be merging with it right so we're either in the process of merging with it or we've just merged like we've moved the tile enough so we're going to say if merge check and then tile if we can type this correctly and next tile then we're going to say tile. move and then Delta so this is checking okay are we in the process of merging if we are we can continue to move the tile now if we are not then we need to do is actually perform the merge operation so the merge operation looks like this we're going to take the next tile we're going to get its value and we're going to multiply it by two we're then going to remove the tile that merged with it which is the one that we're moving so we're going to say sorted tiles. pop at index I which is the index of this tile in the sorted tiles list we're then going to say blocks. add and we're going to add the tile and we we are going to also add the next tile or sorry we don't need to add the tile cuz we just removed it we're just going to add the next tile now what this is doing here is saying okay well we've already okay so what this is doing here is simply saying all right well this tile just got merged with another tile so we want to make sure it doesn't merge again so we're just adding it into the blocks so that we can then use that set to ensure we don't do a kind of double merge operation now where we'll actually use that is right here we're going to say and tile not in blocks and the next underscore tile not in blocks when I save that we'll get the auto formatting but what we're doing here is making sure okay well if the tile. value is equal to the next tile. value so if it's the same and that tile and the current tile that we have has not merged with another tile go ahead and we can perform this operation now if it has merged with another tile we don't want to do this we don't want to merge with it so we're not going to initiate that operation okay next thing we're going to do is we're going to say LF the move check and this is going to be tile next tile then we're going to say tile. move by the Delta otherwise we're going to say continue all right so let me just quickly break this down here what we're doing is we're getting the next tile if we don't have a next tile we simply move now if we do have a next tile and that tile value is the same as this value we're going to go ahead and initiate the merge operation which we discussed now once we reach this LF we know okay we do have a x tile the next tile's value is not the same as ours so what that means is that we should move this tile until we reach the border of that next tile which is what's checked by this function so we move until this is false right until it you can no longer move we're going to continue to move otherwise if none of that is true then we just say continue and what that means is we're not going to do anything and when we don't do anything no update occurred so now we're going to go down here and we're going to say updated equal true so unless we were in this case or we were on the boundary we're going to reach this variable and we're going to say update equals true and that's going to tell us to initiate another loop here and continue the movement process because something did actually move as soon as this variable never becomes equal to true we stop the W Loop and we exit now there's a few other things that we need to do but that's a good start to our function all right so let's continue here as I was discussing while we move these tiles their row and column are going to be adjusted based on their X and Y position so based on where they're actually moving in the grid because as they move uh enough then they're going to be in a different row and a different column so we need to actually adjust that so to adjust that we're going to use this if we can write here set position function now the set position function or method whatever you'd prefer to call it is is simply going to look at the current X and Y position of this um what do you call it tile and then adjust it sorry adjust the row and call based on that X and Y position so we're going to say seal is equal to false and this is a variable that's going to tell us whether or not we should round up or we should round down which is going to be important based on the direction in which we're moving so we're going to say if ceiling so simply if we're rounding up then we're going to say self. row is equal to the math do seiling which is always rounds a value up and then we're going to take the self.y and we're going to divide that by the rectangular height so let's say the Y position is 600 right we're going to take six so let's say the Y position is 599 we're going to take 599 divided by the rectangular height which is 200 that's going to give us like 2.9 something we're then going to round that up to three telling us that we are currently still in the third row okay we're now going to say self. column is equal to math do ceiling self.x divided by the rectangular width and then for the else so if we're not rounding up we're going to round down so we're going to say self. row is equal to math. floor and then the exact same thing here right so this is going to be the Y value and then self. column is equal to math. floor self.x / by the rectangular width okay so that is just going to adjust the row and column as we move and what we're doing is we're essentially with this determining at what point will we move to the left or to the right that we want to set that row column value so when I go with ceiling that means as soon as I move fully past the bounding line or I'm right at it then I'm going to adjust this as I'm moving to the left whereas when I'm moving to the right it's actually going to be the opposite um because of the kind of directions in which we're moving it's it's difficult to explain this but you'll be able to see in the code here how we change this based on if we're moving to the left or to the right so that we know what row and column we're actually in to check for the next tile okay so now what we'll do is we'll go over here to updated and either before after updated doesn't actually matter the order in which we do it we're just going to set the tile position so we're going to say tile do set position and we're going to pass that ceiling value which we find here so we're moving to the left ceiling is true we're moving to the right it's going to be false okay now this is all good however you'll notice that we removed some tiles but we only removed them from the sorted tiles list now this is not actually where all of the tiles are stored it's just where they're temporarily stored while we're in this updated Loop so what we actually need to do now is adjust the tiles object itself which is passed in here to remove any tiles that were then removed from the sorted tiles um and to kind of adjust them so what we're going to do is inside of the wall Loop here but outside of the for Loop so make sure you have that indentation correct we're going to say update tiles and we're going to take the window the tiles and the sorted tiles now all this is going to do is essentially Loop through our tiles and it's just going to remove any of the sorted tiles that no longer exist from tiles so we're going to say Define update under _ tiles and we'll take in the window the tiles and the sorted tiles like that and we will go ahead and write that function so the way we can do this is we can just start by clearing all of the tiles so we're going to say tiles. CLE just removes everything from the dictionary and then we'll just say for tile in the sorted tiles and then we're going to say tiles and we'll create an F string again okay and this this is going to be tile. row tile. column is equal to the tile that's it and then we'll just do a draw operation here so we can actually see what's going on and we're going to draw the window and the tiles so update tiles is going to as I said update this tiles dictionary so it only contains the ones that are actually still there and it's going to draw all of the tiles on the screen as they move so we can actually see that movement operation occurring so I think that's okay last thing we'll do here is we're just going to call something known as end tiles now notice that this is happening outside of the wall Loop so as soon as we're no longer updating any tiles we're going to call this function so we're going to say Define end tiles like this this is going to take in the tiles and what this is going to do here is just check whether or not the game is over uh and kind of do that last cleanup operation so what do we want to do here actually let's call this end move cuz that makes a bit more sense okay and then inside of here we're going to say if the Len of tiles is equal to 16 then we're going to return lost so if after we did a move we have 16 tiles uh that means that we can't move anymore because the en entire board is well full of tiles uh and that way we lost so we'll just say we lost and then we can handle that later on if we want and then what we also want to do is we want to add a new tile to the screen right so every time we make a move a new tile gets added so we're going to say row column is equal to get random position and this is going to be tiles and then we're just going to say Tiles at the F string of row column is equal to tile and then what we need to do is randomly select whether or not we want the tile to be a two or a four so we're going to say random. Choice and then in an array two four just randomly pick between two and four then the position is going to be at row column and we'll just return continue so we know know that we can continue the game now from here we're also return and move and then what we'll do is we'll just go to main here and we'll actually start calling these functions that we wrote and then if we get a like end game returned then we'll simply end the game right we can send a message to the user we can do whatever we want in fact I'll actually let you guys handle that but we'll talk about that in a second okay so we've now handled moving left the other movements will be fairly straightforward I know that was kind of complicated let's actually test this though so what we want to do is we want to check for the different key presses right so if you're pressing Left Right Etc so we need to first check okay did we press a key so to do that we're going to say if event. type is equal to py game. key down so did we press a key down if we did we're going to say if event. key is equal to py game. Kore and we'll start with left so if we press the left key then we're going to say move tiles and we're going to pass window TI clock and the direction which is left okay so we're checking all right did we press key down if we did let's check the key that we pressed if it's equal to K left which is the left Arrow key you can also do like k a if you wanted to do the a key so Kore a but in our case we want the left Arrow key which is denoted by this then we're going to call the move tiles function pass the window pass the tiles pass the clock pass the direction of left let's copy this four times and handle the other directions Okay so if the key is right then we just change this to be right in lower cases otherwise we'll do up and down and then adjust this so that's up and that's down okay so now we have all of the directions however only left is going to work right now so let's go here and let's move left and you'll notice that they merge together and we saw a new four got added to the screen now when I press left you'll see that even though there's no movements happening a new thing will add onto the screen and you can see that as we move them they will move and they will merge accordingly okay so we can only currently move left and you'll see that now at this point the game's over because we can no longer move or merge any more tiles although I guess we could go up or down or whatever but in this case that's fine okay so that's it for left now we just need to handle the movement in the other directions and then we're done so to move in the other direction we pretty much just need to copy all of this and then adjust it for the different directions so let's go with right now so we're going to copy all that and paste this inside of here so to move right is going to be very similar we're going to keep the column key the same we're going to change this to be true because now we want to sort in reverse order the Delta now is going to be positive so moving in the right direction and the boundary check is going to be if the columns is equal to column minus one because that is going to be uh the kind of right boundary right if we're equal to whatever the number of columns is minus one well then we're in the last column now getting the next tile we're just going to add one not subtract one and now the merge check will look a little bit different so here we're going to change the sign to be less than and we're going to subtract the move velocity cuz now we're moving right and now for the move check again we're going to need to adjust that as well so this is going to be tile dox plus the rectangular width plus the move velocity is less than the next tile dox okay so we kind of just flip this around again because we're moving right that should now handle right and then we're going to say sealing is equal to false because we actually want to round down when we're moving to the right side okay let's run this and let's check left and right so we can now move to the right and we can merge as well as moving to the left okay looks pretty good obviously we could you know make the movement more fluid but I think this is actually pretty good so far okay let's see what happens if we go and merge and you see now that game is done all right so let us now do the up and the down okay so how do we do this well for up we're going to copy the exact same thing and actually we'll copy it from left because it's going to be a little bit more similar to that one and paste that here now for the sort function we're now moving up and down which means rather than using the column we're going to use the row now for reverse this is going to be false as well and for the Delta we're going to change this now so it's going to be zero and it's going to be negative move velocity because we're moving up in the y direction for the boundary check this now will be row not column so if we're at the zero with row that means we're at the top of the screen and when we get the next tile we're looking above so it's going to be row minus one and then the call will stay constant for the merge check now it's going to be similar but this time we're moving up right so rather than using X we're going to have to use y so we're going to say tiley is greater than next tile. Y and then this will be plus the move velocity for the move check similarly again we need this to be y so we're just going to adjust this so that rather than uh X it's Y and we're just going to change from rect width to rect height okay if we're sealing that's going to be true as well and now we're going to copy this and we're going to do the same thing for down okay so down this time reverse is going to be true cuz we're moving downwards the move velocity is going to be positive the boundar is going to be rows minus one when we look at the next tile we're looking down a row so we're going to add one and for the merge check again slightly more adjustments here so we're going to say tile. y we're going to change the sign and this is going to be less than the next tile. y minus the move velocity and for the move check same thing it's going to be next tile doy we're going to change the sign and and we're actually going to take this and we're going to put this on the other side okay so we're going to go like that plus the recti plus the move velocity less than the next tiley and the ceiling is going to be false okay now if we run this we should have a finished game so let's go ahead and do this and you can see that we can move up we can move down we can move to the right and we can merge our tiles and we can play the famous game of 2048 I don't know if if I quite know the strategy maybe as well as some of you guys but there you go functioning game now as I kind of play through this I will mention that there are a few like kind of tiny little bugs or things that you could adjust here for example it doesn't handle when the game is finished that's actually something I intentionally wanted to leave for you as homework we already kind of set it up so it should be fairly straightforward to add it and there's a few other like kind of small movement things that you might notice if you play this a long time but overall I think it's pretty good and it's not really worth it to fix them right now because it will add a significant amount of time to the video and I think most of you are going to be pretty happy with this implementation that we currently have now another thing to note is that if you get too high up you're going to run out of colors so if we look at this here I only added uh my quick math is what like 10 colors nine colors so that means we're only going to be able to go up to two to the exponent 9 or actually I think two the exponent yeah two the exponent 9 so you're going to need to add some more colors if you want to handle larger values than what ever two the exponent 9 is I don't actually remember what that value is so uh you can add more colorss you'll see that you'll get an index error if you go above that value but that's a pretty easy thing to fix okay a reminder all of the code will be available from the link in the description I hope you guys enjoyed this video if you did make sure to leave a like subscribe to the channel and I will see you in the next one
