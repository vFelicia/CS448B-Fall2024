With timestamps:

00:02 - [Music]
00:08 - in this video i'll be explaining to you
00:10 - dynamic programming specifically i'll go
00:12 - through the definition and the theory
00:14 - then i'll talk about how you classify
00:16 - different problems and understand if you
00:18 - can use dynamic programming for them
00:20 - then i'll get into a few examples where
00:22 - i explain how to implement dynamic
00:23 - programming as well as how you can
00:25 - optimize otherwise poor time complexity
00:27 - solutions using dynamic programming now
00:30 - i do want to mention that i do have a
00:32 - programming course it's called
00:33 - programming expert you can check it out
00:35 - from the link in the description it
00:36 - teaches fundamental and advanced
00:38 - programming concepts mostly in python
00:40 - but soon in some other languages as well
00:42 - as well as software engineering tools
00:44 - software design has over 100 videos
00:47 - hundreds of practice questions multiple
00:49 - programming projects if you guys want to
00:50 - check it out and support me please do
00:52 - from the link in the description you can
00:53 - use discount code tim i think it's a
00:55 - great resource to get better at
00:57 - programming regardless with that said
00:59 - let's get into dynamic programming so
01:01 - let me start here by reading the
01:02 - definition dynamic programming is an
01:04 - algorithmic technique for solving an
01:06 - optimization problem by breaking it down
01:08 - into simpler sub problems and utilizing
01:11 - the fact that the optimal solution to
01:12 - the overall problem depends upon the
01:14 - optimal solution to its sub problems so
01:17 - this is a very general definition and
01:20 - this describes a variety of ways of
01:22 - solving problems but the key here is
01:24 - that we are breaking a problem down into
01:26 - simpler sub problems and then solving
01:29 - those sub problems and the solutions of
01:31 - those sub problems are going to lead us
01:32 - to the solution of the overall problem
01:35 - now this can be tricky because sometimes
01:37 - you can have problems that can be broken
01:39 - into sub problems however the solutions
01:42 - of those sub problems do not necessarily
01:44 - lead you towards the optimal solution of
01:46 - the overall problem so optimization
01:49 - problems really involve finding the best
01:52 - answer out of multiple answers and
01:54 - you'll so you'll see dynamic programming
01:56 - is used many times when you're trying to
01:58 - maximize a value or minimize a value or
02:00 - again find the best answer out of a
02:02 - variety of different answers based on
02:04 - whatever criteria that may mean now you
02:07 - can use dynamic programming for problems
02:08 - that are not optimization problems or
02:11 - not by definition optimization problems
02:13 - i'm actually going to show you an
02:14 - example of that right now so to better
02:16 - illustrate this because i understand
02:17 - it's still probably confusing i'm just
02:19 - going to go through the famous example
02:21 - which is the fibonacci number sequence
02:23 - and discuss how we solve that problem
02:26 - why we can kind of write this as a
02:27 - dynamic programming problem and then how
02:29 - we optimize the solution using dynamic
02:32 - programming then i'll get into a much
02:33 - more advanced example so stick around if
02:35 - you already understand this example
02:37 - anyways the fibonacci sequence of
02:39 - numbers is a very famous sequence that
02:40 - looks like the following we have 0 1 1
02:44 - 2
02:45 - 3
02:46 - 5
02:47 - 8
02:48 - 13.
02:49 - and then we continue
02:51 - now just to write this out here this
02:53 - would be the zeroth number first second
02:55 - third fourth fifth sixth seventh and
02:58 - then so on and so forth so if i were to
03:00 - ask you to find the nth fibonacci number
03:03 - so we have some function here say like
03:05 - fib and we take in n and we want to know
03:08 - what the nth number is in the sequence
03:10 - well the way we actually determine what
03:12 - each number in this sequence is is we
03:14 - simply add the two previous values in
03:17 - the sequence to generate the next one so
03:19 - if i'm looking for the seventh fibonacci
03:21 - number i add the fifth and the six
03:23 - together and that gives me well 13. now
03:26 - same for any of the other numbers right
03:28 - so for say this one right here
03:31 - i just add one and two and that's an
03:33 - exception when you come to these first
03:34 - three values here because we have to
03:36 - have some starting values in the
03:37 - sequence but for anything beyond the
03:38 - second number you simply take the last
03:41 - number and the second last number add
03:43 - them together and that gives you the nth
03:45 - fibonacci number so the reason i'm
03:47 - showing this to you is because this is a
03:48 - great example of something that we can
03:50 - use dynamic programming to solve and the
03:52 - reason we can do that is because we can
03:54 - write the fibonacci of n as simply the
03:57 - fibonacci of n minus 1 plus
04:01 - the fibonacci of n minus 2. so this is
04:05 - our entire problem
04:07 - these are now two sub problems and if we
04:10 - solve both of these sub problems that
04:12 - will give us the solution to the main
04:13 - problem so as easy as that this is kind
04:16 - of a dynamic programming problem because
04:18 - we can write it in this way so whenever
04:20 - you're trying to determine if you can
04:21 - use dynamic programming you usually need
04:24 - to come up with some type of equation it
04:26 - might be more complicated than this but
04:27 - something along these lines where you're
04:29 - saying okay the answer to the main
04:31 - problem is equal to the answer of a
04:33 - sub-problem and maybe multiple
04:35 - sub-problems okay so in this case we're
04:37 - adding two sub-problems together but we
04:39 - could be dividing them we could be
04:40 - taking the minimum or the maximum value
04:42 - we're just utilizing the sub problem
04:44 - solution to actually find the solution
04:46 - to the main problem so won't drag on
04:48 - that explanation anymore now that we've
04:50 - looked at this i want to show you the
04:52 - kind of naive approach to solving this
04:54 - actual question right here so for
04:56 - generating the nth fibonacci sequence
04:58 - and then i'll talk about how we use
04:59 - dynamic programming to better optimize
05:02 - this solution so i've just put on the
05:04 - screen here a solution to that fibonacci
05:06 - problem i was just discussing and i want
05:08 - to explain to you why the time
05:09 - complexity of the solution is very poor
05:12 - and then how we can optimize it using a
05:14 - dynamic programming technique now
05:16 - theoretically you could say this is
05:19 - using dynamic programming and the reason
05:21 - you may say that is because we're
05:23 - utilizing the solution of sub problems
05:26 - to get the solution to the main problem
05:29 - however the issue with the solution that
05:31 - i have right here is as a very horrible
05:33 - time complexity the time complexity is
05:35 - actually big o of 2 to the exponent n
05:38 - now i'm going to draw a diagram to
05:39 - explain why that is but to quickly run
05:41 - through the code in case you haven't
05:42 - seen this before we take in some integer
05:44 - n if n is less than 2 we return n so
05:46 - just for the cases of 0 and 1 so we can
05:49 - return 0 and 1 respectively and then
05:51 - otherwise we're returning the fibonacci
05:52 - of n minus 1 plus n minus 2 and this is
05:55 - a recursive call right so i'm
05:57 - recursively calling the function with in
05:59 - this case let's say i had n5 this would
06:02 - be 4 and this would be 3 i would then
06:04 - have to repeat the code for those
06:06 - recursively and while i would get my
06:08 - solution so the issue with this is that
06:10 - if i do decide to say generate the
06:12 - fibonacci number of five or the fifth
06:14 - fibonacci number the recursive calls
06:16 - that i end up making is to four
06:19 - and is 2 3 right as i said i need to
06:21 - call 4 and i need to call 3. now from 4
06:24 - i need to make a call to 3 and i need to
06:26 - make a call to 2 because if i pass n
06:28 - equals 4 here will it generate the 4th
06:30 - fibonacci number because this is not a
06:32 - base case i must generate the third as
06:35 - well as the second right so you get the
06:37 - idea here i'm just drawing out kind of
06:38 - the tree of all the recursive calls that
06:40 - we're going to have
06:41 - from the third number however i need to
06:43 - generate the second fibonacci number as
06:46 - well as the first fibonacci number from
06:48 - the second fibonacci number this is not
06:49 - a base case i need to generate the first
06:52 - and the zeroth and add those together
06:54 - from one this is a base case so i simply
06:56 - return what the answer is now from two
06:58 - same thing i need to generate one and
07:00 - zero from three i need to generate two
07:02 - and one and then from two let's draw
07:05 - these a little bit weird here it's gonna
07:06 - be one
07:07 - and zero so sorry about the messed up
07:09 - tree on the right hand side but you get
07:11 - the point this tree is growing
07:12 - exponentially and if i actually go in
07:14 - here you can see there's a ton of
07:16 - repeated values that i'm calculating i'm
07:18 - calculating one a ton of different times
07:21 - right zero a bunch of different times
07:23 - two i'm calculating multiple times as
07:25 - well three i'm calculating multiple
07:27 - times and while this is leading to a
07:28 - very poor time complexity of big o of 2
07:30 - to the exponent n because i'm doing a
07:32 - bunch of repeated calculations that i've
07:34 - already done as soon as i calculate say
07:36 - the second number i really should just
07:38 - store that value so i'm able to quickly
07:40 - access what the answer is same thing
07:42 - with 3 i should store that same thing
07:44 - with four i should store that i should
07:45 - never have to do any of the right hand
07:47 - side of this tree here because i should
07:49 - have already had the solutions i
07:51 - shouldn't have to actually make these
07:52 - recursive calls so i understand it's a
07:54 - little bit confusing for now but let me
07:56 - show you a new solution here that uses
07:58 - dynamic programming and then you'll
07:59 - understand kind of the basics of this
08:01 - approach all right so i've just placed a
08:03 - new solution onto the screen here which
08:05 - has a much better time complexity this
08:08 - actually has a time complexity of big o
08:10 - of n and the reason for that is we're
08:12 - using a technique here called
08:13 - memoization which is something you do
08:16 - typically in dynamic programming
08:17 - problems so as i said before there was
08:20 - really no point in us continually making
08:22 - the same function calls the same
08:24 - recursive calls to calculate a value
08:26 - that we already calculated previously so
08:29 - here we're optimizing our solution by
08:31 - implementing a cash now what is a cash
08:34 - well cash is just a way to store values
08:36 - that we've already calculated before so
08:38 - in this solution we're never going to do
08:40 - any repetitive calculations and that
08:42 - means if i want to generate say the
08:44 - sixth fibonacci number it only takes me
08:46 - six total computations to generate that
08:48 - or approximately six a linear number of
08:50 - computations so let's just run through
08:52 - this solution and see how it works
08:54 - because this is the most basic example i
08:56 - can give you of implementing a dynamic
08:58 - programming solution so we have our base
09:00 - case again inside of this function so if
09:02 - you have n less than 2 okay we're going
09:03 - to return n
09:04 - otherwise though i'm going to check if n
09:06 - is in my cache now the cache is simply a
09:09 - dictionary we're going to have different
09:11 - keys mapped with different values and
09:13 - every key is going to be one of the nth
09:15 - fibonacci numbers and then the value
09:18 - with that key is going to be the actual
09:19 - number associated with that
09:21 - so maybe we have 0 1
09:23 - 1 1
09:25 - 2 1
09:26 - 3 and then this would be 2 right so on
09:29 - and so forth that's what will actually
09:30 - be in our cache and i will generate this
09:32 - cache or kind of write it out as we go
09:34 - through this solution
09:35 - so we have if n is in cache then return
09:38 - the cache at n so this avoids us having
09:40 - to do any repetitive recursive calls
09:42 - because if we've already generated a
09:43 - value it will be stored in the cache and
09:46 - then what i'm doing here is exactly what
09:47 - i had in my previous solution except
09:49 - this time i'm storing the solution
09:52 - to whatever the call was to end here
09:55 - inside of my cache so that i never have
09:57 - to generate it again and then i'm simply
09:58 - returning whatever the value it is that
10:00 - i just stored in the cache so for
10:02 - example purposes here let's say n is
10:03 - equal to 5 again and now let's draw out
10:06 - the tree and see how large the tree
10:07 - gretz gets in this solution sorry as
10:09 - opposed to the previous one so if we're
10:12 - solving the fib of 5 well the first
10:14 - thing that we're going to see here is
10:15 - that it's not less than 2 and it is not
10:18 - in the cache and so we are going to have
10:19 - to generate the solution to this
10:21 - sub-problem so we're going to have to
10:23 - call 4 and we're going to have to call
10:24 - 3. so let's draw that out
10:27 - 4 and 3. okay so now we're going to go
10:30 - to 4 and we need to solve the problem
10:32 - for 4. so if we say n is equal to 4 it's
10:34 - not less than 2 and it's not in the
10:36 - cache so again we're going to have to
10:38 - solve these sub-problems we're going to
10:39 - have to call 3 and we're going to have
10:41 - to call 2. okay so now i go 3 and i call
10:44 - 2. now let's do the call to three so we
10:47 - come to three it's not less than two not
10:48 - in the cache we gotta solve these
10:49 - problems
10:51 - two and one so we have two
10:53 - and we have one and then what happens is
10:56 - we have two here
10:58 - okay we need to solve 2 because 2 is not
11:00 - a base case and it's not in the cache so
11:02 - we're going to call 2 with
11:04 - 1 and 0 running out of room but you get
11:06 - the point that's what we're calling it
11:07 - with okay so when we get to 1 and 0
11:10 - we're going to return our values we're
11:12 - going to get 1
11:13 - and we're going to get 0. so now what's
11:15 - going to happen is we've returned these
11:16 - values and we're going to say the cash
11:19 - at 2 is equal to and then this is going
11:22 - to be 1
11:23 - plus 0 which is simply equal to 1. so
11:26 - now i have my cache and inside of my
11:28 - cache i'm going to have 2 which is my
11:30 - nth fibonacci number and the value of
11:32 - this is going to be 1. so now whenever i
11:35 - try to solve the sub problem of 2 again
11:37 - i'm not going to have to actually call
11:39 - these i'm not going to have to solve 1
11:41 - and 0 i'm just going to simply take the
11:43 - value from the cache because now it's
11:44 - stored inside of there okay so now we've
11:46 - completed this recursive call at 2 1 is
11:49 - simply a base case so we return the
11:51 - value here that's going to be 1. this
11:53 - value is going to be returned as 1 as
11:54 - well i apologize this a bit messy but
11:57 - hopefully you get the point and now
11:58 - we're going to say the cache at 3 is
12:01 - equal to and it's going to be 1
12:03 - plus 1 which is 2. so now i'm going to
12:06 - change the cache so now in the cache
12:08 - we're going to add key 3 and it is going
12:10 - to have value 2. so now whenever we try
12:12 - to find what the n fibonacci number of 3
12:15 - is we'll be able to do that very fast we
12:17 - just take it from the cache okay then we
12:19 - need to solve 2. so now when we go to
12:21 - try to solve 2 i don't actually need to
12:23 - call 1 and 0 and the reason i don't need
12:26 - to do that is because 2 is inside of the
12:28 - cache so since 2 is inside of the cache
12:30 - i've now just avoided doing 2 recursive
12:33 - calls and what i do is simply grab the
12:35 - value from the cache which is 1 and i
12:37 - can return that up to 4 which is what
12:39 - needed that value so we're going to
12:40 - return 1 there and then from over on
12:43 - this side we're returning a value of 2.
12:45 - so now when we get the 4th fibonacci
12:47 - number we're going to say the cache at 4
12:49 - is equal to and then this is going to be
12:51 - 2 plus 1 and that's going to give us 3
12:54 - so we're going to insert this into the
12:55 - cache
12:56 - so we're going to say okay 4 this has
12:58 - value 3. and now same thing whenever we
13:00 - try to solve the sub problem 4 again we
13:02 - can just grab the value from the cache
13:04 - as opposed to actually doing those
13:05 - recursive calls
13:07 - now finally we go to this recursive call
13:09 - over here which is for value three and
13:11 - for three it's inside of the cache so i
13:14 - can simply return the value so i return
13:16 - the value of two from four we know this
13:18 - number was 3 and so we know now that the
13:21 - 5th fibonacci number is value 5. we add
13:24 - those together we would actually add it
13:26 - to the cache and then we just return the
13:27 - value from the cache hopefully that
13:29 - explained how this worked but what we
13:31 - were doing was storing the solution to
13:33 - each sub problem as we went and that
13:36 - avoided us having to do a bunch of
13:38 - recursive calls that we had to do in the
13:40 - previous solution and if we wanted to
13:42 - reduce these even more we could start
13:44 - the cache
13:45 - and say okay cache is equal to then we
13:48 - could have something like 0 1 and 1 1
13:51 - but that would effectively give us the
13:52 - exact same solution as just having if n
13:54 - is less than 2.
13:55 - but we could remove this if statement
13:57 - and simply add these values into the
13:59 - cache as well just noting there's kind
14:01 - of multiple ways to go about solving
14:02 - this all right
14:04 - hopefully that makes sense but you've
14:05 - just seen an example of dynamic
14:07 - programming we've used a technique here
14:09 - called memoization now this is a
14:10 - technique that's used for dynamic
14:12 - programming problems or within a dynamic
14:14 - programming solution and all it involves
14:17 - is storing results that we've calculated
14:19 - in the past so we don't have to
14:20 - calculate them again all right so that
14:23 - is the first thing that i want to show
14:24 - you the first example i wanted to go
14:25 - through hopefully that is all clear now
14:27 - we're going to get into a more difficult
14:29 - problem and i'll give you a chance to
14:31 - solve it on your own and then i will
14:32 - walk you through the multiple solutions
14:34 - and different ways to go about solving
14:36 - it one of which of course is going to
14:37 - use dynamic program alright so i've just
14:39 - written an array on the screen here or a
14:41 - list whatever you want to refer to it as
14:43 - and i'm going to ask you the following
14:44 - question i'm just going to verbalize it
14:46 - so just listen think about it and then i
14:48 - will talk about how we solve
14:50 - so the question is determine the minimum
14:52 - possible sum
14:54 - of any continuous subarray in this array
14:58 - so what that means is that i could have
14:59 - a subarray say like this this is a
15:01 - continuous subarray because all of the
15:03 - elements are adjacent to each other i
15:05 - could have a sub-array that's these
15:06 - elements i could have a sub-array that's
15:08 - just one single element but they have to
15:09 - be touching i can't have a subarray that
15:11 - has say this
15:12 - this
15:13 - and this that would not be a continuous
15:15 - sub-array so they just have to be
15:16 - touching hopefully that's clear but any
15:18 - continuous sub-array what is the minimum
15:21 - possible sum of any one that we have and
15:23 - for this example right here the minimum
15:25 - sum that we would have of any continuous
15:27 - subarray is negative 7. now there's two
15:30 - possible answers here the first answer
15:31 - is to take this as the sub-array the
15:34 - second answer would be to take this as
15:36 - the sub-array if you take the sum of all
15:38 - the elements within these you'll see
15:39 - that they both add up to negative seven
15:41 - so that's really the question i'm asking
15:43 - you determine what the minimum possible
15:44 - sum is of any continuous sub array in an
15:47 - array so take a second if you want think
15:49 - about how you would solve it and then
15:50 - i'm going to show you the naive approach
15:52 - that does not use dynamic programming
15:54 - then we will talk about the dynamic
15:55 - programming approach so hopefully you've
15:57 - taken a second to think about how you
15:59 - would solve this problem because i'm
16:00 - going to go through a solution now this
16:02 - solution that i have is the non-optimal
16:04 - solution it runs in a time complexity
16:07 - the big o of n squared and this does not
16:10 - use dynamic program now this solution
16:12 - simply says
16:14 - what i'm going to do is find every
16:16 - single subarray in this array and then
16:19 - calculate the sum of all of those
16:20 - sub-arrays and determine what the
16:22 - minimum sum is that's it so we start by
16:25 - calculating all of the subarrays that
16:27 - start at negative seven
16:28 - calculating the sum for all of them and
16:30 - then updating this min sum variable
16:32 - then all of the sub-arrays starting at 3
16:35 - then all of the sub arrays starting at 4
16:37 - all of them starting at negative 2 so on
16:39 - and so forth and we get every single sub
16:41 - array that we have
16:43 - calculate the sum update this variable
16:45 - and well that will give us the correct
16:46 - answer now this solution is fine it does
16:49 - solve the problem there's nothing wrong
16:50 - with this the issue is that it runs in n
16:52 - squared and there is a faster and better
16:55 - way to solve this problem that involves
16:57 - using dynamic programming so what i want
16:59 - to ask you now is if you came up with
17:01 - this solution can you think of any way
17:03 - to solve this problem
17:05 - in linear time and at this point i will
17:07 - mention if you're unfamiliar with time
17:08 - complexities i do have an entire video
17:10 - on them so i'll leave it on the screen
17:11 - here and in the description anyways
17:13 - think of a way that you can solve this
17:14 - in linear time or big o of n time
17:17 - utilizing dynamic programming now you
17:19 - may not be able to come up with it
17:20 - that's totally fine of course that's why
17:22 - i'm here i'm going to explain it to you
17:23 - but just take a second and think okay
17:25 - can i solve this in a more efficient way
17:28 - so the answer of course is yes that's
17:29 - why i'm using this problem but let's get
17:31 - rid of this and let's talk about how we
17:33 - would actually frame this problem as a
17:35 - dynamic programming problem and how we
17:37 - would write a solution that utilizes the
17:40 - solution to sub problems so when you
17:42 - want to solve a problem using dynamic
17:44 - programming again what you really need
17:46 - to think about is what sub-problems am i
17:49 - going to have and how are the solutions
17:51 - of those sub-problems going to help me
17:53 - come up with the solution of the entire
17:55 - problem so i've just written a new
17:57 - example here and i'm going to start
17:58 - walking you through how we solve this
18:00 - using dynamic programming
18:02 - now in this example we want to try to
18:04 - solve this using one single pass of the
18:07 - array so rather than writing an
18:09 - algorithm right now let's kind of try to
18:10 - do this as a human and figure out what
18:13 - values we're going to want to store and
18:14 - how we're going to optimize the previous
18:16 - solution so again we only do a single
18:18 - pass of the array and there's no need to
18:20 - have a nested for loop and an n squared
18:22 - time complexity solution
18:24 - so what i'm going to do is start here at
18:26 - this element and i'm going to have some
18:28 - variable here i'm going to say min sum
18:31 - and this will be equal to 0 and this
18:33 - will just store what the minimum sum is
18:34 - that i've found so far and what i'm
18:36 - trying to do here again is create this
18:38 - minimum sum sub array or actually
18:40 - determine what the minimum sum is of any
18:43 - subarray so i need to kind of build
18:45 - different subarrays as i go through here
18:47 - and determine what their sums are update
18:49 - this value and then figure out
18:50 - essentially what elements i want to be
18:52 - in this subarray okay so i start at 20
18:55 - we can kind of imagine that we can't see
18:57 - any of this right now because we're just
18:58 - looking at element 20 and i'm going to
19:00 - ask at element 20. what is the minimum
19:03 - possible sum that i can create
19:06 - using this element so at every single
19:08 - element the question i want to ask is if
19:10 - i were to use this element what is the
19:12 - minimum sum that i can create in a
19:14 - subarray so if this element was in any
19:15 - subarray i don't know how big or small
19:17 - the sub array would be but if it was
19:18 - included 100 what's the minimum sum i
19:21 - could generate that's what we're asking
19:23 - so in this case at 20 we know that the
19:25 - minimum sum that we can make is 20. so
19:27 - let's just write this here and we'll
19:29 - update this minimum sum variable really
19:31 - this should have been
19:32 - float infinity or just infinity before
19:35 - and so this will now go to 20 because if
19:37 - we have a subarray that just includes
19:39 - this element right here well the sum of
19:40 - that is 20. okay now we move on to the
19:42 - next element
19:44 - negative 7. now same question here i
19:46 - want to ask if i were to include this
19:48 - element negative 7 what is the minimum
19:51 - possible sum that i could have
19:54 - now the way that i determine that is i
19:55 - need to look at the minimum sum of the
19:57 - previous element and i need to add that
20:00 - to the current element and then compare
20:02 - that to what the value of the current
20:04 - element is
20:05 - so we'd have 20 minus 7
20:08 - that's going to give us a sum of 13 or
20:10 - if we did not include this previous
20:12 - element so if we were to start the
20:13 - subarray say right here then we would
20:15 - have a sum of negative 7
20:17 - okay so obviously negative 7 is going to
20:19 - be a smaller sum so i'm going to put
20:21 - negative 7 there and i would imagine
20:23 - that okay if i had the sub array i would
20:25 - not expand my sub array to be like this
20:27 - i would just start my sub array here on
20:29 - negative 7. no need for 20.
20:32 - that does not help me or it doesn't make
20:33 - it any more negative negative seven
20:35 - however it does okay so we have negative
20:37 - seven now with the minimum sum that we
20:39 - found
20:40 - is negative seven and that's if we're
20:41 - just using a sub array like this again
20:43 - from here we wanted to see okay should
20:45 - we include any of the elements prior and
20:47 - we said no because if we did then it was
20:49 - going to make this a larger sum than
20:51 - just having the element itself
20:52 - okay so now we have negative 7 and i'm
20:55 - going to move on to negative 3. so now
20:57 - if i'm on this element i ask the same
20:58 - question if i have a subarray that
21:00 - includes this element 100 so we're going
21:03 - to end right here
21:04 - would i want to include the minimum sum
21:06 - of the previous element or just this
21:09 - element well if i were to take whatever
21:11 - the minimum sum is that i could have
21:13 - using this previous element so including
21:15 - the previous element right here then
21:17 - that sum would be negative seven
21:19 - and that obviously would make this lower
21:22 - than negative three so i would just
21:23 - write negative ten here we're comparing
21:24 - negative seven minus three and just the
21:26 - element itself negative three well
21:28 - what's lower of course negative 10. okay
21:30 - so let's erase this bar here so now we
21:32 - move on to nine and don't worry i will
21:33 - explain this again so it makes perfect
21:35 - sense let's just walk through the entire
21:37 - example okay so now we're on nine same
21:39 - question from nine if i were to have a
21:41 - sub array that included the element 9.
21:44 - would i want
21:45 - the previous elements in the array to be
21:47 - a part of it or would i want just
21:50 - element 9 well in this case i have 9 and
21:52 - i'm going to compare that now to
21:54 - whatever the minimum sum is that i could
21:57 - create by using the previous element so
21:59 - again really what i'm doing here from 9
22:02 - is i'm looking at this value right here
22:04 - and i'm saying okay if i were to include
22:06 - the last element what is the minimum sum
22:10 - that i can create that uses the last
22:12 - element in a sub-array it's not just the
22:15 - value of the last element it is again
22:17 - the minimum sub that i can create by
22:19 - using the last element in a sub-array
22:21 - and we know that the sub-array with the
22:22 - last element is negative seven and
22:24 - negative three so now when we come to 9
22:26 - we say okay well if we're going to use
22:28 - this element in the subarray do we want
22:29 - it to just start here or do we want to
22:32 - include potentially some other elements
22:34 - well i look at this negative 10 i say
22:36 - well that's less than 9 it's going to
22:37 - make this smaller so of course we're
22:39 - going to include that and now the sum
22:40 - that i can create at 9 is going to be
22:42 - negative 1. now i'm not going to update
22:44 - my minimum sum and in fact the minimum
22:45 - sum should be negative 10. sorry i
22:47 - should have updated that before because
22:48 - well negative 1 is not less than
22:50 - negative 10. okay now i move over to
22:52 - negative 4. so from negative 4 again we
22:54 - have the same question should we include
22:56 - previous elements in the array well if i
22:58 - include this previous element right here
23:01 - i know that the minimum sum i can
23:02 - generate that uses this previous element
23:05 - currently is negative 1. so that means i
23:07 - can say the negative
23:09 - 5 is going to be the sum right here and
23:10 - that's of course going to be lower than
23:12 - me starting the sub array right here of
23:14 - just negative 4.
23:15 - okay hopefully this is all making a bit
23:17 - of sense continuing we'll move over to
23:18 - 6. now from 6 i ask the same question
23:21 - okay
23:22 - should i include the previous element if
23:25 - i'm going to have this element in a
23:26 - sub-array or should i just start the sub
23:28 - array right here well i want to include
23:30 - the previous element because negative 5
23:31 - is less than 6 so that's going to give
23:33 - me a sum of 1 right here for this
23:34 - element no need to update max sum
23:37 - continuing here we're now at negative 9.
23:39 - now at negative 9 i ask the question is
23:41 - it helpful to me to include the previous
23:44 - element which is going to be 6 or do i
23:46 - start my subarray right here well the
23:49 - answer of course is no i'm not going to
23:50 - include it i'm going to get a sum of
23:52 - negative 9 and i'm going to start right
23:53 - here with this element because the
23:56 - minimum possible sum that i can create
23:58 - using this element with all of the
24:00 - previous elements that i have in this
24:02 - array is 1 and 1 plus negative 9 gives
24:05 - me a larger value than the negative 9
24:08 - itself
24:09 - so i just start at negative 9. okay
24:11 - lastly i come over to 10. now the answer
24:13 - here is just going to be 1. of course
24:15 - we're going to going to include negative
24:16 - 9 because that's going to make this
24:18 - lower so now i actually know that the
24:20 - minimum possible sum that i can create
24:22 - is going to be negative 10. in that
24:24 - there you go i return that answer now i
24:26 - know this is not crystal clear but
24:28 - really all we did at every single
24:29 - position here in this array is we ask
24:31 - ourselves the question
24:32 - what is the minimum possible sum that i
24:35 - can get when i include this element in
24:38 - the sub array now the answer to that is
24:40 - it's either the element itself or it's
24:42 - the element itself plus the minimum sum
24:45 - that we can get when we include the
24:47 - previous element because we need to have
24:49 - a continuous subarray so if we're
24:51 - including the previous element well
24:52 - whatever the minimum sum is that it can
24:54 - have plus our current element that's the
24:56 - minimum we could get if we included this
24:59 - element and that allows us to actually
25:01 - not need to keep track of the different
25:02 - indices of the subarrays but to
25:04 - determine the minimum sum by constantly
25:07 - updating this min sum variable as we run
25:09 - through the problem now the dynamic
25:11 - programming aspect of the solution is
25:13 - that i am storing the solution to every
25:16 - sub problem that i solved and i'm simply
25:19 - taking the minimum of all of the
25:22 - solutions that i had right so all of
25:24 - these sub problems i need to solve i
25:26 - solved them one by one and they actually
25:28 - utilized the solution to the previous
25:30 - subproblems i then take the minimum of
25:32 - all of those sub problems and well that
25:34 - gives me the solution to the problem so
25:36 - let's clear the screen here
25:38 - and let's have a look at what the
25:39 - solution actually looks like in code all
25:41 - right so i've got the solution in front
25:43 - of me to find my function i have my if
25:45 - statement so just handling an empty
25:47 - array here and then i'm saying the min
25:49 - sum using element is equal to array at
25:50 - zero so this is what we're going to use
25:52 - to actually store all of these
25:53 - sub-problem solutions and then the
25:55 - minimum sum well this is going to give
25:56 - us the complete answer because we're
25:58 - taking the minimum sum of any of the
26:00 - sub-problem solutions okay we then
26:02 - continue here we say 4i in range then
26:05 - we're looping through all of the
26:06 - elements except index 1. our accept
26:08 - index 0 sorry because we've already
26:10 - handled that up here
26:11 - and then we're going to say the number
26:13 - is equal to array at i and we're going
26:14 - to generate what the current minimum is
26:17 - that we can create using this element so
26:20 - the minimum possible subarray sum we can
26:22 - get that uses the current element that
26:24 - we're on as i said that's going to be
26:26 - the number let me draw this in a
26:27 - different color here
26:29 - or the number plus the minimum sum using
26:32 - element at the previous index so if we
26:34 - were to include the previous element
26:36 - whatever the minimum sum is that we
26:37 - could create using that element we add
26:40 - that to the current element and we take
26:41 - the minimum of those two values okay we
26:43 - then say the min sum using element dot
26:45 - append current minimum then we say the
26:47 - minimum sum is min of min sum and
26:50 - current min then we continue this and
26:51 - well that solves the problem for us so
26:54 - this solution does run in big o of n
26:57 - time however it takes big o of n space
27:01 - because of the fact that we're using
27:02 - this array now some of you may have
27:04 - noticed that since we're only ever
27:06 - looking at the last element in the array
27:08 - we actually don't need to utilize an
27:10 - array and store every single sub-problem
27:12 - solution what we can do instead is
27:14 - simply store the previous sub-problem
27:16 - solution so let me put on the code for
27:18 - that and show you what that looks like
27:20 - all right so now this is the updated
27:21 - solution which is going to run in big o
27:24 - of n time
27:25 - and is going to take big o of 1 or
27:27 - constant space because we've now removed
27:30 - the array and instead we're just saying
27:32 - the min sum using the last element and
27:34 - this is not an array it's just whatever
27:36 - the last value was because we only need
27:38 - to access the last value again so we can
27:40 - just use a variable as opposed to using
27:42 - an entire array now let you read through
27:44 - this code but at this point i am
27:46 - finished with this video now dynamic
27:48 - programming on its own is not extremely
27:50 - complicated what's actually most
27:52 - difficult about it is determining how
27:54 - you write a problem in a dynamic
27:56 - programming way so how you frame the
27:58 - problem in a way such that you're
28:00 - solving sub problems so that's what i
28:02 - was trying to illustrate to you before
28:03 - when i was walking through the array
28:04 - step by step is that we can look at this
28:07 - problem and say okay the sub problem
28:08 - that we're solving is what's the minimum
28:11 - sum that we can generate when we include
28:13 - this element and once we start framing
28:15 - the problem in that way it now becomes
28:17 - very easy to figure out how those sub
28:19 - problems actually lead us to the optimal
28:21 - solution so that's what you need to
28:22 - think about when you're saying okay can
28:24 - i use this problem for dynamic
28:25 - programming or sorry can i solve this
28:27 - problem using dynamic programming you
28:29 - need to think what way can i look at
28:31 - this problem and kind of read it out
28:32 - such that i have sub problems that i'm
28:34 - solving and that's not always possible
28:37 - and sometimes you can solve sub problems
28:39 - but those don't actually lead you to the
28:41 - optimal solution so you have to rethink
28:43 - your approach anyways with that said i
28:44 - will wrap it up here hope you found this
28:46 - helpful if you did make sure to leave a
28:47 - like subscribe to the channel and i will
28:49 - see you in another one
28:53 - [Music]
28:59 - you

Cleaned transcript:

in this video i'll be explaining to you dynamic programming specifically i'll go through the definition and the theory then i'll talk about how you classify different problems and understand if you can use dynamic programming for them then i'll get into a few examples where i explain how to implement dynamic programming as well as how you can optimize otherwise poor time complexity solutions using dynamic programming now i do want to mention that i do have a programming course it's called programming expert you can check it out from the link in the description it teaches fundamental and advanced programming concepts mostly in python but soon in some other languages as well as well as software engineering tools software design has over 100 videos hundreds of practice questions multiple programming projects if you guys want to check it out and support me please do from the link in the description you can use discount code tim i think it's a great resource to get better at programming regardless with that said let's get into dynamic programming so let me start here by reading the definition dynamic programming is an algorithmic technique for solving an optimization problem by breaking it down into simpler sub problems and utilizing the fact that the optimal solution to the overall problem depends upon the optimal solution to its sub problems so this is a very general definition and this describes a variety of ways of solving problems but the key here is that we are breaking a problem down into simpler sub problems and then solving those sub problems and the solutions of those sub problems are going to lead us to the solution of the overall problem now this can be tricky because sometimes you can have problems that can be broken into sub problems however the solutions of those sub problems do not necessarily lead you towards the optimal solution of the overall problem so optimization problems really involve finding the best answer out of multiple answers and you'll so you'll see dynamic programming is used many times when you're trying to maximize a value or minimize a value or again find the best answer out of a variety of different answers based on whatever criteria that may mean now you can use dynamic programming for problems that are not optimization problems or not by definition optimization problems i'm actually going to show you an example of that right now so to better illustrate this because i understand it's still probably confusing i'm just going to go through the famous example which is the fibonacci number sequence and discuss how we solve that problem why we can kind of write this as a dynamic programming problem and then how we optimize the solution using dynamic programming then i'll get into a much more advanced example so stick around if you already understand this example anyways the fibonacci sequence of numbers is a very famous sequence that looks like the following we have 0 1 1 2 3 5 8 13. and then we continue now just to write this out here this would be the zeroth number first second third fourth fifth sixth seventh and then so on and so forth so if i were to ask you to find the nth fibonacci number so we have some function here say like fib and we take in n and we want to know what the nth number is in the sequence well the way we actually determine what each number in this sequence is is we simply add the two previous values in the sequence to generate the next one so if i'm looking for the seventh fibonacci number i add the fifth and the six together and that gives me well 13. now same for any of the other numbers right so for say this one right here i just add one and two and that's an exception when you come to these first three values here because we have to have some starting values in the sequence but for anything beyond the second number you simply take the last number and the second last number add them together and that gives you the nth fibonacci number so the reason i'm showing this to you is because this is a great example of something that we can use dynamic programming to solve and the reason we can do that is because we can write the fibonacci of n as simply the fibonacci of n minus 1 plus the fibonacci of n minus 2. so this is our entire problem these are now two sub problems and if we solve both of these sub problems that will give us the solution to the main problem so as easy as that this is kind of a dynamic programming problem because we can write it in this way so whenever you're trying to determine if you can use dynamic programming you usually need to come up with some type of equation it might be more complicated than this but something along these lines where you're saying okay the answer to the main problem is equal to the answer of a subproblem and maybe multiple subproblems okay so in this case we're adding two subproblems together but we could be dividing them we could be taking the minimum or the maximum value we're just utilizing the sub problem solution to actually find the solution to the main problem so won't drag on that explanation anymore now that we've looked at this i want to show you the kind of naive approach to solving this actual question right here so for generating the nth fibonacci sequence and then i'll talk about how we use dynamic programming to better optimize this solution so i've just put on the screen here a solution to that fibonacci problem i was just discussing and i want to explain to you why the time complexity of the solution is very poor and then how we can optimize it using a dynamic programming technique now theoretically you could say this is using dynamic programming and the reason you may say that is because we're utilizing the solution of sub problems to get the solution to the main problem however the issue with the solution that i have right here is as a very horrible time complexity the time complexity is actually big o of 2 to the exponent n now i'm going to draw a diagram to explain why that is but to quickly run through the code in case you haven't seen this before we take in some integer n if n is less than 2 we return n so just for the cases of 0 and 1 so we can return 0 and 1 respectively and then otherwise we're returning the fibonacci of n minus 1 plus n minus 2 and this is a recursive call right so i'm recursively calling the function with in this case let's say i had n5 this would be 4 and this would be 3 i would then have to repeat the code for those recursively and while i would get my solution so the issue with this is that if i do decide to say generate the fibonacci number of five or the fifth fibonacci number the recursive calls that i end up making is to four and is 2 3 right as i said i need to call 4 and i need to call 3. now from 4 i need to make a call to 3 and i need to make a call to 2 because if i pass n equals 4 here will it generate the 4th fibonacci number because this is not a base case i must generate the third as well as the second right so you get the idea here i'm just drawing out kind of the tree of all the recursive calls that we're going to have from the third number however i need to generate the second fibonacci number as well as the first fibonacci number from the second fibonacci number this is not a base case i need to generate the first and the zeroth and add those together from one this is a base case so i simply return what the answer is now from two same thing i need to generate one and zero from three i need to generate two and one and then from two let's draw these a little bit weird here it's gonna be one and zero so sorry about the messed up tree on the right hand side but you get the point this tree is growing exponentially and if i actually go in here you can see there's a ton of repeated values that i'm calculating i'm calculating one a ton of different times right zero a bunch of different times two i'm calculating multiple times as well three i'm calculating multiple times and while this is leading to a very poor time complexity of big o of 2 to the exponent n because i'm doing a bunch of repeated calculations that i've already done as soon as i calculate say the second number i really should just store that value so i'm able to quickly access what the answer is same thing with 3 i should store that same thing with four i should store that i should never have to do any of the right hand side of this tree here because i should have already had the solutions i shouldn't have to actually make these recursive calls so i understand it's a little bit confusing for now but let me show you a new solution here that uses dynamic programming and then you'll understand kind of the basics of this approach all right so i've just placed a new solution onto the screen here which has a much better time complexity this actually has a time complexity of big o of n and the reason for that is we're using a technique here called memoization which is something you do typically in dynamic programming problems so as i said before there was really no point in us continually making the same function calls the same recursive calls to calculate a value that we already calculated previously so here we're optimizing our solution by implementing a cash now what is a cash well cash is just a way to store values that we've already calculated before so in this solution we're never going to do any repetitive calculations and that means if i want to generate say the sixth fibonacci number it only takes me six total computations to generate that or approximately six a linear number of computations so let's just run through this solution and see how it works because this is the most basic example i can give you of implementing a dynamic programming solution so we have our base case again inside of this function so if you have n less than 2 okay we're going to return n otherwise though i'm going to check if n is in my cache now the cache is simply a dictionary we're going to have different keys mapped with different values and every key is going to be one of the nth fibonacci numbers and then the value with that key is going to be the actual number associated with that so maybe we have 0 1 1 1 2 1 3 and then this would be 2 right so on and so forth that's what will actually be in our cache and i will generate this cache or kind of write it out as we go through this solution so we have if n is in cache then return the cache at n so this avoids us having to do any repetitive recursive calls because if we've already generated a value it will be stored in the cache and then what i'm doing here is exactly what i had in my previous solution except this time i'm storing the solution to whatever the call was to end here inside of my cache so that i never have to generate it again and then i'm simply returning whatever the value it is that i just stored in the cache so for example purposes here let's say n is equal to 5 again and now let's draw out the tree and see how large the tree gretz gets in this solution sorry as opposed to the previous one so if we're solving the fib of 5 well the first thing that we're going to see here is that it's not less than 2 and it is not in the cache and so we are going to have to generate the solution to this subproblem so we're going to have to call 4 and we're going to have to call 3. so let's draw that out 4 and 3. okay so now we're going to go to 4 and we need to solve the problem for 4. so if we say n is equal to 4 it's not less than 2 and it's not in the cache so again we're going to have to solve these subproblems we're going to have to call 3 and we're going to have to call 2. okay so now i go 3 and i call 2. now let's do the call to three so we come to three it's not less than two not in the cache we gotta solve these problems two and one so we have two and we have one and then what happens is we have two here okay we need to solve 2 because 2 is not a base case and it's not in the cache so we're going to call 2 with 1 and 0 running out of room but you get the point that's what we're calling it with okay so when we get to 1 and 0 we're going to return our values we're going to get 1 and we're going to get 0. so now what's going to happen is we've returned these values and we're going to say the cash at 2 is equal to and then this is going to be 1 plus 0 which is simply equal to 1. so now i have my cache and inside of my cache i'm going to have 2 which is my nth fibonacci number and the value of this is going to be 1. so now whenever i try to solve the sub problem of 2 again i'm not going to have to actually call these i'm not going to have to solve 1 and 0 i'm just going to simply take the value from the cache because now it's stored inside of there okay so now we've completed this recursive call at 2 1 is simply a base case so we return the value here that's going to be 1. this value is going to be returned as 1 as well i apologize this a bit messy but hopefully you get the point and now we're going to say the cache at 3 is equal to and it's going to be 1 plus 1 which is 2. so now i'm going to change the cache so now in the cache we're going to add key 3 and it is going to have value 2. so now whenever we try to find what the n fibonacci number of 3 is we'll be able to do that very fast we just take it from the cache okay then we need to solve 2. so now when we go to try to solve 2 i don't actually need to call 1 and 0 and the reason i don't need to do that is because 2 is inside of the cache so since 2 is inside of the cache i've now just avoided doing 2 recursive calls and what i do is simply grab the value from the cache which is 1 and i can return that up to 4 which is what needed that value so we're going to return 1 there and then from over on this side we're returning a value of 2. so now when we get the 4th fibonacci number we're going to say the cache at 4 is equal to and then this is going to be 2 plus 1 and that's going to give us 3 so we're going to insert this into the cache so we're going to say okay 4 this has value 3. and now same thing whenever we try to solve the sub problem 4 again we can just grab the value from the cache as opposed to actually doing those recursive calls now finally we go to this recursive call over here which is for value three and for three it's inside of the cache so i can simply return the value so i return the value of two from four we know this number was 3 and so we know now that the 5th fibonacci number is value 5. we add those together we would actually add it to the cache and then we just return the value from the cache hopefully that explained how this worked but what we were doing was storing the solution to each sub problem as we went and that avoided us having to do a bunch of recursive calls that we had to do in the previous solution and if we wanted to reduce these even more we could start the cache and say okay cache is equal to then we could have something like 0 1 and 1 1 but that would effectively give us the exact same solution as just having if n is less than 2. but we could remove this if statement and simply add these values into the cache as well just noting there's kind of multiple ways to go about solving this all right hopefully that makes sense but you've just seen an example of dynamic programming we've used a technique here called memoization now this is a technique that's used for dynamic programming problems or within a dynamic programming solution and all it involves is storing results that we've calculated in the past so we don't have to calculate them again all right so that is the first thing that i want to show you the first example i wanted to go through hopefully that is all clear now we're going to get into a more difficult problem and i'll give you a chance to solve it on your own and then i will walk you through the multiple solutions and different ways to go about solving it one of which of course is going to use dynamic program alright so i've just written an array on the screen here or a list whatever you want to refer to it as and i'm going to ask you the following question i'm just going to verbalize it so just listen think about it and then i will talk about how we solve so the question is determine the minimum possible sum of any continuous subarray in this array so what that means is that i could have a subarray say like this this is a continuous subarray because all of the elements are adjacent to each other i could have a subarray that's these elements i could have a subarray that's just one single element but they have to be touching i can't have a subarray that has say this this and this that would not be a continuous subarray so they just have to be touching hopefully that's clear but any continuous subarray what is the minimum possible sum of any one that we have and for this example right here the minimum sum that we would have of any continuous subarray is negative 7. now there's two possible answers here the first answer is to take this as the subarray the second answer would be to take this as the subarray if you take the sum of all the elements within these you'll see that they both add up to negative seven so that's really the question i'm asking you determine what the minimum possible sum is of any continuous sub array in an array so take a second if you want think about how you would solve it and then i'm going to show you the naive approach that does not use dynamic programming then we will talk about the dynamic programming approach so hopefully you've taken a second to think about how you would solve this problem because i'm going to go through a solution now this solution that i have is the nonoptimal solution it runs in a time complexity the big o of n squared and this does not use dynamic program now this solution simply says what i'm going to do is find every single subarray in this array and then calculate the sum of all of those subarrays and determine what the minimum sum is that's it so we start by calculating all of the subarrays that start at negative seven calculating the sum for all of them and then updating this min sum variable then all of the subarrays starting at 3 then all of the sub arrays starting at 4 all of them starting at negative 2 so on and so forth and we get every single sub array that we have calculate the sum update this variable and well that will give us the correct answer now this solution is fine it does solve the problem there's nothing wrong with this the issue is that it runs in n squared and there is a faster and better way to solve this problem that involves using dynamic programming so what i want to ask you now is if you came up with this solution can you think of any way to solve this problem in linear time and at this point i will mention if you're unfamiliar with time complexities i do have an entire video on them so i'll leave it on the screen here and in the description anyways think of a way that you can solve this in linear time or big o of n time utilizing dynamic programming now you may not be able to come up with it that's totally fine of course that's why i'm here i'm going to explain it to you but just take a second and think okay can i solve this in a more efficient way so the answer of course is yes that's why i'm using this problem but let's get rid of this and let's talk about how we would actually frame this problem as a dynamic programming problem and how we would write a solution that utilizes the solution to sub problems so when you want to solve a problem using dynamic programming again what you really need to think about is what subproblems am i going to have and how are the solutions of those subproblems going to help me come up with the solution of the entire problem so i've just written a new example here and i'm going to start walking you through how we solve this using dynamic programming now in this example we want to try to solve this using one single pass of the array so rather than writing an algorithm right now let's kind of try to do this as a human and figure out what values we're going to want to store and how we're going to optimize the previous solution so again we only do a single pass of the array and there's no need to have a nested for loop and an n squared time complexity solution so what i'm going to do is start here at this element and i'm going to have some variable here i'm going to say min sum and this will be equal to 0 and this will just store what the minimum sum is that i've found so far and what i'm trying to do here again is create this minimum sum sub array or actually determine what the minimum sum is of any subarray so i need to kind of build different subarrays as i go through here and determine what their sums are update this value and then figure out essentially what elements i want to be in this subarray okay so i start at 20 we can kind of imagine that we can't see any of this right now because we're just looking at element 20 and i'm going to ask at element 20. what is the minimum possible sum that i can create using this element so at every single element the question i want to ask is if i were to use this element what is the minimum sum that i can create in a subarray so if this element was in any subarray i don't know how big or small the sub array would be but if it was included 100 what's the minimum sum i could generate that's what we're asking so in this case at 20 we know that the minimum sum that we can make is 20. so let's just write this here and we'll update this minimum sum variable really this should have been float infinity or just infinity before and so this will now go to 20 because if we have a subarray that just includes this element right here well the sum of that is 20. okay now we move on to the next element negative 7. now same question here i want to ask if i were to include this element negative 7 what is the minimum possible sum that i could have now the way that i determine that is i need to look at the minimum sum of the previous element and i need to add that to the current element and then compare that to what the value of the current element is so we'd have 20 minus 7 that's going to give us a sum of 13 or if we did not include this previous element so if we were to start the subarray say right here then we would have a sum of negative 7 okay so obviously negative 7 is going to be a smaller sum so i'm going to put negative 7 there and i would imagine that okay if i had the sub array i would not expand my sub array to be like this i would just start my sub array here on negative 7. no need for 20. that does not help me or it doesn't make it any more negative negative seven however it does okay so we have negative seven now with the minimum sum that we found is negative seven and that's if we're just using a sub array like this again from here we wanted to see okay should we include any of the elements prior and we said no because if we did then it was going to make this a larger sum than just having the element itself okay so now we have negative 7 and i'm going to move on to negative 3. so now if i'm on this element i ask the same question if i have a subarray that includes this element 100 so we're going to end right here would i want to include the minimum sum of the previous element or just this element well if i were to take whatever the minimum sum is that i could have using this previous element so including the previous element right here then that sum would be negative seven and that obviously would make this lower than negative three so i would just write negative ten here we're comparing negative seven minus three and just the element itself negative three well what's lower of course negative 10. okay so let's erase this bar here so now we move on to nine and don't worry i will explain this again so it makes perfect sense let's just walk through the entire example okay so now we're on nine same question from nine if i were to have a sub array that included the element 9. would i want the previous elements in the array to be a part of it or would i want just element 9 well in this case i have 9 and i'm going to compare that now to whatever the minimum sum is that i could create by using the previous element so again really what i'm doing here from 9 is i'm looking at this value right here and i'm saying okay if i were to include the last element what is the minimum sum that i can create that uses the last element in a subarray it's not just the value of the last element it is again the minimum sub that i can create by using the last element in a subarray and we know that the subarray with the last element is negative seven and negative three so now when we come to 9 we say okay well if we're going to use this element in the subarray do we want it to just start here or do we want to include potentially some other elements well i look at this negative 10 i say well that's less than 9 it's going to make this smaller so of course we're going to include that and now the sum that i can create at 9 is going to be negative 1. now i'm not going to update my minimum sum and in fact the minimum sum should be negative 10. sorry i should have updated that before because well negative 1 is not less than negative 10. okay now i move over to negative 4. so from negative 4 again we have the same question should we include previous elements in the array well if i include this previous element right here i know that the minimum sum i can generate that uses this previous element currently is negative 1. so that means i can say the negative 5 is going to be the sum right here and that's of course going to be lower than me starting the sub array right here of just negative 4. okay hopefully this is all making a bit of sense continuing we'll move over to 6. now from 6 i ask the same question okay should i include the previous element if i'm going to have this element in a subarray or should i just start the sub array right here well i want to include the previous element because negative 5 is less than 6 so that's going to give me a sum of 1 right here for this element no need to update max sum continuing here we're now at negative 9. now at negative 9 i ask the question is it helpful to me to include the previous element which is going to be 6 or do i start my subarray right here well the answer of course is no i'm not going to include it i'm going to get a sum of negative 9 and i'm going to start right here with this element because the minimum possible sum that i can create using this element with all of the previous elements that i have in this array is 1 and 1 plus negative 9 gives me a larger value than the negative 9 itself so i just start at negative 9. okay lastly i come over to 10. now the answer here is just going to be 1. of course we're going to going to include negative 9 because that's going to make this lower so now i actually know that the minimum possible sum that i can create is going to be negative 10. in that there you go i return that answer now i know this is not crystal clear but really all we did at every single position here in this array is we ask ourselves the question what is the minimum possible sum that i can get when i include this element in the sub array now the answer to that is it's either the element itself or it's the element itself plus the minimum sum that we can get when we include the previous element because we need to have a continuous subarray so if we're including the previous element well whatever the minimum sum is that it can have plus our current element that's the minimum we could get if we included this element and that allows us to actually not need to keep track of the different indices of the subarrays but to determine the minimum sum by constantly updating this min sum variable as we run through the problem now the dynamic programming aspect of the solution is that i am storing the solution to every sub problem that i solved and i'm simply taking the minimum of all of the solutions that i had right so all of these sub problems i need to solve i solved them one by one and they actually utilized the solution to the previous subproblems i then take the minimum of all of those sub problems and well that gives me the solution to the problem so let's clear the screen here and let's have a look at what the solution actually looks like in code all right so i've got the solution in front of me to find my function i have my if statement so just handling an empty array here and then i'm saying the min sum using element is equal to array at zero so this is what we're going to use to actually store all of these subproblem solutions and then the minimum sum well this is going to give us the complete answer because we're taking the minimum sum of any of the subproblem solutions okay we then continue here we say 4i in range then we're looping through all of the elements except index 1. our accept index 0 sorry because we've already handled that up here and then we're going to say the number is equal to array at i and we're going to generate what the current minimum is that we can create using this element so the minimum possible subarray sum we can get that uses the current element that we're on as i said that's going to be the number let me draw this in a different color here or the number plus the minimum sum using element at the previous index so if we were to include the previous element whatever the minimum sum is that we could create using that element we add that to the current element and we take the minimum of those two values okay we then say the min sum using element dot append current minimum then we say the minimum sum is min of min sum and current min then we continue this and well that solves the problem for us so this solution does run in big o of n time however it takes big o of n space because of the fact that we're using this array now some of you may have noticed that since we're only ever looking at the last element in the array we actually don't need to utilize an array and store every single subproblem solution what we can do instead is simply store the previous subproblem solution so let me put on the code for that and show you what that looks like all right so now this is the updated solution which is going to run in big o of n time and is going to take big o of 1 or constant space because we've now removed the array and instead we're just saying the min sum using the last element and this is not an array it's just whatever the last value was because we only need to access the last value again so we can just use a variable as opposed to using an entire array now let you read through this code but at this point i am finished with this video now dynamic programming on its own is not extremely complicated what's actually most difficult about it is determining how you write a problem in a dynamic programming way so how you frame the problem in a way such that you're solving sub problems so that's what i was trying to illustrate to you before when i was walking through the array step by step is that we can look at this problem and say okay the sub problem that we're solving is what's the minimum sum that we can generate when we include this element and once we start framing the problem in that way it now becomes very easy to figure out how those sub problems actually lead us to the optimal solution so that's what you need to think about when you're saying okay can i use this problem for dynamic programming or sorry can i solve this problem using dynamic programming you need to think what way can i look at this problem and kind of read it out such that i have sub problems that i'm solving and that's not always possible and sometimes you can solve sub problems but those don't actually lead you to the optimal solution so you have to rethink your approach anyways with that said i will wrap it up here hope you found this helpful if you did make sure to leave a like subscribe to the channel and i will see you in another one you
