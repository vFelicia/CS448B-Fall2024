With timestamps:

00:02 - [Music]
00:08 - hello everybody and welcome to another
00:10 - video in this blockchain for beginners
00:12 - tutorial series in this video we're
00:14 - going to be continuing from the last
00:16 - video and learning more about solidity
00:18 - once we learn a few new topics then
00:20 - we're actually going to work on an
00:22 - auction where we're going to be
00:23 - auctioning an nft now this will work
00:25 - with any type of nfts this is really
00:27 - really cool and if you're interested in
00:29 - nfts you're going to learn a little bit
00:30 - about how they work so with that said
00:32 - we'll get into the content in a second
00:34 - but i do need to thank cartesi again for
00:36 - sponsoring this video and this series
00:38 - they are an awesome company they've been
00:40 - helping me come up with the content for
00:42 - this series and they have a bunch of
00:43 - scaling solutions for ethereum and for
00:45 - developing smart contracts that we're
00:47 - gonna look at in a future video
00:49 - regardless let's go ahead and get into
00:51 - the content alright so i'm back in remix
00:54 - and in front of me i have the example
00:56 - that we finished in the last video which
00:58 - is kind of a mock bank account now what
01:00 - i'm going to do is just give you a quick
01:01 - recap of everything that's in this
01:03 - contract so we understand the syntax and
01:05 - get a quick refresher then we'll look at
01:07 - some new solidity features and we'll
01:09 - actually move into working on that
01:10 - auction which is going to be the bulk of
01:12 - the video okay so right now we can see
01:14 - we're inside of a dot sol file now the
01:17 - dot sol stands for solidity and that's
01:19 - the extension you need for your solidity
01:20 - smart contracts now at the top of our
01:23 - contracts we need a pragma line now the
01:25 - pragma line is going to tell solidity
01:26 - what compiler version we should use so
01:29 - in this case we're using 0.8.10 to see
01:31 - the compiler versions you can go to the
01:33 - solidity compiler extension click here
01:35 - and then it will show you the versions
01:37 - in this case 0.8.10 is one of the latest
01:39 - so that's the one that we're going to
01:41 - use
01:42 - great we then define our contract we say
01:43 - contract my contract open the curly
01:46 - brace and close the curly brace and
01:47 - inside of here is the content of our
01:50 - contract now it's worth noting that you
01:51 - can define multiple contracts in one
01:53 - solidity file and you can have stuff
01:55 - like contract inheritance that's a
01:57 - little bit complicated we don't need to
01:59 - look at that here but just wanted to
02:00 - mention that okay so inside of our
02:02 - contract here we start by defining what
02:04 - most of you would consider a class
02:06 - attribute this is just going to be
02:08 - actually a private member of this class
02:09 - because we've defined it as private
02:11 - anyways this is a mapping type now the
02:13 - mapping type is like a hash table or a
02:15 - dictionary where we have some key that
02:18 - can be associated with some value now in
02:20 - this case we're having an address this
02:21 - is going to be an ethereum address being
02:23 - associated with a uint so an unsigned
02:26 - integer we then denote this as private
02:28 - meaning we can't directly access this
02:30 - from outside of the contract and then we
02:32 - have balances that's just the name of
02:34 - this mapping okay now we have a function
02:36 - the function is called deposit it's
02:38 - denoted external and payable now
02:41 - external says that we can only call this
02:43 - function from outside of the contract so
02:45 - i couldn't go here and do something like
02:47 - deposit that would be invalid because
02:49 - this is an external function then we
02:51 - have payable payable is saying that this
02:53 - is either going to be sending money to
02:55 - someone or receiving money or
02:57 - specifically ether and in this case
02:59 - since we're going to be getting money we
03:00 - have to make it payable then what we do
03:02 - inside of deposit is we say balances at
03:05 - message.sender now message.sender is
03:07 - going to be the address of the sender of
03:10 - the transaction who's sending money to
03:12 - this contract so essentially whoever
03:15 - invoked the call to this contract or
03:17 - made the transaction to this contract
03:19 - it's going to be their address we're
03:20 - adding that as a key to balances and
03:23 - then we're going to increment the value
03:25 - here by message.value
03:27 - now message.value is going to store the
03:29 - amount of ether that they sent to this
03:31 - contract and the reason why we can do
03:33 - this is because the default value of all
03:35 - of our uins inside of our mappings is
03:37 - going to be zero so even if this sender
03:40 - does not already exist in the mapping
03:42 - we'll simply make the value equal to
03:44 - whatever the message.value is because
03:46 - the default value is 0. hopefully that
03:48 - makes sense that's explained in the
03:50 - previous video in case you are confused
03:52 - regardless we now have withdraw so
03:54 - withdraw is going to take in an address
03:56 - payable this is going to be our addr
03:59 - that's going to take a new int amount
04:01 - now this means that we need to pass an
04:03 - address to this withdraw function this
04:05 - is the address that we want to withdraw
04:06 - funds to then we have uint amount this
04:09 - is the amount of funds that we want to
04:10 - withdraw from the contract now this is a
04:13 - public payable function
04:15 - when we say this is public that pretty
04:16 - much means it can be called from
04:18 - anywhere and then we have payable and
04:20 - again what payable means is we're either
04:22 - going to be sending money out or
04:23 - receiving money so of course we need to
04:25 - denote this function as payable
04:27 - okay we then have a require statement
04:29 - now what the require statement is going
04:30 - to do is it's going to check if this
04:32 - condition is true and if it is not true
04:35 - then it's actually going to raise an
04:36 - exception and the exception is going to
04:38 - be insufficient funds that means we're
04:41 - actually going to cancel the entire
04:43 - contract call everything that would have
04:45 - happened is going to be reverted i'm
04:46 - going to talk about this more in a
04:48 - second and essentially this transaction
04:50 - is going to fail because this condition
04:52 - was not satisfied okay so you use
04:54 - require when you want to ensure that
04:56 - something is true before proceeding in
04:58 - the contract okay so we're requiring
05:00 - that the balance of the address is
05:02 - greater than or equal to the amount that
05:03 - we want to withdraw makes sense if we
05:05 - don't have that then the error or the
05:07 - exception is insufficient funds so next
05:09 - we're actually going to send money from
05:11 - the smart contract to this address if
05:14 - they had sufficient funds to withdraw so
05:16 - we're going to say bool sent bytes
05:17 - memory data is equal to adr dot call and
05:20 - then we're putting the amount that we
05:22 - want to withdraw
05:23 - and we're actually calling this
05:24 - transaction now if you're confused on
05:26 - how this line works i spent about three
05:28 - or four minutes explaining it in the
05:29 - last video so you can go back and watch
05:31 - that essentially all this is doing is
05:33 - sending money to this address this is
05:35 - the amount of money that it's going to
05:36 - be sending or the amount of ether
05:38 - great then we have this bool sent now
05:41 - this bool sent is going to be equal to
05:42 - true if we successfully sent this
05:44 - otherwise it's going to be equal to
05:46 - false so if we were not able to
05:48 - successfully send the money some error
05:50 - occurred there then we're just going to
05:51 - raise the exception could not withdraw
05:53 - otherwise what we're going to do is
05:55 - we're going to update the balances so
05:56 - we're going to say balances at
05:57 - message.sender minus equals the amount
06:00 - to make sure they can't just keep
06:01 - withdrawing the same amount of money
06:03 - it's actually going to subtract from
06:04 - their current balance when they withdraw
06:07 - great then we go to this function so
06:09 - this is get balance now let's say public
06:11 - view function now again public means we
06:13 - can call this from anywhere and view
06:15 - actually means that this is only going
06:17 - to be returning or accessing state from
06:19 - this contract it's not going to be
06:21 - modifying it so this means we can call
06:23 - this get balance function without
06:25 - actually having to make a transaction
06:27 - which pretty much means this is free to
06:29 - call so this is a good point in time to
06:31 - remind you that whenever we're just
06:32 - accessing the state of a contract this
06:34 - is free we can just query the state of
06:36 - the contract we don't need to pay for
06:38 - this however if we're going to be
06:39 - actually modifying the state then that
06:41 - requires a transaction that transaction
06:43 - needs to be mined and while that means
06:45 - it's going to cost us some money at
06:46 - least in gas and potentially ethereum if
06:49 - what we're doing requires that we send
06:51 - ethereum okay so let's continue
06:53 - explaining this we then have returns and
06:54 - then you end now returns is just stating
06:57 - what this function is going to return
06:58 - we're saying u in standing for unsigned
07:00 - integer and then here all we're doing is
07:02 - we're returning the address of this now
07:05 - this is just going to be the contract
07:06 - we're just going to cast this to its
07:08 - actual address and then we're going to
07:10 - get the balance whenever you have an
07:11 - address you can access the balance by
07:13 - just using dot bounce there you go that
07:16 - is everything that we did inside of this
07:18 - contract so now that we've talked about
07:20 - all of this i just want to spend a
07:21 - second talking about exceptions because
07:23 - we've seen them in this contract but i
07:25 - haven't actually talked about exactly
07:27 - what they do and how they work so in
07:29 - solidity we have a few different ways to
07:30 - actually throw an exception or to cause
07:33 - an exception to occur now an exception
07:35 - is pretty much an error that's going to
07:37 - occur in our program and all exceptions
07:39 - in solidity are state reverting now what
07:42 - that means is if there's ever an
07:44 - exception at any point in time during
07:46 - the transaction call then this is going
07:48 - to revert the state back to what it was
07:50 - previously any changes you've made up
07:52 - until that point will be completely
07:54 - removed so just to give you an example
07:56 - here let's say
07:58 - that i did something like
08:00 - balances at 1 is equal to 2. now i know
08:03 - this makes no sense but let's say i did
08:05 - this right here and then i come to this
08:06 - required line and this actually ends up
08:09 - raising an exception because sent is
08:11 - equal to false well if that's the case
08:13 - this line will be completely reverted we
08:15 - won't actually have done that operation
08:17 - it will be undone and reverted back to
08:19 - what it was before so just worth noting
08:21 - whenever an exception occurs any of the
08:24 - state in the contract that's been
08:25 - changed is going to be reverted now
08:27 - require as i'm kind of alluding to here
08:29 - does cause an exception right so if the
08:31 - condition here is not true then it
08:33 - raises an exception and the message for
08:35 - that exception is going to be whatever
08:37 - we put here now there's a few other ways
08:39 - that we can raise exceptions in solidity
08:41 - i'll quickly show them to you although
08:42 - we're not really going to look at an
08:43 - example of them
08:45 - so one way to raise an exception is to
08:47 - use revert now revert actually allows us
08:50 - to just directly uh reverse the entire
08:52 - contract state again this is just going
08:54 - to raise an exception exactly like
08:56 - require will except inside of here we
08:58 - can just put our error message we don't
09:01 - actually need to put any condition so if
09:03 - we ever encounter a revert in the
09:05 - program we're just immediately going to
09:07 - raise an exception the exception message
09:09 - will be this and again that's going to
09:11 - revert the state because that's what all
09:12 - exceptions do in solidity okay
09:15 - so that's revert now another thing that
09:17 - we have is a cert now a search is
09:19 - similar to require in fact it works in
09:22 - the exact same way except it's designed
09:24 - to be used when you want to check in
09:26 - variants rather than checking input
09:28 - validation so i'll show you here i could
09:30 - do something like assert
09:32 - true
09:33 - is equal to true now of course that's
09:35 - always going to be true but
09:37 - you get the idea now if this condition
09:39 - was false what would happen is we would
09:41 - raise an exception with this as the
09:43 - error message now assert and require are
09:45 - pretty much identical but the reason you
09:47 - use assert is because you're checking an
09:49 - invariant if you don't know what that
09:50 - means don't worry about it and if we're
09:53 - using require we're using that when we
09:55 - want to check input validation okay so
09:57 - that's why we're using require here
09:59 - because we want to ensure that the
10:01 - amount that they passed in is valid now
10:03 - in this case we could probably actually
10:05 - replace this require with an assert it's
10:07 - not a huge deal and there's actually not
10:09 - really any formal recommendation on
10:11 - which one you should use but it's kind
10:12 - of the standard to just use assert when
10:14 - you're checking an invariant and require
10:16 - when you're checking input validation so
10:18 - in this case based on what i'm saying we
10:20 - would use assert here because this is an
10:22 - invariant but we also can just use
10:24 - require like i had before that's
10:25 - completely fine anyways this isn't super
10:27 - important but i just want to show you
10:29 - those methods in case you see them in
10:30 - other contracts alright so that's almost
10:32 - everything for exceptions one more thing
10:34 - to note here is that the only thing that
10:36 - will not be reverted if an exception
10:39 - occurs is low level calls like this
10:41 - adr.com now i can't really show you what
10:44 - the other calls are because we haven't
10:45 - seen them but essentially if you were to
10:47 - send money to someone successfully and
10:50 - then later on in the contract there's an
10:52 - exception that occurs that's not going
10:54 - to be reverted you just can't revert
10:56 - that because once the funds are
10:57 - transferred well you can't really just
10:58 - transfer them back and so if i did
11:01 - something like this
11:02 - and let's say that this was successful
11:04 - then that means this is not going to be
11:06 - reverted now everything else will be
11:07 - reverted this balances will be changed
11:10 - back but this isn't going to be reverted
11:12 - the ethereum that was sent to that
11:13 - account is not going to be sent back to
11:15 - the smart contract okay there's some
11:17 - good reasons for that but that's worth
11:19 - noting
11:20 - now
11:21 - a few other things to mention here with
11:23 - exceptions exceptions are cascading now
11:26 - that means if i have an exception that
11:28 - occurs in another smart contract that
11:31 - i'm calling from this smart contract
11:33 - that's going to mean that the state of
11:35 - this contract
11:36 - as well as the state of the other one
11:38 - are going to be reverted so it's kind of
11:40 - hard to show this but let's say i make a
11:41 - contract
11:43 - and i call this my contract
11:46 - 2 like this and let's just make some
11:48 - functions so we can do something like
11:51 - function
11:52 - test and then just make this public
11:55 - view
11:56 - returns
11:58 - you ins
11:59 - okay and then maybe what i do here is i
12:01 - just say revert okay so that's what i do
12:04 - now if i call this function okay from
12:08 - inside of here then even though it's
12:10 - happening inside of this contract the
12:12 - exceptions occurring here it's going to
12:14 - cascade into this contract meaning that
12:16 - if any of the state was changed inside
12:18 - of here that's going to be reverted and
12:20 - same with any of the state inside of my
12:22 - contract too
12:24 - hopefully that makes sense but just keep
12:26 - in mind that exceptions cascade so even
12:28 - if you have like 10 contracts all
12:30 - calling each other and then in the 10th
12:31 - contract an exception occurs every
12:33 - single one of the contracts that we're
12:35 - dealing with that contract are going to
12:37 - get the cascading exception and all of
12:39 - them are going to have their state
12:40 - reverted and the transaction will fail
12:42 - now just to note here the reason why
12:44 - we're getting this error is because i
12:45 - didn't have the semicolon of course
12:46 - revert is fine i can put this here
12:49 - although this doesn't really make much
12:50 - sense because why would you just revert
12:52 - inside of a function all right so now
12:54 - that we've talked about exceptions what
12:55 - i can do is start showing you some new
12:57 - features in solidity and the first thing
12:59 - i want to do is show you a constructor
13:01 - so i'm just going to clear everything
13:02 - that's inside of this contract and i'm
13:04 - going to write a public variable here so
13:07 - i'm going to say let's go with address
13:10 - and this is going to be
13:12 - public and then i'm going to say that
13:13 - this is the owner of the contract
13:16 - so what i'm going to show you is a
13:17 - constructor now a constructor is simply
13:20 - a special function that's a part of a
13:22 - class or in this case a contract that's
13:24 - going to be called when the contract is
13:25 - initialized now in solidity your
13:27 - constructor will be called exactly one
13:30 - time and just like any other language
13:31 - constructor you can accept parameters in
13:33 - here you can do some setup steps and
13:36 - well you'll see how this works so the
13:37 - way you implement a constructor in this
13:39 - version of solidity is constructor
13:41 - open and close parentheses open and
13:43 - close curly brace and then inside of
13:45 - here you can do whatever you want so in
13:47 - this case i'm just going to say my owner
13:49 - is equal to the message.sender
13:51 - now the reason i'm doing this is so that
13:53 - i can keep track of who actually created
13:54 - this contract so when i create a
13:56 - contract i have a message.sender whoever
13:59 - sent the transaction to actually create
14:00 - the contract so this is perfectly valid
14:03 - i can say my owner is equal to the
14:05 - message.sender and now whoever deployed
14:07 - the contract will be the owner and i'll
14:09 - be keeping track of that inside of this
14:11 - public variable on the contract okay
14:14 - pretty straightforward that's how that
14:16 - works now again this is how you do the
14:17 - constructor you can only have one of
14:19 - them and this will be called exactly one
14:21 - time and only one time when the contract
14:24 - is deployed this isn't going to be
14:26 - called every single time a transaction
14:28 - is sent to the contract it's only called
14:30 - when it's deployed the very first time
14:32 - so let me show you how this works let's
14:34 - go and actually deploy this to the
14:36 - javascript vm
14:37 - let's click on deploy
14:39 - okay
14:40 - we have our contract when i click on
14:42 - owner it's going to give me the address
14:44 - of this account right here which is the
14:45 - one that i'm using now let's try
14:47 - deploying from this account
14:49 - okay so deploy
14:51 - my contract's down here
14:52 - owner now it's giving me the other own
14:54 - pretty straightforward that is how the
14:56 - constructor works and this is a pretty
14:58 - common thing that you'll want to do is
14:59 - keep track of who actually deployed the
15:01 - contract now another thing you can do in
15:04 - here is accept parameters so maybe i
15:06 - just want to accept a uint and let's
15:07 - just go with something like test for now
15:10 - again this can really be anything okay
15:12 - so i want this to be test and then what
15:14 - i will do is say
15:16 - u int
15:18 - public and let's just go with
15:20 - i don't know v i'm just picking random
15:23 - names for now and i can do something
15:24 - like v is equal to test that's
15:26 - completely fine i can access the value
15:28 - of this parameter so now let's get rid
15:30 - of these contracts all right so now we
15:32 - can deploy our contract and notice where
15:34 - the deploy button is it's actually
15:36 - giving me a parameter that i need to
15:37 - pass here it's saying tasks this is the
15:39 - uint256
15:40 - so i'm going to do something like 2 hit
15:42 - transact now i go to my contract i have
15:44 - owner and i have v and i can see v is
15:47 - equal to 2.
15:49 - there you go that is the basics of the
15:50 - constructor now of course you can have
15:52 - multiple arguments if you would like or
15:54 - multiple parameters sorry and do
15:55 - whatever you please with them great so
15:58 - what i'm going to do now is just get rid
16:00 - of everything inside of here and i'm
16:02 - going to start talking to you about a
16:03 - new thing which is called a pure
16:05 - function now we've looked at view
16:07 - functions we've looked at payable
16:08 - functions internal functions external
16:10 - functions public functions now we want
16:12 - to look at pure now a pure function is
16:15 - pretty straightforward but it is simply
16:16 - a function that is not going to do
16:18 - anything with the state of the contract
16:21 - you can kind of think of it like a
16:22 - static method because it has no access
16:25 - to the internal state of the contract it
16:27 - just does some type of computations then
16:29 - returns some value so i'm just going to
16:31 - write a function here i'm going to say
16:32 - function and this will be something like
16:34 - add two now we will make this a public
16:37 - and then this will be pure function and
16:41 - this is going to return
16:43 - a u int
16:45 - like that now i'm going to take as a
16:48 - parameter here the u int x and all i'm
16:51 - going to do is just
16:52 - return like this x plus 2. okay very
16:56 - straightforward but this is a pure
16:58 - function now as i said a pure function
16:59 - is not going to modify or access the
17:01 - state of this contract it's just going
17:03 - to be performing some type of
17:05 - computation that doesn't rely on the
17:08 - actual contract internal state so just
17:10 - like accessing the data from a contract
17:12 - this is going to be free as well we
17:14 - don't need to pay to do this and let me
17:16 - prove this to you so if i go to my
17:18 - injected web 3 now i'm connected to the
17:20 - goreli test network and i do
17:23 - deploy this okay it's going to ask me
17:25 - for a i guess transaction because when i
17:27 - deploy i need to pay for that
17:29 - and then let's give this a second okay
17:32 - we can see that our contract is deployed
17:34 - now let's do something like add two five
17:36 - notice it gives me the value seven back
17:38 - i didn't need to add a transaction to be
17:40 - able to do this okay so whenever you
17:42 - have a view or a pure function these are
17:44 - free you don't need to have a
17:45 - transaction to call these so if you ever
17:47 - just want some type of utility functions
17:49 - associated with your contract then you
17:51 - make them pure okay hopefully that makes
17:53 - sense that's all i need to cover with
17:55 - pure
17:56 - okay so now that we've gone through that
17:57 - we can start getting into the important
17:59 - stuff which is events so i'm actually
18:01 - going to hop over to the drawing tablet
18:02 - to explain to you what events are and
18:04 - then we'll start implementing them when
18:06 - we work on the auction all right so i'm
18:08 - now on my drawing tablet i'm going to
18:10 - start explaining events to you but
18:11 - before i can do that i need to talk to
18:13 - you about why we need them
18:15 - so in front of me i have a smart
18:16 - contract now this is going to be our
18:18 - auction contract and on the auction
18:20 - we're going to have some function called
18:21 - start now of course we're going to have
18:23 - some other functions as well but for now
18:25 - just imagine we have start and what
18:27 - start is going to do is it's going to
18:28 - attempt to start the auction so it's
18:30 - going to modify some of the state and
18:31 - then it's going to return a value
18:33 - indicating to us whether or not this was
18:35 - successful so we're expecting this to be
18:37 - a bull let me just write this right here
18:40 - indicating that it's going to return a
18:41 - bool
18:42 - okay that's great so now we want to
18:44 - start the auction so let's say we have
18:46 - some account so account one like this we
18:48 - know since this is going to modify state
18:50 - we need to make a transaction to the
18:52 - auction to be able to start this so i'm
18:55 - going to make a transaction we're going
18:57 - to call start on here and then what
18:59 - we're expecting is that we're going to
19:00 - get some return value here indicating to
19:02 - us whether or not this started
19:04 - successfully well if we're just working
19:06 - on our javascript vm then we know that
19:08 - it's actually going to work successfully
19:09 - we're going to be able to get a return
19:11 - value we'll see something like true or
19:13 - we'll see something like false
19:15 - however if we're working on a real
19:17 - blockchain we're actually not able to
19:20 - return something from a function that's
19:22 - modifying the state
19:24 - back to our account so essentially
19:26 - whenever we're making a transaction we
19:28 - can't return data back to that
19:30 - transaction now this actually makes
19:32 - sense if you look at how transactions
19:34 - work but for now you really need to
19:36 - understand that if you ever make a
19:37 - transaction to a smart contract that
19:40 - contract cannot return you any data now
19:42 - it can try it can have a return
19:44 - statement but you're not going to be
19:46 - able to view that return data from the
19:48 - transaction so really we have to imagine
19:50 - that this is going to be a one-way
19:52 - operation where we're just going to call
19:54 - start now if an exception occurs we're
19:56 - going to be notified of that however if
19:58 - an exception doesn't occur we're not
19:59 - going to get any return value so trying
20:01 - to do something like this is not going
20:03 - to work on a real blockchain now that's
20:06 - a pretty big problem right because in a
20:07 - lot of situations when i make a call or
20:09 - i make a transaction sorry to my smart
20:12 - contract i probably want to get a return
20:14 - value i need some information i want to
20:16 - know if this started successfully
20:18 - however we can't have a returned value
20:20 - so how do we get around this problem
20:22 - well the way we get around this problem
20:24 - is with events so what a smart contract
20:27 - can do is it can actually emit events
20:30 - now that means that what we can do from
20:31 - auction is when we start this we can
20:34 - create or omit
20:35 - something known as an event and this
20:38 - event can have a return value that we
20:41 - might want this account to be able to
20:43 - see so we can emit an event that says
20:45 - something like started
20:47 - and then maybe we can put the time that
20:49 - this started out and we can put if it
20:51 - happened successfully or not so we could
20:52 - but true or alternatively we could put
20:55 - false now these events will be stored on
20:57 - the blockchain however they're going to
20:58 - be stored in a different way than the
21:00 - data associated with your contract so
21:02 - any of the variables you would have
21:04 - defined or kind of the state of the
21:06 - contract is said to be in storage these
21:09 - events are not going to be in storage
21:11 - they're going to be stored as a part of
21:12 - the transaction history on the
21:14 - blockchain so that makes them a little
21:15 - bit less accessible however they are
21:18 - much cheaper to use because of the way
21:20 - that they're stored so i'm not going to
21:21 - get into this too much but essentially
21:23 - just understand that your events are
21:25 - stored in a different way that makes
21:27 - them much cheaper to actually store
21:29 - although they are a little bit harder to
21:30 - access so that means that you usually
21:32 - use a third-party tool maybe something
21:34 - like etherscan to actually read and
21:36 - query these events because it's not as
21:38 - simple to go directly look at them like
21:41 - it is for the data on the contract and
21:43 - so we omit this event and then this
21:45 - account here or some external client
21:48 - that's off the blockchain is able to
21:50 - view these events and subscribe to them
21:52 - so they'll be notified if an event
21:54 - occurs now i'm going to get into a
21:56 - detailed example in a second but for now
21:58 - just understand that whenever we have a
22:00 - transaction our smart contract cannot
22:02 - return a value to that transaction
22:05 - instead what it can do is emit an event
22:07 - this event will be stored off the
22:08 - blockchain you can kind of think of
22:10 - these events as a log right
22:12 - we'll be able to then view those logs
22:14 - off of the blockchain and we can search
22:16 - for specific data inside of those logs
22:19 - and subscribe to events which means
22:21 - we'll be notified when an event occurs
22:24 - now just an important note here this is
22:26 - not the case so the no return value
22:28 - thing is not a case if we're making a
22:30 - call not a transaction now i understand
22:32 - this is a bit confusing but if i'm
22:34 - making a call to a function that does
22:36 - not modify the state so that doesn't
22:38 - require that i spend money on it doesn't
22:40 - need a transaction essentially i'm just
22:41 - querying the state then of course i can
22:43 - get a return value right if all i want
22:45 - to do is just get some data that's
22:47 - stored in the state of the auction
22:48 - that's fine i can do that i can get a
22:50 - return value but if i make a transaction
22:52 - that modifies the state that's the
22:54 - situation where i can't get a return
22:56 - value okay hopefully that makes sense
22:58 - but that is why we need events so now
23:00 - let me clear the screen and let's get
23:02 - into a more advanced example all right
23:04 - so for this example what i want to do is
23:06 - imagine that we're trying to build an
23:07 - application that's going to be partly on
23:09 - the blockchain that's going to allow us
23:11 - to auction our nft so again we still
23:13 - have this auction this is our contract
23:16 - but now what we probably want to do is
23:18 - we probably want to make a nice
23:19 - beautiful user interface that allows
23:21 - users to interact with this auction so
23:24 - to interact with the auction the owner
23:26 - of the auction is going to need to start
23:27 - it and then once it's started we're
23:29 - going to be able to accept bids right
23:31 - now the bid will be a certain amount of
23:32 - ethereum and we'll need to keep track of
23:34 - what the current bid is who's currently
23:36 - winning the auction we need to know when
23:38 - the auction ends and all of that logic
23:40 - again will be handled by auction however
23:42 - we want a very easy way for users to be
23:44 - able to interact with the auction
23:46 - contract i don't want them to have to
23:48 - write some really low level code and
23:50 - send their own transactions instead i
23:52 - want them to just be able to connect
23:53 - their blockchain account or their
23:54 - ethereum account with my user interface
23:56 - and click this nice big button that says
23:59 - bid okay so they're going to be using my
24:01 - user interface all of my clients are
24:03 - going to have a different instance of
24:04 - the user interface maybe this is
24:06 - something like a react app or something
24:08 - like a javascript client whatever right
24:10 - so let's say we have kind of two user
24:12 - interfaces here
24:13 - and we have two people that are bidding
24:14 - against each other just for simplicity
24:16 - so i'm going to say that this is number
24:18 - one and this is number two
24:20 - now the concept here is that this
24:22 - person's going to press the bid button
24:23 - it's going to send a transaction to the
24:25 - auction it's going to send maybe one
24:27 - ethereum and well that's going to be
24:29 - their bid and then this person maybe
24:30 - they want to send a bid maybe they send
24:32 - a bid of to ethereum now this is all
24:35 - great but again we run into this problem
24:37 - where i want these user interfaces to be
24:39 - able to be updated whenever another bit
24:42 - occurs
24:43 - so essentially if i'm sitting right here
24:45 - i want to know that number two just made
24:48 - a bid so that i can then bid again and i
24:50 - can bid three ethereum right now how do
24:52 - i do that well since i can't get a
24:54 - return value here and since my auction
24:57 - can't send something to my user
24:59 - interface it's not able to do that what
25:00 - i need to do is use my events so what's
25:03 - going to happen is every single time i
25:05 - make a bid an event is going to be
25:07 - emitted so i'm going to say emit
25:09 - and then i'll omit an event that's going
25:11 - to be something like
25:13 - let's write this properly something like
25:15 - bid
25:15 - one f and then it will be from number
25:18 - one and then we'll probably give the
25:19 - time that this bit occurred and a bunch
25:21 - of other information but the idea is
25:22 - we're going to omit all of these events
25:25 - and then what we can do is we can have
25:27 - these user interfaces subscribe to the
25:30 - events so when they subscribe to the
25:32 - events what's going to happen is they're
25:34 - going to be notified when an event
25:36 - occurs and then they can use the data
25:38 - from the event to update their user
25:41 - interface and tell the user hey you just
25:43 - got outbid do you want to bid again or
25:45 - hey the current bit is this or the
25:46 - auction ended or whatever you get the
25:48 - idea but the concept here is we have an
25:50 - external client right so our javascript
25:52 - clients kind of sitting on some type of
25:54 - user interface they are subscribed to
25:56 - the events that this contract is going
25:58 - to be emitting and whenever the contract
26:00 - omits an event they'll be able to update
26:02 - their user interface and they could say
26:04 - query the state of the auction if they
26:06 - wanted to they could do that for free
26:07 - because that doesn't require a
26:09 - transaction
26:10 - hopefully this makes sense but that is
26:12 - the point of events and this is kind of
26:14 - how you would start building out a very
26:16 - simple blockchain application you would
26:18 - deploy your smart contract this would be
26:20 - kind of your source of truth right this
26:22 - would handle all of the complex logic
26:24 - then you would have your nice user
26:25 - interfaces that allow the user to
26:27 - interact with the smart contract and be
26:29 - updated of things that's happening with
26:31 - the smart contract because the smart
26:33 - contract can only do some type of
26:35 - operation when a transaction is
26:37 - performed so you need some type of
26:39 - external client sitting listening for
26:41 - events and updating the user then the
26:43 - user can trigger those transactions to
26:45 - the smart contract when they actually
26:47 - want to do something that is state
26:49 - changing
26:50 - perfect there we go we now understand
26:52 - the importance of events let's go ahead
26:54 - and go back to the computer we're going
26:56 - to start writing out this auction
26:57 - contract and looking at events all right
27:00 - so i'm back on my computer in remix
27:02 - we're actually just going to start
27:03 - working on the auction contract and then
27:05 - as we work on that i'll show you events
27:07 - so i'm going to change the name of my
27:09 - contract here to auction because that's
27:10 - going to be a bit more fitting and i'm
27:12 - going to implement a bunch of public
27:13 - things that we need here for our auction
27:16 - so if we're thinking of an auction we're
27:17 - going to have a time span for this
27:19 - auction so we need to know if the
27:20 - auction has been started if it's ended
27:22 - how much time is left so when the
27:24 - auction is actually going to end we want
27:26 - to know all of the bids we want to know
27:28 - who's selling the nft we want to know
27:30 - what the current highest bid is and who
27:31 - the current highest bidder is and we
27:33 - also need to know what nft we're selling
27:35 - but we'll deal with the nfts later
27:37 - because that's a little bit complicated
27:38 - so for now what i'm going to do is say
27:41 - address
27:43 - payable it's important we do payable
27:45 - here because we're going to want to pay
27:46 - this person who you'll see is the seller
27:48 - so we're going to say address payable
27:50 - public seller now it needs to be payable
27:52 - because well the seller of the nft we're
27:53 - going to have to pay the profits of the
27:55 - auction so whoever you know the highest
27:56 - bidder was we're going to take money
27:58 - from them and send it to the seller
28:00 - okay now other than that we are going to
28:02 - need to know when the auction started so
28:04 - actually we don't need to know when it
28:05 - started we just need to know when it's
28:07 - going to end if it started and then if
28:09 - it's ended so i'm going to say bool and
28:12 - then this will be public and this will
28:13 - be started we'll then say bool
28:16 - public ended and we'll say bool
28:19 - our sorry not bool this is going to be
28:21 - you int
28:22 - and then this will be
28:25 - public if we could spell this correctly
28:28 - and then end at and this will be the
28:29 - time that we actually are going to end
28:31 - the auction at now other than that we
28:33 - need the highest bidder so we're going
28:34 - to say you int or sorry we want the
28:36 - highest bid so i'm going to say uint
28:39 - public and then this will be highest
28:41 - bid like that
28:43 - and then we will have address and do i
28:46 - want this to be payable let me look at
28:48 - my cheat sheet here no i don't think we
28:49 - need that to be payable we'll just say
28:51 - address public
28:52 - and then highest bidder
28:56 - like that uh and that should be good now
28:59 - other than that we're gonna need some
29:00 - mapping to keep track of all of the bids
29:02 - that users have made to this contract so
29:05 - the idea here for the auction is that
29:06 - when you make a bid you have to send
29:08 - money to the contract so if you don't
29:10 - actually end up winning the nft then you
29:12 - need the ability to withdraw your money
29:13 - right so we're going to have a
29:14 - withdrawal function that allows you if
29:16 - you didn't win to actually take all your
29:18 - money back from the contract so i'm
29:20 - going to say mapping
29:23 - and then this is going to be address and
29:25 - this will go to a uint and this will be
29:27 - a public and then this will be bits now
29:30 - the reason all of these are public is
29:32 - because i don't need to hide any of this
29:33 - information it's fine if everybody sees
29:35 - it and i want people to be able to see
29:37 - when it started when it ended what the
29:38 - end that is what the highest bid is
29:40 - because you want people to trust this
29:41 - contract that's the whole point of
29:42 - writing smart contracts right
29:44 - okay so now that we have that i'm going
29:46 - to make a constructor
29:47 - i'm going to say constructor
29:49 - like this and all i'm going to do is
29:51 - simply assign the seller so i'm going to
29:54 - say
29:54 - the seller is equal to message dot and
29:58 - then this will be sender so whoever
30:00 - deployed the smart contract will be the
30:02 - seller of the contract now notice i'm
30:04 - getting an error here it's going to tell
30:05 - me that the type address is not
30:07 - implicitly convertible to expected type
30:09 - address payable now i didn't show this
30:11 - to you previously but the way that you
30:12 - can convert a regular address to a
30:14 - payable address is you can just say
30:16 - payable like this and then surround what
30:18 - you want to convert so now this address
30:20 - that is not addressed payable will be
30:22 - payable and i'll put that inside of
30:24 - seller
30:25 - okay now what i'm going to do is
30:26 - implement a start function this function
30:28 - will allow only the seller of the nft to
30:31 - start and they'll need to pass all the
30:32 - nft details to be able to start the
30:34 - auction now we won't implement the nft
30:36 - stuff right now as i mentioned we'll do
30:38 - that at the end
30:39 - so i'm going to say function we'll just
30:41 - call this start
30:42 - then this will be public
30:45 - external okay so we're going to call
30:46 - this from outside of the smart contract
30:49 - and inside of here what i want to do is
30:52 - i want to require
30:55 - that the message dot sender
30:58 - is
30:59 - equal to the seller otherwise i will say
31:01 - you did not start
31:05 - the auction exclamation point okay
31:07 - and then we'll go with semicolon now
31:09 - what's the error here it says visibility
31:10 - already specified as public okay so
31:12 - that's my bad story i'm just going to
31:13 - make this external because you can't
31:15 - have public external those are going to
31:17 - be you know messing with each other so
31:18 - external is fine now what's the warning
31:20 - function state mutability can be
31:22 - restricted to view okay that's fine
31:24 - we're going to change that layer
31:26 - okay so now what i'm going to do is i'm
31:27 - going to say started
31:29 - is equal to true and then what i need to
31:32 - do is pick the end at date now this is
31:34 - going to be a little bit weird because
31:36 - we haven't seen this yet but i'm going
31:37 - to say end at is equal to and this is
31:39 - going to be block
31:40 - dot and then time stamp plus and then
31:44 - seven days now
31:45 - we can actually change this so that it's
31:47 - not days and in fact let me check if
31:49 - that's correct okay actually i think
31:51 - seven days is correct
31:53 - so first of all let's just explain what
31:54 - this line is because i haven't covered
31:56 - this so block is actually referring to
31:58 - the block that this transaction is a
32:00 - part of once it's been mined right so
32:02 - once it's been mined it will be a part
32:03 - of a block and the block is going to
32:05 - have a time stamp that's when the block
32:07 - was created so this is going to give us
32:08 - the relative timestamp of the
32:10 - transaction it's not going to be
32:12 - precisely when we sent it but it will be
32:14 - very close to that because blocks are
32:16 - created very very quickly in ethereum
32:18 - and we're going to add seven days to
32:19 - that and days is a keyword just like
32:22 - ether in remix so i can or sorry not in
32:24 - remix but in solidity so this way we're
32:26 - just going to add seven days to this
32:28 - time stamp which means we will end seven
32:30 - days after this so of course feel free
32:32 - to modify the number of days i mean you
32:33 - can make this one day if you want two
32:34 - days whatever it doesn't really matter
32:36 - in fact let's just go with two days for
32:38 - now but whatever you set this that's
32:40 - going to be the amount of time the
32:41 - contract or sorry the
32:43 - what do you call it the auction will
32:44 - last for okay so now we have start
32:47 - however what i want to do is add one
32:49 - more require here that just makes it so
32:52 - we cannot start this contract if it's
32:53 - already started so i'm going to say not
32:55 - started like that and then i'll say
32:57 - already
32:59 - started exclamation point and what i
33:02 - want to do is i want to omit an event
33:05 - saying that i started the contract so
33:07 - now we're going to talk about how we
33:08 - actually implement events now creating
33:10 - an event is actually pretty
33:11 - straightforward you first need to
33:12 - declare an event in the body of your
33:14 - contract so i'm going to do it up here
33:16 - i'm going to say event
33:17 - and then start and i've just created an
33:20 - event now we need to omit these events
33:22 - but this is an event that is emittable
33:24 - so what you do is you put the keyword
33:26 - event you then put the name of the event
33:28 - in this case i'm going to go with start
33:29 - now notice i'm starting it with a
33:31 - capital because the convention here is
33:32 - pascal case just like our contracts and
33:35 - then inside of the parentheses you put
33:37 - any arguments you want the event to
33:39 - accept
33:40 - so you could put for example the address
33:43 - of the person who started the event now
33:45 - that wouldn't really be very useful
33:46 - because the only person who can start
33:48 - the event or sorry start the contract or
33:50 - start the auction is going to be the
33:52 - seller but you could put any other data
33:54 - you want here you don't need to put the
33:56 - time because that will automatically be
33:58 - associated with events whenever they're
33:59 - omitted but i can put any data inside of
34:02 - the parentheses and then i pass that
34:04 - data as arguments when i omit the event
34:06 - and that'll be like the data of the
34:08 - event
34:09 - we'll see this in a second right now for
34:11 - start i don't need any arguments we
34:13 - won't look at that right now but when i
34:15 - do events for a bid i'm going to have
34:16 - the address of the person who bid the
34:18 - amount they bid et cetera right
34:21 - okay so anyways we have an event defined
34:22 - which is start and now if i want to emit
34:24 - an event this is really straightforward
34:26 - i just do omit
34:27 - and then i put the name of the event
34:28 - like that
34:29 - okay there you go i'm now emitting the
34:31 - start event now if start was accepting
34:33 - arguments i would pass them right in
34:35 - here
34:36 - so whatever the arguments are right
34:38 - okay
34:39 - there we go pretty straightforward so
34:40 - now that we have that let's deploy this
34:42 - contract let's deploy it to a legitimate
34:44 - network right so i'm going to deploy it
34:46 - to the goreli test network and then i'm
34:48 - actually going to go look at the events
34:50 - of my smart contract and show you how
34:52 - you can view them off the blockchain on
34:54 - etherscan so let's do this i'm going to
34:56 - click deploy and then once it's finished
34:58 - i will let you know okay so the contract
35:00 - has now been deployed so i'm going to
35:01 - click on the contract deployment here
35:04 - i'm going to view this on ether scan
35:06 - notice it says that it was successful so
35:08 - what i'm going to do now is click right
35:10 - on the contract so notice it says
35:11 - contract here it was created so i'm
35:13 - going to click on that and when i go
35:15 - here we can see we have the hash of the
35:17 - transaction that created the contract
35:19 - then i can click on events now when i go
35:22 - to event notice we don't see any events
35:24 - now that's because we haven't triggered
35:25 - any yet but i'm now going to trigger an
35:27 - event and show you that it will show up
35:29 - right here okay so let's go back to
35:31 - remix
35:33 - let's now go to our contract and let's
35:36 - start by just clicking on some of these
35:37 - so we can see the seller is it started
35:39 - no it's not started so let's start it by
35:41 - clicking on start now when we do this of
35:42 - course we need a transaction because
35:44 - this is going to modify the state so i'm
35:46 - going to click on confirm okay this is
35:48 - going to take a second to complete
35:51 - and let's just go here and it should
35:53 - tell us when this is done then we can go
35:55 - check the corresponding event that would
35:57 - have been omitted okay so this is
35:58 - finished now so let's go back here
36:01 - and let's refresh the page
36:03 - and notice that we have an event now the
36:06 - event is start okay and i can click on
36:08 - this right here and kind of view some of
36:09 - the details now the method will actually
36:12 - be the method that we called in the
36:13 - transaction now this is going to be a
36:15 - special hash of this method i'm not
36:18 - really going to describe exactly how you
36:19 - kind of read this stuff because there is
36:21 - a special way to do that however
36:23 - whenever you're going to be subscribing
36:25 - to events or trying to get the data
36:26 - associated with an event you're not just
36:28 - going to be reading it from this page
36:30 - you're going to have a client this
36:31 - client is going to be using a special
36:32 - library a library could be something
36:34 - like web3js this is a javascript library
36:37 - that kind of handles a lot of this
36:39 - complex lower level stuff for you and it
36:41 - will kind of decode this data and tell
36:43 - you the stuff in the event now i'm not
36:45 - going to show you how we subscribe to
36:46 - events in this tutorial because it's
36:48 - fairly complicated but if you were
36:50 - writing say a javascript client or
36:51 - something what you could do is use
36:53 - something like
36:54 - web3.js so let's do this this is the
36:57 - ethereum javascript api and inside of
36:59 - here you can subscribe to events so if
37:01 - you go to f.subscribe this is the thing
37:04 - right here i'll leave a link to this in
37:06 - the description and you can kind of view
37:08 - how you would do this and how you
37:09 - actually get the data associated with
37:10 - events from a smart contract okay
37:14 - let's go back to remix though and let's
37:15 - continue all right so now that we've
37:16 - written the start method let's write the
37:19 - end method or the end function so i'm
37:21 - going to say function end external and
37:23 - inside of here i need to require a bunch
37:25 - of things the first thing i'm going to
37:26 - require is that they started the
37:28 - contract so i'm going to say require
37:30 - started because well if they haven't
37:31 - started it they can't end it so i'll say
37:33 - you need to start first exclamation
37:36 - point doesn't really matter the error
37:38 - message that i give then i will also
37:40 - require
37:41 - that the block dot timestamp is greater
37:45 - than or equal to end at because i don't
37:48 - want to allow someone to end the auction
37:51 - if uh the end at time is not yet reached
37:53 - right because that would be unfair that
37:55 - means you could have someone like bid on
37:57 - it and then you could end it for them so
37:59 - that they would win it before anyone
38:00 - else was able to bid
38:01 - anyways we're gonna do this we're going
38:03 - to say block.timestamp greater than or
38:04 - equal to end at i'll say
38:07 - auction is
38:10 - still
38:10 - ongoing
38:12 - is ongoing one word or two word i think
38:13 - it's one word someone can correct me in
38:15 - the comments
38:16 - clearly programming is greater than
38:18 - spelling anyways and then we also want
38:20 - to make sure that it's not already ended
38:22 - right so i'm going to say not ended
38:24 - we'll say
38:26 - auction
38:28 - already ended and let's spell already
38:31 - correctly okay
38:32 - exclamation point
38:34 - perfect so now that we have all of our
38:35 - requires what we can do is say ended
38:38 - is equal to true and then we want to
38:40 - emit an event that says we ended it now
38:42 - of course when we end we're going to
38:44 - actually have to transfer the nft to the
38:45 - highest bidder and then we're gonna
38:47 - transfer the funds from the contract to
38:49 - the uh what do you call it the seller of
38:52 - the nft
38:53 - but for now we'll just do the events so
38:54 - let's go up here and let's say event and
38:57 - let's say end
38:58 - now for this event i actually want to
39:00 - know what the highest bid was and who
39:02 - the highest bidder was so i know who won
39:04 - the auction right so i'm going to say
39:07 - let's go with
39:08 - address and this will be
39:11 - i guess
39:12 - highest bidder okay and then we will go
39:16 - with uint and then this will be highest
39:18 - bid okay so that's for event and in fact
39:22 - i guess i can do this yeah that's fine
39:23 - we can do that inside here okay so now
39:26 - for end i'm going to say omit and then
39:28 - end and then inside of here i'm going to
39:30 - pass the highest bidder
39:33 - so let's go highest bidder like that and
39:35 - then let's pass the highest bid
39:37 - perfect okay there we go now one thing i
39:39 - want to add to start is i just want to
39:41 - add a parameter here that's going to be
39:44 - the starting price or the starting bid
39:47 - or whatever for the auction so i'm going
39:48 - to say uint we'll say starting bid
39:51 - and what i'm going to do is after i
39:53 - start this or it actually it doesn't
39:54 - really matter where i do this but i'm
39:56 - going to say that the highest bid
40:00 - is equal to and then this is going to be
40:01 - the starting bit so this way you're
40:03 - going to have to bid at least a little
40:05 - bit higher than this to be able to
40:06 - actually win the item if you were say
40:08 - the only bidder that way someone doesn't
40:10 - list this and kind of gets screwed by
40:12 - only having someone bid like one way or
40:14 - two-way or something and no one else
40:15 - actually bids on the nft
40:17 - regardless we'll have that for now and
40:20 - we can now test if end is going to work
40:22 - and then we can implement bid and we can
40:24 - implement withdraw which are the other
40:26 - two functions that we're going to need
40:27 - so let me save this now let's close this
40:30 - i'm going to deploy the contract again
40:32 - this will take a second once it's done i
40:34 - will be back all right so the auction is
40:36 - now deployed now i can start this by
40:38 - passing say a thousand way as the
40:40 - starting bid
40:42 - we will wait for this to go through
40:44 - and then we can try to end it now i will
40:46 - show you that when we end it this isn't
40:48 - gonna work and the reason it's not gonna
40:50 - work is pretty obvious but we don't have
40:52 - this condition being equal to true right
40:54 - the block.timestamp is not going to be
40:55 - greater than or equal to end at so it's
40:57 - not going to let us end this and i'll
40:58 - just show you that that works in a
41:00 - second once this starts okay so that's
41:01 - started
41:03 - let's now go to this contract
41:05 - the way i'm going to get to this
41:06 - is i'm going to open up metamask
41:09 - i'm going to go to contract creation
41:11 - okay let's go here
41:13 - let's view the contract okay it's still
41:16 - indexing let me refresh this once it's
41:18 - done i'll be right back okay so now it
41:20 - is fully successful let me click on the
41:21 - contract
41:23 - let's go to events and we can see that
41:25 - the event start has been triggered or
41:28 - been omitted right because we started
41:29 - the contract so now let's see what
41:30 - happens if we try to end it so notice is
41:33 - going to tell us that we're probably
41:34 - going to get a problem here it's saying
41:36 - that gas estimation errored with the
41:38 - following message see below the
41:39 - transaction execution will likely fail
41:41 - do you want to force sending and it's
41:43 - saying that the area's auction is still
41:45 - ongoing so it's actually able to look at
41:47 - our smart contract and realize that
41:49 - we're not going to be able to do this
41:51 - because the block dot time stamp is not
41:54 - greater than or equal to the end at time
41:56 - so we can still send the transaction if
41:58 - we want now if we do this what's going
42:00 - to happen
42:01 - is it's just going to fail now when it
42:03 - fails and we hit a require statement the
42:05 - required statement will return whatever
42:07 - remaining gas we had as a part of this
42:09 - transaction back to us however some gas
42:12 - is going to be lost now that's one thing
42:14 - to note here with require it does
42:16 - actually return your gas if this fails
42:18 - again not all of it because it still had
42:20 - to use some gas but it will return
42:22 - whatever wasn't used so you can see here
42:23 - we're getting this error right it's
42:25 - telling us this didn't work
42:26 - and we weren't able to do that because
42:28 - this require statement would have been
42:30 - well not true right it would have you
42:31 - know caused an exception okay
42:34 - so hopefully that makes sense that is
42:36 - how that works now that we've done that
42:38 - let's start implementing the bid and the
42:41 - with draw functions that we need okay so
42:44 - let's code out the bid function let's go
42:46 - with function
42:47 - bid
42:48 - external now this needs to be payable
42:50 - because this is actually going to accept
42:52 - ethereum right so inside of here we need
42:54 - to require a few things
42:56 - we're going to require
42:58 - that we have started the auction if we
43:00 - haven't started then obviously
43:02 - we can't do this so i'm going to say not
43:04 - started we're going to require that the
43:07 - block dot timestamp again this is a
43:10 - global keyword that we have access to is
43:12 - going to be less than the end at time so
43:15 - this means that the contract is not
43:17 - ended or sorry i keep saying contract i
43:18 - mean auction so we'll say ended
43:21 - exclamation point
43:22 - and then we will also require that the
43:25 - message dot value so this is going to be
43:27 - the value of the bid because they're
43:29 - going to be sending the amount of the
43:30 - bid right is greater than and then this
43:33 - will be the current highest bit
43:35 - okay so now we have all of our required
43:37 - statements now let's see why it's
43:38 - getting mounted mountainous here it's
43:39 - saying expected semicolon but got
43:41 - identifier okay i need a semicolon right
43:42 - there so now if this is the case what
43:44 - we're going to do is we're going to
43:46 - update the amount of money that people
43:47 - have sent to this contract kind of
43:49 - similar to the bank account by using
43:50 - this bids mapping and we're going to
43:52 - update the highest bid in the highest
43:54 - bidder because at this point we know
43:56 - this person would have bid an amount
43:58 - higher than the highest bid so we need
44:00 - to update those values right so we're
44:02 - going to say that the highest bid is
44:03 - equal to message dot value
44:06 - and we're going to say that the highest
44:08 - bidder
44:09 - is equal to the message.sender okay so
44:12 - now after updating this since the
44:14 - highest bidder has now changed what i
44:17 - need to do is make it so the person who
44:18 - just got outbid is able to withdraw
44:20 - their money from the contract so i'm
44:22 - going to say if and then this is going
44:24 - to be the highest bidder
44:26 - so not bid but bidder does not equal the
44:29 - address zero now address zero is the
44:31 - default address i'll talk about this in
44:33 - a second then what i'm going to do is
44:34 - say that bid at and this is going to be
44:37 - highest bidder
44:38 - plus equals and then the highest bid so
44:41 - the logic here
44:43 - why is this yelling at me let's see what
44:44 - the problem is operator not compatible
44:46 - with types uint256 and address sorry
44:48 - this needs to be highest bid not highest
44:50 - bidder okay that's better but the logic
44:52 - here is that as soon as someone gets
44:54 - outbid i want to allow them to withdraw
44:56 - their money from the contract so that
44:57 - they could withdraw and then bid again
44:59 - right because otherwise they would need
45:00 - to have a ton of ethereum to be able to
45:02 - actually continually outbidding someone
45:04 - if all of their money is stored in the
45:05 - contract so hopefully this makes sense
45:07 - but since we're updating the highest
45:09 - bidder now if the highest bidder was not
45:11 - equal to address zero
45:13 - so essentially if this was not the first
45:14 - person to make a bid then what we do is
45:17 - we take whatever the highest bidder was
45:19 - store that in our bids
45:21 - mapping and then we add whatever their
45:23 - highest bid to that so that now they're
45:25 - able to withdraw and let's say they
45:26 - don't withdraw and they just continue
45:28 - making bids that's fine this will
45:30 - continue to increment however many bids
45:31 - they've made so then they will be able
45:33 - to withdraw all of that if they're not
45:35 - currently the highest bidder
45:37 - okay and actually they'll be able to
45:38 - withdraw whatever amount inside of there
45:40 - is not their current bid that's being
45:42 - stored in highest bid you can look
45:44 - through this logic and probably see why
45:46 - that makes sense but address zero just
45:48 - to clarify here is the default address
45:50 - so when i write something like address
45:51 - public for right now sorry not just
45:53 - public but address public highest bidder
45:55 - it's going to be storing just a zero
45:57 - filled address so i'm just making sure
45:59 - that it's not equal to the zero filled
46:01 - address and you can do that by just
46:02 - writing address and then putting zero
46:04 - inside of here okay so that is bid
46:06 - that's pretty much all we need for bid
46:08 - now we want to write the withdraw
46:09 - function so i'm going to say function
46:12 - withdraw like that and then this is
46:15 - going to be an external payable as well
46:18 - and inside of here what we need to do is
46:20 - withdraw a certain amount or i guess
46:22 - we'll just withdraw the entire amount of
46:24 - whatever the person's bidded that's not
46:26 - the current bid so we're just going to
46:27 - start by getting the amount of money
46:29 - they've sent to this contract that's not
46:30 - currently the highest bid so i'm going
46:32 - to say a uint and i guess i'll just go
46:35 - with something like balance
46:36 - is going to be equal to and then this
46:38 - will be bidsat
46:40 - message.sender and then what i'm going
46:42 - to do is say bidsmessage
46:45 - dot sender is equal to 0 just to reset
46:48 - that and then i'm going to send whatever
46:50 - their balance is to them so the way i'm
46:52 - going to do this is i'm going to write
46:53 - this complex line in fact i'm just going
46:55 - to copy this in because we saw this in
46:56 - the last video i'm going to say bool
46:58 - sent bytes memory data is equal to
47:00 - payable message.sender so just
47:02 - converting that address to a payable
47:03 - address dot call value and then this is
47:06 - going to be balance balance is right
47:07 - here right and then what i need to do is
47:09 - require that this was successful so i'm
47:11 - going to say require sent and i'm going
47:13 - to say
47:14 - could not withdraw so let's do this
47:17 - could not withdraw let's add our
47:19 - semicolon and there we go we have just
47:21 - implemented the withdraw function now
47:23 - what i'm going to do is actually add
47:25 - some events here as well for bid and for
47:28 - withdraw then we can test this out and
47:30 - then we'll start actually working within
47:32 - nft because right now we're not really
47:33 - auctioning anything
47:35 - so let's make some events
47:37 - let's make an event for bid
47:39 - now what i want to do is have an address
47:41 - now this is going to be indexed now we
47:43 - haven't seen this keyword before but
47:45 - what you're allowed to do whenever
47:47 - you're defining the arguments for your
47:49 - events is you can put an indexed
47:51 - parameter and you can actually put up to
47:52 - three of these and this is what you will
47:54 - be able to search for an event for so if
47:56 - i say indexed here then this means i can
47:58 - search by whatever this parameter is for
48:01 - this event in my logs right or in my
48:04 - event so i'm going to say address
48:05 - indexed let me just look at my cheat
48:07 - sheet to make sure i don't mess this up
48:08 - it's going to be sender and then we're
48:10 - going to say uint amount to specify how
48:13 - much they actually bid and then we'll do
48:15 - an event and this is going to be
48:17 - withdraw and this again will be an
48:19 - address that's going to be indexed this
48:21 - will be the bidder
48:23 - and then this will be you ins and the
48:26 - amount that they withdrew
48:28 - okay
48:29 - i think that is fine now what's it
48:32 - telling me what's what's it saying i did
48:33 - wrong here oh i spelt index incorrectly
48:35 - okay
48:36 - so let's go and let's now omit these
48:38 - events so i'm going to say omit and then
48:40 - this is going to be bid and then we're
48:42 - going to pass to this just the highest
48:44 - bidder and the highest bid okay perfect
48:48 - let's add our semicolon and then for
48:49 - withdraw we will say omit and then
48:52 - withdraw and then we're going to omit
48:55 - the message.sender and the balance
48:59 - great there we go okay so now let's
49:01 - actually just deploy this we can do some
49:03 - experiments with it i'll set up another
49:04 - ethereum account make sure it works and
49:06 - then we'll talk about the nfts so i'm
49:08 - going to deploy once it's done i will be
49:10 - right back okay so i am back this
49:12 - finished deploying my contract this year
49:14 - i actually started the contract with a
49:16 - minimum bid of a thousand way and now
49:18 - what i'm going to do is change my
49:19 - ethereum account in fact i've actually
49:21 - already done this so i deployed this
49:23 - contract from my tutorial account but
49:25 - now i'm on account one so now i'm going
49:27 - to make a bid from account one and show
49:29 - you how this works so i'm on account 1.
49:31 - you can see i've reconnected this here
49:33 - to what do you call it
49:35 - remix and now i'm going to make a bid of
49:36 - a thousand way i'm going to click on bid
49:39 - then when i do this notice it's going to
49:40 - tell me that i'm probably going to get
49:41 - an error the reason i'm going to get an
49:43 - error is because this is not greater
49:44 - than the starting bid and so i'm just
49:46 - going to cancel the transaction so i'm
49:48 - going to change this now to be a
49:49 - thousand one
49:51 - let's click on bid
49:53 - and let's see okay
49:55 - so confirm
49:56 - let's give this a second and again
49:58 - notice i'm not going to get any return
50:00 - value here it's not going to tell me if
50:01 - this was successful or whatever i'm just
50:03 - going to see that the transaction didn't
50:04 - fail whenever this is done
50:07 - and then i should see an event be
50:08 - emitted here okay so let's now refresh
50:11 - this and we now see
50:14 - uh hmm okay maybe we need to wait a
50:16 - second
50:17 - okay so the event has showed up i just
50:18 - had to wait a second i was being
50:20 - impatient but after i refreshed a few
50:21 - times it appeared here anyways this has
50:24 - happened successfully i know this looks
50:26 - like gibberish but if you were actually
50:27 - subscribing to this event then you would
50:29 - have some library that would be
50:30 - translating this for you so you'd be
50:32 - able to read the real data regardless
50:34 - the bid happened and i can look now at
50:38 - for example the highest bid which i can
50:39 - see is 1001 the highest bidder which is
50:41 - this address i can look at the seller
50:43 - which is different if the contract is
50:45 - started and all of this type of stuff
50:47 - now that's pretty much all i wanted to
50:48 - show you for that
50:50 - since we don't really have two days to
50:52 - wait here for this to finish i can't
50:53 - show you it actually ending
50:55 - what i will do though is i will now
50:58 - start implementing the nft stuff which
51:00 - is a little bit complicated but it's
51:02 - pretty cool so i'll try my best to
51:03 - explain it to you alright so i've just
51:05 - switched tabs and i'm going to try to
51:06 - explain to you the difference between
51:08 - fungible and non-fungible tokens and how
51:10 - these kind of live on the ethereum
51:12 - network
51:13 - so i'm sure all of you are familiar with
51:15 - cryptocurrencies right we have
51:16 - currencies like ethereum we have
51:18 - currencies like bitcoin we have a ton of
51:20 - other currencies that are built on top
51:22 - of these main blockchain networks so if
51:24 - we're talking about coins that are built
51:26 - on ethereum these are tokens now really
51:29 - all a token is is a smart contract that
51:32 - defines that your address owns a certain
51:35 - amount of tokens now this is specific to
51:38 - ethereum but if you're working with a
51:39 - token that's on the ethereum network
51:42 - really what gives you the ability to own
51:44 - that token is that there's a smart
51:46 - contract with the name of that token
51:47 - it's named say timcoin for example right
51:50 - if i had my own token on ethereum and in
51:52 - that contract it says that your address
51:54 - has 20 tim coins or 100 tim coins or
51:57 - whatever it is
51:58 - now the way this all gets standardized
52:00 - is that what happens is you need to
52:02 - implement specific methods or specific
52:04 - functions on your smart contracts then
52:06 - make it act like an erc20 or an erc 721
52:10 - token now erc20 is simply a protocol for
52:14 - a specific token in this case it's a
52:16 - fungible token now erc20 states that you
52:19 - need to define some special methods on
52:21 - the smart contract now if you do that
52:23 - ethereum is able to look at your smart
52:25 - contract and treat that smart contract
52:28 - like a token rather than just any other
52:30 - smart contract now that means in your
52:32 - ethereum wallet you're going to see your
52:34 - tokens showing up or you'll be able to
52:35 - link them you'll be able to then say buy
52:37 - these tokens or exchange these tokens
52:39 - because you've defined certain functions
52:41 - on the token and it meets the erc20
52:43 - protocol hopefully that makes sense now
52:46 - erc 20 is simply a fungible token
52:48 - protocol what that means is every single
52:50 - one of these tokens is exactly the same
52:53 - so there's no difference in you owning
52:55 - one of the tokens or the other tokens
52:57 - like any token is just identical each of
52:59 - them has the same value
53:01 - and as it says here this makes erc20
53:03 - tokens useful for things like medium of
53:04 - exchange voting rights staking whatever
53:07 - okay that's what you can use these
53:08 - tokens for however now we go over to erc
53:12 - 721 now erc 721 is fungible tokens now
53:16 - fungible tokens mean that these tokens
53:18 - are different so there could be a
53:19 - different value associated with each
53:20 - token maybe there's some assets like an
53:22 - image associated with a token hence nfts
53:25 - right
53:26 - maybe you get some
53:27 - special rights with a specific token
53:29 - tokens are unique they are different and
53:31 - they have a unique id
53:33 - now this is very similar to erc20 except
53:36 - you're just having these unique tokens
53:38 - and you have some special functions now
53:39 - that you need to define on smart
53:41 - contracts that are defining an erc 721
53:44 - token so it's a little bit too
53:45 - complicated for me to show you exactly
53:47 - how to create your own nfts or your own
53:49 - erc20 tokens but the concept is again
53:52 - that we have this smart contract this is
53:54 - an example of an nft contract this smart
53:57 - contract defines who owns what nfts it's
54:00 - capable of creating new nfts and then if
54:03 - i wanted to say send my nft from me to
54:05 - you what i would do is call a function
54:07 - on the smart contract that transfers the
54:09 - nft i have to be the owner of the nft to
54:12 - be able to do that and then it changes
54:14 - the internal state of the nft contract
54:16 - to now define that you own my nft
54:19 - because i sent it to you so hopefully
54:21 - this makes a tiny bit of sense but
54:23 - that's the general idea behind tokens
54:25 - and behind nfts and all of this type of
54:27 - stuff now as you can see here there's
54:28 - some other types of tokens that you can
54:30 - create but erc 721 is the one we're
54:33 - going to work with right now and what
54:34 - we're actually going to accept in our
54:37 - smart contract that's going to be the
54:38 - auction is the address of a smart
54:41 - contract that represents an nft as well
54:44 - as the unique id associated with the nft
54:47 - that the user wants to auction so
54:49 - whenever you get an nft it has a unique
54:51 - id associated with it because every
54:53 - single erc721 token is unique when i say
54:57 - erc721 that really just means
54:59 - non-fungible token okay and so it has a
55:01 - unique id if i pass that unique id along
55:04 - with the contract representing that nft
55:06 - then what i'm able to do is verify that
55:08 - the user owns that nft and then actually
55:11 - list it in the auction and transfer it
55:12 - between different people
55:14 - okay
55:15 - so now let's get into some even more
55:17 - complicated stuff because i need to show
55:19 - you how we can make our own nft
55:22 - and when i say make our own nft i'm not
55:24 - talking about make your own nft contract
55:25 - i'm saying kind of acquire an nft in
55:28 - your ethereum account so that you can
55:29 - follow along and actually auction off
55:31 - your own nft in this tutorial all right
55:34 - so to do this i'm going to go up to this
55:36 - other tab here where i have token.sol
55:38 - now i'm not going to explain any of this
55:40 - code but essentially this is my own
55:42 - timcoin nft okay and i'm going to give
55:44 - you guys all the privilege of owning
55:46 - some timcoin completely for free it has
55:48 - zero value and it's going to be on an
55:50 - ethereum test network but you can own it
55:51 - for free you are welcome and the way i'm
55:53 - going to do that is i'm going to deploy
55:55 - this smart contract i'm going to leave a
55:57 - link to the contract address in the
55:59 - description and you actually are able to
56:01 - create
56:02 - your own nft by calling this award item
56:05 - function which is going to give you your
56:07 - ethereum address a nft okay it's going
56:10 - to give you a special id essentially of
56:12 - timcoin i'll explain this more in depth
56:15 - and i'll show you exactly how to do this
56:17 - but right now when you're watching this
56:18 - video this will be deployed on the
56:20 - goreli test network so you need to make
56:22 - sure you're using that test network and
56:23 - then what you'll be able to do is
56:25 - interact with this contract from remix
56:28 - again i'm going to show you exactly how
56:29 - to do that it will then award you an nft
56:32 - and then once you have that nft you'll
56:34 - be able to auction that nft inside of
56:36 - our test contract
56:38 - now before i show you how to do that
56:39 - we're going to implement kind of the nft
56:41 - logic in our contract then i'll show you
56:43 - how you get your own timcoin nft again
56:46 - you're welcome you guys can thank me in
56:47 - the comments okay so what we're going to
56:49 - do is we're going to now specify
56:52 - what's known as an interface that we are
56:54 - going to accept for a specific contract
56:57 - which is going to be the contract
56:58 - address of the nft that we want to list
57:01 - so i'm going to say interface so
57:03 - actually there's not a ton of value of
57:04 - me typing this in so i'm just going to
57:05 - paste in the interface and i'll explain
57:07 - what this is so first of all an
57:08 - interface is an abstract data type the
57:10 - reason we're going to use an interface
57:12 - is because we need to verify that the
57:14 - contract passed to this auction does
57:16 - actually represent an nft and so we're
57:19 - going to treat the contract as an irc
57:22 - 721
57:24 - type contract which means we're going to
57:26 - make sure it has a transfer and a
57:27 - transfer from function on it now if
57:30 - you're unfamiliar with interfaces i
57:31 - can't explain them too much in depth
57:33 - essentially they just enforce that
57:35 - anything that is of type of this
57:36 - interface has these methods that are
57:38 - specified in this way so for us to have
57:41 - a valid nft contract really all we care
57:43 - about is that it has a transfer and a
57:45 - transfer from function that we can use
57:48 - now the transfer from allows us to
57:49 - transfer from one address to another
57:51 - address a specific
57:53 - what do you call it
57:55 - nft id okay so as i was saying before
57:57 - all we're doing is we're going to be
57:58 - calling
57:59 - a function on the nft contract that
58:02 - takes in the address of the owner of the
58:03 - nft the address of the receiver of the
58:05 - nft the nft id it verifies we own this
58:08 - nft and then it would transfer it to
58:10 - here and then transfer is simply going
58:12 - to take an nft id and transfer it to a
58:15 - specific address once it's been approved
58:17 - to do that you'll see what i mean in a
58:20 - second but anyways that's our interface
58:22 - so what we're going to do now is we're
58:24 - going to go inside of our auction and
58:26 - we're going to define the nft that we're
58:28 - actually going to be auctioning so i'm
58:29 - going to say i
58:31 - erc 721
58:34 - public like this nft
58:38 - and then what i'm going to do is i'm
58:39 - going to say uint
58:41 - public nft id okay
58:44 - so what i'm saying is i want to store
58:45 - the contract of the nft address here
58:47 - it's going to be of type
58:49 - ierc721 meaning it has to have these
58:52 - functions on it and then i'm going to
58:53 - have uint public not nd t nftid which is
58:58 - going to be the unique id of the nft
58:59 - that we want to auction
59:01 - so now inside of my start function what
59:03 - i'm going to do is take in a starting
59:04 - bid i'm going to take in the nft
59:06 - contract and the unique id of that nft
59:09 - so i'm going to say irc
59:12 - 7
59:14 - 21 this is going to be nft and we'll
59:17 - make this underscore nft and then we're
59:19 - going to say uint
59:21 - nft
59:22 - id we'll just make this underscore again
59:24 - so it doesn't mirror our global name
59:26 - and then comma now let me make sure i
59:28 - typed that correctly i think i did okay
59:31 - so now inside of here what we're going
59:33 - to do
59:34 - is we're going to set the nft so we're
59:36 - going to say nft
59:38 - is equal to
59:39 - and then this is going to be underscore
59:41 - nft
59:42 - again this is the contract representing
59:44 - the nft
59:45 - then we're going to say nft id
59:47 - is equal to underscore nft
59:50 - id like that now what i'm going to do is
59:52 - just take these two lines here and put
59:54 - them after i do this just in case these
59:57 - return some error although it doesn't
59:59 - really matter because if an error was
60:00 - returned then the state would have been
60:02 - reverted but that's fine okay so we're
60:04 - going to do that now what we also need
60:06 - to do is we need to transfer this nft
60:09 - from the owner of the nft to this
60:11 - contract so now the contract owns the
60:13 - nft and then is able to actually
60:15 - transfer this to whoever wins the nft in
60:17 - the auction right so what i'm going to
60:19 - do is say nft
60:20 - dot transfer from and we're going to
60:23 - transfer from and this is going to be
60:24 - the message.sender who we're assuming
60:26 - owns the nft to this or sorry it's going
60:30 - to be
60:32 - address this like that and then this is
60:35 - going to be nft id
60:38 - okay
60:39 - so this here is going to fail if we
60:41 - don't own the nft so if whoever called
60:43 - this start here doesn't own the nft then
60:46 - we're not going to allow them transfer
60:48 - because the nft contract will raise an
60:50 - exception and so that whole thing will
60:51 - cascade meaning all of this is going to
60:54 - fail as well and so we won't actually
60:55 - start the auction so we're only able to
60:57 - start the auction if we own the nft and
60:59 - if we have the ability to send the nft
61:01 - from the sender to this address okay
61:05 - hopefully that makes sense i'll explain
61:06 - again how we kind of set the nft up and
61:09 - how we actually make an nft and get
61:11 - access to it in a second so now that we
61:13 - have that what we need to do is deal
61:15 - with what happens when the auction ends
61:17 - because once the auction ends we need to
61:19 - send the nft to whoever won it then we
61:21 - need to take the balance of the contract
61:24 - and specifically whatever the highest
61:26 - bid was and send that actually to
61:28 - ourselves right to the seller of the nft
61:30 - so all we're going to do here is we're
61:32 - going to check
61:33 - if
61:35 - the and this is going to be highest
61:37 - bidder
61:38 - does not equal the address zero
61:41 - because if it's equal to the address
61:43 - zero that means no one actually bid on
61:45 - this item and so we can just return the
61:47 - funds or return the nft to ourself so
61:50 - anyways we're going to say if this is
61:51 - the case then that means that we're
61:52 - going to take whatever the highest
61:54 - bidder amount was or the highest bid
61:56 - story we're going to transfer that to
61:58 - ourselves and then we are going to
62:00 - transfer the nft to
62:02 - whoever won the nft so i'm going to say
62:05 - nft
62:07 - dot transfer and then we're going to
62:09 - transfer it to the highest bidder
62:12 - i think that's all i need to put in here
62:14 - let me confirm that's correct oh one
62:15 - more thing the nft id
62:18 - okay
62:19 - so we're using the nft contract we're
62:21 - using dot transfer we're going to
62:22 - transfer it to the highest bidder and
62:25 - then this will be the nft id
62:27 - now what's it saying is the issue it
62:28 - says transfer is not found well that's
62:30 - because i spelt transfer incorrectly
62:31 - okay that's fine
62:33 - then after that we're going to figure
62:35 - out whatever the highest bid was and we
62:37 - are going to then pay that to ourselves
62:38 - the seller of the nft
62:40 - so the way we do that is we just copy in
62:43 - this line because i really don't feel
62:44 - like writing it again so we're going to
62:46 - say bool
62:48 - sent and then bytes memory equals data
62:50 - seller.call value and then this is going
62:52 - to be highest bid and then we'll call
62:54 - that like that and then we're going to
62:55 - require sent and we're going to say
62:57 - could not pay the seller okay
62:59 - there we go now in the other situation
63:02 - so if the highest bid actually is equal
63:04 - to address zero then what we're going to
63:06 - do is just return the nft to ourselves
63:09 - so we're going to say nft
63:11 - dot transfer and then this is going to
63:14 - be 2. i guess
63:16 - we will just say the seller
63:19 - and then this will be nft id
63:21 - and i think that's it again i spelt
63:23 - transfer incorrectly let me just make
63:25 - sure that's right looks good to me
63:27 - awesome
63:28 - okay so that is actually all we need for
63:31 - this contract now this contract should
63:33 - work
63:34 - however i need to show you how we can
63:35 - now actually get access to an nft and
63:37 - what that looks like in our account so
63:39 - i'm going to start by deploying this
63:40 - contract now be careful what account you
63:42 - deploy this from i'm going to deploy it
63:43 - from this one so i'm going to deploy
63:47 - test.soul which is really just my kind
63:49 - of auction contract
63:50 - let's confirm this
63:52 - okay this will take a second once that's
63:54 - done i'll be right back okay so that has
63:56 - now been deployed now remember to be
63:59 - able to start this auction we actually
64:01 - need the address of our nft so i am now
64:04 - going to deploy this nft contract here
64:06 - i'll leave the link to it in the
64:08 - description or you could just painfully
64:10 - write out all whatever the number of
64:11 - characters are but again it'll be linked
64:13 - in the description and i'll show you how
64:15 - you can use this to get your own nft so
64:17 - let me now deploy this i need to pass a
64:19 - string name and a symbol actually do i
64:22 - need to do that uh oh sorry i'm doing
64:24 - the wrong thing okay let's deploy
64:26 - timcoin so i'm going to deploy timcoin
64:28 - to the goreli test network this is going
64:30 - to take a second and then i will show
64:33 - you again how we can actually access
64:35 - this and get our own nft okay so tim
64:37 - coin has now been deployed now for me i
64:40 - can see timcoin right here right and we
64:42 - see all these different methods you
64:43 - don't have to worry about a bunch of
64:44 - them but anyways you're not going to see
64:47 - this inside of your remix because you
64:49 - didn't deploy this contract but you need
64:51 - to interact with the contract again on
64:53 - the gorilla test network you need to be
64:55 - on the gorilla test network otherwise
64:56 - this isn't going to work for you so what
64:58 - you're going to do is you're going to
64:59 - take the contract address which will be
65:00 - linked in the description and you're
65:02 - going to paste it right here where it
65:03 - says or at address okay so it should say
65:06 - that right at the bottom you're going to
65:08 - do that and then it will load this
65:09 - contract now notice it just loaded the
65:11 - same contract for me twice
65:12 - because i already had it here but that's
65:14 - how you can load again just copy it
65:16 - paste it in here and then it will load
65:18 - it right here now what you're going to
65:20 - want to do is you're going to want to
65:21 - start by setting the approval for all
65:24 - now i'm going to discuss what this is in
65:25 - a second
65:26 - but essentially what you need to do here
65:28 - is you need to allow this smart contract
65:31 - being the auction to actually transfer
65:34 - your nft now if you don't allow it to do
65:36 - that you're not going to be able to
65:38 - actually auction the nft the reason you
65:40 - can't auction the nft is because the
65:42 - contract will not have the ability to
65:44 - take the nft and transfer it to itself
65:46 - so you have to explicitly give the
65:47 - contract permission to do that
65:49 - before you create your nft so what
65:52 - you're going to do
65:53 - is go to your auction contract this is
65:56 - going to be different than mine you're
65:57 - going to copy the address of your
65:58 - auction contract
66:00 - okay i've done that i'm going to go to
66:01 - timcoin i'm going to go to set approved
66:04 - for all i'm going to paste in my
66:06 - contract like this
66:08 - then i'm going to go comma and i'm going
66:10 - to go true now look here it says
66:12 - operator which is this so the operator
66:14 - is the auction contract it's going to be
66:16 - operating on this nft and then true now
66:18 - what this is going to do is it's going
66:20 - to allow this contract to pretty much
66:22 - list any of your nfts now you still have
66:25 - to call the contract for it to do that
66:27 - but you're giving it explicit permission
66:29 - for it to access any of the timcoin nfts
66:31 - that you have access to so don't worry
66:33 - this doesn't mess with any other nfts
66:35 - you might have on your ethereum account
66:36 - and we're on a test network anyway so it
66:38 - shouldn't matter but i'm going to press
66:39 - transact this should go or this should
66:42 - be successful once i click confirm here
66:44 - okay so let's wait for that to finish
66:47 - and then we have set the approval for
66:48 - all of the nfts that you own to be able
66:51 - to be operated by the auction contract
66:54 - again what you're passing here is the
66:55 - auction contract now it's very important
66:57 - that you do this first before you
66:59 - actually give yourself an nft otherwise
67:01 - the nft you give yourself will not have
67:02 - the approval set for it for the auction
67:05 - contract okay so now that we've done
67:07 - that
67:08 - let's close all these and we're going to
67:10 - go to the award item function now this
67:12 - is what you want to press when you want
67:13 - to give yourself an nft so you're going
67:15 - to copy your address so my address is
67:17 - right here i'm going to copy it in
67:19 - to a word item and then what it says
67:21 - here is that there is a uri
67:23 - now the token uri is actually a url to
67:27 - json metadata related to this nft so as
67:30 - you may have seen nfts have like fancy
67:33 - images and music and gifs and all of
67:35 - this very valuable stuff
67:37 - anyways the point is all of that stuff
67:39 - is stored off of the blockchain on a
67:41 - specific url in json data and so what
67:44 - you actually have to do is associate
67:46 - data with your nft off the blockchain so
67:49 - when i create the nft i pass the url of
67:52 - the data sitting off the blockchain that
67:54 - represents my nft and then it links
67:56 - those two together and that's why when
67:58 - you go and you view nfts you see like a
68:00 - nice little fancy image it's because
68:01 - it's referencing the uri of this
68:04 - nft and then it's grabbing the image for
68:06 - it and displaying it
68:08 - pretty straightforward but that's really
68:09 - how nfts work again i'm not it's not
68:11 - meant to be an entire lesson on nfts but
68:13 - the token uri is just that it's a url
68:15 - now you actually don't need to pass
68:17 - anything here i'm just going to pass
68:18 - like one two you have to give some data
68:20 - but you don't have to give a url so i
68:21 - can pass one two three zero whatever
68:24 - doesn't matter so just go like that and
68:26 - when i hit transact then what's going to
68:28 - happen is it's actually going to give
68:30 - your ethereum account or whatever
68:31 - account you put the address for in nft
68:33 - so let's wait a second
68:35 - and then i'll show you that we actually
68:37 - will have tim coin showing up in our
68:39 - ethereum wallet okay so that finished so
68:41 - now if i go to metamask so let's get out
68:44 - of this here
68:45 - let's go to metamask and let's look at
68:48 - my account let's go to assets and notice
68:50 - how it says don't see your tokens import
68:53 - tokens so i'm going to click on import
68:54 - tokens and i'm going to copy in the
68:56 - token
68:57 - contract address of timcoin now again
69:00 - that's what will be linked in the
69:01 - description i can just copy it from
69:02 - right here
69:03 - so i'm going to go here i'm going to go
69:05 - to assets import tokens i'm going to
69:07 - paste this in notice the symbol is tim
69:10 - very fitting for the token decimal just
69:12 - put 0 and then add custom token and now
69:14 - it's showing that i have one tim
69:17 - token so i'm going to go import tokens
69:18 - like that and now if i look at my assets
69:21 - i see one tim coin okay
69:24 - it's just looking at the contract and
69:25 - since it follows the erc 721 protocol
69:28 - it's able to specify that i have one of
69:29 - these now if you want to own multiple
69:32 - just do this again just call the
69:33 - contract you can even pass the same uri
69:35 - it really doesn't matter and hit
69:37 - transact
69:38 - and now when you do this you're just
69:39 - gonna have to wait a second and then
69:41 - your wallet should update and once this
69:42 - is done you'll now have two tim coins
69:45 - and in fact just because this is
69:46 - interesting i will show you that if i go
69:48 - to
69:49 - metamask i go to my wallet here
69:52 - and let's go view account on etherscan
69:54 - you can actually view the tim coins that
69:56 - you have on here so notice i can go to
69:58 - token and i can specify timcoin
70:00 - and when i go here you can see that i
70:02 - have the token id of one i have one tim
70:05 - coin that was just added here in one
70:06 - minute now if i refresh this i should
70:08 - have a second tim coin in a second
70:10 - because i just requested that uh okay it
70:13 - might take a second so let's go
70:15 - back to where we were before
70:17 - okay
70:18 - uh award item let's refresh okay so now
70:20 - we should have two tim coins if we go
70:22 - here yes there we go now we have tim
70:24 - coins and the token id is one and two so
70:27 - if you want to see what your token id is
70:28 - because all of you're going to have a
70:29 - different token id you need to do what i
70:31 - just did go to metamask you're going to
70:33 - view your account on metamask so i
70:36 - went to where is that here view account
70:39 - on sorry not metamask on etherscan it's
70:42 - going to bring you to etherscan and then
70:43 - what you can do is go to your tim coins
70:45 - i showed you how to do that but let's go
70:46 - back
70:47 - so you're just going to click here click
70:48 - on timcoin
70:50 - and then it will show you your token id
70:51 - so you own tokenid one and two well in
70:54 - this case ion one and two you'll own
70:55 - something that's not one and two because
70:56 - it's going to be a unique id so this
70:58 - means i can auction token id 1 and 2
71:00 - because i own that so now how do we
71:02 - auction it well this is kind of the
71:04 - moment of truth here to see if this is
71:05 - all going to work so i'm going to copy
71:07 - the address of my timcoin
71:09 - nft contract okay
71:12 - then i'm going to go to start
71:14 - i'm going to paste that in as the first
71:15 - argument so let's go here for the nft id
71:18 - you have to post an id that you own so
71:20 - either one or two for me and then put a
71:22 - starting bid
71:23 - so i'm going to put a thousand and i'm
71:25 - going to hit transact like this okay
71:28 - fingers crossed once i hit this let's
71:30 - see if this works and if everything we
71:32 - did was successful okay so very good we
71:34 - see the green check mark here meaning
71:37 - that this was good so now let's go to
71:39 - nft and notice the address is this nft
71:42 - id is one seller is me started is true
71:45 - highest bid is the zero address because
71:47 - no one's made a bid yet and then we have
71:49 - highest bid now of course this will work
71:51 - as it would would work before as we
71:52 - tested it previously and this will now
71:55 - take how many days did we set
71:57 - if we go here
71:58 - i think we set two days
72:00 - yeah so after two days then you'll
72:02 - actually be able to win your nft
72:04 - when someone hits the end button or
72:06 - sends the end request to this contract
72:09 - okay so that is going to wrap up the
72:12 - video i hope this was helpful in terms
72:14 - of giving you a deeper understanding of
72:15 - solidity and smart contracts and showing
72:18 - you a real practical application hosted
72:20 - on the blockchain now in the next videos
72:22 - we're going to be talking about some of
72:24 - the scaling limitations of ethereum and
72:26 - of solidity and some of the problems you
72:28 - can run into when you need to perform
72:30 - large computations then i'm going to be
72:32 - showing you some scaling solutions so
72:34 - ways that you can mitigate those
72:35 - concerns and we'll be talking about
72:37 - cartesi which again is the sponsor of
72:39 - this video and this series and showing
72:41 - you some of the solutions that they
72:42 - provide again i really hope that you
72:44 - guys have learned a lot from these
72:45 - videos i've been having a great time
72:47 - filming them well i look forward to
72:49 - posting more on the channel with that
72:51 - said if you enjoyed make sure to leave a
72:52 - like subscribe to the channel and i will
72:54 - see you in the next one
72:57 - [Music]

Cleaned transcript:

hello everybody and welcome to another video in this blockchain for beginners tutorial series in this video we're going to be continuing from the last video and learning more about solidity once we learn a few new topics then we're actually going to work on an auction where we're going to be auctioning an nft now this will work with any type of nfts this is really really cool and if you're interested in nfts you're going to learn a little bit about how they work so with that said we'll get into the content in a second but i do need to thank cartesi again for sponsoring this video and this series they are an awesome company they've been helping me come up with the content for this series and they have a bunch of scaling solutions for ethereum and for developing smart contracts that we're gonna look at in a future video regardless let's go ahead and get into the content alright so i'm back in remix and in front of me i have the example that we finished in the last video which is kind of a mock bank account now what i'm going to do is just give you a quick recap of everything that's in this contract so we understand the syntax and get a quick refresher then we'll look at some new solidity features and we'll actually move into working on that auction which is going to be the bulk of the video okay so right now we can see we're inside of a dot sol file now the dot sol stands for solidity and that's the extension you need for your solidity smart contracts now at the top of our contracts we need a pragma line now the pragma line is going to tell solidity what compiler version we should use so in this case we're using 0.8.10 to see the compiler versions you can go to the solidity compiler extension click here and then it will show you the versions in this case 0.8.10 is one of the latest so that's the one that we're going to use great we then define our contract we say contract my contract open the curly brace and close the curly brace and inside of here is the content of our contract now it's worth noting that you can define multiple contracts in one solidity file and you can have stuff like contract inheritance that's a little bit complicated we don't need to look at that here but just wanted to mention that okay so inside of our contract here we start by defining what most of you would consider a class attribute this is just going to be actually a private member of this class because we've defined it as private anyways this is a mapping type now the mapping type is like a hash table or a dictionary where we have some key that can be associated with some value now in this case we're having an address this is going to be an ethereum address being associated with a uint so an unsigned integer we then denote this as private meaning we can't directly access this from outside of the contract and then we have balances that's just the name of this mapping okay now we have a function the function is called deposit it's denoted external and payable now external says that we can only call this function from outside of the contract so i couldn't go here and do something like deposit that would be invalid because this is an external function then we have payable payable is saying that this is either going to be sending money to someone or receiving money or specifically ether and in this case since we're going to be getting money we have to make it payable then what we do inside of deposit is we say balances at message.sender now message.sender is going to be the address of the sender of the transaction who's sending money to this contract so essentially whoever invoked the call to this contract or made the transaction to this contract it's going to be their address we're adding that as a key to balances and then we're going to increment the value here by message.value now message.value is going to store the amount of ether that they sent to this contract and the reason why we can do this is because the default value of all of our uins inside of our mappings is going to be zero so even if this sender does not already exist in the mapping we'll simply make the value equal to whatever the message.value is because the default value is 0. hopefully that makes sense that's explained in the previous video in case you are confused regardless we now have withdraw so withdraw is going to take in an address payable this is going to be our addr that's going to take a new int amount now this means that we need to pass an address to this withdraw function this is the address that we want to withdraw funds to then we have uint amount this is the amount of funds that we want to withdraw from the contract now this is a public payable function when we say this is public that pretty much means it can be called from anywhere and then we have payable and again what payable means is we're either going to be sending money out or receiving money so of course we need to denote this function as payable okay we then have a require statement now what the require statement is going to do is it's going to check if this condition is true and if it is not true then it's actually going to raise an exception and the exception is going to be insufficient funds that means we're actually going to cancel the entire contract call everything that would have happened is going to be reverted i'm going to talk about this more in a second and essentially this transaction is going to fail because this condition was not satisfied okay so you use require when you want to ensure that something is true before proceeding in the contract okay so we're requiring that the balance of the address is greater than or equal to the amount that we want to withdraw makes sense if we don't have that then the error or the exception is insufficient funds so next we're actually going to send money from the smart contract to this address if they had sufficient funds to withdraw so we're going to say bool sent bytes memory data is equal to adr dot call and then we're putting the amount that we want to withdraw and we're actually calling this transaction now if you're confused on how this line works i spent about three or four minutes explaining it in the last video so you can go back and watch that essentially all this is doing is sending money to this address this is the amount of money that it's going to be sending or the amount of ether great then we have this bool sent now this bool sent is going to be equal to true if we successfully sent this otherwise it's going to be equal to false so if we were not able to successfully send the money some error occurred there then we're just going to raise the exception could not withdraw otherwise what we're going to do is we're going to update the balances so we're going to say balances at message.sender minus equals the amount to make sure they can't just keep withdrawing the same amount of money it's actually going to subtract from their current balance when they withdraw great then we go to this function so this is get balance now let's say public view function now again public means we can call this from anywhere and view actually means that this is only going to be returning or accessing state from this contract it's not going to be modifying it so this means we can call this get balance function without actually having to make a transaction which pretty much means this is free to call so this is a good point in time to remind you that whenever we're just accessing the state of a contract this is free we can just query the state of the contract we don't need to pay for this however if we're going to be actually modifying the state then that requires a transaction that transaction needs to be mined and while that means it's going to cost us some money at least in gas and potentially ethereum if what we're doing requires that we send ethereum okay so let's continue explaining this we then have returns and then you end now returns is just stating what this function is going to return we're saying u in standing for unsigned integer and then here all we're doing is we're returning the address of this now this is just going to be the contract we're just going to cast this to its actual address and then we're going to get the balance whenever you have an address you can access the balance by just using dot bounce there you go that is everything that we did inside of this contract so now that we've talked about all of this i just want to spend a second talking about exceptions because we've seen them in this contract but i haven't actually talked about exactly what they do and how they work so in solidity we have a few different ways to actually throw an exception or to cause an exception to occur now an exception is pretty much an error that's going to occur in our program and all exceptions in solidity are state reverting now what that means is if there's ever an exception at any point in time during the transaction call then this is going to revert the state back to what it was previously any changes you've made up until that point will be completely removed so just to give you an example here let's say that i did something like balances at 1 is equal to 2. now i know this makes no sense but let's say i did this right here and then i come to this required line and this actually ends up raising an exception because sent is equal to false well if that's the case this line will be completely reverted we won't actually have done that operation it will be undone and reverted back to what it was before so just worth noting whenever an exception occurs any of the state in the contract that's been changed is going to be reverted now require as i'm kind of alluding to here does cause an exception right so if the condition here is not true then it raises an exception and the message for that exception is going to be whatever we put here now there's a few other ways that we can raise exceptions in solidity i'll quickly show them to you although we're not really going to look at an example of them so one way to raise an exception is to use revert now revert actually allows us to just directly uh reverse the entire contract state again this is just going to raise an exception exactly like require will except inside of here we can just put our error message we don't actually need to put any condition so if we ever encounter a revert in the program we're just immediately going to raise an exception the exception message will be this and again that's going to revert the state because that's what all exceptions do in solidity okay so that's revert now another thing that we have is a cert now a search is similar to require in fact it works in the exact same way except it's designed to be used when you want to check in variants rather than checking input validation so i'll show you here i could do something like assert true is equal to true now of course that's always going to be true but you get the idea now if this condition was false what would happen is we would raise an exception with this as the error message now assert and require are pretty much identical but the reason you use assert is because you're checking an invariant if you don't know what that means don't worry about it and if we're using require we're using that when we want to check input validation okay so that's why we're using require here because we want to ensure that the amount that they passed in is valid now in this case we could probably actually replace this require with an assert it's not a huge deal and there's actually not really any formal recommendation on which one you should use but it's kind of the standard to just use assert when you're checking an invariant and require when you're checking input validation so in this case based on what i'm saying we would use assert here because this is an invariant but we also can just use require like i had before that's completely fine anyways this isn't super important but i just want to show you those methods in case you see them in other contracts alright so that's almost everything for exceptions one more thing to note here is that the only thing that will not be reverted if an exception occurs is low level calls like this adr.com now i can't really show you what the other calls are because we haven't seen them but essentially if you were to send money to someone successfully and then later on in the contract there's an exception that occurs that's not going to be reverted you just can't revert that because once the funds are transferred well you can't really just transfer them back and so if i did something like this and let's say that this was successful then that means this is not going to be reverted now everything else will be reverted this balances will be changed back but this isn't going to be reverted the ethereum that was sent to that account is not going to be sent back to the smart contract okay there's some good reasons for that but that's worth noting now a few other things to mention here with exceptions exceptions are cascading now that means if i have an exception that occurs in another smart contract that i'm calling from this smart contract that's going to mean that the state of this contract as well as the state of the other one are going to be reverted so it's kind of hard to show this but let's say i make a contract and i call this my contract 2 like this and let's just make some functions so we can do something like function test and then just make this public view returns you ins okay and then maybe what i do here is i just say revert okay so that's what i do now if i call this function okay from inside of here then even though it's happening inside of this contract the exceptions occurring here it's going to cascade into this contract meaning that if any of the state was changed inside of here that's going to be reverted and same with any of the state inside of my contract too hopefully that makes sense but just keep in mind that exceptions cascade so even if you have like 10 contracts all calling each other and then in the 10th contract an exception occurs every single one of the contracts that we're dealing with that contract are going to get the cascading exception and all of them are going to have their state reverted and the transaction will fail now just to note here the reason why we're getting this error is because i didn't have the semicolon of course revert is fine i can put this here although this doesn't really make much sense because why would you just revert inside of a function all right so now that we've talked about exceptions what i can do is start showing you some new features in solidity and the first thing i want to do is show you a constructor so i'm just going to clear everything that's inside of this contract and i'm going to write a public variable here so i'm going to say let's go with address and this is going to be public and then i'm going to say that this is the owner of the contract so what i'm going to show you is a constructor now a constructor is simply a special function that's a part of a class or in this case a contract that's going to be called when the contract is initialized now in solidity your constructor will be called exactly one time and just like any other language constructor you can accept parameters in here you can do some setup steps and well you'll see how this works so the way you implement a constructor in this version of solidity is constructor open and close parentheses open and close curly brace and then inside of here you can do whatever you want so in this case i'm just going to say my owner is equal to the message.sender now the reason i'm doing this is so that i can keep track of who actually created this contract so when i create a contract i have a message.sender whoever sent the transaction to actually create the contract so this is perfectly valid i can say my owner is equal to the message.sender and now whoever deployed the contract will be the owner and i'll be keeping track of that inside of this public variable on the contract okay pretty straightforward that's how that works now again this is how you do the constructor you can only have one of them and this will be called exactly one time and only one time when the contract is deployed this isn't going to be called every single time a transaction is sent to the contract it's only called when it's deployed the very first time so let me show you how this works let's go and actually deploy this to the javascript vm let's click on deploy okay we have our contract when i click on owner it's going to give me the address of this account right here which is the one that i'm using now let's try deploying from this account okay so deploy my contract's down here owner now it's giving me the other own pretty straightforward that is how the constructor works and this is a pretty common thing that you'll want to do is keep track of who actually deployed the contract now another thing you can do in here is accept parameters so maybe i just want to accept a uint and let's just go with something like test for now again this can really be anything okay so i want this to be test and then what i will do is say u int public and let's just go with i don't know v i'm just picking random names for now and i can do something like v is equal to test that's completely fine i can access the value of this parameter so now let's get rid of these contracts all right so now we can deploy our contract and notice where the deploy button is it's actually giving me a parameter that i need to pass here it's saying tasks this is the uint256 so i'm going to do something like 2 hit transact now i go to my contract i have owner and i have v and i can see v is equal to 2. there you go that is the basics of the constructor now of course you can have multiple arguments if you would like or multiple parameters sorry and do whatever you please with them great so what i'm going to do now is just get rid of everything inside of here and i'm going to start talking to you about a new thing which is called a pure function now we've looked at view functions we've looked at payable functions internal functions external functions public functions now we want to look at pure now a pure function is pretty straightforward but it is simply a function that is not going to do anything with the state of the contract you can kind of think of it like a static method because it has no access to the internal state of the contract it just does some type of computations then returns some value so i'm just going to write a function here i'm going to say function and this will be something like add two now we will make this a public and then this will be pure function and this is going to return a u int like that now i'm going to take as a parameter here the u int x and all i'm going to do is just return like this x plus 2. okay very straightforward but this is a pure function now as i said a pure function is not going to modify or access the state of this contract it's just going to be performing some type of computation that doesn't rely on the actual contract internal state so just like accessing the data from a contract this is going to be free as well we don't need to pay to do this and let me prove this to you so if i go to my injected web 3 now i'm connected to the goreli test network and i do deploy this okay it's going to ask me for a i guess transaction because when i deploy i need to pay for that and then let's give this a second okay we can see that our contract is deployed now let's do something like add two five notice it gives me the value seven back i didn't need to add a transaction to be able to do this okay so whenever you have a view or a pure function these are free you don't need to have a transaction to call these so if you ever just want some type of utility functions associated with your contract then you make them pure okay hopefully that makes sense that's all i need to cover with pure okay so now that we've gone through that we can start getting into the important stuff which is events so i'm actually going to hop over to the drawing tablet to explain to you what events are and then we'll start implementing them when we work on the auction all right so i'm now on my drawing tablet i'm going to start explaining events to you but before i can do that i need to talk to you about why we need them so in front of me i have a smart contract now this is going to be our auction contract and on the auction we're going to have some function called start now of course we're going to have some other functions as well but for now just imagine we have start and what start is going to do is it's going to attempt to start the auction so it's going to modify some of the state and then it's going to return a value indicating to us whether or not this was successful so we're expecting this to be a bull let me just write this right here indicating that it's going to return a bool okay that's great so now we want to start the auction so let's say we have some account so account one like this we know since this is going to modify state we need to make a transaction to the auction to be able to start this so i'm going to make a transaction we're going to call start on here and then what we're expecting is that we're going to get some return value here indicating to us whether or not this started successfully well if we're just working on our javascript vm then we know that it's actually going to work successfully we're going to be able to get a return value we'll see something like true or we'll see something like false however if we're working on a real blockchain we're actually not able to return something from a function that's modifying the state back to our account so essentially whenever we're making a transaction we can't return data back to that transaction now this actually makes sense if you look at how transactions work but for now you really need to understand that if you ever make a transaction to a smart contract that contract cannot return you any data now it can try it can have a return statement but you're not going to be able to view that return data from the transaction so really we have to imagine that this is going to be a oneway operation where we're just going to call start now if an exception occurs we're going to be notified of that however if an exception doesn't occur we're not going to get any return value so trying to do something like this is not going to work on a real blockchain now that's a pretty big problem right because in a lot of situations when i make a call or i make a transaction sorry to my smart contract i probably want to get a return value i need some information i want to know if this started successfully however we can't have a returned value so how do we get around this problem well the way we get around this problem is with events so what a smart contract can do is it can actually emit events now that means that what we can do from auction is when we start this we can create or omit something known as an event and this event can have a return value that we might want this account to be able to see so we can emit an event that says something like started and then maybe we can put the time that this started out and we can put if it happened successfully or not so we could but true or alternatively we could put false now these events will be stored on the blockchain however they're going to be stored in a different way than the data associated with your contract so any of the variables you would have defined or kind of the state of the contract is said to be in storage these events are not going to be in storage they're going to be stored as a part of the transaction history on the blockchain so that makes them a little bit less accessible however they are much cheaper to use because of the way that they're stored so i'm not going to get into this too much but essentially just understand that your events are stored in a different way that makes them much cheaper to actually store although they are a little bit harder to access so that means that you usually use a thirdparty tool maybe something like etherscan to actually read and query these events because it's not as simple to go directly look at them like it is for the data on the contract and so we omit this event and then this account here or some external client that's off the blockchain is able to view these events and subscribe to them so they'll be notified if an event occurs now i'm going to get into a detailed example in a second but for now just understand that whenever we have a transaction our smart contract cannot return a value to that transaction instead what it can do is emit an event this event will be stored off the blockchain you can kind of think of these events as a log right we'll be able to then view those logs off of the blockchain and we can search for specific data inside of those logs and subscribe to events which means we'll be notified when an event occurs now just an important note here this is not the case so the no return value thing is not a case if we're making a call not a transaction now i understand this is a bit confusing but if i'm making a call to a function that does not modify the state so that doesn't require that i spend money on it doesn't need a transaction essentially i'm just querying the state then of course i can get a return value right if all i want to do is just get some data that's stored in the state of the auction that's fine i can do that i can get a return value but if i make a transaction that modifies the state that's the situation where i can't get a return value okay hopefully that makes sense but that is why we need events so now let me clear the screen and let's get into a more advanced example all right so for this example what i want to do is imagine that we're trying to build an application that's going to be partly on the blockchain that's going to allow us to auction our nft so again we still have this auction this is our contract but now what we probably want to do is we probably want to make a nice beautiful user interface that allows users to interact with this auction so to interact with the auction the owner of the auction is going to need to start it and then once it's started we're going to be able to accept bids right now the bid will be a certain amount of ethereum and we'll need to keep track of what the current bid is who's currently winning the auction we need to know when the auction ends and all of that logic again will be handled by auction however we want a very easy way for users to be able to interact with the auction contract i don't want them to have to write some really low level code and send their own transactions instead i want them to just be able to connect their blockchain account or their ethereum account with my user interface and click this nice big button that says bid okay so they're going to be using my user interface all of my clients are going to have a different instance of the user interface maybe this is something like a react app or something like a javascript client whatever right so let's say we have kind of two user interfaces here and we have two people that are bidding against each other just for simplicity so i'm going to say that this is number one and this is number two now the concept here is that this person's going to press the bid button it's going to send a transaction to the auction it's going to send maybe one ethereum and well that's going to be their bid and then this person maybe they want to send a bid maybe they send a bid of to ethereum now this is all great but again we run into this problem where i want these user interfaces to be able to be updated whenever another bit occurs so essentially if i'm sitting right here i want to know that number two just made a bid so that i can then bid again and i can bid three ethereum right now how do i do that well since i can't get a return value here and since my auction can't send something to my user interface it's not able to do that what i need to do is use my events so what's going to happen is every single time i make a bid an event is going to be emitted so i'm going to say emit and then i'll omit an event that's going to be something like let's write this properly something like bid one f and then it will be from number one and then we'll probably give the time that this bit occurred and a bunch of other information but the idea is we're going to omit all of these events and then what we can do is we can have these user interfaces subscribe to the events so when they subscribe to the events what's going to happen is they're going to be notified when an event occurs and then they can use the data from the event to update their user interface and tell the user hey you just got outbid do you want to bid again or hey the current bit is this or the auction ended or whatever you get the idea but the concept here is we have an external client right so our javascript clients kind of sitting on some type of user interface they are subscribed to the events that this contract is going to be emitting and whenever the contract omits an event they'll be able to update their user interface and they could say query the state of the auction if they wanted to they could do that for free because that doesn't require a transaction hopefully this makes sense but that is the point of events and this is kind of how you would start building out a very simple blockchain application you would deploy your smart contract this would be kind of your source of truth right this would handle all of the complex logic then you would have your nice user interfaces that allow the user to interact with the smart contract and be updated of things that's happening with the smart contract because the smart contract can only do some type of operation when a transaction is performed so you need some type of external client sitting listening for events and updating the user then the user can trigger those transactions to the smart contract when they actually want to do something that is state changing perfect there we go we now understand the importance of events let's go ahead and go back to the computer we're going to start writing out this auction contract and looking at events all right so i'm back on my computer in remix we're actually just going to start working on the auction contract and then as we work on that i'll show you events so i'm going to change the name of my contract here to auction because that's going to be a bit more fitting and i'm going to implement a bunch of public things that we need here for our auction so if we're thinking of an auction we're going to have a time span for this auction so we need to know if the auction has been started if it's ended how much time is left so when the auction is actually going to end we want to know all of the bids we want to know who's selling the nft we want to know what the current highest bid is and who the current highest bidder is and we also need to know what nft we're selling but we'll deal with the nfts later because that's a little bit complicated so for now what i'm going to do is say address payable it's important we do payable here because we're going to want to pay this person who you'll see is the seller so we're going to say address payable public seller now it needs to be payable because well the seller of the nft we're going to have to pay the profits of the auction so whoever you know the highest bidder was we're going to take money from them and send it to the seller okay now other than that we are going to need to know when the auction started so actually we don't need to know when it started we just need to know when it's going to end if it started and then if it's ended so i'm going to say bool and then this will be public and this will be started we'll then say bool public ended and we'll say bool our sorry not bool this is going to be you int and then this will be public if we could spell this correctly and then end at and this will be the time that we actually are going to end the auction at now other than that we need the highest bidder so we're going to say you int or sorry we want the highest bid so i'm going to say uint public and then this will be highest bid like that and then we will have address and do i want this to be payable let me look at my cheat sheet here no i don't think we need that to be payable we'll just say address public and then highest bidder like that uh and that should be good now other than that we're gonna need some mapping to keep track of all of the bids that users have made to this contract so the idea here for the auction is that when you make a bid you have to send money to the contract so if you don't actually end up winning the nft then you need the ability to withdraw your money right so we're going to have a withdrawal function that allows you if you didn't win to actually take all your money back from the contract so i'm going to say mapping and then this is going to be address and this will go to a uint and this will be a public and then this will be bits now the reason all of these are public is because i don't need to hide any of this information it's fine if everybody sees it and i want people to be able to see when it started when it ended what the end that is what the highest bid is because you want people to trust this contract that's the whole point of writing smart contracts right okay so now that we have that i'm going to make a constructor i'm going to say constructor like this and all i'm going to do is simply assign the seller so i'm going to say the seller is equal to message dot and then this will be sender so whoever deployed the smart contract will be the seller of the contract now notice i'm getting an error here it's going to tell me that the type address is not implicitly convertible to expected type address payable now i didn't show this to you previously but the way that you can convert a regular address to a payable address is you can just say payable like this and then surround what you want to convert so now this address that is not addressed payable will be payable and i'll put that inside of seller okay now what i'm going to do is implement a start function this function will allow only the seller of the nft to start and they'll need to pass all the nft details to be able to start the auction now we won't implement the nft stuff right now as i mentioned we'll do that at the end so i'm going to say function we'll just call this start then this will be public external okay so we're going to call this from outside of the smart contract and inside of here what i want to do is i want to require that the message dot sender is equal to the seller otherwise i will say you did not start the auction exclamation point okay and then we'll go with semicolon now what's the error here it says visibility already specified as public okay so that's my bad story i'm just going to make this external because you can't have public external those are going to be you know messing with each other so external is fine now what's the warning function state mutability can be restricted to view okay that's fine we're going to change that layer okay so now what i'm going to do is i'm going to say started is equal to true and then what i need to do is pick the end at date now this is going to be a little bit weird because we haven't seen this yet but i'm going to say end at is equal to and this is going to be block dot and then time stamp plus and then seven days now we can actually change this so that it's not days and in fact let me check if that's correct okay actually i think seven days is correct so first of all let's just explain what this line is because i haven't covered this so block is actually referring to the block that this transaction is a part of once it's been mined right so once it's been mined it will be a part of a block and the block is going to have a time stamp that's when the block was created so this is going to give us the relative timestamp of the transaction it's not going to be precisely when we sent it but it will be very close to that because blocks are created very very quickly in ethereum and we're going to add seven days to that and days is a keyword just like ether in remix so i can or sorry not in remix but in solidity so this way we're just going to add seven days to this time stamp which means we will end seven days after this so of course feel free to modify the number of days i mean you can make this one day if you want two days whatever it doesn't really matter in fact let's just go with two days for now but whatever you set this that's going to be the amount of time the contract or sorry the what do you call it the auction will last for okay so now we have start however what i want to do is add one more require here that just makes it so we cannot start this contract if it's already started so i'm going to say not started like that and then i'll say already started exclamation point and what i want to do is i want to omit an event saying that i started the contract so now we're going to talk about how we actually implement events now creating an event is actually pretty straightforward you first need to declare an event in the body of your contract so i'm going to do it up here i'm going to say event and then start and i've just created an event now we need to omit these events but this is an event that is emittable so what you do is you put the keyword event you then put the name of the event in this case i'm going to go with start now notice i'm starting it with a capital because the convention here is pascal case just like our contracts and then inside of the parentheses you put any arguments you want the event to accept so you could put for example the address of the person who started the event now that wouldn't really be very useful because the only person who can start the event or sorry start the contract or start the auction is going to be the seller but you could put any other data you want here you don't need to put the time because that will automatically be associated with events whenever they're omitted but i can put any data inside of the parentheses and then i pass that data as arguments when i omit the event and that'll be like the data of the event we'll see this in a second right now for start i don't need any arguments we won't look at that right now but when i do events for a bid i'm going to have the address of the person who bid the amount they bid et cetera right okay so anyways we have an event defined which is start and now if i want to emit an event this is really straightforward i just do omit and then i put the name of the event like that okay there you go i'm now emitting the start event now if start was accepting arguments i would pass them right in here so whatever the arguments are right okay there we go pretty straightforward so now that we have that let's deploy this contract let's deploy it to a legitimate network right so i'm going to deploy it to the goreli test network and then i'm actually going to go look at the events of my smart contract and show you how you can view them off the blockchain on etherscan so let's do this i'm going to click deploy and then once it's finished i will let you know okay so the contract has now been deployed so i'm going to click on the contract deployment here i'm going to view this on ether scan notice it says that it was successful so what i'm going to do now is click right on the contract so notice it says contract here it was created so i'm going to click on that and when i go here we can see we have the hash of the transaction that created the contract then i can click on events now when i go to event notice we don't see any events now that's because we haven't triggered any yet but i'm now going to trigger an event and show you that it will show up right here okay so let's go back to remix let's now go to our contract and let's start by just clicking on some of these so we can see the seller is it started no it's not started so let's start it by clicking on start now when we do this of course we need a transaction because this is going to modify the state so i'm going to click on confirm okay this is going to take a second to complete and let's just go here and it should tell us when this is done then we can go check the corresponding event that would have been omitted okay so this is finished now so let's go back here and let's refresh the page and notice that we have an event now the event is start okay and i can click on this right here and kind of view some of the details now the method will actually be the method that we called in the transaction now this is going to be a special hash of this method i'm not really going to describe exactly how you kind of read this stuff because there is a special way to do that however whenever you're going to be subscribing to events or trying to get the data associated with an event you're not just going to be reading it from this page you're going to have a client this client is going to be using a special library a library could be something like web3js this is a javascript library that kind of handles a lot of this complex lower level stuff for you and it will kind of decode this data and tell you the stuff in the event now i'm not going to show you how we subscribe to events in this tutorial because it's fairly complicated but if you were writing say a javascript client or something what you could do is use something like web3.js so let's do this this is the ethereum javascript api and inside of here you can subscribe to events so if you go to f.subscribe this is the thing right here i'll leave a link to this in the description and you can kind of view how you would do this and how you actually get the data associated with events from a smart contract okay let's go back to remix though and let's continue all right so now that we've written the start method let's write the end method or the end function so i'm going to say function end external and inside of here i need to require a bunch of things the first thing i'm going to require is that they started the contract so i'm going to say require started because well if they haven't started it they can't end it so i'll say you need to start first exclamation point doesn't really matter the error message that i give then i will also require that the block dot timestamp is greater than or equal to end at because i don't want to allow someone to end the auction if uh the end at time is not yet reached right because that would be unfair that means you could have someone like bid on it and then you could end it for them so that they would win it before anyone else was able to bid anyways we're gonna do this we're going to say block.timestamp greater than or equal to end at i'll say auction is still ongoing is ongoing one word or two word i think it's one word someone can correct me in the comments clearly programming is greater than spelling anyways and then we also want to make sure that it's not already ended right so i'm going to say not ended we'll say auction already ended and let's spell already correctly okay exclamation point perfect so now that we have all of our requires what we can do is say ended is equal to true and then we want to emit an event that says we ended it now of course when we end we're going to actually have to transfer the nft to the highest bidder and then we're gonna transfer the funds from the contract to the uh what do you call it the seller of the nft but for now we'll just do the events so let's go up here and let's say event and let's say end now for this event i actually want to know what the highest bid was and who the highest bidder was so i know who won the auction right so i'm going to say let's go with address and this will be i guess highest bidder okay and then we will go with uint and then this will be highest bid okay so that's for event and in fact i guess i can do this yeah that's fine we can do that inside here okay so now for end i'm going to say omit and then end and then inside of here i'm going to pass the highest bidder so let's go highest bidder like that and then let's pass the highest bid perfect okay there we go now one thing i want to add to start is i just want to add a parameter here that's going to be the starting price or the starting bid or whatever for the auction so i'm going to say uint we'll say starting bid and what i'm going to do is after i start this or it actually it doesn't really matter where i do this but i'm going to say that the highest bid is equal to and then this is going to be the starting bit so this way you're going to have to bid at least a little bit higher than this to be able to actually win the item if you were say the only bidder that way someone doesn't list this and kind of gets screwed by only having someone bid like one way or twoway or something and no one else actually bids on the nft regardless we'll have that for now and we can now test if end is going to work and then we can implement bid and we can implement withdraw which are the other two functions that we're going to need so let me save this now let's close this i'm going to deploy the contract again this will take a second once it's done i will be back all right so the auction is now deployed now i can start this by passing say a thousand way as the starting bid we will wait for this to go through and then we can try to end it now i will show you that when we end it this isn't gonna work and the reason it's not gonna work is pretty obvious but we don't have this condition being equal to true right the block.timestamp is not going to be greater than or equal to end at so it's not going to let us end this and i'll just show you that that works in a second once this starts okay so that's started let's now go to this contract the way i'm going to get to this is i'm going to open up metamask i'm going to go to contract creation okay let's go here let's view the contract okay it's still indexing let me refresh this once it's done i'll be right back okay so now it is fully successful let me click on the contract let's go to events and we can see that the event start has been triggered or been omitted right because we started the contract so now let's see what happens if we try to end it so notice is going to tell us that we're probably going to get a problem here it's saying that gas estimation errored with the following message see below the transaction execution will likely fail do you want to force sending and it's saying that the area's auction is still ongoing so it's actually able to look at our smart contract and realize that we're not going to be able to do this because the block dot time stamp is not greater than or equal to the end at time so we can still send the transaction if we want now if we do this what's going to happen is it's just going to fail now when it fails and we hit a require statement the required statement will return whatever remaining gas we had as a part of this transaction back to us however some gas is going to be lost now that's one thing to note here with require it does actually return your gas if this fails again not all of it because it still had to use some gas but it will return whatever wasn't used so you can see here we're getting this error right it's telling us this didn't work and we weren't able to do that because this require statement would have been well not true right it would have you know caused an exception okay so hopefully that makes sense that is how that works now that we've done that let's start implementing the bid and the with draw functions that we need okay so let's code out the bid function let's go with function bid external now this needs to be payable because this is actually going to accept ethereum right so inside of here we need to require a few things we're going to require that we have started the auction if we haven't started then obviously we can't do this so i'm going to say not started we're going to require that the block dot timestamp again this is a global keyword that we have access to is going to be less than the end at time so this means that the contract is not ended or sorry i keep saying contract i mean auction so we'll say ended exclamation point and then we will also require that the message dot value so this is going to be the value of the bid because they're going to be sending the amount of the bid right is greater than and then this will be the current highest bit okay so now we have all of our required statements now let's see why it's getting mounted mountainous here it's saying expected semicolon but got identifier okay i need a semicolon right there so now if this is the case what we're going to do is we're going to update the amount of money that people have sent to this contract kind of similar to the bank account by using this bids mapping and we're going to update the highest bid in the highest bidder because at this point we know this person would have bid an amount higher than the highest bid so we need to update those values right so we're going to say that the highest bid is equal to message dot value and we're going to say that the highest bidder is equal to the message.sender okay so now after updating this since the highest bidder has now changed what i need to do is make it so the person who just got outbid is able to withdraw their money from the contract so i'm going to say if and then this is going to be the highest bidder so not bid but bidder does not equal the address zero now address zero is the default address i'll talk about this in a second then what i'm going to do is say that bid at and this is going to be highest bidder plus equals and then the highest bid so the logic here why is this yelling at me let's see what the problem is operator not compatible with types uint256 and address sorry this needs to be highest bid not highest bidder okay that's better but the logic here is that as soon as someone gets outbid i want to allow them to withdraw their money from the contract so that they could withdraw and then bid again right because otherwise they would need to have a ton of ethereum to be able to actually continually outbidding someone if all of their money is stored in the contract so hopefully this makes sense but since we're updating the highest bidder now if the highest bidder was not equal to address zero so essentially if this was not the first person to make a bid then what we do is we take whatever the highest bidder was store that in our bids mapping and then we add whatever their highest bid to that so that now they're able to withdraw and let's say they don't withdraw and they just continue making bids that's fine this will continue to increment however many bids they've made so then they will be able to withdraw all of that if they're not currently the highest bidder okay and actually they'll be able to withdraw whatever amount inside of there is not their current bid that's being stored in highest bid you can look through this logic and probably see why that makes sense but address zero just to clarify here is the default address so when i write something like address public for right now sorry not just public but address public highest bidder it's going to be storing just a zero filled address so i'm just making sure that it's not equal to the zero filled address and you can do that by just writing address and then putting zero inside of here okay so that is bid that's pretty much all we need for bid now we want to write the withdraw function so i'm going to say function withdraw like that and then this is going to be an external payable as well and inside of here what we need to do is withdraw a certain amount or i guess we'll just withdraw the entire amount of whatever the person's bidded that's not the current bid so we're just going to start by getting the amount of money they've sent to this contract that's not currently the highest bid so i'm going to say a uint and i guess i'll just go with something like balance is going to be equal to and then this will be bidsat message.sender and then what i'm going to do is say bidsmessage dot sender is equal to 0 just to reset that and then i'm going to send whatever their balance is to them so the way i'm going to do this is i'm going to write this complex line in fact i'm just going to copy this in because we saw this in the last video i'm going to say bool sent bytes memory data is equal to payable message.sender so just converting that address to a payable address dot call value and then this is going to be balance balance is right here right and then what i need to do is require that this was successful so i'm going to say require sent and i'm going to say could not withdraw so let's do this could not withdraw let's add our semicolon and there we go we have just implemented the withdraw function now what i'm going to do is actually add some events here as well for bid and for withdraw then we can test this out and then we'll start actually working within nft because right now we're not really auctioning anything so let's make some events let's make an event for bid now what i want to do is have an address now this is going to be indexed now we haven't seen this keyword before but what you're allowed to do whenever you're defining the arguments for your events is you can put an indexed parameter and you can actually put up to three of these and this is what you will be able to search for an event for so if i say indexed here then this means i can search by whatever this parameter is for this event in my logs right or in my event so i'm going to say address indexed let me just look at my cheat sheet to make sure i don't mess this up it's going to be sender and then we're going to say uint amount to specify how much they actually bid and then we'll do an event and this is going to be withdraw and this again will be an address that's going to be indexed this will be the bidder and then this will be you ins and the amount that they withdrew okay i think that is fine now what's it telling me what's what's it saying i did wrong here oh i spelt index incorrectly okay so let's go and let's now omit these events so i'm going to say omit and then this is going to be bid and then we're going to pass to this just the highest bidder and the highest bid okay perfect let's add our semicolon and then for withdraw we will say omit and then withdraw and then we're going to omit the message.sender and the balance great there we go okay so now let's actually just deploy this we can do some experiments with it i'll set up another ethereum account make sure it works and then we'll talk about the nfts so i'm going to deploy once it's done i will be right back okay so i am back this finished deploying my contract this year i actually started the contract with a minimum bid of a thousand way and now what i'm going to do is change my ethereum account in fact i've actually already done this so i deployed this contract from my tutorial account but now i'm on account one so now i'm going to make a bid from account one and show you how this works so i'm on account 1. you can see i've reconnected this here to what do you call it remix and now i'm going to make a bid of a thousand way i'm going to click on bid then when i do this notice it's going to tell me that i'm probably going to get an error the reason i'm going to get an error is because this is not greater than the starting bid and so i'm just going to cancel the transaction so i'm going to change this now to be a thousand one let's click on bid and let's see okay so confirm let's give this a second and again notice i'm not going to get any return value here it's not going to tell me if this was successful or whatever i'm just going to see that the transaction didn't fail whenever this is done and then i should see an event be emitted here okay so let's now refresh this and we now see uh hmm okay maybe we need to wait a second okay so the event has showed up i just had to wait a second i was being impatient but after i refreshed a few times it appeared here anyways this has happened successfully i know this looks like gibberish but if you were actually subscribing to this event then you would have some library that would be translating this for you so you'd be able to read the real data regardless the bid happened and i can look now at for example the highest bid which i can see is 1001 the highest bidder which is this address i can look at the seller which is different if the contract is started and all of this type of stuff now that's pretty much all i wanted to show you for that since we don't really have two days to wait here for this to finish i can't show you it actually ending what i will do though is i will now start implementing the nft stuff which is a little bit complicated but it's pretty cool so i'll try my best to explain it to you alright so i've just switched tabs and i'm going to try to explain to you the difference between fungible and nonfungible tokens and how these kind of live on the ethereum network so i'm sure all of you are familiar with cryptocurrencies right we have currencies like ethereum we have currencies like bitcoin we have a ton of other currencies that are built on top of these main blockchain networks so if we're talking about coins that are built on ethereum these are tokens now really all a token is is a smart contract that defines that your address owns a certain amount of tokens now this is specific to ethereum but if you're working with a token that's on the ethereum network really what gives you the ability to own that token is that there's a smart contract with the name of that token it's named say timcoin for example right if i had my own token on ethereum and in that contract it says that your address has 20 tim coins or 100 tim coins or whatever it is now the way this all gets standardized is that what happens is you need to implement specific methods or specific functions on your smart contracts then make it act like an erc20 or an erc 721 token now erc20 is simply a protocol for a specific token in this case it's a fungible token now erc20 states that you need to define some special methods on the smart contract now if you do that ethereum is able to look at your smart contract and treat that smart contract like a token rather than just any other smart contract now that means in your ethereum wallet you're going to see your tokens showing up or you'll be able to link them you'll be able to then say buy these tokens or exchange these tokens because you've defined certain functions on the token and it meets the erc20 protocol hopefully that makes sense now erc 20 is simply a fungible token protocol what that means is every single one of these tokens is exactly the same so there's no difference in you owning one of the tokens or the other tokens like any token is just identical each of them has the same value and as it says here this makes erc20 tokens useful for things like medium of exchange voting rights staking whatever okay that's what you can use these tokens for however now we go over to erc 721 now erc 721 is fungible tokens now fungible tokens mean that these tokens are different so there could be a different value associated with each token maybe there's some assets like an image associated with a token hence nfts right maybe you get some special rights with a specific token tokens are unique they are different and they have a unique id now this is very similar to erc20 except you're just having these unique tokens and you have some special functions now that you need to define on smart contracts that are defining an erc 721 token so it's a little bit too complicated for me to show you exactly how to create your own nfts or your own erc20 tokens but the concept is again that we have this smart contract this is an example of an nft contract this smart contract defines who owns what nfts it's capable of creating new nfts and then if i wanted to say send my nft from me to you what i would do is call a function on the smart contract that transfers the nft i have to be the owner of the nft to be able to do that and then it changes the internal state of the nft contract to now define that you own my nft because i sent it to you so hopefully this makes a tiny bit of sense but that's the general idea behind tokens and behind nfts and all of this type of stuff now as you can see here there's some other types of tokens that you can create but erc 721 is the one we're going to work with right now and what we're actually going to accept in our smart contract that's going to be the auction is the address of a smart contract that represents an nft as well as the unique id associated with the nft that the user wants to auction so whenever you get an nft it has a unique id associated with it because every single erc721 token is unique when i say erc721 that really just means nonfungible token okay and so it has a unique id if i pass that unique id along with the contract representing that nft then what i'm able to do is verify that the user owns that nft and then actually list it in the auction and transfer it between different people okay so now let's get into some even more complicated stuff because i need to show you how we can make our own nft and when i say make our own nft i'm not talking about make your own nft contract i'm saying kind of acquire an nft in your ethereum account so that you can follow along and actually auction off your own nft in this tutorial all right so to do this i'm going to go up to this other tab here where i have token.sol now i'm not going to explain any of this code but essentially this is my own timcoin nft okay and i'm going to give you guys all the privilege of owning some timcoin completely for free it has zero value and it's going to be on an ethereum test network but you can own it for free you are welcome and the way i'm going to do that is i'm going to deploy this smart contract i'm going to leave a link to the contract address in the description and you actually are able to create your own nft by calling this award item function which is going to give you your ethereum address a nft okay it's going to give you a special id essentially of timcoin i'll explain this more in depth and i'll show you exactly how to do this but right now when you're watching this video this will be deployed on the goreli test network so you need to make sure you're using that test network and then what you'll be able to do is interact with this contract from remix again i'm going to show you exactly how to do that it will then award you an nft and then once you have that nft you'll be able to auction that nft inside of our test contract now before i show you how to do that we're going to implement kind of the nft logic in our contract then i'll show you how you get your own timcoin nft again you're welcome you guys can thank me in the comments okay so what we're going to do is we're going to now specify what's known as an interface that we are going to accept for a specific contract which is going to be the contract address of the nft that we want to list so i'm going to say interface so actually there's not a ton of value of me typing this in so i'm just going to paste in the interface and i'll explain what this is so first of all an interface is an abstract data type the reason we're going to use an interface is because we need to verify that the contract passed to this auction does actually represent an nft and so we're going to treat the contract as an irc 721 type contract which means we're going to make sure it has a transfer and a transfer from function on it now if you're unfamiliar with interfaces i can't explain them too much in depth essentially they just enforce that anything that is of type of this interface has these methods that are specified in this way so for us to have a valid nft contract really all we care about is that it has a transfer and a transfer from function that we can use now the transfer from allows us to transfer from one address to another address a specific what do you call it nft id okay so as i was saying before all we're doing is we're going to be calling a function on the nft contract that takes in the address of the owner of the nft the address of the receiver of the nft the nft id it verifies we own this nft and then it would transfer it to here and then transfer is simply going to take an nft id and transfer it to a specific address once it's been approved to do that you'll see what i mean in a second but anyways that's our interface so what we're going to do now is we're going to go inside of our auction and we're going to define the nft that we're actually going to be auctioning so i'm going to say i erc 721 public like this nft and then what i'm going to do is i'm going to say uint public nft id okay so what i'm saying is i want to store the contract of the nft address here it's going to be of type ierc721 meaning it has to have these functions on it and then i'm going to have uint public not nd t nftid which is going to be the unique id of the nft that we want to auction so now inside of my start function what i'm going to do is take in a starting bid i'm going to take in the nft contract and the unique id of that nft so i'm going to say irc 7 21 this is going to be nft and we'll make this underscore nft and then we're going to say uint nft id we'll just make this underscore again so it doesn't mirror our global name and then comma now let me make sure i typed that correctly i think i did okay so now inside of here what we're going to do is we're going to set the nft so we're going to say nft is equal to and then this is going to be underscore nft again this is the contract representing the nft then we're going to say nft id is equal to underscore nft id like that now what i'm going to do is just take these two lines here and put them after i do this just in case these return some error although it doesn't really matter because if an error was returned then the state would have been reverted but that's fine okay so we're going to do that now what we also need to do is we need to transfer this nft from the owner of the nft to this contract so now the contract owns the nft and then is able to actually transfer this to whoever wins the nft in the auction right so what i'm going to do is say nft dot transfer from and we're going to transfer from and this is going to be the message.sender who we're assuming owns the nft to this or sorry it's going to be address this like that and then this is going to be nft id okay so this here is going to fail if we don't own the nft so if whoever called this start here doesn't own the nft then we're not going to allow them transfer because the nft contract will raise an exception and so that whole thing will cascade meaning all of this is going to fail as well and so we won't actually start the auction so we're only able to start the auction if we own the nft and if we have the ability to send the nft from the sender to this address okay hopefully that makes sense i'll explain again how we kind of set the nft up and how we actually make an nft and get access to it in a second so now that we have that what we need to do is deal with what happens when the auction ends because once the auction ends we need to send the nft to whoever won it then we need to take the balance of the contract and specifically whatever the highest bid was and send that actually to ourselves right to the seller of the nft so all we're going to do here is we're going to check if the and this is going to be highest bidder does not equal the address zero because if it's equal to the address zero that means no one actually bid on this item and so we can just return the funds or return the nft to ourself so anyways we're going to say if this is the case then that means that we're going to take whatever the highest bidder amount was or the highest bid story we're going to transfer that to ourselves and then we are going to transfer the nft to whoever won the nft so i'm going to say nft dot transfer and then we're going to transfer it to the highest bidder i think that's all i need to put in here let me confirm that's correct oh one more thing the nft id okay so we're using the nft contract we're using dot transfer we're going to transfer it to the highest bidder and then this will be the nft id now what's it saying is the issue it says transfer is not found well that's because i spelt transfer incorrectly okay that's fine then after that we're going to figure out whatever the highest bid was and we are going to then pay that to ourselves the seller of the nft so the way we do that is we just copy in this line because i really don't feel like writing it again so we're going to say bool sent and then bytes memory equals data seller.call value and then this is going to be highest bid and then we'll call that like that and then we're going to require sent and we're going to say could not pay the seller okay there we go now in the other situation so if the highest bid actually is equal to address zero then what we're going to do is just return the nft to ourselves so we're going to say nft dot transfer and then this is going to be 2. i guess we will just say the seller and then this will be nft id and i think that's it again i spelt transfer incorrectly let me just make sure that's right looks good to me awesome okay so that is actually all we need for this contract now this contract should work however i need to show you how we can now actually get access to an nft and what that looks like in our account so i'm going to start by deploying this contract now be careful what account you deploy this from i'm going to deploy it from this one so i'm going to deploy test.soul which is really just my kind of auction contract let's confirm this okay this will take a second once that's done i'll be right back okay so that has now been deployed now remember to be able to start this auction we actually need the address of our nft so i am now going to deploy this nft contract here i'll leave the link to it in the description or you could just painfully write out all whatever the number of characters are but again it'll be linked in the description and i'll show you how you can use this to get your own nft so let me now deploy this i need to pass a string name and a symbol actually do i need to do that uh oh sorry i'm doing the wrong thing okay let's deploy timcoin so i'm going to deploy timcoin to the goreli test network this is going to take a second and then i will show you again how we can actually access this and get our own nft okay so tim coin has now been deployed now for me i can see timcoin right here right and we see all these different methods you don't have to worry about a bunch of them but anyways you're not going to see this inside of your remix because you didn't deploy this contract but you need to interact with the contract again on the gorilla test network you need to be on the gorilla test network otherwise this isn't going to work for you so what you're going to do is you're going to take the contract address which will be linked in the description and you're going to paste it right here where it says or at address okay so it should say that right at the bottom you're going to do that and then it will load this contract now notice it just loaded the same contract for me twice because i already had it here but that's how you can load again just copy it paste it in here and then it will load it right here now what you're going to want to do is you're going to want to start by setting the approval for all now i'm going to discuss what this is in a second but essentially what you need to do here is you need to allow this smart contract being the auction to actually transfer your nft now if you don't allow it to do that you're not going to be able to actually auction the nft the reason you can't auction the nft is because the contract will not have the ability to take the nft and transfer it to itself so you have to explicitly give the contract permission to do that before you create your nft so what you're going to do is go to your auction contract this is going to be different than mine you're going to copy the address of your auction contract okay i've done that i'm going to go to timcoin i'm going to go to set approved for all i'm going to paste in my contract like this then i'm going to go comma and i'm going to go true now look here it says operator which is this so the operator is the auction contract it's going to be operating on this nft and then true now what this is going to do is it's going to allow this contract to pretty much list any of your nfts now you still have to call the contract for it to do that but you're giving it explicit permission for it to access any of the timcoin nfts that you have access to so don't worry this doesn't mess with any other nfts you might have on your ethereum account and we're on a test network anyway so it shouldn't matter but i'm going to press transact this should go or this should be successful once i click confirm here okay so let's wait for that to finish and then we have set the approval for all of the nfts that you own to be able to be operated by the auction contract again what you're passing here is the auction contract now it's very important that you do this first before you actually give yourself an nft otherwise the nft you give yourself will not have the approval set for it for the auction contract okay so now that we've done that let's close all these and we're going to go to the award item function now this is what you want to press when you want to give yourself an nft so you're going to copy your address so my address is right here i'm going to copy it in to a word item and then what it says here is that there is a uri now the token uri is actually a url to json metadata related to this nft so as you may have seen nfts have like fancy images and music and gifs and all of this very valuable stuff anyways the point is all of that stuff is stored off of the blockchain on a specific url in json data and so what you actually have to do is associate data with your nft off the blockchain so when i create the nft i pass the url of the data sitting off the blockchain that represents my nft and then it links those two together and that's why when you go and you view nfts you see like a nice little fancy image it's because it's referencing the uri of this nft and then it's grabbing the image for it and displaying it pretty straightforward but that's really how nfts work again i'm not it's not meant to be an entire lesson on nfts but the token uri is just that it's a url now you actually don't need to pass anything here i'm just going to pass like one two you have to give some data but you don't have to give a url so i can pass one two three zero whatever doesn't matter so just go like that and when i hit transact then what's going to happen is it's actually going to give your ethereum account or whatever account you put the address for in nft so let's wait a second and then i'll show you that we actually will have tim coin showing up in our ethereum wallet okay so that finished so now if i go to metamask so let's get out of this here let's go to metamask and let's look at my account let's go to assets and notice how it says don't see your tokens import tokens so i'm going to click on import tokens and i'm going to copy in the token contract address of timcoin now again that's what will be linked in the description i can just copy it from right here so i'm going to go here i'm going to go to assets import tokens i'm going to paste this in notice the symbol is tim very fitting for the token decimal just put 0 and then add custom token and now it's showing that i have one tim token so i'm going to go import tokens like that and now if i look at my assets i see one tim coin okay it's just looking at the contract and since it follows the erc 721 protocol it's able to specify that i have one of these now if you want to own multiple just do this again just call the contract you can even pass the same uri it really doesn't matter and hit transact and now when you do this you're just gonna have to wait a second and then your wallet should update and once this is done you'll now have two tim coins and in fact just because this is interesting i will show you that if i go to metamask i go to my wallet here and let's go view account on etherscan you can actually view the tim coins that you have on here so notice i can go to token and i can specify timcoin and when i go here you can see that i have the token id of one i have one tim coin that was just added here in one minute now if i refresh this i should have a second tim coin in a second because i just requested that uh okay it might take a second so let's go back to where we were before okay uh award item let's refresh okay so now we should have two tim coins if we go here yes there we go now we have tim coins and the token id is one and two so if you want to see what your token id is because all of you're going to have a different token id you need to do what i just did go to metamask you're going to view your account on metamask so i went to where is that here view account on sorry not metamask on etherscan it's going to bring you to etherscan and then what you can do is go to your tim coins i showed you how to do that but let's go back so you're just going to click here click on timcoin and then it will show you your token id so you own tokenid one and two well in this case ion one and two you'll own something that's not one and two because it's going to be a unique id so this means i can auction token id 1 and 2 because i own that so now how do we auction it well this is kind of the moment of truth here to see if this is all going to work so i'm going to copy the address of my timcoin nft contract okay then i'm going to go to start i'm going to paste that in as the first argument so let's go here for the nft id you have to post an id that you own so either one or two for me and then put a starting bid so i'm going to put a thousand and i'm going to hit transact like this okay fingers crossed once i hit this let's see if this works and if everything we did was successful okay so very good we see the green check mark here meaning that this was good so now let's go to nft and notice the address is this nft id is one seller is me started is true highest bid is the zero address because no one's made a bid yet and then we have highest bid now of course this will work as it would would work before as we tested it previously and this will now take how many days did we set if we go here i think we set two days yeah so after two days then you'll actually be able to win your nft when someone hits the end button or sends the end request to this contract okay so that is going to wrap up the video i hope this was helpful in terms of giving you a deeper understanding of solidity and smart contracts and showing you a real practical application hosted on the blockchain now in the next videos we're going to be talking about some of the scaling limitations of ethereum and of solidity and some of the problems you can run into when you need to perform large computations then i'm going to be showing you some scaling solutions so ways that you can mitigate those concerns and we'll be talking about cartesi which again is the sponsor of this video and this series and showing you some of the solutions that they provide again i really hope that you guys have learned a lot from these videos i've been having a great time filming them well i look forward to posting more on the channel with that said if you enjoyed make sure to leave a like subscribe to the channel and i will see you in the next one
