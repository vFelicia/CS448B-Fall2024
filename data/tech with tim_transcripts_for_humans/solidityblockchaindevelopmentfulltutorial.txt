With timestamps:

00:04 - foreign
00:09 - [Music]
00:14 - hello everybody and welcome to this
00:17 - introductory course on blockchain
00:18 - development and solidity throughout this
00:21 - course not only will you learn about
00:22 - theoretical concepts related to
00:24 - blockchain networks like ethereum but
00:26 - you will understand how to write smart
00:28 - contracts in solidity how to deploy
00:30 - those onto the ethereum network and how
00:32 - to do things like create erc20 and ERC
00:35 - 721 tokens which are nfts this course is
00:39 - designed for complete beginners whether
00:40 - you have experience with blockchain or
00:42 - programming or not you will be able to
00:44 - follow along with this content now this
00:47 - content is meant to just be a good
00:49 - introduction to this topic and to this
00:51 - space this is not going to teach you
00:53 - everything you need to know to become a
00:55 - web 3 developer but it's going to be a
00:56 - really good starting place and kind of
00:58 - show you if you're interested in this or
01:00 - not so after going through this course
01:02 - if you are interested in web3 technology
01:04 - you really want to get to the next level
01:06 - you want to potentially land a job I
01:08 - have an entire higher premium course
01:10 - it's called blockchain expert I'll leave
01:12 - a link to it in the description this
01:13 - covers some of the same content as this
01:15 - introductory course but obviously it
01:17 - goes much more in depth we have over 20
01:19 - hours of video content we have full
01:21 - projects using things like oracles we
01:24 - show you how to actually write front-end
01:25 - code that can interact with your smart
01:27 - contracts we teach you Advanced solidity
01:29 - features there's hundreds of practice
01:31 - questions assessment questions projects
01:33 - so much more it's a great value you guys
01:36 - can check that out from the link in the
01:37 - description now this course is an
01:39 - aggregation of a bunch of videos I made
01:41 - about a year ago I know many of you
01:43 - don't actually know that I have these
01:44 - videos so every once in a while I like
01:46 - to combine them all together so you're
01:48 - going to see that after this intro
01:49 - there's kind of another intro and then
01:51 - it goes through all of the videos that I
01:53 - posted on the channel a really long time
01:55 - ago so just keep that in mind this is
01:57 - kind of an aggregation and I wanted to
01:59 - give you this introduction just so you
02:00 - understand the purpose of this course
02:02 - and I also wanted to mention that it's
02:04 - possible that when you try to use what's
02:06 - known as the gorelli test Network this
02:09 - is a network we used in this course
02:10 - about a year ago it will fail now if
02:13 - that fails I've left a link in the
02:15 - description to another test Network that
02:17 - you can use it's called Avalanche so use
02:19 - that test network instead the setup
02:21 - steps are essentially the same except
02:23 - instead of connecting to go rally you
02:25 - connect to Avalanche so you may have to
02:27 - do a quick Google search how to connect
02:28 - the Avalanche test Network it's fine
02:30 - I've left the link to the faucet a
02:32 - faucet is a place where you can get kind
02:34 - of free ethereum so you can actually
02:36 - test out your Smart contracts so
02:38 - hopefully you guys can keep that in mind
02:39 - I apologize if the network doesn't work
02:41 - I don't have any control over that but
02:43 - I've left an alternative so hopefully
02:45 - you can kind of continue in this course
02:46 - without any issues with that said I hope
02:49 - you guys are looking forward to this all
02:50 - of the resources for all of the videos
02:52 - will be linked in the description as
02:53 - well as the link to blockchain expert
02:55 - let's get into the first video and dive
02:57 - into blockchain development
02:59 - [Music]
03:01 - hello everybody and welcome to a brand
03:04 - new and very exciting series on this
03:06 - channel on an introduction to blockchain
03:09 - development so in this series I'm going
03:11 - to be showing you how to write smart
03:13 - contracts and deploy them on the
03:15 - ethereum network and I just want to
03:17 - State before I go any further this is
03:18 - designed for complete beginners so if
03:21 - you have never written code before if
03:22 - you don't know anything about blockchain
03:24 - do not worry this is the place for you
03:26 - I'm going to be explaining absolutely
03:28 - everything and in this series we're not
03:30 - going to write any massively complicated
03:32 - smart contracts this is really meant to
03:34 - give you kind of a high speed
03:35 - introduction and just get your hands
03:37 - dirty and actually deploying and writing
03:40 - contracts anyways with that said in this
03:42 - first video here what I'm going to be
03:44 - doing is showing you how to set up
03:46 - ethereum so how to set up a wallet how
03:48 - to get some different accounts and then
03:50 - how you can get free ethereum from an
03:52 - ethereum test Network this is important
03:54 - because when we're kind of practicing we
03:56 - don't want to be spending real money and
03:58 - you do need to actually spend ethereum
04:00 - to put your smart contracts on on the
04:02 - ethereum network so I'll show you how we
04:03 - can do that for free in this video so
04:06 - I'm super excited for this series I hope
04:08 - you guys are as well and there will
04:10 - likely be more on blockchain related
04:12 - topics on this channel coming in the
04:14 - future so look forward to that now I do
04:16 - need to mention and I apologize for the
04:18 - long intro here that the reason why I'm
04:20 - able to actually create this series is
04:21 - because of a company known as cartesi
04:23 - now cartesi is the sponsor of this video
04:25 - and this series and they've actually
04:27 - been working with me behind the scenes
04:29 - to come up with the curriculum here and
04:31 - make sure that I'm getting everything
04:32 - correct as I'm relaying this information
04:34 - to you I am not a blockchain expert I am
04:37 - kind of a beginner just like you guys
04:39 - but I am good at making YouTube videos
04:41 - and tutorials and so they've been kind
04:43 - of helping me come up with the content
04:44 - in the structure and then reviewing all
04:46 - of the work just to make sure everything
04:48 - is a hundred percent accurate now
04:50 - cartesi is an amazing company they are
04:52 - dedicated to making the blockchain more
04:54 - accessible for everyone and they have a
04:56 - ton of Technology Solutions that allow
04:58 - you to develop on the blockchain for
05:00 - much cheaper now we will hear more about
05:02 - them throughout the rest of this series
05:04 - but for now I just wanted to give them a
05:06 - general introduction and a massive thank
05:08 - you for working with me and well with
05:10 - you guys I guess to make this accessible
05:12 - to everyone and allow people to get into
05:14 - this world of blockchain development
05:16 - with that said let's get into this first
05:18 - video
05:28 - all right so let's go ahead and get
05:29 - started in this first video I'm going to
05:31 - show you how to set up a metamask wallet
05:33 - this is actually an extension for Chrome
05:35 - although it's available for IOS and
05:38 - Android as well and please even if you
05:40 - have an existing ethereum wallet because
05:42 - this will be storing ethereum follow
05:44 - along with these steps because you want
05:46 - a metamask wallet so you can get access
05:47 - to free ethereum and use it with the
05:50 - different applications we're going to be
05:51 - using later in this series so go to this
05:54 - website click on download I'll leave a
05:55 - link to it in the description and click
05:57 - on Chrome and then install metamask for
06:00 - Chrome now when you do this it will
06:01 - install a Chrome extension it should pin
06:04 - this for you but if for some reason you
06:06 - don't see this in the top right hand
06:08 - corner so a little fox icon that's the
06:09 - metamask icon then click on this puzzle
06:12 - icon for extensions and just pin this
06:15 - it's just going to be helpful so click
06:16 - on the little pin and then it will make
06:18 - it so it's persistently up and I guess
06:19 - your I don't know you want to call this
06:21 - a taskbar bookmark bar whatever
06:23 - uh otherwise if you don't want to pin
06:24 - this you can just click directly on
06:26 - metamask and it will open up this page
06:28 - now for you I'm sure this is going to
06:30 - look a little bit different because you
06:32 - have not yet set up an account with
06:33 - metamask so I'm not going to walk
06:35 - through those steps because they're
06:36 - pretty intuitive but just walk through
06:37 - the basic setup steps on metamask you
06:40 - need a password make sure that's secure
06:41 - you're also going to need some secret
06:43 - words you want to make sure you save
06:45 - those somewhere you want to have access
06:47 - to them and then once you've done that
06:49 - it should prompt you to create an
06:51 - account
06:52 - so if you don't get prompted to create
06:54 - an account for some reason just click on
06:56 - this circular icon in the top right hand
06:58 - corner and click create account now you
07:01 - can have as many accounts as you would
07:03 - like within metamask you can see here I
07:05 - have two I have account one and I have
07:07 - tutorial and this will be very useful
07:09 - for us later on if we want to actually
07:11 - try testing out sending ethereum between
07:13 - different accounts great so that's kind
07:16 - of the basic setup so I have account one
07:17 - notice I have six ethereum this is
07:19 - actually fake ethereum I'm going to show
07:21 - you how to get that in a second and then
07:22 - the tutorial account where I have zero
07:24 - right there all right so at this point
07:26 - in time I'm going to imagine that you've
07:27 - gone through those setup steps you've
07:29 - figured out how to get to a page that
07:30 - looks similar to this and now I can show
07:33 - you how to get some free ethereum so the
07:35 - first thing I want to mention is that
07:36 - ethereum has a few different networks so
07:38 - if you click up here where it says for
07:40 - you it'll say ethereum mainnet but for
07:42 - me it says this gorelli test Network
07:44 - what you're going to do is select one of
07:47 - the test networks that you want to try
07:49 - out your application on now these test
07:52 - networks are kind of a mirror or a clone
07:54 - of the ethereum mainnet the mainnet is
07:57 - the main ethereum Network this is where
07:59 - real ethereum exists real smart
08:01 - contracts exist and anything on here is
08:03 - real money so you'll see this is 0.00
08:06 - USD whereas if I switch to a test
08:09 - Network there's no price because this is
08:10 - all fake ethereum it's not worth any
08:12 - money it's just for testing for
08:14 - development so you can use any test
08:16 - Network that you would like and you can
08:17 - kind of mess around with different ones
08:19 - if you want but the one that's been
08:20 - working really well for me recently is
08:22 - this go rally one now I'm probably uh
08:24 - mispronouncing this but this is the test
08:26 - that we're going to be using for right
08:27 - now and I just want to note that the
08:29 - public address of this wallet if that
08:32 - means anything to you is available right
08:34 - here so if you go copy a clipboard let's
08:36 - take this and paste this you'll see that
08:38 - we have this address this is the address
08:40 - for my ethereum well
08:43 - okay let me go back to metamask here and
08:45 - now we are back on the go rally test
08:47 - Network in my tutorial account great now
08:50 - that we've done this I'm going to show
08:51 - you how we can use a faucet to access
08:54 - free ethereum and have it sent to this
08:56 - wallet so what we can do is click on buy
08:58 - when we do this we have directly deposit
09:00 - ether or test faucet get ether from a
09:04 - faucet for the go rally now this is the
09:06 - one that we want so we're going to click
09:08 - on get ether you can do this on any of
09:10 - the test networks and it will bring you
09:11 - to a different website now this is
09:13 - bringing us to some faucet I actually
09:14 - haven't used this faucet I'm going to
09:16 - show you how we do a different one or
09:17 - use a different one but what you can do
09:19 - is just stick in your address right here
09:21 - and then request The Ether I would need
09:24 - to do the I'm not a robot thing and
09:26 - notice it's giving me an internal server
09:27 - error because sometimes these things
09:29 - just don't work they are test networks
09:31 - okay so they're going to be down
09:33 - sometimes there's going to be some
09:34 - maintenance they're not 100 reliable but
09:37 - that's fine because we're just using
09:38 - them to test so you kind of just have to
09:40 - experiment and mess around with them and
09:42 - find one that's worth working on a
09:44 - specific day kind of annoying but
09:46 - considering we get free ethereum and we
09:47 - can test it out without without having
09:49 - to pay I am not complaining okay so what
09:51 - I'm going to do is go back to metamask
09:53 - here
09:54 - and actually uh let's just copy this
09:57 - public address although I already have
09:58 - that copied and now we're going to go to
10:00 - this website right here I'll leave a
10:02 - link to this in the description now this
10:04 - website is what's known as a social
10:06 - faucet now a social faucet means that
10:08 - you need to post something on social
10:10 - media that contains your wallet address
10:12 - and then put the link to that post and
10:15 - it will then send you a theory now you
10:17 - don't need to post on some large account
10:19 - or something you can just make a brand
10:20 - new account on Twitter or Facebook I
10:22 - think those are the two available ones
10:23 - right here and in fact that's exactly
10:25 - what I did so what I did is I went to
10:27 - Twitter I have this actually really old
10:29 - Twitter account from when I was like 12
10:30 - or something oh yeah July uh 2013.
10:33 - anyways I don't use this account so I
10:34 - just signed in and then I posted this
10:36 - tweet requesting faucet funds into and
10:39 - then this address now you actually don't
10:41 - need to write anything other than the
10:43 - address of your wallet so what you'll do
10:45 - is go tweet or if you're on Facebook you
10:47 - would post something and then I'm just
10:49 - going to make a tweet that contains my
10:51 - wallet address I'm going to click tweet
10:53 - then I'm going to go here and I'm going
10:55 - to go share so I'm going to copy the
10:57 - link to the tweet
10:58 - I'm going to go here paste that link in
11:01 - and then click give me ether now we have
11:03 - a few options select whatever one you
11:05 - want I'm just going to go with six
11:06 - ethers every day
11:08 - I gotta select the chimney so let's see
11:10 - if I can pass this
11:12 - okay that looks good and it said oh I
11:15 - have a certain amount of time left until
11:17 - my next allowance uh okay looks like
11:20 - it's because I got ether recently from
11:23 - the same account and so that means that
11:26 - I have to wait but for you guys this
11:27 - should work you shouldn't have a timeout
11:29 - problem uh I already have six ethereum
11:31 - so I'll deal with using that as I need
11:33 - to as we go through the tutorial
11:35 - regardless this should work it should
11:37 - just give you ethereum and then if you
11:38 - go to metamask
11:39 - you should see in your account so let me
11:42 - swap my account here to account one that
11:44 - you have some amount of ethereum all
11:47 - right so at this point in time I'm going
11:48 - to assume you've successfully got some
11:50 - ethereum if the test Network I use
11:52 - didn't work just try another one go
11:54 - through all of them eventually one
11:56 - should probably work for you now it
11:57 - doesn't really matter which test Network
11:59 - you used but just keep track of which
12:01 - one it was because you will need to
12:02 - change some very minor steps as we go
12:04 - through the rest of the tutorial if you
12:06 - did use a different test network but
12:07 - everything will still work the general
12:08 - concepts are the same you just need to
12:10 - alter like one or two things very very
12:12 - small anyways what I want to do now is
12:14 - show you how to send ethereum which is
12:16 - really easy to do with metamask and how
12:19 - you can explore the blockchain and look
12:21 - at the addresses of wallets look at
12:23 - different transactions that have
12:24 - occurred and just show you this website
12:26 - here known as etherscan now etherscan is
12:29 - what I like to call a blockchain
12:30 - Explorer you'll notice here I'm on
12:33 - gorelli.etherscan.io so this is specific
12:36 - to the test Network that I'm using if
12:38 - you did use a different test snap work
12:39 - then you're going to want to search up
12:41 - etherscan plus the name of that test
12:43 - Network and just go to that etherskin
12:45 - obviously this one is for the test
12:47 - Network that I used so what I want to do
12:49 - is show you that we can actually view
12:51 - everything on the blockchain completely
12:53 - transparently it's one of the great
12:55 - things about the blockchain you can just
12:57 - go and look at any wall address you
12:59 - don't necessarily know who owns that
13:00 - walled address but you can see every
13:02 - single transaction that's occurred you
13:04 - can see who sent the money how much
13:05 - money is in every single account that's
13:07 - one of the great features of the
13:08 - blockchain everything is completely
13:10 - transparent so I want to show you how we
13:12 - look up our own account on etherskin
13:15 - so I'm going to go here to metamask and
13:17 - I'm just going to click on my account
13:18 - address right here and copy it to the
13:20 - clipboard now that I have that I'm just
13:22 - going to paste it in this search bar
13:23 - right here and just click search
13:26 - okay so here we go we can now see my
13:28 - wall address showing up on etherscan now
13:31 - if you guys go and paste this address in
13:33 - I don't assume you're going to type all
13:34 - of it out but let's say you did that
13:35 - into etherscan you would see the exact
13:37 - same page that I'm seeing and you could
13:39 - view all the transactions in my wallet
13:42 - so anyways here we are this is my wallet
13:44 - you can see I have six ethereum inside
13:46 - of here and I had one transaction that
13:48 - occurred eight days and three hours ago
13:50 - this is correct that's actually when I
13:53 - had the ethereum sent in when I was kind
13:55 - of preparing for this video and you can
13:57 - see it was on this block I had this
13:59 - transaction hash and then I have the
14:01 - from address and the to address so the
14:03 - two address is my wallet address right
14:05 - here but if I want to see where this
14:07 - ethereum came from which was the faucet
14:09 - I can click on this so when I click here
14:11 - notice this has an absurd amount of
14:13 - ethereum 515
14:15 - 000 ethereum right that's quite a bit
14:16 - and you can go and look at all of the
14:18 - different transactions that it sent and
14:20 - how frequently it's sending them so you
14:22 - can see how many people are requesting
14:23 - ethereum from this faucet anyways let's
14:26 - go back
14:27 - and let's actually click on this
14:29 - transaction hash that's what txn hash is
14:32 - so let's do that and let's just look at
14:34 - some details that we have here now
14:35 - notice it's telling us this is only from
14:37 - this test Network okay it gives us the
14:40 - hash of the transaction which we'll
14:41 - discuss later on we have the status this
14:44 - was successful you could have a status
14:45 - of pending meaning it's not yet been
14:47 - sent through then we have the block that
14:49 - this was attached to we can actually
14:51 - click directly into the block and view
14:53 - everything that was associated with this
14:55 - block as well we can see the miner that
14:57 - mined it too which is interesting then
14:59 - we can go and look at the from address
15:01 - the to address the value of the ethereum
15:03 - the transaction fee the gas price and a
15:06 - bunch of other stuff now this is really
15:08 - not going to mean anything to you right
15:10 - now but I just wanted to show you that
15:11 - you can do this you can look at all of
15:13 - the details of the blockchain completely
15:16 - for free transparently and anyone can do
15:19 - this there's not one person who has
15:20 - access You Can't Hide Your transactions
15:22 - from one person everything is completely
15:24 - publicly available all right so now that
15:27 - we've looked at that I'm just going to
15:28 - quickly show you how you could send
15:29 - ethereum now you only can send ethereum
15:32 - between the same test networks so I
15:34 - can't send this ethereum to a different
15:36 - test Network or to the main ethereum
15:38 - Network obviously that's not going to
15:39 - work but what I'm going to do here is
15:41 - just look at my other account so you'll
15:43 - notice that if I go here I have my
15:46 - tutorial account and then I have my
15:47 - account one so let's say I want to send
15:49 - I don't know one ethereum to this
15:51 - tutorial account well I'm just going to
15:53 - copy the address here notice I'm on this
15:55 - test Network
15:56 - going to go back to account one I'm just
15:58 - going to click on send in metamask I'm
16:00 - going to paste in this public address
16:02 - I'll go with one ethereum I will click
16:05 - next and I can confirm this it's going
16:08 - to tell me how much this will cost I
16:09 - have to pay a very small gas fee I will
16:12 - click confirm and now it is sending the
16:14 - transaction you can see it says pending
16:16 - if I click on it here it gives me the
16:18 - details and this is very similar to what
16:21 - I had on etherscan now let's see if we
16:23 - can find the hash of this transaction uh
16:26 - copy address copy address no let's go
16:29 - copy transaction ID okay so I'm going to
16:31 - copy that let's go to etherscan here and
16:34 - paste this in and let's see if we can
16:35 - view the transaction and there we go we
16:38 - can view it and notice if we go to the
16:39 - from address this is my address that now
16:42 - has less ethereum in it than it did
16:44 - before because I am attempting to send
16:46 - money now it is not showing me the
16:47 - pending transaction because the
16:49 - transaction is currently pending it is
16:50 - not finished but you get the point this
16:53 - is all working and well we can view all
16:55 - of the transaction details all right so
16:57 - I just took a quick cut and you can see
16:58 - that the transaction has now actually
17:00 - gone through so I have a status success
17:02 - the page actually updated live when I
17:04 - was on it so that's how I knew this and
17:06 - if I go back to the from address you can
17:08 - see this transaction is now here uh and
17:11 - sorry it's right here actually because
17:12 - it's more recent and it's saying we sent
17:14 - one ethereum out from this address to
17:16 - the other dress and if we go here we can
17:18 - see we have one ether and then of course
17:20 - if we go back to metamask and let's go
17:23 - to this other account so let's go to
17:25 - account number one or tutorial we have
17:29 - one ethereum so anyways with this
17:31 - transaction now being completed I'm
17:33 - actually going to end the video here I
17:35 - just wanted to give you a brief
17:36 - introduction to how we actually set up
17:38 - ethereum accounts how we can send money
17:40 - between different accounts the test
17:41 - networks and the faucets and then of
17:43 - course ether scan so how you can
17:45 - actually view different transactions
17:46 - view wallets and see what's going on on
17:49 - the blockchain a lot of this will start
17:50 - to make more sense in the next video
17:52 - where I actually go through a deep
17:54 - explanation of how blockchain technology
17:56 - Works how the network is secure how
17:59 - transactions are sent etc etc anyways I
18:02 - am going to wrap up the video here I
18:04 - hope you guys enjoyed one last massive
18:06 - thank you to cartesi for sponsoring this
18:08 - video and helping with the content we'll
18:10 - hear more from them in future videos I
18:13 - hope you guys are sticking around make
18:14 - sure you subscribe to the channel and I
18:16 - will see you in the next one
18:17 - [Music]
18:20 - hello everybody and welcome to part two
18:22 - of this video series in this part I'm
18:25 - going to be explaining to you the theory
18:27 - behind blockchain technology so
18:29 - specifically going through some key
18:31 - terms like private Keys public Keys
18:33 - cryptographic hash functions what those
18:35 - are how those work I will talk about
18:37 - transactions how a transaction is
18:39 - created and signed and secured I will
18:42 - talk to you about blocks how blocks are
18:44 - connected together I will then start
18:46 - talking about proof of work which
18:48 - involves minors and securing the
18:50 - blockchain and while all of this is very
18:52 - very interesting and I try my best to
18:54 - break it down as simply as possible for
18:56 - you in this video so in a second we're
18:59 - going to hop over to the drawing tablet
19:00 - I'm just going to start doing some
19:02 - diagramming and explaining and I
19:03 - encourage you to sit back relax and
19:05 - enjoy the explanation however before we
19:07 - do that I quickly need to thank the
19:09 - sponsor of this video and this series
19:11 - which is cartesi now cartesi is a
19:13 - company that is dedicated to making the
19:15 - blockchain more accessible and
19:16 - affordable and when I say affordable the
19:18 - reason that's important is because as
19:20 - you're going to see as we go through the
19:22 - rest of these videos here deploying
19:24 - smart contracts is very very expensive
19:26 - now cartesia offers a bunch of solutions
19:28 - that can actually cut this cost by a
19:30 - factor of almost a hundred and really
19:32 - just make it much easier to work on the
19:35 - blockchain anyways we'll hear more from
19:37 - them later on and we'll actually start
19:38 - using some cartesi technology hopefully
19:40 - in a future series but regardless they
19:43 - are an awesome company they've been
19:44 - helping me come up with the content for
19:46 - this video and I'm just super grateful
19:48 - and happy to be working with them
19:49 - regardless let's dive into the video
19:56 - foreign
20:02 - ignore the black screen there will be
20:04 - some drawing in one second but for now
20:06 - I'm gonna start by explaining to you
20:08 - some key terminology related to
20:10 - cryptocurrency specifically private key
20:13 - public key and address so let's actually
20:15 - start by looking at what's knows a
20:17 - cryptographic hash function because it's
20:19 - very important to understand this
20:20 - concept so we have a function let's say
20:23 - f of x and this is equal to Y this means
20:26 - you take some input X you get some
20:28 - output y pretty standard now with most
20:31 - regular functions you can compute what's
20:32 - known as the inverse now the inverse of
20:34 - f is known as F inverse and then you
20:36 - would take Y and this will give you X so
20:39 - the idea here is that given some output
20:42 - and given the function that computed
20:44 - that output tell me what the input to
20:46 - that function would need to be to get
20:48 - that output so the inverse is like this
20:50 - you take the output you pass that to the
20:52 - inverse function and it gives you the
20:54 - input required to pass to the original
20:55 - function to get that output so let's
20:57 - just look at one concrete example let's
21:00 - say we have something like Y is equal to
21:03 - X Plus 2. well if 2 is my input then Y
21:07 - is 4. now compute the inverse of this
21:09 - function the inverse of this function
21:11 - you simply compute by isolating X so you
21:14 - just say y minus 2 is equal to X that's
21:17 - the inverse and so if I give you the
21:19 - value 4 You Can Tell Me 2 was used to
21:21 - compute that great so now that we
21:23 - understand what the inverse is the first
21:25 - property of a cryptographic hash
21:27 - function is that it has no inverse so
21:30 - we're going to call this now
21:32 - the hash function so let's do hash func
21:35 - this is going to be our input and this
21:38 - is going to be our hash otherwise known
21:40 - as a digest okay you don't really need
21:42 - to know that but hash is what I'm
21:45 - probably going to be referring to this
21:46 - as as we go through this video so the
21:48 - first factor or the first property of a
21:51 - cryptographic hash function is that it
21:53 - has no inverse now what that really
21:54 - means is that given y you cannot find X
21:57 - so if you're given the function and the
21:59 - output of the function there's no way to
22:01 - figure out what the input is that's very
22:03 - very important so to clarify here when I
22:05 - say we can't find the inverse of a
22:07 - cryptographic hash that's not
22:09 - necessarily true now it's important to
22:11 - note that here I'm not talking about the
22:13 - cryptographic hash function I'm talking
22:15 - about the actual hash itself that was
22:17 - the output of this function So currently
22:20 - there's no efficient way or formula that
22:22 - we know that we can use to take an
22:25 - individual hash and determine its
22:27 - inverse however it may be possible to
22:29 - invert a hash using a Brute Force
22:31 - approach where you would blindly guess
22:33 - and try several different values until
22:36 - you determine what the original input
22:37 - value was that generated this hash now
22:40 - this Brute Force approach would take
22:42 - billions of years to perform and that's
22:44 - why we say a cryptographic hash has no
22:46 - inverse because it would take an
22:48 - extremely long and unfeasible amount of
22:50 - time to compute it so yes theoretically
22:53 - it may be possible to compute the
22:55 - inverse of an individual hash but it
22:57 - would take such a long time that we just
22:59 - simplify things by saying it has no
23:01 - inverse so moving on the next property
23:03 - of a cryptographic hash function is that
23:05 - it is deterministic that means that any
23:08 - input X1 always leads to one output y1
23:11 - so second property deterministic again
23:14 - meaning that one input always points to
23:16 - the exact same output next property is
23:19 - that every output is unique so if I pass
23:21 - X1 I get y1 nothing else points to y1 so
23:24 - if I have X2 it's not possible for me to
23:27 - get the same y1 as soon as I have
23:29 - something like X2 and they both point to
23:31 - the same output this is no longer a
23:33 - cryptographic hash function so again I
23:35 - need to add a small clarification here
23:37 - theoretically it is possible to have two
23:40 - inputs mapped to the same output using a
23:42 - hash function now when that happens this
23:44 - is known as a collision now the thing
23:46 - with cryptographic hash functions is
23:48 - that for that to happen for you to find
23:50 - a collision just like finding the
23:52 - inverse that would take you say billions
23:53 - of years a very very long time to do so
23:56 - we can kind of operate on the assumption
23:58 - that there will be no collisions but
24:00 - theoretically if we're talking about the
24:02 - exact definition there could be so I'm
24:04 - going to kind of be speaking in this
24:05 - video in definitives just understand
24:07 - there is some Nuance behind those but
24:09 - it's just much easier to operate under
24:11 - these assumptions and well hopefully
24:13 - that makes sense
24:14 - okay so those are the first three
24:16 - properties of this function the next is
24:18 - that the hash that you get is
24:19 - uncorrelated to the input so what this
24:22 - means is that if I have something like f
24:23 - of 1 1 maybe this gives me a hash of a b
24:27 - c 2 3. now you might be trying to guess
24:30 - here that if I had a hash of 1 2 that it
24:33 - would give me something similar to this
24:34 - maybe you would think we get a b c 2 4
24:37 - or something along those lines because
24:39 - you would imagine that the output here
24:41 - is correlated to the input but with a
24:43 - cryptographic hash function this is not
24:44 - the case if I were to pass one two so
24:46 - just one number is different I get a
24:48 - completely different hash
24:50 - so I might get something like d f a two
24:53 - nine four or seven or whatever you know
24:56 - what I mean we just get a completely
24:57 - different hash there's no way to
24:59 - reasonably guess what the hash is going
25:01 - to be by looking at the input all right
25:03 - so that is great the very last property
25:06 - is that this is quick to compute so
25:07 - Computing the hash of some input is very
25:10 - very fast those are the five properties
25:12 - of a cryptographic hash function okay so
25:15 - moving forward we're now going to talk
25:16 - about private Keys public keys and
25:19 - addresses
25:20 - so let's start with our private key
25:23 - now the private key I like to think of
25:26 - as the master password for our ethereum
25:29 - account so the private key is actually
25:31 - what allows us to access our account and
25:34 - to send money so if you have access to a
25:36 - private key you have access to an
25:38 - ethereum account and while you can send
25:40 - money on that account that means you
25:42 - need to keep this private you do not
25:44 - want to share this with anyone and in
25:46 - fact we don't even look at what our
25:47 - private key is when we use metamask it's
25:49 - generated for us and stored in an
25:52 - encrypted fashion in kind of the back
25:54 - end of metamask so that no one can
25:56 - actually see it now when I say encrypted
25:58 - this is actually one of the reasons why
26:00 - we need to pass a password when we
26:02 - created our metamask account so what
26:04 - happens in metamask is it will generate
26:06 - a private key for us but it won't store
26:08 - it in plain text so if the private key
26:10 - was one two three it will never store
26:13 - one two three instead it will store
26:15 - what's known as an encryption or an
26:17 - encrypted version of this private key
26:19 - and it will encrypt it using our
26:21 - password so we have some special
26:22 - function that's going to you take in our
26:25 - private key and our password and then it
26:26 - will give us some output okay
26:29 - and then the only way to go from this
26:31 - output back to what this private key is
26:33 - is to know what the password is okay so
26:35 - we need to use the password every time
26:37 - we sign in so that we can decrypt our
26:39 - private key so that we can then use the
26:41 - private key to actually send
26:42 - transactions okay that is the private
26:44 - key and what the private key actually is
26:46 - is just a string of characters that's
26:48 - really all it is it's extremely long and
26:51 - again you usually are not going to be
26:52 - looking at this yourself it's going to
26:53 - be stored in some secure way so next
26:56 - from our private key we generate what's
26:58 - known as a public key now the public key
27:01 - is generated from the private key so you
27:04 - need the private key to get to the
27:06 - public key and we use a cryptographic
27:08 - hash function to generate this which
27:10 - means if you know the public key there
27:12 - is no way to go back to the private key
27:14 - you cannot do that because the way we
27:16 - generate it was using a cryptographic
27:18 - hash function that's very important
27:20 - because someone could theoretically
27:21 - figure out your public key if they do
27:24 - figure out what that is that doesn't
27:25 - matter there's no way for them to go to
27:27 - the private key hence why this is
27:28 - private and this is public the public
27:29 - one can be shared anywhere okay moving
27:32 - forward the next thing we have is our
27:34 - address now the address is generated
27:37 - from the public key so a private key in
27:39 - a public key actually make up an
27:40 - ethereum account and then the address is
27:43 - what you're going to actually send money
27:44 - to now what the address is is actually a
27:47 - few characters when I say a few it's
27:49 - something like 20 characters of the hash
27:51 - of this public key that's pretty much
27:53 - all I will say it's kind of just a
27:54 - simplified version of the public key and
27:57 - the way you get the address is you
27:58 - generate it from the public key so you
28:00 - go private key public Key address and
28:02 - from the public key again you cannot get
28:04 - back to the private key from the address
28:05 - you cannot get back to the private key
28:07 - and that's very important because as
28:09 - soon as you have the private key you
28:10 - have access to the ethereum account so
28:12 - you give the address to whoever you want
28:14 - to send money to you and that is how you
28:16 - will reference your account on the
28:18 - ethereum network by this address great
28:21 - so the whole point of the address as I
28:23 - was saying is it just a simplified
28:24 - version of the public key so it's a
28:26 - little bit easier to be using on the
28:28 - blockchain rather than writing the
28:29 - public key everywhere so now that we
28:31 - have understand private key public key
28:33 - and address we need to talk about
28:34 - transactions and then how the blockchain
28:36 - actually handles transactions so let's
28:39 - say we have the example where we have
28:40 - maybe a count one
28:42 - and a count two and account one wants to
28:45 - send some ethereum maybe 0.1 F to
28:47 - account two how do we do this well to do
28:50 - this we need a transaction now anyone
28:52 - can create transactions on the
28:55 - blockchain anyone can do it and what's
28:56 - involved in a transaction is an amount
29:00 - so it's going to be 0.1 F we're going to
29:02 - have a 2 wallet so what address we're
29:05 - going to so we're going to be going to
29:06 - account to and then from
29:09 - is going to be account one now the only
29:11 - problem right now with this transaction
29:13 - is that we kind of have to trust that
29:15 - who's making this transaction is the
29:17 - person who's sending the money right the
29:19 - from address but
29:21 - theoretically account 2 could make this
29:25 - transaction and say oh yeah account one
29:27 - is sending me all of its ethereum anyone
29:29 - could just make a transaction and you
29:31 - could add as many as you want and you
29:32 - could just throw them on the blockchain
29:33 - and well if there was no security then
29:35 - you would just have random people adding
29:37 - transactions all of the time that is why
29:40 - we have something known as a digital
29:42 - signature
29:43 - so a digital signature is a very special
29:46 - hash that involves the actual private
29:49 - key of the account trying to send the
29:51 - money so of the from account as well as
29:54 - all the information associated with the
29:56 - transaction now I won't talk too much
29:57 - about the signature because it's pretty
29:59 - mathematically complicated but to be
30:01 - able to actually create a transaction
30:03 - that is valid what you need is the
30:05 - private key of the account you're trying
30:07 - to send ethereum from so this signature
30:10 - here again as I was saying is going to
30:11 - require the private key as well as the
30:16 - transaction itself so the transaction
30:17 - I'm just going to represent by TX and
30:19 - then there's actually another part of
30:21 - this as well and anyways you hash all of
30:23 - this it gives you some you know random
30:25 - uh string of characters and this string
30:27 - of characters you can verify is a
30:29 - correct
30:30 - um signature for this transaction now
30:32 - the way that you actually verify the
30:34 - signature is simply by using the public
30:36 - key of the account that's sending this
30:38 - ethereum so if we see a transaction
30:40 - that's coming from account number one we
30:42 - don't need to know what count number
30:43 - one's private key to determine that the
30:46 - signature is about we can just use their
30:48 - public key and a special kind of
30:50 - mathematical computation to determine
30:52 - that this signature is valid and that it
30:54 - was actually signed by the account
30:56 - that's sending the ethereum because
30:57 - again you can only send this ethereum if
31:00 - you have access to the private key of
31:02 - the account that's supposed to be
31:03 - sending the ethereum so just know for
31:05 - now that you can verify a signature very
31:08 - easily without knowing the private key
31:10 - of the account you just use a certain
31:12 - aspect of the public key I'm not going
31:14 - to go into too much more detail but that
31:15 - is how you verify a signature so anyways
31:18 - that is how you actually secure a
31:19 - transaction you digitally sign it using
31:21 - your private key and a few other things
31:23 - we don't have to manually do that
31:25 - ourselves it's done by metamask when we
31:27 - actually send a transaction okay so
31:29 - let's remove all this and now let's see
31:31 - how we actually associate a transaction
31:33 - with a block and how we actually you
31:36 - know use the blockchain and put a
31:37 - transaction on the blockchain because
31:39 - right now we made this transaction
31:40 - that's fine but we need to send it on
31:43 - the blockchain we need to attach it to a
31:44 - block before it's actually going to go
31:46 - through before our money gets sent to
31:48 - the other person
31:49 - so let's look at what a blockchain is
31:51 - let's say we have one block like this
31:54 - another block like this and a third
31:56 - block like this now all of these blocks
31:58 - are connected together in a chain now
32:00 - they would be of equal size I've
32:02 - obviously drawn mine a little wonky here
32:04 - but all of these blocks contain some
32:06 - information on them as well as all of
32:08 - the transactions and smart contracts
32:10 - that were added to them at the current
32:12 - point in time so what this blockchain
32:15 - actually does is it represents a digital
32:18 - Ledger of the entire history of the
32:20 - ethereum network when we're talking
32:21 - about ethereum here right so every
32:24 - single transaction is a transaction that
32:26 - has taken place and we know the order in
32:28 - which they took place because they're
32:29 - ordered on the Block and then all of
32:31 - these blocks are ordered and this is
32:32 - very similar to something like a ledger
32:34 - that you would have at a bank so a bank
32:36 - would keep track of every single
32:37 - transaction you had sent and everyone
32:39 - else had sent it would know all of that
32:41 - information well same thing here with
32:42 - the blockchain we just do it in a
32:43 - different way now one of the Key
32:45 - properties of the blockchain is that it
32:47 - is decentralized this means it is not
32:50 - controlled by a bank is not controlled
32:51 - by a single person it is controlled by a
32:53 - network of computers that are owned
32:55 - privately by random people around the
32:57 - internet and the reason why this is
32:59 - important is because as soon as
33:00 - something is owned centrally so by one
33:02 - person or one organization or one entity
33:04 - they have the ability and the power to
33:07 - do something with it that is corrupt or
33:09 - that is malicious or that anyone else
33:12 - just doesn't have the ability to do or
33:13 - that they shouldn't maybe have the
33:15 - ability to for example if you own a bank
33:17 - account the likelihood this is going to
33:19 - happen is very slim but theoretically
33:20 - the government could just force the bank
33:22 - to hand over all of your funds maybe you
33:24 - need to pay your taxes or something
33:25 - whatever the idea is there's a central
33:27 - organization that controls this and so
33:29 - at any point in time this Central
33:31 - Authority could go in and actually
33:33 - modify what's on The Ledger they could
33:35 - change the account balance they could
33:37 - take money from you but here when we're
33:39 - talking about a blockchain that is
33:41 - actually not possible because this is
33:43 - not owned by one person or one entity it
33:45 - is used and controlled by all of the
33:48 - computers around the world that
33:49 - contribute to the network and we'll talk
33:51 - about what those are in a second but to
33:53 - be able to do anything malicious on the
33:54 - blockchain you would have to control
33:56 - almost all of the computers around the
33:58 - world that are storing a copy of the
34:00 - blockchain and that are on the
34:01 - blockchain network
34:03 - okay hopefully this makes a tiny bit of
34:04 - sense but let's have a look at one
34:06 - individual block kind of see how that
34:08 - works in the context of transactions and
34:10 - then we'll talk about proof of work and
34:12 - a bunch of other very important aspects
34:13 - of the security of the blockchain so
34:16 - let's say we have a single block okay
34:18 - we can just call this something like
34:21 - block number two okay now the reason why
34:25 - I'm naming it number two and not number
34:26 - one is because the first block in a
34:28 - blockchain is a special block contains
34:30 - some configuration and initialization
34:32 - related stuff because well it's the very
34:33 - first block so that's kind of a special
34:35 - one we're going to ignore block one for
34:37 - now and just move straight to block two
34:39 - now block two is going to contain some
34:41 - transactions on it the transactions I'm
34:44 - going to represent by these squiggly
34:45 - lines now these transactions are exactly
34:47 - what I showed you before they have a to
34:49 - address a from address an amount a
34:51 - signature and they have a few other
34:52 - things as well in fact every time you
34:54 - send a transaction you usually have to
34:56 - pay a very small fee and this fee will
34:59 - be given to the miners that are trying
35:00 - to secure and validate a block
35:03 - anyways this block has some transactions
35:05 - on
35:06 - now this is where we get into the
35:07 - concept of miners so miners are
35:10 - computers that are sitting around the
35:12 - world that are supporting the ethereum
35:13 - network they're actually what allow it
35:15 - to run and they're what secure the
35:17 - blocks and make sure that you can't just
35:19 - hack the network okay so we'll dive into
35:21 - miners in a second I just want to take a
35:23 - quick step back here so whenever you're
35:25 - sending a transaction you need this
35:26 - transaction to be associated with a
35:28 - block and this block has to be mined
35:31 - which we'll discuss in a minute before
35:32 - your transaction actually goes through
35:34 - and is completely successful up until
35:37 - that point your transaction will be
35:39 - pending but once it's been added to a
35:41 - block and that block has been mined then
35:42 - it is successful now a new block is
35:45 - added to the ethereum network
35:46 - approximately every 15 seconds so very
35:49 - very quickly anyways now let's talk
35:51 - about mining so what are monitors well
35:54 - as I discussed miners are just computers
35:56 - that are sitting around the world this
35:57 - is going to be my computer just a bunch
35:59 - of kind of deformed squares here right
36:01 - so there's a bunch of these guys sitting
36:02 - all around the world connected to the
36:05 - ethereum blockchain now every single
36:07 - time a new block is created and all the
36:09 - transactions are added it gets sent to
36:11 - every single Miner so all these miners
36:13 - are kind of nodes on the network they're
36:15 - all sitting there waiting for
36:16 - transactions to get added to the current
36:18 - block
36:19 - when this happens what these miners do
36:21 - is try to mine the block now mining the
36:23 - block consists of Performing some
36:25 - computations particularly some very
36:27 - difficult computations that are very
36:29 - time consuming and trying to guess a
36:31 - number that makes the hash of a block
36:33 - which we're going to get to in a minute
36:35 - have some specific properties now the
36:38 - point of doing this for these miners is
36:40 - that if they are able to guess a
36:41 - specific number they successfully mine
36:43 - the block and they will be given a
36:45 - reward so let's say minor one actually
36:47 - guesses what the number is I'll discuss
36:49 - what that number is in a second and they
36:50 - will be given some reward now this
36:52 - reward will be made up of two things the
36:54 - first thing it will be made up of is a
36:56 - block reward now a block reward is a
36:59 - reward that is hard coded into the
37:01 - ethereum network and actually decreases
37:03 - over time and this is new ethereum that
37:05 - will be created and given to the miner
37:07 - as a reward for mining this block I'm
37:09 - not sure what the current block reward
37:11 - is right now it's probably something
37:12 - like one ethereum but the point is that
37:14 - this is new ethereum that then gets
37:15 - added to the ecosystem and is
37:16 - circulating around so yes some
37:18 - cryptocurrency season here specifically
37:20 - ethereum do have an inflationary aspect
37:22 - to them because new currency is being
37:24 - created but it's not something you
37:26 - really need to be worried about and
37:27 - while there's a whole field of
37:28 - cryptocurrency called tokenomics that
37:30 - kind of discusses this and why this is
37:32 - maybe actually a good thing I'm not
37:34 - really going to get into this in this
37:35 - video point being don't be too worried
37:37 - about the fact that new ethereum is
37:39 - being created so the second thing that
37:40 - you're going to have is going to be your
37:42 - fees now every time you send a
37:44 - transaction you're going to pay a very
37:45 - small fee this fee goes to the miners
37:48 - that are mining the block and so the
37:50 - successful Miner the minor actually
37:52 - guesses the number that mines the block
37:53 - is going to get the block reward and any
37:56 - fees associated with all the
37:57 - transactions on the Block okay hopefully
37:59 - that makes sense I'm just trying to
38:00 - explain the incentive structure here for
38:02 - people to actually mine so continuing
38:05 - now we need to talk about what the
38:06 - miners are actually doing what the
38:08 - miners are doing are trying to guess a
38:10 - number that gets added at the end of the
38:13 - block so I'm going to say num equals
38:15 - question mark that makes the hash of
38:18 - this block equal to a certain number
38:21 - so what they're trying to do here is
38:22 - they are trying to find some number that
38:25 - they can add as kind of a dummy
38:27 - transaction at the very end of the block
38:29 - so that when I take a hash of this
38:32 - entire block so I run this to a
38:33 - cryptographic hash function the hash
38:35 - that I get starts with a certain number
38:38 - of zeros I believe right now what
38:39 - they're trying to find is a number that
38:41 - starts with 30 zeros but it could be
38:43 - actually higher lower I'm not sure what
38:45 - the exact number is the point is that
38:47 - what these miners are going to be doing
38:48 - is trying to guess some number right
38:50 - this is a random number that you add at
38:52 - the end of the block and then when you
38:54 - hash the entire block so all of the
38:56 - transactions associated with the block
38:58 - and the number together it gives you
39:00 - some hash some digest right that has 30
39:04 - numbers at the beginning or 30 zeros at
39:06 - the beginning sorry and then the rest of
39:07 - it doesn't really matter what that is
39:08 - but you're just trying to find something
39:09 - that has a certain number of leading
39:12 - zeros so the point of this is that the
39:13 - more zeros that you have in that number
39:15 - you're trying to guess the harder it is
39:17 - to Guess that number because the
39:18 - probability just decreases that you're
39:20 - going to guess the correct number right
39:22 - here and again I'm just really trying to
39:23 - reiterate here that what's going to
39:25 - happen is you're going to take a hash of
39:27 - all of this everything inside of the
39:28 - block including this number and then you
39:31 - want it to give you some number that
39:33 - starts with 30 zeros but the thing is
39:35 - there's no way to figure out what this
39:37 - number is other than just guessing and
39:39 - checking because the cryptographic hash
39:41 - function has that property that there's
39:42 - no known inverse so since we can't
39:44 - compute the inverse we have no better
39:46 - way of finding out what this number is
39:48 - other than guessing and checking and so
39:50 - these miners are just guessing and
39:51 - checking as quickly as they possibly can
39:53 - and the one that gets the correct number
39:55 - then adds that to the block that mines
39:57 - the block and then we create a new block
39:58 - and continue moving forward now this is
40:01 - an oversimplification but that's the
40:03 - general idea of what these miners are
40:04 - doing
40:05 - okay so hopefully that kind of makes
40:07 - sense uh but that is what these miners
40:09 - are attempting to do and you might be
40:10 - wondering well there's so many minors so
40:12 - is it only actually one minor that's
40:14 - guessing this number and the answer is
40:16 - yes at every single block you're only
40:18 - having one Miner that is going to guess
40:20 - what the correct number is and get the
40:22 - reward that's why you'll have pool
40:23 - mining which means you'll have like
40:25 - hundreds of thousands of computers that
40:27 - will split their processing power
40:29 - they'll say okay we're all going to try
40:30 - to guess a number together and if any of
40:32 - us get the number we're going to split
40:34 - the rewards between everyone because the
40:36 - probability that one of us can guess the
40:38 - number consistently is very very low in
40:40 - fact if you only had one computer Mining
40:42 - and it was not mining very quickly your
40:44 - probability of ever getting a blocked
40:45 - reward would be almost zero because
40:47 - there's just so many other computers
40:48 - doing it and you'd have to get extremely
40:50 - extremely lucky so that's why you would
40:52 - mine with a bunch of other people so
40:53 - that your probability of getting a
40:55 - reward is much higher and then you would
40:56 - split that based on how much work all of
40:58 - you have done
40:59 - okay so let's continue here now what I
41:02 - want to do is draw a few blocks and
41:04 - we'll see how these are connected and
41:06 - kind of the security aspect of this so
41:08 - let's just paste this block over here
41:10 - and for now we can just go with two
41:12 - blocks okay so we have block two and
41:15 - then this guy is going to have to be
41:17 - block three let's fix your corner right
41:20 - there okay so we have block two and we
41:23 - have block three now this will be coming
41:25 - from block one we don't need to worry
41:26 - about that right now now the thing is
41:28 - these blocks are connected together
41:29 - right so we have block three we have
41:31 - block two block three is connected to
41:33 - block two and obviously it comes after
41:35 - block two now how do we know that well
41:38 - obviously these arrows aren't actually
41:39 - there we don't really have arrows
41:41 - connecting these things but what we do
41:42 - have is a field in every single block
41:44 - that represents the hash of the last
41:47 - block so we have something like last is
41:49 - equal to and then whatever the hash of
41:51 - this block is including the number that
41:53 - we guessed that is what we put right
41:56 - here to represent this is the last block
41:57 - in the chain so let's say when we hash
42:00 - all of this we get a number that is zero
42:02 - zero zero zero four nine a b now this
42:06 - will usually be a hexadecimal number
42:08 - that is 64 characters long but for
42:10 - Simplicity we'll just go with this for
42:12 - now so to get this hash we would also
42:14 - have guessed this number let's just say
42:15 - it's 7 and what we were trying to do was
42:18 - to get a hash that started with four
42:19 - zeros which we've done so next what
42:21 - we'll do is we'll write this hash here
42:23 - so zero zero zero zero four nine a b
42:27 - so now in block three we know the
42:30 - previous block was block two and block 2
42:31 - would also have this field it would say
42:33 - last equal to the hash of whatever block
42:35 - 1 is so now block three we get a bunch
42:37 - of transactions on here we add them all
42:39 - on and we say okay we want to mine block
42:41 - three so what we need to do now when we
42:43 - mind block three is we have to find some
42:45 - number such that when we hash all of
42:47 - this including this last field right
42:49 - that's going to be included in the block
42:50 - where we're hashing we get a number this
42:53 - starts with four zeros so what this
42:55 - really means here is that if the hash of
42:57 - block 2 ever changes for some reason
42:59 - then this is no longer going to be
43:01 - correct because this is going to be
43:03 - referencing block 2 which now no longer
43:05 - exists and so this will be disconnected
43:07 - from the blockchain you can kind of
43:08 - imagine that this Arrow would get erased
43:11 - now I'll continue explaining this but
43:12 - again what we're doing is we're trying
43:14 - to mine block three so we'll guess some
43:15 - number let's say we guess some number
43:17 - nine and then we end up getting some
43:19 - hash here I guess I can just do it in
43:20 - maybe a purple color zero zero zero and
43:23 - then maybe this is 7
43:25 - 9ba okay this is the hash that we end up
43:28 - get so now where the real security
43:30 - feature of the blockchain comes in is
43:32 - that let's say I am a malicious entity
43:34 - here and I want to change one of the
43:36 - transactions on the blockchain so let's
43:38 - say I take my copy of the blockchain and
43:40 - I go to block 2 and I change the
43:43 - transaction instead I add this
43:45 - fraudulent transaction right here well
43:47 - as soon as I change this transaction
43:49 - this hash here
43:51 - changes right and the reason this is
43:53 - going to change is because when I take
43:55 - the hash of this block now since this
43:57 - transaction has changed I get something
43:59 - completely different and so what I'm
44:00 - probably going to end up getting here is
44:02 - something that doesn't start with four
44:03 - zeros so say maybe I get one zero two a
44:07 - b b c 1 that's my hash so now since this
44:10 - hash doesn't start with four zeros I
44:12 - need to recompute this number and remind
44:14 - this entire block because now the number
44:17 - seven is no longer correct to give me a
44:20 - hash that starts with four zeros so
44:22 - let's say I'm successful in doing that
44:23 - and I guess uh you know the number let's
44:25 - go 275 or something and now I get a hash
44:28 - like zero zero zero zero one two three
44:31 - four okay that's my new hash well now
44:34 - the problem is this hash
44:36 - does not match this hash right here and
44:39 - so this block is disconnected from this
44:41 - block and so if I want to actually keep
44:43 - this fraudulent transaction in Block 2
44:45 - what I need to do now is modify block 3
44:47 - because I have to change this last to
44:50 - match what my new last on block 2 is so
44:53 - what I do now is I come here and I would
44:56 - need to change this now to whatever this
44:58 - is so zero zero zero zero one two three
45:01 - four but now that I've changed this the
45:04 - hash here is going to be completely
45:05 - different
45:06 - right because we're going to get a
45:07 - different value when we have something
45:08 - different inside of the block so now I
45:10 - get a hash maybe that doesn't start with
45:12 - zeros right one zero zero two three a b
45:15 - c whatever some random hash so now I
45:18 - need to recompute this block recompute
45:20 - this random number and remind it so that
45:22 - I now find a hash that starts with four
45:24 - zeros and you get the point I have to do
45:26 - that for every single block in the
45:27 - blockchain right because these blocks
45:30 - are connected together and as soon as
45:31 - these blocks are no longer connected I
45:33 - don't have a valid blockchain and if I
45:35 - try to send this on the ethereum network
45:37 - all of the other computers on the
45:39 - network are going to be like uh no that
45:41 - is not correct your blocks are not
45:42 - connected your hashes are all messed up
45:44 - and I have a different version than you
45:46 - have so no I'm not going to accept that
45:47 - as a transaction I'm not going to accept
45:49 - that as a block because that is
45:50 - fraudulent so hopefully this makes a bit
45:53 - of sense but this is a concept known of
45:54 - hashes of hashes or hashing of hashes
45:57 - and so what we're doing is we're taking
45:59 - a hash of this block putting it inside
46:01 - of here and then taking a hash of this
46:03 - block that contains the hash of the
46:05 - previous block and so any change to the
46:07 - previous block means that this will no
46:09 - longer be valid and so we have to change
46:11 - pretty well every single block in the
46:13 - blockchain to be able to modify
46:14 - everything and that is why this is so
46:16 - secure and that is what leads me to the
46:18 - concept of proof of work
46:21 - so what we're doing when we're mining is
46:23 - we are proving that we have spent a
46:25 - certain amount of time before adding
46:27 - this block to the blockchain and the
46:29 - reason that's important is because the
46:31 - more time we spend the harder it is to
46:33 - modify the blockchain if you had an
46:35 - absolute supercomputer and you could
46:37 - just remind these blocks instantly then
46:40 - you would be able to go and change the
46:41 - blockchain that would be fine you could
46:43 - do that because you could just
46:44 - regenerate every single block with all
46:46 - of your fraudulent transactions added
46:48 - however since that's pretty well
46:50 - impossible and we have so many computers
46:53 - working on the blockchain at the exact
46:54 - same time for you to be able to do that
46:57 - you would need more computing power than
46:59 - all of the other computers on the
47:01 - blockchain combined and you would need
47:02 - to be able to not only rewrite the
47:05 - entire blockchain previously to what
47:07 - it's currently at you would also need to
47:09 - be able to catch up to all of the other
47:10 - computers that are working on the new
47:12 - blocks being added to the chain and kind
47:14 - of beat them and you'd be like racing
47:16 - against them in a sense I'm sure this is
47:18 - very abstract but this is what makes the
47:19 - blockchain so secure that these blocks
47:21 - are actually linked together you need to
47:23 - perform this mining process which is
47:25 - proving you've done a certain amount of
47:27 - work this work takes some amount of time
47:30 - this amount of time you can calculate
47:32 - using probability the probability you're
47:34 - going to guess a random number and how
47:36 - quickly you can guess random numbers and
47:37 - all of that and as the blockchain
47:39 - continues to grow being able to
47:41 - potentially modify it becomes harder and
47:43 - harder and harder so anything that is
47:45 - added to the blockchain is pretty well
47:46 - permanent and you cannot remove of it
47:49 - without having to rewrite the entire
47:51 - blockchain so this is all great but one
47:53 - other thing I will mention here is that
47:54 - another security feature that's built in
47:56 - is that every single computer that is
47:58 - mining the blockchain or mining the
48:00 - current block has a copy of the existing
48:03 - blockchain and so what that means is
48:04 - that if you try to change something on
48:06 - say the current block every single other
48:09 - computer knows what the current block
48:10 - looks like and so if you're submitting a
48:12 - block that looks different from that
48:13 - it's going to be able to tell that very
48:15 - very quickly it can just take the hash
48:16 - of the block if it doesn't match the
48:18 - hash that it has it's going to be like
48:20 - no this is the incorrect block I'm not
48:22 - going to accept this block or accept
48:24 - this transaction because well it doesn't
48:25 - match what I currently have
48:27 - so hopefully this is all starting to
48:29 - come full circle just a little bit you
48:31 - don't have to understand this stuff
48:32 - super super well but you just have to
48:34 - have a general idea of why the
48:36 - blockchain is so secure this concept of
48:39 - decentralization and kind of how
48:41 - transactions get added to the blockchain
48:42 - and what mining actually means right and
48:45 - that's the reason why there's been a
48:47 - huge GPU crisis in the past and recently
48:49 - as well a bunch of people are mining
48:51 - cryptocurrency for the incentive of
48:53 - trying to earn these different rewards
48:55 - alright so that is all great and really
48:57 - what I just spent the last 10 or 15
48:59 - minutes explaining is proof of work so
49:02 - pretty much everything starting from
49:03 - when I started talking about blocks was
49:05 - trying to explain to you how proof of
49:07 - work works and while that uses raw
49:10 - computing power typically gpus to
49:12 - perform hashing which then secures the
49:15 - blockchain in the ways that I mentioned
49:16 - however and I understand some of you may
49:18 - be a little frustrated here ethereum is
49:20 - actually switching over now to proof of
49:22 - stake I'm not sure exactly when that's
49:24 - going to happen but it's supposed to
49:26 - have happened for a long time and I know
49:28 - it's going to happen very very soon and
49:30 - the difference is that with proof of
49:31 - stake which is going to be kind of the
49:33 - new method and algorithm this is a type
49:35 - of consensus mechanism which is going to
49:37 - be used to validate the transactions
49:39 - versus using raw computing power now
49:42 - proof of stake pretty much means that if
49:44 - you own cryptocurrency you can stake
49:46 - your coins by staking them you're kind
49:48 - of putting them in a locked container
49:50 - that's the way you can think of it and
49:52 - what this does is give you the right as
49:54 - the Staker of these coins to check new
49:56 - blocks of transactions and to add those
49:58 - to the blockchain now I'm not going to
50:00 - explain proof of stake in this video
50:02 - maybe we'll explain that in another
50:04 - video point being ethereum is slowly
50:06 - switching over or actually probably
50:08 - pretty quickly switching over to proof
50:10 - of stake and that's going to be the new
50:12 - method now I will just say that even
50:13 - though ethereum is switching over to
50:15 - proof of stake that does not mean that
50:17 - what I just explained to you was a waste
50:19 - of your time it is still very very
50:20 - valuable to understand how proof of work
50:22 - works and that is currently what is
50:24 - being used and is being used for a lot
50:26 - of other cryptocurrencies as well proof
50:28 - of stake is just another method of doing
50:30 - this and while I'm not going to explain
50:31 - that further in this video but maybe
50:33 - we'll talk about that in the future
50:35 - regardless with that said that pretty
50:37 - much wraps up everything that I needed
50:39 - to cover if you guys made it to the end
50:41 - of the video give yourself a pat on the
50:43 - back I hope that this maybe cleared up
50:45 - how the blockchain works and gave you at
50:47 - least a little bit of the insight into
50:48 - the theory behind it if I were to go
50:51 - through and explain all of the
50:52 - mathematics of This Not only would I
50:54 - probably make a ton of mistakes but this
50:55 - video would probably be four or five
50:57 - hours long so really if you can grasp
50:59 - The Core Concepts here you have a good
51:01 - enough understanding to kind of proceed
51:03 - and to move forward and start writing
51:05 - smart contracts and to be quite honest
51:06 - with you you don't necessarily need to
51:08 - have all this master to actually write a
51:10 - smart contract it's just very helpful in
51:12 - something that I think is fundamental
51:14 - before moving forward anyways with that
51:16 - said I will finally end the video here
51:18 - thank you guys again for watching if you
51:20 - enjoyed leave a like subscribe to the
51:22 - channel and I will see you in another
51:23 - one
51:24 - [Music]
51:26 - hello everybody and welcome to the third
51:29 - video in this blockchain for beginners
51:31 - tutorial Series in this video I'm going
51:34 - to be giving you an introduction to
51:35 - solidity and showing you how to write
51:37 - and deploy your first smart contract
51:39 - this is really really cool I had a lot
51:41 - of fun messing with this before the
51:43 - video and I think you guys are going to
51:44 - be amazed at how simple it is to
51:46 - actually write a smart contract anyways
51:48 - I should mention that solidity is the
51:50 - programming language typically used for
51:52 - deploying smart contracts and writing
51:54 - ethereum smart contracts and so that's
51:56 - why we're going to be using it now in
51:58 - terms of kind of some prerequisites for
52:00 - this video I'm going to assume that you
52:02 - have some understanding of programming
52:04 - some experience writing and maybe a
52:06 - different programming language just
52:07 - because in this video I'm not going to
52:09 - explain the very Basics like things like
52:11 - variables functions and all that stuff
52:13 - that's kind of common knowledge when it
52:15 - comes to program of course I'll go
52:17 - through the solidity syntax and we're
52:19 - really going to learn by actually just
52:20 - doing a bunch of examples and not
52:22 - focusing a ton on Theory last thing I
52:25 - will say is that you do need to have
52:26 - your metamask set up if you want to
52:28 - deploy this to a test Network so an
52:30 - ethereum test network if you don't have
52:31 - metamask setup that's fine you just
52:33 - won't be able to follow along with that
52:35 - step in the video alright so with that
52:37 - said we're just about ready to get
52:39 - started I just want to quickly thank
52:40 - cartesi again for sponsoring this video
52:42 - in this series they're an awesome
52:44 - company again dedicated to making the
52:46 - blockchain more accessible and easy to
52:49 - use they've really helped me a ton in
52:51 - terms of coming up with the content for
52:52 - these videos well I hope you guys
52:54 - appreciate that in the future videos in
52:56 - this series we're going to be talking
52:57 - about how we can actually use cartesi to
52:59 - fix some of the scalability issues with
53:01 - smart contracts because you're going to
53:03 - start to see some of the problems that
53:04 - can actually occur when we write a smart
53:06 - contract because they're a lot different
53:08 - than your traditional code anyways let's
53:10 - go ahead and get into the code
53:17 - foreign
53:21 - so I'm here on my computer and the first
53:23 - thing I'm going to discuss is just
53:24 - setting up our environment for writing
53:26 - code in solidity and deploying smart
53:28 - contracts now of course you can write
53:30 - contracts in vs code or any local code
53:32 - editor but instead for this series I'm
53:35 - going to use an online IDE called remix
53:37 - now this is a browser-based IDE it's
53:41 - completely free and it's super beginner
53:43 - friendly and allows you to actually
53:44 - deploy and test your smart contracts
53:47 - directly from the browser so I'd
53:49 - recommend that you use this you can
53:50 - check it out from the link in the
53:52 - description or just Google remix IDE
53:54 - again completely free and once you click
53:56 - on that link it should bring you to a
53:58 - page that looks like this so for now
54:00 - what I'm going to do is just give a
54:01 - quick tour of remix then we'll talk
54:04 - about smart contracts what they actually
54:05 - are how they work then we'll start
54:07 - writing some code and going through some
54:09 - examples of smart contracts so the first
54:11 - thing we want to do here when we open up
54:13 - remix is we just want to install a few
54:15 - extensions specifically for solidity so
54:17 - you can write other stuff in remix not
54:19 - just solidity code so that's why we want
54:21 - these extensions so what we're going to
54:23 - do is just on the left hand side here go
54:25 - to this plug-in manager it looks like a
54:27 - plug and what we're going to do is
54:28 - search for solidity now for me I already
54:31 - have these extensions installed but what
54:33 - you're going to want to install is the
54:34 - solidity compiler the solidity static
54:36 - analysis and then the solidity unit
54:38 - testing now you don't really need the
54:40 - unit testing but you might as well just
54:41 - install it while we're here so install
54:43 - those three plugins and once you have
54:45 - them installed we're pretty much ready
54:46 - to start writing solidity code now
54:49 - you're going to see in the left hand
54:50 - side here let me zoom in a little bit
54:51 - that we have a bunch of you know I guess
54:54 - folders directories and inside of here
54:56 - we have some different smart contracts
54:57 - we have some scripts we have all this
54:59 - kind of stuff you don't need to worry
55:00 - about any of that this is all just kind
55:02 - of test code that's provided to you
55:04 - we're not going to use any of this we
55:05 - don't even need to look at it so you can
55:07 - kind of just ignore it for now what I'm
55:09 - actually going to do to get started is
55:10 - I'm just going to make a new file so I'm
55:12 - going to click on this little file icon
55:14 - right here and then I'm just going to
55:16 - call this
55:17 - test.soul so dot Sol is the extension
55:20 - for sale D file so that's why we're
55:22 - going to use that when I do that it will
55:24 - open up a brand new file notice we have
55:26 - the little solidity icon now we can
55:28 - start actually writing a smart contract
55:30 - now one thing to notice here is there's
55:32 - stuff like GitHub Integrations you can
55:34 - create new directories you can upload
55:36 - files you can also have different
55:38 - workspaces so right now I'm in a
55:40 - workspace I created called tutorial but
55:42 - you also could make a new one by
55:44 - clicking this right here I guess this is
55:46 - renaming a workspace and then of course
55:48 - you can delete it I'll let you look at
55:50 - that yourself pretty straightforward
55:51 - anyways all we need to do is get to kind
55:53 - of a file that looks like this just an
55:55 - empty solidity file so I'm just going to
55:57 - zoom in by clicking this plus icon here
55:59 - so you guys can actually read the code
56:00 - alright so now that we're here we might
56:02 - as well write a very basic smart
56:04 - contract I'll briefly show you how it
56:06 - works and how we can run it then I'll
56:08 - actually discuss smart contracts in
56:10 - detail so how they work how you call
56:12 - them and how they're different from
56:13 - traditional code because they are much
56:15 - much different than anything you would
56:17 - have seen before okay so what I'm going
56:19 - to do is zoom in a bit and let's start
56:21 - by writing what's known as our pragma
56:22 - line now the pragma line is required at
56:25 - the beginning of all of your solidity
56:27 - files and what this does is actually
56:29 - tell solidity what company Tyler version
56:31 - this file needs to use so there's a ton
56:34 - of different compilers that are
56:35 - accessible for solidity you just need to
56:37 - define the minimum compiler version so
56:39 - I'm going to say pragma solidity and I'm
56:41 - going to say
56:42 - 0.8.10 and then put a semicolon like
56:45 - that so for all of your lines you're
56:47 - going to have semicolons at the end very
56:48 - similar to something like Java okay so
56:51 - we have our pragma line again just
56:52 - pragma solidity and then the minimum
56:54 - compiler version if you want to see the
56:56 - compiler versions you can go to I
56:58 - believe it's this tab right here and it
57:01 - will show you all the compiler versions
57:03 - so notice we're on 0.8.10 so I'm just
57:06 - using one of the latest versions that we
57:07 - have okay and then for language of
57:09 - course that'd be solidity and you're
57:11 - just going to have compiler default now
57:12 - here you can actually manually compile
57:14 - your solidity code I'll talk about that
57:16 - in a few minutes for now though let's
57:18 - continue writing the rest of our
57:20 - contract so after we do our pragma line
57:22 - the next thing we need to do is Define a
57:24 - contract so I'm going to say contract
57:26 - and then I'm going to give this a name
57:27 - now I can give this whatever name I want
57:30 - I'm just going to call it my contract so
57:32 - what I've just done is created a smart
57:34 - contract okay that's all you need to do
57:35 - you write the word contract give some
57:37 - name the casing you're supposed to use
57:39 - for this name is Pascal case which means
57:42 - you're supposed to have capital letters
57:43 - for every single word and then inside of
57:45 - here we can start defining some
57:46 - variables some functions and methods
57:49 - sorry not not functions methods that's
57:50 - what I mean
57:51 - anyways for now I'm just going to define
57:53 - a very basic variable then I'm going to
57:55 - show you how we actually deploy and test
57:57 - this smart contract and then we'll
57:59 - continue with some theory in looking at
58:00 - this more in depth so for now what I'm
58:03 - going to say is uint this stands for
58:06 - unsigned integer and I'm just going to
58:08 - say that this is public like this I'm
58:11 - going to call this X and I'm just going
58:12 - to make this equal to 21. okay super
58:15 - straightforward this is just me defining
58:17 - a variable the type of the variable is
58:18 - an unsigned integer it is public meaning
58:20 - anyone can view it its name is X and its
58:23 - value is 21. so now that we have this
58:26 - contract what we need to do is compile
58:28 - the contract and then deploy so all of
58:31 - our contracts in solidity need to be
58:33 - compiled into bytecode this bytecode is
58:35 - then sent to the ethereum network where
58:38 - the contract is deployed and then we can
58:40 - call the contract so let's just look at
58:42 - a quick example of doing this so we can
58:43 - manually compile by pressing compile we
58:46 - actually don't need to manually do this
58:47 - when we deploy it will automatically
58:49 - compile for us anyways I've compiled the
58:51 - contract right here notice I have my
58:53 - compiler version solidity compiler
58:55 - default then what I'm going to do is go
58:56 - to this tab right here so just below it
58:59 - let's see what this one's called deploy
59:00 - and run transactions and here what we
59:03 - can do is choose a few different options
59:04 - for actually deploying our contract so
59:07 - if you go here notice we have a bunch of
59:08 - options we have web3 provider injected
59:11 - web3 JavaScript VM and then we have the
59:14 - Berlin version of the JavaScript VM now
59:16 - the JavaScript VM is what I'm going to
59:18 - use for right now but what this is is a
59:20 - virtual machine that simulates the
59:22 - ethereum network in your browser so this
59:25 - means you don't actually have to make
59:26 - any real transactions you're not
59:28 - actually adding this to a legitimate
59:30 - blockchain you're just simulating it so
59:32 - that you can test this directly in your
59:34 - browser now if you refresh your browser
59:36 - what's going to happen is anything that
59:38 - you've been simulating in the JavaScript
59:39 - VM is going to disappear because while
59:41 - it was being stored and I guess the
59:43 - cache or whatever inside of your browser
59:45 - point is Javascript VM is kind of a
59:47 - testing environment and when you're
59:49 - actually going to deploy this smart
59:50 - contract for other people to use you
59:52 - need to deploy it to what's known as a
59:54 - web 3 provider or an injected web3 now
59:57 - injected web 3 is actually going to use
59:59 - whatever Network your metamask is on so
60:02 - if I do this what's going to happen is
60:04 - when I try to deploy this contract it's
60:06 - going to open up metamask and it's going
60:07 - to require that I actually do a
60:09 - transaction to deploy this contract
60:11 - again we're going to look at that in a
60:12 - second for now I just want to quickly
60:14 - show you deploying it and running it and
60:15 - then we'll get into the theory so I'm
60:17 - going to go to JavaScript VM and notice
60:19 - here that when I do this it's going to
60:21 - give me a bunch of different accounts
60:23 - that have a hundred ethereum again this
60:24 - is just testing and the point of these
60:26 - different accounts is that I can
60:28 - actually use all of them with my smart
60:30 - contract because every time I deploy the
60:32 - smart contract I want to call a function
60:34 - on a smart contract I need to make a
60:36 - transaction to do that and that requires
60:38 - an account to make the transaction with
60:40 - so for now I'll just select this first
60:42 - account I could copy the address here if
60:44 - I wanted to do that the gas limit just
60:46 - leave this the same for now and then you
60:48 - could pick an amount of ethereum that
60:49 - you actually want to send with this
60:51 - transaction now I don't want to do that
60:53 - for now I don't want to send any
60:54 - ethereum all I want to do is deploy my
60:55 - smart contract so I'm just going to
60:57 - click on deploy and then you're going to
60:59 - see down here it's going to show you my
61:00 - deployed contracts so I now have a
61:03 - contract notice that showing this little
61:04 - button X and if I click on this it gives
61:06 - me the value of x okay very very simple
61:09 - that's all you need to do to deploy a
61:11 - smart contract we'll talk about this
61:13 - more in a second what I want to do now
61:14 - is hop over to my drawing tablet and
61:17 - start talking about some of the theory
61:18 - behind smart contracts and how they
61:20 - actually work and why we kind of need to
61:22 - go through this alright so I'm here on
61:24 - the drawing tab and I want to start by
61:25 - discussing how we deploy a smart
61:27 - contract then I want to talk about their
61:29 - use cases and go through a few
61:31 - properties of them so as we saw we had a
61:34 - smart contract and we stored this inside
61:37 - of a DOT Sol file now this is our
61:39 - solidity file and this is what we refer
61:41 - to as our source code now the source
61:44 - code is simply the code that we write as
61:46 - a programmer it's the closest to English
61:48 - it's the easiest for us to understand it
61:50 - is the source code okay this is where we
61:52 - actually write solidity code however
61:54 - this code cannot be executed on the
61:56 - ethereum network so what we need to do
61:58 - is compile this by running it through a
62:00 - compiler into something called by code
62:02 - so the first step when we're deploying
62:04 - this contract is we run this through a
62:06 - compiler this compiler is capable of
62:08 - taking one language and translating it
62:10 - into another
62:12 - and what we get here is now what I'm
62:14 - going to refer to as the bytecode
62:16 - now the byte code is just a special type
62:18 - of code that the computer can actually
62:20 - understand and execute in almost every
62:23 - programming language what's occurring is
62:24 - you're taking source code you're
62:26 - compiling it into bytecode and then that
62:28 - bytecode is being interpreted by an
62:29 - interpreter The Interpreter you can kind
62:31 - of think of as a mini computer in a
62:33 - sense that's actually going to be able
62:34 - to take all of this code read it
62:37 - understand it and then tell the CPU of
62:39 - your computer how to execute it The
62:42 - Interpreter is typically known as a
62:43 - virtual machine anyways you don't need
62:44 - to know too much about that point being
62:46 - you take source code compile it into
62:48 - something like bytecode byte code is
62:50 - then something that the computer can
62:52 - actually understand and execute and so
62:54 - that's how your code actually ends up
62:56 - running anyways at this point we now
62:57 - have our byte codes we've taken our
62:59 - solidity code We've ran it through the
63:01 - compiler by The Way remix will do this
63:03 - for us automatically so you don't need
63:04 - to manually compile the code and now we
63:06 - have our byte code so let me just move
63:08 - my byte code over here so now that we
63:10 - have this bytecode this is the code the
63:11 - ethereum network and understanding that
63:13 - computers can execute but how do I
63:15 - actually get this now to the block
63:17 - well what I need to do is I need to
63:20 - create a transaction now I just want to
63:22 - quickly mention here that what a smart
63:24 - contract is is just code that's sitting
63:27 - on the blockchain so all we're doing is
63:28 - we're taking this bytecode we're putting
63:31 - this in a transaction and then this
63:33 - transaction is kind of special in the
63:34 - sense that it requests to create this
63:37 - code this smart contract on the ethereum
63:40 - network so what happens is we make a
63:42 - transaction
63:43 - we throw the bytecode on this
63:45 - transaction we pay some fees and then we
63:48 - kind of upload this or send this in a
63:49 - way to the ethereum network okay so just
63:52 - like sending money between different
63:54 - accounts except in this case we're
63:55 - making a transaction that is adding this
63:57 - bytecode as a smart contract to the
64:00 - ethereum network now like all other
64:02 - transactions the first thing that needs
64:03 - to happen here is this transaction needs
64:05 - to be associated with a block then it
64:07 - needs to be mined once it's mined then
64:09 - is on the ethereum network now what that
64:12 - means is just like any other transaction
64:14 - anyone can go and see this they can see
64:16 - the transaction they can see who created
64:18 - the smart contract they can see all of
64:20 - the code of the smart contract they're
64:22 - able to view when you created it the
64:24 - balance of the smart contract all of
64:25 - these other things and this also means
64:28 - that once we add this smart contract to
64:30 - the network we can never change it we
64:32 - cannot mutate it we cannot modify it we
64:34 - cannot change it or delete it and the
64:36 - reason for that is the same reason that
64:38 - we can't delete transactions on the
64:40 - ethereum network right because that's
64:42 - the way the blockchain chain works it is
64:44 - forever there it is a ledger of
64:46 - everything that has happened is
64:47 - completely transparent and trustworthy
64:49 - and that's actually the main point of
64:51 - our smart contracts so hopefully that
64:53 - makes a bit of sense we're going to
64:54 - continue to clarify this in this section
64:56 - point being is that the reason we create
64:59 - smart contracts is because we're taking
65:01 - advantage of the security features of
65:03 - the blockchain to make people trust the
65:06 - code that we are uploading so let's take
65:08 - an example where we want to write some
65:10 - type of Poker application or a casino or
65:12 - something that involves money right
65:14 - something that's going to have money
65:15 - being transacted from either us to the
65:17 - client or from the client to us well if
65:20 - someone comes to our website or we go to
65:22 - some Casino website for example most
65:24 - times we can't see the code right we
65:27 - have no idea what's actually happening
65:28 - in the back end we could easily be
65:30 - getting ripped off maybe our money's
65:31 - being stolen maybe the odds are not in
65:33 - our favor or less in our favor than they
65:35 - should be whatever if we can't see the
65:37 - code we don't really have any way to
65:38 - trust what this website is doing or how
65:41 - these transactions are occurring however
65:43 - if you had your code as a smart contract
65:46 - and you knew that the website was using
65:48 - the smart contract maybe you're able to
65:49 - verify that in some way then you could
65:51 - just go and read the smart contracts
65:53 - that were being used and decide if you
65:55 - want to interact with them or not this
65:57 - means you can fully and transparently
65:59 - see all of the code that's actually
66:01 - being ran and executed you know if you
66:03 - want to trust it or not and then you can
66:05 - decide if you want to interact with it
66:06 - right so hopefully that makes sense one
66:09 - important point there as well is that
66:10 - that code that you're looking at can
66:12 - never be changed which means if you're
66:14 - interacting with the same smart contract
66:16 - you know it's always going to look like
66:18 - that and it's always going to be
66:19 - trustworthy so that's kind of the main
66:21 - point of smart contracts is to allow
66:22 - people to trust the code to make it
66:25 - fully visible to everyone and also just
66:27 - to allow everyone to be able to use it
66:28 - right although I will say it is pretty
66:30 - expensive to be interacting with smart
66:32 - contracts and uploading them to a theory
66:35 - okay that is the main point of smart
66:38 - contracts now one thing I will mention
66:39 - as well is that smart contracts can have
66:41 - a balance so that means you can send
66:43 - money money to a Smart contract it can
66:45 - receive money it can send money back to
66:47 - you it can call other smart contracts
66:49 - and in fact we're going to start talking
66:50 - about that now so let me clear the
66:52 - screen and now we're going to talk about
66:53 - how you actually call a smart contract
66:55 - so in front of me I have a beautiful
66:57 - illustration I have a contract and two
66:59 - ethereum accounts now as I said briefly
67:02 - a contract can have a balance so just
67:05 - like an account a contract is going to
67:06 - have an address it's going to have some
67:08 - type of balance so we can actually store
67:09 - ethereum and it can send and receive
67:12 - ethereum as well so that means that the
67:14 - account 2 can send money directly to the
67:17 - contract the contract could send money
67:19 - back to it and again account one and
67:21 - account two I'm just treating as regular
67:22 - ethereum accounts so ones we already
67:24 - would have talked about anyways the
67:27 - contract has a balance and that means we
67:29 - can go and view the balance we can see
67:31 - every single call and transaction that's
67:33 - happened with the contract everything is
67:35 - completely transparent just like our
67:37 - other regular ethereum accounts great
67:40 - okay so now that we understand that I
67:42 - want to talk about the fact that a
67:44 - contract should really be treated like a
67:46 - state machine so what I mean by that is
67:48 - that most contracts are going to store
67:49 - some type of data so in this case we
67:51 - have x equals one now we need to think
67:53 - of this like the state of the contract
67:55 - and the reason for that is that these
67:57 - contracts are not constantly run they're
68:00 - not just always executing in the
68:01 - background they need to manually be
68:04 - triggered from a transaction to actually
68:06 - do something and so when they're not
68:08 - being called by a transaction they're
68:10 - simply some State that's sitting on the
68:12 - ethereum blockchain okay that's all they
68:14 - are we just have the code we have the
68:16 - values of the different variables so the
68:18 - state of the contract and we can access
68:20 - the state or request to change the state
68:22 - by making some type of transaction
68:25 - okay so let's see now how we actually
68:27 - call a smart contract because I keep
68:29 - saying this for it to do anything we
68:31 - need to call it so calling a smart
68:33 - contract is really just making a
68:35 - transaction that requests some operation
68:37 - be performed on the contract okay so
68:40 - from account two maybe we make a
68:42 - transaction so in fact let's just write
68:43 - TX here representing transaction and
68:46 - this transaction is going to the smart
68:48 - contract now usually what we do is we
68:50 - pick some type of method or some
68:51 - operation we're going to be performing
68:53 - on the contract so maybe we call this a
68:55 - method here like set X and we pass value
68:58 - two now the smart contract can do
69:00 - whatever it wants in this method but
69:01 - maybe all it does is just change the
69:03 - state to two then what we would do is we
69:05 - would simply change this so now X is
69:07 - equal to 2. perfect now when we make
69:10 - this transaction just like any other
69:12 - transactions we need to sign it we need
69:14 - to secure it we're going to have a to
69:15 - address and a from address and we're
69:17 - also going to have to pay a transaction
69:18 - fee which is going to be made up of gas
69:20 - now you can think of gas kind of like a
69:23 - literal gas in the real world in the
69:25 - sense that this contract requires gas to
69:29 - actually be able to execute code so
69:31 - every single operation this is going to
69:33 - perform is going to use a tiny bit of
69:35 - gas it's going to use a little bit of
69:36 - gas and so we send what's known as a gas
69:39 - limit so the maximum amount of gas that
69:41 - we potentially want to use in executing
69:43 - this contract and then if that's enough
69:45 - gas the contract will actually be able
69:48 - to execute it will run through all of
69:50 - the code whatever it will have enough
69:51 - gas to do that it costs us ethereum
69:54 - essentially to execute code on the
69:56 - ethereum blockchain okay now the amount
69:58 - of gas you send in is required is going
70:00 - to depend on what the contract is doing
70:02 - some operations require a lot more gas
70:04 - than others anyways that's pretty
70:06 - complicated we don't need to talk about
70:07 - that for now but just understand stand
70:09 - that what happens is we're passing along
70:10 - gas and the gas allows the contract to
70:13 - actually execute if it runs out of gas
70:15 - just like a car it's not able to do
70:17 - anything else okay so that's it for
70:20 - calling contracts but now let's quickly
70:22 - talk about contracts calling other
70:23 - contracts because that is possible so
70:26 - let's say I have another contract right
70:28 - here and maybe this contract needs to
70:30 - interact with this one maybe it's going
70:32 - to call something on it's going to send
70:33 - ethereum whatever it's going to do so
70:34 - first of all that that's fine these
70:36 - contracts can interact with each other
70:38 - but they can only do that if this
70:40 - interaction starts from stems from is at
70:43 - the root of some account sending a
70:46 - transaction so these contracts if they
70:49 - have no transaction so imagine this
70:50 - guy's gone right here they can't do
70:52 - anything they cannot execute they cannot
70:54 - call each other they can't do anything
70:56 - at all they're just sitting there idle
70:57 - they are State machines however as soon
71:00 - as I have some transaction from any
71:03 - regular ethereum account that goes to a
71:06 - contract now this contract is capable of
71:09 - Performing some operations executing
71:11 - some code whatever and calling other
71:14 - contracts it needs to start though from
71:16 - one of these main transactions there's
71:18 - no way for this contract to call the
71:20 - other contract unless we start from a
71:23 - transaction that I've showed you right
71:24 - here so all of this needs to kind of
71:26 - root from some transaction outside of
71:29 - the blockchain so what I mean by that is
71:30 - from some kind of regular ethereum
71:32 - account so hopefully that makes sense
71:34 - but again you can really think about
71:36 - this in the sense that these contracts
71:38 - are idle not doing anything unless
71:40 - they're called from outside of the main
71:42 - blockchain Network right so from kind of
71:43 - a regular account and so if no account
71:45 - is calling any of these contracts
71:47 - they're not able to do anything and we
71:49 - also need gas which is going to be
71:51 - passed along with the transaction to the
71:53 - first contract call that we make all
71:55 - right so with that said I think that
71:56 - ends the theory section of this video I
71:58 - apologize if this was long but this
72:00 - really did need to be covered now we're
72:02 - going to get back to the code and I'm
72:04 - going to start showing you how to write
72:05 - more advanced smart contracts alright so
72:08 - I am back on the computer and now what
72:10 - I'm going to show you how to do is how
72:11 - to deploy the smart contract to a real
72:13 - ethereum Network so we'll go with the
72:15 - test Network right rather than the
72:17 - JavaScript VM which is going to emulate
72:19 - the blockchain in your browser so what
72:22 - I'm going to do here is change this to
72:23 - injected web3 now when you do that it's
72:26 - going to connect with metamask which I
72:27 - assume you already have set up and it's
72:29 - going to show you the test Network that
72:31 - you have I guess enabled in metamask and
72:33 - the account that you're using for
72:35 - metamask so in this case I have my
72:36 - tutorial account that has a little bit
72:38 - less than one ether
72:40 - anyways in the same way that we deployed
72:42 - this uh when we were using the
72:44 - JavaScript VM we could just click deploy
72:46 - it will automatically compile this for
72:48 - us we don't need to manually compile and
72:50 - it's going to actually bring up metamask
72:51 - because we need to make a transaction to
72:53 - do this right we need to create the
72:55 - contract that requires a transaction so
72:57 - we can look at data this is going to
72:59 - have the contract data we're going to
73:00 - have our details that's going to tell us
73:02 - how much it costs now the bigger the
73:03 - contract is the more this would cost
73:05 - anyways this is relatively cheap I will
73:07 - click confirm
73:09 - okay now this is going to take a second
73:10 - and if I bring up this uh kind of you
73:13 - know terminal here console you're going
73:14 - to see it tells me that it successfully
73:16 - deployed the contract okay so you can
73:18 - view kind of I guess the output of all
73:20 - the transactions and contract calls by
73:22 - just bringing this terminal up right
73:24 - here anyways what we're going to see now
73:26 - is it shows my deployed contracts so
73:28 - this is my deployed contract now what I
73:30 - want to do is actually look at this
73:32 - contract so let's see how we can do that
73:34 - so what I'm going to do is go to
73:35 - metamask here
73:36 - I am going to go to the contract
73:39 - deployment which is right here okay and
73:42 - then you'll see that I can actually
73:43 - click on this button and it will allow
73:44 - me to view the transaction on etherscan
73:47 - now I had some other transactions there
73:48 - I was of course messing with this before
73:50 - the video so you can ignore those ones
73:51 - this is the one that we just crit
73:54 - anyways now we are in etherscan the go
73:56 - rally test Network etherscan right and
73:58 - we can see we had our transaction it was
74:00 - successful and we have the from and the
74:02 - two now what I want to look at is the
74:04 - actual contract address so I'm going to
74:06 - click on that right there
74:07 - now it's going to bring me to the
74:09 - contract address on etherscan so I can
74:11 - see the balance I can see the content
74:13 - creator so this was me right I created
74:15 - this contract at this transaction and
74:18 - then it tells you that the content or
74:20 - the contract sorry was created now we
74:22 - can look at the contract itself so we
74:23 - can actually view the byte code we can
74:25 - decompile that into the source code if
74:27 - we want and then we have events I'm not
74:30 - going to talk about that right now that
74:31 - will be in the next video
74:33 - anyways we can close that I just wanted
74:34 - to oops uh let's go back I just wanted
74:37 - to show you what that looks like uh okay
74:39 - so let's go back to remix
74:42 - all right so now that we have this
74:43 - deployed we can use the contract right
74:45 - so I can access the variable X that's
74:48 - fine it's going to give me the value 21.
74:50 - so one thing to note here is that when
74:51 - you're viewing the state of a contract
74:53 - so we're just looking at the value of x
74:55 - here right viewing the state this is
74:57 - free we don't need to do a transaction
74:58 - it's fine we can query the state that's
75:01 - a free operation and the reason for that
75:03 - is the state is available right like we
75:05 - can go look at the state of the contract
75:07 - because it's stored in there publicly
75:09 - available it's already on the blockchain
75:11 - so we don't need to do any computation
75:12 - we're just querying and viewing a state
75:15 - so that's completely free to do so
75:17 - that's why when I click X here I get
75:19 - this instantly and it gives me 21
75:20 - because I don't need to actually have a
75:22 - transaction mined to view the state the
75:25 - only transactions I need are when I'm
75:26 - modifying the state of this contract
75:28 - okay or performing some type of
75:30 - computation
75:31 - anyways what I want to do now is change
75:34 - the contract so we can actually update
75:35 - the value of x so this is where we'll
75:37 - talk about functions slash methods
75:40 - so what I can do is inside of this
75:42 - contract I can create a function this
75:44 - will be a kind of a method associated
75:45 - with the contract obviously I need to
75:47 - give this a name so I'll give it
75:49 - something like set X now for the
75:51 - parameters of this function I need to
75:53 - Define first there type and then the
75:55 - name of the parameter so I'm going to
75:57 - say uint
75:58 - underscore X like that this will kind of
76:00 - be my new x value that I want to set X
76:02 - to then I need to give my access
76:05 - modifier for this function now the
76:07 - access modifiers essentially tell people
76:09 - trying to use the contract if this
76:12 - function is private if it is public if
76:14 - it's internal external I'll talk about
76:16 - what all of those mean but you need one
76:18 - of these here
76:19 - so I'm going to say public to define the
76:21 - fact that anyone can use this method so
76:24 - a contract any uh anyone calling this
76:26 - from a transaction is able to use this
76:28 - method because it's public same with
76:30 - this variable X now if we made X private
76:33 - for example you wouldn't be able to
76:34 - access the state of it at least not very
76:37 - easily because it would be private to
76:39 - the contract again we'll talk about
76:40 - access modifiers in a sec for now though
76:42 - we'll just say function set X uint
76:44 - underscore X will make this public then
76:46 - I'm just going to say X
76:47 - is equal to underscore X okay so now
76:51 - when I call this function we will change
76:53 - X Change the value and then when we
76:55 - access it again it will be different
76:57 - pretty straightforward
76:59 - okay so now that we've changed the
77:01 - contract we need to redeploy this I'll
77:02 - do this again to the gorelli test
77:04 - Network so I'll just click on deploy
77:06 - okay we're going to have to confirm the
77:08 - transaction and notice this time it's a
77:10 - bit more expensive we have more content
77:12 - in our contract and so it makes sense
77:14 - this is going to be more expensive right
77:16 - so I'm going to click confirm okay it's
77:18 - going to take a second and then once
77:20 - it's created we should be able to use it
77:22 - and I'll show you what happens when we
77:24 - actually modify X okay so the contract
77:26 - has been created I'm going to click
77:28 - right here and now uh we'll have a new
77:31 - contract so we'll look at that one in a
77:32 - second but for now what I can do is set
77:34 - X so if I look at X right now it's 21
77:36 - that was free right I didn't have to pay
77:38 - for that I'm just viewing the state but
77:39 - now if I change the state to say 25 so
77:42 - let's set X notice I need a transaction
77:44 - okay so it's giving me a transaction and
77:47 - this is going to cost me a certain
77:48 - amount of gas right so I will click
77:50 - confirm now this is going to take a
77:52 - minute I need to wait for the
77:53 - transaction to be mined okay it was done
77:55 - pretty quickly now if I click X again
77:57 - its new value is 25. so I've modified
78:00 - the state of this contract okay
78:02 - hopefully that makes sense that kind of
78:04 - wraps up all the explanation in terms of
78:06 - how you call a contract with the state
78:08 - of the contract is all of that stuff now
78:10 - we're going to continue looking at some
78:11 - more solidity syntax all right so I've
78:13 - just cleared my code and changed the
78:15 - environment back to JavaScript VM now
78:17 - I'm going to talk to you about a few
78:18 - data types in the solidity so the first
78:21 - one is uint now we've already looked at
78:23 - this it stands for unsigned integer
78:25 - meaning we can store any positive whole
78:27 - number okay so I can do something like
78:29 - uint public X is equal to one of course
78:33 - we know that is found now with the uint
78:36 - this actually allows us to specify the
78:38 - number of bytes we want to use to store
78:40 - the integer so I could do something like
78:42 - uint 8 un 16. you win 32 un 64 unit 128
78:47 - and then 256 and I believe 256 is
78:51 - actually the default so if you just
78:52 - write uint I think by default it uses
78:54 - 256. I'll put something on the screen
78:56 - that confirms that or not now let's
78:58 - actually just see what happens if we try
79:01 - to store a negative number inside of a
79:03 - uint okay so let me just deploy this
79:05 - contract here we have our smart contract
79:07 - and notice that it's actually not even
79:09 - deploying this right because we would
79:11 - have seen the variable y because we have
79:13 - an error so it's deploying the last
79:15 - contract so the last one that we
79:16 - actually had compiled not this one
79:19 - because we have the error and it's
79:20 - showing that right here okay we cannot
79:22 - implicitly convert negative one to an
79:24 - unsigned integer now of course though we
79:27 - have regular integer right so regular
79:29 - int allows us to store a signed number
79:31 - again just like the UNS we can specify
79:34 - the number of bytes so 16 32
79:38 - 64 whatever now let's run to this one so
79:40 - deploy and let's see what we get here
79:43 - and now we have y so it actually
79:45 - deployed this contract and we can look
79:47 - at its value
79:48 - perfect okay so that is it now other
79:50 - than int we have a Boolean
79:53 - okay so we can say something like
79:54 - Boolean public Y is equal to True let's
79:57 - deploy this
79:59 - now oops I want to close that let's look
80:01 - at this contract here click on Y and
80:03 - notice we get true now of course other
80:04 - than true we have false I assume most of
80:07 - you know what the Boolean data type is
80:09 - just note here there is a lowercase on
80:11 - the first letter rather than a capital
80:13 - if you're coming from python like me
80:15 - okay so we had int uint bull now we also
80:18 - have a dress address payable and mapping
80:21 - and a ton of other data types as well
80:23 - now I'm only going through these ones
80:24 - because these are kind of the core most
80:26 - important ones we're going to use right
80:27 - now there is strings there is arrays but
80:29 - those work really strangely in solidity
80:32 - compared to other languages so just be
80:34 - careful there if you're looking at say a
80:35 - string or an array there's a lot of
80:37 - nuances and kind of details with those
80:39 - okay for now though let's actually not
80:42 - to a string so let's actually just look
80:44 - at the mapping type so the mapping type
80:46 - allows us to take some key and Associate
80:49 - it with some value so I'm going to say
80:51 - public and then we'll just call this map
80:53 - okay now what this means is that I can
80:55 - have some data type for the key and some
80:57 - data type for the value it's very
80:59 - similar to a dictionary or a hash table
81:01 - so when I Define a mapping I need to
81:03 - pick the value for the key or the type
81:05 - sorry for the key and the type for the
81:07 - value so for right now I'm just going to
81:09 - say uint like that is associated with it
81:13 - now just to show you how this works what
81:15 - I can do if I want to set a new mapping
81:17 - is I can say map and then I can put my
81:20 - key like this is equal to my value so if
81:22 - this was a real example I could do
81:24 - something like maybe the map of one is
81:26 - associated with the key of negative two
81:28 - now that means if I accessed map at 1 it
81:32 - would give me negative two okay so this
81:34 - allows you to associate some key with
81:36 - some value very useful you're going to
81:39 - use this all the time anyways that is a
81:41 - mapping again you put the type of the
81:42 - key and then you do this little equal
81:44 - and I guess greater than sign or less
81:46 - than sign associated with whatever the
81:48 - value data type is
81:50 - so right now what I'm going to do is
81:51 - just make a function that lets us
81:53 - actually add a new key value pair to
81:55 - this map so I'm going to say function
81:57 - we'll say set key like that we're going
82:00 - to take in a uint key and we'll take an
82:02 - INT value
82:04 - okay and then we're going to say that
82:06 - this is public and inside of here we'll
82:09 - just say the map at key is equal to
82:13 - Value okay now since this function is
82:16 - actually going to be changing the state
82:18 - of this contract that means we will
82:19 - require a transaction to use this excuse
82:22 - me but since we're in the JavaScript VM
82:24 - we don't need to do that because we're
82:25 - not actually on the blockchain anyways
82:27 - let me quickly go through the syntax so
82:29 - function keyword this lets us make a
82:31 - method or a function inside of the
82:32 - contract or inside of the class whatever
82:34 - you want to call it we then have set key
82:36 - this is the name of that function we
82:38 - have our parameters key and value and
82:40 - we're defining the type that is required
82:42 - for those we then say this is public
82:44 - meaning anyone can call it and we say
82:46 - map key equals value adding a new key
82:49 - value pair to our mapping okay let's
82:51 - deploy this okay so here's our contract
82:54 - let me open this up so we have set key
82:56 - and map now one thing to note is that
82:58 - automatically when you define a variable
83:00 - like this outside of a function so just
83:02 - in the body of the contract it's going
83:04 - to have a getter added for it
83:06 - automatically which means I can access
83:07 - any value in the map so I can do
83:09 - something like map one and we're going
83:10 - to see its default value is zero so in
83:13 - solidity all of our data types have a
83:15 - default value so even though we didn't
83:17 - assign this to something we just declare
83:20 - that it exists if I try to access any
83:22 - key since the value type is int it's
83:24 - always going to give me zero unless we
83:26 - have a different value for that okay so
83:29 - let's just set a key let's set like five
83:31 - with actually let me do this let's set
83:34 - five with like negative 23.
83:37 - I'll click on transact and now to test
83:39 - this I'll see if the key five is
83:41 - associated with negative 23 and it is so
83:43 - we're all good to go now let's do
83:45 - another one let's do like four
83:47 - with negative 10.
83:48 - okay transact let's go four
83:51 - and then notice we have negative 10.
83:53 - perfect there we go okay so now that we
83:57 - have done that what I want to do is talk
83:59 - about addresses and how we actually
84:01 - accept money in the contract as well as
84:04 - pay money out
84:05 - so let's get rid of all this for right
84:07 - now and let's start making some
84:09 - functions that can receive money and
84:10 - send money so what I'm going to do is
84:12 - write function we're going to call this
84:14 - receive and this is going to be an
84:16 - external like this
84:18 - payable function now let's talk about
84:21 - external because we haven't yet seen
84:23 - this so just like the public keyword
84:25 - that we had what external does is it
84:28 - makes it so that this can only be used
84:29 - from outside of the contract so I cannot
84:32 - call this function from within the
84:34 - contract if I did that that would give
84:36 - me an error and the reason for that is
84:37 - because we're going to be accepting some
84:39 - ethereum and when you define this as
84:41 - payable which is what I've done right
84:43 - here this means that we can actually pay
84:45 - money to this function when we call it
84:48 - okay hopefully that makes a little bit
84:49 - of sense we're saying function receive
84:51 - external payable meaning okay we can
84:54 - accept money and we can only accept
84:55 - money from outside of the contract so we
84:57 - can't call this from within the contract
84:59 - whenever you're accepting money you need
85:00 - to put payable when I say money I'm
85:02 - really talking about ethereum anyways
85:04 - inside of here we actually don't need to
85:06 - do anything we can just write the body
85:07 - of this function in fact that's
85:08 - completely fine and now what I'm going
85:10 - to show you is that what we can do is
85:13 - send money to this contract by calling
85:15 - this receive method because it's
85:17 - external pal so what I'm I'm going to do
85:19 - is deploy this
85:20 - okay when I deploy it I'm going to have
85:22 - my contract down here we have this
85:24 - receive function so when we click this
85:26 - red button here what's actually going to
85:27 - happen is we're going to send this
85:30 - amount of whatever this unit is so in
85:32 - this case it's way from this account to
85:35 - our contract okay so this function
85:38 - doesn't need anybody if it's external
85:40 - payable that just means we can pay money
85:41 - to it and so what I'm going to do here
85:43 - is set this to like I don't know we'll
85:46 - go with 10 000 way now way is the
85:48 - smallest amount of ethereum that you can
85:51 - send I believe 10 to the 18 way makes
85:54 - one ether so this is a very small amount
85:56 - anyways it's going to take it from this
85:58 - account in fact let's just send it from
85:59 - another account so we can see if it
86:01 - actually worked let me make it a bit
86:02 - larger and when I click the button again
86:04 - it's going to send that amount from this
86:05 - account to the contract so let's do that
86:07 - and now notice this amount has gone down
86:10 - I have sent some way right
86:13 - there you go makes sense now there was
86:15 - also some gas associated with that
86:16 - that's why it's not perfectly even and
86:18 - the gas limit was right here
86:20 - okay awesome so we said function receive
86:22 - external payable now this contract
86:24 - technically has a certain balance it
86:26 - would be ten thousand way all right so
86:28 - now that we've looked at that I'm going
86:30 - to show you how we can actually view the
86:31 - balance of this contract from a function
86:34 - so I'm going to say function and then
86:36 - this is going to be get balance okay
86:39 - let's spell balance correctly and then
86:41 - we don't actually need anything inside
86:42 - of parentheses and what I can do is make
86:44 - this a public view that returns like
86:49 - this a unit
86:52 - and sorry not units it's going to be a
86:54 - uint and then we can actually write the
86:56 - body of our function now let me just
86:58 - talk about this view keyword because we
86:59 - haven't seen this yet view is saying
87:01 - that this is a read-only method or a
87:03 - read-only function which means it cannot
87:05 - modify the state of our contract so you
87:07 - need to add that when you're writing a
87:09 - function that's going to return a value
87:11 - that's not modifying the state okay
87:13 - that's what we're doing so public view
87:15 - returns unit now inside of here what I'm
87:19 - going to do is I'm going to Simply
87:20 - return
87:22 - the address
87:24 - of this
87:26 - dot bounce now let me talk about this
87:28 - for a second so return I mean pretty
87:30 - straightforward we're turning a value
87:31 - from the function now what address is
87:33 - doing is actually casting this which is
87:36 - referring to the contract itself to an
87:39 - address so this is the address type
87:41 - right we can use this to actually cast
87:43 - this the contract to the address and
87:46 - then on the address type we have balance
87:48 - balance is how much ether is in this
87:50 - account or in this case in this contract
87:52 - now previously you could just write this
87:54 - dot balance however uh in the new
87:57 - version of solidity what you need to do
87:58 - is manually cast this to an address so
88:00 - again this was giving us the address of
88:02 - the smart contract we're then getting
88:03 - the balance and then returning it
88:06 - awesome so let's deploy the contract and
88:07 - see if this works now so I'm going to go
88:09 - here I'm going to send some money to
88:12 - this contract first actually I'll go get
88:13 - balance when I run get balanced notice
88:15 - that we have zero right there's a zero
88:17 - balance and let's now send some money so
88:20 - let's go from this account here and
88:22 - let's just send one ether
88:24 - okay so if I send one like that let's
88:26 - click receive
88:28 - click on get balance and then notice
88:30 - it's going to give me the balance in way
88:31 - okay if I wanted to convert that to
88:33 - Ether I would need to divide it by 10 to
88:36 - the 18 uh what do you call it way or I
88:38 - guess I could just divide it by one
88:39 - ether anyways not super important point
88:43 - is that uh there you go that is how you
88:44 - get the balance okay so now that we've
88:46 - looked at that I want to talk to you
88:47 - about a few Global keywords that we have
88:49 - access to in solidity from our smart
88:52 - contract so remember whenever the smart
88:54 - contract is running it's been initiated
88:57 - whatever it would have had to have been
88:58 - called from a transaction so someone had
89:01 - to send the transaction they had to call
89:03 - a specific function or method and then
89:05 - maybe they sent some ether along with
89:07 - that so we actually have a way to access
89:09 - that information like who sent the
89:11 - transaction so what I'm going to do here
89:13 - is write a smart contract that keeps
89:15 - track of the last person to send it
89:17 - ether so I'm going to make a variable up
89:19 - here I'm going to say this is an address
89:21 - now again the address is just storing an
89:23 - ethereum account address right or the
89:26 - address for an ethereum account so
89:28 - that's the data type there we have
89:29 - access to things like dot balance on an
89:31 - address so I'm going to say address this
89:34 - is going to be public I'm going to say
89:36 - this is last sender so let's go last
89:38 - sender like that and for now we'll just
89:41 - make this equal to nothing okay so it'll
89:42 - have a default value I believe the
89:44 - default address is just a bunch of zeros
89:46 - okay then inside of receive I actually
89:49 - want to set this to be equal to wherever
89:51 - the last sender was so I'm going to say
89:54 - last sender is equal to and then this is
89:57 - where we talk about the global keyword
89:59 - message dot sender so message is
90:02 - something that you can use to access all
90:04 - of the information about the transaction
90:06 - that was used to call this contract now
90:09 - other than message.sender we also have
90:11 - access to message.value now this is
90:13 - going to be the amount of ethereum that
90:15 - was sent with the transaction and we
90:17 - have access to message.gas as well so
90:19 - the amount of gas I believe that's
90:21 - remaining with this transaction okay so
90:24 - let's go and change this back to
90:25 - message.sender and now we can actually
90:27 - use this smart contract and see if it
90:29 - keeps track of who sent the ethereum so
90:31 - I'm going to deploy this
90:33 - okay so we should be deployed let's
90:36 - change to one of these fresh accounts
90:37 - and let's uh actually send one ether in
90:41 - the receiver okay
90:43 - so I'm going to send that one ethereum
90:44 - let's check the balance okay now the
90:47 - balance or sorry this is wrong contract
90:49 - I want to use this contract okay let's
90:51 - send one ether
90:53 - okay so go receive now let's check the
90:55 - balance okay so we have one ether in
90:57 - here and now if I go last sender it
90:59 - gives me the address of the account that
91:01 - actually send this ethereum so now let's
91:04 - change this to be let's go with this
91:06 - account
91:07 - let's send two ether okay get the
91:10 - balance we now have three ethereum
91:11 - inside of here and the last sender has
91:14 - now changed okay there you go that is
91:16 - how you keep track of the actual last
91:18 - sender of ethereum now what I would like
91:21 - to do is I want to show you how to send
91:23 - ethereum from the contract back to a
91:27 - different ethereum account okay because
91:29 - right now what's happening is we're
91:30 - sending ethereum to the contract but the
91:32 - contract's not sending anything back
91:33 - obviously that's not ideal we need a way
91:35 - to you know pay people back from the
91:37 - contract so let's do that so what I'm
91:39 - going to do is write a function I'm
91:41 - going to say function this is going to
91:42 - be pay this is going to be address
91:45 - payable addr and then this is going to
91:48 - be public
91:50 - like this and then payable now let's
91:53 - just quickly go through this so the
91:54 - reason I have the payable here is
91:56 - because whenever I want an address or
91:58 - whenever I want to be able to send
91:59 - ethereum to an address I need to specify
92:01 - it as payable so address payable is
92:03 - different than just regular address this
92:06 - actually allows me now to send the money
92:08 - to this account if I don't have payable
92:10 - then I won't have access to the methods
92:12 - I need for this address to send the
92:14 - money to so just make sure you put
92:15 - payable then we're going to have public
92:17 - payable now since this function is going
92:19 - to be paying money out it's payable if
92:21 - you're going to be sending money or
92:22 - receiving money you need payable then of
92:24 - course this is public which we've
92:25 - already talked about so inside of here
92:27 - there's a few different ways that I can
92:29 - actually send a theorem now some are
92:31 - simpler than others unfortunately though
92:33 - there's a bunch that have kind of some
92:35 - issues with them and that are not
92:36 - recommended to use so the ones you
92:37 - should not use are the following addr
92:40 - dot transfer okay now I know I spelled
92:43 - that incorrectly but you should not be
92:45 - using transfer okay there's some
92:46 - problems with that I'm not really going
92:47 - to get into them and then we have dot
92:49 - send again and there's some problems
92:51 - with this don't use this instead what
92:53 - you need to use is the most complicated
92:55 - one funny enough which is going to be
92:57 - something like this so let me just type
92:58 - it out then I'll explain it this is
93:00 - going to be bytes memory and then it's
93:03 - going to be data and this is going to
93:05 - equal to addr dot call and then we're
93:09 - going to say here that the value is
93:11 - equal to and whatever the amount of
93:13 - ethereum is we want to send and then
93:15 - we're going to call this with one
93:16 - argument
93:17 - okay I believe this is correct let me
93:20 - move this over a bit so we have some
93:22 - more room okay so function pay address
93:24 - payable addr public payable and then we
93:26 - have this kind of crazy line right here
93:28 - so first of all what this is going to do
93:30 - is it's going to decompose the return
93:32 - value of this into two variables first
93:35 - Cent and then second byte memory data
93:38 - now this first one right here is going
93:39 - to be a Boolean variable telling us if
93:42 - this was successful so if it was
93:43 - successful this is going to be true
93:44 - otherwise it's going to be false there's
93:46 - a variety of reasons it could be
93:47 - unsuccessful one of them being you don't
93:49 - have enough money in the contract to
93:50 - send
93:51 - okay then we have bytes memory data now
93:54 - this is going to give us the data of
93:56 - this transaction now you don't really
93:58 - need to worry about this too much in
94:00 - fact I'm not really going to explain it
94:01 - but memory is specifying that we want to
94:03 - store this data which is a reference
94:05 - type in memory again I'm not really
94:08 - going to talk about this much more just
94:10 - write this for now we'll worry about
94:12 - this in a later video then what does
94:14 - this do so what we're doing is we're
94:16 - saying address dot call okay and then
94:18 - inside of curly braces here we're
94:20 - passing the value which is the amount of
94:22 - ethereum we want to send now optionally
94:25 - we can actually choose the amount of gas
94:26 - that we want to send as well so forward
94:28 - with this transaction you don't need to
94:30 - do that you can just leave it to the
94:32 - default value which is what I'm going to
94:33 - do
94:34 - and then we call this whole thing with a
94:38 - string now this is going to be the
94:39 - message that's going to be sent to our
94:42 - uh what do you call it to our
94:43 - transaction or with our transaction so
94:45 - you don't really need to put anything
94:46 - here for right now it just requires one
94:48 - mandatory argument so that's why I put
94:50 - in empty string okay
94:52 - hopefully this makes a bit of sense
94:53 - again address dot call Curly braces with
94:57 - the amount of ethereum that you want to
94:58 - send and then this is setting up the
95:00 - transaction and this is actually going
95:02 - to execute it when you do the kind of
95:04 - parenthesis call right here with the
95:06 - string argument anyways what we can do
95:08 - after this is we can check if this was
95:10 - successful or not and the way we do that
95:13 - is we could use an if statement so ifs
95:15 - do exist in solidity or I can do
95:16 - something like if sent or I can use this
95:19 - fancy thing that we haven't seen yet
95:20 - called require now what require does is
95:23 - similar to an assert statement because
95:25 - it's going to check the value of a
95:26 - condition or a variable and if that's
95:28 - true we're going to continue everything
95:29 - will be fine if that's false it's going
95:32 - to throw an exception and actually tell
95:34 - whoever called this smart contract that
95:36 - there was an issue with that call so I'm
95:38 - going to say require sent and then here
95:40 - I can put an error message so I'll just
95:42 - say error sending money okay like that
95:45 - or error sending let's just go with f
95:48 - okay so again if this is true all is
95:50 - good we will continue if this is false
95:52 - then it's going to tell us that there
95:53 - was an error because we were
95:54 - unsuccessful in sending this ethereum
95:57 - all right now let's add our semicolon
95:59 - and what I can do is deploy this and
96:02 - test it out okay so let's go back here
96:04 - and let's deploy this let me close this
96:07 - contract okay so we have our deployed
96:09 - contract we have pay receive get balance
96:11 - and last sender so let us receive some
96:14 - money first so let's send one ether
96:17 - from this account so let's go receive
96:19 - okay last sender is this get balance is
96:22 - one now let's copy this guy's address
96:25 - right here by clicking on copy let's
96:28 - paste it in here let's click on pay and
96:31 - I think everything should be good we can
96:32 - go back here now
96:34 - and we can see uh if we were paid the
96:37 - ethereum or not all right so I thought
96:38 - something was going wrong until I
96:40 - realized that we actually are only
96:42 - sending a hundred way here rather than
96:44 - an entire ethereum which is what I
96:46 - thought we were going to be sending so
96:48 - what I'm going to do is change this to
96:49 - one ether now ether is actually a
96:51 - built-in word or built-in keyword in
96:53 - solidity and it will just multiply this
96:55 - by 10 to the 18 so that will give me I
96:58 - guess 10 to the 18 way right so one
97:01 - ether anyways I'm going to change that
97:02 - to one ether so now this will pay one
97:04 - ether from this function okay so let me
97:07 - redeploy here and let's close this
97:10 - okay and now we have our contract so
97:12 - let's receive some money so let's go
97:13 - from this account let's just send like
97:16 - five ether
97:17 - okay so let's go receive
97:19 - what's the balance
97:20 - five ether now let's copy one of these
97:24 - okay and we will pay it and let's see if
97:28 - this is all good I'll move up the
97:29 - console
97:30 - and looks like it's sent fine okay so
97:33 - now let's go here and we should see that
97:36 - in one of these accounts we have okay
97:38 - almost 101 ether right so I have
97:40 - 100.9999 because there was gas
97:42 - associated with the transaction so we
97:44 - didn't get a full one ether we got a
97:46 - little bit less
97:47 - perfect there you go that is how you
97:49 - send money using I guess this right here
97:52 - using this line okay great so now that
97:54 - we have that what I want to do is I want
97:56 - to end by quickly writing kind of an
97:58 - example of a bank that allows people to
98:00 - send ethereum to the smart contract and
98:02 - then withdraw up to the amount of money
98:05 - that they had sent to the contract so if
98:07 - I send one ether I can withdraw up to
98:09 - one ether from the contract as soon as I
98:12 - try to withdraw more it's going to tell
98:13 - me hey you don't have a sufficient
98:14 - balance so kind of just like a very
98:15 - simple bank account so let's go ahead
98:18 - and do that all right so let's get into
98:19 - this example of implementing kind of the
98:21 - basic bank accounts so I'm actually just
98:23 - going to get rid of all this we can just
98:25 - rewrite it this will be good practice so
98:28 - I'm going to start by making a mapping
98:29 - and this mapping is going to allow me to
98:31 - associate an amount of ethereum with an
98:34 - address so that way I'll know how much a
98:36 - specific account has sent so far and so
98:38 - I can regulate how much they can
98:39 - withdraw so what I'm going to do here is
98:42 - say mapping and this is going to go
98:45 - address like that and then this will go
98:48 - to an unsigned integer which will be the
98:50 - amount of way that they have sent so
98:52 - amount of ethereum okay then I will call
98:55 - this balances
98:57 - and I can actually manually make this
98:59 - private if I want now when I make this
99:01 - private what that means is there won't
99:02 - be a default getter for this so I can't
99:04 - easily just access the balance of a
99:07 - specific account instead I'll have to
99:09 - use one of the methods or functions that
99:11 - we Define okay
99:13 - now we need some way to receive money so
99:15 - let's write that we're going to say
99:17 - function and we'll say deposit
99:20 - okay and then this is going to be a
99:24 - actually external
99:27 - and then payable okay now what I'm going
99:30 - to do is I'm going to say balances act
99:32 - and then this will be message dot sender
99:34 - which is going to be the address of the
99:36 - sender of the transaction is equal to or
99:39 - sorry plus equal to message dot value
99:42 - okay so remember all of the keys here
99:45 - are going to have a default value of
99:46 - zero so even if this address doesn't
99:49 - kind of exist yet in the balances it's
99:51 - going to have a value of 0 when I access
99:54 - it so I'm going to add message.value
99:56 - which is the amount of ethereum they
99:58 - deposit okay then of course if this
100:00 - already existed I would just be adding
100:01 - to it whatever the amount of ethereum is
100:03 - they deposited in this transaction
100:05 - that's all I need for here I'm just
100:06 - adding this to the balances then what
100:09 - I'm going to do is say function withdraw
100:12 - and this is going to need to take in an
100:15 - address to withdraw to and in fact I
100:17 - don't necessarily need to do that uh
100:20 - because what I could do is just use the
100:21 - message.sender address so whoever was
100:24 - withdrawn whoever sent the transaction I
100:26 - just automatically give the money to
100:27 - them but instead what I'll do here is
100:29 - just put in an actual parameter so that
100:31 - you could technically withdraw your
100:33 - money to someone else's account
100:34 - hopefully that makes sense but you'll
100:36 - see what I mean so I'm going to say
100:37 - address payable and then this will be
100:38 - addr and then we'll say this is going to
100:41 - be a public and then this will be a
100:44 - payable function like that okay so what
100:47 - I need to do here is I need to check
100:49 - that they have a sufficient balance in
100:51 - the uh the balances before they can
100:53 - withdraw something I also need to take
100:55 - in the amount that they're going to
100:56 - withdraw so I'm going to say uint amount
100:58 - like that and this will be the amount in
101:00 - way that they want to take it okay so
101:03 - we'll say withdraw payable amount okay
101:05 - great that's fine now inside of here
101:07 - what I'm going to do is I'm going to
101:09 - confirm that they have a sufficient
101:10 - balance before I let them withdraw so
101:12 - I'm going to say require and I'm going
101:15 - to say balances at addr is greater than
101:19 - or equal to the amount that they want to
101:21 - take out
101:22 - okay perfect so we'll do that then I'm
101:24 - actually going to send the ethereum to
101:26 - them that they want to withdraw so we're
101:29 - going to say I guess this is going to be
101:32 - bull sent and then this will be bytes
101:37 - memory and then what was this data is
101:40 - equal to and then addr dot call and then
101:44 - this is going to be value colon
101:46 - amount okay and then I think I can just
101:50 - call this like that
101:52 - okay so that's good now that I have that
101:55 - I'm going to confirm that they sent it
101:57 - successfully so I'm going to say require
102:00 - sent and we'll say
102:03 - could
102:04 - not withdraw okay we got to spell this
102:08 - properly this is just okay there we go
102:11 - could not withdraw and then what I'm
102:13 - going to do here after I successfully
102:15 - check if they withdrew or not or after I
102:17 - check that they successfully withdrew
102:19 - I'm going to subtract their balance I'm
102:21 - going to say balances and then this is
102:23 - going to be at message dot sender minus
102:26 - equals the amount
102:28 - okay I think that should be good now
102:30 - let's just run through this and make
102:32 - sure we understand so first we're
102:33 - requiring that their balance is greater
102:36 - than the amount so if the balance that
102:38 - they currently have in our kind of bank
102:39 - here is not greater than the amount then
102:41 - we actually need to give them an error
102:43 - message and we'll say in
102:45 - sufficient funds like that okay I think
102:49 - that's how you spell insufficient that
102:51 - should be fine all right and then what
102:52 - we're doing is we're trying to actually
102:53 - send this amount to them so if they have
102:55 - a sufficient balance we'll try to send
102:57 - it to them if this for some reason does
102:59 - not work then we'll tell them that they
103:00 - could not withdraw and we'll keep the
103:02 - balance here right because if we didn't
103:03 - send it then the balance is not gone we
103:05 - still have the money in the contract
103:07 - otherwise we will subtract their balance
103:10 - and then we're good to go okay so now we
103:12 - have deposit and withdraw and if we want
103:14 - to we can write one more function here
103:16 - let's go function get
103:18 - balance and this will just give us the
103:20 - balance of a contract okay so let's just
103:23 - go
103:24 - public
103:26 - view
103:27 - returns unit
103:30 - okay and then let's return the address
103:34 - of this
103:36 - dot balance
103:38 - and that should be good
103:40 - okay now we could also write something
103:42 - that allows us to get the the balance of
103:45 - a specific address or we could just make
103:46 - this public but for now I'm going to
103:48 - leave it private okay hopefully that is
103:50 - all good now what I'm gonna do is just
103:52 - deploy this contract so let's deploy it
103:54 - let me get rid of this one now what we
103:56 - can do is deposit some money so let's go
103:58 - to this account let's deposit 10 ether
104:01 - okay so we're going to deposit uh that
104:03 - should have happened successfully let's
104:05 - check the balance looks like we have 10
104:07 - ether now let's see if we can withdraw
104:09 - so let me copy this address okay
104:13 - so I'm going to paste that in there in
104:14 - fact let's make this larger
104:16 - and for the amount I wish I could copy
104:18 - this uh let's just go
104:20 - with a bunch of zeros here I don't think
104:22 - I can write F directly in here otherwise
104:24 - that'd be useful okay so let's click on
104:26 - transact and let's look at our console
104:28 - here and see if this was good okay it
104:30 - looks like we successfully sent the way
104:32 - so now if we go we see we have 85 ether
104:34 - rather than 84 which is what we had
104:36 - before so let me see if I can make this
104:37 - something like five now and click
104:39 - transact okay looks like that was
104:41 - successful I guess we're not passing
104:43 - enough zeros okay now we have 85.599
104:46 - okay now let me try to send an entire
104:49 - five ethereum which we know we don't
104:51 - have for this person
104:52 - actually maybe we do because I think we
104:54 - transacted 10 ethereum sorry but let's
104:56 - try this okay transact and that was
104:58 - successful now let's try this again and
105:00 - notice that when I try to do it again I
105:02 - don't have enough ethereum for this
105:03 - balance so I get insufficient funds as
105:06 - my error message okay if I look at the
105:08 - balance of here we have 4.4 ethereum
105:11 - left in the contract so now let's try to
105:14 - do this from another account so let me
105:16 - copy this address and let's see what
105:17 - happens if I try to withdraw
105:20 - say one ethereum
105:22 - from this address
105:24 - okay if I do that notice we get an error
105:25 - it says uh insufficient funds because
105:27 - this address is not yet deposited any
105:29 - ethereum so let's now deposit some so
105:32 - let's make this one ether
105:34 - let's click deposit okay now let's try
105:36 - to withdraw and notice we're able to
105:37 - withdraw that successfully all right so
105:39 - that is all I have to show you for this
105:41 - example here hopefully that was a decent
105:43 - introduction to solidity I understand
105:45 - there was a lot of stuff covered in this
105:47 - video I don't expect you to know all of
105:49 - it I just wanted to kind of show you how
105:51 - to create a basic smart contract how to
105:53 - send ethereum receive ethereum and then
105:55 - hopefully give you a bit of an idea
105:56 - behind the theory of how smart contracts
105:59 - actually work in the next video we're
106:01 - going to continue learning more about
106:03 - solidity I'm going to show you some more
106:04 - advanced things that we can do and then
106:06 - in future videos we'll talk about some
106:08 - of the limitations of solidity and how
106:10 - to make things more affordable using
106:11 - cartesi which is the sponsor of this
106:13 - video and this series hope you guys
106:15 - enjoyed if you did make sure to leave a
106:16 - like subscribe to the channel and I will
106:18 - see you in another one
106:19 - [Music]
106:21 - hello everybody and welcome to another
106:24 - video in this blockchain for beginners
106:26 - tutorial Series in this video we're
106:28 - going to be continuing from the last
106:30 - video and learning more about solidity
106:32 - once we learn a few new topics then
106:34 - we're actually going to work on an
106:36 - auction where we're going to be
106:37 - auctioning an nft now this will work
106:39 - with any type of nfts this is really
106:41 - really cool and if you're interested in
106:43 - nfts you're going to learn a little bit
106:44 - about how they work so with that said
106:46 - we'll get into the content in a second
106:48 - but I do need to thank cartesi again for
106:50 - sponsoring this video and this series
106:52 - they are an awesome company they've been
106:54 - helping me come up with the content for
106:56 - this series and they have a bunch of
106:58 - scaling solutions for ethereum and for
107:00 - developing smart contracts that we're
107:02 - going to look at in a future video
107:03 - regardless let's go ahead and get into
107:05 - the content alright so I'm back in remix
107:08 - and in front of me I have the example
107:10 - that we finished in the last video which
107:12 - is kind of a mock bank account now what
107:14 - I'm going to do is just give you a quick
107:15 - recap of everything that's in this
107:17 - contract so we understand the syntax and
107:19 - get a quick refresher then we'll look at
107:21 - some new solidity features and we'll
107:23 - actually move into working on that
107:25 - auction which is going to be the bulk of
107:26 - the video okay so right now we can see
107:28 - we're inside of a DOT Sol file now the
107:31 - dot Sol stands for solidity and that's
107:33 - the extension you need for your solidity
107:35 - smart contracts now at the top of our
107:37 - contracts we need a pragma line now the
107:39 - pragma line is going to tell solidity
107:41 - what compiler version we should use so
107:43 - in this case we're using 0.8.10 to see
107:45 - the compiler versions you can go to the
107:47 - solidity compiler extension click here
107:49 - and then it will show you the versions
107:51 - in this case 0.8.10 is one of the latest
107:53 - so that's the one that we're going to
107:55 - use great we then Define our contract we
107:57 - say contract my contract open the curly
108:00 - brace and close the curly brace and
108:02 - inside of here is the content of our
108:04 - contract now it's worth noting that you
108:06 - can Define multiple contracts in one
108:07 - solidity file and you can have stuff
108:10 - like contract inheritance that's a
108:12 - little bit complicated we don't need to
108:13 - look at that here but just wanted to
108:15 - mention them okay so inside of our
108:17 - contract here we start by defining what
108:18 - most of you would consider a class
108:20 - attribute this is just going to be
108:22 - actually a private member of this class
108:24 - because we've defined it as private
108:25 - anyways this is a mapping type now the
108:28 - mapping type is like a hash table or a
108:30 - dictionary where we have some key that
108:32 - can be associated with some value now in
108:34 - this case we're having an address this
108:36 - is going to be an ethereum address being
108:37 - associated with a uint so an unsigned
108:40 - integer we then denote this as private
108:42 - meaning we can't directly access this
108:44 - from outside of the contract and then we
108:46 - have balances that's just the name of
108:48 - this mapping okay now we have a function
108:50 - the function is called deposit it's
108:52 - denoted external and payable now
108:55 - external says that we can only call this
108:57 - function from outside of the contract so
108:59 - I couldn't go here and do something like
109:01 - deposit that would be invalid because
109:03 - this is an external function then we
109:05 - have payable payable is saying that this
109:07 - is either going to be sending money to
109:09 - someone or receiving money or
109:11 - specifically ether and in this case
109:13 - since we're going to be getting money we
109:14 - have to make it payable then what we do
109:16 - inside of deposit is we say balances at
109:19 - message dot sender now message.sender is
109:21 - going to be the address of the sender of
109:24 - the transaction who's sending money to
109:26 - this contract so essentially whoever
109:28 - invoked the call to this contract or
109:31 - made the transaction to this contract
109:33 - it's going to be there address we're
109:35 - adding that as a key to balances and
109:37 - then we're going to increment the value
109:39 - here by message.value now message.value
109:42 - is going to store the amount of ether
109:44 - that they sent to this contract and the
109:46 - reason why we can do this is because the
109:48 - default value of all of our uins inside
109:51 - of our mappings is going to be zero so
109:53 - even if this sender does not already
109:54 - exist in the mapping we'll simply make
109:57 - the value equal to whatever the
109:59 - message.value is because the default
110:01 - value is zero hopefully that makes sense
110:03 - that's explained in the previous video
110:04 - in case you are confused regardless we
110:07 - now have withdraw so withdraw is going
110:09 - to take in an address payable this is
110:12 - going to be our addr that's going to
110:13 - take in uint amount now this means that
110:16 - we need to pass an address to this
110:18 - withdrawal function this is the address
110:19 - that we want to withdraw funds to then
110:22 - we have u in to mount this is the amount
110:24 - of funds that we want to withdraw from
110:25 - the contract now this is a public
110:27 - payable function when we say this is
110:30 - public that pretty much means it can be
110:31 - called from anywhere and then we have
110:33 - payable and again what payable means is
110:35 - we're either going to be sending money
110:37 - out or receiving money so of course we
110:39 - need to denote this function as payable
110:41 - okay we then have a require statement
110:43 - and what the require statement is going
110:45 - to do is it's going to check if this
110:47 - condition is true and if it is not true
110:49 - then it's actually going to raise an
110:51 - exception and the exception is going to
110:52 - be insufficient funds that means we're
110:55 - actually going to cancel the entire
110:57 - contract call everything that would have
110:59 - happened is going to be reverted I'm
111:01 - going to talk about this more in a
111:02 - second and essentially this transaction
111:04 - is going to fail because this condition
111:06 - was not satisfied okay so you use
111:08 - require when you want to ensure that
111:10 - something is true before proceeding in
111:12 - the contract okay so we're requiring
111:14 - that the balance of the address is
111:16 - greater than or equal to the amount that
111:17 - we want to withdraw makes sense if we
111:19 - don't have that then the error or the
111:21 - exception is insufficient funds so next
111:24 - we're actually going to send money from
111:25 - the smart contract to this address if
111:28 - they had sufficient funds to withdraw so
111:30 - we're going to say bull sent bytes
111:31 - memory data is equal to 80dr dot call
111:34 - and then we're putting the amount that
111:36 - we want to withdraw and then we're
111:37 - actually calling this transaction now if
111:39 - you're confused on how this line works I
111:41 - spent about three or four minutes
111:42 - explaining it in the last video so you
111:44 - can go back and watch that essentially
111:46 - all this is doing is sending money to
111:48 - this address this is the amount of money
111:50 - that it's going to be sending or the
111:51 - amount of ether great then we have this
111:54 - bull sent now this bull sent is going to
111:56 - be equal to true if we successfully sent
111:58 - this otherwise it's going to be equal to
112:00 - false so if we were not able to
112:02 - successfully send the money some error
112:04 - occurred there then we're just going to
112:05 - raise the exception could not withdraw
112:07 - otherwise what we're going to do is
112:09 - we're going to update the balances so
112:10 - we're going to say balances at
112:12 - message.sender minus equals the amount
112:14 - to make sure they can't just keep
112:15 - withdrawing the same amount of money
112:17 - it's actually going to subtract from
112:18 - their current balance when they withdraw
112:21 - great then we go to this function so
112:23 - this is get balance now let's say public
112:25 - view function now again public means we
112:27 - can call this from anywhere and view
112:29 - actually means that this is only going
112:31 - to be returning or accessing state from
112:34 - this contract it's not going to be
112:35 - modifying it so this means we can call
112:37 - this get balance function without
112:39 - actually having to make a transaction
112:41 - which pretty much means this is free to
112:43 - call so this is a good point in time to
112:45 - remind you that whenever we're just
112:46 - accessing the state of a contract this
112:49 - is free we can just query the state of
112:50 - the contract we don't need to pay for
112:52 - this however if we're going to be
112:53 - actually modifying the state then that
112:55 - requires a transaction that transaction
112:57 - needs to be mined and well that means
112:59 - it's going to cost us some money at
113:01 - least in gas and potentially ethereum if
113:03 - what we're doing requires that we send
113:05 - ethereum Okay so let's continue
113:07 - explaining this we then have returns and
113:09 - then you wins now returns is just
113:11 - stating what this function is going to
113:12 - return we're saying u n standing for
113:14 - unsigned integer and then here all we're
113:16 - doing is we're returning the address of
113:18 - this now this is just going to be the
113:20 - contract we're just going to cast this
113:22 - to its actual address and then we're
113:24 - going to get the balance whenever you
113:25 - have an address you can access the
113:26 - balance by just using dot bounce there
113:29 - you go that is everything that we did
113:31 - inside of this contract so now that
113:33 - we've talked about all of this I just
113:35 - want to spend a second talking about
113:36 - exceptions because we've seen them in
113:38 - this contract but I haven't actually
113:40 - talked about exactly what they do and
113:41 - how they work so in solidity we have a
113:44 - few different ways to actually throw an
113:46 - exception or to cause an exception to
113:48 - occur now an exception is pretty much an
113:50 - error that's going to occur in our
113:52 - program and all exceptions in solidity
113:54 - are State reverting now what that means
113:56 - is if there's ever an exception at any
113:59 - point in time during the transaction
114:01 - call then this is going to revert the
114:03 - state back to what it was previously any
114:06 - changes you've made up until that point
114:07 - will be completely removed so just to
114:10 - give you an example here let's say that
114:12 - I did something like balances at one is
114:16 - equal to two now I know this makes no
114:17 - sense but let's say I did this right
114:19 - here and then I come to this require
114:21 - line and this actually ends up raising
114:23 - an exception because Cent is equal to
114:25 - false well if that's the case this line
114:27 - will be completely reverted we won't
114:30 - actually have done that operation it
114:31 - will be undone and reverted back to what
114:33 - it was before so just worth noting
114:35 - whenever an exception occurs any of the
114:38 - state in the contract that's been
114:39 - changed is going to be reverted now
114:41 - require as I'm kind of alluding to here
114:43 - does cause an exception right so if the
114:46 - condition here is not true then it
114:47 - raises an exception and the message for
114:49 - that exception is going to be whatever
114:51 - we put here now there's a few other ways
114:53 - that we can raise exceptions in solidity
114:55 - I'll quickly show them to you although
114:56 - we're not really going to look at an
114:57 - example of them
114:59 - so one way to raise an exception is to
115:01 - use revert now revert actually allows us
115:04 - to just directly uh revert the entire
115:06 - contract State again this is just going
115:09 - to raise an exception exactly like
115:10 - require will except inside of here we
115:13 - can just put our error message we don't
115:15 - actually need to put any condition so if
115:17 - we ever encounter a revert in the
115:19 - program we're just immediately going to
115:21 - raise an exception the exception message
115:23 - will be this and again that's going to
115:25 - revert the state because that's what all
115:26 - exceptions do in solidity okay so that's
115:29 - revert now another thing that we have is
115:32 - assert now assert is similar to require
115:34 - in fact it works in the exact same way
115:37 - except it's designed to be used when you
115:39 - want to check in variants rather than
115:41 - checking input validation so I'll show
115:43 - you here I could do something like
115:45 - assert uh true
115:47 - is equal to true now of course that's
115:49 - always going to be true but you get the
115:52 - idea now if this condition was false
115:54 - what would happen is we would raise an
115:55 - exception with this as the error message
115:57 - now assert and require are pretty much
116:00 - identical but the reason you use assert
116:02 - is because you're checking an invariance
116:04 - if you don't know what that means don't
116:05 - worry about it and if we're using
116:07 - require we're using that when we want to
116:09 - check input validation okay so that's
116:11 - why we're using require here because we
116:13 - want to ensure that the amount that they
116:16 - passed in is valid now in this case we
116:18 - could probably actually replace this
116:20 - require with an assert it's not a huge
116:22 - deal and there's actually not really any
116:24 - formal recommendation on which one you
116:26 - should use but it's kind of the standard
116:27 - to just use assert when you're checking
116:29 - an invariant and require when you're
116:31 - checking input validation so in this
116:33 - case based on what I'm saying we would
116:34 - use assert here because this is an
116:36 - invariant but we also can just use
116:38 - require like I had before that's
116:39 - completely fine anyways this isn't super
116:42 - important but I just wanted to show you
116:43 - those methods in case you see them in
116:44 - other contracts alright so that's almost
116:46 - everything for exceptions one more thing
116:48 - to note here is that the only thing that
116:50 - will not be reverted if an exception
116:53 - occurs is low level calls like this
116:55 - addr.com now I can't really show you
116:58 - what the other calls are because we
116:59 - haven't seen them but essentially if you
117:01 - were to send money to someone
117:02 - successfully and then later on in the
117:05 - contract there's an exception that
117:06 - occurs that's not going to be reverted
117:09 - you just can't revert that because once
117:11 - the funds are transferred well you can't
117:12 - really just transfer them back and so if
117:14 - I did something like this
117:16 - and let's say that this was successful
117:18 - then that means this is not going to be
117:20 - reverted now everything else will be
117:22 - reverted this balances will be changed
117:24 - back but this isn't going to be reverted
117:26 - the ethereum that was sent to that
117:28 - account is not going to be sent back to
117:29 - the smart contract okay there's some
117:31 - good reasons for that but that's worth
117:33 - noting
117:34 - now a few other things to mention here
117:37 - with exceptions exceptions are cascading
117:40 - now that means if I have an exception
117:42 - that occurs in another smart contract
117:44 - that I'm calling from this smart
117:46 - contract that's going to mean that the
117:48 - state of this contract as well as the
117:51 - state of the other one are going to be
117:53 - reverted so it's kind of hard to show
117:54 - this but let's say I make a contract
117:57 - and I call this my contract
118:00 - two like this and let's just make some
118:02 - functions so we can do something like
118:05 - function test and then just make this
118:08 - public view
118:11 - returns you ins okay and then maybe what
118:15 - I do here is I just say revert okay so
118:17 - that's what I do now if I call this
118:20 - function okay from inside of here then
118:23 - even though it's happening inside of
118:25 - this contract the exceptions occurring
118:27 - here it's going to Cascade into this
118:29 - contract meaning that if any of the
118:31 - state was changed inside of here that's
118:33 - going to be reverted and same with any
118:35 - of the state inside of my contract too
118:37 - hopefully that makes sense but just keep
118:40 - in mind that exceptions Cascade so even
118:42 - if you have like 10 contracts all
118:44 - calling each other and then in the 10th
118:46 - contract an exception occurs every
118:48 - single one of the contracts that we're
118:49 - dealing with that contract are going to
118:51 - get the cascading exception and all of
118:53 - them are going to have their state
118:54 - reverted and the transaction will fail
118:57 - now just to note here the reason why
118:58 - we're getting this error is because I
118:59 - didn't have the semicolon of course
119:01 - revert is fine I can put this here
119:03 - although this doesn't really make much
119:04 - sense because why would you just just
119:05 - revert inside of a function alright so
119:08 - now that we've talked about exceptions
119:09 - what I can do is start showing you some
119:11 - new features in solidity and the first
119:13 - thing I want to do is show you a
119:14 - Constructor so I'm just going to clear
119:16 - everything that's inside of this
119:18 - contract and I'm going to write a public
119:19 - variable here so I'm going to say let's
119:22 - go with address and this is going to be
119:25 - public and then I'm going to say that
119:27 - this is the owner of the contract
119:30 - so what I'm going to show you is a
119:31 - Constructor now a Constructor is simply
119:34 - a special function that's a part of a
119:36 - class or in this case a contract that's
119:38 - going to be called when the contract is
119:40 - initialized now in solidity your
119:42 - Constructor will be called exactly one
119:44 - time and just like any other language
119:45 - Constructor you can accept parameters in
119:48 - here you can do some setup steps and
119:50 - well you'll see how this works so the
119:51 - way you implement a Constructor in this
119:53 - version of solidity is Constructor
119:55 - open and close parentheses open and
119:57 - close curly brace and then inside of
119:59 - here you can do whatever you want so in
120:01 - this case I'm just going to say my owner
120:03 - is equal to the message dot sender now
120:05 - the reason I'm doing this is so that I
120:07 - can keep track of who actually created
120:09 - this contract so when I create a
120:10 - contract I have a message dot sender
120:12 - whoever sent the transaction to actually
120:14 - create the contract so this is perfectly
120:17 - valid I can say my owner is equal to the
120:19 - message.sender and now whoever deployed
120:21 - the contract will be the owner and I'll
120:23 - be keeping track of that inside of this
120:25 - public variable on the contract okay
120:28 - pretty straightforward that's how that
120:30 - works now again this is how you do the
120:32 - Constructor you can only have one of
120:34 - them and this will be called exactly one
120:36 - time and only one time when the contract
120:38 - is deployed this isn't going to be
120:40 - called every single time a transaction
120:42 - is sent to the contract it's only called
120:44 - when it's deployed the very first time
120:46 - so let me show you how this works let's
120:48 - go and actually deploy this to the
120:50 - JavaScript VM let's click on deploy okay
120:54 - we have our contract when I click on
120:56 - owner it's going to give me the address
120:58 - of this account right here which is the
121:00 - one that I'm using now let's try
121:01 - deploying from this account
121:03 - okay so deploy my contracts down here
121:06 - owner now it's giving me the other own
121:08 - pretty straightforward that is how the
121:10 - Constructor works and this is a pretty
121:12 - common thing that you'll want to do is
121:13 - keep track of who actually deployed the
121:16 - contract now another thing you can do in
121:18 - here is accept parameters so maybe I
121:20 - just want to accept a uint and let's
121:21 - just go with something like test for now
121:24 - again this can really be anything okay I
121:27 - want this to be test and then what I
121:29 - will do is say you int public and let's
121:33 - just go with I don't know V I'm just
121:36 - picking random names for now and I can
121:38 - do something like V is equal to test
121:40 - that's completely fine I can access the
121:42 - value of this parameter so now let's get
121:44 - rid of these contracts all right so now
121:46 - we can deploy our contract and notice
121:48 - where the deploy button is it's actually
121:50 - giving me a parameter that I need to
121:52 - pass here it's saying task this is a
121:53 - uint256 so I'm going to do something
121:55 - like two hit transact now I go to my
121:58 - contract I have owner and I have V and I
122:01 - can see V is equal to two there you go
122:03 - that is the basics of the Constructor
122:05 - now of course you can have multiple
122:07 - arguments if you would like or multiple
122:08 - parameters sorry and do whatever you
122:10 - please with them great so what I'm going
122:12 - to do now is just get rid of everything
122:15 - inside of here and I'm going to start
122:17 - talking to you about a new thing which
122:18 - is called a pure function now we've
122:20 - looked at view functions we've looked at
122:22 - payable functions internal functions
122:24 - external functions public functions now
122:26 - we want to look at pure now a pure
122:28 - function is pretty straightforward but
122:30 - it is simply a function that is not
122:32 - going to do anything with the state of
122:34 - the contract you can kind of think of it
122:36 - like a static method because it has no
122:38 - access to the internal state of the
122:41 - contract it just does some type of
122:42 - computations then returns some value so
122:45 - I'm just going to write a function here
122:46 - I'm going to say function and this will
122:48 - be something like add to now we will
122:50 - make this a public and then this will be
122:53 - pure function and this is going to
122:56 - return a uint like that now I'm going to
123:01 - take as a parameter here the uint X and
123:05 - all I'm going to do is just return like
123:08 - this X Plus 2. okay very straightforward
123:11 - but this is a pure function now as I
123:13 - said a pure function is not going to
123:14 - modify or access the state of this
123:16 - contract it's just going to be
123:18 - performing some type of computation that
123:21 - doesn't rely on the actual contract
123:22 - internal state so just like accessing
123:25 - the data from a contract this is going
123:27 - to be free as well we don't need to pay
123:29 - to do this and let me prove this to you
123:31 - so if I go to my injected web 3 now I'm
123:33 - connected to the godreli test Network
123:35 - and I do deploy this okay it's going to
123:39 - ask me for a I guess transaction because
123:41 - when I deploy I need to pay for that and
123:44 - then let's give this a second okay we
123:46 - can see that our contract is deployed
123:48 - now let's do something like add to five
123:50 - notice it gives me the value 7 back I
123:52 - didn't need to add a transaction to be
123:54 - able to do this okay so whenever you
123:56 - have a view or a pure function these are
123:58 - free you don't need to have a
123:59 - transaction to call these so if you ever
124:01 - just want some type of utility functions
124:03 - associated with your contract then you
124:05 - make them pure okay hopefully that makes
124:07 - sense that's all I need to cover with
124:09 - pure okay so now that we've gone through
124:11 - that we can start getting into the
124:13 - important stuff which is events so I'm
124:15 - actually going to hop over to the
124:16 - drawing tablet to explain to you what
124:18 - events are and then we'll start
124:19 - implementing them when we work on the
124:21 - auction all right so I'm now on my
124:23 - drawing tablet I'm going to start
124:24 - explaining events to you but before I
124:26 - can do that I need to talk to you about
124:27 - why we need them so in front of me I
124:30 - have a smart contract now this is going
124:31 - to be our auction contract and on the
124:33 - auction we're going to have some
124:35 - function called start now of course
124:36 - we're going to have some other functions
124:38 - as well but for now just imagine we have
124:40 - start and what start is going to do is
124:42 - it's going to attempt to start the
124:43 - auction so it's going to modify some of
124:45 - the state and then it's going to return
124:46 - a value indicating to us whether or not
124:49 - this was successful so we're expecting
124:51 - this to be a boo let me just write this
124:53 - right here indicating it's going to
124:55 - return a boom okay that's great so now
124:58 - we want to start the auction so let's
124:59 - say we have some account so account one
125:01 - like this we know since this is going to
125:04 - modify State we need to make a
125:05 - transaction to the auction to be able to
125:08 - start this so I'm going to make a
125:10 - transaction we're going to call start on
125:12 - here and then what we're expecting is
125:14 - that we're going to get some return
125:15 - value here indicating to us whether or
125:17 - not this started successfully well if
125:19 - we're just working on our JavaScript VM
125:21 - then we know that it's actually going to
125:23 - work successfully we're going to be able
125:24 - to get a return value we'll see
125:26 - something like true or we'll see
125:28 - something like false however if we're
125:30 - working on a real blockchain we're
125:33 - actually not able to return something
125:35 - from a function that's modifying the
125:37 - state back to our account so essentially
125:40 - whenever we're making a transaction we
125:42 - can't return data back to that
125:44 - transaction now this actually makes
125:46 - sense if you look at how transactions
125:48 - work but for now you really need to
125:50 - understand that if you ever make a
125:51 - transaction to a Smart contract that
125:54 - contract cannot return you any day data
125:57 - now it can try it can have a return
125:58 - statement but you're not going to be
126:00 - able to view that return data from the
126:02 - transaction so really we have to imagine
126:04 - that this is going to be a one-way
126:06 - operation where we're just going to call
126:08 - start now if an exception occurs we're
126:10 - going to be notified of that however if
126:12 - an exception doesn't occur we're not
126:14 - going to get any return value so trying
126:15 - to do something like this is not going
126:17 - to work on a real blockchain now that's
126:20 - a pretty big problem right because in a
126:22 - lot of situations when I make a call or
126:24 - I make a transaction story to my smart
126:26 - contract I probably want to get a return
126:28 - value I need some information I want to
126:30 - know if this started successfully
126:32 - however we can't have a return value so
126:35 - how do we get around this problem well
126:37 - the way we get around this problem is
126:38 - with events so what a smart contract can
126:41 - do is it can actually emit events now
126:44 - that means that what we can do from
126:45 - auction is when we start this we can
126:48 - create or emit something known as an
126:51 - event and this event can have a return
126:54 - value that we might want this account to
126:57 - be able to see so we can emit an event
126:59 - that says something like started
127:01 - and then maybe we can put the time that
127:03 - this started out and we can put if it
127:05 - happens successfully or not so we could
127:06 - but true or alternatively we could put
127:09 - false now these events will be stored on
127:11 - the blockchain however they're going to
127:12 - be stored in a different way than the
127:14 - data associated with your contract so
127:17 - any of the variables you would have
127:18 - defined or kind of the state of the
127:20 - contract is said to be in storage these
127:23 - events are not going to be in storage
127:24 - they're going to be stored as a part of
127:26 - the transaction history on the
127:28 - blockchain so that makes them a little
127:30 - bit less accessible however they are
127:32 - much cheaper to use because of the way
127:34 - that they're stored so I'm not going to
127:35 - get into this too much but essentially
127:37 - just understand that your events are
127:39 - stored in a different way that makes
127:41 - them much cheaper to actually store
127:43 - although they are a little bit harder to
127:45 - access so that means that you usually
127:46 - use a third-party tool maybe something
127:48 - like etherscan to actually read and
127:50 - query these events because it's not as
127:53 - simple to go directly look at them like
127:55 - it is for the data on the contract and
127:57 - so we emit this event and then this
128:00 - account here or some external client
128:02 - that's off the blockchain is able to
128:04 - view these events and subscribe to them
128:06 - so they'll be notified if an event
128:08 - occurs now I'm going to get into a
128:10 - detailed example in a second but for now
128:12 - just understand that whenever we have a
128:14 - transaction our smart contract cannot
128:16 - return a value to that transaction
128:18 - instead what it can do is emit an event
128:21 - this event will be stored off the
128:23 - blockchain you can kind of think of
128:24 - these events as a log right
128:26 - we'll be able to then view those logs
128:28 - off of the blockchain and we can search
128:30 - for specific data inside of those logs
128:33 - and subscribe to events which means
128:35 - we'll be notified when an event occurs
128:37 - now just an important note here this is
128:40 - not the case the so the no return value
128:42 - thing is not a case if we're making a
128:44 - call not a transaction now I understand
128:46 - this is a bit confusing but if I'm
128:48 - making a call to a function that does
128:50 - not modify the state so that doesn't
128:52 - require that I spend money on it doesn't
128:54 - need a transaction essentially I'm just
128:55 - querying the state then of course I can
128:57 - get a return value right if all I want
128:59 - to do is just get some data that's
129:01 - stored in the state of the auction
129:02 - that's fine I can do that I can get a
129:04 - return value but if I make a transaction
129:06 - that modifies the state that's the
129:09 - situation where I can't get a return
129:10 - value okay hopefully that makes sense
129:12 - but that is why we need events so now
129:14 - let me clear the screen and let's get
129:16 - into a more advanced example alright so
129:18 - for this example what I want to do is
129:20 - imagine that we're trying to build an
129:22 - application that's going to be partly on
129:23 - the blockchain that's going to allow us
129:25 - to auction our nfts again we still have
129:27 - this auction this is our contract but
129:30 - now what we probably want to do is we
129:32 - probably want to make a nice beautiful
129:34 - user interface that allows users to
129:36 - interact with this auction so to
129:38 - interact with the auction the owner of
129:40 - the auction is going to need to start it
129:42 - and then once it's started we're going
129:43 - to be able to accept bids right now the
129:45 - bid will be a certain amount of ethereum
129:47 - and we'll need to keep track of what the
129:49 - current bid is who's currently winning
129:51 - the auction we need to know when the
129:52 - auction ends and all of that logic again
129:54 - will be handled by auction however we
129:56 - want a very easy way for users to be
129:59 - able to interact with the auction
130:00 - contract I don't want them to have to
130:02 - write some really low level code and
130:04 - send their own transactions instead I
130:06 - want them to just be able to connect
130:07 - their blockchain encounter their
130:08 - ethereum account with my user interface
130:10 - and click this nice big button that says
130:13 - bid okay so they're going to be using my
130:15 - user interface all of my clients are
130:17 - going to have a different instance of
130:19 - the user interface maybe this is
130:20 - something like a react app or something
130:22 - like a JavaScript client whatever right
130:24 - so let's say we have kind of two user
130:26 - interfaces here and we have two people
130:28 - that are bidding against each other just
130:30 - for Simplicity so I'm going to say that
130:31 - this is number one and this is number
130:33 - two
130:34 - now the concept here is that this person
130:36 - is going to press the bid button it's
130:38 - going to send a transaction to the
130:39 - auction it's going to send maybe one
130:41 - ethereum and well that's going to be
130:43 - their bid and then this person maybe
130:45 - they want to send a bid maybe they send
130:46 - a bid of two ethereum now this is all
130:49 - great but again we run into this problem
130:51 - where I want these user interfaces to be
130:53 - able to be updated whenever another bit
130:56 - occurs
130:57 - so essentially if I'm sitting right here
130:59 - I want to know that number two just made
131:02 - a bid so that I can then bid again and I
131:04 - can bid three ethereum right now how do
131:07 - I do that well since I can't get a
131:08 - return value here and since my auction
131:11 - can't send something to my user
131:13 - interface it's not able to do that what
131:15 - I need to do is use my events so what's
131:17 - going to happen is every single time I
131:19 - make a bid an event is going to be
131:21 - emitted so I'm going to say omit
131:23 - and then I'll omit an event that's going
131:25 - to be something like let's write this
131:28 - properly something like bid 1f and then
131:31 - it will be from number one and then it
131:33 - will probably give the time that this
131:34 - bit occurred and a bunch of other
131:35 - information but the idea is we're going
131:37 - to Omit all of these events and then
131:39 - what we can do is we can have these user
131:42 - interfaces subscribe to the events so
131:45 - when they subscribe to the events what's
131:47 - going to happen is they're going to be
131:49 - notified when an event occurs and then
131:51 - they can use the data from the event to
131:54 - update their user interface and tell the
131:56 - user hey you just got outbid do you want
131:58 - a bid again or hey the current bit is
132:00 - this or the auction ended or whatever
132:01 - you get the idea but the concept here is
132:04 - we have an external client right so our
132:06 - JavaScript clients kind of sitting on
132:07 - some type of user interface they are
132:09 - subscribed to the events that this
132:12 - contract is going to be emitting and
132:13 - whenever the contract emits an event
132:15 - they'll be able to update their user
132:17 - interface and they could say query the
132:19 - state of the auction if they wanted to
132:20 - they could do that for free because that
132:22 - doesn't require a transaction hopefully
132:25 - this makes sense but that is the point
132:27 - of events and this is kind of how you
132:28 - would start building out a very simple
132:30 - blockchain application you would deploy
132:32 - your smart contract this would be kind
132:34 - of your source of truth right this would
132:36 - handle all the complex logic then you
132:38 - would have your nice user interfaces
132:40 - that allowed the user to interact with
132:42 - the smart contract and be updated of
132:44 - things that's happening with the smart
132:46 - contract because the smart contract can
132:48 - only do some type of operation when a
132:50 - transaction is performed so you need
132:52 - some type of external client sitting
132:54 - listening for events and updating the
132:57 - user then the user can trigger those
132:59 - transactions to the smart contract when
133:01 - they actually want to do something that
133:02 - is State changing perfect there we go we
133:06 - Now understand the importance of events
133:08 - let's go ahead and go back to the
133:09 - computer we're going to start writing
133:10 - out this auction contract and looking at
133:13 - events alright so I am back on my
133:15 - computer in remix we're actually just
133:17 - going to start working on the auction
133:18 - contract and then as we work on that
133:20 - I'll show you events so I'm going to
133:22 - change the name of my contract here to
133:24 - auction because that's going to be a bit
133:25 - more fitting and I'm going to implement
133:26 - a bunch of public things that we need
133:28 - here for our auction so if we're
133:30 - thinking of an auction we're going to
133:32 - have a time span for this auction so we
133:34 - need to know if the auction has been
133:35 - started if it's ended how much time is
133:37 - left so when the auction is actually
133:39 - going to end we want to know all of the
133:41 - bids we want to know who's selling the
133:43 - nft we want to know what the current
133:44 - highest bid is and who the current
133:46 - highest bidder is and we also need to
133:48 - know what nft we're selling but we'll
133:50 - deal with the nfts later because that's
133:51 - a little bit complicated so for now what
133:54 - I'm going to do is say address
133:57 - payable it's important we do payable
133:59 - here because we're going to want to pay
134:00 - this person who you'll see is the seller
134:02 - so we're going to say address payable
134:04 - public seller now it needs to be payable
134:06 - because well the seller of the nft we're
134:07 - gonna have to pay the profits of the
134:09 - auction so whoever you know the highest
134:11 - bidder was we're going to take money
134:12 - from them and send it to the seller okay
134:14 - now other than that we're going to need
134:16 - to know when the auction started so
134:18 - actually we don't need to know when it
134:20 - started we just need to know when it's
134:21 - going to end if it started and then if
134:23 - it's ended so I'm going to say Bool and
134:26 - then this will be public and this will
134:28 - be started we'll then say Bool public
134:31 - ended and we'll say bull or sorry not
134:34 - Bool this is going to be you ins and
134:37 - then this will be
134:39 - public if we could spell this correctly
134:42 - and then end at and this will be the
134:44 - time that we actually are going to end
134:45 - the auction at now other than that we
134:47 - need the highest bidder so we're going
134:49 - to say U int or sorry we want the
134:51 - highest bid so I'm going to say UNS
134:52 - public and then this will be highest uh
134:55 - bid like that
134:57 - and then we will have a dress and do I
135:00 - want this to be payable let me look at
135:02 - my cheat sheet here no I don't think we
135:03 - need that to be payable we'll just say
135:05 - address public and then highest bidder
135:10 - like that uh and that should be good now
135:13 - other than that we're going to need some
135:14 - mapping to keep track of all of the bids
135:16 - that users have made to this contract so
135:19 - the idea here for the auction is that
135:21 - when you make a bid you have to send
135:22 - money to the contract so if you don't
135:24 - actually end up winning the nft then you
135:26 - need the ability to withdraw your money
135:27 - right so we're going to have a
135:29 - withdrawal function that allows you if
135:31 - you didn't win to actually take all your
135:33 - money back from the contract so I'm
135:35 - going to say mapping
135:37 - and then this is going to be address and
135:39 - this will go to a uint and this will be
135:42 - a public and then this will be bits now
135:44 - the reason all these are public is
135:46 - because I don't need to hide any of this
135:47 - information it's fine if everybody sees
135:49 - it and I want people to be able to see
135:51 - when it started when it ended what the
135:52 - end that is what the highest bid is
135:54 - because you want people to trust this
135:55 - contract that's the whole point of
135:57 - writing smart contracts right okay so
135:59 - now that we have that I'm going to make
136:00 - a Constructor I'm going to say
136:02 - Constructor like this and all I'm going
136:05 - to do is simply assign the seller so I'm
136:07 - going to say the seller is equal to
136:10 - message Dot and then this will be sender
136:13 - so whoever deploy the smart contract
136:15 - will be the seller of the contract now
136:17 - notice I'm getting an error here it's
136:19 - going to tell me that the type address
136:21 - is not implicitly convertible to
136:23 - expected type address payable now I
136:25 - didn't show this to you previously but
136:26 - the way that you can convert a regular
136:28 - address to a payable address is you can
136:30 - just say payable like this and then
136:32 - surround what you want to convert so now
136:33 - this address that is non-address payable
136:35 - will be payable and I'll put that in
136:37 - inside of seller okay now what I'm going
136:40 - to do is Implement a start function this
136:42 - function will allow only the seller of
136:44 - the nft to start and they'll need to
136:46 - pass all the nft details to be able to
136:48 - start the auction now we won't implement
136:50 - the nft stuff right now as I mentioned
136:51 - we'll do that at the end so I'm going to
136:53 - say function we'll just call this start
136:56 - then this will be public
136:58 - external okay so we're going to call
137:00 - this from outside of the smart contract
137:03 - and inside of here what I want to do is
137:06 - I want to require
137:09 - that the message dot sender is equal
137:13 - equal to the selling otherwise I will
137:15 - say you did not start
137:19 - the auction exclamation point okay
137:21 - and then we'll go with semicolon now
137:23 - what's the error here it says visibility
137:24 - already specified as public okay so
137:26 - that's my bad story I'm just going to
137:27 - make this external uh because you can't
137:29 - have public external those are going to
137:31 - be you know messing with each other so
137:32 - external is fine now what's the warning
137:34 - uh function State mutability can be
137:36 - restricted to view okay that's fine
137:38 - we're going to change that later okay so
137:40 - now what I'm going to do is I'm going to
137:42 - say started
137:43 - is equal to true and then what I need to
137:46 - do is pick the end at date now this is
137:49 - going to be a little bit weird because
137:50 - we haven't seen this yet but I'm going
137:51 - to say end at is equal to and this is
137:53 - going to be block Dot and then time
137:56 - stamp plus and then seven days now we
138:00 - can actually change this so that it's
138:01 - not days and in fact let me check if
138:03 - that's correct okay actually I think
138:05 - seven days is correct so first of all
138:08 - let's just explain what this line is
138:09 - because I haven't covered this so block
138:11 - is actually referring to the block that
138:13 - this transaction is a part of once it's
138:15 - been mined right so once it's been mined
138:17 - it will be a part of a block and the
138:19 - block is going to have a time stamp
138:20 - that's when the block was created so
138:22 - this is going to give us the relative
138:23 - timestamp of the transaction it's not
138:26 - going to be precisely when we sent it
138:27 - but it will be very close to that
138:29 - because blocks are created very very
138:31 - quickly in ethereum and then we're going
138:32 - to add seven days to that and days is a
138:35 - keyword just like ether in remix so I
138:37 - can or sorry not in remix but in
138:39 - solidity so this way we're just going to
138:41 - add seven days to this timestamp which
138:43 - means we will end seven days after this
138:45 - so of course feel free to modify the
138:46 - number of days I mean you can make this
138:48 - one day if you want two days whatever it
138:50 - doesn't really matter in fact let's just
138:51 - go with two days for now about whatever
138:53 - you set this that's going to be the
138:54 - amount of time the contract or sorry the
138:57 - what do you call it the auction will
138:58 - last for okay so now we have start
139:01 - however what I want to do is add one
139:03 - more require here that just makes it so
139:06 - we cannot start this Con contract if
139:07 - it's already started so I'm going to say
139:09 - not started like that and then I'll say
139:11 - already
139:13 - started exclamation point and what I
139:16 - want to do is I want to Omit an event
139:19 - saying that I started the contract so
139:21 - now we're going to talk about how we
139:22 - actually Implement events now creating
139:24 - an event is actually pretty
139:25 - straightforward you first need to
139:27 - declare an event in the body of your
139:29 - contract so I'm going to do it up here
139:30 - I'm going to say event and then start
139:33 - and I've just created an event now we
139:35 - need to Omit these events but this is an
139:37 - event that is omittable so what you do
139:39 - is you put the keyword event you then
139:41 - put the name of the event in this case
139:42 - I'm going to go with start now notice
139:44 - I'm starting it with a capital because
139:45 - the convention here is Pascal case just
139:48 - like our contracts and then inside of
139:50 - the parentheses you put any arguments
139:52 - you want the event to accept
139:54 - so you could put for example the address
139:56 - of the person who started the event now
139:59 - that wouldn't really be very useful
140:00 - because the only person who can start
140:02 - the event or sorry start the contract or
140:04 - start the auction is going to be the
140:06 - seller but you could put any other data
140:08 - you want here you don't need to put the
140:10 - time because that will automatically be
140:12 - associated with events whenever they're
140:13 - omitted but I can put any data inside of
140:16 - the parentheses and then I pass that
140:18 - data as arguments when I omit the event
140:20 - and that'll be like the data of the
140:22 - event
140:23 - we'll see this in a second right now for
140:25 - start I don't need any arguments so we
140:27 - won't look at that right now but when I
140:29 - do events for a bid I'm going to have
140:30 - the address of the person who bid the
140:32 - amount they bid Etc right okay so
140:35 - anyways we have an event to find which
140:37 - is start and now if I want to emit an
140:38 - event this is really straightforward I
140:40 - just do omit and then I put the name of
140:42 - the event like that
140:43 - okay there you go I'm now emitting the
140:45 - start event now if start was accepting
140:47 - arguments I would pass them right in
140:49 - here so whatever the arguments are right
140:51 - okay
140:53 - there we go pretty straightforward so
140:55 - now that we have that let's deploy this
140:57 - contract let's deploy it to a legitimate
140:59 - Network right so I'm going to deploy it
141:00 - to the go rally test Network and then
141:02 - I'm actually going to go look at the
141:03 - events of my smart contract and show you
141:06 - how you can view them off the blockchain
141:08 - on etherscan so let's do this I'm going
141:10 - to click deploy and then once it's
141:12 - finished I will let you know okay so the
141:14 - contract has now been deployed so I'm
141:15 - going to click on the contract
141:17 - deployment here I'm going to view this
141:19 - on etherscan notice it says that it was
141:21 - successful so what I'm going to do now
141:23 - is Click right on the contract so notice
141:25 - it says contract here it was graded so
141:28 - I'm going to click on that and when I go
141:29 - here we can see we have the hash of the
141:31 - transaction that created the contract
141:33 - then I can click on events now when I go
141:36 - to event notice we don't see any events
141:38 - now that's because we haven't triggered
141:39 - any yet but I'm now going to trigger an
141:41 - event and show you that it will show up
141:43 - right here okay so let's go back to
141:45 - remix
141:47 - let's now go to our contract and let's
141:50 - start by just clicking on some of these
141:51 - so we can see the seller is it started
141:53 - no it's not started so let's start it by
141:55 - clicking on start now when we do this of
141:57 - course we need a transaction because
141:58 - this is going to modify the state so I'm
142:01 - going to click on confirm okay this is
142:03 - going to take a second to complete and
142:06 - let's just go here and it should tell us
142:07 - when this is done then we can go check
142:09 - the corresponding event that would have
142:11 - been emitted okay so this is finished
142:12 - now so let's go back here and let's
142:16 - refresh the page and notice that we have
142:19 - an event now the event is start okay and
142:21 - I can click on this right here and kind
142:23 - of view some of the details now the
142:25 - method will actually be the method that
142:27 - we called in the transaction now this is
142:29 - going to be a special hash of this
142:31 - method I'm not really going to describe
142:33 - exactly how you kind of read this stuff
142:34 - because there is a special way to do
142:36 - that however whenever you're going to be
142:38 - subscribing to events or trying to get
142:40 - the data associated with an event you're
142:42 - not just going to be reading it from
142:43 - this page you're going to have a client
142:45 - this client's going to be using a
142:46 - special live library a library could be
142:48 - something like web3js this is a
142:51 - JavaScript library that kind of handles
142:52 - a lot of this complex lower level stuff
142:54 - for you and it will kind of decode this
142:56 - data and tell you the stuff in the event
142:58 - now I'm not going to show you how we
143:00 - subscribe to events in this tutorial
143:01 - because it's fairly complicated but if
143:04 - you were writing say a JavaScript client
143:05 - or something what you could do is use
143:07 - something like web3.js so let's do this
143:10 - this is the ethereum JavaScript API and
143:13 - inside of here you can subscribe to
143:14 - events so if we go to F dot subscribe
143:17 - this is the thing right here I'll leave
143:19 - a link to this in the description and
143:21 - you can kind of view how you would do
143:22 - this and how you actually get the data
143:24 - associated with events from a smart
143:26 - contract okay
143:27 - let's go back to remix though and let's
143:29 - continue all right so now that we've
143:30 - written the start method let's write the
143:33 - end method or the end function so I'm
143:35 - going to say function end external and
143:38 - inside of here I need to require a bunch
143:39 - of things the first thing I'm going to
143:41 - require is that they started the
143:42 - contract so I'm going to say require
143:44 - started because well if I haven't
143:45 - started it they can't end it so I'll say
143:47 - you need to start first exclamation
143:50 - point it doesn't really matter the error
143:52 - message that I give then I will also
143:54 - require that the block dot timestamp is
143:59 - greater than or equal to end at because
144:02 - I don't want to allow someone to end the
144:04 - auction if uh the end at time is not yet
144:07 - reached right because that would be
144:09 - unfair that means you could have someone
144:10 - like bid on it and then you could end it
144:12 - for them so that they would win it
144:13 - before anyone else was able to bid
144:15 - anyways we're going to do this we're
144:17 - going to say block.time stamp greater
144:18 - than or equal to end at I'll say auction
144:22 - is
144:24 - still ongoing is ongoing one word or two
144:27 - word I think it's one word uh someone
144:29 - can correct me in the comments clearly
144:31 - programming is greater than spelling
144:33 - anyways and then we also want to make
144:35 - sure that it's not already ended right
144:37 - so I'm going to say not ended we'll say
144:39 - auction
144:41 - already ended and let's spell already
144:45 - correctly okay
144:46 - exclamation point
144:48 - perfect so now that we have all of our
144:49 - requires what we can do is say ended is
144:52 - equal to true and then we want to emit
144:55 - an event that says we ended it now of
144:57 - course when we end we're going to
144:58 - actually have to transfer the nft to the
144:59 - highest beta and then we're going to
145:01 - transfer the funds from the contract to
145:03 - the uh what do you call it the seller of
145:06 - the nft but for now we'll just do the
145:08 - events so let's go up here and let's say
145:10 - event and let's say end now for this
145:13 - event I actually want to know what the
145:15 - highest bid was and who the highest
145:17 - bidder was so I know who won the auction
145:19 - right so I'm gonna say let's go with
145:22 - address and this will be I guess highest
145:27 - bidder okay and then we will go with
145:30 - uint and then this will be highest bid
145:32 - okay so that's for event and in fact I
145:36 - guess I can do this yeah that's fine we
145:38 - can do that inside here okay so now for
145:40 - end I'm going to say admit and then end
145:43 - and then inside of here I'm going to
145:44 - pass the highest bidder
145:47 - so let's go high it's better like that
145:48 - and then let's pass the highest bit
145:51 - perfect okay there we go now one thing I
145:54 - want to add to start is I just want to
145:56 - add a parameter here that's going to be
145:58 - the starting uh price or the starting
146:00 - bid or whatever for the auction so I'm
146:02 - going to say uint we'll say starting bid
146:06 - and what I'm going to do is after I
146:07 - start this or it actually it doesn't
146:09 - really matter where I do this but I'm
146:10 - going to say that the highest bid
146:14 - is equal to and then this is going to be
146:16 - the starting bit so this way you're
146:18 - going to have to bid at least a little
146:19 - bit higher than this to be able to
146:20 - actually win the item if you were say
146:22 - the only bidder that way someone doesn't
146:24 - list this and kind of get screwed by
146:26 - only having someone bid like one way or
146:28 - two-way or something and no one else
146:29 - actually bids on the nft regardless
146:32 - we'll have that for now and we can now
146:34 - test if end is going to work and then we
146:37 - can Implement bid and we can Implement
146:38 - withdraw which are the other two
146:40 - functions that we're going to need so
146:42 - let me save this now let's close this
146:44 - I'm going to deploy the contract again
146:46 - this will take a second once it's done I
146:48 - will be back all right so the auction is
146:50 - now deployed now I can start this by
146:53 - passing say a thousand way as the
146:54 - starting bid we will wait for this to go
146:57 - through and then we can try to end it
147:00 - now I will show you that when we end it
147:02 - this isn't going to work now the reason
147:03 - it's not going to work is pretty obvious
147:05 - but we don't have this condition being
147:07 - equal to True right the block.time stamp
147:09 - is not going to be greater than or equal
147:10 - to end at so it's not going to let us
147:12 - end this and I'll just show you that
147:13 - that works in a second once this starts
147:15 - okay so that's started
147:16 - let's now go to this contract uh the way
147:19 - I'm going to get to this is I'm going to
147:21 - open up metamask
147:23 - I'm going to go to contract creation
147:25 - okay let's go here let's view the
147:29 - contract okay it's still indexing uh Let
147:31 - me refresh this once it's done I'll be
147:32 - right back okay so now it is fully
147:34 - successful let me click on the contract
147:36 - uh let's go to events and we can see
147:39 - that the event start has been triggered
147:42 - or been emitted right because we started
147:43 - the contract so now let's see what
147:45 - happens if we try to end it so notice is
147:47 - going to tell us that we're probably
147:48 - going to get a problem here it's saying
147:50 - that gas estimation errored with the
147:52 - following message see below the
147:54 - transaction execution will likely fail
147:55 - do you want you for sending and it's
147:57 - saying that the error's auction is still
147:59 - ongoing so it's actually able to look at
148:01 - our smart contract and realize that
148:03 - we're not going to be able to do this
148:05 - because the block dot timestamp is uh
148:08 - not greater than or equal to the end at
148:10 - time so we can still send the
148:11 - transaction if we want now if we do this
148:13 - what's going to happen
148:15 - is it just gonna fail now when it fails
148:18 - and we hit a require statement the
148:20 - require statement will return whatever
148:21 - remaining gas we had as a part of this
148:23 - transaction back to us however some gas
148:26 - is going to be lost now that's one thing
148:28 - to note here with require it does
148:30 - actually return your gas if this fails
148:32 - again not all of it because it still had
148:34 - to use some gas but it will return
148:36 - whatever was in you so you can see here
148:38 - we're getting this error right it's
148:39 - telling us this didn't work and we
148:41 - weren't able to do that because this
148:42 - require statement would have been well
148:44 - not true right it would have you know
148:46 - caused an exception okay
148:48 - so hopefully that makes sense that is
148:50 - how that works now that we've done that
148:52 - let's start implementing the bid and the
148:55 - withdraw functions that we need Okay so
148:58 - let's code out the bid function let's go
149:00 - with function bid
149:02 - external now this needs to be payable
149:05 - because this is actually going to accept
149:06 - ethereum right so inside of here we need
149:08 - to require a few things we're going to
149:11 - require that we have started the auction
149:14 - if we haven't started then obviously
149:16 - we can't do this I'm going to say not
149:18 - started we're going to require that the
149:21 - block dot timestamp again this is a
149:24 - global keyword that we have access to is
149:26 - going to be less than the end at times
149:29 - this means that the contract is not
149:31 - ended or sorry I keep saying contract I
149:32 - mean auction so we'll say ended
149:35 - exclamation point and then we will also
149:38 - require that the message dot value so
149:41 - this is going to be the value of the bid
149:42 - because they're going to be sending the
149:44 - amount of the bid right is greater than
149:46 - and then this will be the current
149:48 - highest bit
149:49 - okay so now we have all of our required
149:51 - statements now let's see why it's
149:52 - getting mad at us here it's saying
149:54 - expected semicolon but got identifier
149:55 - okay I need a semicolon right there so
149:57 - now if this is the case what we're going
149:59 - to do is we're going to update the
150:00 - amount of money that people have sent to
150:02 - this contract kind of similar to the
150:03 - bank account by using this bids mapping
150:06 - and we're going to update the highest
150:07 - bid and the highest bidder because at
150:09 - this point we know this person would
150:11 - have bid an amount higher than the
150:13 - highest bid so we need to update those
150:14 - values right so we're going to say that
150:16 - the highest bid is equal to message dot
150:19 - value
150:20 - and we're going to say that the highest
150:22 - bidder
150:23 - is equal to the message dot sender okay
150:26 - so now after updating this since the
150:28 - highest bidder has now changed what I
150:31 - need to do is make it so the person who
150:33 - just got outbid is able to withdraw
150:35 - their money from the contract so I'm
150:36 - going to say if and then this is going
150:38 - to be the highest bidder uh so not bid
150:41 - but bitter does not equal the address
150:43 - zero now address zero is the default
150:46 - address I'll talk about this in a second
150:47 - then what I'm going to do is say that
150:49 - bid at and this is going to be highest
150:51 - bidder plus equals and then the highest
150:54 - bit so the logic here uh why is this
150:57 - yelling at me let's see what the problem
150:59 - is uh operate or not compatible with
151:00 - types un256 and address sorry this needs
151:03 - to be highest bid not highest bidder
151:04 - okay that's better but the logic here is
151:07 - that as soon as someone gets outbid I
151:09 - want to allow them to withdraw their
151:10 - money from the contract so that they
151:12 - could withdraw and then bid again right
151:13 - because otherwise they would need to
151:15 - have a ton of ethereum to be able to
151:16 - actually continually out bidding someone
151:18 - if all of their money is stored in the
151:20 - contract so hopefully this makes sense
151:21 - but since we're updating the highest
151:23 - bitter now if the highest bidder was not
151:25 - equal to address zero so essentially if
151:28 - this was not the first person to make a
151:29 - bid then what we do is we take whatever
151:32 - the highest bidder was store that in our
151:34 - bids mapping and then we add whatever
151:37 - their highest bid to that so that now
151:39 - they're able to withdraw and let's say
151:40 - they don't withdrawn they just continue
151:42 - making bids that's fine this will
151:44 - continue to increment however many bids
151:46 - they've made so then they will be able
151:47 - to withdraw all of that if they're not
151:49 - currently the highest bidder okay and
151:51 - actually they'll be able to withdraw
151:52 - whatever amount inside of there is not
151:55 - their current bid that's being stored in
151:57 - highest bit you can look through this
151:59 - logic and probably see why that makes
152:00 - sense but address zero just to clarify
152:02 - here is the default address so when I
152:04 - write something like address public for
152:06 - right now sorry not address public but
152:08 - address public highest bidder it's going
152:10 - to be storing just a zero filled address
152:12 - so I'm just making sure that it's not
152:14 - equal to the zero filled address and you
152:16 - can do that by just writing address and
152:17 - then putting 0 inside of here okay so
152:20 - that is Bid that's pretty much all we
152:21 - need for bid now we want to write the
152:23 - withdrawal function so I'm going to say
152:24 - function
152:26 - withdraw like that and then this is
152:29 - going to be an external payable as well
152:32 - and inside of here what we need to do is
152:34 - withdraw a certain amount or I guess
152:36 - we'll just withdraw the entire amount of
152:38 - whatever the person's bidded that's not
152:40 - the current bid so we're just going to
152:41 - start by getting the amount of money
152:43 - they've sent to this contract that's not
152:45 - currently the highest bid so I'm going
152:47 - to say a uint and I guess I'll just go
152:49 - with something like balance is going to
152:51 - be equal to and then this will be bids
152:53 - at
152:54 - message dot sender and then what I'm
152:57 - going to do is say bids at message dot
153:00 - sender is equal to zero just to reset
153:02 - that and then I'm going to send whatever
153:04 - their balance is to them so the way I'm
153:06 - going to do this is I'm going to write
153:07 - this complex line in fact I'm just going
153:09 - to copy this in because we saw this in
153:10 - the last video I'm going to say bull
153:12 - sent bytes memory data is equal to
153:14 - payable message.center so just
153:16 - converting that address to a payable
153:17 - address dot call Value and then this is
153:20 - going to be balanced balance is right
153:21 - here right and then what I need to do is
153:23 - require that this was successful so I'm
153:25 - going to say require sent and I'm going
153:27 - to say
153:28 - could not withdraw so let's do this
153:30 - could not withdraw let's add our
153:34 - semicolon and there we go we have just
153:35 - implemented the withdraw function now
153:38 - what I'm going to do is actually add
153:39 - some events here as well for bid and for
153:42 - withdraw then we can test this out and
153:45 - then we'll start actually working with
153:46 - an nft because right now we're not
153:47 - really auctioning anything
153:49 - so let's make some events uh let's make
153:51 - an event for bid now what I want to do
153:54 - is have an address now this is going to
153:56 - be indexed now we haven't seen this
153:58 - keyword before but what you're allowed
154:00 - to do whenever you're defining the
154:02 - arguments for your events is you can put
154:04 - an indexed parameter and you can
154:06 - actually put up to three of these and
154:07 - this is what you will be able to search
154:09 - for an event for so if I say indexed
154:12 - here then this means I can search by
154:13 - whatever this parameter is for this
154:15 - event in my logs right or in my events
154:18 - so I'm going to say address indexed let
154:20 - me just look at my cheat sheet to make
154:21 - sure I don't mess this up it's going to
154:23 - be sender and then we're going to say
154:25 - uint amount to specify how much they
154:27 - actually bid and then we'll do an event
154:29 - and this is going to be withdraw and
154:33 - this again will be an address that's
154:34 - going to be indexed this will be the
154:36 - bidder and then this will be you ends
154:39 - and the amount that they withdrew
154:42 - okay I think that is fine now what's it
154:46 - telling me what's what's it saying I did
154:48 - wrong here oh I spelled indexing
154:49 - correctly okay
154:50 - so let's go and let's now omit these
154:52 - events so I'm going to say omit and then
154:54 - this is going to be bid and then we're
154:56 - going to pass to this just the highest
154:58 - bidder and the highest bid okay perfect
155:02 - let's add our semicolon and then for
155:03 - withdraw we will say omit and then
155:06 - withdraw and then we're going to omit
155:09 - the message dot sender and the bounce
155:13 - great there we go okay so now let's
155:15 - actually just deploy this we can do some
155:17 - experiments with it I'll set up another
155:18 - ethereum account uh make sure it works
155:20 - and then we'll talk about the nfts so
155:22 - I'm going to deploy once it's done I
155:24 - will be right back okay so I am back
155:26 - this finished deploying my contract this
155:28 - year I actually started the contract
155:29 - with a minimum bit of a thousand way and
155:32 - now what I'm going to do is change my
155:33 - ethereum account in fact I've actually
155:35 - already done this so I deployed this
155:37 - contract from my tutorial account but
155:40 - now I'm on account one so now I'm going
155:41 - to make a bid from account one and show
155:43 - you how this works so I'm on account one
155:45 - you can see I've reconnected this here
155:47 - to uh what do you call it uh remix and
155:49 - now I'm going to make a bid of a
155:51 - thousand way I'm going to click on bit
155:53 - now when I do this notice it's going to
155:55 - tell me that I'm probably going to get
155:56 - an error the reason I'm going to get an
155:57 - error is because this is not greater
155:59 - than the starting bid and so I'm just
156:00 - going to cancel the transaction so I'm
156:02 - going to change this now to be a
156:04 - thousand one
156:05 - let's click on bid
156:07 - and let's see okay
156:09 - so confirm let's give this a second and
156:12 - again notice I'm not going to get any
156:14 - return value here it's not going to tell
156:15 - me if this was successful or whatever
156:16 - I'm just going to see that the
156:18 - transaction didn't fail whenever this is
156:20 - done
156:21 - and then I should see an event be
156:23 - emitted here okay so let's now refresh
156:25 - this and we now see uh hmm okay maybe we
156:29 - need to wait a second okay so the event
156:31 - has showed up I just had to wait a
156:33 - second I was being impatient but after I
156:35 - refreshed a few times it appeared here
156:37 - anyways this has happened successfully I
156:39 - know this looks like gibberish but if
156:41 - you're actually subscribing to this
156:42 - event then you would have some library
156:44 - that would be translating this for you
156:46 - so you'd be able to read the real data
156:48 - regardless the bid happened and I can
156:51 - look now at for example the highest bid
156:53 - which I can see is 1001 the highest
156:55 - bidder which is this address I can look
156:57 - at the seller which is different if the
156:58 - contract is started and all of this type
157:00 - of stuff now that's pretty much all I
157:02 - wanted to show you for that since we
157:05 - don't really have two days to wait here
157:06 - for this to finish I can't show you it
157:08 - actually ending what I will do though is
157:11 - I will now start implementing the nft
157:13 - stuff which is a little bit complicated
157:15 - uh but it's pretty cool so I'll try my
157:17 - best to explain it to you alright so
157:18 - I've just switched tabs and I'm going to
157:20 - try to explain to you the difference
157:21 - between fungible and non-fungible tokens
157:24 - and how these kind of live on the
157:25 - ethereum network
157:27 - so I'm sure all of you are familiar with
157:29 - cryptocurrencies right we have
157:31 - currencies like ethereum we have
157:32 - currencies like Bitcoin we have a ton of
157:34 - other currencies that are built on top
157:36 - of these main blockchain networks so if
157:38 - we're talking about coins that are built
157:40 - on ethereum these are tokens now really
157:43 - all a token is is a smart contract that
157:47 - defines that your address owns a certain
157:49 - amount of tokens now this is specific to
157:52 - ethereum but if you're working with a
157:54 - token that's on the ethereum network
157:55 - really what gives you the ability to own
157:58 - that token is that there's a smart
158:00 - contract with the name of that token
158:02 - it's named say Tim coin for example
158:03 - right if I had my own token on ethereum
158:06 - and in that contract it says that your
158:08 - address has 20 Tim coins where 100 Tim
158:11 - coins or whatever it is now the way this
158:13 - all gets standardized is that what
158:15 - happens is you need to implement
158:16 - specific methods or specific functions
158:18 - on your smart contracts that make it act
158:21 - like an erc20 or an ERC 721 token now
158:25 - erc20 is simply a protocol for a
158:28 - specific token in this case it's a
158:30 - fungible token now erc20s states that
158:33 - you need to Define some special methods
158:35 - on the smart contract now if you do that
158:38 - ethereum is able to look at your smart
158:39 - contract and treat that smart contract
158:42 - like a token rather than just any other
158:44 - smart contract now that means in your
158:46 - ethereum wallet you're going to see your
158:48 - token showing up or you'll be able to
158:49 - link them you'll be able to then say buy
158:51 - these tokens or exchange these tokens
158:53 - because you've defined certain functions
158:55 - on the token and it meets the erc20
158:57 - protocol hopefully that makes sense now
159:00 - erc20 is simply a fungible token
159:02 - protocol what that means is every single
159:05 - one of these tokens is exactly the same
159:07 - so there's no difference in you owning
159:09 - one of the tokens or the other tokens
159:11 - like any token is just identical vehicle
159:13 - each of them has the same value
159:15 - and as it says here this makes erc20
159:17 - tokens useful for things like medium of
159:19 - exchange voting rights staking whatever
159:21 - okay that's where you can use these
159:23 - tokens for however now we go over to ERC
159:26 - 721 now ERC 721 is fungible tokens now
159:30 - fungible tokens mean that these tokens
159:32 - are different so there could be a
159:33 - different value associated with each
159:35 - token maybe there's some assets like an
159:37 - image associated with a token hence nfts
159:39 - right maybe you get some special rights
159:42 - with a specific token
159:43 - tokens are unique they are different and
159:46 - they have a unique ID now this is very
159:48 - similar to erc20 except you're just
159:51 - having these unique tokens and you have
159:52 - some special functions now that you need
159:54 - to Define on Smart contracts that are
159:56 - defining an ERC 721 token so it's a
159:59 - little bit too complicated for me to
160:00 - show you exactly how to create your own
160:02 - nfts or your own erc20 tokens but the
160:05 - concept is again that we have this smart
160:07 - contract this is an example of an nft
160:10 - contract this smart contract defines who
160:13 - owns what nfts it's capable of creating
160:15 - new nfts and then if I wanted to say
160:18 - send my nft from me to you what I would
160:20 - do is call a function on the smart
160:22 - contract that transfers the nft I have
160:25 - to be the owner of the nft to be able to
160:27 - do that and then it changes the internal
160:29 - state of the nft contract to now Define
160:31 - that you own my nft because I sent it to
160:34 - you so hopefully this makes a tiny bit
160:36 - of sense but that's the general idea
160:38 - behind tokens and behind nfts and all of
160:41 - this type of stuff now as you can see
160:42 - here there's some other types of tokens
160:44 - that you can create but ERC 721 is the
160:47 - one we're going to work with right now
160:48 - and what we're actually going to accept
160:50 - in our smart contract that's going to be
160:52 - the auction is the address of a smart
160:55 - contract that represents an nft as well
160:58 - as the unique ID associated with the nft
161:01 - that the user wants to auction so
161:03 - whenever you get an nft it has a unique
161:05 - ID associated with it because every
161:07 - single ERC 721 token is unique when I
161:10 - say ERC 721 that really just means
161:13 - non-fungible token okay and so it has a
161:15 - unique ID if I pass that unique ID along
161:18 - with the contract representing that nft
161:20 - then what I'm able to do is verify that
161:22 - the user owns that nft and then actually
161:25 - list it in the auction and transfer it
161:27 - between different people okay so now
161:30 - let's get into some even more
161:31 - complicated stuff because I need to show
161:33 - you how we can make our own nft and when
161:36 - I say make our own nft I'm not talking
161:38 - about make your own nft contract I'm
161:40 - saying kind of acquire an nft in your
161:42 - ethereum account so you can follow along
161:44 - and actually auction off your own nft in
161:47 - this tutorial all right so to do this
161:48 - I'm going to go up to this other tab
161:50 - here where I have token.sol now I'm not
161:52 - going to explain any of this code but
161:54 - essentially this is my own Tim coin nft
161:57 - okay and I'm going to give you guys all
161:59 - the privilege of owning some Tim coin
162:01 - completely for free it has zero value
162:03 - and it's going to be on an ethereum test
162:05 - network but you can own it for free you
162:06 - are welcome and the way I'm going to do
162:08 - that is I'm going to deploy this smart
162:10 - contract I'm going to leave a link to
162:11 - the contract address in the description
162:13 - and you actually are able to create your
162:16 - own nft by calling this award item
162:19 - function which is going to give you your
162:21 - ethereum address a nft okay it's going
162:24 - to give you a special ID essentially of
162:27 - Tim coin I'll explain this more in depth
162:29 - and I'll show show you exactly how to do
162:30 - this but right now when you're watching
162:32 - this video this will be deployed on the
162:34 - go rally test Network so you need to
162:36 - make sure you're using that test Network
162:37 - and then what you'll be able to do is
162:39 - interact with this contract from remix
162:42 - again I'm going to show you exactly how
162:43 - to do that it will then award you an nft
162:46 - and then once you have that nft you'll
162:48 - be able to auction that nft inside of
162:50 - our test contract now before I show you
162:53 - how to do that we're going to implement
162:54 - kind of the nft logic in our contract
162:56 - then I'll show you how you get your own
162:58 - Tim coin nft again you're welcome you
163:00 - guys can thank me in the comments okay
163:02 - so what we're going to do is we're going
163:04 - to now specify what's known as an
163:07 - interface that we are going to accept
163:09 - for a specific contract which is going
163:12 - to be the contract address of the nft
163:13 - that we want to list
163:15 - so I'm going to say interface so
163:17 - actually there's not a ton of value of
163:18 - me typing this in so I'm just going to
163:19 - paste in the interface and I'll explain
163:21 - what this is so first of all an
163:23 - interface is an abstract data type the
163:25 - reason we're going to use an interface
163:26 - is because we need to verify that the
163:28 - contract passed to this auction does
163:31 - actually represent an nft and so we're
163:33 - going to treat the contract as an IRC
163:36 - 721 type contract which means we're
163:40 - going to make sure it has a transfer and
163:41 - a transfer from function on it now if
163:44 - you're unfamiliar with interfaces I
163:45 - can't explain them too much in depth
163:47 - essentially they just enforce that
163:49 - anything that is of type of this
163:50 - interface has these methods that are
163:53 - specified in this web so for us to have
163:55 - a valid nft contract really all we care
163:57 - about is that it has a transfer and a
163:59 - transfer from function that we can use
164:01 - now the transfer from allows us to
164:03 - transfer from one address to another
164:05 - address a specific
164:07 - um what do you call it nft ID okay so as
164:10 - I was saying before all we're doing is
164:12 - we're going to be calling a function on
164:15 - the nft contract that takes in the
164:16 - address of the owner of the nft the
164:18 - address of the receiver of the nft the
164:20 - nft ID it verifies we own this nft and
164:23 - then it would transfer it to here and
164:25 - then transfer is simply going to take an
164:27 - nft ID and transfer it to a specific
164:30 - address once it's been approved to do
164:32 - that you'll see what I mean in a second
164:34 - but anyways that's our interface
164:36 - so what we're going to do now is we're
164:38 - going to go inside of our auction and
164:40 - we're going to define the nft that we're
164:43 - actually going to be auctioning so I'm
164:44 - going to say I ERC 721
164:48 - public
164:49 - like this nft
164:52 - and then what I'm going to do is I'm
164:54 - going to say uint public nft ID okay
164:58 - so what I'm saying is I want to store
164:59 - the contract of the nft address here
165:01 - it's going to be of type ierc 721
165:04 - meaning it has to have these functions
165:06 - on it and then I'm going to have uint
165:08 - public not NDT nft ID which is going to
165:12 - be the unique ID of the nft that we want
165:14 - to auction so now inside of my start
165:16 - function what I'm going to do is take in
165:18 - a starting bid I'm going to take in the
165:19 - nft contract and the unique ID of that
165:23 - nft so I'm going to say IRC 7
165:28 - 21 this is going to be nft and we'll
165:31 - make this underscore nft and then we are
165:33 - going to say uint
165:35 - nft ID we'll just make this underscore
165:38 - again so it doesn't mirror our Global
165:40 - name and then comma Now let me make sure
165:42 - I type that correctly I think I did okay
165:45 - so now inside of here what we're going
165:47 - to do is we're going to set the nft so
165:50 - we're going to say n of t
165:52 - is equal to and then this is going to be
165:54 - underscore nft
165:56 - again this is the contract representing
165:58 - the nft
165:59 - then we're going to say nft ID is equal
166:02 - to underscore nft
166:04 - ID like that now what I'm going to do is
166:06 - just take these two lines here and put
166:08 - them after I do this just in case these
166:11 - return some error although it doesn't
166:13 - really matter because if an error was
166:15 - returned then the state would have been
166:16 - reverted but that's fine okay so we're
166:18 - going to do that now what we also need
166:20 - to do is we need to transfer this nft
166:22 - from the owner of the nft to this
166:25 - contract so now the contract owns the
166:27 - nft and then is able to actually
166:29 - transfer this to whoever wins the nft in
166:31 - the auction right so what I'm going to
166:33 - do is say nft
166:34 - dot transfer from and we're going to
166:37 - transfer from and this is going to be
166:38 - the message.sender who we're assuming
166:40 - owns the nft to this or sorry it's going
166:44 - to be
166:45 - address this like that and then this is
166:49 - going to be nft ID
166:51 - okay
166:53 - so this here is going to fail if we
166:55 - don't own the nft so if whoever called
166:57 - this start here doesn't own the nft then
167:01 - we're not going to allow them to
167:02 - transfer because the nft contract will
167:04 - raise an exception and so that whole
167:05 - thing will Cascade meaning all of this
167:07 - is going to fail as well and so we won't
167:09 - actually start the auction so we're only
167:11 - able to start the auction if we own the
167:13 - nft and if we have the ability to send
167:15 - the nft from the sender to this address
167:18 - okay
167:19 - hopefully that makes sense I'll explain
167:20 - again how we kind of set the nft up and
167:23 - how we actually make an nft and get
167:25 - access to it in a second so now that we
167:27 - have that what we need to do is deal
167:29 - with what happens when the auction ends
167:31 - because once the auction ends we need to
167:33 - send the nft to whoever won it and then
167:35 - we need to take the balance of the
167:37 - contract and specifically whatever the
167:39 - highest bid was and send that actually
167:41 - to ourselves right to the seller of the
167:44 - nft so all we're going to do here is
167:46 - we're going to check
167:47 - if V and this is going to be highest
167:51 - bidder
167:52 - does not equal the address zero because
167:55 - if it's equal to the address 0 that
167:57 - means no one actually bid on this item
168:00 - and so we can just return the funds or
168:02 - return the nft to ourself so anyways
168:04 - we're going to say if this is the case
168:06 - then that means we're going to take
168:07 - whatever the highest beta amount was or
168:09 - the highest bid sorry we're going to
168:11 - transfer that to ourselves and then we
168:14 - are going to transfer the nft to uh
168:17 - whoever won the nft so I'm going to say
168:19 - nft
168:21 - dot transfer and we're going to transfer
168:23 - it to the highest bidder
168:26 - I think that's all I need to put in here
168:28 - let me confirm that's correct oh one
168:30 - more thing the nft ID
168:32 - okay
168:33 - so we're using the nft contract we're
168:35 - using dot transfer we're going to
168:36 - transfer to the highest bidder and then
168:39 - this will be the nft ID now what it's
168:42 - saying is the issue it says transfer is
168:43 - not found well that's because I spelled
168:45 - transfer incorrectly okay that's fine
168:47 - then after that we're going to figure
168:49 - out whatever the highest bid was and we
168:51 - are going to then pay that to ourselves
168:52 - the seller of the nft
168:54 - so the way we do that is we just copy in
168:57 - this line because I really don't feel
168:59 - like writing it again so we're going to
169:01 - say Bool
169:02 - sent and then bytes memory equals data
169:04 - seller.call value and then this is going
169:07 - to be highest bid and then we'll call
169:08 - that like that and then we're going to
169:09 - require sent and we're going to say
169:11 - could not pay the seller okay
169:13 - there we go now in the other situation
169:16 - so if the highest bid actually is equal
169:18 - to address 0 then what we're going to do
169:21 - is just return the nft to ourselves so
169:23 - we're going to say nft
169:25 - dot transfer and then this is going to
169:28 - be two I guess we will just say the
169:32 - seller and then this will be nft ID and
169:35 - I think that's it again I spelled
169:37 - transfer incorrectly let me just make
169:39 - sure that's right looks good to me
169:41 - awesome
169:42 - okay so that is actually all we need for
169:45 - this contract now this contract should
169:47 - work however I need to show you how we
169:50 - can now actually get access to an nft
169:51 - and what that looks like in our account
169:53 - so I'm going to start by deploying this
169:55 - contract now be careful what account you
169:56 - deploy this from I'm going to deploy it
169:58 - from this one so I'm going to deploy uh
170:01 - test.soul which is really just my kind
170:03 - of auction contract let's confirm this
170:06 - okay this will take a second once that's
170:09 - done I'll be right back okay so that has
170:11 - now been deployed now remember to be
170:13 - able to start this auction we actually
170:15 - need the address of our nft so I am now
170:18 - going to deploy this nft contract here
170:20 - I'll leave the link to it in the
170:22 - description or you could just painfully
170:24 - write out all whatever the number of
170:26 - characters are but again it'll be linked
170:28 - in the description and I'll show you how
170:29 - you can use this to get your own nft so
170:31 - let me now deploy this I need to pass a
170:33 - string name and a symbol actually do I
170:36 - need to do that uh oh sorry I'm doing
170:38 - the wrong thing okay let's deploy Tim
170:40 - coin so I'm going to deploy timcoin to
170:42 - the go rally test Network this is going
170:45 - to take a second and then I will show
170:47 - you again how we can actually access
170:49 - this and get our own nft Okay so Tim
170:51 - coin has now been deployed now for me I
170:54 - can see Tim coin right here right and we
170:56 - see all these different methods you
170:57 - don't have to worry about a bunch of
170:59 - them but anyways you're not going to see
171:01 - this inside of your remix because you
171:03 - didn't deploy this contract but you need
171:05 - to interact with the contract again on
171:07 - the gorilli test Network you need to be
171:09 - on the gorilla test Network otherwise
171:10 - this isn't going to work for you so what
171:12 - you're going to do is you're going to
171:13 - take the contract address which will be
171:14 - linked in the description and you're
171:16 - going to paste it right here where it
171:18 - says or at address okay so it should say
171:20 - that right at the bottom you're going to
171:22 - do that and then it will load this
171:23 - contract now notice it just loaded the
171:25 - same contract for me to twice because I
171:27 - already had it here but that's how you
171:29 - can load again just copy it paste it in
171:31 - here and then it will load it right here
171:33 - now what you're going to want to do is
171:35 - you're going to want to start by setting
171:36 - the approval for all now I'm going to
171:38 - discuss what this is in a second
171:40 - but essentially what you need to do here
171:42 - is you need to allow this smart contract
171:45 - being the auction to actually transfer
171:48 - your nft now if you don't allow it to do
171:51 - that you're not going to be able to
171:52 - actually auction the nft the reason you
171:54 - can't auction the nft is because the
171:56 - contract will not have the ability to
171:58 - take the nft and transfer it to itself
172:00 - so you have to explicitly give the
172:02 - contract permission to do that before
172:04 - you create your nft so what you're going
172:06 - to do is go to your auction contract
172:09 - this is going to be different than mine
172:11 - you're going to copy the address of your
172:12 - auction contract
172:14 - okay I've done that I'm going to go to
172:15 - Tim coin I'm going to go to set approved
172:18 - for all I'm going to paste in my
172:20 - contract like this
172:22 - then I'm going to go comma and I'm going
172:24 - to go true now look here it says
172:26 - operator which is this so the operator
172:28 - is the auction contract it's going to be
172:30 - operating on this nft and then true now
172:32 - what this is going to do is it's going
172:34 - to allow this contract to pretty much
172:36 - list any of your nfts now you still have
172:39 - to call the contract for it to do that
172:41 - but you're giving it explicit permission
172:43 - for it to access any of the Tim coin
172:45 - nfts that you have access to so don't
172:47 - worry this doesn't mess with any other
172:48 - nfts you might have on your ethereum
172:50 - account and we're on a test Network
172:51 - anyway so it shouldn't matter but I'm
172:53 - going to press transact this should go
172:55 - or this should be successful once I
172:57 - click confirm here
172:58 - okay so let's wait for that to finish
173:00 - and then we have set the approval for
173:03 - all of the nfts that you own to be able
173:05 - to be operated by the auction contract
173:08 - again what you're passing here is the
173:09 - auction contract now it's very important
173:11 - that you do this first before you
173:13 - actually give yourself an nft otherwise
173:15 - the nft you give yourself will not have
173:17 - the approval set for it for the uh
173:19 - auction contract okay so now that we've
173:21 - done that
173:22 - let's close all these and we're going to
173:24 - go to the award item function now this
173:26 - is what you want to press when you want
173:28 - to give yourself an nft so you're going
173:30 - to copy your address so my address is
173:31 - right here I'm going to copy it in to a
173:33 - word item and then what it says here is
173:35 - that there is a URI now the token URI is
173:40 - actually a URL to Json metadata related
173:43 - to this nft so as you may have seen nfts
173:46 - have like fancy images and music and
173:48 - gifs and all of this very valuable stuff
173:51 - anyways the point is all of that stuff
173:53 - is stored off of the blockchain on a
173:55 - specific URL in Json data and so what
173:58 - you actually have to do is associate
174:00 - data with your nft off the blockchain so
174:03 - when I create the nft I pass the URL of
174:06 - the data sitting off the blockchain that
174:08 - represents my nft and then it links
174:10 - those two together and that's why when
174:12 - you go and you view nfts you see like a
174:14 - nice little fancy image it's because
174:15 - it's referencing the URI of this uh nft
174:19 - and then it's grabbing the image for it
174:21 - and displaying pretty straightforward
174:23 - but that's really how nfts work again
174:25 - I'm not it's not meant to be an entire
174:26 - lesson on nfts but the token URI is just
174:28 - that it's a URL now you actually don't
174:30 - need to pass anything here I'm just
174:32 - going to pass like one two like you have
174:34 - to give some data but you don't have to
174:35 - give a URL so I can pass one two three
174:36 - zero whatever doesn't matter so just go
174:39 - like that and when I hit transact then
174:42 - what's going to happen is it's actually
174:43 - going to give your ethereum account or
174:45 - whatever account you put the address for
174:47 - in nft so let's wait a second and then
174:50 - I'll show you that we actually will have
174:51 - Tim coin showing up in our ethereum
174:54 - won't okay so that finished so now if I
174:56 - go to metamask so let's get out of this
174:58 - here
174:59 - let's go to metamask and let's look at
175:02 - my account let's go to assets and notice
175:05 - how it says don't see your tokens import
175:07 - tokens so I'm going to click on import
175:08 - tokens and I'm going to copy in the
175:11 - token uh contract address of Tim coin
175:13 - now again that's what will be linked in
175:15 - the description I can just copy it from
175:16 - right here
175:17 - so I'm going to go here I'm going to go
175:19 - to assets import tokens I'm going to
175:21 - paste this in notice the symbol is Tim
175:24 - very fitting for the token decimal just
175:26 - put 0 and then add custom token and now
175:29 - it's showing that I have one Tim uh
175:31 - token so I'm going to go import tokens
175:32 - like that and now if I look at my assets
175:35 - I see one Tim coin okay
175:38 - it's just looking at the contract and
175:39 - since it follows the ERC 721 protocol
175:42 - it's able to specify that I have one of
175:44 - these now if you want to own multiple
175:45 - just do this again just call the
175:47 - contract you can even pass the same URI
175:49 - it really doesn't matter and hit
175:51 - transact
175:52 - and now when you do this you're just
175:53 - gonna have to wait a second and then
175:55 - your wallet should update and once this
175:57 - is done you'll now have two Tim coins
175:58 - and in fact just because this is
176:00 - interesting I will show you that if I go
176:02 - to metamask I go to my wallet here
176:06 - and let's go view account on etherscan
176:08 - you can actually view the Tim coins that
176:10 - you have on here so notice I can go to
176:12 - token and I can specify timcoin and when
176:15 - I go here you can see that I have the
176:17 - token ID of one I have one Tim coin that
176:19 - was just added here in one minute now if
176:21 - I refresh this I should have a second
176:23 - Tim coin in a second because I just
176:25 - requested that uh okay it might take a
176:27 - second so let's go back to where we were
176:30 - before
176:31 - okay uh word item let's refresh okay so
176:34 - now we should have two Tim coins if we
176:36 - go here yes there we go now we have Tim
176:38 - coins and the token ID is one and two so
176:41 - if you want to see what your token ID is
176:42 - because all of you're gonna have a
176:43 - different token ID you need to do what I
176:45 - just did go to metamask You're Gonna
176:47 - view your account on metamask so I went
176:50 - to where is that here view account on
176:53 - sorry not metamask on etherscan it's
176:56 - going to bring you to etherscan and then
176:57 - what you can do is go to your Tim coins
176:59 - I showed you how to do that but let's go
177:00 - back
177:01 - so you're just going to click here click
177:03 - on Tim coin and then it will show you
177:05 - your token ID so you own token ID one
177:07 - and two well in this case I own one and
177:09 - two you'll own something that's not one
177:10 - and two because it's going to be a
177:11 - unique ID so this means I can auction
177:13 - token ID one and two because I own that
177:15 - so now how do we auction it well this is
177:17 - kind of the Moment of Truth here to see
177:19 - if this is all going to work so I'm
177:20 - going to copy the address of my Tim coin
177:23 - uh nft contract okay
177:26 - then I'm going to go to start I'm going
177:28 - to paste that in as the first argument
177:30 - so let's go here for the nft ID you have
177:33 - to post an ID that you own so either one
177:35 - or two for me and then put a starting
177:36 - bid so I'm going to put a thousand and
177:39 - I'm going to hit transact like this okay
177:41 - fingers crossed once I hit this let's
177:44 - see if this works and if everything we
177:46 - did was successful okay so very good we
177:49 - see the green check mark here meaning
177:51 - that this was good so now let's go to
177:53 - nft and notice the address is this nftid
177:56 - is one seller is me started is true
177:59 - highest bid is the zero address because
178:01 - no one's made a bid yet and then we have
178:03 - highest bid now of course this will work
178:05 - as it would would work before as we
178:07 - tested it previously and this will now
178:09 - take how many days did we set if we go
178:11 - here
178:12 - I think we set two days yeah so after
178:15 - two days then you'll actually be able to
178:17 - win your nft when someone hits the end
178:19 - button or sends the end request uh to
178:22 - this contract okay so that is going to
178:25 - wrap up the video I hope this was
178:27 - helpful in terms of giving you a deeper
178:29 - understanding of solidity and smart
178:31 - contracts and showing you a real
178:32 - practical application hosted on the
178:35 - blockchain now in the next videos we're
178:37 - going to be talking about some of the
178:38 - scaling limitations of ethereum and of
178:40 - solidity and some of the problems you
178:42 - can run into when you need to perform
178:44 - large computations then I'm going to be
178:46 - showing you some scaling Solutions so
178:48 - ways that you can mitigate those
178:50 - concerns and we'll be talking about
178:51 - cartesi which again is the sponsor of
178:53 - this video and this series and showing
178:55 - you some of the solutions that they
178:56 - provide again I really hope that you
178:58 - guys have learned a lot from these
179:00 - videos I've been having a great time
179:01 - filming them well I look forward to
179:03 - posting more on the Channel with that
179:05 - said if you enjoyed make sure to leave a
179:06 - like subscribe to the channel and I will
179:08 - see you in the next one
179:09 - [Music]
179:12 - hello everybody and welcome to the fifth
179:15 - video in this blockchain for beginners
179:17 - tutorial series now in this video I'm
179:19 - going to be talking to you about the
179:21 - limitations of solidity and of smart
179:23 - contracts and some applications that are
179:26 - very difficult to deploy on the
179:28 - blockchain because of these limitations
179:30 - specifically I'll be talking to you
179:31 - about arrays strings for Loops while
179:34 - loops and why it's very expensive to use
179:36 - those things in a spark contract and how
179:39 - they can actually cause your smart
179:40 - contract to break or to be in a state
179:42 - where it can never be ran again I'll get
179:44 - into all of that in this video but
179:46 - before we dive in I do need to thank
179:47 - cartesi for sponsoring this video and
179:50 - this series as I've said many times
179:51 - they're an awesome company I've loved
179:53 - working with them through these videos
179:55 - they've really helped me come up with a
179:56 - great curriculum to teach you guys so
179:58 - another massive thank you to them and
180:00 - with that said let's go ahead and get
180:02 - into the video alright so I'm now on my
180:04 - computer and I am in remix in front of
180:06 - me I have a very simple smart contract
180:08 - and what I'm going to be doing in the
180:10 - first part of the video here is talking
180:11 - to you about arrays strings for Loops
180:14 - while loops and then finally structs now
180:17 - after we do that I'll talk about some of
180:18 - the limitations of solidities and
180:20 - expenses in using these different
180:22 - features and then we will talk about
180:23 - some potential I guess fixes or
180:25 - solutions for these limitations so let's
180:28 - begin by talking about arrays so the way
180:31 - you create an array in solidity is you
180:33 - define the type you would like to be
180:34 - inside of the array for all of the
180:35 - elements so in this case I'll say uint
180:37 - you put your square brackets like this
180:39 - if you wanted a multi-dimensional array
180:41 - you do another set of square brackets
180:43 - and then what you can do after this is
180:44 - put the name of the array or the
180:46 - modifier so I'm going to do something
180:47 - like public AR and then I can just close
180:50 - it off like that so there you go I've
180:52 - just now created a dynamically sized
180:54 - array in solidity so in solidity you can
180:57 - have both a statically sized or fixed
180:59 - sized array or a dynamically sized array
181:01 - if I do something like this where I just
181:03 - have square brackets with no element
181:04 - inside or no value inside this is
181:07 - dynamically sized so this means it will
181:09 - grow as I add more element moments to it
181:11 - now if I do something like 5 this is
181:13 - going to say this array can only have
181:15 - five elements inside of it and I will
181:16 - initialize those elements I believe all
181:19 - as zero all right so that's the basics
181:21 - for arrays now arrays are a reference
181:23 - type in solidity and that means that
181:25 - they are mutable and we can modify them
181:27 - once they have been created so we have
181:29 - direct index access we can access the
181:31 - length of elements or the length of the
181:33 - array story and again we can push
181:34 - elements inside okay so let's just
181:37 - deploy the contract right now and have a
181:39 - look at how we actually access the
181:40 - elements in this array so I'm going to
181:42 - deploy this when I go here notice I'm
181:44 - going to have ARR and then I can pass
181:46 - the index of the element that I want to
181:48 - access now raise our zero indexed so if
181:50 - I do something like ARR and 0 it's going
181:52 - to give me the value 0 because since we
181:54 - statically initialize this array we're
181:56 - going to have one element with value
181:57 - zero or sorry five elements with value
181:59 - zero inside of the array now let's
182:01 - access index one okay we get zero again
182:03 - let's do index four zero again let's do
182:06 - five and then notice here that we
182:09 - actually are going to get a revert the
182:10 - transaction has been reverted to the
182:12 - initial State and that's because an
182:13 - error would have occurred because we're
182:14 - accessing an index that is out of the
182:16 - bounds of this array perfect so now that
182:19 - we have done that let's look at how we
182:20 - can actually I guess modify the elements
182:22 - of this array so let's create a function
182:25 - let's say function I'm just going to say
182:27 - mod ARR standing for modify array we
182:30 - will make this a public function and
182:33 - we're not going to return anything we'll
182:34 - just actually modify this okay now
182:36 - inside of here I'm just going to take in
182:38 - a uint X and A uint
182:41 - uh idx and instead of X let's actually
182:45 - just go with value just so this is a
182:46 - little bit more clear now essentially
182:48 - what this is going to do is change the
182:49 - element at index to be equal to Value so
182:52 - let's just say AR at index let's go idx
182:56 - is equal to Val notice we're not getting
182:58 - any errors so this should be good to go
183:00 - okay so let's deploy the contract let's
183:02 - go here we're going to look at index 0
183:05 - . see that that has value zero now let's
183:08 - change this so let's pass to here a
183:11 - value of say 10 and an index of zero
183:14 - let's transact looks like that's all
183:16 - good now when we look here notice we
183:18 - have a value of 10. very basic that's
183:20 - how you can modify this array now what I
183:22 - want to do is create a dynamically sized
183:24 - array so let's simply change this by
183:26 - removing the five and now when we do mod
183:28 - array we're just going to take in a
183:29 - value and I'll show you how we can
183:31 - append this value or push it to the
183:33 - array pretty straightforward but you can
183:34 - use the dot push method so I can say AR
183:37 - dot push I can push the value which is
183:40 - uint and now this should be good so
183:43 - let's try this let's deploy the contract
183:45 - let me just delete this one here okay
183:48 - now we have mod array that takes it a
183:51 - value so let's just pass one let's pass
183:55 - two and let's pass three now let's look
183:58 - at index zero index zero is one index
184:01 - one is two and index two is three
184:03 - perfect there we go we just pushed
184:05 - elements into the array all right great
184:07 - so now that we've done that let me show
184:08 - you how we get the length of the array
184:10 - so I'm just going to say function get
184:13 - length we'll make this an external and
184:17 - then this can be a view function that
184:20 - returns and then we'll just put U ins
184:23 - like that and then inside of here I can
184:26 - simply return error dot length like that
184:29 - okay so this will give us the length you
184:31 - can just use the dot length property so
184:33 - let's now deploy this contract let's go
184:35 - deploy let's mod the array by adding one
184:38 - two and three now let's get the length
184:42 - and notice we have a length of three now
184:44 - let's add another element let's add four
184:45 - get length we're at four there you go
184:48 - that pretty much covers a race I don't
184:50 - think there's actually anything more to
184:52 - go through with the raise one thing you
184:54 - you can do is access individual elements
184:56 - using the index notation so I can do
184:58 - something like array at 0 is equal to
185:00 - one that's perfectly valid or I can just
185:03 - do array at zero that works as well as
185:05 - you saw previously uh last thing I will
185:08 - mention is that if you want to actually
185:10 - Define the literal for the array so you
185:12 - want to do something like this use
185:14 - square brackets so say uint public ARR
185:17 - and then one two three this is different
185:20 - than something like I guess C plus plus
185:22 - or Java where you would use uh squiggly
185:24 - brackets at least I think you use those
185:26 - in those languages anyways in slowly to
185:28 - use square brackets I to define the
185:29 - elements in the array perfect hopefully
185:32 - that is clear that pretty much covers a
185:34 - race okay so now that we have gone
185:35 - through a raise I want to cover strings
185:38 - so let's get rid of all of this now
185:40 - strings and solidity are very expensive
185:42 - to work with and same thing with a race
185:44 - arrays are very expensive as well and in
185:46 - fact the reason I'm showing them to you
185:48 - last is because mappings are much
185:50 - preferred over a Race So you pretty much
185:52 - never want to be using a raise or using
185:55 - strings if you can avoid doing so there
185:57 - is some use cases where you do need them
185:58 - but essentially you always want to go
186:00 - with something like a mapping as opposed
186:02 - to an array I won't get into all of the
186:03 - details but just understand that they
186:05 - cost a lot more gas than something like
186:07 - a mapping so if you can avoid it avoid
186:10 - using arrays and if you want to mess
186:11 - around with kind of the differences in
186:13 - arrays and mappings deploy a few
186:15 - contracts and look at the actual gas
186:17 - cost in terms of working with arrays
186:19 - versus working with mappings and same
186:21 - thing with strings strings are extremely
186:23 - expensive to use in solidity and one of
186:26 - the reasons for that is that a string in
186:27 - solidity is actually a bytes array so
186:30 - you can create a byte array like this
186:32 - now bytes are used for kind of a raw
186:34 - data type and a string and solidity
186:36 - essentially is a bytes array that's
186:38 - going to be decoded and encoded with
186:40 - utf-8 just allowing you to actually view
186:42 - the string
186:43 - so let me show you what I mean if I do
186:45 - something like string and I guess we can
186:47 - put public although we don't really need
186:48 - to and we'll expect this equal to a
186:50 - hello we can say this is equal to world
186:52 - that is completely valid now you want to
186:55 - again avoid using strings whenever you
186:57 - possibly can because they're very
186:59 - expensive to work with same reason with
187:01 - the arrays because they are actually
187:02 - represented by 8 bytes array now strings
187:05 - and solidity are extremely simple you do
187:07 - not have index access to them you cannot
187:10 - concatenate them you can't get the
187:11 - length of them there's actually almost
187:13 - no methods or properties for Strings you
187:15 - literally can just store a literal
187:17 - string and in most situations it's going
187:19 - to be much more efficient especially if
187:20 - you're working with large strings to
187:22 - store them off of the blockchain and
187:24 - simply store a hash of that string in
187:26 - the storage of your contract that will
187:28 - be much much cheaper than actually
187:30 - storing the string itself in the
187:31 - contract anyways let's deploy the
187:33 - contract here with the string notice
187:36 - that I can access this and I can have
187:38 - World threat I can see World there so
187:40 - let's create another function let's go
187:42 - function set stream ring and let's go
187:45 - string and then let's go with value now
187:49 - I'm not quite done with this yet I need
187:50 - to uh talk about something with having
187:52 - strings inside of functions but for now
187:54 - I will say hello is equal to Bell okay
187:57 - so notice that I'm getting an error here
187:59 - now why am I getting an error this
188:01 - function actually looks pretty valid
188:02 - right I have my string parameter I have
188:04 - this public I'm setting a value this
188:06 - should be good the reason why I'm
188:08 - getting an error here we can hover over
188:10 - this is because the data location must
188:12 - be memory or call data for a parameter
188:15 - so this is where I'm going to talk about
188:17 - the different storage locations that you
188:19 - have in your contract so in your
188:21 - contract you have state or storage
188:23 - they're kind of the same things storage
188:24 - State now that essentially means that
188:27 - you're persistently going to be storing
188:28 - this data in the smart contract itself
188:31 - now any data you store is going to cost
188:33 - you small amounts of ethereum right it's
188:35 - going to be more expensive to store more
188:36 - data than to store less you want to
188:38 - store the least amount of stuff that you
188:40 - possibly can so that's the first
188:41 - location storage state that's persistent
188:44 - it's always going to be there the other
188:46 - location is memory now memory similar to
188:49 - your computer's Ram is a temporary
188:51 - location that's only going to be used
188:52 - when the contract is actually executing
188:54 - so when I'm using a reference type like
188:56 - a string I need to specify it's going to
188:58 - be stored in memory so I'm going to say
189:00 - memory like this so as soon as I put
189:03 - memory we actually would have seen this
189:04 - before I think now this is valid because
189:06 - it's saying I want to store this
189:08 - parameter in memory as opposed to in the
189:10 - state or storage of the contract and you
189:13 - only need to specify this for reference
189:14 - data types so same thing with arrays
189:16 - let's say I did something like UNS and
189:19 - then I wanted to have my uh value like
189:22 - this I would need to now specify memory
189:25 - to not get yelled at by the compiler
189:26 - okay so let's go back though to what we
189:28 - had before string memory value low
189:30 - equals Bell let's deploy this let's look
189:33 - at this let's go hello world I am Tim
189:37 - let's set the string let's look at a low
189:40 - and now we have hello world I am 10.
189:42 - awesome again avoid using strings if you
189:44 - need to use a large string what you want
189:46 - to do is store it off the blockchain and
189:47 - simply store a hash of that string on
189:49 - the blockchain that will be much cheaper
189:51 - okay so now we've gone through a raise
189:53 - we have gone through strings I want to
189:54 - show you looping and then I will show
189:56 - you the gas costs associated with a lot
189:58 - of these different features I'm just
189:59 - trying to give you kind of the basics
190:00 - right now okay so let us
190:04 - um should we Loop through an array no
190:05 - let's just uh loop over kind of a range
190:07 - of numbers to start so I'm just going to
190:09 - say function and I will say Loop and I'm
190:12 - going to take in U and n
190:14 - and all I'm going to do here is simply
190:16 - Loop Over N numbers so to do a for Loop
190:19 - in solidity is similar to pretty much
190:21 - every other programming language you can
190:22 - say four and then you can Define your
190:25 - looping variable so I'm going to say U
190:27 - and I I'm going to say I is less than n
190:29 - and then I'm going to say I plus plus
190:32 - okay so I'm just incrementing I by 1 in
190:34 - every iteration and then what I'm going
190:36 - to do here is I guess we can just add to
190:39 - some variable or something because I'm
190:40 - just trying to illustrate Luke so I'll
190:42 - do something like uint sum is equal to
190:45 - zero and then sum plus equals I and I
190:50 - think that should be good and then if we
190:51 - wanted to we could return the sum but
190:53 - this is fine we'll just do this for now
190:54 - so I just had to take a quick cut there
190:56 - because my cat was freaking out at me
190:57 - for some reason anyways that is now
190:59 - resolved but continuing here uh we're
191:01 - getting a warning the reason we're
191:03 - getting a warning is because this can be
191:04 - restricted to Pure the reason for that
191:06 - is because we're not actually modifying
191:08 - or accessing the state of the contract
191:10 - so I just want to put pure like this
191:12 - anyways this is how you do a for Loop uh
191:15 - now I will mention that the for Loops
191:17 - again are going to be very very
191:18 - expensive to run if you're not doing
191:20 - them in something like a pure function
191:22 - right in a pure function or something
191:23 - that doesn't require a transaction it's
191:25 - not going to cost you ethereum to run
191:27 - this however it's going to be very
191:29 - expensive to implement for Loops when
191:30 - you're actually working with the state
191:32 - of the con contract now the reason for
191:34 - that is whenever you do a transaction
191:35 - you need to pass gas along with that
191:37 - transaction right and the gas cost is
191:40 - the sum of all the operations that the
191:42 - contract is doing so in this case it's
191:45 - going to cost me gas to actually add a
191:47 - number to another number right for me to
191:48 - add two numbers that cost gas but here
191:51 - in this situation the amount of gas this
191:52 - would cost if it wasn't a pure function
191:54 - is n multiplied by all of the gas used
191:58 - inside of the for Loop now that might
192:00 - not seem like a lot but if an N is a
192:03 - large number say like a thousand or ten
192:05 - thousand and the amount of gas in here
192:07 - is four gas 20 gas 100 gas something
192:10 - along those lines you can see how the
192:11 - amount of gas required adds up very very
192:14 - quickly and it becomes unfeasible to
192:16 - actually be able to Loop inside of smart
192:17 - contracts and in fact there's actually a
192:20 - maximum amount of gas that you can pass
192:21 - to an ethereum smart contract I believe
192:24 - right now it's at 30 million gas in fact
192:26 - I think that's right here it's the gas
192:28 - limit that's showing up regardless you
192:30 - can only pass so much gas so if your
192:32 - smart con contract needs to do a ton of
192:33 - computations you have to have multiple
192:35 - transactions to be able to complete that
192:38 - because you need to pass the required
192:40 - gas and you can only do a certain amount
192:42 - of gas in each transaction
192:44 - anyways that was kind of it for for
192:46 - Loops I just want to show you the syntax
192:47 - this is the basics of for Loops now I
192:49 - will show you while loops so let's do a
192:51 - very similar thing here let's just
192:53 - manually declare I so U and I is equal
192:56 - to zero we'll say well I is less than n
193:00 - we'll say I plus plus we can do that at
193:03 - the end and then we'll say sum plus
193:06 - equals I like that perfect there you go
193:09 - this is a while loop again not really
193:11 - going to explain this I'm sure most of
193:12 - you understand how this works anyways
193:15 - those are for loops and while loops and
193:17 - now that we've looked at those I want to
193:18 - write a very simple smart contract
193:20 - that's going to work with arrays and for
193:23 - Loops or while loops and show you how
193:25 - much gas it actually costs on an
193:26 - ethereum test Network so let's start by
193:29 - just initializing an array here and
193:31 - let's just say you ends and let's go ARR
193:34 - and let's just make this equal I guess
193:36 - actually I can just Define it like that
193:38 - uint AR that's fine for now then I'm
193:40 - going to have a function I'm going to
193:42 - say function create AR I'm going to say
193:45 - U and n and I will go with string value
193:49 - and I'm actually going to change the
193:51 - type of this array to be a string array
193:53 - and show you how expensive this gets
193:55 - okay now I will make this public
193:57 - now what I want to do here is
193:59 - essentially initialize this array with n
194:01 - elements that are equal to this string
194:03 - value now I need to remember to add my
194:04 - memory keyword otherwise it's going to
194:06 - get mad okay so let's do this so what
194:09 - I'm going to do is write a for Loop I'm
194:10 - going to say four again this will be i i
194:13 - u and I
194:15 - this is going to be I is less than n
194:18 - let's add a space here and then I plus
194:21 - plus
194:22 - okay now what we'll do is say ARR dot
194:25 - push and we're going to push the value
194:28 - like so okay so right now we can
194:31 - technically run this infinite number of
194:32 - times and I'll show you what happens if
194:34 - we try to do that but I want to deploy
194:36 - this to our injected web3 to the go
194:38 - rally test Network so it says custom
194:41 - Network right now let me just go to my
194:42 - metamask and change this to go rally and
194:44 - then we will deploy this and test it
194:45 - alright so we are back on go rally I'm
194:48 - going to deploy let's see how much this
194:50 - is going to cost us right now okay so
194:52 - not a significant amount of gas because
194:54 - obviously we haven't done any
194:55 - computation yet in the contract and then
194:57 - once this is deployed we'll actually try
194:59 - running this method and see how much gas
195:01 - it cost us alright so it looks as though
195:03 - the contract has been deployed we can
195:05 - see it down here it says create AR now
195:07 - let's just see again this is going to be
195:09 - kind of antidotal I'll just go through a
195:10 - few uh examples here how much it costs
195:12 - to do one that has 10 elements and the
195:15 - string hello world now I need to quote
195:18 - the string here so let's do that and
195:20 - let's transact and see approximately how
195:22 - much this costs us so when I do this
195:24 - notice we're getting
195:26 - 0.006876 okay so we can kind of copy
195:28 - that and keep that in mind and then I'll
195:31 - show you how this is gonna I guess not
195:32 - exponentially but go up a lot as I
195:35 - increase the value of n so let's now do
195:37 - one that has a thousand elements and see
195:40 - how much this costs so when I do
195:41 - transact now
195:42 - we're going to see that now we're at
195:44 - 0.05 now if you actually put that into
195:47 - the price of ethereum 0.05 ethereum is a
195:50 - lot now I'm not sure if it would be the
195:52 - exact same on the regular ethereum
195:54 - network but the point is you saw how we
195:56 - drastically increase this to a whole
195:58 - decimal point right just by making this
196:00 - a thousand instead of say 10. and then
196:02 - let's go crazy and let's make this
196:04 - something like a hundred thousand and
196:06 - transact and see how much this would
196:07 - cost and here it tells me we actually
196:09 - cannot even send this amount of gas the
196:11 - transaction will likely fail so let's go
196:13 - to ten thousand and see if 10 000 is a
196:15 - doable same thing we can't even do ten
196:18 - thousand let's try doing something like
196:20 - 5000 and see if that's gonna work okay
196:22 - 5000 doesn't work let's try
196:25 - 25 000 transact okay that's not gonna
196:28 - work so just trying to show you here
196:30 - that we really cannot do a lot of
196:32 - looping operations and even if we try to
196:34 - do a lot of looping operations that is
196:36 - going to be very very expensive to the
196:38 - point where it really doesn't make sense
196:39 - to do them inside of the smart contract
196:41 - all right so now that we've gone through
196:43 - those few examples just so you can see
196:44 - kind of in the real world how much the
196:46 - gas is going to cost let me delete all
196:49 - of this and show you that remix can
196:51 - actually give us a gas estimate for
196:53 - specific functions so what I can do is
196:55 - something like let's go uint X is equal
196:59 - to zero and let's go function set X
197:03 - let's take in a uint value let's just
197:07 - make this public and then what we can do
197:10 - is say x is equal to Value okay so this
197:13 - is my function very very simple all
197:15 - we're doing is assigning a variable now
197:16 - if I hover over the function name notice
197:19 - that down here kind of in the right
197:21 - corner or I guess not really corner but
197:22 - right on the console bar it's showing us
197:24 - the execution is going to be 22
197:27 - 498 gas so that's a significant amount
197:30 - of gas considering we're only doing a
197:32 - very simple operation all right so now
197:34 - that we've seen that let's just do a few
197:36 - more examples and estimate some more gas
197:37 - costs so another thing we might want to
197:40 - do is evaluate a condition maybe we want
197:42 - to use a require statement or something
197:43 - like that so let's just do something
197:45 - like
197:46 - require and we'll say Val is greater
197:50 - than and let's just go with 10 and we'll
197:52 - say Val is too low okay put our
197:55 - semicolon let's see how much gas it's
197:57 - telling us now so if I hover over here
197:59 - now you can see the gas has increased a
198:01 - small amount so the require statement
198:02 - doesn't really use that much gas right
198:04 - now let's see what happens if we try to
198:06 - add a number so let's do something like
198:07 - X plus equals Val multiplied by 10 and
198:12 - let's look at the gas estimate now and
198:14 - nose is giving us infinite gas now
198:16 - whenever you're seeing infinite gas that
198:18 - usually means a remix is not able to
198:20 - estimate how much this is going to cost
198:21 - now in this case uh the reason saying
198:23 - infinite is because Val can be any
198:25 - single number now if Val is any number
198:27 - greater than 10 when I multiply this by
198:29 - 10 remix has no idea how much this
198:32 - computation is going to cost because the
198:34 - larger value is then you know the more
198:36 - that this is going to be the more gas
198:38 - this is going to cost because the more
198:40 - addition operations we need to do
198:41 - essentially whenever you're doing
198:43 - multiplication you're really doing
198:44 - repeated addition and while the more
198:46 - repeated addition the more gas this
198:48 - costs so infinite gas is just telling
198:50 - you it could theoretically be anything
198:51 - and you really want to try to limit
198:53 - these functions so that they cannot cost
198:55 - infinite gas because if they cost
198:57 - infinite gas you could do a transaction
198:58 - that will never be able to run because
199:01 - you can't pass enough gas to actually be
199:03 - able to execute it all right hopefully
199:05 - that makes a bit of sense I just want to
199:06 - give you a quick example of the gas
199:08 - costs and how quickly they go up using
199:10 - smart contracts now I will talk to you
199:12 - about structs and then we'll talk about
199:14 - some programs that are really limited on
199:17 - the blockchain because of the fact that
199:19 - we can't really do any looping or at
199:21 - least not very efficiently alright so to
199:23 - illustrate structs to you I first want
199:24 - to start by showing the alternative to
199:26 - structs which would be actually
199:28 - representing objects using contracts now
199:31 - contracts just like classes can be
199:32 - instantiated so I can have different
199:34 - instances of the contract now typically
199:37 - we just deploy a single contract but
199:39 - this contract can instantiate another
199:40 - contract and then have a reference to
199:43 - them so for example I can do something
199:45 - like this I can have contract person I
199:47 - can have you and age string name you and
199:49 - balance I can have a Constructor and I
199:51 - can treat this just like I would any
199:53 - other class and say jump right now from
199:56 - this tutorial class what I might do is
199:58 - create a function like this I might say
200:00 - function
200:01 - create and then person and then maybe I
200:04 - take in my uint age and then my string
200:09 - memory name like that and then the
200:11 - balance we would just imagine would be
200:13 - uh implemented at another time okay then
200:16 - I'm going to say public and then inside
200:17 - of here what I can do is actually create
200:19 - an instance of this person class so I
200:21 - would say person person equals new
200:23 - person and then I would just pass my
200:26 - Constructor values so uh this needs to
200:29 - be a string sorry age and name okay
200:32 - there we go I've just created a person
200:33 - instance now this is an instance of this
200:36 - contract now this looks perfectly fine
200:38 - however this is going to cost you a ton
200:40 - of gas because contracts are much more
200:42 - expensive to work with than structs so
200:44 - instead what you would want to do is
200:46 - replace this contract with the struct
200:48 - now the struct would look something like
200:50 - this
200:51 - uh let's do this struct and then we can
200:54 - remove the Constructor and just do the
200:56 - font now there's a few other changes I
200:58 - need to make here so when I'm working
200:59 - with a struct first of all I no longer
201:01 - need the new keyword and I also need to
201:03 - pass a balance right so I'm going to
201:05 - pass the balance zero the reason I need
201:07 - the balance is because this is a
201:08 - required field in the struct I'm storing
201:10 - an age a name and a balance and if I
201:12 - initialize my struct in this way then I
201:14 - need to pass all of these fields I'll
201:16 - show you another way to initialize it in
201:17 - a second now we're getting an error the
201:19 - error is that I need to specify the
201:21 - location for this type the reason for
201:23 - that is this is a reference data type
201:25 - meaning it's mutable so I can change it
201:26 - later on
201:27 - so I need to specify memory here just
201:30 - like for my strings now when I do this
201:32 - notice it's all good now it's telling me
201:34 - I can make this a pure function I
201:35 - believe yeah because I'm not actually
201:36 - working with the state of the contract
201:38 - this is just an example to illustrate
201:41 - the struct now I'm getting a warning
201:43 - here just saying that this can be a pure
201:44 - function because uh what do you call
201:46 - we're not dealing with the state of the
201:48 - contract anyways this is what you want
201:50 - to do if you want to store like custom
201:52 - data essentially in a custom type create
201:54 - a struct rather than creating a contract
201:56 - so now to really uh kind of show the use
201:59 - case of a struct we'll write a very
202:01 - simple contract that's going to allow us
202:03 - to associate an address with a person so
202:06 - what I'm going to do is put a mapping up
202:08 - here and I'm going to map and address to
202:12 - a person like that totally fine for me
202:14 - to do that and I will just call this
202:16 - people
202:17 - so now when I create my person I will
202:20 - add them into the uh the people map so
202:23 - what I'll do after I make my person is
202:25 - I'll say people at and then this is
202:27 - going to be the address so message dot
202:30 - sender is equal to person like that and
202:33 - then of course I would adjust the
202:34 - balance if money was sent into this
202:37 - contract so now that we've seen this
202:38 - I'll just show you another way of
202:40 - initializing this person because we
202:41 - don't have to do it in this way so I can
202:43 - actually remove kind of the literal I
202:45 - guess written person and just say person
202:48 - memory person like that and now I can
202:50 - just specify the attributes on this
202:52 - person so I can say person.age
202:55 - is equal to age I can say person dot
202:59 - name
202:59 - is equal to name and then if I don't do
203:02 - anything for the balance that's
203:03 - completely fine because the balance will
203:04 - be initialized as zero anyways that's
203:07 - another way that you can initialize a
203:08 - struct just wanted to show you you can
203:09 - do it in this way or you can actually
203:10 - write out kind of I guess the main
203:13 - initialization or the Constructor
203:14 - initialization where you pass in those
203:16 - values anyways that is pretty much all I
203:19 - had for this first section here I showed
203:22 - you the gas costs associated with
203:24 - looping and how looping is really a big
203:26 - problem in smart contracts and is
203:27 - unfeasible especially if you're doing a
203:29 - large amount of computations I also
203:31 - showed you that storing strings and
203:33 - bytes is very expensive and you don't
203:35 - want to do that lastly I talked about
203:37 - structs here and how if you want to
203:39 - represent kind of a custom object or a
203:41 - custom type it's much cheaper and better
203:44 - practice to use a struct rather than to
203:46 - use a separate contract right which
203:49 - would kind of act as a class you don't
203:50 - really want to be doing that in solidity
203:52 - there are some use cases but if we're
203:54 - going to be creating a ton of different
203:55 - people like this we definitely don't
203:56 - want to be using a separate contract now
203:59 - what I would like to do is really focus
204:01 - more on the limitations of solidity
204:02 - based on some of these things you just
204:04 - saw and talk about how we would
204:06 - Implement something like an order book
204:08 - in solidity now an order book is
204:10 - essentially what to use when you're
204:11 - trading stocks you're trading assets of
204:13 - some sort you want to have buy orders
204:15 - and sell orders and match the buy and
204:17 - the the sell orders now in
204:19 - cryptocurrency you definitely need this
204:20 - need a way to exchange your different
204:22 - coins buy coins sell coins whatever it
204:25 - may be so I'm going to hop over to the
204:27 - Blackboard now or the drawing tablet and
204:29 - start talking to you about how we would
204:30 - Implement order book in solidity a lot
204:33 - of the problems that we're going to run
204:34 - into doing that and then some of the
204:36 - solutions we may have to actually make
204:38 - this more feasy alright so I'm here on
204:40 - my drawing tablet I want to begin by
204:42 - explaining to you what an order book is
204:44 - so an order book is essentially used
204:46 - whenever you're trying to trade
204:47 - something so in this situation let's say
204:49 - we're talking about US Dollars and then
204:51 - something like ethereum now in order
204:53 - book just really States the buy and the
204:56 - sell orders for this specific asset so
204:58 - in this case with US Dollars we would be
205:00 - buying ethereums these would be our buy
205:02 - orders and then on the other side we
205:03 - would have sell orders now whenever we
205:06 - want to actually make a trade we need to
205:08 - match buy and sell orders together based
205:10 - on the price so when I put in a buy
205:12 - order I need to specify the price that I
205:14 - want to purchase ethereum at now what I
205:17 - would do is something like one ethereum
205:19 - and then I want to buy this at maybe 4K
205:21 - right that's the price that I'm willing
205:23 - to buy this at I put that buy order into
205:25 - the book
205:26 - now maybe someone wants to sell ethereum
205:28 - maybe they're selling one ethereum and
205:30 - maybe they want to sell it at like 4.4
205:32 - 000. well if this is the case we cannot
205:34 - match these two orders together because
205:35 - they have different prices now you can
205:38 - probably realize just by looking at this
205:39 - it's going to be very difficult to
205:41 - actually match buy and sell orders
205:43 - because the probability that two people
205:45 - are going to have the exact same price
205:46 - in mind for this specific asset well
205:49 - that's just very rare you know the
205:50 - seller is always going to want to sell
205:51 - High the buyer is always going to want
205:53 - to buy low so because of this situation
205:55 - we can use multiple buy orders or
205:57 - multiple sell orders to fill either
205:59 - order right so maybe I have a ton of
206:01 - small bios something like 0.1 ethereum
206:04 - well if all of these small orders allow
206:06 - me to actually fill one large cell order
206:08 - then I would use you know all let's say
206:10 - 10 of these to fill this one ethereum
206:12 - order now of course they have to be at
206:13 - the same price and so we end up running
206:15 - into the same problem again now this is
206:17 - where we talk about something called
206:18 - market makers so I'm going to draw this
206:20 - right here Market make now a market
206:22 - maker essentially provides liquidity to
206:25 - this trading pair or to this order book
206:27 - Because as I was saying it's gonna be
206:29 - very rare to have our buyers and sellers
206:31 - agreeing on a price so the market maker
206:33 - is actually a neutral entity that's
206:36 - always willing to buy and always willing
206:38 - to sell now they have incentives to do
206:40 - this they will earn some rewards some
206:41 - fees whatever it may be but the idea is
206:44 - they're always buying and they're always
206:45 - selling and this allows liquidity in
206:47 - this market they make the market it
206:49 - allows me at any point in time to go and
206:51 - buy my ethereum or sell the ethereum now
206:54 - the market maker is pretty well
206:55 - dictating the price of this asset based
206:58 - on the pressure to buy and the pressure
206:59 - to sell now I don't want to get more
207:01 - into this because it's a bit beyond my
207:03 - scope of knowledge and finance and all
207:05 - of that that's the basics of an order
207:07 - book and now we'll talk about how you
207:08 - would Implement something like that on
207:10 - the blockchain so of course an order
207:11 - book is pretty important especially when
207:13 - we're talking about cryptocurrency
207:14 - people want to buy and people want to
207:16 - sell so let's draw out another order
207:19 - book right here
207:20 - and I'll talk about how we would
207:21 - actually kind of do this algorithmically
207:23 - because of course although this was done
207:25 - manually in the old days we now have
207:27 - computers that do this for us and they
207:28 - can do it very very quickly and
207:30 - efficiently so let's say we have a bunch
207:32 - of buy orders over here in green we have
207:34 - a bunch of cell orders here in red well
207:37 - the first thing that we should realize
207:39 - is that since we're going to implement
207:40 - this as a smart contract if someone is
207:42 - going to be making say a large sell
207:44 - order maybe a one ethereum or maybe a
207:46 - lot more than one ethereum they're going
207:48 - to have to use uh usually multiple buy
207:51 - orders to fill this cell order so they
207:54 - may have to actually Loop maybe 20 30 40
207:57 - maybe 500 times to actually fill their
208:00 - order and as we saw previously looping
208:02 - is very very expensive and so the more
208:04 - looping we have to do the more it's
208:06 - going to cost whoever is performing the
208:08 - transaction now we also may run into a
208:10 - problem where someone needs to Loop more
208:12 - times than that is allowed in the smart
208:14 - contract based on the gas limit let's
208:17 - say I want to make a sell order of maybe
208:19 - a hundred ethereum well the chances that
208:21 - someone else is going to be buying 100
208:22 - ethereum is Slim maybe there's a ton of
208:25 - people buying a small amount of ethereum
208:26 - so I might have to Loop say 2 000 times
208:29 - now if the maximum number of Loops I can
208:32 - do in one iteration of my smart
208:34 - contractor one calls or in my smart
208:35 - contract is a hundred then I'm gonna
208:38 - have to split this into two separate
208:40 - orders to be able to actually make this
208:42 - sell right I'm gonna have to do two 50th
208:44 - cells because I can only do a thousand
208:47 - Loops in one smart contract transaction
208:50 - so that's kind of the main problem we're
208:51 - going to run into here and it really
208:53 - just has to do with the ability of
208:54 - looping with the smart contract now this
208:57 - is kind of a naive perspective because
208:59 - this assumes that everyone interacting
209:01 - with this contract is interacting with
209:03 - good intentions they are a good actor
209:05 - everyone wants to buy everyone wants to
209:07 - sell they're not trying to manipulate
209:09 - the market but of course people are
209:10 - always going to try to manipulate the
209:11 - market and one way they could do that
209:13 - with something like this is they could
209:15 - put in a ton of tiny buy orders so let's
209:18 - say we have some buyer who's really
209:20 - trying to kind of lag the smart contract
209:21 - and make it take a very long time or be
209:23 - very expensive to interact with well the
209:26 - way they would do this is they would put
209:28 - in a ton of fractional kind of bogus buy
209:30 - orders and they would do this many many
209:32 - times let's say maybe they have a
209:34 - thousand of these orders realistically
209:35 - it would be way more than that but they
209:37 - have a ton of these orders that they're
209:38 - adding they're all very small bios well
209:40 - now even if I want to make a relatively
209:42 - small sell order of say one ethereum I
209:45 - have to Loop thousands of times in this
209:47 - case probably hundreds of thousands of
209:49 - times to actually be able to fill this
209:50 - order because there's so many small buy
209:52 - orders so now again that requires me as
209:55 - the seller to split this into very very
209:57 - small amounts to be selling so maybe I
209:59 - have to sell this amount at a time
210:02 - because I just cannot do enough Loops in
210:04 - my smart contract transaction
210:06 - so that's kind of a main problem that
210:08 - can arise here you can have people try
210:10 - to manipulate the market and when
210:11 - someone does this if we're not handling
210:13 - this correctly it's going to cause the
210:15 - seller practically to not be able to
210:16 - sell because it's going to take them so
210:18 - long and it's going to cost them a lot
210:20 - of money to do that so the way that we
210:22 - de-incentivize this type of behavior is
210:24 - we put the burden of looping on the
210:26 - buyer now the seller is still going to
210:28 - have to Loop to fill their order but we
210:30 - try to make it so that less small buy
210:32 - orders come in by kind of penalizing
210:34 - those so for example if we want to
210:36 - purchase one ethereum what we do as the
210:39 - seller is we Loop through buy orders
210:41 - hopefully in efficient manner and we
210:43 - Mark all of the orders that we require
210:44 - to fill this cell order as executed now
210:47 - when we mark them as executed that
210:49 - essentially means that we've made the
210:51 - trade so we immediately take all of the
210:53 - USD funds we give those to the seller
210:56 - but then we lock this asset in the smart
210:59 - contract and we require that the buyer
211:01 - do as many transactions as they
211:04 - originally did to buy to be able to take
211:06 - their stock back so what I mean by that
211:09 - is if they did a thousand of these tiny
211:11 - little transactions they need to do a
211:14 - thousand more transactions to retrieve
211:16 - all of those funds from the smart
211:18 - contract so for example if they want to
211:20 - take whatever it is they bought for you
211:22 - know 0.0001 USD or after whatever it's
211:25 - going to be then they need to do one
211:27 - transaction and that will give them
211:28 - whatever the amount of stock that was
211:30 - traded in this specific trade hopefully
211:32 - that's making a bit of sense but they
211:34 - will take this amount of ethereum
211:35 - they'll get that from this one
211:37 - transaction then they have to do this a
211:39 - thousand more times because they had so
211:41 - many orders so for every order they need
211:43 - to do one transaction to retrieve all of
211:45 - the funds that were traded in that
211:47 - specific order
211:48 - so this now puts the burden of looping
211:50 - on the buyer and hopefully
211:52 - de-incentivizes them from doing this now
211:54 - of course we still have this underlying
211:56 - problem that the seller needs to do
211:58 - looping to be able to actually fill
212:00 - their sell order so we need to come up
212:02 - with an efficient way to do this and
212:04 - that's what I want to talk to you about
212:05 - now as we head over to the other screen
212:07 - so to reiterate here the main problem
212:09 - that we're running into is that we're
212:11 - requiring a ton of Loops to be able to
212:14 - perform buy and sell orders and even if
212:17 - we Implement that previous solution we
212:18 - talked about the seller still needs to
212:21 - determine which buy orders to match with
212:23 - to be able to make the sale right and
212:25 - then we have to mark orders as executed
212:27 - we have to store these orders somewhere
212:29 - how do we do all of that that's really
212:31 - the question right now and how do we do
212:33 - it in an efficient manner because we
212:34 - can't have nested for Loops we can't
212:36 - have any crazy algorithms that are
212:38 - taking really long time to run that's
212:40 - just not feasible on the blockchain and
212:42 - with smart contracts now solution one is
212:45 - really the approach that has to be done
212:47 - on the blockchain and this this is to
212:49 - come up with the most efficient data
212:51 - structures and algorithms possible to
212:53 - implement what we just talked about we
212:54 - need probably an advanced type of tree
212:56 - that's going to allow us to look for the
212:58 - largest possible orders to fill the
213:00 - largest cell orders so we only use four
213:02 - five six orders and require a very
213:05 - little amount of looping to be able to
213:07 - make a sale now of course the same thing
213:08 - happens on the buy side the idea though
213:10 - is that we need to do all of this
213:11 - efficiently and again we need to manage
213:13 - our storage efficiently as well because
213:15 - it's expensive to store orders on the
213:17 - blockchain so solution one is
213:19 - essentially be a genius and come up with
213:21 - a great data structure and algorithm
213:23 - that has no bugs has no problems is
213:25 - never going to be inefficient and use
213:26 - that now of course that's not really the
213:29 - most reasonable approach ask me to
213:30 - implement order book I have no idea
213:32 - where to even start that's going to be
213:33 - very complicated I'm gonna have to do a
213:35 - ton of research hopefully I'm going to
213:36 - find someone who's done something like
213:38 - this before and kind of copy what they
213:39 - have but even then again this is just
213:41 - really an impractical approach for most
213:43 - people trying to implement something
213:45 - like this and even if you do come up
213:46 - with an implementation the first
213:48 - approach is most likely going to be
213:49 - buggy it's going to be inefficient and
213:51 - it's probably going to be infeasible to
213:53 - use so then solution 2 is essentially
213:55 - kind of similar to solution one copy
213:58 - someone else who's already done this
213:59 - hope that there's some genius out there
214:01 - who's written a great order book just
214:03 - take the exact same order book maybe
214:04 - modify it a little bit if you were
214:06 - trying to make your own and use that now
214:08 - again that's really still not a great
214:09 - approach you can still have a lot of
214:11 - inefficiencies and you still might have
214:13 - to Loop a ton of times to be able to
214:15 - fill a buy or sell order now the third
214:18 - solution is kind of more of an abstract
214:19 - one but this would be to use something
214:21 - off the blockchain maybe like a SQL
214:23 - database that's already very efficient
214:25 - at searching for specific orders maybe
214:27 - you write some Advanced select query
214:29 - that can kind of give this information
214:31 - to you and then you store hashes of this
214:33 - on the blockchain whatever it's going to
214:35 - be unfortunately interacting with SQL
214:37 - from the blockchain isn't really
214:38 - possible right now at least I don't know
214:40 - how to do that and so that kind of
214:42 - limits that option as well so even with
214:44 - the only feasible option which is
214:46 - essentially have a really good data
214:48 - structure and algorithm you're still
214:50 - running into problems now you might be
214:51 - asking yourself at this point in time
214:53 - well how is this done then how do people
214:54 - do this if this is such a problem now
214:56 - you can still use an order book it's
214:58 - just not going to be the most efficient
214:59 - thing in the world but what a lot of
215:01 - platforms are doing now is using
215:02 - something called a liquidity pool now
215:04 - liquidity pool has its own issues I'm
215:06 - not going to talk about those in this
215:07 - video essentially liquidity pool is just
215:10 - a store of a ton of the assets that
215:12 - you're going to be trading so you have
215:13 - whatever asset one is an asset to you
215:16 - have usually an equal amount of them in
215:17 - the pool and then based on the demand
215:19 - for the specific assets the price of
215:21 - those assets will fluctuate within the
215:23 - liquidity pool and the people providing
215:25 - liquidity so putting their assets into
215:26 - the pool will be given a type of reward
215:28 - kind of like a fee that you would pay
215:30 - when you're actually trading them right
215:31 - anyways that's liquid equal again has
215:33 - its own issues but that's kind of an
215:35 - approach that's being used currently and
215:37 - really with that said I think I'm going
215:39 - to wrap up the video here now I know I
215:41 - didn't talk too much about the solutions
215:42 - but that's because this this video is
215:44 - really focused on the limitations of the
215:47 - blockchain and showing you that a lot of
215:48 - stuff we would like to be able to create
215:50 - that would be way simpler to do off the
215:52 - blockchain we just can't feasibly do
215:54 - using spark contracts and on the
215:56 - blockchain because of those limitations
215:58 - now even the stuff I showed you at the
216:00 - beginning of the video strings arrays
216:02 - for Loops while Loops those are very
216:03 - inefficient to use they cost a lot of
216:05 - money and the reason we left them until
216:07 - the very end was because we don't really
216:09 - want to encourage their use and I want
216:11 - to make sure that you understand kind of
216:14 - the problems with them and that they do
216:15 - exist you can use them but you should be
216:17 - very careful when you're implementing
216:18 - those specific features alright so with
216:20 - that said I am going to end the video
216:22 - here another massive thank you to
216:23 - cartesi for sponsoring this video and
216:25 - this series in the next video we'll be
216:27 - looking at specific Solutions and how we
216:29 - can actually write scalable smart
216:31 - contracts and decentralized applications
216:33 - I hope you guys enjoyed if you did make
216:35 - sure to leave a like subscribe to the
216:36 - channel and I will see you in another
216:38 - one
216:38 - [Music]
216:41 - hello everybody and welcome to the sixth
216:44 - and final video in this blockchain for
216:46 - beginners tutorial Series in this video
216:49 - I'm going to talk to you about ethereum
216:51 - scaling Solutions specifically Solutions
216:54 - on layer 1 and on layer 2. and of course
216:57 - I'll describe what layer 1 and layer 2
216:59 - meet now the reason we need ethereum
217:01 - scaling Solutions is because as you've
217:03 - seen through this series ethereum can be
217:06 - quite slow and the number of
217:07 - transactions that it can handle per
217:09 - second is very very small now this means
217:12 - it takes a really long time for us to
217:13 - actually submit a transaction to the
217:15 - blockchain and have that processed and
217:17 - validated and if we want to be using a
217:19 - smart contract to perform computations
217:21 - that can take a really long time as well
217:23 - or be infeasible based on the amount of
217:26 - say iterations we need to do within a
217:28 - for Loop or something along those lines
217:30 - so there's tons of reasons why we need
217:31 - better scalability on ethereum and
217:34 - fortunately there's many different
217:35 - solutions so with that said we'll go
217:37 - ahead and get into the video but I do
217:39 - want to thank cartesi for sponsoring
217:41 - this video and this series they're an
217:43 - awesome company that have been helping
217:45 - me come up with all of the content for
217:47 - this series and they're actually working
217:48 - on a bunch of layer 2 blockchain
217:50 - Solutions right now and trying to make
217:53 - the blockchain more accessible and
217:55 - scalable for developers so definitely
217:57 - check them out from the link in the
217:58 - description they have a ton of detailed
218:00 - articles on a lot of the stuff I'm going
218:02 - to go over in this video and I do just
218:04 - want to quickly mention here in the
218:05 - intro that this is going to be very high
218:07 - level I'm not going to get into a ton of
218:09 - technical explanations about these
218:11 - different solutions I just want to give
218:13 - you an introduction to them and then
218:14 - encourage you to research and learn more
218:16 - anyways let's start talking about the
218:18 - difference between layer 1 and layer 2
218:20 - Solutions so in blockchain world and in
218:23 - this video you're going to see the terms
218:25 - layer 1 and layer 2 a lot now layer 1 is
218:28 - referring to the blockchain network
218:30 - itself so the actual ethereum main
218:32 - Network and layer 2 is referring to
218:34 - stuff built on top of that Network so
218:37 - when we talk about increasing the
218:38 - scalability of ethereum when we're
218:40 - referring to layer 1 we're talking about
218:42 - actually modifying the underlying
218:44 - blockchain technology so changing the
218:46 - architecture increasing the block size
218:48 - decreasing the block size whatever the
218:50 - solution is going to be it's going to be
218:51 - right on ethereum and that's something
218:53 - that we can't really directly modify
218:55 - ourself the people that are working on
218:57 - ethereum would have to actually change
218:58 - then we have layer two layer 2 is
219:01 - referring to Solutions we build on top
219:03 - of the blockchain so we're not touching
219:05 - layer one we're not modifying the
219:07 - ethereum network we're doing stuff on
219:09 - top of this to increase the scalability
219:11 - so of course I'll get into those
219:13 - different solutions but again on layer 2
219:15 - we're relying on layer 1 to give us the
219:18 - security and aspects of the blockchain
219:20 - but we're not actually going to be
219:21 - modifying that underlying technology and
219:23 - that underlying architecture hopefully
219:26 - that is clear now what I want to do is
219:28 - talk to you about something known as the
219:29 - scalability trilemma which has to do
219:31 - with the different aspects of a
219:33 - blockchain that we want to have and that
219:35 - we need to consider when we're picking
219:36 - different blockchain solutions so the
219:38 - scale ability trilemma is essentially a
219:41 - triangle I'll put a photo up on the
219:42 - screen where each Vertex or point is one
219:45 - of the properties or aspects of a
219:47 - blockchain that we'd like to have so
219:49 - here we have security decentralization
219:51 - and scalability now broadly speaking
219:54 - what this says is that whenever we
219:55 - Implement a solution we end up lacking
219:58 - in one of the areas of this triangle so
220:00 - one of these points for example if we
220:02 - Implement a solution that has great
220:04 - security and great decentralization
220:05 - typically we're going to have a worse
220:08 - scalability where if we Implement
220:09 - something with great scalability and
220:11 - great security we may have worse
220:13 - decentralization now this is not always
220:15 - the case there is some solutions that
220:17 - are great in all three of these areas
220:19 - but this is something that we want to
220:20 - think about when we're actually talking
220:22 - about different blockchain solutions so
220:24 - does this increase decentralization does
220:27 - it decrease decentralization what are
220:29 - the pros and the cons and the trade-offs
220:31 - as it relates to the scalability
220:32 - trilemma now before we go any further I
220:35 - do really want to Define scalability as
220:37 - well as security and decentralized just
220:39 - to make sure we know those terms so when
220:41 - we're talking about scalability the
220:43 - common thing to refer to as it relates
220:45 - to blockchains is transactions per
220:47 - second or transaction throughput now
220:49 - that is one of the areas of scalability
220:51 - that we're concerned with we're also
220:53 - concerned with data scalability as well
220:55 - as computation scalability so when we're
220:57 - building smart contracts one of the big
220:59 - issues there was we don't want to store
221:00 - a ton of data and we can't do too many
221:03 - computations in the smart contract
221:05 - because of the cost on the ethereum
221:07 - network and the time it takes to
221:08 - actually process those so keep that in
221:10 - mind as we go through this video it's
221:12 - not just a number of transactions it's
221:14 - also computations and data on the
221:16 - blockchain now as we go to
221:18 - decentralization that's really referring
221:21 - to the centralization of power or in
221:23 - this case the lack of centralization of
221:25 - power so the example I always like to
221:27 - use is a bank a bank is an example of a
221:30 - central institution or organization they
221:32 - have you know a few Executives or a few
221:34 - board members that really control what
221:36 - the bank can do they have investors they
221:38 - have government interests whatever it's
221:39 - very very centralized the people that
221:41 - use a bank don't control what the bank
221:43 - is able to do and what control they have
221:45 - of your money it's the bank itself very
221:48 - Central that controls all of them so
221:50 - hopefully that makes a bit of sense now
221:51 - when we talk about blockchain we want
221:53 - everything to be decentralized so
221:55 - there's not one person one institution
221:57 - or maybe a few people or few
221:59 - institutions that have control over the
222:01 - network ideally we want millions of
222:03 - computers or thousands of computers
222:05 - around the world to be running and
222:06 - securing this network so we're less
222:08 - prone to hacks less prone to corruption
222:10 - and all those other things that can
222:12 - happen when you have Central Power and
222:14 - Central you know authority of something
222:16 - so hopefully that makes a little bit of
222:18 - sense then we're talking about security
222:20 - this is pretty straightforward but how
222:22 - secure is the network how easy is it to
222:24 - be hacked how uh sure can we be that
222:27 - this transaction is valid when it's
222:28 - posted on The blockchain Ledger all of
222:31 - those types of things relate to security
222:32 - alright so that is the scalability
222:34 - trilemma keep this in mind as we go
222:36 - through the rest of this video now I'm
222:38 - going to start talking to you about
222:39 - layer 1 Solutions now I'm not going to
222:41 - spend too much time here because we
222:43 - don't have much control over layer 1
222:45 - Solutions we can't really build a layer
222:47 - 1 solution because we don't have control
222:49 - of the ethereum network
222:50 - regardless though I will talk about why
222:52 - we would want a layer 1 solution so why
222:55 - would we actually want to improve
222:56 - ethereum well as I'm sure many of you
222:59 - are aware ethereum is relatively slow so
223:01 - when we're talking about scalability it
223:03 - only does about 15 transactions per
223:05 - second and in contrast to something like
223:08 - Visa that can do upwards of about 60 000
223:10 - that's really really slow and that makes
223:13 - it infeasible for a ton of different
223:14 - applications especially something like
223:17 - being the Global Currency right if we
223:19 - wanted everyone to be using ethereum for
223:21 - their day-to-day transactions well that
223:23 - would take a really long time because we
223:25 - would have to be waiting hours maybe
223:26 - even days for a transaction to go
223:28 - through because we can only do 15 per
223:30 - second now in terms of computations as
223:33 - well we've seen when we were working
223:35 - with smart contracts we're really
223:36 - Limited in what computations we can do
223:39 - we probably can't Implement any advanced
223:41 - data structures and algorithms we can't
223:43 - store too much information and we can't
223:45 - do too many iterations without it
223:47 - costing us a ton of money on the
223:49 - blockchain so that is kind of the reason
223:51 - we would want to improve ethereum
223:53 - because of those lack of scalability
223:55 - issues now ethereum is very
223:57 - decentralized and is very secure so
223:59 - we're not super concerned with those two
224:00 - aspects we just really want the
224:02 - scalability to increase without hurting
224:04 - the decentralization and hurting the
224:06 - security anyways let's talk about the
224:08 - layer 1 Solutions So currently ethereum
224:11 - is actually working on a layer 1
224:12 - solution which they're calling ethereum
224:14 - 2.0 this is going to be a complete
224:16 - change to the architecture and the
224:19 - algorithm used for ethereum so I'm sure
224:21 - many of you have heard of this before
224:23 - they've been working on it for a really
224:24 - long time and it should be out
224:25 - relatively soon but they're going to be
224:27 - changing from proof of work to proof of
224:29 - stick now I'm not going to discuss the
224:31 - differences here or get into kind of a
224:33 - debate about which is better but that is
224:35 - what they're doing they're changing the
224:36 - main algorithm for improve of work to
224:38 - proof of stake and ideally they're going
224:40 - to be bringing the transaction
224:41 - throughput from about 15 transactions
224:43 - per second to upwards of a hundred
224:45 - thousand transactions per second now I
224:48 - cannot confirm this these are just the
224:49 - rumors and what I've heard online line
224:51 - and seen when looking at the project
224:52 - anyways that is kind of what they're
224:54 - doing now in ethereum 2.0 they're doing
224:56 - a few other things one of the main
224:58 - things that they're adding is something
224:59 - called sharding so sharding is really
225:01 - this process of taking a large piece of
225:04 - data and splitting it horizontally into
225:06 - smaller pieces of data which can be
225:08 - handled by multiple computers at the
225:10 - exact same time so to put this simply
225:12 - imagine I have one piece of data and
225:15 - this piece of data can only be processed
225:16 - by one computer at a time what's going
225:18 - to be slower to process that data than
225:20 - if I split this data into say 64 chunks
225:23 - or 120 chunks or whatever the number of
225:25 - chunks is going to be and allow 120
225:27 - computers 2 000 computers whatever the
225:30 - number is to process these smaller
225:32 - pieces of data at the exact same time so
225:34 - that's exactly what ethereum is aiming
225:36 - to do take the large piece of data split
225:38 - it into multiple smaller pieces of data
225:40 - and then allow for parallel processing
225:42 - and to drastically increase the number
225:44 - of transactions per second in fact this
225:46 - is a similar thing that many large
225:48 - companies do in many large databases do
225:50 - to increase the efficiency or increase
225:53 - the scalability of their systems so this
225:55 - is not just something that's done in
225:56 - blockchain this is done generally in
225:59 - computer science and I would encourage
226:00 - you to read more about it and look it up
226:02 - if you're interested in exactly how
226:03 - sharding works so with that said that's
226:05 - going to wrap up our layer 1 Solutions
226:07 - now I'm going to talk about the layer 2
226:09 - Solutions so as reminder layer 2
226:12 - Solutions are simply Solutions built on
226:14 - top of ethereum so they rely on the
226:16 - ethereum network and they do not modify
226:18 - it and they aim to increase the
226:20 - scalability while again still keeping
226:22 - the decentralization and security aspect
226:24 - so that said let's talk about some
226:26 - different layer 2 Solutions now the
226:28 - solutions that we have are things like
226:30 - State channels side chains and then
226:33 - Roll-Ups now I'm actually going to start
226:35 - with side chains so I probably should
226:36 - list it in the other order what a side
226:39 - chain is is essentially another
226:40 - blockchain Network that has a different
226:43 - architecture than the ethereum network
226:45 - and makes it better for scalability so
226:48 - what a side chain actually does is it
226:49 - links to the ethereum area main Network
226:51 - it makes it very easy to transfer assets
226:54 - between the two different chains now
226:56 - typically side chains are going to be
226:57 - much smaller they're going to have less
226:59 - validators they may have smaller block
227:01 - sizes and this does actually decrease
227:03 - the security and the decentralization of
227:06 - the side chain but it drastically
227:08 - increases the scalability because now
227:10 - rather than me sending a transaction to
227:12 - ethereum I'm going to send it to a side
227:14 - chain and then the side chain can kind
227:16 - of link up with the ethereum main
227:17 - Network and allow me to transfer the
227:19 - assets between the two networks very
227:21 - very quickly or very easily at minimum
227:24 - so an example of a side chain would be
227:26 - something like polygon I'll put up an
227:28 - image on the screen these are
227:30 - controversial and there's a lot of
227:31 - reasons why you may not want to use a
227:33 - sidechain but again the basic reasoning
227:35 - here is rather than using the ethereum
227:36 - network we're going to use it completely
227:38 - entirely different blockchain network
227:40 - that's going to be somewhat linked to
227:42 - the ethereum main Network which allows
227:44 - us to take the smart contracts running
227:46 - on the side chain and very easily Port
227:47 - them over to the ethereum main Network
227:49 - while still Main containing all of the
227:51 - data all of the assets and all of the
227:53 - information essentially that was posted
227:55 - to the sign chain Network hopefully that
227:57 - makes a bit of sense but those are side
227:59 - chains so the next solution that I'm
228:01 - going to introduce to you is something
228:03 - known as state channels now I just want
228:05 - to emphasize before doing that again I'm
228:07 - bringing this to you at a very very high
228:09 - level there's a lot of details and
228:11 - Nuance with all of these Solutions and
228:13 - you really should do some research and
228:15 - look at these more before actually
228:16 - trying to implement them or use them for
228:19 - your decentralized applications so
228:20 - please keep that in mind this is a very
228:22 - very general introduction anyways state
228:25 - champs to explain the usefulness of
228:27 - State channels I want to introduce to
228:28 - you a problem of making a decentralized
228:31 - application so if we wanted to make a
228:33 - decentralized app we want this to be
228:35 - some type of game maybe a game like
228:37 - chess right well this game requires many
228:40 - state changes now we know when we make a
228:42 - decentralized application we're going to
228:44 - have a smart contract the smart contract
228:46 - handles the state of our application if
228:48 - we're talking about Chess and we need to
228:50 - store the state of the board so if we
228:52 - want to play a game of chess on the
228:54 - ethereum network what we would have to
228:56 - do is send transactions to the smart
228:58 - contract to update the state after every
229:01 - single move was played now at least in
229:03 - the chess games that I play they're like
229:04 - five minutes long we're three minutes
229:06 - long and we make moves every few seconds
229:08 - right so I make a move my opponent makes
229:10 - a move and every time that would happen
229:12 - if we're running this on ethereum we
229:14 - would need to submit a transaction to
229:16 - the network however the next player
229:18 - can't make a move until that transaction
229:20 - is verified and the state has been
229:22 - updated in the smart contract and we
229:24 - know that that can take a really long
229:25 - time to happen so that makes it
229:27 - infeasible for us to play a game that
229:29 - has very rapid State changes hopefully
229:31 - that makes sense but you would be
229:33 - sitting there waiting 30 minutes an hour
229:34 - for the transaction to be finalized
229:36 - before the next player would be able to
229:38 - move and while that completely defeats
229:40 - the purpose of like a quick game of
229:41 - chest or something along those lines so
229:43 - this is where we introduce State
229:45 - channels so the idea here between State
229:47 - channels is that if we have a ton of
229:48 - micro transactions or many any
229:50 - transactions that are going to be
229:52 - occurring in a short period of time
229:53 - rather than doing them on the blockchain
229:55 - we're going to take them off the
229:57 - blockchain and do them in a secure way
229:59 - that can later be verified by the
230:01 - blockchain so a state channel is
230:03 - essentially a communication Channel a
230:05 - peer-to-peer messaging Channel where me
230:07 - and someone else who are participating
230:08 - in for example some type of game are
230:10 - going to be sending signed messages to
230:13 - and from each other with the state of
230:15 - the game so if we're playing a game of
230:17 - chess I'm going to be sending a message
230:18 - that's signed by me to my opponent
230:21 - saying I made this move and then they're
230:23 - going to send me a message that science
230:24 - said I made this move and we're both
230:26 - going to be verifying that the state is
230:28 - correct at each point in time by signing
230:31 - these messages hopefully that makes a
230:32 - bit of sense now the way that this works
230:34 - is we're first going to send a
230:36 - transaction to a Smart contract sitting
230:38 - on layer 1 to open up the state Channel
230:41 - Once the state channel has been opened
230:43 - we're going to do all of our
230:44 - transactions the micro quick ones off
230:46 - the blockchain they will happen almost
230:47 - instantly then at the end of the game
230:50 - we're going to send one transaction to
230:52 - the smart contract with the final State
230:54 - and we're going to say hey we finished
230:56 - the game and then the smart contract is
230:59 - essentially going to verify that the
231:00 - state is correct and there's a lot of
231:02 - stuff that goes on to do that I won't
231:03 - really talk about how that works and if
231:05 - we're playing for say one ethereum so
231:07 - whoever wins the chess game gets one
231:08 - ethereum then that ethereum would be
231:10 - transferred and we would have had to
231:11 - kind of stake that at the beginning of
231:13 - the game so hopefully that makes a bit
231:15 - of sense but typically State channels
231:17 - allow for us to have very fast
231:18 - transactions they make it very cheap
231:20 - because we don't have to pay gas fees
231:22 - when we're doing this off the blockchain
231:23 - we just have that first and last
231:25 - transaction that require the gas fee to
231:27 - open the state Channel and to close the
231:29 - state Channel and typically they do
231:31 - allow for the same security and
231:32 - decentralization however you may have
231:35 - the security be slightly decreased
231:37 - depending on the way that you're
231:38 - verifying the states and what you're
231:40 - doing between the blockchain and the off
231:43 - chain or between layer 1 and layer 2.
231:45 - again I don't want to get into this too
231:47 - much those are stage channels very
231:49 - useful when you have a ton of micro
231:50 - transactions that need to be performed
231:52 - very very quickly so now we are moving
231:54 - on to the final solution I have in this
231:56 - video which is Roll-Ups now before I get
231:59 - into those I do want to mention that
232:00 - cartesi actually implements a ton of
232:03 - layer 2 Solutions and makes it really
232:05 - easy for developers like yourself to use
232:07 - these Solutions without having a full
232:09 - understanding of how they work and
232:11 - what's going on behind the scenes
232:12 - cartesia is working on operating systems
232:15 - libraries modules packages Frameworks
232:18 - all of the stuff you could imagine is
232:20 - going to make it easier for you as a
232:21 - developer to use these types of
232:23 - solutions that are really complicated on
232:25 - a lower level so make sure you check
232:27 - them out from the link in the
232:28 - description anyways let me talk about
232:30 - roll ups here and I will also mention
232:32 - that cartesi has a ton of articles that
232:34 - explain this stuff more in depth if
232:36 - you're interested again reference them
232:37 - from the link in the description so a
232:39 - roll up is essentially an idea that
232:41 - we're going to take all of the
232:43 - transaction execution so the
232:45 - computations associated with the
232:47 - transaction and perform those off the
232:49 - blockchain will posting transaction data
232:52 - to the blockchain on layer 1. so the
232:54 - basic concept behind rollups is that
232:56 - it's very expensive to perform
232:57 - computations on the blockchain it can
233:00 - also be very time consuming so rather
233:02 - than do them on the blockchain let's
233:04 - perform our transaction execution off of
233:07 - the blockchain and then post the
233:08 - transaction data to layer 1 and have a
233:11 - smart contract on layer one so on the
233:13 - blockchain they can validate that the
233:15 - execution that we did off the blockchain
233:17 - was indeed correct now I know that's
233:20 - confusing but essentially we're taking
233:21 - the time consuming operations and
233:23 - computations Performing them off the
233:25 - blockchain and then posting all of the
233:27 - data to the blockchain where we can then
233:29 - validate that it is correct and we can
233:31 - use the properties of the blockchain to
233:33 - store the data now another advantage of
233:35 - the rollups is that what they can do is
233:37 - they can bundle multiple transactions
233:39 - maybe hundreds or thousands of
233:41 - transactions into one smaller
233:43 - transaction and then post that to layer
233:46 - one so rather than having the user have
233:48 - to send a thousand transactions directly
233:51 - to a Smart contract which costs a lot
233:53 - takes a lot of time we're going to send
233:55 - it to whatever's rolling up these
233:56 - transactions it's going to kind of
233:58 - bundle them all together and then send
234:00 - one transaction to the blockchain that
234:03 - contains all of the data that it needs
234:04 - of the state change that's going to be
234:06 - made so before I can go any further
234:08 - because I do want to give you some more
234:09 - detail here I will mention that there's
234:11 - some different types of Roll-Ups so we
234:13 - have optimistic robes and pessimistic
234:15 - ropes now I'm going to start with
234:16 - optimistic Roll-Ups now I do want to add
234:18 - here that the blockchain community
234:20 - currently considers roll ups to be one
234:22 - of the most promising solutions for
234:24 - scaling ethereum and the reason for that
234:26 - is that they allow you to scale the
234:27 - computations and throughput of the
234:30 - network without compromising on security
234:32 - and decentralization so using that in
234:35 - combination with sharding which allows
234:36 - you to scale the data on the network
234:38 - really gives you the best of both worlds
234:40 - and allows you to scale ethereum in all
234:42 - three of the areas that we talked about
234:44 - so sharding scales the data and the
234:46 - Roll-Ups allow us to scale the
234:48 - computations as well as the throughput
234:49 - so the transactions per second so you're
234:52 - likely going to be hearing a lot more
234:53 - about Roll-Ups in the future and maybe
234:55 - even using them yourself and if you were
234:57 - to pay attention to any of the solutions
234:58 - in this video this would be the one that
235:00 - I recommend so when we talk about
235:02 - optimistic rollups what we're really
235:03 - referring to is that the smart contract
235:05 - that's sitting on layer 1 is assuming
235:08 - that any of the transactions sent to it
235:10 - are valid so any of the state changes
235:12 - that are made any of the transaction
235:13 - data we'd assume that's valid and that
235:16 - it's not malicious now this allows for
235:18 - us to have very quick transactions and
235:20 - to perform faster computations off the
235:22 - blockchain because we don't have to
235:23 - prove that everything is correct however
235:26 - this does mean that someone could submit
235:28 - a malicious transaction now there is
235:30 - incentives put in place to make sure
235:32 - that people do not submit malicious
235:33 - transactions for example there may be
235:36 - something like staking ethereum so
235:38 - whenever people are dealing with rollups
235:39 - you may have to stake some ethereum that
235:41 - says hey I'm going to be a good actor
235:43 - I'm not going to submit any malicious uh
235:45 - transactions or state data and if you do
235:47 - that so if you are malicious your stake
235:49 - could get slashed that could be the
235:51 - incentive or the incentive from
235:53 - performing poorly or having bad behavior
235:56 - on the network hopefully that makes a
235:57 - bit of sense but the idea here is that
235:59 - we're assuming everything is correct now
236:02 - if someone does do something that is not
236:04 - correct or is invalid or malicious or
236:06 - whatever anyone can submit something
236:08 - known as a fraud proof now this fraud
236:10 - proof essentially says I believe that
236:12 - this state is incorrect I believe that
236:15 - someone did something malicious go and
236:17 - verify that it's not or go and verify
236:19 - that they did indeed do something
236:20 - malicious so that's what's called it's a
236:22 - fraud proof this puts the smart contract
236:24 - into a specific mode where it's going to
236:27 - go and validate that all of the
236:28 - transactions and data that are sent is
236:30 - actually correct and if they are not
236:32 - correct it's going to punish whoever
236:33 - submitted the incorrect transaction
236:35 - hopefully that makes a bit of sense but
236:37 - that is optimistic ropes again just
236:39 - really think about the fact that an
236:41 - optimistic roll-up is assuming
236:42 - everything is correct and it's only
236:44 - doing a validation if someone submits a
236:46 - fraud proof all right moving on now to
236:49 - pessimistic roll-ups now pessimistic
236:51 - ropes are kind of the opposite of
236:53 - optimistic ropes in a pessimistic
236:55 - roll-up you cannot submit or update the
236:57 - state of a smart contract unless you
236:59 - submit something known as a validity
237:01 - proof now this proof is a specific
237:03 - cryptographic proof I'm not going to
237:06 - really talk about exactly how it works
237:07 - but essentially off the blockchain when
237:10 - you're performing all of your
237:10 - computations you also need to compute
237:12 - this proof and then this proof is sent
237:14 - to the smart contract and you can only
237:17 - submit or update the state story of the
237:19 - smart contract if you have this proof
237:21 - alongside it now the only real issue
237:23 - with these type of proofs though is that
237:25 - they can be inviable to compute for a
237:27 - really complex transactions so these are
237:29 - time consuming and difficult for a
237:31 - computer to come up with these
237:32 - cryptographic proofs and so if you're
237:34 - doing anything that's too complex it can
237:36 - be inviable to come up with one of these
237:38 - proofs and in that situation you need to
237:40 - use an optimistic roll-up now the reason
237:42 - you would use one of these proofs though
237:44 - is because this limits the amount of
237:45 - data that the smart contract needs to
237:47 - hold because all it needs to do is hold
237:49 - a state because it can only update the
237:52 - state if it has a valid proof I
237:54 - understand it's a little bit confusing
237:55 - but in the optimistic roll-up scenario
237:57 - it's holding all of the transaction data
238:00 - and it's only doing a verification when
238:02 - a fraud proof is sent so it is time
238:04 - consuming when you send the fraud proof
238:06 - but ideally you're not having that
238:07 - happen very oft whereas in a pessimistic
238:11 - scenario here the smart contract is
238:13 - holding much less data it's just storing
238:15 - the state and it's only updating that
238:16 - state when you submit the proof this
238:19 - means it's really easy for the smart
238:20 - contract to validate that everything is
238:22 - correct however it takes more time off
238:25 - the blockchain to be able to submit
238:27 - these State changes because you need to
238:29 - perform this validity proof and
238:31 - sometimes this validity proof can be
238:33 - inviable to compute alright so that's
238:35 - pretty much all I can share with you
238:36 - related to roll up so getting into too
238:38 - much detail again I want to emphasize
238:40 - this at a very high level there's a ton
238:42 - of stuff that I skipped over and omitted
238:44 - in this video with that said I'm going
238:46 - to start wrapping it up here another
238:48 - massive thank you to cartesi for
238:50 - sponsoring this video and this series
238:52 - make sure you check them out from the
238:53 - link in the description they have all
238:55 - kinds of Articles very smart people
238:57 - there that are implementing these types
238:58 - of layer 2 Solutions and are trying to
239:00 - make it much easier for you and me to
239:03 - develop decentralized applications
239:04 - without the huge issues or limitations
239:07 - of ethereum that we looked at in some
239:09 - previous videos hope you guys enjoyed
239:11 - this series if you did make sure you
239:13 - leave a like subscribe to the Channel
239:15 - please leave a comment down below and
239:16 - let me know if you want to see more
239:18 - blockchain on this channel because I'm
239:20 - hoping do some more series in the future
239:22 - and with that said I will see you in
239:23 - another YouTube video
239:25 - [Music]
239:28 - foreign
239:29 - [Music]

Cleaned transcript:

foreign hello everybody and welcome to this introductory course on blockchain development and solidity throughout this course not only will you learn about theoretical concepts related to blockchain networks like ethereum but you will understand how to write smart contracts in solidity how to deploy those onto the ethereum network and how to do things like create erc20 and ERC 721 tokens which are nfts this course is designed for complete beginners whether you have experience with blockchain or programming or not you will be able to follow along with this content now this content is meant to just be a good introduction to this topic and to this space this is not going to teach you everything you need to know to become a web 3 developer but it's going to be a really good starting place and kind of show you if you're interested in this or not so after going through this course if you are interested in web3 technology you really want to get to the next level you want to potentially land a job I have an entire higher premium course it's called blockchain expert I'll leave a link to it in the description this covers some of the same content as this introductory course but obviously it goes much more in depth we have over 20 hours of video content we have full projects using things like oracles we show you how to actually write frontend code that can interact with your smart contracts we teach you Advanced solidity features there's hundreds of practice questions assessment questions projects so much more it's a great value you guys can check that out from the link in the description now this course is an aggregation of a bunch of videos I made about a year ago I know many of you don't actually know that I have these videos so every once in a while I like to combine them all together so you're going to see that after this intro there's kind of another intro and then it goes through all of the videos that I posted on the channel a really long time ago so just keep that in mind this is kind of an aggregation and I wanted to give you this introduction just so you understand the purpose of this course and I also wanted to mention that it's possible that when you try to use what's known as the gorelli test Network this is a network we used in this course about a year ago it will fail now if that fails I've left a link in the description to another test Network that you can use it's called Avalanche so use that test network instead the setup steps are essentially the same except instead of connecting to go rally you connect to Avalanche so you may have to do a quick Google search how to connect the Avalanche test Network it's fine I've left the link to the faucet a faucet is a place where you can get kind of free ethereum so you can actually test out your Smart contracts so hopefully you guys can keep that in mind I apologize if the network doesn't work I don't have any control over that but I've left an alternative so hopefully you can kind of continue in this course without any issues with that said I hope you guys are looking forward to this all of the resources for all of the videos will be linked in the description as well as the link to blockchain expert let's get into the first video and dive into blockchain development hello everybody and welcome to a brand new and very exciting series on this channel on an introduction to blockchain development so in this series I'm going to be showing you how to write smart contracts and deploy them on the ethereum network and I just want to State before I go any further this is designed for complete beginners so if you have never written code before if you don't know anything about blockchain do not worry this is the place for you I'm going to be explaining absolutely everything and in this series we're not going to write any massively complicated smart contracts this is really meant to give you kind of a high speed introduction and just get your hands dirty and actually deploying and writing contracts anyways with that said in this first video here what I'm going to be doing is showing you how to set up ethereum so how to set up a wallet how to get some different accounts and then how you can get free ethereum from an ethereum test Network this is important because when we're kind of practicing we don't want to be spending real money and you do need to actually spend ethereum to put your smart contracts on on the ethereum network so I'll show you how we can do that for free in this video so I'm super excited for this series I hope you guys are as well and there will likely be more on blockchain related topics on this channel coming in the future so look forward to that now I do need to mention and I apologize for the long intro here that the reason why I'm able to actually create this series is because of a company known as cartesi now cartesi is the sponsor of this video and this series and they've actually been working with me behind the scenes to come up with the curriculum here and make sure that I'm getting everything correct as I'm relaying this information to you I am not a blockchain expert I am kind of a beginner just like you guys but I am good at making YouTube videos and tutorials and so they've been kind of helping me come up with the content in the structure and then reviewing all of the work just to make sure everything is a hundred percent accurate now cartesi is an amazing company they are dedicated to making the blockchain more accessible for everyone and they have a ton of Technology Solutions that allow you to develop on the blockchain for much cheaper now we will hear more about them throughout the rest of this series but for now I just wanted to give them a general introduction and a massive thank you for working with me and well with you guys I guess to make this accessible to everyone and allow people to get into this world of blockchain development with that said let's get into this first video all right so let's go ahead and get started in this first video I'm going to show you how to set up a metamask wallet this is actually an extension for Chrome although it's available for IOS and Android as well and please even if you have an existing ethereum wallet because this will be storing ethereum follow along with these steps because you want a metamask wallet so you can get access to free ethereum and use it with the different applications we're going to be using later in this series so go to this website click on download I'll leave a link to it in the description and click on Chrome and then install metamask for Chrome now when you do this it will install a Chrome extension it should pin this for you but if for some reason you don't see this in the top right hand corner so a little fox icon that's the metamask icon then click on this puzzle icon for extensions and just pin this it's just going to be helpful so click on the little pin and then it will make it so it's persistently up and I guess your I don't know you want to call this a taskbar bookmark bar whatever uh otherwise if you don't want to pin this you can just click directly on metamask and it will open up this page now for you I'm sure this is going to look a little bit different because you have not yet set up an account with metamask so I'm not going to walk through those steps because they're pretty intuitive but just walk through the basic setup steps on metamask you need a password make sure that's secure you're also going to need some secret words you want to make sure you save those somewhere you want to have access to them and then once you've done that it should prompt you to create an account so if you don't get prompted to create an account for some reason just click on this circular icon in the top right hand corner and click create account now you can have as many accounts as you would like within metamask you can see here I have two I have account one and I have tutorial and this will be very useful for us later on if we want to actually try testing out sending ethereum between different accounts great so that's kind of the basic setup so I have account one notice I have six ethereum this is actually fake ethereum I'm going to show you how to get that in a second and then the tutorial account where I have zero right there all right so at this point in time I'm going to imagine that you've gone through those setup steps you've figured out how to get to a page that looks similar to this and now I can show you how to get some free ethereum so the first thing I want to mention is that ethereum has a few different networks so if you click up here where it says for you it'll say ethereum mainnet but for me it says this gorelli test Network what you're going to do is select one of the test networks that you want to try out your application on now these test networks are kind of a mirror or a clone of the ethereum mainnet the mainnet is the main ethereum Network this is where real ethereum exists real smart contracts exist and anything on here is real money so you'll see this is 0.00 USD whereas if I switch to a test Network there's no price because this is all fake ethereum it's not worth any money it's just for testing for development so you can use any test Network that you would like and you can kind of mess around with different ones if you want but the one that's been working really well for me recently is this go rally one now I'm probably uh mispronouncing this but this is the test that we're going to be using for right now and I just want to note that the public address of this wallet if that means anything to you is available right here so if you go copy a clipboard let's take this and paste this you'll see that we have this address this is the address for my ethereum well okay let me go back to metamask here and now we are back on the go rally test Network in my tutorial account great now that we've done this I'm going to show you how we can use a faucet to access free ethereum and have it sent to this wallet so what we can do is click on buy when we do this we have directly deposit ether or test faucet get ether from a faucet for the go rally now this is the one that we want so we're going to click on get ether you can do this on any of the test networks and it will bring you to a different website now this is bringing us to some faucet I actually haven't used this faucet I'm going to show you how we do a different one or use a different one but what you can do is just stick in your address right here and then request The Ether I would need to do the I'm not a robot thing and notice it's giving me an internal server error because sometimes these things just don't work they are test networks okay so they're going to be down sometimes there's going to be some maintenance they're not 100 reliable but that's fine because we're just using them to test so you kind of just have to experiment and mess around with them and find one that's worth working on a specific day kind of annoying but considering we get free ethereum and we can test it out without without having to pay I am not complaining okay so what I'm going to do is go back to metamask here and actually uh let's just copy this public address although I already have that copied and now we're going to go to this website right here I'll leave a link to this in the description now this website is what's known as a social faucet now a social faucet means that you need to post something on social media that contains your wallet address and then put the link to that post and it will then send you a theory now you don't need to post on some large account or something you can just make a brand new account on Twitter or Facebook I think those are the two available ones right here and in fact that's exactly what I did so what I did is I went to Twitter I have this actually really old Twitter account from when I was like 12 or something oh yeah July uh 2013. anyways I don't use this account so I just signed in and then I posted this tweet requesting faucet funds into and then this address now you actually don't need to write anything other than the address of your wallet so what you'll do is go tweet or if you're on Facebook you would post something and then I'm just going to make a tweet that contains my wallet address I'm going to click tweet then I'm going to go here and I'm going to go share so I'm going to copy the link to the tweet I'm going to go here paste that link in and then click give me ether now we have a few options select whatever one you want I'm just going to go with six ethers every day I gotta select the chimney so let's see if I can pass this okay that looks good and it said oh I have a certain amount of time left until my next allowance uh okay looks like it's because I got ether recently from the same account and so that means that I have to wait but for you guys this should work you shouldn't have a timeout problem uh I already have six ethereum so I'll deal with using that as I need to as we go through the tutorial regardless this should work it should just give you ethereum and then if you go to metamask you should see in your account so let me swap my account here to account one that you have some amount of ethereum all right so at this point in time I'm going to assume you've successfully got some ethereum if the test Network I use didn't work just try another one go through all of them eventually one should probably work for you now it doesn't really matter which test Network you used but just keep track of which one it was because you will need to change some very minor steps as we go through the rest of the tutorial if you did use a different test network but everything will still work the general concepts are the same you just need to alter like one or two things very very small anyways what I want to do now is show you how to send ethereum which is really easy to do with metamask and how you can explore the blockchain and look at the addresses of wallets look at different transactions that have occurred and just show you this website here known as etherscan now etherscan is what I like to call a blockchain Explorer you'll notice here I'm on gorelli.etherscan.io so this is specific to the test Network that I'm using if you did use a different test snap work then you're going to want to search up etherscan plus the name of that test Network and just go to that etherskin obviously this one is for the test Network that I used so what I want to do is show you that we can actually view everything on the blockchain completely transparently it's one of the great things about the blockchain you can just go and look at any wall address you don't necessarily know who owns that walled address but you can see every single transaction that's occurred you can see who sent the money how much money is in every single account that's one of the great features of the blockchain everything is completely transparent so I want to show you how we look up our own account on etherskin so I'm going to go here to metamask and I'm just going to click on my account address right here and copy it to the clipboard now that I have that I'm just going to paste it in this search bar right here and just click search okay so here we go we can now see my wall address showing up on etherscan now if you guys go and paste this address in I don't assume you're going to type all of it out but let's say you did that into etherscan you would see the exact same page that I'm seeing and you could view all the transactions in my wallet so anyways here we are this is my wallet you can see I have six ethereum inside of here and I had one transaction that occurred eight days and three hours ago this is correct that's actually when I had the ethereum sent in when I was kind of preparing for this video and you can see it was on this block I had this transaction hash and then I have the from address and the to address so the two address is my wallet address right here but if I want to see where this ethereum came from which was the faucet I can click on this so when I click here notice this has an absurd amount of ethereum 515 000 ethereum right that's quite a bit and you can go and look at all of the different transactions that it sent and how frequently it's sending them so you can see how many people are requesting ethereum from this faucet anyways let's go back and let's actually click on this transaction hash that's what txn hash is so let's do that and let's just look at some details that we have here now notice it's telling us this is only from this test Network okay it gives us the hash of the transaction which we'll discuss later on we have the status this was successful you could have a status of pending meaning it's not yet been sent through then we have the block that this was attached to we can actually click directly into the block and view everything that was associated with this block as well we can see the miner that mined it too which is interesting then we can go and look at the from address the to address the value of the ethereum the transaction fee the gas price and a bunch of other stuff now this is really not going to mean anything to you right now but I just wanted to show you that you can do this you can look at all of the details of the blockchain completely for free transparently and anyone can do this there's not one person who has access You Can't Hide Your transactions from one person everything is completely publicly available all right so now that we've looked at that I'm just going to quickly show you how you could send ethereum now you only can send ethereum between the same test networks so I can't send this ethereum to a different test Network or to the main ethereum Network obviously that's not going to work but what I'm going to do here is just look at my other account so you'll notice that if I go here I have my tutorial account and then I have my account one so let's say I want to send I don't know one ethereum to this tutorial account well I'm just going to copy the address here notice I'm on this test Network going to go back to account one I'm just going to click on send in metamask I'm going to paste in this public address I'll go with one ethereum I will click next and I can confirm this it's going to tell me how much this will cost I have to pay a very small gas fee I will click confirm and now it is sending the transaction you can see it says pending if I click on it here it gives me the details and this is very similar to what I had on etherscan now let's see if we can find the hash of this transaction uh copy address copy address no let's go copy transaction ID okay so I'm going to copy that let's go to etherscan here and paste this in and let's see if we can view the transaction and there we go we can view it and notice if we go to the from address this is my address that now has less ethereum in it than it did before because I am attempting to send money now it is not showing me the pending transaction because the transaction is currently pending it is not finished but you get the point this is all working and well we can view all of the transaction details all right so I just took a quick cut and you can see that the transaction has now actually gone through so I have a status success the page actually updated live when I was on it so that's how I knew this and if I go back to the from address you can see this transaction is now here uh and sorry it's right here actually because it's more recent and it's saying we sent one ethereum out from this address to the other dress and if we go here we can see we have one ether and then of course if we go back to metamask and let's go to this other account so let's go to account number one or tutorial we have one ethereum so anyways with this transaction now being completed I'm actually going to end the video here I just wanted to give you a brief introduction to how we actually set up ethereum accounts how we can send money between different accounts the test networks and the faucets and then of course ether scan so how you can actually view different transactions view wallets and see what's going on on the blockchain a lot of this will start to make more sense in the next video where I actually go through a deep explanation of how blockchain technology Works how the network is secure how transactions are sent etc etc anyways I am going to wrap up the video here I hope you guys enjoyed one last massive thank you to cartesi for sponsoring this video and helping with the content we'll hear more from them in future videos I hope you guys are sticking around make sure you subscribe to the channel and I will see you in the next one hello everybody and welcome to part two of this video series in this part I'm going to be explaining to you the theory behind blockchain technology so specifically going through some key terms like private Keys public Keys cryptographic hash functions what those are how those work I will talk about transactions how a transaction is created and signed and secured I will talk to you about blocks how blocks are connected together I will then start talking about proof of work which involves minors and securing the blockchain and while all of this is very very interesting and I try my best to break it down as simply as possible for you in this video so in a second we're going to hop over to the drawing tablet I'm just going to start doing some diagramming and explaining and I encourage you to sit back relax and enjoy the explanation however before we do that I quickly need to thank the sponsor of this video and this series which is cartesi now cartesi is a company that is dedicated to making the blockchain more accessible and affordable and when I say affordable the reason that's important is because as you're going to see as we go through the rest of these videos here deploying smart contracts is very very expensive now cartesia offers a bunch of solutions that can actually cut this cost by a factor of almost a hundred and really just make it much easier to work on the blockchain anyways we'll hear more from them later on and we'll actually start using some cartesi technology hopefully in a future series but regardless they are an awesome company they've been helping me come up with the content for this video and I'm just super grateful and happy to be working with them regardless let's dive into the video foreign ignore the black screen there will be some drawing in one second but for now I'm gonna start by explaining to you some key terminology related to cryptocurrency specifically private key public key and address so let's actually start by looking at what's knows a cryptographic hash function because it's very important to understand this concept so we have a function let's say f of x and this is equal to Y this means you take some input X you get some output y pretty standard now with most regular functions you can compute what's known as the inverse now the inverse of f is known as F inverse and then you would take Y and this will give you X so the idea here is that given some output and given the function that computed that output tell me what the input to that function would need to be to get that output so the inverse is like this you take the output you pass that to the inverse function and it gives you the input required to pass to the original function to get that output so let's just look at one concrete example let's say we have something like Y is equal to X Plus 2. well if 2 is my input then Y is 4. now compute the inverse of this function the inverse of this function you simply compute by isolating X so you just say y minus 2 is equal to X that's the inverse and so if I give you the value 4 You Can Tell Me 2 was used to compute that great so now that we understand what the inverse is the first property of a cryptographic hash function is that it has no inverse so we're going to call this now the hash function so let's do hash func this is going to be our input and this is going to be our hash otherwise known as a digest okay you don't really need to know that but hash is what I'm probably going to be referring to this as as we go through this video so the first factor or the first property of a cryptographic hash function is that it has no inverse now what that really means is that given y you cannot find X so if you're given the function and the output of the function there's no way to figure out what the input is that's very very important so to clarify here when I say we can't find the inverse of a cryptographic hash that's not necessarily true now it's important to note that here I'm not talking about the cryptographic hash function I'm talking about the actual hash itself that was the output of this function So currently there's no efficient way or formula that we know that we can use to take an individual hash and determine its inverse however it may be possible to invert a hash using a Brute Force approach where you would blindly guess and try several different values until you determine what the original input value was that generated this hash now this Brute Force approach would take billions of years to perform and that's why we say a cryptographic hash has no inverse because it would take an extremely long and unfeasible amount of time to compute it so yes theoretically it may be possible to compute the inverse of an individual hash but it would take such a long time that we just simplify things by saying it has no inverse so moving on the next property of a cryptographic hash function is that it is deterministic that means that any input X1 always leads to one output y1 so second property deterministic again meaning that one input always points to the exact same output next property is that every output is unique so if I pass X1 I get y1 nothing else points to y1 so if I have X2 it's not possible for me to get the same y1 as soon as I have something like X2 and they both point to the same output this is no longer a cryptographic hash function so again I need to add a small clarification here theoretically it is possible to have two inputs mapped to the same output using a hash function now when that happens this is known as a collision now the thing with cryptographic hash functions is that for that to happen for you to find a collision just like finding the inverse that would take you say billions of years a very very long time to do so we can kind of operate on the assumption that there will be no collisions but theoretically if we're talking about the exact definition there could be so I'm going to kind of be speaking in this video in definitives just understand there is some Nuance behind those but it's just much easier to operate under these assumptions and well hopefully that makes sense okay so those are the first three properties of this function the next is that the hash that you get is uncorrelated to the input so what this means is that if I have something like f of 1 1 maybe this gives me a hash of a b c 2 3. now you might be trying to guess here that if I had a hash of 1 2 that it would give me something similar to this maybe you would think we get a b c 2 4 or something along those lines because you would imagine that the output here is correlated to the input but with a cryptographic hash function this is not the case if I were to pass one two so just one number is different I get a completely different hash so I might get something like d f a two nine four or seven or whatever you know what I mean we just get a completely different hash there's no way to reasonably guess what the hash is going to be by looking at the input all right so that is great the very last property is that this is quick to compute so Computing the hash of some input is very very fast those are the five properties of a cryptographic hash function okay so moving forward we're now going to talk about private Keys public keys and addresses so let's start with our private key now the private key I like to think of as the master password for our ethereum account so the private key is actually what allows us to access our account and to send money so if you have access to a private key you have access to an ethereum account and while you can send money on that account that means you need to keep this private you do not want to share this with anyone and in fact we don't even look at what our private key is when we use metamask it's generated for us and stored in an encrypted fashion in kind of the back end of metamask so that no one can actually see it now when I say encrypted this is actually one of the reasons why we need to pass a password when we created our metamask account so what happens in metamask is it will generate a private key for us but it won't store it in plain text so if the private key was one two three it will never store one two three instead it will store what's known as an encryption or an encrypted version of this private key and it will encrypt it using our password so we have some special function that's going to you take in our private key and our password and then it will give us some output okay and then the only way to go from this output back to what this private key is is to know what the password is okay so we need to use the password every time we sign in so that we can decrypt our private key so that we can then use the private key to actually send transactions okay that is the private key and what the private key actually is is just a string of characters that's really all it is it's extremely long and again you usually are not going to be looking at this yourself it's going to be stored in some secure way so next from our private key we generate what's known as a public key now the public key is generated from the private key so you need the private key to get to the public key and we use a cryptographic hash function to generate this which means if you know the public key there is no way to go back to the private key you cannot do that because the way we generate it was using a cryptographic hash function that's very important because someone could theoretically figure out your public key if they do figure out what that is that doesn't matter there's no way for them to go to the private key hence why this is private and this is public the public one can be shared anywhere okay moving forward the next thing we have is our address now the address is generated from the public key so a private key in a public key actually make up an ethereum account and then the address is what you're going to actually send money to now what the address is is actually a few characters when I say a few it's something like 20 characters of the hash of this public key that's pretty much all I will say it's kind of just a simplified version of the public key and the way you get the address is you generate it from the public key so you go private key public Key address and from the public key again you cannot get back to the private key from the address you cannot get back to the private key and that's very important because as soon as you have the private key you have access to the ethereum account so you give the address to whoever you want to send money to you and that is how you will reference your account on the ethereum network by this address great so the whole point of the address as I was saying is it just a simplified version of the public key so it's a little bit easier to be using on the blockchain rather than writing the public key everywhere so now that we have understand private key public key and address we need to talk about transactions and then how the blockchain actually handles transactions so let's say we have the example where we have maybe a count one and a count two and account one wants to send some ethereum maybe 0.1 F to account two how do we do this well to do this we need a transaction now anyone can create transactions on the blockchain anyone can do it and what's involved in a transaction is an amount so it's going to be 0.1 F we're going to have a 2 wallet so what address we're going to so we're going to be going to account to and then from is going to be account one now the only problem right now with this transaction is that we kind of have to trust that who's making this transaction is the person who's sending the money right the from address but theoretically account 2 could make this transaction and say oh yeah account one is sending me all of its ethereum anyone could just make a transaction and you could add as many as you want and you could just throw them on the blockchain and well if there was no security then you would just have random people adding transactions all of the time that is why we have something known as a digital signature so a digital signature is a very special hash that involves the actual private key of the account trying to send the money so of the from account as well as all the information associated with the transaction now I won't talk too much about the signature because it's pretty mathematically complicated but to be able to actually create a transaction that is valid what you need is the private key of the account you're trying to send ethereum from so this signature here again as I was saying is going to require the private key as well as the transaction itself so the transaction I'm just going to represent by TX and then there's actually another part of this as well and anyways you hash all of this it gives you some you know random uh string of characters and this string of characters you can verify is a correct um signature for this transaction now the way that you actually verify the signature is simply by using the public key of the account that's sending this ethereum so if we see a transaction that's coming from account number one we don't need to know what count number one's private key to determine that the signature is about we can just use their public key and a special kind of mathematical computation to determine that this signature is valid and that it was actually signed by the account that's sending the ethereum because again you can only send this ethereum if you have access to the private key of the account that's supposed to be sending the ethereum so just know for now that you can verify a signature very easily without knowing the private key of the account you just use a certain aspect of the public key I'm not going to go into too much more detail but that is how you verify a signature so anyways that is how you actually secure a transaction you digitally sign it using your private key and a few other things we don't have to manually do that ourselves it's done by metamask when we actually send a transaction okay so let's remove all this and now let's see how we actually associate a transaction with a block and how we actually you know use the blockchain and put a transaction on the blockchain because right now we made this transaction that's fine but we need to send it on the blockchain we need to attach it to a block before it's actually going to go through before our money gets sent to the other person so let's look at what a blockchain is let's say we have one block like this another block like this and a third block like this now all of these blocks are connected together in a chain now they would be of equal size I've obviously drawn mine a little wonky here but all of these blocks contain some information on them as well as all of the transactions and smart contracts that were added to them at the current point in time so what this blockchain actually does is it represents a digital Ledger of the entire history of the ethereum network when we're talking about ethereum here right so every single transaction is a transaction that has taken place and we know the order in which they took place because they're ordered on the Block and then all of these blocks are ordered and this is very similar to something like a ledger that you would have at a bank so a bank would keep track of every single transaction you had sent and everyone else had sent it would know all of that information well same thing here with the blockchain we just do it in a different way now one of the Key properties of the blockchain is that it is decentralized this means it is not controlled by a bank is not controlled by a single person it is controlled by a network of computers that are owned privately by random people around the internet and the reason why this is important is because as soon as something is owned centrally so by one person or one organization or one entity they have the ability and the power to do something with it that is corrupt or that is malicious or that anyone else just doesn't have the ability to do or that they shouldn't maybe have the ability to for example if you own a bank account the likelihood this is going to happen is very slim but theoretically the government could just force the bank to hand over all of your funds maybe you need to pay your taxes or something whatever the idea is there's a central organization that controls this and so at any point in time this Central Authority could go in and actually modify what's on The Ledger they could change the account balance they could take money from you but here when we're talking about a blockchain that is actually not possible because this is not owned by one person or one entity it is used and controlled by all of the computers around the world that contribute to the network and we'll talk about what those are in a second but to be able to do anything malicious on the blockchain you would have to control almost all of the computers around the world that are storing a copy of the blockchain and that are on the blockchain network okay hopefully this makes a tiny bit of sense but let's have a look at one individual block kind of see how that works in the context of transactions and then we'll talk about proof of work and a bunch of other very important aspects of the security of the blockchain so let's say we have a single block okay we can just call this something like block number two okay now the reason why I'm naming it number two and not number one is because the first block in a blockchain is a special block contains some configuration and initialization related stuff because well it's the very first block so that's kind of a special one we're going to ignore block one for now and just move straight to block two now block two is going to contain some transactions on it the transactions I'm going to represent by these squiggly lines now these transactions are exactly what I showed you before they have a to address a from address an amount a signature and they have a few other things as well in fact every time you send a transaction you usually have to pay a very small fee and this fee will be given to the miners that are trying to secure and validate a block anyways this block has some transactions on now this is where we get into the concept of miners so miners are computers that are sitting around the world that are supporting the ethereum network they're actually what allow it to run and they're what secure the blocks and make sure that you can't just hack the network okay so we'll dive into miners in a second I just want to take a quick step back here so whenever you're sending a transaction you need this transaction to be associated with a block and this block has to be mined which we'll discuss in a minute before your transaction actually goes through and is completely successful up until that point your transaction will be pending but once it's been added to a block and that block has been mined then it is successful now a new block is added to the ethereum network approximately every 15 seconds so very very quickly anyways now let's talk about mining so what are monitors well as I discussed miners are just computers that are sitting around the world this is going to be my computer just a bunch of kind of deformed squares here right so there's a bunch of these guys sitting all around the world connected to the ethereum blockchain now every single time a new block is created and all the transactions are added it gets sent to every single Miner so all these miners are kind of nodes on the network they're all sitting there waiting for transactions to get added to the current block when this happens what these miners do is try to mine the block now mining the block consists of Performing some computations particularly some very difficult computations that are very time consuming and trying to guess a number that makes the hash of a block which we're going to get to in a minute have some specific properties now the point of doing this for these miners is that if they are able to guess a specific number they successfully mine the block and they will be given a reward so let's say minor one actually guesses what the number is I'll discuss what that number is in a second and they will be given some reward now this reward will be made up of two things the first thing it will be made up of is a block reward now a block reward is a reward that is hard coded into the ethereum network and actually decreases over time and this is new ethereum that will be created and given to the miner as a reward for mining this block I'm not sure what the current block reward is right now it's probably something like one ethereum but the point is that this is new ethereum that then gets added to the ecosystem and is circulating around so yes some cryptocurrency season here specifically ethereum do have an inflationary aspect to them because new currency is being created but it's not something you really need to be worried about and while there's a whole field of cryptocurrency called tokenomics that kind of discusses this and why this is maybe actually a good thing I'm not really going to get into this in this video point being don't be too worried about the fact that new ethereum is being created so the second thing that you're going to have is going to be your fees now every time you send a transaction you're going to pay a very small fee this fee goes to the miners that are mining the block and so the successful Miner the minor actually guesses the number that mines the block is going to get the block reward and any fees associated with all the transactions on the Block okay hopefully that makes sense I'm just trying to explain the incentive structure here for people to actually mine so continuing now we need to talk about what the miners are actually doing what the miners are doing are trying to guess a number that gets added at the end of the block so I'm going to say num equals question mark that makes the hash of this block equal to a certain number so what they're trying to do here is they are trying to find some number that they can add as kind of a dummy transaction at the very end of the block so that when I take a hash of this entire block so I run this to a cryptographic hash function the hash that I get starts with a certain number of zeros I believe right now what they're trying to find is a number that starts with 30 zeros but it could be actually higher lower I'm not sure what the exact number is the point is that what these miners are going to be doing is trying to guess some number right this is a random number that you add at the end of the block and then when you hash the entire block so all of the transactions associated with the block and the number together it gives you some hash some digest right that has 30 numbers at the beginning or 30 zeros at the beginning sorry and then the rest of it doesn't really matter what that is but you're just trying to find something that has a certain number of leading zeros so the point of this is that the more zeros that you have in that number you're trying to guess the harder it is to Guess that number because the probability just decreases that you're going to guess the correct number right here and again I'm just really trying to reiterate here that what's going to happen is you're going to take a hash of all of this everything inside of the block including this number and then you want it to give you some number that starts with 30 zeros but the thing is there's no way to figure out what this number is other than just guessing and checking because the cryptographic hash function has that property that there's no known inverse so since we can't compute the inverse we have no better way of finding out what this number is other than guessing and checking and so these miners are just guessing and checking as quickly as they possibly can and the one that gets the correct number then adds that to the block that mines the block and then we create a new block and continue moving forward now this is an oversimplification but that's the general idea of what these miners are doing okay so hopefully that kind of makes sense uh but that is what these miners are attempting to do and you might be wondering well there's so many minors so is it only actually one minor that's guessing this number and the answer is yes at every single block you're only having one Miner that is going to guess what the correct number is and get the reward that's why you'll have pool mining which means you'll have like hundreds of thousands of computers that will split their processing power they'll say okay we're all going to try to guess a number together and if any of us get the number we're going to split the rewards between everyone because the probability that one of us can guess the number consistently is very very low in fact if you only had one computer Mining and it was not mining very quickly your probability of ever getting a blocked reward would be almost zero because there's just so many other computers doing it and you'd have to get extremely extremely lucky so that's why you would mine with a bunch of other people so that your probability of getting a reward is much higher and then you would split that based on how much work all of you have done okay so let's continue here now what I want to do is draw a few blocks and we'll see how these are connected and kind of the security aspect of this so let's just paste this block over here and for now we can just go with two blocks okay so we have block two and then this guy is going to have to be block three let's fix your corner right there okay so we have block two and we have block three now this will be coming from block one we don't need to worry about that right now now the thing is these blocks are connected together right so we have block three we have block two block three is connected to block two and obviously it comes after block two now how do we know that well obviously these arrows aren't actually there we don't really have arrows connecting these things but what we do have is a field in every single block that represents the hash of the last block so we have something like last is equal to and then whatever the hash of this block is including the number that we guessed that is what we put right here to represent this is the last block in the chain so let's say when we hash all of this we get a number that is zero zero zero zero four nine a b now this will usually be a hexadecimal number that is 64 characters long but for Simplicity we'll just go with this for now so to get this hash we would also have guessed this number let's just say it's 7 and what we were trying to do was to get a hash that started with four zeros which we've done so next what we'll do is we'll write this hash here so zero zero zero zero four nine a b so now in block three we know the previous block was block two and block 2 would also have this field it would say last equal to the hash of whatever block 1 is so now block three we get a bunch of transactions on here we add them all on and we say okay we want to mine block three so what we need to do now when we mind block three is we have to find some number such that when we hash all of this including this last field right that's going to be included in the block where we're hashing we get a number this starts with four zeros so what this really means here is that if the hash of block 2 ever changes for some reason then this is no longer going to be correct because this is going to be referencing block 2 which now no longer exists and so this will be disconnected from the blockchain you can kind of imagine that this Arrow would get erased now I'll continue explaining this but again what we're doing is we're trying to mine block three so we'll guess some number let's say we guess some number nine and then we end up getting some hash here I guess I can just do it in maybe a purple color zero zero zero and then maybe this is 7 9ba okay this is the hash that we end up get so now where the real security feature of the blockchain comes in is that let's say I am a malicious entity here and I want to change one of the transactions on the blockchain so let's say I take my copy of the blockchain and I go to block 2 and I change the transaction instead I add this fraudulent transaction right here well as soon as I change this transaction this hash here changes right and the reason this is going to change is because when I take the hash of this block now since this transaction has changed I get something completely different and so what I'm probably going to end up getting here is something that doesn't start with four zeros so say maybe I get one zero two a b b c 1 that's my hash so now since this hash doesn't start with four zeros I need to recompute this number and remind this entire block because now the number seven is no longer correct to give me a hash that starts with four zeros so let's say I'm successful in doing that and I guess uh you know the number let's go 275 or something and now I get a hash like zero zero zero zero one two three four okay that's my new hash well now the problem is this hash does not match this hash right here and so this block is disconnected from this block and so if I want to actually keep this fraudulent transaction in Block 2 what I need to do now is modify block 3 because I have to change this last to match what my new last on block 2 is so what I do now is I come here and I would need to change this now to whatever this is so zero zero zero zero one two three four but now that I've changed this the hash here is going to be completely different right because we're going to get a different value when we have something different inside of the block so now I get a hash maybe that doesn't start with zeros right one zero zero two three a b c whatever some random hash so now I need to recompute this block recompute this random number and remind it so that I now find a hash that starts with four zeros and you get the point I have to do that for every single block in the blockchain right because these blocks are connected together and as soon as these blocks are no longer connected I don't have a valid blockchain and if I try to send this on the ethereum network all of the other computers on the network are going to be like uh no that is not correct your blocks are not connected your hashes are all messed up and I have a different version than you have so no I'm not going to accept that as a transaction I'm not going to accept that as a block because that is fraudulent so hopefully this makes a bit of sense but this is a concept known of hashes of hashes or hashing of hashes and so what we're doing is we're taking a hash of this block putting it inside of here and then taking a hash of this block that contains the hash of the previous block and so any change to the previous block means that this will no longer be valid and so we have to change pretty well every single block in the blockchain to be able to modify everything and that is why this is so secure and that is what leads me to the concept of proof of work so what we're doing when we're mining is we are proving that we have spent a certain amount of time before adding this block to the blockchain and the reason that's important is because the more time we spend the harder it is to modify the blockchain if you had an absolute supercomputer and you could just remind these blocks instantly then you would be able to go and change the blockchain that would be fine you could do that because you could just regenerate every single block with all of your fraudulent transactions added however since that's pretty well impossible and we have so many computers working on the blockchain at the exact same time for you to be able to do that you would need more computing power than all of the other computers on the blockchain combined and you would need to be able to not only rewrite the entire blockchain previously to what it's currently at you would also need to be able to catch up to all of the other computers that are working on the new blocks being added to the chain and kind of beat them and you'd be like racing against them in a sense I'm sure this is very abstract but this is what makes the blockchain so secure that these blocks are actually linked together you need to perform this mining process which is proving you've done a certain amount of work this work takes some amount of time this amount of time you can calculate using probability the probability you're going to guess a random number and how quickly you can guess random numbers and all of that and as the blockchain continues to grow being able to potentially modify it becomes harder and harder and harder so anything that is added to the blockchain is pretty well permanent and you cannot remove of it without having to rewrite the entire blockchain so this is all great but one other thing I will mention here is that another security feature that's built in is that every single computer that is mining the blockchain or mining the current block has a copy of the existing blockchain and so what that means is that if you try to change something on say the current block every single other computer knows what the current block looks like and so if you're submitting a block that looks different from that it's going to be able to tell that very very quickly it can just take the hash of the block if it doesn't match the hash that it has it's going to be like no this is the incorrect block I'm not going to accept this block or accept this transaction because well it doesn't match what I currently have so hopefully this is all starting to come full circle just a little bit you don't have to understand this stuff super super well but you just have to have a general idea of why the blockchain is so secure this concept of decentralization and kind of how transactions get added to the blockchain and what mining actually means right and that's the reason why there's been a huge GPU crisis in the past and recently as well a bunch of people are mining cryptocurrency for the incentive of trying to earn these different rewards alright so that is all great and really what I just spent the last 10 or 15 minutes explaining is proof of work so pretty much everything starting from when I started talking about blocks was trying to explain to you how proof of work works and while that uses raw computing power typically gpus to perform hashing which then secures the blockchain in the ways that I mentioned however and I understand some of you may be a little frustrated here ethereum is actually switching over now to proof of stake I'm not sure exactly when that's going to happen but it's supposed to have happened for a long time and I know it's going to happen very very soon and the difference is that with proof of stake which is going to be kind of the new method and algorithm this is a type of consensus mechanism which is going to be used to validate the transactions versus using raw computing power now proof of stake pretty much means that if you own cryptocurrency you can stake your coins by staking them you're kind of putting them in a locked container that's the way you can think of it and what this does is give you the right as the Staker of these coins to check new blocks of transactions and to add those to the blockchain now I'm not going to explain proof of stake in this video maybe we'll explain that in another video point being ethereum is slowly switching over or actually probably pretty quickly switching over to proof of stake and that's going to be the new method now I will just say that even though ethereum is switching over to proof of stake that does not mean that what I just explained to you was a waste of your time it is still very very valuable to understand how proof of work works and that is currently what is being used and is being used for a lot of other cryptocurrencies as well proof of stake is just another method of doing this and while I'm not going to explain that further in this video but maybe we'll talk about that in the future regardless with that said that pretty much wraps up everything that I needed to cover if you guys made it to the end of the video give yourself a pat on the back I hope that this maybe cleared up how the blockchain works and gave you at least a little bit of the insight into the theory behind it if I were to go through and explain all of the mathematics of This Not only would I probably make a ton of mistakes but this video would probably be four or five hours long so really if you can grasp The Core Concepts here you have a good enough understanding to kind of proceed and to move forward and start writing smart contracts and to be quite honest with you you don't necessarily need to have all this master to actually write a smart contract it's just very helpful in something that I think is fundamental before moving forward anyways with that said I will finally end the video here thank you guys again for watching if you enjoyed leave a like subscribe to the channel and I will see you in another one hello everybody and welcome to the third video in this blockchain for beginners tutorial Series in this video I'm going to be giving you an introduction to solidity and showing you how to write and deploy your first smart contract this is really really cool I had a lot of fun messing with this before the video and I think you guys are going to be amazed at how simple it is to actually write a smart contract anyways I should mention that solidity is the programming language typically used for deploying smart contracts and writing ethereum smart contracts and so that's why we're going to be using it now in terms of kind of some prerequisites for this video I'm going to assume that you have some understanding of programming some experience writing and maybe a different programming language just because in this video I'm not going to explain the very Basics like things like variables functions and all that stuff that's kind of common knowledge when it comes to program of course I'll go through the solidity syntax and we're really going to learn by actually just doing a bunch of examples and not focusing a ton on Theory last thing I will say is that you do need to have your metamask set up if you want to deploy this to a test Network so an ethereum test network if you don't have metamask setup that's fine you just won't be able to follow along with that step in the video alright so with that said we're just about ready to get started I just want to quickly thank cartesi again for sponsoring this video in this series they're an awesome company again dedicated to making the blockchain more accessible and easy to use they've really helped me a ton in terms of coming up with the content for these videos well I hope you guys appreciate that in the future videos in this series we're going to be talking about how we can actually use cartesi to fix some of the scalability issues with smart contracts because you're going to start to see some of the problems that can actually occur when we write a smart contract because they're a lot different than your traditional code anyways let's go ahead and get into the code foreign so I'm here on my computer and the first thing I'm going to discuss is just setting up our environment for writing code in solidity and deploying smart contracts now of course you can write contracts in vs code or any local code editor but instead for this series I'm going to use an online IDE called remix now this is a browserbased IDE it's completely free and it's super beginner friendly and allows you to actually deploy and test your smart contracts directly from the browser so I'd recommend that you use this you can check it out from the link in the description or just Google remix IDE again completely free and once you click on that link it should bring you to a page that looks like this so for now what I'm going to do is just give a quick tour of remix then we'll talk about smart contracts what they actually are how they work then we'll start writing some code and going through some examples of smart contracts so the first thing we want to do here when we open up remix is we just want to install a few extensions specifically for solidity so you can write other stuff in remix not just solidity code so that's why we want these extensions so what we're going to do is just on the left hand side here go to this plugin manager it looks like a plug and what we're going to do is search for solidity now for me I already have these extensions installed but what you're going to want to install is the solidity compiler the solidity static analysis and then the solidity unit testing now you don't really need the unit testing but you might as well just install it while we're here so install those three plugins and once you have them installed we're pretty much ready to start writing solidity code now you're going to see in the left hand side here let me zoom in a little bit that we have a bunch of you know I guess folders directories and inside of here we have some different smart contracts we have some scripts we have all this kind of stuff you don't need to worry about any of that this is all just kind of test code that's provided to you we're not going to use any of this we don't even need to look at it so you can kind of just ignore it for now what I'm actually going to do to get started is I'm just going to make a new file so I'm going to click on this little file icon right here and then I'm just going to call this test.soul so dot Sol is the extension for sale D file so that's why we're going to use that when I do that it will open up a brand new file notice we have the little solidity icon now we can start actually writing a smart contract now one thing to notice here is there's stuff like GitHub Integrations you can create new directories you can upload files you can also have different workspaces so right now I'm in a workspace I created called tutorial but you also could make a new one by clicking this right here I guess this is renaming a workspace and then of course you can delete it I'll let you look at that yourself pretty straightforward anyways all we need to do is get to kind of a file that looks like this just an empty solidity file so I'm just going to zoom in by clicking this plus icon here so you guys can actually read the code alright so now that we're here we might as well write a very basic smart contract I'll briefly show you how it works and how we can run it then I'll actually discuss smart contracts in detail so how they work how you call them and how they're different from traditional code because they are much much different than anything you would have seen before okay so what I'm going to do is zoom in a bit and let's start by writing what's known as our pragma line now the pragma line is required at the beginning of all of your solidity files and what this does is actually tell solidity what company Tyler version this file needs to use so there's a ton of different compilers that are accessible for solidity you just need to define the minimum compiler version so I'm going to say pragma solidity and I'm going to say 0.8.10 and then put a semicolon like that so for all of your lines you're going to have semicolons at the end very similar to something like Java okay so we have our pragma line again just pragma solidity and then the minimum compiler version if you want to see the compiler versions you can go to I believe it's this tab right here and it will show you all the compiler versions so notice we're on 0.8.10 so I'm just using one of the latest versions that we have okay and then for language of course that'd be solidity and you're just going to have compiler default now here you can actually manually compile your solidity code I'll talk about that in a few minutes for now though let's continue writing the rest of our contract so after we do our pragma line the next thing we need to do is Define a contract so I'm going to say contract and then I'm going to give this a name now I can give this whatever name I want I'm just going to call it my contract so what I've just done is created a smart contract okay that's all you need to do you write the word contract give some name the casing you're supposed to use for this name is Pascal case which means you're supposed to have capital letters for every single word and then inside of here we can start defining some variables some functions and methods sorry not not functions methods that's what I mean anyways for now I'm just going to define a very basic variable then I'm going to show you how we actually deploy and test this smart contract and then we'll continue with some theory in looking at this more in depth so for now what I'm going to say is uint this stands for unsigned integer and I'm just going to say that this is public like this I'm going to call this X and I'm just going to make this equal to 21. okay super straightforward this is just me defining a variable the type of the variable is an unsigned integer it is public meaning anyone can view it its name is X and its value is 21. so now that we have this contract what we need to do is compile the contract and then deploy so all of our contracts in solidity need to be compiled into bytecode this bytecode is then sent to the ethereum network where the contract is deployed and then we can call the contract so let's just look at a quick example of doing this so we can manually compile by pressing compile we actually don't need to manually do this when we deploy it will automatically compile for us anyways I've compiled the contract right here notice I have my compiler version solidity compiler default then what I'm going to do is go to this tab right here so just below it let's see what this one's called deploy and run transactions and here what we can do is choose a few different options for actually deploying our contract so if you go here notice we have a bunch of options we have web3 provider injected web3 JavaScript VM and then we have the Berlin version of the JavaScript VM now the JavaScript VM is what I'm going to use for right now but what this is is a virtual machine that simulates the ethereum network in your browser so this means you don't actually have to make any real transactions you're not actually adding this to a legitimate blockchain you're just simulating it so that you can test this directly in your browser now if you refresh your browser what's going to happen is anything that you've been simulating in the JavaScript VM is going to disappear because while it was being stored and I guess the cache or whatever inside of your browser point is Javascript VM is kind of a testing environment and when you're actually going to deploy this smart contract for other people to use you need to deploy it to what's known as a web 3 provider or an injected web3 now injected web 3 is actually going to use whatever Network your metamask is on so if I do this what's going to happen is when I try to deploy this contract it's going to open up metamask and it's going to require that I actually do a transaction to deploy this contract again we're going to look at that in a second for now I just want to quickly show you deploying it and running it and then we'll get into the theory so I'm going to go to JavaScript VM and notice here that when I do this it's going to give me a bunch of different accounts that have a hundred ethereum again this is just testing and the point of these different accounts is that I can actually use all of them with my smart contract because every time I deploy the smart contract I want to call a function on a smart contract I need to make a transaction to do that and that requires an account to make the transaction with so for now I'll just select this first account I could copy the address here if I wanted to do that the gas limit just leave this the same for now and then you could pick an amount of ethereum that you actually want to send with this transaction now I don't want to do that for now I don't want to send any ethereum all I want to do is deploy my smart contract so I'm just going to click on deploy and then you're going to see down here it's going to show you my deployed contracts so I now have a contract notice that showing this little button X and if I click on this it gives me the value of x okay very very simple that's all you need to do to deploy a smart contract we'll talk about this more in a second what I want to do now is hop over to my drawing tablet and start talking about some of the theory behind smart contracts and how they actually work and why we kind of need to go through this alright so I'm here on the drawing tab and I want to start by discussing how we deploy a smart contract then I want to talk about their use cases and go through a few properties of them so as we saw we had a smart contract and we stored this inside of a DOT Sol file now this is our solidity file and this is what we refer to as our source code now the source code is simply the code that we write as a programmer it's the closest to English it's the easiest for us to understand it is the source code okay this is where we actually write solidity code however this code cannot be executed on the ethereum network so what we need to do is compile this by running it through a compiler into something called by code so the first step when we're deploying this contract is we run this through a compiler this compiler is capable of taking one language and translating it into another and what we get here is now what I'm going to refer to as the bytecode now the byte code is just a special type of code that the computer can actually understand and execute in almost every programming language what's occurring is you're taking source code you're compiling it into bytecode and then that bytecode is being interpreted by an interpreter The Interpreter you can kind of think of as a mini computer in a sense that's actually going to be able to take all of this code read it understand it and then tell the CPU of your computer how to execute it The Interpreter is typically known as a virtual machine anyways you don't need to know too much about that point being you take source code compile it into something like bytecode byte code is then something that the computer can actually understand and execute and so that's how your code actually ends up running anyways at this point we now have our byte codes we've taken our solidity code We've ran it through the compiler by The Way remix will do this for us automatically so you don't need to manually compile the code and now we have our byte code so let me just move my byte code over here so now that we have this bytecode this is the code the ethereum network and understanding that computers can execute but how do I actually get this now to the block well what I need to do is I need to create a transaction now I just want to quickly mention here that what a smart contract is is just code that's sitting on the blockchain so all we're doing is we're taking this bytecode we're putting this in a transaction and then this transaction is kind of special in the sense that it requests to create this code this smart contract on the ethereum network so what happens is we make a transaction we throw the bytecode on this transaction we pay some fees and then we kind of upload this or send this in a way to the ethereum network okay so just like sending money between different accounts except in this case we're making a transaction that is adding this bytecode as a smart contract to the ethereum network now like all other transactions the first thing that needs to happen here is this transaction needs to be associated with a block then it needs to be mined once it's mined then is on the ethereum network now what that means is just like any other transaction anyone can go and see this they can see the transaction they can see who created the smart contract they can see all of the code of the smart contract they're able to view when you created it the balance of the smart contract all of these other things and this also means that once we add this smart contract to the network we can never change it we cannot mutate it we cannot modify it we cannot change it or delete it and the reason for that is the same reason that we can't delete transactions on the ethereum network right because that's the way the blockchain chain works it is forever there it is a ledger of everything that has happened is completely transparent and trustworthy and that's actually the main point of our smart contracts so hopefully that makes a bit of sense we're going to continue to clarify this in this section point being is that the reason we create smart contracts is because we're taking advantage of the security features of the blockchain to make people trust the code that we are uploading so let's take an example where we want to write some type of Poker application or a casino or something that involves money right something that's going to have money being transacted from either us to the client or from the client to us well if someone comes to our website or we go to some Casino website for example most times we can't see the code right we have no idea what's actually happening in the back end we could easily be getting ripped off maybe our money's being stolen maybe the odds are not in our favor or less in our favor than they should be whatever if we can't see the code we don't really have any way to trust what this website is doing or how these transactions are occurring however if you had your code as a smart contract and you knew that the website was using the smart contract maybe you're able to verify that in some way then you could just go and read the smart contracts that were being used and decide if you want to interact with them or not this means you can fully and transparently see all of the code that's actually being ran and executed you know if you want to trust it or not and then you can decide if you want to interact with it right so hopefully that makes sense one important point there as well is that that code that you're looking at can never be changed which means if you're interacting with the same smart contract you know it's always going to look like that and it's always going to be trustworthy so that's kind of the main point of smart contracts is to allow people to trust the code to make it fully visible to everyone and also just to allow everyone to be able to use it right although I will say it is pretty expensive to be interacting with smart contracts and uploading them to a theory okay that is the main point of smart contracts now one thing I will mention as well is that smart contracts can have a balance so that means you can send money money to a Smart contract it can receive money it can send money back to you it can call other smart contracts and in fact we're going to start talking about that now so let me clear the screen and now we're going to talk about how you actually call a smart contract so in front of me I have a beautiful illustration I have a contract and two ethereum accounts now as I said briefly a contract can have a balance so just like an account a contract is going to have an address it's going to have some type of balance so we can actually store ethereum and it can send and receive ethereum as well so that means that the account 2 can send money directly to the contract the contract could send money back to it and again account one and account two I'm just treating as regular ethereum accounts so ones we already would have talked about anyways the contract has a balance and that means we can go and view the balance we can see every single call and transaction that's happened with the contract everything is completely transparent just like our other regular ethereum accounts great okay so now that we understand that I want to talk about the fact that a contract should really be treated like a state machine so what I mean by that is that most contracts are going to store some type of data so in this case we have x equals one now we need to think of this like the state of the contract and the reason for that is that these contracts are not constantly run they're not just always executing in the background they need to manually be triggered from a transaction to actually do something and so when they're not being called by a transaction they're simply some State that's sitting on the ethereum blockchain okay that's all they are we just have the code we have the values of the different variables so the state of the contract and we can access the state or request to change the state by making some type of transaction okay so let's see now how we actually call a smart contract because I keep saying this for it to do anything we need to call it so calling a smart contract is really just making a transaction that requests some operation be performed on the contract okay so from account two maybe we make a transaction so in fact let's just write TX here representing transaction and this transaction is going to the smart contract now usually what we do is we pick some type of method or some operation we're going to be performing on the contract so maybe we call this a method here like set X and we pass value two now the smart contract can do whatever it wants in this method but maybe all it does is just change the state to two then what we would do is we would simply change this so now X is equal to 2. perfect now when we make this transaction just like any other transactions we need to sign it we need to secure it we're going to have a to address and a from address and we're also going to have to pay a transaction fee which is going to be made up of gas now you can think of gas kind of like a literal gas in the real world in the sense that this contract requires gas to actually be able to execute code so every single operation this is going to perform is going to use a tiny bit of gas it's going to use a little bit of gas and so we send what's known as a gas limit so the maximum amount of gas that we potentially want to use in executing this contract and then if that's enough gas the contract will actually be able to execute it will run through all of the code whatever it will have enough gas to do that it costs us ethereum essentially to execute code on the ethereum blockchain okay now the amount of gas you send in is required is going to depend on what the contract is doing some operations require a lot more gas than others anyways that's pretty complicated we don't need to talk about that for now but just understand stand that what happens is we're passing along gas and the gas allows the contract to actually execute if it runs out of gas just like a car it's not able to do anything else okay so that's it for calling contracts but now let's quickly talk about contracts calling other contracts because that is possible so let's say I have another contract right here and maybe this contract needs to interact with this one maybe it's going to call something on it's going to send ethereum whatever it's going to do so first of all that that's fine these contracts can interact with each other but they can only do that if this interaction starts from stems from is at the root of some account sending a transaction so these contracts if they have no transaction so imagine this guy's gone right here they can't do anything they cannot execute they cannot call each other they can't do anything at all they're just sitting there idle they are State machines however as soon as I have some transaction from any regular ethereum account that goes to a contract now this contract is capable of Performing some operations executing some code whatever and calling other contracts it needs to start though from one of these main transactions there's no way for this contract to call the other contract unless we start from a transaction that I've showed you right here so all of this needs to kind of root from some transaction outside of the blockchain so what I mean by that is from some kind of regular ethereum account so hopefully that makes sense but again you can really think about this in the sense that these contracts are idle not doing anything unless they're called from outside of the main blockchain Network right so from kind of a regular account and so if no account is calling any of these contracts they're not able to do anything and we also need gas which is going to be passed along with the transaction to the first contract call that we make all right so with that said I think that ends the theory section of this video I apologize if this was long but this really did need to be covered now we're going to get back to the code and I'm going to start showing you how to write more advanced smart contracts alright so I am back on the computer and now what I'm going to show you how to do is how to deploy the smart contract to a real ethereum Network so we'll go with the test Network right rather than the JavaScript VM which is going to emulate the blockchain in your browser so what I'm going to do here is change this to injected web3 now when you do that it's going to connect with metamask which I assume you already have set up and it's going to show you the test Network that you have I guess enabled in metamask and the account that you're using for metamask so in this case I have my tutorial account that has a little bit less than one ether anyways in the same way that we deployed this uh when we were using the JavaScript VM we could just click deploy it will automatically compile this for us we don't need to manually compile and it's going to actually bring up metamask because we need to make a transaction to do this right we need to create the contract that requires a transaction so we can look at data this is going to have the contract data we're going to have our details that's going to tell us how much it costs now the bigger the contract is the more this would cost anyways this is relatively cheap I will click confirm okay now this is going to take a second and if I bring up this uh kind of you know terminal here console you're going to see it tells me that it successfully deployed the contract okay so you can view kind of I guess the output of all the transactions and contract calls by just bringing this terminal up right here anyways what we're going to see now is it shows my deployed contracts so this is my deployed contract now what I want to do is actually look at this contract so let's see how we can do that so what I'm going to do is go to metamask here I am going to go to the contract deployment which is right here okay and then you'll see that I can actually click on this button and it will allow me to view the transaction on etherscan now I had some other transactions there I was of course messing with this before the video so you can ignore those ones this is the one that we just crit anyways now we are in etherscan the go rally test Network etherscan right and we can see we had our transaction it was successful and we have the from and the two now what I want to look at is the actual contract address so I'm going to click on that right there now it's going to bring me to the contract address on etherscan so I can see the balance I can see the content creator so this was me right I created this contract at this transaction and then it tells you that the content or the contract sorry was created now we can look at the contract itself so we can actually view the byte code we can decompile that into the source code if we want and then we have events I'm not going to talk about that right now that will be in the next video anyways we can close that I just wanted to oops uh let's go back I just wanted to show you what that looks like uh okay so let's go back to remix all right so now that we have this deployed we can use the contract right so I can access the variable X that's fine it's going to give me the value 21. so one thing to note here is that when you're viewing the state of a contract so we're just looking at the value of x here right viewing the state this is free we don't need to do a transaction it's fine we can query the state that's a free operation and the reason for that is the state is available right like we can go look at the state of the contract because it's stored in there publicly available it's already on the blockchain so we don't need to do any computation we're just querying and viewing a state so that's completely free to do so that's why when I click X here I get this instantly and it gives me 21 because I don't need to actually have a transaction mined to view the state the only transactions I need are when I'm modifying the state of this contract okay or performing some type of computation anyways what I want to do now is change the contract so we can actually update the value of x so this is where we'll talk about functions slash methods so what I can do is inside of this contract I can create a function this will be a kind of a method associated with the contract obviously I need to give this a name so I'll give it something like set X now for the parameters of this function I need to Define first there type and then the name of the parameter so I'm going to say uint underscore X like that this will kind of be my new x value that I want to set X to then I need to give my access modifier for this function now the access modifiers essentially tell people trying to use the contract if this function is private if it is public if it's internal external I'll talk about what all of those mean but you need one of these here so I'm going to say public to define the fact that anyone can use this method so a contract any uh anyone calling this from a transaction is able to use this method because it's public same with this variable X now if we made X private for example you wouldn't be able to access the state of it at least not very easily because it would be private to the contract again we'll talk about access modifiers in a sec for now though we'll just say function set X uint underscore X will make this public then I'm just going to say X is equal to underscore X okay so now when I call this function we will change X Change the value and then when we access it again it will be different pretty straightforward okay so now that we've changed the contract we need to redeploy this I'll do this again to the gorelli test Network so I'll just click on deploy okay we're going to have to confirm the transaction and notice this time it's a bit more expensive we have more content in our contract and so it makes sense this is going to be more expensive right so I'm going to click confirm okay it's going to take a second and then once it's created we should be able to use it and I'll show you what happens when we actually modify X okay so the contract has been created I'm going to click right here and now uh we'll have a new contract so we'll look at that one in a second but for now what I can do is set X so if I look at X right now it's 21 that was free right I didn't have to pay for that I'm just viewing the state but now if I change the state to say 25 so let's set X notice I need a transaction okay so it's giving me a transaction and this is going to cost me a certain amount of gas right so I will click confirm now this is going to take a minute I need to wait for the transaction to be mined okay it was done pretty quickly now if I click X again its new value is 25. so I've modified the state of this contract okay hopefully that makes sense that kind of wraps up all the explanation in terms of how you call a contract with the state of the contract is all of that stuff now we're going to continue looking at some more solidity syntax all right so I've just cleared my code and changed the environment back to JavaScript VM now I'm going to talk to you about a few data types in the solidity so the first one is uint now we've already looked at this it stands for unsigned integer meaning we can store any positive whole number okay so I can do something like uint public X is equal to one of course we know that is found now with the uint this actually allows us to specify the number of bytes we want to use to store the integer so I could do something like uint 8 un 16. you win 32 un 64 unit 128 and then 256 and I believe 256 is actually the default so if you just write uint I think by default it uses 256. I'll put something on the screen that confirms that or not now let's actually just see what happens if we try to store a negative number inside of a uint okay so let me just deploy this contract here we have our smart contract and notice that it's actually not even deploying this right because we would have seen the variable y because we have an error so it's deploying the last contract so the last one that we actually had compiled not this one because we have the error and it's showing that right here okay we cannot implicitly convert negative one to an unsigned integer now of course though we have regular integer right so regular int allows us to store a signed number again just like the UNS we can specify the number of bytes so 16 32 64 whatever now let's run to this one so deploy and let's see what we get here and now we have y so it actually deployed this contract and we can look at its value perfect okay so that is it now other than int we have a Boolean okay so we can say something like Boolean public Y is equal to True let's deploy this now oops I want to close that let's look at this contract here click on Y and notice we get true now of course other than true we have false I assume most of you know what the Boolean data type is just note here there is a lowercase on the first letter rather than a capital if you're coming from python like me okay so we had int uint bull now we also have a dress address payable and mapping and a ton of other data types as well now I'm only going through these ones because these are kind of the core most important ones we're going to use right now there is strings there is arrays but those work really strangely in solidity compared to other languages so just be careful there if you're looking at say a string or an array there's a lot of nuances and kind of details with those okay for now though let's actually not to a string so let's actually just look at the mapping type so the mapping type allows us to take some key and Associate it with some value so I'm going to say public and then we'll just call this map okay now what this means is that I can have some data type for the key and some data type for the value it's very similar to a dictionary or a hash table so when I Define a mapping I need to pick the value for the key or the type sorry for the key and the type for the value so for right now I'm just going to say uint like that is associated with it now just to show you how this works what I can do if I want to set a new mapping is I can say map and then I can put my key like this is equal to my value so if this was a real example I could do something like maybe the map of one is associated with the key of negative two now that means if I accessed map at 1 it would give me negative two okay so this allows you to associate some key with some value very useful you're going to use this all the time anyways that is a mapping again you put the type of the key and then you do this little equal and I guess greater than sign or less than sign associated with whatever the value data type is so right now what I'm going to do is just make a function that lets us actually add a new key value pair to this map so I'm going to say function we'll say set key like that we're going to take in a uint key and we'll take an INT value okay and then we're going to say that this is public and inside of here we'll just say the map at key is equal to Value okay now since this function is actually going to be changing the state of this contract that means we will require a transaction to use this excuse me but since we're in the JavaScript VM we don't need to do that because we're not actually on the blockchain anyways let me quickly go through the syntax so function keyword this lets us make a method or a function inside of the contract or inside of the class whatever you want to call it we then have set key this is the name of that function we have our parameters key and value and we're defining the type that is required for those we then say this is public meaning anyone can call it and we say map key equals value adding a new key value pair to our mapping okay let's deploy this okay so here's our contract let me open this up so we have set key and map now one thing to note is that automatically when you define a variable like this outside of a function so just in the body of the contract it's going to have a getter added for it automatically which means I can access any value in the map so I can do something like map one and we're going to see its default value is zero so in solidity all of our data types have a default value so even though we didn't assign this to something we just declare that it exists if I try to access any key since the value type is int it's always going to give me zero unless we have a different value for that okay so let's just set a key let's set like five with actually let me do this let's set five with like negative 23. I'll click on transact and now to test this I'll see if the key five is associated with negative 23 and it is so we're all good to go now let's do another one let's do like four with negative 10. okay transact let's go four and then notice we have negative 10. perfect there we go okay so now that we have done that what I want to do is talk about addresses and how we actually accept money in the contract as well as pay money out so let's get rid of all this for right now and let's start making some functions that can receive money and send money so what I'm going to do is write function we're going to call this receive and this is going to be an external like this payable function now let's talk about external because we haven't yet seen this so just like the public keyword that we had what external does is it makes it so that this can only be used from outside of the contract so I cannot call this function from within the contract if I did that that would give me an error and the reason for that is because we're going to be accepting some ethereum and when you define this as payable which is what I've done right here this means that we can actually pay money to this function when we call it okay hopefully that makes a little bit of sense we're saying function receive external payable meaning okay we can accept money and we can only accept money from outside of the contract so we can't call this from within the contract whenever you're accepting money you need to put payable when I say money I'm really talking about ethereum anyways inside of here we actually don't need to do anything we can just write the body of this function in fact that's completely fine and now what I'm going to show you is that what we can do is send money to this contract by calling this receive method because it's external pal so what I'm I'm going to do is deploy this okay when I deploy it I'm going to have my contract down here we have this receive function so when we click this red button here what's actually going to happen is we're going to send this amount of whatever this unit is so in this case it's way from this account to our contract okay so this function doesn't need anybody if it's external payable that just means we can pay money to it and so what I'm going to do here is set this to like I don't know we'll go with 10 000 way now way is the smallest amount of ethereum that you can send I believe 10 to the 18 way makes one ether so this is a very small amount anyways it's going to take it from this account in fact let's just send it from another account so we can see if it actually worked let me make it a bit larger and when I click the button again it's going to send that amount from this account to the contract so let's do that and now notice this amount has gone down I have sent some way right there you go makes sense now there was also some gas associated with that that's why it's not perfectly even and the gas limit was right here okay awesome so we said function receive external payable now this contract technically has a certain balance it would be ten thousand way all right so now that we've looked at that I'm going to show you how we can actually view the balance of this contract from a function so I'm going to say function and then this is going to be get balance okay let's spell balance correctly and then we don't actually need anything inside of parentheses and what I can do is make this a public view that returns like this a unit and sorry not units it's going to be a uint and then we can actually write the body of our function now let me just talk about this view keyword because we haven't seen this yet view is saying that this is a readonly method or a readonly function which means it cannot modify the state of our contract so you need to add that when you're writing a function that's going to return a value that's not modifying the state okay that's what we're doing so public view returns unit now inside of here what I'm going to do is I'm going to Simply return the address of this dot bounce now let me talk about this for a second so return I mean pretty straightforward we're turning a value from the function now what address is doing is actually casting this which is referring to the contract itself to an address so this is the address type right we can use this to actually cast this the contract to the address and then on the address type we have balance balance is how much ether is in this account or in this case in this contract now previously you could just write this dot balance however uh in the new version of solidity what you need to do is manually cast this to an address so again this was giving us the address of the smart contract we're then getting the balance and then returning it awesome so let's deploy the contract and see if this works now so I'm going to go here I'm going to send some money to this contract first actually I'll go get balance when I run get balanced notice that we have zero right there's a zero balance and let's now send some money so let's go from this account here and let's just send one ether okay so if I send one like that let's click receive click on get balance and then notice it's going to give me the balance in way okay if I wanted to convert that to Ether I would need to divide it by 10 to the 18 uh what do you call it way or I guess I could just divide it by one ether anyways not super important point is that uh there you go that is how you get the balance okay so now that we've looked at that I want to talk to you about a few Global keywords that we have access to in solidity from our smart contract so remember whenever the smart contract is running it's been initiated whatever it would have had to have been called from a transaction so someone had to send the transaction they had to call a specific function or method and then maybe they sent some ether along with that so we actually have a way to access that information like who sent the transaction so what I'm going to do here is write a smart contract that keeps track of the last person to send it ether so I'm going to make a variable up here I'm going to say this is an address now again the address is just storing an ethereum account address right or the address for an ethereum account so that's the data type there we have access to things like dot balance on an address so I'm going to say address this is going to be public I'm going to say this is last sender so let's go last sender like that and for now we'll just make this equal to nothing okay so it'll have a default value I believe the default address is just a bunch of zeros okay then inside of receive I actually want to set this to be equal to wherever the last sender was so I'm going to say last sender is equal to and then this is where we talk about the global keyword message dot sender so message is something that you can use to access all of the information about the transaction that was used to call this contract now other than message.sender we also have access to message.value now this is going to be the amount of ethereum that was sent with the transaction and we have access to message.gas as well so the amount of gas I believe that's remaining with this transaction okay so let's go and change this back to message.sender and now we can actually use this smart contract and see if it keeps track of who sent the ethereum so I'm going to deploy this okay so we should be deployed let's change to one of these fresh accounts and let's uh actually send one ether in the receiver okay so I'm going to send that one ethereum let's check the balance okay now the balance or sorry this is wrong contract I want to use this contract okay let's send one ether okay so go receive now let's check the balance okay so we have one ether in here and now if I go last sender it gives me the address of the account that actually send this ethereum so now let's change this to be let's go with this account let's send two ether okay get the balance we now have three ethereum inside of here and the last sender has now changed okay there you go that is how you keep track of the actual last sender of ethereum now what I would like to do is I want to show you how to send ethereum from the contract back to a different ethereum account okay because right now what's happening is we're sending ethereum to the contract but the contract's not sending anything back obviously that's not ideal we need a way to you know pay people back from the contract so let's do that so what I'm going to do is write a function I'm going to say function this is going to be pay this is going to be address payable addr and then this is going to be public like this and then payable now let's just quickly go through this so the reason I have the payable here is because whenever I want an address or whenever I want to be able to send ethereum to an address I need to specify it as payable so address payable is different than just regular address this actually allows me now to send the money to this account if I don't have payable then I won't have access to the methods I need for this address to send the money to so just make sure you put payable then we're going to have public payable now since this function is going to be paying money out it's payable if you're going to be sending money or receiving money you need payable then of course this is public which we've already talked about so inside of here there's a few different ways that I can actually send a theorem now some are simpler than others unfortunately though there's a bunch that have kind of some issues with them and that are not recommended to use so the ones you should not use are the following addr dot transfer okay now I know I spelled that incorrectly but you should not be using transfer okay there's some problems with that I'm not really going to get into them and then we have dot send again and there's some problems with this don't use this instead what you need to use is the most complicated one funny enough which is going to be something like this so let me just type it out then I'll explain it this is going to be bytes memory and then it's going to be data and this is going to equal to addr dot call and then we're going to say here that the value is equal to and whatever the amount of ethereum is we want to send and then we're going to call this with one argument okay I believe this is correct let me move this over a bit so we have some more room okay so function pay address payable addr public payable and then we have this kind of crazy line right here so first of all what this is going to do is it's going to decompose the return value of this into two variables first Cent and then second byte memory data now this first one right here is going to be a Boolean variable telling us if this was successful so if it was successful this is going to be true otherwise it's going to be false there's a variety of reasons it could be unsuccessful one of them being you don't have enough money in the contract to send okay then we have bytes memory data now this is going to give us the data of this transaction now you don't really need to worry about this too much in fact I'm not really going to explain it but memory is specifying that we want to store this data which is a reference type in memory again I'm not really going to talk about this much more just write this for now we'll worry about this in a later video then what does this do so what we're doing is we're saying address dot call okay and then inside of curly braces here we're passing the value which is the amount of ethereum we want to send now optionally we can actually choose the amount of gas that we want to send as well so forward with this transaction you don't need to do that you can just leave it to the default value which is what I'm going to do and then we call this whole thing with a string now this is going to be the message that's going to be sent to our uh what do you call it to our transaction or with our transaction so you don't really need to put anything here for right now it just requires one mandatory argument so that's why I put in empty string okay hopefully this makes a bit of sense again address dot call Curly braces with the amount of ethereum that you want to send and then this is setting up the transaction and this is actually going to execute it when you do the kind of parenthesis call right here with the string argument anyways what we can do after this is we can check if this was successful or not and the way we do that is we could use an if statement so ifs do exist in solidity or I can do something like if sent or I can use this fancy thing that we haven't seen yet called require now what require does is similar to an assert statement because it's going to check the value of a condition or a variable and if that's true we're going to continue everything will be fine if that's false it's going to throw an exception and actually tell whoever called this smart contract that there was an issue with that call so I'm going to say require sent and then here I can put an error message so I'll just say error sending money okay like that or error sending let's just go with f okay so again if this is true all is good we will continue if this is false then it's going to tell us that there was an error because we were unsuccessful in sending this ethereum all right now let's add our semicolon and what I can do is deploy this and test it out okay so let's go back here and let's deploy this let me close this contract okay so we have our deployed contract we have pay receive get balance and last sender so let us receive some money first so let's send one ether from this account so let's go receive okay last sender is this get balance is one now let's copy this guy's address right here by clicking on copy let's paste it in here let's click on pay and I think everything should be good we can go back here now and we can see uh if we were paid the ethereum or not all right so I thought something was going wrong until I realized that we actually are only sending a hundred way here rather than an entire ethereum which is what I thought we were going to be sending so what I'm going to do is change this to one ether now ether is actually a builtin word or builtin keyword in solidity and it will just multiply this by 10 to the 18 so that will give me I guess 10 to the 18 way right so one ether anyways I'm going to change that to one ether so now this will pay one ether from this function okay so let me redeploy here and let's close this okay and now we have our contract so let's receive some money so let's go from this account let's just send like five ether okay so let's go receive what's the balance five ether now let's copy one of these okay and we will pay it and let's see if this is all good I'll move up the console and looks like it's sent fine okay so now let's go here and we should see that in one of these accounts we have okay almost 101 ether right so I have 100.9999 because there was gas associated with the transaction so we didn't get a full one ether we got a little bit less perfect there you go that is how you send money using I guess this right here using this line okay great so now that we have that what I want to do is I want to end by quickly writing kind of an example of a bank that allows people to send ethereum to the smart contract and then withdraw up to the amount of money that they had sent to the contract so if I send one ether I can withdraw up to one ether from the contract as soon as I try to withdraw more it's going to tell me hey you don't have a sufficient balance so kind of just like a very simple bank account so let's go ahead and do that all right so let's get into this example of implementing kind of the basic bank accounts so I'm actually just going to get rid of all this we can just rewrite it this will be good practice so I'm going to start by making a mapping and this mapping is going to allow me to associate an amount of ethereum with an address so that way I'll know how much a specific account has sent so far and so I can regulate how much they can withdraw so what I'm going to do here is say mapping and this is going to go address like that and then this will go to an unsigned integer which will be the amount of way that they have sent so amount of ethereum okay then I will call this balances and I can actually manually make this private if I want now when I make this private what that means is there won't be a default getter for this so I can't easily just access the balance of a specific account instead I'll have to use one of the methods or functions that we Define okay now we need some way to receive money so let's write that we're going to say function and we'll say deposit okay and then this is going to be a actually external and then payable okay now what I'm going to do is I'm going to say balances act and then this will be message dot sender which is going to be the address of the sender of the transaction is equal to or sorry plus equal to message dot value okay so remember all of the keys here are going to have a default value of zero so even if this address doesn't kind of exist yet in the balances it's going to have a value of 0 when I access it so I'm going to add message.value which is the amount of ethereum they deposit okay then of course if this already existed I would just be adding to it whatever the amount of ethereum is they deposited in this transaction that's all I need for here I'm just adding this to the balances then what I'm going to do is say function withdraw and this is going to need to take in an address to withdraw to and in fact I don't necessarily need to do that uh because what I could do is just use the message.sender address so whoever was withdrawn whoever sent the transaction I just automatically give the money to them but instead what I'll do here is just put in an actual parameter so that you could technically withdraw your money to someone else's account hopefully that makes sense but you'll see what I mean so I'm going to say address payable and then this will be addr and then we'll say this is going to be a public and then this will be a payable function like that okay so what I need to do here is I need to check that they have a sufficient balance in the uh the balances before they can withdraw something I also need to take in the amount that they're going to withdraw so I'm going to say uint amount like that and this will be the amount in way that they want to take it okay so we'll say withdraw payable amount okay great that's fine now inside of here what I'm going to do is I'm going to confirm that they have a sufficient balance before I let them withdraw so I'm going to say require and I'm going to say balances at addr is greater than or equal to the amount that they want to take out okay perfect so we'll do that then I'm actually going to send the ethereum to them that they want to withdraw so we're going to say I guess this is going to be bull sent and then this will be bytes memory and then what was this data is equal to and then addr dot call and then this is going to be value colon amount okay and then I think I can just call this like that okay so that's good now that I have that I'm going to confirm that they sent it successfully so I'm going to say require sent and we'll say could not withdraw okay we got to spell this properly this is just okay there we go could not withdraw and then what I'm going to do here after I successfully check if they withdrew or not or after I check that they successfully withdrew I'm going to subtract their balance I'm going to say balances and then this is going to be at message dot sender minus equals the amount okay I think that should be good now let's just run through this and make sure we understand so first we're requiring that their balance is greater than the amount so if the balance that they currently have in our kind of bank here is not greater than the amount then we actually need to give them an error message and we'll say in sufficient funds like that okay I think that's how you spell insufficient that should be fine all right and then what we're doing is we're trying to actually send this amount to them so if they have a sufficient balance we'll try to send it to them if this for some reason does not work then we'll tell them that they could not withdraw and we'll keep the balance here right because if we didn't send it then the balance is not gone we still have the money in the contract otherwise we will subtract their balance and then we're good to go okay so now we have deposit and withdraw and if we want to we can write one more function here let's go function get balance and this will just give us the balance of a contract okay so let's just go public view returns unit okay and then let's return the address of this dot balance and that should be good okay now we could also write something that allows us to get the the balance of a specific address or we could just make this public but for now I'm going to leave it private okay hopefully that is all good now what I'm gonna do is just deploy this contract so let's deploy it let me get rid of this one now what we can do is deposit some money so let's go to this account let's deposit 10 ether okay so we're going to deposit uh that should have happened successfully let's check the balance looks like we have 10 ether now let's see if we can withdraw so let me copy this address okay so I'm going to paste that in there in fact let's make this larger and for the amount I wish I could copy this uh let's just go with a bunch of zeros here I don't think I can write F directly in here otherwise that'd be useful okay so let's click on transact and let's look at our console here and see if this was good okay it looks like we successfully sent the way so now if we go we see we have 85 ether rather than 84 which is what we had before so let me see if I can make this something like five now and click transact okay looks like that was successful I guess we're not passing enough zeros okay now we have 85.599 okay now let me try to send an entire five ethereum which we know we don't have for this person actually maybe we do because I think we transacted 10 ethereum sorry but let's try this okay transact and that was successful now let's try this again and notice that when I try to do it again I don't have enough ethereum for this balance so I get insufficient funds as my error message okay if I look at the balance of here we have 4.4 ethereum left in the contract so now let's try to do this from another account so let me copy this address and let's see what happens if I try to withdraw say one ethereum from this address okay if I do that notice we get an error it says uh insufficient funds because this address is not yet deposited any ethereum so let's now deposit some so let's make this one ether let's click deposit okay now let's try to withdraw and notice we're able to withdraw that successfully all right so that is all I have to show you for this example here hopefully that was a decent introduction to solidity I understand there was a lot of stuff covered in this video I don't expect you to know all of it I just wanted to kind of show you how to create a basic smart contract how to send ethereum receive ethereum and then hopefully give you a bit of an idea behind the theory of how smart contracts actually work in the next video we're going to continue learning more about solidity I'm going to show you some more advanced things that we can do and then in future videos we'll talk about some of the limitations of solidity and how to make things more affordable using cartesi which is the sponsor of this video and this series hope you guys enjoyed if you did make sure to leave a like subscribe to the channel and I will see you in another one hello everybody and welcome to another video in this blockchain for beginners tutorial Series in this video we're going to be continuing from the last video and learning more about solidity once we learn a few new topics then we're actually going to work on an auction where we're going to be auctioning an nft now this will work with any type of nfts this is really really cool and if you're interested in nfts you're going to learn a little bit about how they work so with that said we'll get into the content in a second but I do need to thank cartesi again for sponsoring this video and this series they are an awesome company they've been helping me come up with the content for this series and they have a bunch of scaling solutions for ethereum and for developing smart contracts that we're going to look at in a future video regardless let's go ahead and get into the content alright so I'm back in remix and in front of me I have the example that we finished in the last video which is kind of a mock bank account now what I'm going to do is just give you a quick recap of everything that's in this contract so we understand the syntax and get a quick refresher then we'll look at some new solidity features and we'll actually move into working on that auction which is going to be the bulk of the video okay so right now we can see we're inside of a DOT Sol file now the dot Sol stands for solidity and that's the extension you need for your solidity smart contracts now at the top of our contracts we need a pragma line now the pragma line is going to tell solidity what compiler version we should use so in this case we're using 0.8.10 to see the compiler versions you can go to the solidity compiler extension click here and then it will show you the versions in this case 0.8.10 is one of the latest so that's the one that we're going to use great we then Define our contract we say contract my contract open the curly brace and close the curly brace and inside of here is the content of our contract now it's worth noting that you can Define multiple contracts in one solidity file and you can have stuff like contract inheritance that's a little bit complicated we don't need to look at that here but just wanted to mention them okay so inside of our contract here we start by defining what most of you would consider a class attribute this is just going to be actually a private member of this class because we've defined it as private anyways this is a mapping type now the mapping type is like a hash table or a dictionary where we have some key that can be associated with some value now in this case we're having an address this is going to be an ethereum address being associated with a uint so an unsigned integer we then denote this as private meaning we can't directly access this from outside of the contract and then we have balances that's just the name of this mapping okay now we have a function the function is called deposit it's denoted external and payable now external says that we can only call this function from outside of the contract so I couldn't go here and do something like deposit that would be invalid because this is an external function then we have payable payable is saying that this is either going to be sending money to someone or receiving money or specifically ether and in this case since we're going to be getting money we have to make it payable then what we do inside of deposit is we say balances at message dot sender now message.sender is going to be the address of the sender of the transaction who's sending money to this contract so essentially whoever invoked the call to this contract or made the transaction to this contract it's going to be there address we're adding that as a key to balances and then we're going to increment the value here by message.value now message.value is going to store the amount of ether that they sent to this contract and the reason why we can do this is because the default value of all of our uins inside of our mappings is going to be zero so even if this sender does not already exist in the mapping we'll simply make the value equal to whatever the message.value is because the default value is zero hopefully that makes sense that's explained in the previous video in case you are confused regardless we now have withdraw so withdraw is going to take in an address payable this is going to be our addr that's going to take in uint amount now this means that we need to pass an address to this withdrawal function this is the address that we want to withdraw funds to then we have u in to mount this is the amount of funds that we want to withdraw from the contract now this is a public payable function when we say this is public that pretty much means it can be called from anywhere and then we have payable and again what payable means is we're either going to be sending money out or receiving money so of course we need to denote this function as payable okay we then have a require statement and what the require statement is going to do is it's going to check if this condition is true and if it is not true then it's actually going to raise an exception and the exception is going to be insufficient funds that means we're actually going to cancel the entire contract call everything that would have happened is going to be reverted I'm going to talk about this more in a second and essentially this transaction is going to fail because this condition was not satisfied okay so you use require when you want to ensure that something is true before proceeding in the contract okay so we're requiring that the balance of the address is greater than or equal to the amount that we want to withdraw makes sense if we don't have that then the error or the exception is insufficient funds so next we're actually going to send money from the smart contract to this address if they had sufficient funds to withdraw so we're going to say bull sent bytes memory data is equal to 80dr dot call and then we're putting the amount that we want to withdraw and then we're actually calling this transaction now if you're confused on how this line works I spent about three or four minutes explaining it in the last video so you can go back and watch that essentially all this is doing is sending money to this address this is the amount of money that it's going to be sending or the amount of ether great then we have this bull sent now this bull sent is going to be equal to true if we successfully sent this otherwise it's going to be equal to false so if we were not able to successfully send the money some error occurred there then we're just going to raise the exception could not withdraw otherwise what we're going to do is we're going to update the balances so we're going to say balances at message.sender minus equals the amount to make sure they can't just keep withdrawing the same amount of money it's actually going to subtract from their current balance when they withdraw great then we go to this function so this is get balance now let's say public view function now again public means we can call this from anywhere and view actually means that this is only going to be returning or accessing state from this contract it's not going to be modifying it so this means we can call this get balance function without actually having to make a transaction which pretty much means this is free to call so this is a good point in time to remind you that whenever we're just accessing the state of a contract this is free we can just query the state of the contract we don't need to pay for this however if we're going to be actually modifying the state then that requires a transaction that transaction needs to be mined and well that means it's going to cost us some money at least in gas and potentially ethereum if what we're doing requires that we send ethereum Okay so let's continue explaining this we then have returns and then you wins now returns is just stating what this function is going to return we're saying u n standing for unsigned integer and then here all we're doing is we're returning the address of this now this is just going to be the contract we're just going to cast this to its actual address and then we're going to get the balance whenever you have an address you can access the balance by just using dot bounce there you go that is everything that we did inside of this contract so now that we've talked about all of this I just want to spend a second talking about exceptions because we've seen them in this contract but I haven't actually talked about exactly what they do and how they work so in solidity we have a few different ways to actually throw an exception or to cause an exception to occur now an exception is pretty much an error that's going to occur in our program and all exceptions in solidity are State reverting now what that means is if there's ever an exception at any point in time during the transaction call then this is going to revert the state back to what it was previously any changes you've made up until that point will be completely removed so just to give you an example here let's say that I did something like balances at one is equal to two now I know this makes no sense but let's say I did this right here and then I come to this require line and this actually ends up raising an exception because Cent is equal to false well if that's the case this line will be completely reverted we won't actually have done that operation it will be undone and reverted back to what it was before so just worth noting whenever an exception occurs any of the state in the contract that's been changed is going to be reverted now require as I'm kind of alluding to here does cause an exception right so if the condition here is not true then it raises an exception and the message for that exception is going to be whatever we put here now there's a few other ways that we can raise exceptions in solidity I'll quickly show them to you although we're not really going to look at an example of them so one way to raise an exception is to use revert now revert actually allows us to just directly uh revert the entire contract State again this is just going to raise an exception exactly like require will except inside of here we can just put our error message we don't actually need to put any condition so if we ever encounter a revert in the program we're just immediately going to raise an exception the exception message will be this and again that's going to revert the state because that's what all exceptions do in solidity okay so that's revert now another thing that we have is assert now assert is similar to require in fact it works in the exact same way except it's designed to be used when you want to check in variants rather than checking input validation so I'll show you here I could do something like assert uh true is equal to true now of course that's always going to be true but you get the idea now if this condition was false what would happen is we would raise an exception with this as the error message now assert and require are pretty much identical but the reason you use assert is because you're checking an invariance if you don't know what that means don't worry about it and if we're using require we're using that when we want to check input validation okay so that's why we're using require here because we want to ensure that the amount that they passed in is valid now in this case we could probably actually replace this require with an assert it's not a huge deal and there's actually not really any formal recommendation on which one you should use but it's kind of the standard to just use assert when you're checking an invariant and require when you're checking input validation so in this case based on what I'm saying we would use assert here because this is an invariant but we also can just use require like I had before that's completely fine anyways this isn't super important but I just wanted to show you those methods in case you see them in other contracts alright so that's almost everything for exceptions one more thing to note here is that the only thing that will not be reverted if an exception occurs is low level calls like this addr.com now I can't really show you what the other calls are because we haven't seen them but essentially if you were to send money to someone successfully and then later on in the contract there's an exception that occurs that's not going to be reverted you just can't revert that because once the funds are transferred well you can't really just transfer them back and so if I did something like this and let's say that this was successful then that means this is not going to be reverted now everything else will be reverted this balances will be changed back but this isn't going to be reverted the ethereum that was sent to that account is not going to be sent back to the smart contract okay there's some good reasons for that but that's worth noting now a few other things to mention here with exceptions exceptions are cascading now that means if I have an exception that occurs in another smart contract that I'm calling from this smart contract that's going to mean that the state of this contract as well as the state of the other one are going to be reverted so it's kind of hard to show this but let's say I make a contract and I call this my contract two like this and let's just make some functions so we can do something like function test and then just make this public view returns you ins okay and then maybe what I do here is I just say revert okay so that's what I do now if I call this function okay from inside of here then even though it's happening inside of this contract the exceptions occurring here it's going to Cascade into this contract meaning that if any of the state was changed inside of here that's going to be reverted and same with any of the state inside of my contract too hopefully that makes sense but just keep in mind that exceptions Cascade so even if you have like 10 contracts all calling each other and then in the 10th contract an exception occurs every single one of the contracts that we're dealing with that contract are going to get the cascading exception and all of them are going to have their state reverted and the transaction will fail now just to note here the reason why we're getting this error is because I didn't have the semicolon of course revert is fine I can put this here although this doesn't really make much sense because why would you just just revert inside of a function alright so now that we've talked about exceptions what I can do is start showing you some new features in solidity and the first thing I want to do is show you a Constructor so I'm just going to clear everything that's inside of this contract and I'm going to write a public variable here so I'm going to say let's go with address and this is going to be public and then I'm going to say that this is the owner of the contract so what I'm going to show you is a Constructor now a Constructor is simply a special function that's a part of a class or in this case a contract that's going to be called when the contract is initialized now in solidity your Constructor will be called exactly one time and just like any other language Constructor you can accept parameters in here you can do some setup steps and well you'll see how this works so the way you implement a Constructor in this version of solidity is Constructor open and close parentheses open and close curly brace and then inside of here you can do whatever you want so in this case I'm just going to say my owner is equal to the message dot sender now the reason I'm doing this is so that I can keep track of who actually created this contract so when I create a contract I have a message dot sender whoever sent the transaction to actually create the contract so this is perfectly valid I can say my owner is equal to the message.sender and now whoever deployed the contract will be the owner and I'll be keeping track of that inside of this public variable on the contract okay pretty straightforward that's how that works now again this is how you do the Constructor you can only have one of them and this will be called exactly one time and only one time when the contract is deployed this isn't going to be called every single time a transaction is sent to the contract it's only called when it's deployed the very first time so let me show you how this works let's go and actually deploy this to the JavaScript VM let's click on deploy okay we have our contract when I click on owner it's going to give me the address of this account right here which is the one that I'm using now let's try deploying from this account okay so deploy my contracts down here owner now it's giving me the other own pretty straightforward that is how the Constructor works and this is a pretty common thing that you'll want to do is keep track of who actually deployed the contract now another thing you can do in here is accept parameters so maybe I just want to accept a uint and let's just go with something like test for now again this can really be anything okay I want this to be test and then what I will do is say you int public and let's just go with I don't know V I'm just picking random names for now and I can do something like V is equal to test that's completely fine I can access the value of this parameter so now let's get rid of these contracts all right so now we can deploy our contract and notice where the deploy button is it's actually giving me a parameter that I need to pass here it's saying task this is a uint256 so I'm going to do something like two hit transact now I go to my contract I have owner and I have V and I can see V is equal to two there you go that is the basics of the Constructor now of course you can have multiple arguments if you would like or multiple parameters sorry and do whatever you please with them great so what I'm going to do now is just get rid of everything inside of here and I'm going to start talking to you about a new thing which is called a pure function now we've looked at view functions we've looked at payable functions internal functions external functions public functions now we want to look at pure now a pure function is pretty straightforward but it is simply a function that is not going to do anything with the state of the contract you can kind of think of it like a static method because it has no access to the internal state of the contract it just does some type of computations then returns some value so I'm just going to write a function here I'm going to say function and this will be something like add to now we will make this a public and then this will be pure function and this is going to return a uint like that now I'm going to take as a parameter here the uint X and all I'm going to do is just return like this X Plus 2. okay very straightforward but this is a pure function now as I said a pure function is not going to modify or access the state of this contract it's just going to be performing some type of computation that doesn't rely on the actual contract internal state so just like accessing the data from a contract this is going to be free as well we don't need to pay to do this and let me prove this to you so if I go to my injected web 3 now I'm connected to the godreli test Network and I do deploy this okay it's going to ask me for a I guess transaction because when I deploy I need to pay for that and then let's give this a second okay we can see that our contract is deployed now let's do something like add to five notice it gives me the value 7 back I didn't need to add a transaction to be able to do this okay so whenever you have a view or a pure function these are free you don't need to have a transaction to call these so if you ever just want some type of utility functions associated with your contract then you make them pure okay hopefully that makes sense that's all I need to cover with pure okay so now that we've gone through that we can start getting into the important stuff which is events so I'm actually going to hop over to the drawing tablet to explain to you what events are and then we'll start implementing them when we work on the auction all right so I'm now on my drawing tablet I'm going to start explaining events to you but before I can do that I need to talk to you about why we need them so in front of me I have a smart contract now this is going to be our auction contract and on the auction we're going to have some function called start now of course we're going to have some other functions as well but for now just imagine we have start and what start is going to do is it's going to attempt to start the auction so it's going to modify some of the state and then it's going to return a value indicating to us whether or not this was successful so we're expecting this to be a boo let me just write this right here indicating it's going to return a boom okay that's great so now we want to start the auction so let's say we have some account so account one like this we know since this is going to modify State we need to make a transaction to the auction to be able to start this so I'm going to make a transaction we're going to call start on here and then what we're expecting is that we're going to get some return value here indicating to us whether or not this started successfully well if we're just working on our JavaScript VM then we know that it's actually going to work successfully we're going to be able to get a return value we'll see something like true or we'll see something like false however if we're working on a real blockchain we're actually not able to return something from a function that's modifying the state back to our account so essentially whenever we're making a transaction we can't return data back to that transaction now this actually makes sense if you look at how transactions work but for now you really need to understand that if you ever make a transaction to a Smart contract that contract cannot return you any day data now it can try it can have a return statement but you're not going to be able to view that return data from the transaction so really we have to imagine that this is going to be a oneway operation where we're just going to call start now if an exception occurs we're going to be notified of that however if an exception doesn't occur we're not going to get any return value so trying to do something like this is not going to work on a real blockchain now that's a pretty big problem right because in a lot of situations when I make a call or I make a transaction story to my smart contract I probably want to get a return value I need some information I want to know if this started successfully however we can't have a return value so how do we get around this problem well the way we get around this problem is with events so what a smart contract can do is it can actually emit events now that means that what we can do from auction is when we start this we can create or emit something known as an event and this event can have a return value that we might want this account to be able to see so we can emit an event that says something like started and then maybe we can put the time that this started out and we can put if it happens successfully or not so we could but true or alternatively we could put false now these events will be stored on the blockchain however they're going to be stored in a different way than the data associated with your contract so any of the variables you would have defined or kind of the state of the contract is said to be in storage these events are not going to be in storage they're going to be stored as a part of the transaction history on the blockchain so that makes them a little bit less accessible however they are much cheaper to use because of the way that they're stored so I'm not going to get into this too much but essentially just understand that your events are stored in a different way that makes them much cheaper to actually store although they are a little bit harder to access so that means that you usually use a thirdparty tool maybe something like etherscan to actually read and query these events because it's not as simple to go directly look at them like it is for the data on the contract and so we emit this event and then this account here or some external client that's off the blockchain is able to view these events and subscribe to them so they'll be notified if an event occurs now I'm going to get into a detailed example in a second but for now just understand that whenever we have a transaction our smart contract cannot return a value to that transaction instead what it can do is emit an event this event will be stored off the blockchain you can kind of think of these events as a log right we'll be able to then view those logs off of the blockchain and we can search for specific data inside of those logs and subscribe to events which means we'll be notified when an event occurs now just an important note here this is not the case the so the no return value thing is not a case if we're making a call not a transaction now I understand this is a bit confusing but if I'm making a call to a function that does not modify the state so that doesn't require that I spend money on it doesn't need a transaction essentially I'm just querying the state then of course I can get a return value right if all I want to do is just get some data that's stored in the state of the auction that's fine I can do that I can get a return value but if I make a transaction that modifies the state that's the situation where I can't get a return value okay hopefully that makes sense but that is why we need events so now let me clear the screen and let's get into a more advanced example alright so for this example what I want to do is imagine that we're trying to build an application that's going to be partly on the blockchain that's going to allow us to auction our nfts again we still have this auction this is our contract but now what we probably want to do is we probably want to make a nice beautiful user interface that allows users to interact with this auction so to interact with the auction the owner of the auction is going to need to start it and then once it's started we're going to be able to accept bids right now the bid will be a certain amount of ethereum and we'll need to keep track of what the current bid is who's currently winning the auction we need to know when the auction ends and all of that logic again will be handled by auction however we want a very easy way for users to be able to interact with the auction contract I don't want them to have to write some really low level code and send their own transactions instead I want them to just be able to connect their blockchain encounter their ethereum account with my user interface and click this nice big button that says bid okay so they're going to be using my user interface all of my clients are going to have a different instance of the user interface maybe this is something like a react app or something like a JavaScript client whatever right so let's say we have kind of two user interfaces here and we have two people that are bidding against each other just for Simplicity so I'm going to say that this is number one and this is number two now the concept here is that this person is going to press the bid button it's going to send a transaction to the auction it's going to send maybe one ethereum and well that's going to be their bid and then this person maybe they want to send a bid maybe they send a bid of two ethereum now this is all great but again we run into this problem where I want these user interfaces to be able to be updated whenever another bit occurs so essentially if I'm sitting right here I want to know that number two just made a bid so that I can then bid again and I can bid three ethereum right now how do I do that well since I can't get a return value here and since my auction can't send something to my user interface it's not able to do that what I need to do is use my events so what's going to happen is every single time I make a bid an event is going to be emitted so I'm going to say omit and then I'll omit an event that's going to be something like let's write this properly something like bid 1f and then it will be from number one and then it will probably give the time that this bit occurred and a bunch of other information but the idea is we're going to Omit all of these events and then what we can do is we can have these user interfaces subscribe to the events so when they subscribe to the events what's going to happen is they're going to be notified when an event occurs and then they can use the data from the event to update their user interface and tell the user hey you just got outbid do you want a bid again or hey the current bit is this or the auction ended or whatever you get the idea but the concept here is we have an external client right so our JavaScript clients kind of sitting on some type of user interface they are subscribed to the events that this contract is going to be emitting and whenever the contract emits an event they'll be able to update their user interface and they could say query the state of the auction if they wanted to they could do that for free because that doesn't require a transaction hopefully this makes sense but that is the point of events and this is kind of how you would start building out a very simple blockchain application you would deploy your smart contract this would be kind of your source of truth right this would handle all the complex logic then you would have your nice user interfaces that allowed the user to interact with the smart contract and be updated of things that's happening with the smart contract because the smart contract can only do some type of operation when a transaction is performed so you need some type of external client sitting listening for events and updating the user then the user can trigger those transactions to the smart contract when they actually want to do something that is State changing perfect there we go we Now understand the importance of events let's go ahead and go back to the computer we're going to start writing out this auction contract and looking at events alright so I am back on my computer in remix we're actually just going to start working on the auction contract and then as we work on that I'll show you events so I'm going to change the name of my contract here to auction because that's going to be a bit more fitting and I'm going to implement a bunch of public things that we need here for our auction so if we're thinking of an auction we're going to have a time span for this auction so we need to know if the auction has been started if it's ended how much time is left so when the auction is actually going to end we want to know all of the bids we want to know who's selling the nft we want to know what the current highest bid is and who the current highest bidder is and we also need to know what nft we're selling but we'll deal with the nfts later because that's a little bit complicated so for now what I'm going to do is say address payable it's important we do payable here because we're going to want to pay this person who you'll see is the seller so we're going to say address payable public seller now it needs to be payable because well the seller of the nft we're gonna have to pay the profits of the auction so whoever you know the highest bidder was we're going to take money from them and send it to the seller okay now other than that we're going to need to know when the auction started so actually we don't need to know when it started we just need to know when it's going to end if it started and then if it's ended so I'm going to say Bool and then this will be public and this will be started we'll then say Bool public ended and we'll say bull or sorry not Bool this is going to be you ins and then this will be public if we could spell this correctly and then end at and this will be the time that we actually are going to end the auction at now other than that we need the highest bidder so we're going to say U int or sorry we want the highest bid so I'm going to say UNS public and then this will be highest uh bid like that and then we will have a dress and do I want this to be payable let me look at my cheat sheet here no I don't think we need that to be payable we'll just say address public and then highest bidder like that uh and that should be good now other than that we're going to need some mapping to keep track of all of the bids that users have made to this contract so the idea here for the auction is that when you make a bid you have to send money to the contract so if you don't actually end up winning the nft then you need the ability to withdraw your money right so we're going to have a withdrawal function that allows you if you didn't win to actually take all your money back from the contract so I'm going to say mapping and then this is going to be address and this will go to a uint and this will be a public and then this will be bits now the reason all these are public is because I don't need to hide any of this information it's fine if everybody sees it and I want people to be able to see when it started when it ended what the end that is what the highest bid is because you want people to trust this contract that's the whole point of writing smart contracts right okay so now that we have that I'm going to make a Constructor I'm going to say Constructor like this and all I'm going to do is simply assign the seller so I'm going to say the seller is equal to message Dot and then this will be sender so whoever deploy the smart contract will be the seller of the contract now notice I'm getting an error here it's going to tell me that the type address is not implicitly convertible to expected type address payable now I didn't show this to you previously but the way that you can convert a regular address to a payable address is you can just say payable like this and then surround what you want to convert so now this address that is nonaddress payable will be payable and I'll put that in inside of seller okay now what I'm going to do is Implement a start function this function will allow only the seller of the nft to start and they'll need to pass all the nft details to be able to start the auction now we won't implement the nft stuff right now as I mentioned we'll do that at the end so I'm going to say function we'll just call this start then this will be public external okay so we're going to call this from outside of the smart contract and inside of here what I want to do is I want to require that the message dot sender is equal equal to the selling otherwise I will say you did not start the auction exclamation point okay and then we'll go with semicolon now what's the error here it says visibility already specified as public okay so that's my bad story I'm just going to make this external uh because you can't have public external those are going to be you know messing with each other so external is fine now what's the warning uh function State mutability can be restricted to view okay that's fine we're going to change that later okay so now what I'm going to do is I'm going to say started is equal to true and then what I need to do is pick the end at date now this is going to be a little bit weird because we haven't seen this yet but I'm going to say end at is equal to and this is going to be block Dot and then time stamp plus and then seven days now we can actually change this so that it's not days and in fact let me check if that's correct okay actually I think seven days is correct so first of all let's just explain what this line is because I haven't covered this so block is actually referring to the block that this transaction is a part of once it's been mined right so once it's been mined it will be a part of a block and the block is going to have a time stamp that's when the block was created so this is going to give us the relative timestamp of the transaction it's not going to be precisely when we sent it but it will be very close to that because blocks are created very very quickly in ethereum and then we're going to add seven days to that and days is a keyword just like ether in remix so I can or sorry not in remix but in solidity so this way we're just going to add seven days to this timestamp which means we will end seven days after this so of course feel free to modify the number of days I mean you can make this one day if you want two days whatever it doesn't really matter in fact let's just go with two days for now about whatever you set this that's going to be the amount of time the contract or sorry the what do you call it the auction will last for okay so now we have start however what I want to do is add one more require here that just makes it so we cannot start this Con contract if it's already started so I'm going to say not started like that and then I'll say already started exclamation point and what I want to do is I want to Omit an event saying that I started the contract so now we're going to talk about how we actually Implement events now creating an event is actually pretty straightforward you first need to declare an event in the body of your contract so I'm going to do it up here I'm going to say event and then start and I've just created an event now we need to Omit these events but this is an event that is omittable so what you do is you put the keyword event you then put the name of the event in this case I'm going to go with start now notice I'm starting it with a capital because the convention here is Pascal case just like our contracts and then inside of the parentheses you put any arguments you want the event to accept so you could put for example the address of the person who started the event now that wouldn't really be very useful because the only person who can start the event or sorry start the contract or start the auction is going to be the seller but you could put any other data you want here you don't need to put the time because that will automatically be associated with events whenever they're omitted but I can put any data inside of the parentheses and then I pass that data as arguments when I omit the event and that'll be like the data of the event we'll see this in a second right now for start I don't need any arguments so we won't look at that right now but when I do events for a bid I'm going to have the address of the person who bid the amount they bid Etc right okay so anyways we have an event to find which is start and now if I want to emit an event this is really straightforward I just do omit and then I put the name of the event like that okay there you go I'm now emitting the start event now if start was accepting arguments I would pass them right in here so whatever the arguments are right okay there we go pretty straightforward so now that we have that let's deploy this contract let's deploy it to a legitimate Network right so I'm going to deploy it to the go rally test Network and then I'm actually going to go look at the events of my smart contract and show you how you can view them off the blockchain on etherscan so let's do this I'm going to click deploy and then once it's finished I will let you know okay so the contract has now been deployed so I'm going to click on the contract deployment here I'm going to view this on etherscan notice it says that it was successful so what I'm going to do now is Click right on the contract so notice it says contract here it was graded so I'm going to click on that and when I go here we can see we have the hash of the transaction that created the contract then I can click on events now when I go to event notice we don't see any events now that's because we haven't triggered any yet but I'm now going to trigger an event and show you that it will show up right here okay so let's go back to remix let's now go to our contract and let's start by just clicking on some of these so we can see the seller is it started no it's not started so let's start it by clicking on start now when we do this of course we need a transaction because this is going to modify the state so I'm going to click on confirm okay this is going to take a second to complete and let's just go here and it should tell us when this is done then we can go check the corresponding event that would have been emitted okay so this is finished now so let's go back here and let's refresh the page and notice that we have an event now the event is start okay and I can click on this right here and kind of view some of the details now the method will actually be the method that we called in the transaction now this is going to be a special hash of this method I'm not really going to describe exactly how you kind of read this stuff because there is a special way to do that however whenever you're going to be subscribing to events or trying to get the data associated with an event you're not just going to be reading it from this page you're going to have a client this client's going to be using a special live library a library could be something like web3js this is a JavaScript library that kind of handles a lot of this complex lower level stuff for you and it will kind of decode this data and tell you the stuff in the event now I'm not going to show you how we subscribe to events in this tutorial because it's fairly complicated but if you were writing say a JavaScript client or something what you could do is use something like web3.js so let's do this this is the ethereum JavaScript API and inside of here you can subscribe to events so if we go to F dot subscribe this is the thing right here I'll leave a link to this in the description and you can kind of view how you would do this and how you actually get the data associated with events from a smart contract okay let's go back to remix though and let's continue all right so now that we've written the start method let's write the end method or the end function so I'm going to say function end external and inside of here I need to require a bunch of things the first thing I'm going to require is that they started the contract so I'm going to say require started because well if I haven't started it they can't end it so I'll say you need to start first exclamation point it doesn't really matter the error message that I give then I will also require that the block dot timestamp is greater than or equal to end at because I don't want to allow someone to end the auction if uh the end at time is not yet reached right because that would be unfair that means you could have someone like bid on it and then you could end it for them so that they would win it before anyone else was able to bid anyways we're going to do this we're going to say block.time stamp greater than or equal to end at I'll say auction is still ongoing is ongoing one word or two word I think it's one word uh someone can correct me in the comments clearly programming is greater than spelling anyways and then we also want to make sure that it's not already ended right so I'm going to say not ended we'll say auction already ended and let's spell already correctly okay exclamation point perfect so now that we have all of our requires what we can do is say ended is equal to true and then we want to emit an event that says we ended it now of course when we end we're going to actually have to transfer the nft to the highest beta and then we're going to transfer the funds from the contract to the uh what do you call it the seller of the nft but for now we'll just do the events so let's go up here and let's say event and let's say end now for this event I actually want to know what the highest bid was and who the highest bidder was so I know who won the auction right so I'm gonna say let's go with address and this will be I guess highest bidder okay and then we will go with uint and then this will be highest bid okay so that's for event and in fact I guess I can do this yeah that's fine we can do that inside here okay so now for end I'm going to say admit and then end and then inside of here I'm going to pass the highest bidder so let's go high it's better like that and then let's pass the highest bit perfect okay there we go now one thing I want to add to start is I just want to add a parameter here that's going to be the starting uh price or the starting bid or whatever for the auction so I'm going to say uint we'll say starting bid and what I'm going to do is after I start this or it actually it doesn't really matter where I do this but I'm going to say that the highest bid is equal to and then this is going to be the starting bit so this way you're going to have to bid at least a little bit higher than this to be able to actually win the item if you were say the only bidder that way someone doesn't list this and kind of get screwed by only having someone bid like one way or twoway or something and no one else actually bids on the nft regardless we'll have that for now and we can now test if end is going to work and then we can Implement bid and we can Implement withdraw which are the other two functions that we're going to need so let me save this now let's close this I'm going to deploy the contract again this will take a second once it's done I will be back all right so the auction is now deployed now I can start this by passing say a thousand way as the starting bid we will wait for this to go through and then we can try to end it now I will show you that when we end it this isn't going to work now the reason it's not going to work is pretty obvious but we don't have this condition being equal to True right the block.time stamp is not going to be greater than or equal to end at so it's not going to let us end this and I'll just show you that that works in a second once this starts okay so that's started let's now go to this contract uh the way I'm going to get to this is I'm going to open up metamask I'm going to go to contract creation okay let's go here let's view the contract okay it's still indexing uh Let me refresh this once it's done I'll be right back okay so now it is fully successful let me click on the contract uh let's go to events and we can see that the event start has been triggered or been emitted right because we started the contract so now let's see what happens if we try to end it so notice is going to tell us that we're probably going to get a problem here it's saying that gas estimation errored with the following message see below the transaction execution will likely fail do you want you for sending and it's saying that the error's auction is still ongoing so it's actually able to look at our smart contract and realize that we're not going to be able to do this because the block dot timestamp is uh not greater than or equal to the end at time so we can still send the transaction if we want now if we do this what's going to happen is it just gonna fail now when it fails and we hit a require statement the require statement will return whatever remaining gas we had as a part of this transaction back to us however some gas is going to be lost now that's one thing to note here with require it does actually return your gas if this fails again not all of it because it still had to use some gas but it will return whatever was in you so you can see here we're getting this error right it's telling us this didn't work and we weren't able to do that because this require statement would have been well not true right it would have you know caused an exception okay so hopefully that makes sense that is how that works now that we've done that let's start implementing the bid and the withdraw functions that we need Okay so let's code out the bid function let's go with function bid external now this needs to be payable because this is actually going to accept ethereum right so inside of here we need to require a few things we're going to require that we have started the auction if we haven't started then obviously we can't do this I'm going to say not started we're going to require that the block dot timestamp again this is a global keyword that we have access to is going to be less than the end at times this means that the contract is not ended or sorry I keep saying contract I mean auction so we'll say ended exclamation point and then we will also require that the message dot value so this is going to be the value of the bid because they're going to be sending the amount of the bid right is greater than and then this will be the current highest bit okay so now we have all of our required statements now let's see why it's getting mad at us here it's saying expected semicolon but got identifier okay I need a semicolon right there so now if this is the case what we're going to do is we're going to update the amount of money that people have sent to this contract kind of similar to the bank account by using this bids mapping and we're going to update the highest bid and the highest bidder because at this point we know this person would have bid an amount higher than the highest bid so we need to update those values right so we're going to say that the highest bid is equal to message dot value and we're going to say that the highest bidder is equal to the message dot sender okay so now after updating this since the highest bidder has now changed what I need to do is make it so the person who just got outbid is able to withdraw their money from the contract so I'm going to say if and then this is going to be the highest bidder uh so not bid but bitter does not equal the address zero now address zero is the default address I'll talk about this in a second then what I'm going to do is say that bid at and this is going to be highest bidder plus equals and then the highest bit so the logic here uh why is this yelling at me let's see what the problem is uh operate or not compatible with types un256 and address sorry this needs to be highest bid not highest bidder okay that's better but the logic here is that as soon as someone gets outbid I want to allow them to withdraw their money from the contract so that they could withdraw and then bid again right because otherwise they would need to have a ton of ethereum to be able to actually continually out bidding someone if all of their money is stored in the contract so hopefully this makes sense but since we're updating the highest bitter now if the highest bidder was not equal to address zero so essentially if this was not the first person to make a bid then what we do is we take whatever the highest bidder was store that in our bids mapping and then we add whatever their highest bid to that so that now they're able to withdraw and let's say they don't withdrawn they just continue making bids that's fine this will continue to increment however many bids they've made so then they will be able to withdraw all of that if they're not currently the highest bidder okay and actually they'll be able to withdraw whatever amount inside of there is not their current bid that's being stored in highest bit you can look through this logic and probably see why that makes sense but address zero just to clarify here is the default address so when I write something like address public for right now sorry not address public but address public highest bidder it's going to be storing just a zero filled address so I'm just making sure that it's not equal to the zero filled address and you can do that by just writing address and then putting 0 inside of here okay so that is Bid that's pretty much all we need for bid now we want to write the withdrawal function so I'm going to say function withdraw like that and then this is going to be an external payable as well and inside of here what we need to do is withdraw a certain amount or I guess we'll just withdraw the entire amount of whatever the person's bidded that's not the current bid so we're just going to start by getting the amount of money they've sent to this contract that's not currently the highest bid so I'm going to say a uint and I guess I'll just go with something like balance is going to be equal to and then this will be bids at message dot sender and then what I'm going to do is say bids at message dot sender is equal to zero just to reset that and then I'm going to send whatever their balance is to them so the way I'm going to do this is I'm going to write this complex line in fact I'm just going to copy this in because we saw this in the last video I'm going to say bull sent bytes memory data is equal to payable message.center so just converting that address to a payable address dot call Value and then this is going to be balanced balance is right here right and then what I need to do is require that this was successful so I'm going to say require sent and I'm going to say could not withdraw so let's do this could not withdraw let's add our semicolon and there we go we have just implemented the withdraw function now what I'm going to do is actually add some events here as well for bid and for withdraw then we can test this out and then we'll start actually working with an nft because right now we're not really auctioning anything so let's make some events uh let's make an event for bid now what I want to do is have an address now this is going to be indexed now we haven't seen this keyword before but what you're allowed to do whenever you're defining the arguments for your events is you can put an indexed parameter and you can actually put up to three of these and this is what you will be able to search for an event for so if I say indexed here then this means I can search by whatever this parameter is for this event in my logs right or in my events so I'm going to say address indexed let me just look at my cheat sheet to make sure I don't mess this up it's going to be sender and then we're going to say uint amount to specify how much they actually bid and then we'll do an event and this is going to be withdraw and this again will be an address that's going to be indexed this will be the bidder and then this will be you ends and the amount that they withdrew okay I think that is fine now what's it telling me what's what's it saying I did wrong here oh I spelled indexing correctly okay so let's go and let's now omit these events so I'm going to say omit and then this is going to be bid and then we're going to pass to this just the highest bidder and the highest bid okay perfect let's add our semicolon and then for withdraw we will say omit and then withdraw and then we're going to omit the message dot sender and the bounce great there we go okay so now let's actually just deploy this we can do some experiments with it I'll set up another ethereum account uh make sure it works and then we'll talk about the nfts so I'm going to deploy once it's done I will be right back okay so I am back this finished deploying my contract this year I actually started the contract with a minimum bit of a thousand way and now what I'm going to do is change my ethereum account in fact I've actually already done this so I deployed this contract from my tutorial account but now I'm on account one so now I'm going to make a bid from account one and show you how this works so I'm on account one you can see I've reconnected this here to uh what do you call it uh remix and now I'm going to make a bid of a thousand way I'm going to click on bit now when I do this notice it's going to tell me that I'm probably going to get an error the reason I'm going to get an error is because this is not greater than the starting bid and so I'm just going to cancel the transaction so I'm going to change this now to be a thousand one let's click on bid and let's see okay so confirm let's give this a second and again notice I'm not going to get any return value here it's not going to tell me if this was successful or whatever I'm just going to see that the transaction didn't fail whenever this is done and then I should see an event be emitted here okay so let's now refresh this and we now see uh hmm okay maybe we need to wait a second okay so the event has showed up I just had to wait a second I was being impatient but after I refreshed a few times it appeared here anyways this has happened successfully I know this looks like gibberish but if you're actually subscribing to this event then you would have some library that would be translating this for you so you'd be able to read the real data regardless the bid happened and I can look now at for example the highest bid which I can see is 1001 the highest bidder which is this address I can look at the seller which is different if the contract is started and all of this type of stuff now that's pretty much all I wanted to show you for that since we don't really have two days to wait here for this to finish I can't show you it actually ending what I will do though is I will now start implementing the nft stuff which is a little bit complicated uh but it's pretty cool so I'll try my best to explain it to you alright so I've just switched tabs and I'm going to try to explain to you the difference between fungible and nonfungible tokens and how these kind of live on the ethereum network so I'm sure all of you are familiar with cryptocurrencies right we have currencies like ethereum we have currencies like Bitcoin we have a ton of other currencies that are built on top of these main blockchain networks so if we're talking about coins that are built on ethereum these are tokens now really all a token is is a smart contract that defines that your address owns a certain amount of tokens now this is specific to ethereum but if you're working with a token that's on the ethereum network really what gives you the ability to own that token is that there's a smart contract with the name of that token it's named say Tim coin for example right if I had my own token on ethereum and in that contract it says that your address has 20 Tim coins where 100 Tim coins or whatever it is now the way this all gets standardized is that what happens is you need to implement specific methods or specific functions on your smart contracts that make it act like an erc20 or an ERC 721 token now erc20 is simply a protocol for a specific token in this case it's a fungible token now erc20s states that you need to Define some special methods on the smart contract now if you do that ethereum is able to look at your smart contract and treat that smart contract like a token rather than just any other smart contract now that means in your ethereum wallet you're going to see your token showing up or you'll be able to link them you'll be able to then say buy these tokens or exchange these tokens because you've defined certain functions on the token and it meets the erc20 protocol hopefully that makes sense now erc20 is simply a fungible token protocol what that means is every single one of these tokens is exactly the same so there's no difference in you owning one of the tokens or the other tokens like any token is just identical vehicle each of them has the same value and as it says here this makes erc20 tokens useful for things like medium of exchange voting rights staking whatever okay that's where you can use these tokens for however now we go over to ERC 721 now ERC 721 is fungible tokens now fungible tokens mean that these tokens are different so there could be a different value associated with each token maybe there's some assets like an image associated with a token hence nfts right maybe you get some special rights with a specific token tokens are unique they are different and they have a unique ID now this is very similar to erc20 except you're just having these unique tokens and you have some special functions now that you need to Define on Smart contracts that are defining an ERC 721 token so it's a little bit too complicated for me to show you exactly how to create your own nfts or your own erc20 tokens but the concept is again that we have this smart contract this is an example of an nft contract this smart contract defines who owns what nfts it's capable of creating new nfts and then if I wanted to say send my nft from me to you what I would do is call a function on the smart contract that transfers the nft I have to be the owner of the nft to be able to do that and then it changes the internal state of the nft contract to now Define that you own my nft because I sent it to you so hopefully this makes a tiny bit of sense but that's the general idea behind tokens and behind nfts and all of this type of stuff now as you can see here there's some other types of tokens that you can create but ERC 721 is the one we're going to work with right now and what we're actually going to accept in our smart contract that's going to be the auction is the address of a smart contract that represents an nft as well as the unique ID associated with the nft that the user wants to auction so whenever you get an nft it has a unique ID associated with it because every single ERC 721 token is unique when I say ERC 721 that really just means nonfungible token okay and so it has a unique ID if I pass that unique ID along with the contract representing that nft then what I'm able to do is verify that the user owns that nft and then actually list it in the auction and transfer it between different people okay so now let's get into some even more complicated stuff because I need to show you how we can make our own nft and when I say make our own nft I'm not talking about make your own nft contract I'm saying kind of acquire an nft in your ethereum account so you can follow along and actually auction off your own nft in this tutorial all right so to do this I'm going to go up to this other tab here where I have token.sol now I'm not going to explain any of this code but essentially this is my own Tim coin nft okay and I'm going to give you guys all the privilege of owning some Tim coin completely for free it has zero value and it's going to be on an ethereum test network but you can own it for free you are welcome and the way I'm going to do that is I'm going to deploy this smart contract I'm going to leave a link to the contract address in the description and you actually are able to create your own nft by calling this award item function which is going to give you your ethereum address a nft okay it's going to give you a special ID essentially of Tim coin I'll explain this more in depth and I'll show show you exactly how to do this but right now when you're watching this video this will be deployed on the go rally test Network so you need to make sure you're using that test Network and then what you'll be able to do is interact with this contract from remix again I'm going to show you exactly how to do that it will then award you an nft and then once you have that nft you'll be able to auction that nft inside of our test contract now before I show you how to do that we're going to implement kind of the nft logic in our contract then I'll show you how you get your own Tim coin nft again you're welcome you guys can thank me in the comments okay so what we're going to do is we're going to now specify what's known as an interface that we are going to accept for a specific contract which is going to be the contract address of the nft that we want to list so I'm going to say interface so actually there's not a ton of value of me typing this in so I'm just going to paste in the interface and I'll explain what this is so first of all an interface is an abstract data type the reason we're going to use an interface is because we need to verify that the contract passed to this auction does actually represent an nft and so we're going to treat the contract as an IRC 721 type contract which means we're going to make sure it has a transfer and a transfer from function on it now if you're unfamiliar with interfaces I can't explain them too much in depth essentially they just enforce that anything that is of type of this interface has these methods that are specified in this web so for us to have a valid nft contract really all we care about is that it has a transfer and a transfer from function that we can use now the transfer from allows us to transfer from one address to another address a specific um what do you call it nft ID okay so as I was saying before all we're doing is we're going to be calling a function on the nft contract that takes in the address of the owner of the nft the address of the receiver of the nft the nft ID it verifies we own this nft and then it would transfer it to here and then transfer is simply going to take an nft ID and transfer it to a specific address once it's been approved to do that you'll see what I mean in a second but anyways that's our interface so what we're going to do now is we're going to go inside of our auction and we're going to define the nft that we're actually going to be auctioning so I'm going to say I ERC 721 public like this nft and then what I'm going to do is I'm going to say uint public nft ID okay so what I'm saying is I want to store the contract of the nft address here it's going to be of type ierc 721 meaning it has to have these functions on it and then I'm going to have uint public not NDT nft ID which is going to be the unique ID of the nft that we want to auction so now inside of my start function what I'm going to do is take in a starting bid I'm going to take in the nft contract and the unique ID of that nft so I'm going to say IRC 7 21 this is going to be nft and we'll make this underscore nft and then we are going to say uint nft ID we'll just make this underscore again so it doesn't mirror our Global name and then comma Now let me make sure I type that correctly I think I did okay so now inside of here what we're going to do is we're going to set the nft so we're going to say n of t is equal to and then this is going to be underscore nft again this is the contract representing the nft then we're going to say nft ID is equal to underscore nft ID like that now what I'm going to do is just take these two lines here and put them after I do this just in case these return some error although it doesn't really matter because if an error was returned then the state would have been reverted but that's fine okay so we're going to do that now what we also need to do is we need to transfer this nft from the owner of the nft to this contract so now the contract owns the nft and then is able to actually transfer this to whoever wins the nft in the auction right so what I'm going to do is say nft dot transfer from and we're going to transfer from and this is going to be the message.sender who we're assuming owns the nft to this or sorry it's going to be address this like that and then this is going to be nft ID okay so this here is going to fail if we don't own the nft so if whoever called this start here doesn't own the nft then we're not going to allow them to transfer because the nft contract will raise an exception and so that whole thing will Cascade meaning all of this is going to fail as well and so we won't actually start the auction so we're only able to start the auction if we own the nft and if we have the ability to send the nft from the sender to this address okay hopefully that makes sense I'll explain again how we kind of set the nft up and how we actually make an nft and get access to it in a second so now that we have that what we need to do is deal with what happens when the auction ends because once the auction ends we need to send the nft to whoever won it and then we need to take the balance of the contract and specifically whatever the highest bid was and send that actually to ourselves right to the seller of the nft so all we're going to do here is we're going to check if V and this is going to be highest bidder does not equal the address zero because if it's equal to the address 0 that means no one actually bid on this item and so we can just return the funds or return the nft to ourself so anyways we're going to say if this is the case then that means we're going to take whatever the highest beta amount was or the highest bid sorry we're going to transfer that to ourselves and then we are going to transfer the nft to uh whoever won the nft so I'm going to say nft dot transfer and we're going to transfer it to the highest bidder I think that's all I need to put in here let me confirm that's correct oh one more thing the nft ID okay so we're using the nft contract we're using dot transfer we're going to transfer to the highest bidder and then this will be the nft ID now what it's saying is the issue it says transfer is not found well that's because I spelled transfer incorrectly okay that's fine then after that we're going to figure out whatever the highest bid was and we are going to then pay that to ourselves the seller of the nft so the way we do that is we just copy in this line because I really don't feel like writing it again so we're going to say Bool sent and then bytes memory equals data seller.call value and then this is going to be highest bid and then we'll call that like that and then we're going to require sent and we're going to say could not pay the seller okay there we go now in the other situation so if the highest bid actually is equal to address 0 then what we're going to do is just return the nft to ourselves so we're going to say nft dot transfer and then this is going to be two I guess we will just say the seller and then this will be nft ID and I think that's it again I spelled transfer incorrectly let me just make sure that's right looks good to me awesome okay so that is actually all we need for this contract now this contract should work however I need to show you how we can now actually get access to an nft and what that looks like in our account so I'm going to start by deploying this contract now be careful what account you deploy this from I'm going to deploy it from this one so I'm going to deploy uh test.soul which is really just my kind of auction contract let's confirm this okay this will take a second once that's done I'll be right back okay so that has now been deployed now remember to be able to start this auction we actually need the address of our nft so I am now going to deploy this nft contract here I'll leave the link to it in the description or you could just painfully write out all whatever the number of characters are but again it'll be linked in the description and I'll show you how you can use this to get your own nft so let me now deploy this I need to pass a string name and a symbol actually do I need to do that uh oh sorry I'm doing the wrong thing okay let's deploy Tim coin so I'm going to deploy timcoin to the go rally test Network this is going to take a second and then I will show you again how we can actually access this and get our own nft Okay so Tim coin has now been deployed now for me I can see Tim coin right here right and we see all these different methods you don't have to worry about a bunch of them but anyways you're not going to see this inside of your remix because you didn't deploy this contract but you need to interact with the contract again on the gorilli test Network you need to be on the gorilla test Network otherwise this isn't going to work for you so what you're going to do is you're going to take the contract address which will be linked in the description and you're going to paste it right here where it says or at address okay so it should say that right at the bottom you're going to do that and then it will load this contract now notice it just loaded the same contract for me to twice because I already had it here but that's how you can load again just copy it paste it in here and then it will load it right here now what you're going to want to do is you're going to want to start by setting the approval for all now I'm going to discuss what this is in a second but essentially what you need to do here is you need to allow this smart contract being the auction to actually transfer your nft now if you don't allow it to do that you're not going to be able to actually auction the nft the reason you can't auction the nft is because the contract will not have the ability to take the nft and transfer it to itself so you have to explicitly give the contract permission to do that before you create your nft so what you're going to do is go to your auction contract this is going to be different than mine you're going to copy the address of your auction contract okay I've done that I'm going to go to Tim coin I'm going to go to set approved for all I'm going to paste in my contract like this then I'm going to go comma and I'm going to go true now look here it says operator which is this so the operator is the auction contract it's going to be operating on this nft and then true now what this is going to do is it's going to allow this contract to pretty much list any of your nfts now you still have to call the contract for it to do that but you're giving it explicit permission for it to access any of the Tim coin nfts that you have access to so don't worry this doesn't mess with any other nfts you might have on your ethereum account and we're on a test Network anyway so it shouldn't matter but I'm going to press transact this should go or this should be successful once I click confirm here okay so let's wait for that to finish and then we have set the approval for all of the nfts that you own to be able to be operated by the auction contract again what you're passing here is the auction contract now it's very important that you do this first before you actually give yourself an nft otherwise the nft you give yourself will not have the approval set for it for the uh auction contract okay so now that we've done that let's close all these and we're going to go to the award item function now this is what you want to press when you want to give yourself an nft so you're going to copy your address so my address is right here I'm going to copy it in to a word item and then what it says here is that there is a URI now the token URI is actually a URL to Json metadata related to this nft so as you may have seen nfts have like fancy images and music and gifs and all of this very valuable stuff anyways the point is all of that stuff is stored off of the blockchain on a specific URL in Json data and so what you actually have to do is associate data with your nft off the blockchain so when I create the nft I pass the URL of the data sitting off the blockchain that represents my nft and then it links those two together and that's why when you go and you view nfts you see like a nice little fancy image it's because it's referencing the URI of this uh nft and then it's grabbing the image for it and displaying pretty straightforward but that's really how nfts work again I'm not it's not meant to be an entire lesson on nfts but the token URI is just that it's a URL now you actually don't need to pass anything here I'm just going to pass like one two like you have to give some data but you don't have to give a URL so I can pass one two three zero whatever doesn't matter so just go like that and when I hit transact then what's going to happen is it's actually going to give your ethereum account or whatever account you put the address for in nft so let's wait a second and then I'll show you that we actually will have Tim coin showing up in our ethereum won't okay so that finished so now if I go to metamask so let's get out of this here let's go to metamask and let's look at my account let's go to assets and notice how it says don't see your tokens import tokens so I'm going to click on import tokens and I'm going to copy in the token uh contract address of Tim coin now again that's what will be linked in the description I can just copy it from right here so I'm going to go here I'm going to go to assets import tokens I'm going to paste this in notice the symbol is Tim very fitting for the token decimal just put 0 and then add custom token and now it's showing that I have one Tim uh token so I'm going to go import tokens like that and now if I look at my assets I see one Tim coin okay it's just looking at the contract and since it follows the ERC 721 protocol it's able to specify that I have one of these now if you want to own multiple just do this again just call the contract you can even pass the same URI it really doesn't matter and hit transact and now when you do this you're just gonna have to wait a second and then your wallet should update and once this is done you'll now have two Tim coins and in fact just because this is interesting I will show you that if I go to metamask I go to my wallet here and let's go view account on etherscan you can actually view the Tim coins that you have on here so notice I can go to token and I can specify timcoin and when I go here you can see that I have the token ID of one I have one Tim coin that was just added here in one minute now if I refresh this I should have a second Tim coin in a second because I just requested that uh okay it might take a second so let's go back to where we were before okay uh word item let's refresh okay so now we should have two Tim coins if we go here yes there we go now we have Tim coins and the token ID is one and two so if you want to see what your token ID is because all of you're gonna have a different token ID you need to do what I just did go to metamask You're Gonna view your account on metamask so I went to where is that here view account on sorry not metamask on etherscan it's going to bring you to etherscan and then what you can do is go to your Tim coins I showed you how to do that but let's go back so you're just going to click here click on Tim coin and then it will show you your token ID so you own token ID one and two well in this case I own one and two you'll own something that's not one and two because it's going to be a unique ID so this means I can auction token ID one and two because I own that so now how do we auction it well this is kind of the Moment of Truth here to see if this is all going to work so I'm going to copy the address of my Tim coin uh nft contract okay then I'm going to go to start I'm going to paste that in as the first argument so let's go here for the nft ID you have to post an ID that you own so either one or two for me and then put a starting bid so I'm going to put a thousand and I'm going to hit transact like this okay fingers crossed once I hit this let's see if this works and if everything we did was successful okay so very good we see the green check mark here meaning that this was good so now let's go to nft and notice the address is this nftid is one seller is me started is true highest bid is the zero address because no one's made a bid yet and then we have highest bid now of course this will work as it would would work before as we tested it previously and this will now take how many days did we set if we go here I think we set two days yeah so after two days then you'll actually be able to win your nft when someone hits the end button or sends the end request uh to this contract okay so that is going to wrap up the video I hope this was helpful in terms of giving you a deeper understanding of solidity and smart contracts and showing you a real practical application hosted on the blockchain now in the next videos we're going to be talking about some of the scaling limitations of ethereum and of solidity and some of the problems you can run into when you need to perform large computations then I'm going to be showing you some scaling Solutions so ways that you can mitigate those concerns and we'll be talking about cartesi which again is the sponsor of this video and this series and showing you some of the solutions that they provide again I really hope that you guys have learned a lot from these videos I've been having a great time filming them well I look forward to posting more on the Channel with that said if you enjoyed make sure to leave a like subscribe to the channel and I will see you in the next one hello everybody and welcome to the fifth video in this blockchain for beginners tutorial series now in this video I'm going to be talking to you about the limitations of solidity and of smart contracts and some applications that are very difficult to deploy on the blockchain because of these limitations specifically I'll be talking to you about arrays strings for Loops while loops and why it's very expensive to use those things in a spark contract and how they can actually cause your smart contract to break or to be in a state where it can never be ran again I'll get into all of that in this video but before we dive in I do need to thank cartesi for sponsoring this video and this series as I've said many times they're an awesome company I've loved working with them through these videos they've really helped me come up with a great curriculum to teach you guys so another massive thank you to them and with that said let's go ahead and get into the video alright so I'm now on my computer and I am in remix in front of me I have a very simple smart contract and what I'm going to be doing in the first part of the video here is talking to you about arrays strings for Loops while loops and then finally structs now after we do that I'll talk about some of the limitations of solidities and expenses in using these different features and then we will talk about some potential I guess fixes or solutions for these limitations so let's begin by talking about arrays so the way you create an array in solidity is you define the type you would like to be inside of the array for all of the elements so in this case I'll say uint you put your square brackets like this if you wanted a multidimensional array you do another set of square brackets and then what you can do after this is put the name of the array or the modifier so I'm going to do something like public AR and then I can just close it off like that so there you go I've just now created a dynamically sized array in solidity so in solidity you can have both a statically sized or fixed sized array or a dynamically sized array if I do something like this where I just have square brackets with no element inside or no value inside this is dynamically sized so this means it will grow as I add more element moments to it now if I do something like 5 this is going to say this array can only have five elements inside of it and I will initialize those elements I believe all as zero all right so that's the basics for arrays now arrays are a reference type in solidity and that means that they are mutable and we can modify them once they have been created so we have direct index access we can access the length of elements or the length of the array story and again we can push elements inside okay so let's just deploy the contract right now and have a look at how we actually access the elements in this array so I'm going to deploy this when I go here notice I'm going to have ARR and then I can pass the index of the element that I want to access now raise our zero indexed so if I do something like ARR and 0 it's going to give me the value 0 because since we statically initialize this array we're going to have one element with value zero or sorry five elements with value zero inside of the array now let's access index one okay we get zero again let's do index four zero again let's do five and then notice here that we actually are going to get a revert the transaction has been reverted to the initial State and that's because an error would have occurred because we're accessing an index that is out of the bounds of this array perfect so now that we have done that let's look at how we can actually I guess modify the elements of this array so let's create a function let's say function I'm just going to say mod ARR standing for modify array we will make this a public function and we're not going to return anything we'll just actually modify this okay now inside of here I'm just going to take in a uint X and A uint uh idx and instead of X let's actually just go with value just so this is a little bit more clear now essentially what this is going to do is change the element at index to be equal to Value so let's just say AR at index let's go idx is equal to Val notice we're not getting any errors so this should be good to go okay so let's deploy the contract let's go here we're going to look at index 0 . see that that has value zero now let's change this so let's pass to here a value of say 10 and an index of zero let's transact looks like that's all good now when we look here notice we have a value of 10. very basic that's how you can modify this array now what I want to do is create a dynamically sized array so let's simply change this by removing the five and now when we do mod array we're just going to take in a value and I'll show you how we can append this value or push it to the array pretty straightforward but you can use the dot push method so I can say AR dot push I can push the value which is uint and now this should be good so let's try this let's deploy the contract let me just delete this one here okay now we have mod array that takes it a value so let's just pass one let's pass two and let's pass three now let's look at index zero index zero is one index one is two and index two is three perfect there we go we just pushed elements into the array all right great so now that we've done that let me show you how we get the length of the array so I'm just going to say function get length we'll make this an external and then this can be a view function that returns and then we'll just put U ins like that and then inside of here I can simply return error dot length like that okay so this will give us the length you can just use the dot length property so let's now deploy this contract let's go deploy let's mod the array by adding one two and three now let's get the length and notice we have a length of three now let's add another element let's add four get length we're at four there you go that pretty much covers a race I don't think there's actually anything more to go through with the raise one thing you you can do is access individual elements using the index notation so I can do something like array at 0 is equal to one that's perfectly valid or I can just do array at zero that works as well as you saw previously uh last thing I will mention is that if you want to actually Define the literal for the array so you want to do something like this use square brackets so say uint public ARR and then one two three this is different than something like I guess C plus plus or Java where you would use uh squiggly brackets at least I think you use those in those languages anyways in slowly to use square brackets I to define the elements in the array perfect hopefully that is clear that pretty much covers a race okay so now that we have gone through a raise I want to cover strings so let's get rid of all of this now strings and solidity are very expensive to work with and same thing with a race arrays are very expensive as well and in fact the reason I'm showing them to you last is because mappings are much preferred over a Race So you pretty much never want to be using a raise or using strings if you can avoid doing so there is some use cases where you do need them but essentially you always want to go with something like a mapping as opposed to an array I won't get into all of the details but just understand that they cost a lot more gas than something like a mapping so if you can avoid it avoid using arrays and if you want to mess around with kind of the differences in arrays and mappings deploy a few contracts and look at the actual gas cost in terms of working with arrays versus working with mappings and same thing with strings strings are extremely expensive to use in solidity and one of the reasons for that is that a string in solidity is actually a bytes array so you can create a byte array like this now bytes are used for kind of a raw data type and a string and solidity essentially is a bytes array that's going to be decoded and encoded with utf8 just allowing you to actually view the string so let me show you what I mean if I do something like string and I guess we can put public although we don't really need to and we'll expect this equal to a hello we can say this is equal to world that is completely valid now you want to again avoid using strings whenever you possibly can because they're very expensive to work with same reason with the arrays because they are actually represented by 8 bytes array now strings and solidity are extremely simple you do not have index access to them you cannot concatenate them you can't get the length of them there's actually almost no methods or properties for Strings you literally can just store a literal string and in most situations it's going to be much more efficient especially if you're working with large strings to store them off of the blockchain and simply store a hash of that string in the storage of your contract that will be much much cheaper than actually storing the string itself in the contract anyways let's deploy the contract here with the string notice that I can access this and I can have World threat I can see World there so let's create another function let's go function set stream ring and let's go string and then let's go with value now I'm not quite done with this yet I need to uh talk about something with having strings inside of functions but for now I will say hello is equal to Bell okay so notice that I'm getting an error here now why am I getting an error this function actually looks pretty valid right I have my string parameter I have this public I'm setting a value this should be good the reason why I'm getting an error here we can hover over this is because the data location must be memory or call data for a parameter so this is where I'm going to talk about the different storage locations that you have in your contract so in your contract you have state or storage they're kind of the same things storage State now that essentially means that you're persistently going to be storing this data in the smart contract itself now any data you store is going to cost you small amounts of ethereum right it's going to be more expensive to store more data than to store less you want to store the least amount of stuff that you possibly can so that's the first location storage state that's persistent it's always going to be there the other location is memory now memory similar to your computer's Ram is a temporary location that's only going to be used when the contract is actually executing so when I'm using a reference type like a string I need to specify it's going to be stored in memory so I'm going to say memory like this so as soon as I put memory we actually would have seen this before I think now this is valid because it's saying I want to store this parameter in memory as opposed to in the state or storage of the contract and you only need to specify this for reference data types so same thing with arrays let's say I did something like UNS and then I wanted to have my uh value like this I would need to now specify memory to not get yelled at by the compiler okay so let's go back though to what we had before string memory value low equals Bell let's deploy this let's look at this let's go hello world I am Tim let's set the string let's look at a low and now we have hello world I am 10. awesome again avoid using strings if you need to use a large string what you want to do is store it off the blockchain and simply store a hash of that string on the blockchain that will be much cheaper okay so now we've gone through a raise we have gone through strings I want to show you looping and then I will show you the gas costs associated with a lot of these different features I'm just trying to give you kind of the basics right now okay so let us um should we Loop through an array no let's just uh loop over kind of a range of numbers to start so I'm just going to say function and I will say Loop and I'm going to take in U and n and all I'm going to do here is simply Loop Over N numbers so to do a for Loop in solidity is similar to pretty much every other programming language you can say four and then you can Define your looping variable so I'm going to say U and I I'm going to say I is less than n and then I'm going to say I plus plus okay so I'm just incrementing I by 1 in every iteration and then what I'm going to do here is I guess we can just add to some variable or something because I'm just trying to illustrate Luke so I'll do something like uint sum is equal to zero and then sum plus equals I and I think that should be good and then if we wanted to we could return the sum but this is fine we'll just do this for now so I just had to take a quick cut there because my cat was freaking out at me for some reason anyways that is now resolved but continuing here uh we're getting a warning the reason we're getting a warning is because this can be restricted to Pure the reason for that is because we're not actually modifying or accessing the state of the contract so I just want to put pure like this anyways this is how you do a for Loop uh now I will mention that the for Loops again are going to be very very expensive to run if you're not doing them in something like a pure function right in a pure function or something that doesn't require a transaction it's not going to cost you ethereum to run this however it's going to be very expensive to implement for Loops when you're actually working with the state of the con contract now the reason for that is whenever you do a transaction you need to pass gas along with that transaction right and the gas cost is the sum of all the operations that the contract is doing so in this case it's going to cost me gas to actually add a number to another number right for me to add two numbers that cost gas but here in this situation the amount of gas this would cost if it wasn't a pure function is n multiplied by all of the gas used inside of the for Loop now that might not seem like a lot but if an N is a large number say like a thousand or ten thousand and the amount of gas in here is four gas 20 gas 100 gas something along those lines you can see how the amount of gas required adds up very very quickly and it becomes unfeasible to actually be able to Loop inside of smart contracts and in fact there's actually a maximum amount of gas that you can pass to an ethereum smart contract I believe right now it's at 30 million gas in fact I think that's right here it's the gas limit that's showing up regardless you can only pass so much gas so if your smart con contract needs to do a ton of computations you have to have multiple transactions to be able to complete that because you need to pass the required gas and you can only do a certain amount of gas in each transaction anyways that was kind of it for for Loops I just want to show you the syntax this is the basics of for Loops now I will show you while loops so let's do a very similar thing here let's just manually declare I so U and I is equal to zero we'll say well I is less than n we'll say I plus plus we can do that at the end and then we'll say sum plus equals I like that perfect there you go this is a while loop again not really going to explain this I'm sure most of you understand how this works anyways those are for loops and while loops and now that we've looked at those I want to write a very simple smart contract that's going to work with arrays and for Loops or while loops and show you how much gas it actually costs on an ethereum test Network so let's start by just initializing an array here and let's just say you ends and let's go ARR and let's just make this equal I guess actually I can just Define it like that uint AR that's fine for now then I'm going to have a function I'm going to say function create AR I'm going to say U and n and I will go with string value and I'm actually going to change the type of this array to be a string array and show you how expensive this gets okay now I will make this public now what I want to do here is essentially initialize this array with n elements that are equal to this string value now I need to remember to add my memory keyword otherwise it's going to get mad okay so let's do this so what I'm going to do is write a for Loop I'm going to say four again this will be i i u and I this is going to be I is less than n let's add a space here and then I plus plus okay now what we'll do is say ARR dot push and we're going to push the value like so okay so right now we can technically run this infinite number of times and I'll show you what happens if we try to do that but I want to deploy this to our injected web3 to the go rally test Network so it says custom Network right now let me just go to my metamask and change this to go rally and then we will deploy this and test it alright so we are back on go rally I'm going to deploy let's see how much this is going to cost us right now okay so not a significant amount of gas because obviously we haven't done any computation yet in the contract and then once this is deployed we'll actually try running this method and see how much gas it cost us alright so it looks as though the contract has been deployed we can see it down here it says create AR now let's just see again this is going to be kind of antidotal I'll just go through a few uh examples here how much it costs to do one that has 10 elements and the string hello world now I need to quote the string here so let's do that and let's transact and see approximately how much this costs us so when I do this notice we're getting 0.006876 okay so we can kind of copy that and keep that in mind and then I'll show you how this is gonna I guess not exponentially but go up a lot as I increase the value of n so let's now do one that has a thousand elements and see how much this costs so when I do transact now we're going to see that now we're at 0.05 now if you actually put that into the price of ethereum 0.05 ethereum is a lot now I'm not sure if it would be the exact same on the regular ethereum network but the point is you saw how we drastically increase this to a whole decimal point right just by making this a thousand instead of say 10. and then let's go crazy and let's make this something like a hundred thousand and transact and see how much this would cost and here it tells me we actually cannot even send this amount of gas the transaction will likely fail so let's go to ten thousand and see if 10 000 is a doable same thing we can't even do ten thousand let's try doing something like 5000 and see if that's gonna work okay 5000 doesn't work let's try 25 000 transact okay that's not gonna work so just trying to show you here that we really cannot do a lot of looping operations and even if we try to do a lot of looping operations that is going to be very very expensive to the point where it really doesn't make sense to do them inside of the smart contract all right so now that we've gone through those few examples just so you can see kind of in the real world how much the gas is going to cost let me delete all of this and show you that remix can actually give us a gas estimate for specific functions so what I can do is something like let's go uint X is equal to zero and let's go function set X let's take in a uint value let's just make this public and then what we can do is say x is equal to Value okay so this is my function very very simple all we're doing is assigning a variable now if I hover over the function name notice that down here kind of in the right corner or I guess not really corner but right on the console bar it's showing us the execution is going to be 22 498 gas so that's a significant amount of gas considering we're only doing a very simple operation all right so now that we've seen that let's just do a few more examples and estimate some more gas costs so another thing we might want to do is evaluate a condition maybe we want to use a require statement or something like that so let's just do something like require and we'll say Val is greater than and let's just go with 10 and we'll say Val is too low okay put our semicolon let's see how much gas it's telling us now so if I hover over here now you can see the gas has increased a small amount so the require statement doesn't really use that much gas right now let's see what happens if we try to add a number so let's do something like X plus equals Val multiplied by 10 and let's look at the gas estimate now and nose is giving us infinite gas now whenever you're seeing infinite gas that usually means a remix is not able to estimate how much this is going to cost now in this case uh the reason saying infinite is because Val can be any single number now if Val is any number greater than 10 when I multiply this by 10 remix has no idea how much this computation is going to cost because the larger value is then you know the more that this is going to be the more gas this is going to cost because the more addition operations we need to do essentially whenever you're doing multiplication you're really doing repeated addition and while the more repeated addition the more gas this costs so infinite gas is just telling you it could theoretically be anything and you really want to try to limit these functions so that they cannot cost infinite gas because if they cost infinite gas you could do a transaction that will never be able to run because you can't pass enough gas to actually be able to execute it all right hopefully that makes a bit of sense I just want to give you a quick example of the gas costs and how quickly they go up using smart contracts now I will talk to you about structs and then we'll talk about some programs that are really limited on the blockchain because of the fact that we can't really do any looping or at least not very efficiently alright so to illustrate structs to you I first want to start by showing the alternative to structs which would be actually representing objects using contracts now contracts just like classes can be instantiated so I can have different instances of the contract now typically we just deploy a single contract but this contract can instantiate another contract and then have a reference to them so for example I can do something like this I can have contract person I can have you and age string name you and balance I can have a Constructor and I can treat this just like I would any other class and say jump right now from this tutorial class what I might do is create a function like this I might say function create and then person and then maybe I take in my uint age and then my string memory name like that and then the balance we would just imagine would be uh implemented at another time okay then I'm going to say public and then inside of here what I can do is actually create an instance of this person class so I would say person person equals new person and then I would just pass my Constructor values so uh this needs to be a string sorry age and name okay there we go I've just created a person instance now this is an instance of this contract now this looks perfectly fine however this is going to cost you a ton of gas because contracts are much more expensive to work with than structs so instead what you would want to do is replace this contract with the struct now the struct would look something like this uh let's do this struct and then we can remove the Constructor and just do the font now there's a few other changes I need to make here so when I'm working with a struct first of all I no longer need the new keyword and I also need to pass a balance right so I'm going to pass the balance zero the reason I need the balance is because this is a required field in the struct I'm storing an age a name and a balance and if I initialize my struct in this way then I need to pass all of these fields I'll show you another way to initialize it in a second now we're getting an error the error is that I need to specify the location for this type the reason for that is this is a reference data type meaning it's mutable so I can change it later on so I need to specify memory here just like for my strings now when I do this notice it's all good now it's telling me I can make this a pure function I believe yeah because I'm not actually working with the state of the contract this is just an example to illustrate the struct now I'm getting a warning here just saying that this can be a pure function because uh what do you call we're not dealing with the state of the contract anyways this is what you want to do if you want to store like custom data essentially in a custom type create a struct rather than creating a contract so now to really uh kind of show the use case of a struct we'll write a very simple contract that's going to allow us to associate an address with a person so what I'm going to do is put a mapping up here and I'm going to map and address to a person like that totally fine for me to do that and I will just call this people so now when I create my person I will add them into the uh the people map so what I'll do after I make my person is I'll say people at and then this is going to be the address so message dot sender is equal to person like that and then of course I would adjust the balance if money was sent into this contract so now that we've seen this I'll just show you another way of initializing this person because we don't have to do it in this way so I can actually remove kind of the literal I guess written person and just say person memory person like that and now I can just specify the attributes on this person so I can say person.age is equal to age I can say person dot name is equal to name and then if I don't do anything for the balance that's completely fine because the balance will be initialized as zero anyways that's another way that you can initialize a struct just wanted to show you you can do it in this way or you can actually write out kind of I guess the main initialization or the Constructor initialization where you pass in those values anyways that is pretty much all I had for this first section here I showed you the gas costs associated with looping and how looping is really a big problem in smart contracts and is unfeasible especially if you're doing a large amount of computations I also showed you that storing strings and bytes is very expensive and you don't want to do that lastly I talked about structs here and how if you want to represent kind of a custom object or a custom type it's much cheaper and better practice to use a struct rather than to use a separate contract right which would kind of act as a class you don't really want to be doing that in solidity there are some use cases but if we're going to be creating a ton of different people like this we definitely don't want to be using a separate contract now what I would like to do is really focus more on the limitations of solidity based on some of these things you just saw and talk about how we would Implement something like an order book in solidity now an order book is essentially what to use when you're trading stocks you're trading assets of some sort you want to have buy orders and sell orders and match the buy and the the sell orders now in cryptocurrency you definitely need this need a way to exchange your different coins buy coins sell coins whatever it may be so I'm going to hop over to the Blackboard now or the drawing tablet and start talking to you about how we would Implement order book in solidity a lot of the problems that we're going to run into doing that and then some of the solutions we may have to actually make this more feasy alright so I'm here on my drawing tablet I want to begin by explaining to you what an order book is so an order book is essentially used whenever you're trying to trade something so in this situation let's say we're talking about US Dollars and then something like ethereum now in order book just really States the buy and the sell orders for this specific asset so in this case with US Dollars we would be buying ethereums these would be our buy orders and then on the other side we would have sell orders now whenever we want to actually make a trade we need to match buy and sell orders together based on the price so when I put in a buy order I need to specify the price that I want to purchase ethereum at now what I would do is something like one ethereum and then I want to buy this at maybe 4K right that's the price that I'm willing to buy this at I put that buy order into the book now maybe someone wants to sell ethereum maybe they're selling one ethereum and maybe they want to sell it at like 4.4 000. well if this is the case we cannot match these two orders together because they have different prices now you can probably realize just by looking at this it's going to be very difficult to actually match buy and sell orders because the probability that two people are going to have the exact same price in mind for this specific asset well that's just very rare you know the seller is always going to want to sell High the buyer is always going to want to buy low so because of this situation we can use multiple buy orders or multiple sell orders to fill either order right so maybe I have a ton of small bios something like 0.1 ethereum well if all of these small orders allow me to actually fill one large cell order then I would use you know all let's say 10 of these to fill this one ethereum order now of course they have to be at the same price and so we end up running into the same problem again now this is where we talk about something called market makers so I'm going to draw this right here Market make now a market maker essentially provides liquidity to this trading pair or to this order book Because as I was saying it's gonna be very rare to have our buyers and sellers agreeing on a price so the market maker is actually a neutral entity that's always willing to buy and always willing to sell now they have incentives to do this they will earn some rewards some fees whatever it may be but the idea is they're always buying and they're always selling and this allows liquidity in this market they make the market it allows me at any point in time to go and buy my ethereum or sell the ethereum now the market maker is pretty well dictating the price of this asset based on the pressure to buy and the pressure to sell now I don't want to get more into this because it's a bit beyond my scope of knowledge and finance and all of that that's the basics of an order book and now we'll talk about how you would Implement something like that on the blockchain so of course an order book is pretty important especially when we're talking about cryptocurrency people want to buy and people want to sell so let's draw out another order book right here and I'll talk about how we would actually kind of do this algorithmically because of course although this was done manually in the old days we now have computers that do this for us and they can do it very very quickly and efficiently so let's say we have a bunch of buy orders over here in green we have a bunch of cell orders here in red well the first thing that we should realize is that since we're going to implement this as a smart contract if someone is going to be making say a large sell order maybe a one ethereum or maybe a lot more than one ethereum they're going to have to use uh usually multiple buy orders to fill this cell order so they may have to actually Loop maybe 20 30 40 maybe 500 times to actually fill their order and as we saw previously looping is very very expensive and so the more looping we have to do the more it's going to cost whoever is performing the transaction now we also may run into a problem where someone needs to Loop more times than that is allowed in the smart contract based on the gas limit let's say I want to make a sell order of maybe a hundred ethereum well the chances that someone else is going to be buying 100 ethereum is Slim maybe there's a ton of people buying a small amount of ethereum so I might have to Loop say 2 000 times now if the maximum number of Loops I can do in one iteration of my smart contractor one calls or in my smart contract is a hundred then I'm gonna have to split this into two separate orders to be able to actually make this sell right I'm gonna have to do two 50th cells because I can only do a thousand Loops in one smart contract transaction so that's kind of the main problem we're going to run into here and it really just has to do with the ability of looping with the smart contract now this is kind of a naive perspective because this assumes that everyone interacting with this contract is interacting with good intentions they are a good actor everyone wants to buy everyone wants to sell they're not trying to manipulate the market but of course people are always going to try to manipulate the market and one way they could do that with something like this is they could put in a ton of tiny buy orders so let's say we have some buyer who's really trying to kind of lag the smart contract and make it take a very long time or be very expensive to interact with well the way they would do this is they would put in a ton of fractional kind of bogus buy orders and they would do this many many times let's say maybe they have a thousand of these orders realistically it would be way more than that but they have a ton of these orders that they're adding they're all very small bios well now even if I want to make a relatively small sell order of say one ethereum I have to Loop thousands of times in this case probably hundreds of thousands of times to actually be able to fill this order because there's so many small buy orders so now again that requires me as the seller to split this into very very small amounts to be selling so maybe I have to sell this amount at a time because I just cannot do enough Loops in my smart contract transaction so that's kind of a main problem that can arise here you can have people try to manipulate the market and when someone does this if we're not handling this correctly it's going to cause the seller practically to not be able to sell because it's going to take them so long and it's going to cost them a lot of money to do that so the way that we deincentivize this type of behavior is we put the burden of looping on the buyer now the seller is still going to have to Loop to fill their order but we try to make it so that less small buy orders come in by kind of penalizing those so for example if we want to purchase one ethereum what we do as the seller is we Loop through buy orders hopefully in efficient manner and we Mark all of the orders that we require to fill this cell order as executed now when we mark them as executed that essentially means that we've made the trade so we immediately take all of the USD funds we give those to the seller but then we lock this asset in the smart contract and we require that the buyer do as many transactions as they originally did to buy to be able to take their stock back so what I mean by that is if they did a thousand of these tiny little transactions they need to do a thousand more transactions to retrieve all of those funds from the smart contract so for example if they want to take whatever it is they bought for you know 0.0001 USD or after whatever it's going to be then they need to do one transaction and that will give them whatever the amount of stock that was traded in this specific trade hopefully that's making a bit of sense but they will take this amount of ethereum they'll get that from this one transaction then they have to do this a thousand more times because they had so many orders so for every order they need to do one transaction to retrieve all of the funds that were traded in that specific order so this now puts the burden of looping on the buyer and hopefully deincentivizes them from doing this now of course we still have this underlying problem that the seller needs to do looping to be able to actually fill their sell order so we need to come up with an efficient way to do this and that's what I want to talk to you about now as we head over to the other screen so to reiterate here the main problem that we're running into is that we're requiring a ton of Loops to be able to perform buy and sell orders and even if we Implement that previous solution we talked about the seller still needs to determine which buy orders to match with to be able to make the sale right and then we have to mark orders as executed we have to store these orders somewhere how do we do all of that that's really the question right now and how do we do it in an efficient manner because we can't have nested for Loops we can't have any crazy algorithms that are taking really long time to run that's just not feasible on the blockchain and with smart contracts now solution one is really the approach that has to be done on the blockchain and this this is to come up with the most efficient data structures and algorithms possible to implement what we just talked about we need probably an advanced type of tree that's going to allow us to look for the largest possible orders to fill the largest cell orders so we only use four five six orders and require a very little amount of looping to be able to make a sale now of course the same thing happens on the buy side the idea though is that we need to do all of this efficiently and again we need to manage our storage efficiently as well because it's expensive to store orders on the blockchain so solution one is essentially be a genius and come up with a great data structure and algorithm that has no bugs has no problems is never going to be inefficient and use that now of course that's not really the most reasonable approach ask me to implement order book I have no idea where to even start that's going to be very complicated I'm gonna have to do a ton of research hopefully I'm going to find someone who's done something like this before and kind of copy what they have but even then again this is just really an impractical approach for most people trying to implement something like this and even if you do come up with an implementation the first approach is most likely going to be buggy it's going to be inefficient and it's probably going to be infeasible to use so then solution 2 is essentially kind of similar to solution one copy someone else who's already done this hope that there's some genius out there who's written a great order book just take the exact same order book maybe modify it a little bit if you were trying to make your own and use that now again that's really still not a great approach you can still have a lot of inefficiencies and you still might have to Loop a ton of times to be able to fill a buy or sell order now the third solution is kind of more of an abstract one but this would be to use something off the blockchain maybe like a SQL database that's already very efficient at searching for specific orders maybe you write some Advanced select query that can kind of give this information to you and then you store hashes of this on the blockchain whatever it's going to be unfortunately interacting with SQL from the blockchain isn't really possible right now at least I don't know how to do that and so that kind of limits that option as well so even with the only feasible option which is essentially have a really good data structure and algorithm you're still running into problems now you might be asking yourself at this point in time well how is this done then how do people do this if this is such a problem now you can still use an order book it's just not going to be the most efficient thing in the world but what a lot of platforms are doing now is using something called a liquidity pool now liquidity pool has its own issues I'm not going to talk about those in this video essentially liquidity pool is just a store of a ton of the assets that you're going to be trading so you have whatever asset one is an asset to you have usually an equal amount of them in the pool and then based on the demand for the specific assets the price of those assets will fluctuate within the liquidity pool and the people providing liquidity so putting their assets into the pool will be given a type of reward kind of like a fee that you would pay when you're actually trading them right anyways that's liquid equal again has its own issues but that's kind of an approach that's being used currently and really with that said I think I'm going to wrap up the video here now I know I didn't talk too much about the solutions but that's because this this video is really focused on the limitations of the blockchain and showing you that a lot of stuff we would like to be able to create that would be way simpler to do off the blockchain we just can't feasibly do using spark contracts and on the blockchain because of those limitations now even the stuff I showed you at the beginning of the video strings arrays for Loops while Loops those are very inefficient to use they cost a lot of money and the reason we left them until the very end was because we don't really want to encourage their use and I want to make sure that you understand kind of the problems with them and that they do exist you can use them but you should be very careful when you're implementing those specific features alright so with that said I am going to end the video here another massive thank you to cartesi for sponsoring this video and this series in the next video we'll be looking at specific Solutions and how we can actually write scalable smart contracts and decentralized applications I hope you guys enjoyed if you did make sure to leave a like subscribe to the channel and I will see you in another one hello everybody and welcome to the sixth and final video in this blockchain for beginners tutorial Series in this video I'm going to talk to you about ethereum scaling Solutions specifically Solutions on layer 1 and on layer 2. and of course I'll describe what layer 1 and layer 2 meet now the reason we need ethereum scaling Solutions is because as you've seen through this series ethereum can be quite slow and the number of transactions that it can handle per second is very very small now this means it takes a really long time for us to actually submit a transaction to the blockchain and have that processed and validated and if we want to be using a smart contract to perform computations that can take a really long time as well or be infeasible based on the amount of say iterations we need to do within a for Loop or something along those lines so there's tons of reasons why we need better scalability on ethereum and fortunately there's many different solutions so with that said we'll go ahead and get into the video but I do want to thank cartesi for sponsoring this video and this series they're an awesome company that have been helping me come up with all of the content for this series and they're actually working on a bunch of layer 2 blockchain Solutions right now and trying to make the blockchain more accessible and scalable for developers so definitely check them out from the link in the description they have a ton of detailed articles on a lot of the stuff I'm going to go over in this video and I do just want to quickly mention here in the intro that this is going to be very high level I'm not going to get into a ton of technical explanations about these different solutions I just want to give you an introduction to them and then encourage you to research and learn more anyways let's start talking about the difference between layer 1 and layer 2 Solutions so in blockchain world and in this video you're going to see the terms layer 1 and layer 2 a lot now layer 1 is referring to the blockchain network itself so the actual ethereum main Network and layer 2 is referring to stuff built on top of that Network so when we talk about increasing the scalability of ethereum when we're referring to layer 1 we're talking about actually modifying the underlying blockchain technology so changing the architecture increasing the block size decreasing the block size whatever the solution is going to be it's going to be right on ethereum and that's something that we can't really directly modify ourself the people that are working on ethereum would have to actually change then we have layer two layer 2 is referring to Solutions we build on top of the blockchain so we're not touching layer one we're not modifying the ethereum network we're doing stuff on top of this to increase the scalability so of course I'll get into those different solutions but again on layer 2 we're relying on layer 1 to give us the security and aspects of the blockchain but we're not actually going to be modifying that underlying technology and that underlying architecture hopefully that is clear now what I want to do is talk to you about something known as the scalability trilemma which has to do with the different aspects of a blockchain that we want to have and that we need to consider when we're picking different blockchain solutions so the scale ability trilemma is essentially a triangle I'll put a photo up on the screen where each Vertex or point is one of the properties or aspects of a blockchain that we'd like to have so here we have security decentralization and scalability now broadly speaking what this says is that whenever we Implement a solution we end up lacking in one of the areas of this triangle so one of these points for example if we Implement a solution that has great security and great decentralization typically we're going to have a worse scalability where if we Implement something with great scalability and great security we may have worse decentralization now this is not always the case there is some solutions that are great in all three of these areas but this is something that we want to think about when we're actually talking about different blockchain solutions so does this increase decentralization does it decrease decentralization what are the pros and the cons and the tradeoffs as it relates to the scalability trilemma now before we go any further I do really want to Define scalability as well as security and decentralized just to make sure we know those terms so when we're talking about scalability the common thing to refer to as it relates to blockchains is transactions per second or transaction throughput now that is one of the areas of scalability that we're concerned with we're also concerned with data scalability as well as computation scalability so when we're building smart contracts one of the big issues there was we don't want to store a ton of data and we can't do too many computations in the smart contract because of the cost on the ethereum network and the time it takes to actually process those so keep that in mind as we go through this video it's not just a number of transactions it's also computations and data on the blockchain now as we go to decentralization that's really referring to the centralization of power or in this case the lack of centralization of power so the example I always like to use is a bank a bank is an example of a central institution or organization they have you know a few Executives or a few board members that really control what the bank can do they have investors they have government interests whatever it's very very centralized the people that use a bank don't control what the bank is able to do and what control they have of your money it's the bank itself very Central that controls all of them so hopefully that makes a bit of sense now when we talk about blockchain we want everything to be decentralized so there's not one person one institution or maybe a few people or few institutions that have control over the network ideally we want millions of computers or thousands of computers around the world to be running and securing this network so we're less prone to hacks less prone to corruption and all those other things that can happen when you have Central Power and Central you know authority of something so hopefully that makes a little bit of sense then we're talking about security this is pretty straightforward but how secure is the network how easy is it to be hacked how uh sure can we be that this transaction is valid when it's posted on The blockchain Ledger all of those types of things relate to security alright so that is the scalability trilemma keep this in mind as we go through the rest of this video now I'm going to start talking to you about layer 1 Solutions now I'm not going to spend too much time here because we don't have much control over layer 1 Solutions we can't really build a layer 1 solution because we don't have control of the ethereum network regardless though I will talk about why we would want a layer 1 solution so why would we actually want to improve ethereum well as I'm sure many of you are aware ethereum is relatively slow so when we're talking about scalability it only does about 15 transactions per second and in contrast to something like Visa that can do upwards of about 60 000 that's really really slow and that makes it infeasible for a ton of different applications especially something like being the Global Currency right if we wanted everyone to be using ethereum for their daytoday transactions well that would take a really long time because we would have to be waiting hours maybe even days for a transaction to go through because we can only do 15 per second now in terms of computations as well we've seen when we were working with smart contracts we're really Limited in what computations we can do we probably can't Implement any advanced data structures and algorithms we can't store too much information and we can't do too many iterations without it costing us a ton of money on the blockchain so that is kind of the reason we would want to improve ethereum because of those lack of scalability issues now ethereum is very decentralized and is very secure so we're not super concerned with those two aspects we just really want the scalability to increase without hurting the decentralization and hurting the security anyways let's talk about the layer 1 Solutions So currently ethereum is actually working on a layer 1 solution which they're calling ethereum 2.0 this is going to be a complete change to the architecture and the algorithm used for ethereum so I'm sure many of you have heard of this before they've been working on it for a really long time and it should be out relatively soon but they're going to be changing from proof of work to proof of stick now I'm not going to discuss the differences here or get into kind of a debate about which is better but that is what they're doing they're changing the main algorithm for improve of work to proof of stake and ideally they're going to be bringing the transaction throughput from about 15 transactions per second to upwards of a hundred thousand transactions per second now I cannot confirm this these are just the rumors and what I've heard online line and seen when looking at the project anyways that is kind of what they're doing now in ethereum 2.0 they're doing a few other things one of the main things that they're adding is something called sharding so sharding is really this process of taking a large piece of data and splitting it horizontally into smaller pieces of data which can be handled by multiple computers at the exact same time so to put this simply imagine I have one piece of data and this piece of data can only be processed by one computer at a time what's going to be slower to process that data than if I split this data into say 64 chunks or 120 chunks or whatever the number of chunks is going to be and allow 120 computers 2 000 computers whatever the number is to process these smaller pieces of data at the exact same time so that's exactly what ethereum is aiming to do take the large piece of data split it into multiple smaller pieces of data and then allow for parallel processing and to drastically increase the number of transactions per second in fact this is a similar thing that many large companies do in many large databases do to increase the efficiency or increase the scalability of their systems so this is not just something that's done in blockchain this is done generally in computer science and I would encourage you to read more about it and look it up if you're interested in exactly how sharding works so with that said that's going to wrap up our layer 1 Solutions now I'm going to talk about the layer 2 Solutions so as reminder layer 2 Solutions are simply Solutions built on top of ethereum so they rely on the ethereum network and they do not modify it and they aim to increase the scalability while again still keeping the decentralization and security aspect so that said let's talk about some different layer 2 Solutions now the solutions that we have are things like State channels side chains and then RollUps now I'm actually going to start with side chains so I probably should list it in the other order what a side chain is is essentially another blockchain Network that has a different architecture than the ethereum network and makes it better for scalability so what a side chain actually does is it links to the ethereum area main Network it makes it very easy to transfer assets between the two different chains now typically side chains are going to be much smaller they're going to have less validators they may have smaller block sizes and this does actually decrease the security and the decentralization of the side chain but it drastically increases the scalability because now rather than me sending a transaction to ethereum I'm going to send it to a side chain and then the side chain can kind of link up with the ethereum main Network and allow me to transfer the assets between the two networks very very quickly or very easily at minimum so an example of a side chain would be something like polygon I'll put up an image on the screen these are controversial and there's a lot of reasons why you may not want to use a sidechain but again the basic reasoning here is rather than using the ethereum network we're going to use it completely entirely different blockchain network that's going to be somewhat linked to the ethereum main Network which allows us to take the smart contracts running on the side chain and very easily Port them over to the ethereum main Network while still Main containing all of the data all of the assets and all of the information essentially that was posted to the sign chain Network hopefully that makes a bit of sense but those are side chains so the next solution that I'm going to introduce to you is something known as state channels now I just want to emphasize before doing that again I'm bringing this to you at a very very high level there's a lot of details and Nuance with all of these Solutions and you really should do some research and look at these more before actually trying to implement them or use them for your decentralized applications so please keep that in mind this is a very very general introduction anyways state champs to explain the usefulness of State channels I want to introduce to you a problem of making a decentralized application so if we wanted to make a decentralized app we want this to be some type of game maybe a game like chess right well this game requires many state changes now we know when we make a decentralized application we're going to have a smart contract the smart contract handles the state of our application if we're talking about Chess and we need to store the state of the board so if we want to play a game of chess on the ethereum network what we would have to do is send transactions to the smart contract to update the state after every single move was played now at least in the chess games that I play they're like five minutes long we're three minutes long and we make moves every few seconds right so I make a move my opponent makes a move and every time that would happen if we're running this on ethereum we would need to submit a transaction to the network however the next player can't make a move until that transaction is verified and the state has been updated in the smart contract and we know that that can take a really long time to happen so that makes it infeasible for us to play a game that has very rapid State changes hopefully that makes sense but you would be sitting there waiting 30 minutes an hour for the transaction to be finalized before the next player would be able to move and while that completely defeats the purpose of like a quick game of chest or something along those lines so this is where we introduce State channels so the idea here between State channels is that if we have a ton of micro transactions or many any transactions that are going to be occurring in a short period of time rather than doing them on the blockchain we're going to take them off the blockchain and do them in a secure way that can later be verified by the blockchain so a state channel is essentially a communication Channel a peertopeer messaging Channel where me and someone else who are participating in for example some type of game are going to be sending signed messages to and from each other with the state of the game so if we're playing a game of chess I'm going to be sending a message that's signed by me to my opponent saying I made this move and then they're going to send me a message that science said I made this move and we're both going to be verifying that the state is correct at each point in time by signing these messages hopefully that makes a bit of sense now the way that this works is we're first going to send a transaction to a Smart contract sitting on layer 1 to open up the state Channel Once the state channel has been opened we're going to do all of our transactions the micro quick ones off the blockchain they will happen almost instantly then at the end of the game we're going to send one transaction to the smart contract with the final State and we're going to say hey we finished the game and then the smart contract is essentially going to verify that the state is correct and there's a lot of stuff that goes on to do that I won't really talk about how that works and if we're playing for say one ethereum so whoever wins the chess game gets one ethereum then that ethereum would be transferred and we would have had to kind of stake that at the beginning of the game so hopefully that makes a bit of sense but typically State channels allow for us to have very fast transactions they make it very cheap because we don't have to pay gas fees when we're doing this off the blockchain we just have that first and last transaction that require the gas fee to open the state Channel and to close the state Channel and typically they do allow for the same security and decentralization however you may have the security be slightly decreased depending on the way that you're verifying the states and what you're doing between the blockchain and the off chain or between layer 1 and layer 2. again I don't want to get into this too much those are stage channels very useful when you have a ton of micro transactions that need to be performed very very quickly so now we are moving on to the final solution I have in this video which is RollUps now before I get into those I do want to mention that cartesi actually implements a ton of layer 2 Solutions and makes it really easy for developers like yourself to use these Solutions without having a full understanding of how they work and what's going on behind the scenes cartesia is working on operating systems libraries modules packages Frameworks all of the stuff you could imagine is going to make it easier for you as a developer to use these types of solutions that are really complicated on a lower level so make sure you check them out from the link in the description anyways let me talk about roll ups here and I will also mention that cartesi has a ton of articles that explain this stuff more in depth if you're interested again reference them from the link in the description so a roll up is essentially an idea that we're going to take all of the transaction execution so the computations associated with the transaction and perform those off the blockchain will posting transaction data to the blockchain on layer 1. so the basic concept behind rollups is that it's very expensive to perform computations on the blockchain it can also be very time consuming so rather than do them on the blockchain let's perform our transaction execution off of the blockchain and then post the transaction data to layer 1 and have a smart contract on layer one so on the blockchain they can validate that the execution that we did off the blockchain was indeed correct now I know that's confusing but essentially we're taking the time consuming operations and computations Performing them off the blockchain and then posting all of the data to the blockchain where we can then validate that it is correct and we can use the properties of the blockchain to store the data now another advantage of the rollups is that what they can do is they can bundle multiple transactions maybe hundreds or thousands of transactions into one smaller transaction and then post that to layer one so rather than having the user have to send a thousand transactions directly to a Smart contract which costs a lot takes a lot of time we're going to send it to whatever's rolling up these transactions it's going to kind of bundle them all together and then send one transaction to the blockchain that contains all of the data that it needs of the state change that's going to be made so before I can go any further because I do want to give you some more detail here I will mention that there's some different types of RollUps so we have optimistic robes and pessimistic ropes now I'm going to start with optimistic RollUps now I do want to add here that the blockchain community currently considers roll ups to be one of the most promising solutions for scaling ethereum and the reason for that is that they allow you to scale the computations and throughput of the network without compromising on security and decentralization so using that in combination with sharding which allows you to scale the data on the network really gives you the best of both worlds and allows you to scale ethereum in all three of the areas that we talked about so sharding scales the data and the RollUps allow us to scale the computations as well as the throughput so the transactions per second so you're likely going to be hearing a lot more about RollUps in the future and maybe even using them yourself and if you were to pay attention to any of the solutions in this video this would be the one that I recommend so when we talk about optimistic rollups what we're really referring to is that the smart contract that's sitting on layer 1 is assuming that any of the transactions sent to it are valid so any of the state changes that are made any of the transaction data we'd assume that's valid and that it's not malicious now this allows for us to have very quick transactions and to perform faster computations off the blockchain because we don't have to prove that everything is correct however this does mean that someone could submit a malicious transaction now there is incentives put in place to make sure that people do not submit malicious transactions for example there may be something like staking ethereum so whenever people are dealing with rollups you may have to stake some ethereum that says hey I'm going to be a good actor I'm not going to submit any malicious uh transactions or state data and if you do that so if you are malicious your stake could get slashed that could be the incentive or the incentive from performing poorly or having bad behavior on the network hopefully that makes a bit of sense but the idea here is that we're assuming everything is correct now if someone does do something that is not correct or is invalid or malicious or whatever anyone can submit something known as a fraud proof now this fraud proof essentially says I believe that this state is incorrect I believe that someone did something malicious go and verify that it's not or go and verify that they did indeed do something malicious so that's what's called it's a fraud proof this puts the smart contract into a specific mode where it's going to go and validate that all of the transactions and data that are sent is actually correct and if they are not correct it's going to punish whoever submitted the incorrect transaction hopefully that makes a bit of sense but that is optimistic ropes again just really think about the fact that an optimistic rollup is assuming everything is correct and it's only doing a validation if someone submits a fraud proof all right moving on now to pessimistic rollups now pessimistic ropes are kind of the opposite of optimistic ropes in a pessimistic rollup you cannot submit or update the state of a smart contract unless you submit something known as a validity proof now this proof is a specific cryptographic proof I'm not going to really talk about exactly how it works but essentially off the blockchain when you're performing all of your computations you also need to compute this proof and then this proof is sent to the smart contract and you can only submit or update the state story of the smart contract if you have this proof alongside it now the only real issue with these type of proofs though is that they can be inviable to compute for a really complex transactions so these are time consuming and difficult for a computer to come up with these cryptographic proofs and so if you're doing anything that's too complex it can be inviable to come up with one of these proofs and in that situation you need to use an optimistic rollup now the reason you would use one of these proofs though is because this limits the amount of data that the smart contract needs to hold because all it needs to do is hold a state because it can only update the state if it has a valid proof I understand it's a little bit confusing but in the optimistic rollup scenario it's holding all of the transaction data and it's only doing a verification when a fraud proof is sent so it is time consuming when you send the fraud proof but ideally you're not having that happen very oft whereas in a pessimistic scenario here the smart contract is holding much less data it's just storing the state and it's only updating that state when you submit the proof this means it's really easy for the smart contract to validate that everything is correct however it takes more time off the blockchain to be able to submit these State changes because you need to perform this validity proof and sometimes this validity proof can be inviable to compute alright so that's pretty much all I can share with you related to roll up so getting into too much detail again I want to emphasize this at a very high level there's a ton of stuff that I skipped over and omitted in this video with that said I'm going to start wrapping it up here another massive thank you to cartesi for sponsoring this video and this series make sure you check them out from the link in the description they have all kinds of Articles very smart people there that are implementing these types of layer 2 Solutions and are trying to make it much easier for you and me to develop decentralized applications without the huge issues or limitations of ethereum that we looked at in some previous videos hope you guys enjoyed this series if you did make sure you leave a like subscribe to the Channel please leave a comment down below and let me know if you want to see more blockchain on this channel because I'm hoping do some more series in the future and with that said I will see you in another YouTube video foreign
