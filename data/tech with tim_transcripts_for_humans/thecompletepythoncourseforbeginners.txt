With timestamps:

00:00 - hello everyone and welcome to the
00:01 - complete python course this course is
00:03 - designed to teach you everything you
00:05 - need to know about the Python
00:06 - programming language this is going to
00:08 - assume you're a complete beginner you
00:10 - have no knowledge of python and bring
00:11 - you through right from the beginning all
00:13 - the way up to expert and advanced level
00:15 - features so this course is actually a
00:17 - combination of a bunch of videos that
00:19 - I've created over the past few years it
00:21 - starts with beginner Python Programming
00:23 - goes to object-oriented programming then
00:25 - into intermediate and advanced level
00:27 - features so those are the four main
00:29 - section of this course it's kind of
00:31 - split up in those four sections and
00:33 - within those sections there's a bunch of
00:34 - topics now if you want to figure out
00:36 - what section to jump to or you want to
00:37 - see what's involved in the course look
00:39 - in the description there'll be a bunch
00:40 - of different timestamps that show all of
00:42 - the different topics that are covered
00:44 - and feel free to skip through and go to
00:46 - the ones that you find the most
00:47 - interesting so with that being said this
00:49 - video is taking a very long time to
00:51 - compile and create so I would appreciate
00:52 - if you guys leave a like you subscribe
00:54 - and you consider becoming a channel
00:56 - member if you want to support me on a
00:57 - monthly basis so with that being said
00:59 - let's go ahead and get into the full
01:01 - python
01:14 - course hey guys so welcome back um today
01:17 - I'm going to be doing a Python tutorial
01:20 - Series so this is the first episode in
01:23 - the series it's kind of an introduction
01:25 - showing you how to download python how
01:27 - to install it and then going into data
01:29 - types and variables so the first
01:31 - important thing to understand about the
01:34 - Python programming language so don't
01:36 - worry if you've never programmed before
01:38 - um I'm going to be going over everything
01:40 - very slowly and in depth so that you can
01:43 - understand I recommend that you follow
01:45 - along with everything I'm doing in the
01:46 - tutorial uh pause the video at certain
01:48 - points rewind if you don't understand um
01:51 - it's important you understand these
01:52 - parts so that we can move forward into
01:53 - more complex
01:55 - ideas so obviously the first um thing
01:58 - that we're going to have to do if we're
01:59 - going to learn python is we have to
02:00 - install it on our computer so uh we're
02:03 - just going to go to the python website
02:05 - up here python.org
02:07 - downloads right here and all you're
02:09 - going to do is just click download
02:11 - python
02:13 - 3.6.1 now I'm not going to do that
02:15 - because I already have python installed
02:17 - and downloaded on my computer but pretty
02:19 - much once you uh download this it's
02:21 - going to pop up down here in your
02:23 - downloads folder just run the exe it's
02:25 - very simple um and you'll be running
02:27 - python in no time so now pause the video
02:29 - go ahead and do that and then we can go
02:31 - to the next
02:32 - steps okay so once you've done that
02:35 - you're going to notice that you have an
02:37 - application that looks like this it's
02:38 - called idle um Python and then it'll
02:41 - have the version so I'm using version
02:44 - 3.5 um don't worry if you have a version
02:47 - that is larger than that so 3.6 or even
02:49 - one that's before that most of the
02:51 - things that I do in this will work in
02:52 - all the versions of
02:54 - python okay so go ahead and run the idle
02:57 - you'll notice the first thing that pops
02:59 - up is the python shell as you can see at
03:02 - the top here the shell now this right
03:05 - here is not where we're going to write
03:07 - all our programs it's the console kind
03:10 - of so here I can type any lines of code
03:13 - for example I want to
03:15 - print a name like this and it'll run
03:18 - right away so that's not what we're
03:20 - going to do you can play around with
03:21 - this if you want but we're going to go
03:23 - to file and we're going to click new
03:26 - file and then here we go so now we have
03:29 - a new document that we're going to be
03:31 - working on and we're going to be
03:32 - programming in so I'm going to go ahead
03:34 - and I'm going to save this right away as
03:36 - tutorial one into my tutorial folder
03:41 - which I believe is on my
03:42 - desktop right here yep right there
03:45 - awesome okay so there we go we've saved
03:48 - it and now we're ready to learn a little
03:50 - bit about data types so pretty much
03:52 - python is a fairly basic language in
03:55 - comparison to a lot of other ones a lot
03:57 - of things that it does is uh more simple
03:59 - than other languages but it is important
04:01 - to understand the basic data type so
04:03 - there's four main data types in Python
04:05 - there is a few more but we're just going
04:07 - to talk about these ones right now um
04:09 - the first one is an integer so that can
04:12 - be uh a short form int that stands for
04:15 - integer now um an integer is any number
04:18 - so such as 1 4 76 any whole number it's
04:24 - important that is a whole number it
04:25 - could be a negative number as
04:27 - well5 um zero those are are all
04:30 - integers okay now we have strings now
04:34 - the short form for Strings is St now
04:37 - pretty much a string is anything
04:39 - embedded in quotations so like this uh
04:42 - this is my name Tim that is a string and
04:44 - then we also have something like this
04:47 - this would be a string and even like
04:51 - this this would be a string so although
04:53 - there is a number in here since it is
04:55 - between these two quotations here it is
05:00 - a string so even if I did another number
05:02 - like like that string um now it's also
05:06 - important to understand that it doesn't
05:07 - matter if you use the single quotations
05:09 - or the double quotations sometimes we
05:12 - use the single quotations because inside
05:14 - of our actual quotations we want to use
05:17 - double quotations or maybe um if we use
05:20 - the double quotations because we want to
05:22 - use the single quotations inside of our
05:24 - actual string like that okay so those
05:27 - are just a few examples um now we have
05:30 - Boolean variables uh or data types sorry
05:34 - so Boolean data types is something like
05:38 - true and false so true and false pretty
05:42 - basic um these are reserved words in
05:45 - Python um meaning that they're
05:47 - highlighted in yellow and that you
05:48 - cannot use them for variable names
05:50 - that's going to be important later on um
05:53 - just know that they are important words
05:55 - uh true and false and they do start with
05:57 - capitals so um for example if I typee
06:00 - true like this uh it's not highlighting
06:03 - Orange right so that's because true um
06:06 - in Python the keyword for that starts
06:07 - with a capital so true and false um then
06:10 - we have the um decimals which are the
06:14 - float uh data type like this so anything
06:17 - with a decimal floating point so
06:20 - 1.23 um anything like that any decimal
06:23 - number with a floating decimal point uh
06:25 - would be a
06:27 - float okay so those are the four basic
06:31 - um data types um there is a few more
06:34 - that I'll go on to later on but you just
06:36 - have to understand these ones right now
06:38 - so now that we know these data types
06:41 - I'll give a quick little quiz here so
06:43 - I'm just going to put a
06:45 - few things right
06:50 - here and then I want you to pause the
06:53 - video and go ahead and try to determine
06:55 - what type of data type these things are
07:00 - okay so go ahead pause the video and
07:02 - then I'll go over the answers in a
07:05 - second okay so we'll start with the
07:07 - first one here uh hello it's the same
07:09 - example that I have up here except in
07:11 - single quotations so we can see that it
07:13 - is a string data type okay so that is
07:16 - the short form Str Str now we have the
07:19 - number
07:20 - 123 that would be the integer data type
07:24 - we have another number here that has a
07:25 - decimal point so
07:27 - 3.22 that would be a float
07:30 - we have the keyword true this data type
07:33 - is a Boolean data type then we have two
07:37 - in quotations this is very important we
07:39 - don't want to get this mixed up this is
07:40 - a string some people may think that it's
07:43 - an integer because it's two but no it
07:45 - actually is a string because it is
07:47 - inside of the quotations and then same
07:49 - thing here three inside of the double
07:51 - quotations again is a string not an
07:53 - integer okay so now that we have an idea
07:56 - of the basic data types um I'm going to
07:59 - show you how to create a variable so
08:02 - pretty much you may have heard of
08:03 - variables before in math or something
08:05 - like that um in math we tend to use X as
08:08 - a variable we say x may be five x may be
08:11 - four anything like that um it's the same
08:14 - thing in Python now declaring a variable
08:16 - in Python is very easy all you have to
08:18 - do is type the variable name so in this
08:20 - case I'm going to use name and then
08:23 - simply give it a value so this value as
08:25 - you may remember is a string this is my
08:27 - name and I'm just storing it in the
08:29 - variable
08:30 - name now if I want to access that
08:33 - variable I want to see what that
08:35 - variable is I can print it to the
08:38 - console by simply typing the variable
08:40 - name which is name so now we'll see what
08:43 - happens um if I run the program just
08:45 - going run run module I'm going to use F5
08:47 - from now on so that's the uh thing and
08:50 - you can see it prints out Tim just like
08:52 - that okay now um say we did that we have
08:56 - name equals Tim we printed it to the
08:58 - screen now maybe we want to change that
09:00 - variable well it's very easy again all
09:03 - we have to do is just type the value
09:05 - name and now maybe we're going to change
09:06 - it to Bob and now we want to see what
09:08 - the new VAR new variable is so we will
09:11 - print it to the screen we'll print name
09:14 - cck F5 to run that and we'll see name
09:17 - and or sorry Tim and then Bob so like we
09:20 - have here name equals Tim print name
09:23 - name equals Bob print name right so
09:26 - we've set it like that okay so that's
09:28 - pretty basic um
09:30 - now you can create variables of
09:31 - different data types so for example if
09:33 - we had a variable age I would use an
09:36 - integer data type so like 18 for that
09:39 - variable and then again if I wanted to
09:41 - print into the screen I would type print
09:43 - and then the variable name like
09:45 - that okay 18 perfect right so we printed
09:49 - that to the screen um again if the
09:52 - variable names um there's a few
09:54 - restrictions on variable names so here
09:58 - you just see I've used three lowercase
10:00 - letters um your variable names can
10:03 - contain underscores um they cannot
10:05 - contain dashes um they can only contain
10:08 - underscores text and they cannot start
10:11 - with a number I believe so if I try to
10:13 - do one one name equals 2 for
10:18 - example I run into an invalid syntax
10:21 - error because we can't name a variable
10:23 - starting with a number now I can end it
10:25 - with a number I
10:27 - believe let us try
10:31 - yep so that's fine it's let us do that
10:33 - name equals one I could do name
10:36 - underscore um person maybe yeah namore
10:40 - person you see if I run that program
10:42 - everything's fine there um but I can't
10:45 - put something like a star in my variable
10:50 - name you see how we've got an invalid
10:52 - syntax there right this is because these
10:54 - symbols represent something else in the
10:57 - Python language so just know for names
11:00 - um we can use capitals if we'd like I
11:01 - could use name like
11:04 - that run the program that works fine but
11:07 - I cannot start it with numbers so I
11:09 - cannot put a number there um and I
11:11 - cannot contain anything other than
11:13 - underscores texts and numbers in or at
11:16 - the end of the variable name now here's
11:20 - a quiz for you if I make a variable
11:22 - called name and do another variable
11:24 - called
11:26 - name um are they the same thing now
11:29 - that's a good question um are these two
11:32 - the same thing um no they are not the
11:34 - same thing so capitals do matter in
11:36 - Python the all capitals variable name is
11:40 - different than the variable name so
11:43 - again name like this is different than
11:45 - all of those variables there okay so I
11:48 - think I've covered um a little bit on
11:51 - variables and data types today um this
11:53 - is the complete Basics just wanting to
11:56 - get everyone caught up um in the next
11:58 - video we'll go into some more advanced
12:00 - things maybe uh operations of variables
12:03 - adding them together subtracting
12:05 - multiplying um buing conditions things
12:08 - like that okay so I hope you enjoyed the
12:10 - video today um stay tuned and we're
12:13 - going to have another one out tomorrow
12:15 - um and like the video if you if it was
12:17 - good and subscribe so yeah thank
12:24 - you hey guys so welcome to the second
12:27 - video in the series um if you remember
12:29 - in the last video we talked about data
12:31 - types and variables uh we went briefly
12:33 - into some of the things that python can
12:35 - do um today I'm going to be talking
12:37 - about operators and we're going to be
12:40 - doing some print statements some input
12:43 - um a little a few small console
12:45 - applications just applying some of the
12:47 - knowledge that we've learned so pretty
12:50 - much the first thing I want to do is I
12:51 - want to go back and I want to review
12:52 - what we did in the last lesson very
12:53 - quickly so we talked about variables and
12:55 - data types so for example the X variable
12:57 - we could set it to something equal to
12:58 - two like that uh a name we may equal to
13:02 - our name right so I make that equal to
13:03 - Tim um so there we go we have the name
13:07 - right there equal to 10 we'll start with
13:08 - that okay now if you remember in the
13:11 - last one I didn't talk about this but I
13:12 - used something called print now the
13:14 - print statement pretty much takes an
13:16 - argument so inside of these brackets the
13:20 - thing that is inside that brackets is
13:21 - called the argument so it takes a uh a
13:25 - string argument usually so I will give
13:27 - it the name so now you'll see again we
13:29 - did this in the last one just want to
13:30 - review I'm clicking F5 simply to run the
13:32 - program when I go to the console it
13:35 - simply puts Tim onto the console just
13:37 - like that
13:38 - right okay um very basic we already did
13:42 - that so now let's say well we want to do
13:45 - something else so let's let's print here
13:48 - and we're just going to put a string and
13:49 - we're just going to type this in
13:50 - ourselves so let's say hello comma what
13:54 - is your
13:57 - name that's going to print to the
13:59 - console now we want to get what the
14:01 - user's name is now there's a way to do
14:04 - this in Python it's very simple we're
14:06 - going to make a variable name it makes
14:08 - sense to put the variable name here and
14:10 - do an equal sign because it's a variable
14:12 - right we're going to type the word input
14:16 - just like this now what's going to
14:18 - happen if I run the program here I'll
14:20 - show you is it's going to say hello what
14:24 - is your name and it's going to actually
14:25 - allow me now to type into the console
14:28 - which I couldn't do before now nothing
14:30 - happens after when I click enter because
14:31 - we don't have anything else after that
14:33 - but it's allowing me to
14:35 - type okay so now well we want to print
14:38 - out what the name is that was said so
14:40 - let's just simply type print and then
14:44 - name all right and we have hello what is
14:47 - your name I say oh well my name's Tim it
14:49 - says Tim all
14:51 - right now well we just printed out the
14:54 - name but maybe we want to go a little
14:55 - more advanced than that we want to say
14:57 - well hello Tim how are you doing Tim
15:00 - something like that right so I'm going
15:01 - to just put a comma here going to
15:04 - separate these two things and I'm going
15:06 - to put in a string and I'm just going to
15:08 - type what I like to type so I'm going to
15:09 - say hello with a comma and then you see
15:13 - that I have this other comma here that
15:15 - is outside of the quotations meaning
15:17 - it's not a string it's actually just
15:18 - separating the two arguments in here and
15:20 - you'll notice what happens now when I
15:23 - print is it goes hello what is your name
15:25 - so I say oh my name's Tim it says hello
15:28 - Tim
15:29 - right so that's pretty straightforward I
15:31 - hope that's easy to understand we're
15:32 - just using the input to get an input and
15:34 - then we're printing it back out to the
15:36 - screen okay so let's do um let's go into
15:39 - the next part of this now we'll use that
15:40 - again later but let's talk about
15:42 - operators so operator that term may
15:45 - sound familiar to you um in math uh we
15:48 - use things called operators so these
15:50 - four operators hopefully should look
15:52 - familiar to you um this is a plus sign
15:55 - this is the addition operator we have
15:57 - the minus sign which is the subtraction
15:59 - operator the division sign which is the
16:02 - well division operator and then the
16:04 - multiplication sign which is again the
16:06 - multiplication uh operator so there's a
16:09 - few more operators that we'll talk about
16:10 - but these are the four basic ones in
16:13 - Python now you remember how I talked to
16:15 - you about data types this is where this
16:17 - comes in when we use these operators
16:19 - it's important that we use them on
16:21 - certain data types so for example um in
16:23 - math I could do something like 3 + 4
16:27 - right so what is 3 + 4 equal well that
16:29 - is equal to 7 so the computer can
16:31 - actually do that math operation by using
16:34 - that operator to return those values so
16:36 - let's let's give an example here quickly
16:38 - so I have uh let's do num one we're
16:41 - going to use variables here uh remember
16:43 - I can use a number in the variable as
16:45 - long as it's not at the beginning and
16:46 - I'm going to give it a value of 45 and
16:48 - then we'll do num two and we're going to
16:50 - give it a value of three now if I want
16:53 - to print to the console um let's say num
16:57 - one plus num 2
16:59 - well you can guess what that's going to
17:01 - give us it's going to give us 45 + 3 I
17:04 - hope if this is not an
17:07 - error yeah so that gave us 48 right so
17:11 - oops didn't mean to make that full
17:12 - screen num 1 plus num two is 48 all
17:16 - right so now what about minus let's try
17:19 - this 42 basic um we can do
17:22 - multiplication here with the
17:24 - multiplication
17:26 - sign there we go 135 and then we'll try
17:30 - again with the division sign just to
17:32 - show you all of them we get
17:34 - 15.0 like that okay so that's pretty
17:37 - straightforward um those four basic
17:39 - operators now in Python there's a few
17:42 - more operators that we want to talk
17:44 - about now for example in math we have
17:46 - something called exponents right so how
17:48 - do we do exponents in Python well it's
17:51 - actually two stars is how you do an
17:53 - exponent all right and now maybe there's
17:55 - something called integer division um
17:58 - which I'll get into later but I'll just
17:59 - show you the operator for it right now
18:00 - it's two slashes that means uh I'll give
18:03 - you an example a math example here
18:05 - 64 /
18:07 - by um let's do 10 um would give us
18:11 - usually in math a value of 6.4 right
18:15 - that's if you use one division sign
18:17 - sorry what am I doing times I mean
18:19 - divided by would give us 64 I have 6.4
18:22 - but now if we do two division signs here
18:24 - like this it actually gives us a value
18:26 - of six that's because it just um it
18:29 - doesn't worry about the remainder at all
18:31 - it just tells us um how many times 10
18:34 - can go into 64 um and that's all it can
18:37 - go in six times evenly so it gives us a
18:40 - whole number as our answer that's called
18:41 - integer division this double double
18:44 - slash like
18:45 - this okay and then we have another
18:49 - operator which is actually the modulus
18:51 - operator um so this is the percentage
18:54 - sign and this gives us the remainder so
18:57 - here if I do five 5 modulus
19:01 - 2 then the remainder of that is actually
19:05 - 1 because 5 / two is four then with a
19:09 - remainder of one right so it's not going
19:10 - to give us the decimal points it's again
19:11 - just going to give us the remainder if I
19:13 - did five / by four again the remainder
19:15 - is one 5id by 3 the remainder would be
19:17 - two like that okay so that's what the
19:19 - modulus sign um gives us so we'll put
19:21 - modulus here and then there's probably a
19:24 - few others that I'm forgetting about but
19:26 - we can go into those later
19:29 - so now um same thing let's keep using
19:31 - our number variables here and now let's
19:33 - introduce a third variable called
19:35 - num3 now um I want to show you how we
19:38 - can use the variables so num one and
19:40 - let's see if you remember what this
19:42 - operator is uh so that's the exponent
19:44 - operator so that means num one which is
19:45 - going to be our base uh which is 45
19:48 - raised to the power of four because
19:50 - we're going to use num two and we can
19:53 - print num
19:55 - three press okay
19:59 - and you can see we get a pretty large
20:00 - number um that's because of how
20:01 - exponents work and
20:03 - then same thing here if we want to do
20:06 - maybe integer division see what we're
20:08 - going to
20:09 - get we get 11 right a whole number and
20:13 - then say we want to do
20:18 - modulus we get one okay so now let's tie
20:21 - all these things together with the
20:22 - operators that we've used the variables
20:24 - the prints and the
20:26 - inputs so um let's start by just get
20:29 - doing a little print statement and
20:31 - saying pick a
20:35 - number okay pretty basic we're going to
20:37 - pick a number and then we're going to
20:39 - take the input so we're going to say num
20:40 - one again is equal to the input of
20:45 - that okay so we got the input in Num one
20:48 - um now let's say
20:52 - print pick another
20:57 - number all right so now we're going to
20:59 - pick another number so we're going to do
21:00 - num two is equal to input like that and
21:04 - now what we're going to do is we're
21:05 - going to introduce our third variable so
21:07 - we'll call it sum because we're going to
21:08 - add these is equal to num one plus num 2
21:12 - and now actually you can't use sum
21:14 - because it's a reserve word so let's
21:15 - just do in all capital sum because
21:18 - remember how we talked about variables
21:19 - capitals and lowercase are different and
21:21 - then we're going to print to the
21:24 - console the sum like that okay
21:29 - so we run the program says pick a number
21:31 - uh let's pick a number let's say four
21:33 - and let's do 32 now what do you think
21:36 - it's going to
21:37 - be oh oops okay
21:42 - so yeah someone equal num one plus num
21:46 - two okay so this is why um I talked
21:48 - about data types so I'm actually uh
21:50 - Happy this happened it's because what
21:51 - actually happens when we get the input
21:53 - of something is it gives us the type of
21:55 - a string um which in this case is not
21:59 - what we wanted to do so um you saw there
22:02 - I'll run it again um it's a good mistake
22:04 - that this happened actually we have four
22:06 - and we have a three and it gave us 43
22:09 - that's just because we added the string
22:10 - four to the string three um so that
22:13 - simply gave us 43 but now we know in
22:15 - actual math that 4 + 3 equal 7 so if we
22:17 - want to do um the integers we have to
22:20 - actually convert these variables into
22:22 - integers so in order to do that remember
22:24 - I showed you the keyword um int like
22:27 - this before we're just going to put
22:29 - brackets around our two variables here
22:32 - like this
22:33 - integers and now hopefully we should get
22:37 - the correct answer when we do four and
22:39 - we do three and you can see we've got
22:41 - seven so um I didn't mean for that to
22:43 - happen originally but I'm happy it did
22:45 - because it shows us why data types are
22:47 - important so when we take the input of
22:49 - something we're typing it from the
22:51 - keyboard and that is actually a string
22:53 - so um here we can print again um don't
22:57 - worry about what I'm doing right now but
22:58 - I just want to show you the type which
22:59 - is going to give us if it's a string if
23:01 - it's an integer of num two just to show
23:03 - you what the type actually is so we pick
23:06 - a number we pick two and we pick three
23:09 - it tells us that three is actually a
23:12 - string so that's why when we added
23:14 - originally three and two or two and
23:16 - three or whatever it was um it gave us
23:18 - just them added together so two and
23:21 - three rather than what it should be
23:22 - which is five okay now same thing here
23:26 - if we had a number and we wanted to
23:28 - convert it into a string all we would do
23:31 - is we would type Str Str around the
23:34 - number so for example three and then
23:36 - that would give us three just like that
23:39 - so A String so now we've kind of gone
23:42 - over a conversion of variables um
23:45 - conversion of numbers data types how to
23:47 - get input from the console using the
23:49 - input like this um and some basic
23:51 - operators of python so uh review this I
23:55 - hope you followed along and then in the
23:58 - next next lesson we'll move into some
23:59 - more advanced operators and we'll maybe
24:02 - start with conditions okay I hope you
24:04 - enjoyed uh please subscribe like the
24:06 - video and I'll see you in the next
24:14 - video hey guys uh welcome back to the
24:17 - third video in my Python Programming
24:19 - tutorial series um today we're going to
24:21 - be talking about something called
24:23 - conditions so I hope you remember from
24:25 - the other videos we talked about input
24:27 - printing we did variables data types and
24:31 - then we talked about operators so
24:32 - operators like plus minus um division
24:36 - integer division modulus right uh
24:38 - multiplication all those operators today
24:41 - we're going to be talking about a few
24:42 - more operators and then getting into
24:45 - conditions so here in my file right here
24:48 - um I've put down four basic comparison
24:51 - operators so pretty much a comparison is
24:54 - something that's going to return a value
24:56 - of true or false so here we have um
24:59 - let's say if a real world example is Tim
25:02 - equal to Joe well no they're not because
25:07 - Tim obviously spelled differently than
25:08 - Joe so that's going to be giving us a
25:10 - value of false um same thing if we want
25:13 - to go into numbers we say 18 is greater
25:16 - than two well is that true yes it is so
25:20 - that condition gives us a value of true
25:23 - uh it's a very simple concept but it's
25:25 - something that we have to understand as
25:26 - we go into decision Visions later on
25:29 - which will be in the next
25:30 - video okay so these comparison operators
25:33 - I'll read them off and just kind of give
25:34 - a definition of each of them so the
25:36 - first one can e be a less than or a
25:38 - greater than sign uh same thing with the
25:40 - second one right so it's just going to
25:42 - compare if something's less than greater
25:44 - than um usually these are used for
25:46 - integer values um that data type uh we
25:50 - also can use them for Strings but it's a
25:52 - little more complex and I'm not going to
25:54 - get into that right now maybe in a more
25:56 - advanced tutorial later on now the
25:59 - equivalent operator so the equal sign
26:02 - here now a lot of people think well if
26:04 - I'm comparing something why wouldn't I
26:06 - just use one equal sign like this well
26:08 - that's a very good question and a lot of
26:10 - people get mixed up on this it is
26:11 - actually two equal signs that's because
26:14 - in Python um the one equal sign is a
26:17 - declaration um declaration operator so
26:21 - for example if I put a variable X and I
26:24 - want to set it equal to four right um
26:27 - this is is what we do with the one equal
26:30 - sign we're setting values right so when
26:32 - we did name is equal to Tim things like
26:35 - that we're using one equal sign now if
26:38 - we're going to check something we're
26:39 - going to compare them we have to use two
26:41 - because two equal signs and one equal
26:44 - sign have a very different meaning so
26:46 - it's important to keep that in mind that
26:47 - the comparison operator for equivalency
26:49 - is two equal signs okay the next one is
26:53 - not equal to um so we have an
26:56 - exclamation mark and then we have the
26:58 - equal sign like this okay so an example
27:01 - of not equal to because some people may
27:03 - get confused here is say if four not
27:06 - equal to 5 oops what did I type
27:10 - there not equal to 5 okay so what do you
27:14 - think this would give us just think
27:16 - about it for a
27:17 - second well what it's actually going to
27:20 - return to us is true because the
27:23 - condition is if four is not equal to 5
27:28 - and here we can see obviously four is
27:30 - not equal to 5 so now again if I give
27:33 - another example we put five here we say
27:34 - five not equal to 5 well that would
27:37 - return a value of false because five is
27:40 - indeed equal to five now we can do the
27:43 - same thing with strings so for example
27:45 - we have hello oops spelled incorrectly
27:48 - there we go
27:50 - and Tim uh now you can probably guess by
27:55 - yourself that this is going to return
27:56 - true because him is indeed not equal to
28:00 - hello okay uh it's pretty
28:03 - straightforward um but a lot of people
28:05 - may get mixed up with the not equal to
28:07 - if it's returning true or false okay so
28:10 - those are the four basic comparison
28:11 - operators that we're going to use so we
28:13 - have equal to U not equal to and then
28:15 - greater than and less than so greater
28:17 - than and less than again we use for
28:19 - numbers so one less than two again
28:22 - that's going to return true like that
28:25 - okay so now um we're going to start
28:28 - printing from some things to the console
28:30 - and maybe doing a little bit of a quiz
28:32 - here um just to see how you guys are
28:34 - going to do so a booing condition I'm
28:37 - going to store it in a variable so I'm
28:39 - going to say name uh oops actually we're
28:41 - not going to do that we're just going to
28:42 - print to the
28:43 - console 2 less than
28:46 - three okay now you guys guess and uh
28:51 - tell me what you think is going to be
28:52 - returned to the console it's either
28:54 - going to be true or false I'll give you
28:55 - a hint right now
28:59 - now it gives us a value of true that's
29:01 - because this condition 2 is less than
29:04 - three um is true it's equal to three
29:08 - right um so now if we switch the sign
29:10 - and we make it greater than like that
29:13 - well you can guess what's going to come
29:14 - up so we click enter and we get false
29:18 - that's because this condition returns a
29:20 - value of
29:22 - false okay now we'll do another
29:24 - condition here all right um hello
29:28 - equal
29:30 - to Hilo okay um and guess yourself what
29:35 - this one's going to return false okay
29:38 - that's because they are spelled
29:40 - differently um now we're going to do the
29:41 - not equal sign just to show that one as
29:43 - well hello not equal to hello and we'll
29:46 - see that gives us true because they are
29:49 - not the same um fairly straightforward
29:52 - but a lot of people do get these things
29:53 - mixed up now I'll show you what happens
29:55 - when I try to just do one equal sign
29:58 - like
29:59 - this see we get keyword can't be an
30:03 - expression that's because we're trying
30:05 - to declare a variable here but we cannot
30:09 - do that okay because we're just using
30:11 - one equal sign here we need to use two
30:12 - all
30:13 - right okay so now let's try another
30:16 - example maybe a more advanced one uh
30:19 - this is a little bit of a trick okay I
30:20 - want to see if you guys remember from my
30:22 - last tutorial what I talked
30:26 - about so take a guess right now what you
30:29 - think is going to be returned you think
30:30 - it's going to be true or do you think
30:31 - it's going to be
30:32 - false well it was false okay um that's
30:36 - because again what we talked about in
30:37 - Python um capitals matter right so any
30:42 - capital letter is different than a
30:43 - lowercase letter so something like this
30:46 - um yeah it's going to return false all
30:48 - right it's important to understand that
30:50 - okay so we' very briefly uh gone into
30:53 - conditions now um I'm going to write a
30:55 - few on the side here you guys can go
30:56 - ahead um I'll put them in print
30:58 - statements and test yourself and see if
31:00 - you get them right or not
31:03 - okay I'm going to add a few tricks from
31:06 - the other lesson um try to kind of apply
31:08 - some of our
31:09 - knowledge and
31:12 - see if we can get them correct
31:16 - okay so just give me a minute here I'm
31:18 - just going to write a few
31:22 - out and then we'll go through the
31:24 - answers afterwards okay so you know what
31:26 - we'll just we'll just do these ones
31:28 - for right now and we'll do a few other
31:29 - examples okay so these are a little more
31:31 - advanced than what I was talking about
31:32 - before but they are conditions we have a
31:35 - left side of the condition and we have a
31:37 - right side of the condition so I hope
31:38 - you've taken a guess now of what you
31:40 - think these are going to be cuz I'm
31:41 - about to print out the answer right now
31:43 - Okay so we've gotten true false and
31:46 - false all right so for the first one two
31:49 - less than three that's an example I
31:51 - already gave that gives us a value of
31:53 - true because that condition is true uh
31:56 - now we have two - 3 + 4 greater than 5
32:01 - um so you can do the math there and see
32:02 - that that is going to be false and then
32:06 - this one some people may have gotten a
32:07 - little bit of a little bit confused on
32:09 - cuz I actually use the words false and
32:12 - true in my condition that's going to
32:14 - return false or true so I have print
32:17 - false equals equals true well is false
32:19 - the same thing as true no it's not so
32:21 - obviously we going to be returned with
32:23 - the value
32:24 - false Okay so we've talked a little bit
32:27 - about conditions now um in the next
32:29 - tutorial we're going to be doing
32:30 - something called decision so I'll give
32:32 - you a sneak peek on what that
32:34 - is something like this
32:38 - okay so stay tuned for that um the next
32:41 - episode should be up tomorrow um and
32:44 - yeah I hope you guys enjoyed the video
32:45 - go ahead like And subscribe and yeah
32:49 - share with your friends thanks
32:56 - bye hey guys guys uh welcome back to the
32:59 - fourth video in my Python Programming
33:02 - tutorial Series today we're going to be
33:03 - talking about decisions so we're going
33:05 - to be using the if else and L if
33:08 - statements in Python so pretty much I
33:11 - gave you a little example last time on
33:13 - what these are but if
33:16 - condition equals
33:19 - true then do this sorry not his do this
33:25 - okay so pretty much the syntax for the
33:28 - basic if statement which is what we are
33:30 - going to cover first is like this so if
33:33 - you remember my last tutorial I talked
33:35 - about conditions if you haven't seen
33:37 - that go back and look at that first
33:39 - because that's going to be an important
33:40 - part of today's lesson and you have to
33:42 - understand that so if condition is true
33:46 - then we are going to do this now let's
33:49 - just dig into the syntax a little bit
33:51 - here um so you're going to start with
33:52 - the keyword if then we're going to put a
33:55 - condition so the condition could be
33:57 - something like this if 1 is less than
34:00 - two if
34:03 - tree is equal
34:06 - to plant something like that okay
34:09 - anything that can return a true or false
34:11 - value you can use variable names you can
34:13 - say if x is equal to Y anything like
34:16 - that is condition and it uses a
34:19 - conditional operator like I talked about
34:21 - in the last video and then you are going
34:24 - to end your condition with a semicolon
34:28 - or sorry not a semicolon like this with
34:29 - a regular colon and then you going to
34:31 - Simply click enter and it should tab you
34:34 - in one line now it's very important that
34:36 - you have this
34:38 - indentation um if you have your code
34:40 - like this it's not going to work python
34:43 - reads the lines because of indentation
34:45 - so it's very important that you have
34:47 - whatever statements you want to run
34:49 - after the condition returns true
34:51 - indented properly and this will also be
34:54 - very important as we move further on in
34:56 - different tutorials and we have have
34:58 - lots of different indentation levels
35:00 - within the program okay so let's do a
35:02 - real example now instead of uh this kind
35:05 - of pseudo code here so we'll start off
35:07 - by just getting some input from the user
35:09 - so let's say let's get their age okay so
35:13 - age is equal to input like this and then
35:16 - just if you put something inside of the
35:18 - input like this uh it actually gives a
35:20 - prompt to the user so we'll say
35:23 - input your
35:26 - AG like that
35:28 - and then we will say if the age is equal
35:35 - to 16 then we will print to the
35:40 - screen hey
35:43 - your oops 16 like that
35:47 - okay um all right so let's go ahead and
35:50 - just test it out right away I know I
35:51 - haven't really explained it but I just
35:53 - want to show you how this
35:55 - works okay so we have input put your age
35:58 - so I'll say two as my age and we can see
36:02 - that nothing happens okay um now I want
36:06 - to show you one more I hope you've
36:07 - caught this trick already from what I
36:09 - talked about in the last videos but
36:10 - we'll see now you notice here I'm going
36:12 - to put in
36:14 - 16 and nothing's going to happen now the
36:17 - reason for that is because
36:19 - 16 here is different than the 16 that we
36:23 - get from age if you remember whenever
36:26 - we're getting a number or anything from
36:27 - the console we actually get it as a
36:29 - string so this 16 that we're getting
36:32 - actually looks like this now in Python
36:34 - again we have different data types right
36:36 - so this is an integer data type well
36:38 - this is a string so when we're comparing
36:40 - integers and strings um they're
36:42 - different so we have to
36:43 - convert our age variable into an integer
36:46 - before we can compare it like that okay
36:49 - now we'll try
36:50 - again say if int age equals 16 so now we
36:54 - put 16 in and says hey you're 16 like
36:57 - that okay
36:58 - um perfect so that's pretty
37:00 - straightforward um now we can also do
37:03 - some other conditions so let's do a
37:05 - greater than 16 now okay so this is
37:08 - another conditional operator that we
37:09 - talked about before um and yeah we'll go
37:12 - ahead we'll try it now so we'll say
37:14 - 15 now nothing happened because
37:16 - obviously 15 is not greater than
37:19 - 16 now if we put in
37:22 - 17 it works okay great
37:27 - um all right and also uh I just want to
37:29 - show you there's another operator that
37:31 - we didn't talk about last time a
37:32 - conditional operator and it's the
37:34 - greater than or equal to and the less
37:36 - than or equal to so to convert your um
37:40 - greater than sign into a greater than or
37:42 - equal to sign all you have to do is add
37:43 - an equal sign like this and now anything
37:47 - greater than or equal to 16 will work
37:50 - whereas before it had to be strictly
37:52 - greater than 16 and same thing with the
37:54 - less than sign like that okay uh I just
37:57 - forgot to talk about in the other video
37:58 - so I figured I'd put it in here all
38:01 - right um great so let's go into another
38:04 - example then so let's say um it's great
38:08 - it's telling us we're
38:09 - 16 um or let's in this case we're going
38:12 - to
38:13 - be older than 16 right so hey you're
38:17 - older than 16 but what if we want to
38:20 - message when we are younger than 16 well
38:24 - the way to do this is using something
38:26 - called an lse statement so the Syntax
38:28 - for this uh it simply has to come after
38:30 - an if statement you can't just leave
38:32 - your own else statement like this that
38:34 - will not work it has to be after an if
38:37 - statement is placed and then all you
38:38 - have to do is put a call in and click
38:41 - enter and make sure the indentation is
38:43 - the same as the indentation for the
38:45 - first
38:46 - if okay so now we're just going to
38:50 - print you are younger than
38:55 - 16 okay and we can go ahead we can try
38:57 - this to see if the else is going to work
39:00 - and we say well we're 15 and you are
39:03 - younger than 16
39:05 - great okay um so just to explain this a
39:09 - little more how this really works when
39:11 - we're reading through the code well
39:12 - python reads code line by line like this
39:16 - now when it reaches this if statement it
39:18 - checks this condition to see if it is
39:20 - true or false so since this condition um
39:24 - was false in the last example we say if
39:26 - false it says Okay so we're not going to
39:28 - run this line of code we're going to
39:30 - skip to the else statement and we're
39:32 - going to do this okay so if we had typed
39:35 - anything in that does not return true so
39:38 - makes this condition not return true
39:40 - then it would go to this else statement
39:43 - like this okay um yeah and then same
39:47 - thing say we type in a number 17 um and
39:50 - that is greater than 16 it's not going
39:52 - to do the L statement it's just going to
39:54 - do the if statement okay um I hope that
39:56 - makes sense
39:57 - now we're going to go into another layer
40:00 - okay so let's get into a new example
40:02 - here um let's talk
40:06 - about height for a roller coaster okay
40:08 - so for some roller coasters uh you have
40:10 - to be taller than a certain height and
40:12 - you actually can't be too tall right so
40:15 - again we'll get the input from the
40:17 - console so we'll just say height is
40:20 - equal to input and we're just going to
40:23 - do this in meters like 1 meter 2 meter 3
40:25 - meter just to make it really easy okay I
40:27 - know that's not a realistic height but
40:28 - just for the purpose of this example so
40:31 - we say height is equal to input um again
40:34 - we have to remember that when we're
40:36 - going to check the condition we have to
40:38 - make sure we put it in the int because
40:40 - as we get it from the console it's going
40:41 - to be a string okay so we'll say if
40:43 - height is less than 1
40:47 - M we're going to say you cannot ride so
40:50 - we're going to print to the
40:52 - screen you cannot ride okay now we only
40:57 - want to allow the user to ride if their
41:00 - height is in between 1 M but less than 2
41:05 - m okay so as you can see I've introduced
41:08 - a new word here called L if all right so
41:11 - this means if this condition up here is
41:15 - false then we're going to go to this one
41:17 - we're going to check if this condition
41:19 - is true or false if it's true we're
41:20 - going to run whatever's in here um
41:23 - otherwise we're going to keep going so
41:25 - you can have as many l ifs as you
41:28 - possibly want um in a decision statement
41:32 - like this okay um you can only have one
41:35 - else though because else is just the
41:36 - default so anything you type in um that
41:39 - doesn't equal any of these statements so
41:41 - like if isn't true Al if isn't true the
41:43 - other L if isn't true then it'll go to
41:45 - the lse statement okay so L if the
41:51 - height is so if it's less than one you
41:54 - can't ride and if it is greater greater
41:57 - than two you also can't ride so we're
42:01 - going to
42:03 - say you cannot ride I'm going to say and
42:08 - we'll say over 2 m and then we'll put
42:12 - here just so we can distinct them under
42:16 - one meter okay and then now we're going
42:19 - to add in the lse statement like this
42:21 - and we're going to say
42:23 - print you can write okay so I know I
42:27 - just did a lot there so we'll go through
42:29 - it quickly we pretty much have a
42:32 - condition up here we already talked
42:33 - about the if statement so if this
42:35 - condition is true we're going to print
42:37 - this and we're going to skip everything
42:39 - else we're not even going to bother
42:40 - reading it because we know that it's not
42:42 - going to be any of those conditions okay
42:44 - so now we do the L if here right so we
42:47 - say well if this condition is false
42:49 - we're going to go ahead and we're going
42:51 - to check this condition so we say oh
42:53 - well this one's true so then we're going
42:54 - to execute this line of code which is
42:56 - the print and we're not not going to do
42:57 - this else statement now say we go
43:00 - through these two and they're both false
43:02 - okay so this returned false and this
43:04 - return false then we're going to go to
43:06 - the else and we're automatically just
43:08 - going to print whatever is in the else
43:10 - statement like that okay so we'll go
43:12 - ahead uh we'll run the program and we'll
43:15 - try it out make sure I haven't made any
43:17 - errors here okay so the input um I
43:19 - didn't give a prompt so I'm just going
43:20 - to type in the height uh a number all
43:22 - right so we'll say
43:25 - one you can ride great okay um that is
43:29 - because again we have the strictly less
43:31 - than sign now if we wanted it to be you
43:34 - have to be over one foot we just put an
43:36 - equal sign here and then same thing here
43:39 - okay so we'll do that and now I'll show
43:40 - you again if I put in one you cannot
43:46 - ride under 1
43:47 - meter okay so less than or equal to one
43:50 - right okay um let's try again now we'll
43:53 - do it maybe a number greater than two so
43:56 - let's say put four it says you cannot
43:58 - ride because you are over 2 m and then
44:01 - again if we do like a decimal number
44:03 - maybe uh
44:05 - 1.1 Okay so we've run into an error
44:08 - there that's fine just because we can't
44:09 - convert a floating decimal point into an
44:11 - integer but yeah I hope you get the
44:13 - point from that example here um these
44:15 - are just the basic if L if and L
44:18 - statements I'll do one more just to show
44:19 - you here we could do another L if here
44:21 - saying for example um if in
44:25 - height is equal to remember we do two
44:27 - equal signs right not one then we're
44:30 - going to
44:31 - say
44:34 - print while you are
44:38 - tall okay so as you can see we can do
44:41 - infinite elf State L if statements like
44:43 - this and we can only have one lse
44:45 - statement and one if statement at the
44:47 - beginning
44:48 - okay uh so we'll run this one just to
44:50 - show you one more time how this works
44:52 - I'll put in five so
44:54 - five uh you cannot write over two 2 m
44:57 - okay so that's because what actually
44:59 - happened here is we went if we checked
45:01 - this condition now it turns out that um
45:05 - five is greater than two so we did this
45:07 - one and we didn't bother reading the
45:08 - rest now if I wanted to change this uh
45:11 - so that it would check the five first
45:14 - all I would have to do is put this LF
45:16 - statement I'll do it right
45:17 - now above the other L if
45:21 - statement like this and
45:25 - now if I type in 5 it'll work wow you
45:29 - are
45:29 - tall okay so uh that's it for the if L
45:34 - if and L statements um in the next
45:36 - tutorial we're going to go into
45:37 - something called chain conditionals and
45:39 - do some more advanced examples of this
45:41 - we're going to do some addition
45:42 - subtraction and some more things with
45:43 - other operators okay so I hope you
45:46 - enjoyed um please don't forget to like
45:49 - And subscribe the video and I'll see you
45:51 - again tomorrow in another video
45:59 - hey guys uh welcome back to another
46:01 - video this is the fifth video in my
46:03 - Python Programming series and today
46:05 - we're going to be talking about chained
46:07 - conditionals and nested if statements um
46:11 - so pretty much chained conditionals are
46:12 - just adding multiple conditions in one
46:16 - uh one line with using words like and
46:19 - and or okay uh we also have keyword not
46:23 - that we're going to talk about as well
46:24 - so if you haven't seen the last videos
46:27 - in my series go ahead and get watch
46:29 - those now because they are prerequisite
46:30 - for this video all right so let's get
46:33 - right ahead and start um so if you
46:35 - remember before we have something called
46:36 - conditions so for example if we have the
46:38 - variable X I'll set that to two and the
46:40 - variable Y which is equal to three we
46:42 - could have a condition like xal equal y
46:45 - now obviously we know from the last
46:47 - video that this is going to give us a
46:48 - value of
46:50 - false oops and I cannot type today sorry
46:54 - um and that is because two is not equal
46:57 - to three pretty straightforward I hope
46:59 - you have all understood that from the
47:00 - last video all right so what we want to
47:03 - do in this now is we're going to want to
47:04 - check multiple conditions um so we'll
47:07 - put a condition here so if x is equal to
47:10 - Y and then we can put a word in like
47:13 - this the and word um now we'll add
47:16 - another condition so if x +
47:19 - y is equal to 5 Okay so this first
47:25 - condition is going to give us a value of
47:26 - false so if x is equal to Y because they
47:28 - are not the same but now x + y does
47:32 - indeed equal 5 so that is going to give
47:34 - us a value of true so where I'm
47:36 - highlighting we have true and then where
47:38 - I'm highlighting now again we have false
47:41 - so because we have the keyword and this
47:43 - if statement is not going to run so I'll
47:46 - put a print here just to show you we're
47:49 - going to print out true or let's just
47:52 - say
47:53 - ran and you'll see when I run the
47:55 - program nothing is going to happen
47:56 - happen that is because when we use the
47:59 - and keyword it means both conditions on
48:01 - either side must be true so if we change
48:04 - this to something like if Y is equal to
48:08 - 3 now that is going to be
48:11 - true and we'll print out
48:14 - ran okay so that's pretty basic now
48:16 - let's do the or keyword so we'll put or
48:19 - right here and we'll change this
48:22 - condition back to if Y is equal to X and
48:24 - now take a guess on what you think is
48:26 - going to happen well pretty much with
48:29 - the or keyword it means either of the
48:32 - conditions have to be true so if Y is
48:35 - equal to X or x + y is equal to 5 then
48:39 - we are going to run this line now since
48:42 - X+ y does equal 5 we have a true here
48:45 - and again Y is not equal to X so we have
48:47 - a false and you'll see that the program
48:49 - is going to run that's because only one
48:51 - of the condition conditions has to be
48:54 - true for it to run
48:56 - okay so that is the and in the OR
48:58 - keyword they are pretty straightforward
49:00 - and pretty basic now I'd like to point
49:02 - out that you can actually add as many
49:05 - conditions as You' like so now I can
49:06 - have an or I can have an and um I could
49:09 - have another condition I could do as
49:11 - many as I'd possibly can imagine as many
49:13 - as I'd like to do um so now we'll put an
49:16 - lse statement in here and we'll change
49:19 - this just a little bit to use another
49:23 - keyword we'll just put a side face here
49:25 - to show that we didn't run it that we
49:28 - ran the else okay um so now there's
49:30 - something called the not word okay so
49:32 - we're going to put not right here around
49:34 - it and then I will show you what it does
49:36 - so pretty much not reverses anything
49:39 - that you have inside of the brackets of
49:42 - the knot so in here we have if Y is
49:44 - equal to X or x + y is equal to 5 so we
49:48 - know again that this gives us a value of
49:50 - true um so now since true is inside of
49:53 - the KN true becomes false now we have if
49:58 - false um so obviously that's going to
50:00 - bring us to the else statement um which
50:02 - is going to print the sad face so I'll
50:04 - show you that that does indeed work so
50:08 - we have the sad face right now if we
50:10 - change these so that both of these
50:11 - conditions are false you'll see that we
50:14 - have false false um which is going to
50:16 - give us an overall value of false um and
50:19 - then we're going to have the not which
50:20 - is going to change that into a true and
50:22 - will allow us to run it just like that
50:25 - ran um um so yeah so that's how the not
50:29 - the and and the ore work uh and now
50:31 - let's get into nested Loops or sorry not
50:34 - nested Loops Nest nested if statements
50:37 - so we'll do a basic if statement here if
50:39 - x is equal to
50:42 - 2 um if Y is equal to
50:46 - 3 um and then we'll add our
50:49 - El's like this and we'll put some print
50:53 - statements in here
50:58 - okay uh just give me a second while I
51:00 - type out the print statements and then
51:02 - we will go into what this is going to
51:06 - do x = 2 and Y = 3 um so you may have
51:12 - guessed already but pretty much we can
51:15 - actually add as many if statements
51:17 - embedded or nested as we'd like so I
51:19 - could add another if statement here and
51:21 - just constantly keep checking um now the
51:24 - reason I showed you chain conditionals
51:26 - is because if I didn't want to go
51:28 - through the hassle of adding all of
51:29 - these uh nested statements I could just
51:33 - do an and right here and check for
51:35 - another condition but sometimes we do
51:37 - want to do uh nested statements so we'll
51:39 - say here x = 2 y does not
51:44 - equal uh what is it
51:46 - three okay so uh I know I just did that
51:49 - pretty quickly but let's walk through it
51:50 - now so we have if x is equal to 2 then
51:54 - we're going to run whatever is in here
51:56 - because it is indented uh so now we come
51:59 - in here and we say well is y equal to 3
52:02 - let's say it is now we're going to print
52:03 - out this statement and we're going to be
52:05 - done with this loop with this uh bit of
52:08 - codes we're going to skip down to the
52:09 - end of the program where we have nothing
52:11 - else um then so let's say we do another
52:13 - example X is equal to 2 but y equal 4 so
52:17 - that means we're actually going to run
52:18 - the else which means now we've got print
52:21 - X is equal to 2 but y does not equal 3
52:25 - and then the last case is X is not equal
52:27 - to 2 so we don't even bother checking if
52:30 - Y is equal to 3 we just go down and we
52:32 - print X does not equal 2 so we'll change
52:35 - around the variables and we'll show you
52:36 - how this works just very
52:38 - quickly so we can see X is equal to 2
52:41 - and Y is equal to 3 that is because
52:43 - obviously up here two and three now if I
52:44 - want to change Y and we change it to
52:47 - four we get X is equal to two but Y is
52:51 - not equal to three so that means we ran
52:54 - this one in here now let's change it so
52:57 - that X is equal to 4 as
53:00 - well and we can see we get X does not
53:03 - equal
53:04 - 2 all right so that's uh the basics on
53:08 - nested statements and chained
53:10 - conditionals I hope you found this video
53:12 - helpful um stay tuned for more videos
53:15 - we're going to be getting into some more
53:16 - advanced topics and in the next video
53:18 - we're going to be covering
53:20 - Loops um yeah so if you like the video
53:23 - uh please subscribe and like and I'll
53:25 - see you in the next one
53:33 - hey guys welcome back to another video
53:36 - this is the sixth video in my Python
53:38 - Programming series and today we're going
53:40 - to be talking about for Loops again if
53:42 - you missed the other videos in the
53:44 - series please go back and watch them
53:45 - first as it's going to be hard to
53:47 - understand if you haven't seen them
53:48 - already Okay so let's get right into it
53:51 - today we're going to be talking about
53:52 - four Loops um and a loop is a new thing
53:54 - now if you're a beginner in Python and
53:56 - I'll talk about how they work we're
53:57 - going to start off by just writing one
53:59 - out um getting right into it with the
54:01 - syntax so 4X in
54:05 - range and then we're going to put a
54:07 - number which is going to be our starting
54:08 - position so in this case I'm going to
54:10 - put zero um and then a stop point so 10
54:14 - okay and then we're simply going to
54:16 - print out X now I know we did this
54:18 - pretty quickly but let's talk about what
54:22 - this is and the syntax so a for Loop is
54:25 - going to run
54:26 - a certain amount of times so in this
54:29 - case we're going to start at zero and
54:32 - we're going to go to 10 this means the
54:34 - for Loop is actually going to run 10
54:37 - times so what's going to happen is we
54:40 - are going to have our variable X which
54:42 - is right here and every time the for
54:45 - Loop runs X is going to be increased by
54:48 - one now we can increase it by more if
54:51 - we'd like to by adding another comma
54:53 - here but by default it is set to one
54:56 - like this I've just put it in so that
54:57 - you can visualize it so really we have
55:00 - something start a
55:03 - stop Oops stop and an end start stop
55:07 - step sorry my bad and I'll just put
55:09 - commas here to show you how it works so
55:12 - you can see we have our zero that's our
55:13 - starting number our stop which is 10 and
55:16 - our step which is going to be one so I
55:20 - know you don't quite understand yet but
55:22 - you will after I show you a few examples
55:24 - so we have X is our variable which is
55:26 - going to be holding the number um of
55:29 - what iteration we are through now
55:31 - iteration uh just means how many times
55:34 - we've already looped through this Loop
55:37 - okay so let's uh do an example here all
55:40 - right so we have X and we've just
55:42 - started running this for Loop now right
55:44 - now X is zero we're going to print X
55:47 - we're going to print zero to the screen
55:49 - and then we're going to add one to X now
55:52 - this time we come through the loop we
55:54 - say well is X less than 10 yes it is so
55:57 - now we're going to print x x is one now
55:59 - we're adding um two okay so now X is 2
56:03 - is 2 less than 10 yes 2 is less than 10
56:06 - so let's print two okay and we keep
56:09 - going until eventually we print nine
56:12 - then X has one added to it so it becomes
56:15 - 10 well 10 is not less than 10 so we're
56:18 - not going to print out 10 all right I
56:20 - know I just talked a lot there but let's
56:22 - see it in
56:24 - action all right so just like I said we
56:28 - print out the numbers 0 through 9 now
56:31 - this may seem weird um because I have
56:33 - the value 10 here so you'd say well why
56:35 - doesn't it print out 10 it's because of
56:37 - the way the loop works so like I said
56:40 - really what's Happening Here is this um
56:43 - plus equals 1 so pretty much this means
56:45 - we're just adding one to the variable X
56:48 - um you can also write it like this x =
56:51 - x + 1 like that all right so we print
56:55 - out X and then we add one to X and we
56:58 - have to be less than 10 for this Loop to
57:00 - run so on the ninth iteration we have
57:02 - well 9 is equal to 9 + 1 so X is equal
57:06 - to 9 + 1 uh we get the value 10 now
57:08 - again 10 is not less than 10 so we are
57:11 - not going to print out 10 um yeah so
57:15 - that's pretty much how a for Loop Works
57:19 - um it's pretty basic this is the syntax
57:21 - we have four and then a variable name so
57:24 - this doesn't have to be X we could use
57:25 - anything we'd like to use could use
57:27 - hello I could use um any other word it
57:31 - could be as long as I want as short as I
57:32 - want doesn't matter um then we have the
57:35 - word in which is highlighted in Orange
57:38 - and then range now the range takes a
57:41 - different amount of arguments pretty
57:43 - much an argument is whatever is inside
57:44 - this brackets so like at the beginning
57:46 - how I showed you we just did zero and 10
57:48 - this means we have a start and we have a
57:51 - stop so we start at zero and we go to 10
57:56 - now I can also I can actually put one
57:58 - argument in here like this 10 and that
58:01 - just means that we just have a stop so
58:03 - by default python will say well we're
58:05 - just going to start at zero and we're
58:07 - going to step by one now I haven't
58:09 - showed you the step yet so we'll do that
58:12 - um so again we're going to start at zero
58:13 - we're going to stop at 10 and we're
58:15 - going to step This Time by two now what
58:17 - step is is how much we add to X every
58:20 - time so before I showed you we had x = x
58:23 - + 1 um in this case since the step is is
58:26 - two it's going to be by two like that
58:28 - okay um so let's go ahead let's run
58:32 - this we have 0 2 4 6 8 and you notice
58:37 - how we again do not print out 10 because
58:39 - 10 is not less than 10 okay again uh
58:43 - we'll do another example with the step
58:44 - let's put five in this time now you can
58:47 - guess what's going to
58:49 - happen 05 it actually only prints out
58:52 - two things because we start at zero so
58:55 - we print 0 and then we add five we get
58:58 - five now 5 + 5 again is not less than 10
59:00 - so we are not going to print out 10 okay
59:03 - so that is the tutorial on the for loop
59:06 - we're going to do another type of for
59:08 - Loop where we're going to use something
59:09 - called a list a little bit later on but
59:11 - right now we're just using this one this
59:13 - is the basic one I encourage you to play
59:15 - around with it yourself um and yeah so
59:19 - if you like the video please go ahead
59:21 - and like it and subscribe and I will see
59:23 - you again for another video thanks
59:32 - goodbye hey guys welcome back to the
59:34 - seventh video in my Python Programming
59:37 - Series today we're going to be talking
59:39 - about wow Loops so in the last video we
59:41 - talked about for loops and before that
59:42 - we talked a lot about conditions um so
59:45 - it's going to be important to understand
59:46 - those things before we can move on today
59:48 - to this video so if you haven't seen
59:49 - those videos go back in my channel and
59:52 - check those out first okay so let's get
59:55 - right into it today we're going to be
59:56 - talking about while Loops so let's first
59:58 - of all just put an example down and get
60:00 - the syntax okay so we have while
60:04 - condition then we are going to do what
60:08 - is ever is inside the loop so it seems
60:10 - simple
60:11 - enough um but they can get fairly
60:14 - complex um so well condition is equal to
60:19 - uh
60:19 - true so for example this condition here
60:22 - this could be a variable um well that is
60:25 - equal to true then we're going to do
60:27 - whatever is inside of this Loop so again
60:30 - we keep talking about conditions um
60:32 - they're very important in Python we
60:35 - really need to understand them before we
60:36 - can move into more complex topics okay
60:40 - so uh well condition equal to true we're
60:42 - going to do whatever is in this Loop so
60:44 - how does this really
60:45 - work well uh pretty much what happens is
60:50 - we have the W Loop here we have the
60:51 - condition so this is true this means
60:53 - we're going to do this now what happens
60:55 - is we actually come back up to the top
60:56 - after we've done this and we say well is
60:58 - this condition still true um well yes it
61:00 - is so that means now we're going to do
61:02 - this again and we just continuously do
61:05 - this until eventually the condition is
61:07 - equal to false or we have a keyword
61:10 - appear called
61:12 - Break like this now I'll do an example
61:15 - so we can understand this but this is
61:16 - just the basic syntax we have while we
61:18 - have a condition and then we have a
61:20 - colon followed by an indented block
61:22 - which will be whatever is going to run
61:24 - okay so let's start off by using a
61:26 - variable we're going to just call it
61:27 - loop we're going to set it equal to true
61:30 - now we're going to make our while loop
61:32 - we're going to say while loop um Now by
61:36 - just putting a loop here it defaults to
61:38 - say while loop is equal to false um
61:41 - putting Loop there is the exact same
61:42 - thing as typing this um it's just
61:44 - shorter to put Loop instead of doing the
61:46 - equals equals true okay we're going to
61:50 - get some input from the console so we're
61:52 - going to say name is equal to input and
61:56 - then I'm just going to put in here uh
61:57 - insert
61:59 - something
62:01 - okay and then we're going to put an if
62:03 - statement which we talked about in
62:04 - another video so if you haven't seen
62:05 - that go back and check that out we're
62:07 - going to say if name is equal to
62:11 - stop um then we are going to break out
62:15 - of the loop by typing break or we could
62:18 - also do this we could set the condition
62:21 - equal to false so we set the variable up
62:23 - here equal to false now I know I just
62:24 - typed a lot there so let's um talk about
62:27 - what really is going to happen so we
62:29 - have our condition we say while loop is
62:31 - equal to True um right now we set it
62:32 - equal to True up at the top so it's
62:34 - going to automatically run at least once
62:37 - now we get input from the console um and
62:40 - store it in the variable name now we
62:42 - have a basic if statement here that
62:44 - pretty much says if name is equal to
62:46 - stop well then we're going to stop the
62:48 - loop um and we're going to break out of
62:50 - it otherwise we're going to keep asking
62:53 - the user for to insert something until
62:56 - eventually they type stop so let's see
62:58 - how this all
63:00 - works okay so insert something I say one
63:04 - 123 it didn't like that once me insert
63:06 - something again I say we okay what about
63:09 - hello keeps going okay now I'm going to
63:11 - type
63:13 - stop and you see that the program stops
63:16 - running okay so again I'll show you that
63:19 - we can do this by just setting the
63:21 - variable equal to
63:23 - false same thing again if I type hi
63:26 - keeps going I type stop it's going to
63:29 - stop and then maybe if we get rid of the
63:32 - variable here we can also just type in
63:34 - the word
63:35 - break like that and same thing again if
63:38 - I type in some random things and then I
63:40 - type stop it stops okay so pretty much
63:44 - the way that the break keyword works is
63:47 - by simply saying okay are we inside any
63:50 - Loops right now um it checks whatever
63:52 - Loop you're inside so right now we're
63:54 - inside the while loop and it says okay
63:56 - well I've this line has now run so what
63:58 - we're going to do is we're going to get
63:59 - out of the loop so it pretty much will
64:01 - now start reading from the next blank
64:04 - line in the file um meaning that it's
64:07 - going to get out of this Loop um and
64:10 - just continue going down the
64:12 - program okay and that's pretty much it
64:15 - for Wow Loops we can talk a little bit
64:17 - more about why we would use a w Loop
64:19 - instead of using a for Loop um the
64:21 - reason we might use a w Loop is for
64:23 - something like this so for example if
64:24 - you want to ask someone to insert a
64:27 - password so we have password like this
64:31 - um and we'll just change this variable
64:32 - with password so pass for short um and
64:36 - now maybe we wanted to check we wanted
64:38 - to say um well oops well let's just do
64:42 - password because pass is a keyword in
64:43 - Python I forgot about that um password
64:47 - and we want to make sure that the
64:48 - password has for example at least one
64:51 - letter in it well we're going to keep
64:53 - asking the user to re-input their
64:55 - password until it meets these certain
64:58 - criteria so for example it might have to
65:00 - have one Capital it might have to have
65:03 - one letter in it uh it may have to have
65:05 - a few numbers something like that right
65:07 - so we would keep asking the user for a
65:09 - password um until they gave it to us
65:11 - correctly now the reason we wouldn't use
65:13 - a for Loop for this is because a for
65:15 - Loop um usually we know how long we want
65:18 - to run the for Loop for um that's why we
65:21 - put a number in the range so for example
65:22 - we put 10 or we put 12 while as a w Loop
65:25 - we don't know how long we're going to
65:27 - run it for so for example someone could
65:29 - get the password first try like they
65:31 - could put it incorrectly um with the
65:33 - right criteria or it could take them 30
65:34 - tries right we don't know how long it's
65:36 - going to take them okay so that's it for
65:40 - today's video um if you like the video
65:42 - please like it and subscribe and I will
65:45 - see you again tomor tomorrow with a uh
65:48 - new
65:54 - video hey guys guys welcome back to the
65:56 - eth video in my Python Programming
65:59 - Series today we're going to be talking
66:00 - about lists now lists can be fairly
66:03 - complex uh but they are a very important
66:05 - part of python and they are very
66:08 - important to understand so a list is
66:10 - another data type so before we talked
66:13 - about strings integers booleans and
66:15 - floating decimal points so floats um and
66:18 - today we're going to talk about list so
66:19 - lists again are their own data type so
66:21 - let's just start off by doing an example
66:23 - right now so pretty much uh a list which
66:26 - is denoted by the square brackets here
66:29 - uh is a collection of different data
66:31 - types it could be the same data types or
66:33 - it can be different data types so for an
66:35 - example I'm going to put a apple in here
66:38 - in my list I'm going to put a comma and
66:39 - I'm going to add another item so maybe
66:41 - we'll put a pair and then maybe we'll
66:43 - put a number as well okay so we have the
66:46 - list fruits and in the list we have
66:49 - three items um now everything here
66:52 - separated by a comma is known as an item
66:54 - so for an example our apple is an item
66:58 - our pair is an item and the integer
67:00 - three is an item now you can see that
67:02 - they're all different data types or
67:04 - sorry there is different data types we
67:06 - have two strings and we have one integer
67:08 - value um now this is fine you can store
67:11 - um different data types in one
67:14 - list um okay so now let's just print the
67:17 - list to the console so we can see what
67:20 - it looks
67:21 - like print it out and you'll see we
67:24 - simply get what exactly what we we've
67:25 - typed uh into the idle so we get apple
67:29 - pair and 3 now if we want to access an
67:33 - individual item in the list we need to
67:35 - do something um a little different so
67:38 - right now we just printed out the whole
67:40 - list but say we want to just print out
67:42 - pair um now what we're going to do is
67:45 - we're going to use the square brackets
67:47 - so we're going to do the list name so
67:48 - fruits and then we're going to put
67:50 - square brackets right beside it no
67:52 - spaces and then inside of the square
67:54 - brackets we're going to type in what's
67:55 - known as the indic of that item um so
67:58 - the way indices work in Python is when
68:01 - you create a list everything is
68:02 - automatically assigned in indic um so in
68:05 - this list we have indices 0 through two
68:08 - now it may seem weird that we start at
68:10 - zero instead of one but that's just the
68:11 - way that computers count um and the way
68:13 - that they work so we have to understand
68:15 - that apple is going to be assigned the
68:17 - integer value of zero so the indic zero
68:20 - meaning I would put zero in here if I
68:22 - wanted to access Apple because that's
68:24 - the first element
68:26 - in our list and then we have pair so
68:29 - that's the second element or item um now
68:32 - that's actually going to be represented
68:33 - by one here so fruits one will give us
68:36 - the value of pair and then fruits two
68:38 - will give us the value of three um now
68:42 - this is uh sometimes difficult for some
68:44 - people to understand but just really try
68:45 - to remember that the first item always
68:48 - is zero so if you would like to access
68:50 - the second item in your list you're
68:53 - going to type in one um into to the
68:56 - indic thing here okay so I'm just going
68:57 - to run this and show you how this
68:59 - works and you see we get pair okay
69:02 - that's because um we have the first
69:04 - indic which represents the second item
69:08 - which is
69:09 - pair okay um now there's some other
69:12 - things we can do with list as well so if
69:14 - we want to add something to our list
69:17 - there's a few ways that we can do it um
69:20 - the first way uh which is the only one
69:22 - I'm going to show you right now is
69:24 - probably the easiest and simply what
69:25 - we're going to type is fruits followed
69:28 - by the dot uh so a DOT a period and then
69:31 - we're going to type a pend okay now this
69:34 - means to add to the end of the list so
69:38 - inside of a pen I'm going to put the
69:40 - element or the item that I'd like to add
69:42 - so say we want to add uh another fruit
69:45 - let's think of another fruit that we
69:46 - could add maybe a
69:48 - strawberry okay we want to add
69:50 - strawberry into the list I'm just going
69:51 - to get rid of three so it makes more
69:53 - sense okay so right now in our list up
69:55 - here we have fruits which is a variable
69:57 - name um containing the list that has
70:00 - Apple and pear now we want to add
70:02 - strawberry to the list so let's start
70:04 - off by printing the list before we add
70:06 - it so we'll print off fruits and then
70:09 - we're going to print fruits one more
70:11 - time after we add this item to the
70:16 - list and you see we have the first list
70:19 - which is what we defined originally and
70:21 - then when we added or appended
70:23 - strawberry to the end of it it added it
70:25 - in just like this so that is a way that
70:28 - we are able to add things into a list um
70:31 - by using dot append now there is another
70:35 - way um it's known as the slice operator
70:37 - using something called insert um but
70:40 - we're not going to do that right now
70:41 - we're going to talk about the slice
70:42 - operator in a later tutorial so stay
70:44 - tuned for that okay so fruits. append
70:48 - we've added strawberry um now if we
70:50 - wanted to add another item we could do
70:51 - the same thing and we could do append
70:53 - again and we could put in another fruit
70:56 - maybe we want to put in a blueberry okay
70:59 - just like that and again we'll see that
71:01 - it does the same thing we have apple
71:04 - pear and then apple pear strawberry
71:06 - blueberry okay um all right so that's it
71:10 - for adding to the list um now what about
71:14 - changing something in our list uh so
71:17 - let's just add right here at the
71:19 - beginning we'll put in Strawberry so we
71:22 - have three items and now let's say we
71:24 - want to change the middle item in our
71:26 - list to a different fruit say we don't
71:28 - like pairs we want to remove it we want
71:30 - to change that so what we're going to do
71:31 - is we're simply going to type the um the
71:34 - name again so fruits followed by the
71:36 - square brackets and then the indic of
71:38 - the item you want to change um so again
71:40 - remember if we want to change pair we're
71:42 - going to use the Indy one um not two
71:45 - because this is the way that it works
71:46 - we're going to use one and then we're
71:48 - going to change it to whatever we'd like
71:49 - to change it to so say I want to change
71:51 - it to Blueberry I can do that like so
71:55 - and then again we can print out fruits
71:59 - and we'll see if it
72:01 - works okay so we get apple blueberry and
72:04 - strawberry that's because we''ve changed
72:07 - uh the item at indic one into blueberry
72:11 - and we've replaced that we replaced Paar
72:14 - with blueberry pretty
72:16 - much okay um so that's how that works
72:19 - for list for changing items again um we
72:23 - you lists are very useful for storing
72:25 - large amounts of information so this is
72:28 - a very small list but in many programs
72:30 - we use something called
72:32 - multi-dimensional list uh which I'm
72:34 - going to talk about again in another
72:36 - tutorial um and yeah so one more thing
72:39 - before we end it here uh there's another
72:41 - data type called a tuple so a tupal um
72:45 - it's kind of hard word to pronounce but
72:46 - it's used for coordinates and it's also
72:50 - used um for things like colors and
72:53 - rectangles um it can also be used just
72:55 - to hold information as well but it's a
72:58 - different type of data type um than a
72:59 - list so we're going to talk about it
73:01 - quickly uh okay so a tuple pretty much
73:03 - looks like this so if we set a position
73:07 - and we set it equal to something like
73:10 - this not in square brackets in the
73:12 - regular round brackets and then we
73:14 - simply put um the items in like this now
73:17 - we see we get um it looks very similar
73:20 - to a list the way that it works again we
73:22 - can use different data types so I could
73:23 - put something like hello in here as well
73:25 - well um but it does function a little
73:27 - differently and again things like colors
73:29 - we would also store in a tuple so we
73:31 - would use like 255 255 255 that's simply
73:34 - white in uh red green blue colors and
73:37 - again if we print out the
73:39 - type of the
73:42 - color you can see that we get a class
73:46 - tupal okay so I'm not going to go too in
73:48 - depth with the tuples here I just wanted
73:50 - you to understand what they are because
73:52 - we may be using them in some later
73:53 - tutorials okay so I hope you learned how
73:55 - to use lists and a little bit about tups
73:58 - today they're going to be important in
73:59 - the next tutorial um so yeah I hope you
74:03 - enjoyed if you did please like And
74:05 - subscribe and I will see you in the next
74:12 - video hey guys welcome back uh today
74:15 - we're doing the ninth video in my Python
74:17 - Programming series and today we're going
74:19 - to be talking more uh more about for
74:22 - Loops so a more advanced type of for
74:24 - Loop in terms terms of iterating through
74:26 - a list so you may remember a few videos
74:28 - ago we talked about for loops and I
74:30 - mentioned that there are two main type
74:32 - of for Loops that we can use um and the
74:34 - one that we talked about there was
74:36 - looked like this so we had for X in
74:39 - range and then we had a range like this
74:43 - and we simply printed out the numbers
74:47 - like this so we see we got 1 to 10 just
74:49 - like that okay uh so that was the for
74:52 - Loop we talked about there um but the
74:53 - one we're going to be doing today is is
74:55 - a little bit different so I'll leave
74:56 - this here for an example uh so the first
74:58 - thing we need to do is we need to make a
75:00 - list because we're actually going to be
75:01 - iterating through every item or every
75:04 - element in the list so again I'm just
75:06 - going to use the same example I used in
75:08 - the other video fruits and I'm going to
75:09 - make it equal to we're going to have
75:13 - apples
75:15 - pears and strawberries strawberries just
75:19 - like that okay so we have our fruits
75:21 - here and now um we're going to get right
75:24 - into the syntax for this new for Loop so
75:26 - we're going to do four and then any
75:29 - variable name we'd like so in this case
75:30 - I'm going to use fruit and then we're
75:32 - going to use the keyword in once again
75:35 - and then instead of typing range this
75:37 - time we're going to type the name of the
75:39 - list we want to iterate through so in
75:40 - this case it's going to be called fruits
75:43 - just like that and now um we can print
75:48 - out the fruit sorry the fruit just like
75:52 - that so pretty much what is going to
75:55 - happen is we have a list with three
75:57 - items in it we have apples pears and
76:01 - strawberries now we want to print every
76:04 - fruit in that list so we do that by
76:07 - saying for fruit in fruits meaning for
76:10 - every item in fruits so one two and
76:14 - three items we simply want to print out
76:17 - that fruit so this Loop is going to run
76:18 - three times and we're just going to
76:20 - print out every fruit inside of the list
76:24 - just like this
76:26 - and there you go we have apples pears
76:28 - and strawberries just like
76:30 - that um so yeah that's pretty much how
76:33 - you can iterate through a list and same
76:36 - thing if I want to add more elements to
76:37 - the list so 8 um 90 just like that again
76:42 - it'll just simply print out all of the
76:44 - items in the
76:46 - list now uh why might we do this you say
76:49 - well there's a few reasons we may want
76:52 - to iterate by item rather than by indic
76:56 - so the other one uh the in range is
76:58 - known as iterating by indic or by index
77:01 - well this one is known as iterating by
77:03 - item so there's a few reasons we might
77:06 - want to do this but the first one is if
77:07 - we only want to print something out uh
77:09 - if it's a certain value so we just want
77:11 - to check through all of the items in the
77:13 - list and see if there are certain value
77:15 - and if they are then we're going to
77:16 - print it out or we're going to do
77:17 - something specific to that item uh so in
77:19 - this case I'm going to say if fruit is
77:22 - equal to for example
77:25 - pairs then I want to print
77:29 - out pairs so we'll just print out the
77:31 - fruit but if it's not equal to pairs so
77:34 - anything else then I will print
77:38 - out not pairs like that so this is an
77:42 - example of how we can look through every
77:45 - item in the list um and simply check if
77:48 - it is a certain value and then if it is
77:51 - we're going to print it to the screen so
77:52 - we'll try this and we see we have not
77:54 - pairs pairs and Then followed by a few
77:56 - more not pairs um so that's a good way
77:59 - to do it by item um otherwise we can
78:02 - still do this using Indy uh it's just a
78:04 - little more complicated or not as
78:06 - efficient so we could do
78:08 - 4X in range and then in this case we'll
78:13 - do zero and six because we have to do it
78:17 - six times because there's six items in
78:19 - the list and then we'll put a colon and
78:22 - then we'll say the same thing so except
78:25 - this time we're going to say if fruits
78:28 - followed by the square brackets and then
78:30 - X because this is going to be our indic
78:32 - equals equals pairs then we want to
78:37 - print fruit or fruit X
78:42 - oops otherwise we'll
78:45 - print not a pair just like we did in the
78:50 - other loop not a pair okay so we'll run
78:53 - that and we see we get it twice just
78:55 - because I had two for Loops there so it
78:57 - does work uh the exact same way except
79:00 - you can see that this one takes longer
79:02 - to write because we actually have to put
79:05 - the list name followed by the square
79:06 - brackets whereas in this Loop all we
79:09 - have to do is simply type in Fruit um
79:12 - because it's automatically going through
79:14 - the list um another reason too we may
79:16 - want to do that is because in this case
79:18 - we had to actually see how many items
79:20 - were in the list by counting um and then
79:24 - we had to put that number in whereas
79:25 - here it'll just stop at the end of the
79:27 - list automatically um now we could do
79:30 - this so Len this is a new word so I'm
79:33 - just showing this now uh this means
79:36 - length and then inside we can put
79:38 - something like a string or a list so in
79:41 - this case I'm going to put the length of
79:43 - fruits and that would give us a value of
79:46 - six and you'll see if I just get rid of
79:51 - this that it'll work the same way again
79:54 - um um by using the length of
79:57 - fruits okay so that is how to iterate
80:00 - through a list by item uh I hope you
80:04 - enjoyed if you did please leave a like
80:06 - And subscribe and stay tuned for more
80:09 - videos in this
80:16 - series hey guys welcome back today we're
80:19 - going to be doing the 10th video in my
80:21 - Python Programming series and today
80:23 - we're going to be talking about string
80:25 - Methods um so a method is simply
80:27 - something you can call on a string by
80:29 - using the delimiter of a period followed
80:32 - by whatever the method is and then
80:34 - brackets like this now sometimes we have
80:37 - to put some things inside of the
80:39 - brackets um but most of the time we can
80:42 - just leave them with empty brackets okay
80:45 - so let's get right into an example we're
80:46 - going to start by talking about the dot.
80:49 - strip method um now what this one does
80:52 - is it pretty much removes all of the
80:54 - leading and trailing white spaces from a
80:57 - word or from a string sorry so we'll
81:01 - start by just making a variable and
81:03 - we'll make it equal to the input from
81:05 - the console and we'll just say
81:08 - input something like
81:11 - that and then we're just going to print
81:13 - out our input so oops print out text do
81:19 - strip okay so again what strip does is
81:22 - just going to remove all the white
81:23 - spaces before and after the word and
81:25 - it's best to show you with an example um
81:27 - so you can see if we type a few spaces
81:30 - so 1 2 3 4 and then I type hello and
81:33 - then a few more spaces and I click enter
81:35 - it simply gives us hello that's because
81:37 - it had removed all of the spaces from
81:40 - the string while as if I don't have the
81:43 - dot strip here so if I get rid of that
81:46 - and we run it and I do some spaces again
81:48 - and I type hellow and some more spaces
81:50 - it's going to give us those spaces as a
81:52 - part of the string and most the time so
81:55 - when we have a string we want to remove
81:57 - these spaces so that's why we use do
82:00 - strip did I spell that right strip yeah
82:03 - just like that okay um all right so that
82:06 - one's pretty straightforward just
82:07 - removes these spaces now you may want to
82:09 - do this if you're checking um if a
82:11 - string is equal to a certain thing and
82:12 - you're getting a user input and they may
82:15 - have accidentally typed the space before
82:16 - or after the word right okay so now
82:19 - we'll move on to the Len um so this one
82:22 - is actually not a method because you
82:24 - don't call it using a DOT um using a
82:26 - period followed by the word it's
82:28 - actually known as a function which I'll
82:30 - get into later so this just means that
82:31 - it takes something inside of the
82:33 - brackets um so this stands for length
82:36 - Len and pretty much what it does is
82:38 - Returns the length of a string or of a
82:41 - list so right now we're going to use a
82:43 - string and we're going to put text in
82:45 - here and I'll show you again what it
82:47 - does um 1 2 3 4 5 remember although this
82:51 - is a number since I'm typing it in the
82:53 - console it actually gives me a string
82:55 - value so this will work and it says that
82:57 - the length of this is five again uh that
83:00 - one's pretty useful I used it in the
83:02 - last video um to determine how many
83:04 - times we had to iterate through a list
83:06 - because we got the length of the
83:08 - list all right now for lower so pretty
83:11 - much what lower does um is it turns
83:15 - everything into lower cases in our word
83:18 - um so again it's best to just show using
83:20 - an example if I type something like this
83:24 - uh uh with a few lower cases a few
83:26 - capitals and I click enter you see we
83:28 - get everything in lowercase
83:32 - letters all right and now for Dot Upper
83:34 - you can probably guess what this one's
83:36 - going to do it's the exact same thing
83:37 - except in this case everything is going
83:40 - to uppercase
83:42 - so like this and you see we get all
83:45 - uppercase
83:47 - letters all right um and now for the
83:51 - last string method that I'm going to
83:52 - talk about although there is T tons of
83:54 - different string Methods um there's
83:56 - probably over 40 or 50 I'm going to
83:58 - leave the link down below to all of the
84:00 - string Methods on the python website so
84:02 - you can go check them out if you'd like
84:04 - to see some more um so this one is
84:06 - called do spit now this one I'd say is
84:08 - probably one of the most useful methods
84:10 - that I um that I use all the time and
84:13 - what it does is it actually creates a
84:15 - list out of the string that you give it
84:19 - um so inside of these brackets you're
84:21 - going to put what's called a delimiter
84:23 - and what a delimiter is is pretty much
84:26 - what you want to split by so for example
84:29 - I'm going to put a period in here just
84:30 - so we can get an example so we have text
84:34 - dosit and inside of the brackets for dos
84:37 - split we have a period so it's best to
84:39 - just show an example oh invalid syntax I
84:42 - think I have one too many brackets there
84:44 - yes I do okay so we'll run it so I input
84:47 - something I'm going to type
84:49 - hello.
84:51 - tim. by. High just a few random words
84:55 - and you can see they're all separated by
84:57 - a period or by a DOT now when I click
85:00 - enter you see we actually get a list
85:04 - with all of the words and you notice
85:06 - that we don't actually have a period in
85:09 - this list that's because the way that do
85:12 - split works is it gets rid of the
85:14 - delimiter so since the delimiter was a
85:16 - period it's not going to include the
85:17 - period in this list now this may be kind
85:20 - of confusing um we'll do a few more
85:22 - examples so hope you hopefully you can
85:24 - understand
85:25 - so usually what you do um is you would
85:28 - you you would leave these uh brackets
85:30 - blank so you wouldn't put anything in
85:31 - them and by default Python's going to
85:33 - say okay well I guess you want to
85:35 - eliminate by a space um so the way that
85:38 - we can do this again um what'll happen
85:41 - is if I type a sentence like my name is
85:44 - Tim um and I click enter you see it
85:47 - separates by spaces and we have no
85:50 - spaces in our list because it removes
85:53 - those spaces now you could also
85:55 - diiminate by anything you like so I
85:57 - could do an a for example um now if
86:01 - click F5 and we just type a bunch of
86:03 - letters and I put an A and then another
86:05 - a you see we get um the letters and
86:08 - again there's a space at the end because
86:10 - I typed a space right um so yeah okay so
86:14 - that's how dot split works now splits
86:17 - very useful um if you want to do certain
86:20 - things with a list we're going to talk a
86:21 - bit more about it later on um but those
86:24 - are some basic string Methods that we
86:26 - talked about today again there are tons
86:28 - more on the python website which I will
86:30 - link down below um if you like the video
86:33 - please like And subscribe and I will see
86:35 - you again
86:42 - later hey guys welcome back to the 11th
86:45 - video in my Python Programming Series in
86:47 - today's video we're going to be talking
86:49 - about the sliced operator um which is a
86:52 - cool thing that we can use on lists and
86:54 - and strings in Python so if you remember
86:56 - in the previous video if we wanted to
86:58 - access an element in our list we did
87:01 - fruits so the name of our list here
87:02 - which I've already got defined as apples
87:04 - pear and strawberry um and then we would
87:06 - do the items so for example fruits one
87:09 - and we can print that to the screen um
87:11 - just to remind us what this
87:14 - did and we got pair just like that
87:17 - because that is the second item but to
87:19 - reference that we have to use one
87:21 - because in computers we start at zero
87:22 - right um okay yeah and I just wanted to
87:26 - mention I didn't don't think I did this
87:27 - in the list video that you can actually
87:29 - do this on strings as well so say I
87:31 - wanted to access the E there I would
87:33 - just do text one and we get the E
87:36 - because that is the second uh item in
87:38 - this string or character maybe I wanted
87:41 - to do the 11th
87:43 - one then that would give us another E
87:45 - because 11 is right here at the end of
87:47 - like so yeah now what does the slice
87:50 - operator look like so pretty much the
87:52 - slice operator is these two square
87:54 - brackets but inside of them you're going
87:56 - to put two colons just like this now
88:00 - these colons in between them we type
88:02 - some words uh or we're going to put some
88:04 - numbers but in this case I'm just going
88:05 - to show you with words so we have start
88:08 - stop and step um that's what goes where
88:12 - these colons are now if I remove this
88:14 - colon that means I just have a start and
88:16 - a stop and then if I remove this colon I
88:18 - just have a start and that's how we
88:20 - reference what element we want to uh we
88:23 - want to print out right right if we had
88:24 - just put a number there so we'll add the
88:26 -  back in and this now we're going to
88:27 - use numbers so the start stop and step
88:29 - works exactly the same way as the range
88:32 - function so you may remember when I did
88:33 - a for Loop we did 4X in range and then
88:37 - inside of the range we did some numbers
88:39 - like this so we would start at one stop
88:41 - at two and step by three like that right
88:44 - so it works the exact same way except in
88:46 - this case we're going to be using um it
88:48 - on lists and on strings right without
88:51 - these numbers so the range like this
88:54 - okay so let's just do an example um so
88:57 - let's start at zero and let's end at
89:00 - this o so the O is 1 2 3 4 five um but
89:05 - if I want to actually include the O I
89:07 - have to put five because remember five
89:09 - would be the space here um and if we
89:12 - stop on let's say four here you'll see
89:14 - what's going to happen um it's not going
89:16 - to print out the O uh because when we
89:19 - stop we do not include that number
89:21 - remember from the range function so if
89:22 - we want to have the O we'll stop at five
89:25 - just like that hello um okay yeah uh now
89:29 - if we wanted to start just from the
89:31 - beginning say we didn't know um all we
89:34 - have to do is just put nothing there and
89:35 - it's going to default start from the
89:37 - beginning so it'll give us the same
89:38 - thing and then if we wanted to start
89:41 - from somewhere so say we want to start
89:42 - at two and we just want to go all the
89:44 - way to the end now we say we don't know
89:47 - how long our string is we don't want to
89:48 - count all of these things and say oh
89:50 - well let's stop at 17 or whatever number
89:53 - it may be by just leaving this blank
89:56 - it'll actually default to stop at the
89:58 - end of the string and you'll see that so
90:00 - we get l l o I like python right it
90:02 - stopped at the end of the string
90:05 - automatically okay so now let's talk
90:07 - about the uh the step feature so if we
90:10 - want to start at the beginning and we
90:12 - want to stop at the end we'll just put
90:14 - nothing in between these two colons
90:16 - because it's going to default from the
90:18 - beginning and default to the end but now
90:20 - we want to skip every other letter that
90:22 - means we're going to put a two here for
90:24 - the step so that way we're going to get
90:26 - h l o then we're going to skip the space
90:30 - here we're going to get I skip the space
90:31 - get L and so on so I'll show
90:34 - you and you see we get that um a bunch
90:37 - of gibberish like this maybe you want to
90:39 - go every third letter that means we
90:41 - would step by three like
90:43 - this and there we go we get a few less
90:46 - letters and same thing we could do four
90:47 - five um and continually going now say we
90:50 - want to start at the third letter or the
90:54 - fourth because we're typing three here
90:55 - so L um we want to stop at the end and
90:57 - we want to step by
90:59 - three then you can see what's going to
91:01 - happen there so we get l i i TN right so
91:05 - a bunch of gibberish okay now this works
91:07 - again same thing for fruits uh it just I
91:09 - don't have as many items in the fruits
91:11 - list so that's why I was showing you
91:12 - with text but if I put the colon in here
91:15 - and we put another colon uh let's say we
91:17 - start at let's start at one so that
91:19 - means we're going to start at pair and
91:21 - let's just go to the end and we'll print
91:23 - that out and again we get Paar and
91:25 - strawberry so we didn't include the
91:27 - apples because we started at pear right
91:31 - so yeah that's pretty much how the slice
91:33 - operator works now there is one other
91:34 - cool thing we can do with the slice
91:36 - operator um and it's called the insert
91:39 - function or the insert kind of uh thing
91:41 - with the slice operator so if you
91:42 - remember uh we H when we wanted to add
91:44 - something to a list we use dot append
91:48 - right so I showed you that in my list
91:50 - video we did fruits. append and then
91:53 - maybe we want to add blueberries like
91:55 - this I know that's spelled incorrectly
91:57 - but there we go we'll fix that quickly
92:00 - blueberries okay and then we can print
92:03 - out fruits once again just to see what
92:05 - it looks like so if you remember this
92:07 - just adds it to the end of the list but
92:09 - say we don't want to add blueberries to
92:11 - the end of the list we want to add it in
92:13 - between Pairs we want to add it in
92:14 - between Apples and pear um we want to
92:17 - add it at the beginning we want to add
92:18 - it somewhere else right how would we do
92:20 - that well we can use the slice operator
92:23 - to do that so instead of using the dot
92:25 - of pend we'll use a slice operator so
92:27 - we'll go like this and this time we're
92:29 - going to just put one callon and then
92:31 - type the indic see where we want to
92:33 - insert it so if we want to insert it at
92:35 - the beginning we're just going to type
92:36 - zero and then zero like this we do need
92:38 - to do them on both sides and then an
92:41 - equal sign and we'll set it equal to
92:42 - whatever you want in this case we'll
92:43 - just put B for
92:44 - Simplicity and you'll see we get B at
92:47 - the beginning of our list now say we
92:49 - want it in between Apples and pear well
92:52 - in that case we would put one and we put
92:54 - one again like
92:56 - this and we get apples comma B comma
92:59 - pear comma strawberries just like that
93:01 - now if we want to add it to the end um
93:04 - we would have to find out what number
93:05 - that is so we do 3 three I believe that
93:07 - should work we'll
93:10 - see yeah so that adds it to the end for
93:13 - us um and then if we want to insert it
93:16 - in between pear and strawberry we would
93:17 - do 2 two like that and there we go we
93:21 - get it in between there so that's how
93:22 - the insert works for the slice operator
93:25 - um I hope you learned how to use a slice
93:27 - operator today we will be using it a
93:29 - little later in some other videos and
93:31 - doing some more complex things with it
93:33 - um if you liked the video please like
93:35 - And subscribe and I will see you again
93:38 - in the next
93:44 - one hey guys welcome back to another
93:47 - video this is the 12th video in my
93:49 - Python Programming series and today
93:52 - we're going to be talking about
93:53 - functions so this is a function up here
93:57 - um we're going to talk more about the
93:58 - syntax and what a function does but it's
94:01 - first important to understand what is a
94:04 - function well if you're in math you know
94:06 - that a function pretty much you pass it
94:08 - an x value and then it does something to
94:10 - that x value and you get a yalue back
94:13 - well it's a similar idea here in Python
94:15 - except there's different types of
94:17 - functions that can do different things
94:19 - so the first function I've just written
94:21 - right here um pretty much I've named it
94:23 - add two and what happens is we give it
94:25 - an x value and then it simply returns x
94:29 - + 2 now this doesn't have to make sense
94:31 - to you right now I just want to show an
94:33 - example of what a function looks like so
94:35 - if we wanted to make our own function
94:37 - what we would type is we'd type DF this
94:40 - stands for definition um and then the
94:43 - function name so maybe in this case I
94:44 - want to do another math related function
94:46 - so I'll do
94:48 - subtract two and oops two as a word and
94:53 - then I'm going to put two brackets and
94:54 - inside of the brackets we're going to
94:56 - put something that's called a parameter
94:58 - so in this case I can name it anything I
95:00 - want I'm going to put number in here and
95:02 - then I'm going to do a colon click enter
95:06 - it should tab me in one space and I'm
95:08 - simply going to return X or sorry number
95:13 - minus
95:14 - 2 now I'm I'll talk about what all this
95:17 - really does um a little bit later but I
95:19 - just want to give some examples so now
95:21 - if we want to call our function or want
95:23 - to actually use these functions we have
95:26 - to do something we can't just leave it
95:27 - like this I'll show you if I run this
95:29 - right now nothing's going to happen what
95:31 - we actually have to do is we have to do
95:33 - a um call statement so what I can do is
95:36 - I can do add
95:38 - to and then in here we have a parameter
95:42 - X but what's actually going to happen is
95:45 - I have to give add to a number because
95:48 - we're going to add two to that number
95:49 - and it's going to be returned so let's
95:52 - say seven
95:54 - now you'll see what's going to happen
95:56 - here uh I'll run it quickly and nothing
95:59 - prints out to the screen that's simply
96:01 - because we haven't printed anything what
96:04 - actually happens is in this add to call
96:06 - statement we have it sets x equal to 7
96:09 - so it comes up here and it says okay
96:10 - we're going to add two to S so we have X
96:13 - here we add two and then we're going to
96:16 - return that back down here so pretty
96:19 - much we call this function and it
96:21 - returns it right here now I have to set
96:23 - this equal to a variable or simply print
96:26 - it out to the screen so I'll set it
96:27 - equal to a variable right now so I'll
96:28 - say new number is equal to add to 7 and
96:33 - now if I print
96:35 - out new number like this we get nine
96:41 - okay so that that's how that works all
96:43 - right now what about subtract two so we
96:45 - can do the same thing here with seven so
96:47 - we do subtract two we'll leave seven in
96:51 - here for number
96:54 - and you'll see we get five so that works
96:57 - correctly now I can do it again I could
96:59 - do
97:00 - 12 and we get 10 and maybe I could even
97:03 - change what I want to do in these
97:05 - functions so this one's called add two
97:07 - but maybe I wanted to add two to X and
97:11 - then I wanted to square it so then I
97:14 - would do that and then if we go back to
97:17 - the add two so I'm going to put 12 + 2^
97:20 - 2 which should be 14 squar which will be
97:22 - a pretty big number which will give us
97:24 - 196 just like that so you can kind of
97:27 - see um and understand how these
97:29 - functions are working they have a
97:31 - parameter this is what that's called up
97:33 - here so a variable name I could do X I
97:35 - could do y I could do Zed doesn't matter
97:38 - I can do any letter I want any name I
97:40 - want um it makes sense to call it
97:42 - something that makes sense in terms of
97:44 - the function so here x works fine but if
97:46 - I was doing a string so maybe we want to
97:48 - write another function let's let's do
97:50 - another function here and we'll do
97:52 - Define and we'll call we'll say
97:55 - print
97:56 - string and now inside of here I'm just
97:59 - going to put string like that as our
98:02 - parameter name and then we're simply
98:04 - just going to print the string to the
98:07 - screen so now what actually happens is
98:10 - instead of setting something equal to a
98:12 - variable all I have to do is I have to
98:14 - do print string this is my call
98:16 - statement and then in here I'm going to
98:18 - give it a string so I'm just going to
98:19 - type
98:21 - hello and you'll see if we run the
98:23 - function
98:24 - we get hello and we didn't print it down
98:26 - here we just printed it from the
98:28 - function so I know I've gone kind of
98:31 - fast but the easiest way to understand
98:33 - the functions are to show examples of
98:35 - them and how they're working pretty much
98:37 - there's a
98:38 - parameter I'm going to give the
98:40 - parameter I'm in the argument of the
98:42 - call statement so this in the definition
98:45 - of the function is called a parameter
98:48 - and in the call statement in between the
98:51 - brackets it's called an argument
98:53 - um so those are just some key words now
98:56 - I can actually use these functions as
98:57 - many times as I want so I can print
98:59 - string again and I could
99:01 - print my name is Tim just like that and
99:04 - you'll see it should do it twice yeah
99:05 - there we go so that's why these
99:08 - functions are extremely useful because
99:10 - say for example I'm writing a big
99:12 - program and I know that I would need to
99:14 - do a certain thing multiple times well I
99:17 - don't want to have to constantly write
99:19 - it out um in the main line of my program
99:21 - here when I can just have a function
99:23 - that's going to do it for me and all I
99:25 - have to do is call that function using a
99:27 - simple call statement like this so we
99:29 - haven't really done many big programs
99:31 - yet where functions make sense but
99:33 - you'll see when you start programming
99:34 - that you're going to be using a lot of
99:36 - functions um to do things because you're
99:38 - going to be repeating code um now these
99:40 - are very basic functions we have
99:42 - subtract two add two but you can have
99:45 - like physics functions for example if I
99:47 - know I'm need to find the uh
99:49 - acceleration of an object then maybe I
99:51 - would make another function here and i'
99:53 - do
99:54 - Define excel I'll just do like that uh
99:57 - short form and then I'll put in mass and
100:01 - the force like that so you see I can
100:03 - actually have more than one um parameter
100:07 - I can have two parameters here and I'm
100:08 - going to say a is equal
100:11 - to mass Time Force I know that's not
100:15 - correct but we could do something like
100:16 - that mass time
100:18 - force and then I could return the
100:21 - variable a and now if I I called my
100:24 - Excel function and I printed that to the
100:26 - screen well that would give me what the
100:28 - acceleration would be right um so that
100:30 - those are just some examples of why
100:32 - functions are extremely useful well
100:34 - we're going to talk more about functions
100:36 - I'll do a more advanced tutorial um a
100:38 - little later on but this is just an
100:40 - introduction so that you can hopefully
100:42 - understand how they work pretty much you
100:43 - have if you're writing a function you
100:45 - have the deaf keyword um you have the
100:49 - function name so this case it's
100:51 - highlighted in blue so I did add two
100:53 - then you have brackets and say for
100:56 - example when we do a function we can
100:58 - actually do one without a parameter so I
100:59 - could do Define do something and in
101:04 - here I could simply print high right I
101:09 - don't need to have any parameters that
101:11 - just means when I call this function
101:13 - so do something I don't put anything
101:16 - inside of the brackets right we just do
101:18 - this and we see hi hello my name is Tim
101:21 - right um so yeah doesn't have to have
101:24 - parameters it can have multiple
101:25 - parameters um if for example in this
101:27 - acceleration function you have multiple
101:29 - parameters that means that when you call
101:31 - the function so I'll do an example here
101:34 - then you're going to have to put two
101:35 - numbers in or two strings so I do 2
101:38 - comma 5 like that and we'll print this
101:42 - to the to the screen because we don't
101:43 - print it in that function so we can see
101:45 - what we're
101:47 - getting so yeah we get hi hello my name
101:50 - is Tim and then 10 right so acceleration
101:53 - 2 okay um so yeah that's just the basics
101:56 - of functions we're going to talk more
101:58 - about them uh in more in depth later but
102:00 - just try to understand how they work and
102:02 - yeah so if you like the video please
102:04 - like And subscribe and I will see you
102:06 - again
102:12 - later hey guys welcome back this is the
102:15 - 13th video in my Python Programming
102:18 - series and today we're going to be
102:20 - talking about reading from a file so
102:22 - specifically a text file and we're going
102:25 - to be using something called
102:27 - file.io in Python so the first thing we
102:30 - need to do before we can read from a
102:31 - file is we need to create a file so I'm
102:34 - just simply going to go and find the
102:36 - directory where my python tutorials are
102:39 - so oops not here they are right here in
102:42 - the tutorials folder um and now you see
102:45 - I've got all my python uh scripts right
102:47 - here and all I'm going to do is I'm
102:48 - going to right click and I'm going to
102:49 - click
102:50 - new and then I'm going to find text
102:53 - document like that now I can name it
102:55 - whatever I like I'm just going to name
102:56 - it file for right now file. text now you
103:01 - may want to populate the uh text
103:03 - document so put some words in here so
103:05 - I'm just going to put a bunch of
103:06 - different words hello Tim
103:09 - python Learning Easy just some random
103:13 - random words in my text file I'm going
103:14 - to save that um and now we can go to
103:17 - reading in the text file so it is
103:21 - important that when you make the text
103:23 - text file you do have to save it in the
103:25 - same directory as your python script so
103:29 - if I were to put the text file here on
103:30 - my desktop and I have my python script
103:33 - in the tutorials folder here it's not
103:34 - going to be able to find the file
103:36 - properly um you would have to do
103:38 - something which is a path joining which
103:40 - I'm not going to talk about in this
103:41 - video but maybe in a later one so make
103:43 - sure that you save your file in the same
103:45 - directory uh and same folder as where
103:48 - your script is okay so now that we've
103:51 - done that we're going to read from the
103:53 - file so the first thing we need to do is
103:55 - we need to create a variable so we're
103:56 - going to name this file you can name it
103:58 - whatever you'd like and you're going to
103:59 - set it equal to the keyword open and
104:02 - then inside of open all you're going to
104:04 - do is you're going to type the name of
104:06 - your file so file. text a comma and then
104:10 - the mode you want to open your file in
104:12 - so in this case we want to read it so
104:14 - we're simply going to put a lowercase R
104:17 - inside of the quotations just like that
104:20 - and now that's pretty simple that's all
104:22 - you have to do in python to open up the
104:24 - file and to prepare to read it now make
104:28 - sure you do put R in here if you put
104:30 - nothing or you put a W for example which
104:32 - would be write mode it's actually going
104:34 - to clear the whole file which you don't
104:36 - want to happen you want to leave the
104:38 - contents of the file in there right so
104:39 - we need to open it in read mode with
104:41 - this R that's very important um now what
104:44 - we're going to do is we're simply going
104:46 - to read all of the things from the file
104:47 - so we've opened the file now we need to
104:49 - read it so in order to read the file uh
104:53 - we have to type a few things so we can
104:55 - do it in multiple different ways the
104:56 - first way I'm going to show you is this
104:57 - so I'm going to make another variable
104:59 - I'm going to call it f and this one
105:00 - we're going to make it equal to file.
105:03 - read
105:05 - lines like this okay and then we can
105:08 - simply print out F just to show you
105:11 - what's going to happen you see we get
105:14 - all of the words that are in the file
105:17 - now there's an interesting thing here
105:18 - you may notice that there's a back sln
105:22 - attached to all of the words except for
105:24 - the last one that's because I'm going to
105:26 - open up the text file again and show you
105:28 - um you notice here I didn't actually
105:30 - type back sln but every time we click
105:32 - enter like this it actually creates
105:35 - something called an escape character
105:37 - which is that back sln so if we want to
105:40 - read in the file we're going to have to
105:42 - remove that um character afterwards
105:44 - right so it's just something to keep in
105:46 - mind that if you have things on
105:47 - different lines each of the end of the
105:49 - lines is going to have a back sln on
105:52 - that line that you don't actually see
105:53 - here in the text document but python
105:55 - will read that
105:57 - in okay so we don't need to save that um
106:00 - yeah so let's move into the second way
106:03 - to read it properly now so we have f
106:05 - equals file. read lines now we want to
106:08 - remove all of these back slashes uh get
106:10 - rid of these ends from our lines so
106:12 - there's a way we have to do that and
106:13 - it's by using a for Loop so we're going
106:15 - to do a for Loop just going to say for
106:19 - line in F because now F has read all of
106:23 - our lines so we're going to do what's
106:25 - called iterating by item if you remember
106:27 - from my other videos so each line so
106:29 - every item in this F list here that just
106:32 - created by file. readlines we're going
106:34 - to remove that character and we're going
106:36 - to create a new list so let's make a new
106:39 - list we'll call it new list just make it
106:41 - a blank list like this new list and then
106:46 - here we're going to say um what is it
106:50 - new list. a p and if you remember what a
106:54 - pen does that simply means add to the
106:55 - end um of this new list and then we're
106:58 - going to add the line and we're going to
107:01 - use the slice operator to remove that
107:03 - back sln so we're going to Simply do the
107:06 - colon and
107:07 - then1 now what this does is we it will H
107:11 - take all of line except for the last
107:14 - character so negative one um I didn't
107:17 - talk about this in the other video but
107:19 - negative 1 pretty much just goes to the
107:21 - last character but does not include the
107:23 - last character when you do negative 1
107:24 - like this so just just follow along for
107:26 - now you don't have to completely
107:27 - understand it but just put that negative
107:28 - one and now if I print out new list
107:31 - we'll see what we get new
107:34 - list F5 and you see we get rid of all of
107:39 - the back slash ends now we have one
107:41 - issue here um down here on ease uh it
107:44 - should say easy but we've actually
107:46 - removed the last back sln from that
107:49 - string so if we don't want to do that
107:51 - now we need to actually add an if state
107:52 - statement into our for Loop so inside of
107:55 - the for loop we're going to type if and
107:57 - then we'll say line and we'll put a
108:00 - negative 1 again to represent the last
108:02 - character in that line equals equals
108:06 - back
108:07 - sln and then we'll simply tab this in
108:09 - because remember everything in Python
108:11 - needs to be indented properly for it to
108:13 - be read um and now we'll try this and
108:15 - we'll see if this
108:17 - works and there we go so we got hello
108:19 - Tim Python and learning but now we
108:21 - forgotten one thing we haven't actually
108:23 - included easy so now we need to do an
108:26 - else statement so we have else and then
108:28 - we'll do new list do append and we'll
108:32 - simply append the line just like that
108:36 - and now we can print it out and we will
108:37 - see what happens and we get hello Tim
108:41 - python learning and easy now there is an
108:44 - easier way to do this I just want to
108:45 - show this example because you may want
108:47 - to do something where you're checking
108:49 - through all of the lines and you want to
108:51 - see if the last character maybe the
108:53 - first character is equal to a certain
108:55 - item and depending on what that string
108:57 - is or depending on what it is you may
108:59 - want to add it to a new list you may
109:01 - want to do something to it so I just
109:02 - want to show you a way that we can do
109:03 - that pretty much this is iterating
109:06 - through every line in the file so file
109:09 - here so F creates a list of every line
109:11 - and then we go through every line of it
109:13 - and we see we say if the end of it has
109:15 - this back sln then we're going to remove
109:18 - the back sln um otherwise we'll just add
109:21 - that line into our list right
109:23 - okay so now the easier way that we can
109:25 - do this is actually with something
109:26 - that's called The Strip string method so
109:29 - in my other video I talked about this
109:30 - strip method that removes the spaces but
109:33 - what we can actually do with this uh is
109:36 - we can remove what do you call it sorry
109:38 - we can remove the back sln with the
109:40 - strip method as well so all we have to
109:42 - do here now it's a lot simpler is do new
109:45 - list do append and then inside of here
109:48 - we're simply going to type line. strip
109:51 - and now this will automatically remove
109:53 - those back SL ends and we'll see if this
109:56 - works there we go so we get everything
109:58 - and you can see it's a lot simpler and
109:59 - we don't even have to do the if
110:01 - statement um for the easy like that so
110:05 - that pretty much is how you read a file
110:08 - in using python there are some other
110:10 - ways to do this but this is the most
110:12 - basic and easiest way to understand
110:14 - we've also talked about how to remove
110:16 - that it's called an escape character at
110:18 - the end of the string that back sln and
110:20 - in the next video we're going to talk
110:22 - about writing to a file I hope you
110:24 - learned something if you did please like
110:26 - And subscribe and I will see you again
110:28 - in another
110:34 - video hey guys and welcome back today
110:37 - this is the 14th video in my Python
110:40 - Programming series and we are going to
110:42 - be talking about writing to a file so in
110:44 - the last video we talked about reading
110:46 - from a file and now we're going to be
110:48 - writing to it so the first thing we need
110:49 - to do is create a file so we already
110:52 - have a file created here called file.
110:54 - text I did that in the last video and
110:56 - inside we have nothing so I'm just going
110:58 - to put the word hello in here so that we
111:00 - can test something out later okay now it
111:02 - is again important that you have this
111:04 - file in the same directory as your
111:06 - script so tutorial 14 which is the
111:08 - script I'm using right now uh is in the
111:10 - same directory that's important
111:12 - otherwise python will not be able to
111:14 - read that file properly okay so now
111:17 - we're going to do the same thing we did
111:18 - in the last video we're going to do file
111:20 - is equal to open the file name so in
111:22 - this case file. text oops that has to be
111:25 - the lowercase my bad file. text and the
111:29 - mode so in the last one we used R but in
111:31 - this case we're going to use W and that
111:33 - stands for right now there's one thing
111:36 - we need to do which I forgot to do in
111:37 - the last video and that is close the
111:39 - file so we do need to actually close the
111:42 - file so that it saves our changes which
111:44 - I forgot to do in the last video and
111:46 - it's very important that we do that so
111:47 - my apologies but here we go file. close
111:51 - and again if we had changed this name to
111:52 - anything else then we would do that name
111:54 - do close because the file is contained
111:56 - in the variable file like that okay so
112:00 - now we want to write to the file so all
112:02 - we have to do is type the variable name
112:04 - so file and then do write which is very
112:06 - simple and inside here I'll put a new
112:08 - word I'm going to put python like that
112:10 - now before we run it let's notice what
112:12 - is inside of our file. text so in here
112:16 - we have the word hello now I'm going to
112:18 - run the
112:20 - script and nothing happen here obviously
112:23 - because we just wrote to the file but
112:24 - when we open the file again you see now
112:27 - it says python now what actually
112:29 - happened was we removed the word that
112:31 - was in there before so hello and we over
112:34 - wrote it with python so what happens in
112:37 - this mode here W is it actually clears
112:40 - the entire entire file and then it
112:43 - writes what you want to write to it so
112:45 - if you have this W here it is going to
112:47 - clear the entire file now there's a way
112:49 - to get around this but I'm not going to
112:50 - be showing that in this video today
112:53 - okay okay so let's write something else
112:55 - to our file so file.
112:57 - write and then I am learning how
113:02 - to write to a file just like that and
113:07 - again we'll run the
113:08 - script and we'll open the text
113:12 - file and you see we get everything here
113:14 - on the same line so that's okay um but
113:17 - you may want this to be on different
113:19 - lines so how would we do that well if
113:22 - you're remember from the last video
113:24 - there was something called an escape
113:25 - character that we got when we read in
113:28 - the file we had that little back sln
113:30 - attached now that's the same thing we
113:32 - need to do when we're re writing to the
113:34 - file if we want things to go on a
113:35 - different line so on this line here I'm
113:37 - going to type the backs slash and then
113:39 - the
113:40 - N uh and now what's going to happen is
113:42 - it's going to have this Escape character
113:44 - which is going to tell python we need to
113:45 - move to the next line and then it is
113:48 - going to type this right here so we can
113:51 - show what's going to happen here we go
113:54 - F5 and then if we open up the file once
113:56 - again you see Python and then I am
113:58 - learning how to write to a file so that
114:00 - happened again because we use that back
114:02 - sln the Escape character now same thing
114:05 - we could use this in between uh a line
114:07 - so if we wanted to write a large thing
114:09 - and we want it on different lines then
114:10 - we can put the Escape character in there
114:12 - like
114:13 - that same thing open the file again and
114:16 - we'll see what happens and we see we get
114:18 - it on a different line so that's how you
114:20 - can write things to a different line uh
114:23 - now this has been a pretty short video
114:25 - today but that's really all it is uh to
114:28 - writing something to a to a file in
114:32 - Python now in the next video I'm going
114:34 - to show how we can write and read to a
114:36 - file at the same time so that would
114:38 - involve not wiping the entire file when
114:40 - we open it but if you learned something
114:42 - today please like And subscribe and I
114:45 - will see you again in another video
114:53 - hey guys and welcome back today this is
114:56 - the 15th video in my Python Programming
114:59 - series and we are going to be talking
115:01 - about some more methods that we can use
115:03 - on strings and on lists these methods
115:06 - are I'm going to put them in a comment
115:07 - so that I remember is
115:10 - theind and the do count method and now
115:14 - these can be used on strings and on
115:17 - lists so let's go right ahead and give
115:19 - an example so the do find method this is
115:22 - this is a uh very useful method in
115:25 - Python it's not in a lot of other
115:26 - languages so it is specific to python so
115:28 - what we can do is we're going to make a
115:29 - variable we're going to call it string
115:32 - now we can set this equal to whatever we
115:34 - want so let's just say hello for this
115:36 - case for
115:37 - Simplicity and then we're simply going
115:39 - to
115:40 - print
115:42 - string oops if I spelled it correctly
115:45 - string
115:47 - doind and then inside of theind brackets
115:50 - here so the argument for this meth meod
115:53 - we are going to put in what we want to
115:54 - find so we want to see if we can find
115:58 - the indic of any of these letters here
116:01 - so if I put in
116:03 - L you'll see what happens is I get two
116:06 - and that's because there's an L the
116:08 - first l in the string is found at the
116:11 - indic of two just like that um now you
116:14 - may be confused right now I haven't
116:16 - completely explained it but that's fine
116:18 - so as you can see we have two L's in the
116:20 - string right now when I put in this l in
116:24 - the
116:25 - brackets it gives me a value of two now
116:28 - that is where the first L is found in
116:31 - the string if I put in O for
116:34 - example you'll see it gives me four and
116:36 - there's only one o in the string so it
116:38 - gives me the value of where that o is
116:41 - which is the fourth indic of the string
116:43 - the fourth index uh if I put in
116:46 - h you see we get zero and now notice
116:50 - what happens if I put in a number or a
116:52 - letter that's not actually in the string
116:54 - so I'll put in seven for example the
116:56 - string seven and you see we actually
117:00 - get1 that's because if python does not
117:02 - find that inside of the string it's
117:04 - going to tell you that it's negative one
117:07 - so rather than zero it gives you
117:08 - negative 1 just like that so this is
117:11 - useful because maybe we want to check in
117:13 - a password for example if it contains a
117:16 - certain elements so maybe if there's a
117:18 - dash in there we don't want them to be
117:20 - able to use that password or maybe we're
117:22 - not allowing a certain character or we
117:24 - need a certain character to be in a
117:26 - password or a string this is where find
117:28 - is useful um and it'll tell us if that's
117:31 - in the string or not now there's
117:33 - actually another useful uh string method
117:36 - here that is do count now it does a
117:38 - similar thing except instead of finding
117:40 - the index of the letter it counts how
117:43 - many of them there are in the string so
117:45 - now we're going to go to do count so
117:47 - we'll go do count like this and again
117:49 - inside of the brackets we're just going
117:51 - to put a string uh so let's do L and you
117:56 - see if we F5 here we get the value of
117:59 - two that's because obviously there are
118:01 - two L's in our string now I'm just going
118:03 - to type a bunch of random letters and
118:05 - show you that this does work for all
118:07 - kinds of things so if I type in a for
118:10 - example see how many A's I typed we have
118:13 - six A's in that string now let's try a
118:15 - zed I know I didn't use Zed here I'm
118:17 - pretty sure at least oops that's my bad
118:23 - uh we forgotten a uh parenthesis there
118:26 - sorry okay and we get zero right so
118:29 - instead of -1 it counts and it says well
118:32 - there are zero of them in the string so
118:34 - we're going to return zero again we can
118:37 - use this to find if there's a certain
118:40 - character in the string so if we say you
118:41 - can only have a maximum of three numbers
118:44 - in your string well we could count and
118:46 - we could say if there whatever how many
118:48 - numbers right um the dot find is
118:51 - different than this because it actually
118:53 - tells us where that is so if I do find
118:57 - again and now maybe I put in an a well
119:00 - we know there's six A's in the string
119:02 - but which a is this one going to give us
119:04 - so it says five because that is the
119:06 - first place that an a occurred in the
119:08 - string so we see here at the fifth indic
119:11 - or index that's where the first a is
119:13 - it's not going to give us the A's from
119:14 - back here if we wanted to find the A's
119:17 - back here we' have to use a for Loop and
119:19 - we'd have to Loop through the string in
119:20 - different parts of the string to find
119:22 - where all the A's were um again yeah so
119:25 - that's how you use doind and do count
119:28 - it's very useful if you want to check
119:29 - certain things so I'll show you an
119:31 - example here if we wanted to check a
119:33 - string how we would use the count method
119:35 - or the do find method so I'm going to
119:37 - say if
119:40 - string. count and I don't want to allow
119:43 - any let's say underscores in my string
119:47 - is greater than zero so that just means
119:50 - uh if it's I guess we could also say not
119:52 - equal to zero so if it has if it
119:54 - contains at least one of these
119:56 - underscores then we're not going to
119:57 - allow it so we're going to print to the
120:01 - screen not good just like that okay just
120:04 - to show how this works now here instead
120:07 - of actually having a preset string we're
120:09 - just going to get input from the console
120:10 - so we can do this a few times and see so
120:12 - input and we'll say please type
120:16 - something as the prompt like
120:19 - that and otherwise so in L state in here
120:22 - if it doesn't contain any underscores we
120:24 - will print
120:26 - good like that okay so now I'm going to
120:30 - type hello that was our first
120:33 - string and oh what happened
120:38 - there good so we get good sorry I don't
120:41 - something glitched uh in the program
120:43 - there we'll rerun it I'm not sure what
120:44 - happened there
120:46 - F5 please type something I type hello
120:50 - there we go now we get good I'm not sure
120:51 - what happened the other one okay so now
120:53 - let's do it again and this time we're
120:54 - going to include an underscore so we'll
120:56 - do underscore uncore hello it's going to
121:00 - say not good because it counted these
121:02 - underscores and it said well there is
121:04 - more than zero underscores so it's not
121:06 - good and then same thing if we put an
121:08 - underscore in the middle of the word or
121:09 - we put a ton of underscores so h e
121:12 - l o whatever just like that uh not good
121:17 - because there's underscores in the word
121:18 - just like that and yeah that's pretty
121:21 - much how the doind and the do count
121:23 - methods work there's a ton of uses for
121:25 - these and it's really useful um that
121:27 - they have this method because in a lot
121:29 - of other programming languages they
121:30 - don't have this count and find so it
121:33 - makes it a lot harder if you're trying
121:34 - to find how many things are in a string
121:37 - or if you're trying to find the index of
121:38 - a letter so I hope you learned something
121:40 - I hope you enjoyed if you did please
121:42 - like And subscribe and I will see you
121:44 - again tomorrow for another video
121:51 - hey guys welcome back this is the 16th
121:54 - video in my Python Programming series
121:57 - and today we're going to be talking
121:58 - about python modules and import
122:00 - statements so this is something new that
122:02 - I haven't talked about yet but python is
122:05 - a modular programming language meaning
122:07 - that we can use multiple files together
122:09 - to create one program and you'll
122:11 - understand what I mean later in the
122:12 - video when I show some examples um but
122:15 - yeah so pretty much in Python at the
122:17 - beginning of all your Python scripts
122:19 - what you typically do is you write
122:21 - something like this it says import and
122:23 - you can see this highlights an orangey
122:24 - yellow meaning that it is a keyword in
122:27 - Python now there are many built-in
122:30 - modules or what they called um in Python
122:32 - that contain a list of functions and
122:35 - classes that we can use in our python
122:37 - script so for example the math module
122:40 - import math this allows me to do things
122:43 - like dot square root or it's the square
122:46 - root function which I believe is like
122:49 - this and then you can put something
122:52 - inside of it um so yeah there's plenty
122:54 - of cool things like that there's another
122:56 - module it's called pame Uh we're going
122:58 - to be doing this later I'm going to be
123:00 - talking about game development with
123:02 - python if you want to see that leave a
123:03 - comment down below and I'll get it
123:05 - started soon and then we have import we
123:07 - can also import something called OS and
123:10 - this gives us uh opportunity to do
123:12 - things like file paths and lots of
123:15 - different things like that we can import
123:16 - images we can import tons of different
123:18 - things into our files um in Python so
123:22 - we're just going to use the math module
123:24 - today for demonstration purposes but
123:27 - pretty much what happens is there's a
123:28 - bunch of built-in modules in Python so
123:30 - this one is known as a built-in module
123:32 - math uh when you download and install
123:35 - python it pretty much you download that
123:38 - module the pame module that I was
123:40 - talking about is not a built-in module
123:42 - that means you actually have to go to
123:43 - the internet you have to find it and
123:45 - install it on your computer before you
123:47 - can import it into your Python program
123:50 - and now what's really cool about python
123:52 - is that it's an open- Source language
123:54 - meaning that you can actually create
123:55 - your own modules um and they contain
123:58 - functions classes and you can use them
124:00 - in many of your different programs or
124:03 - you can also send them to a friend maybe
124:05 - or post them online for other people to
124:06 - be able to use so let's get right into
124:09 - it and uh let's do some things here so
124:13 - if we want to use this math module we
124:15 - have to first start by typing math so
124:18 - the name of our module here okay so math
124:21 - and then afterwards we're going to do
124:23 - the name of a function or a class in
124:26 - that um that math module so you see a
124:29 - bunch of things pop up there uh in that
124:31 - little box so if I do the dot again in
124:32 - wait a second it should pop up yeah so
124:34 - there we go and you see we have cosine s
124:37 - tangent all that stuff uh
124:40 - degrees factorial all these things
124:44 - inside of our math module so these are
124:46 - new things that we wouldn't be able to
124:48 - use before so I'll show you if we do
124:50 - math.pi and I print that to the screen
124:53 - well we should get an endless number of
124:55 - digits like this math.
124:58 - Pi uh is it running there we go so it
125:01 - just had to print a bunch of numbers so
125:03 - math.pi it didn't print all of them I
125:04 - think it only went to 10 decimal points
125:07 - um so yeah and then I'll show you if I
125:09 - comment out this uh this import math
125:13 - what'll happen if I try to do this we
125:15 - get an error because well math is not
125:17 - defined we didn't import it at the top
125:20 - of our program so we'll uncomment this
125:22 - now now I can do things like math.
125:25 - degrees uh degrees simply turn something
125:28 - that is in radians into degrees so if I
125:31 - did math. Pi in here for example and we
125:34 - print that to the screen we get 180
125:37 - degrees like that uh they also have the
125:40 - math. radians I believe which does the
125:43 - opposite so it turns a degree into a
125:46 - radian so if we did 60 degrees
125:49 - here like that
125:52 - and we get
125:53 - 1.47 which is about pi over 3 uh radians
125:57 - like that so yeah there's lots of cool
125:59 - things that we can do with these modules
126:01 - now I'll actually show you an example of
126:04 - how we can use our own modules and how
126:06 - we can import our own modules into our
126:08 - function so I'm going to just start by
126:10 - typing import I'm going to type my
126:13 - module just like this okay um now I
126:16 - haven't actually created this module yet
126:17 - we're going to do that in just a second
126:19 - now I'm going to go and I'm going to
126:20 - find the directory that my main script
126:22 - is in so it's in tutorials up here I've
126:25 - got this open and remember uh how we had
126:27 - the file in here as well because it has
126:29 - to be in the same directory so I'm going
126:30 - to create a new file in that directory
126:32 - so file new file I'm going to save this
126:36 - one as my module now spelling is very
126:40 - important again capitals do matter uh
126:42 - and it has to be in the same directory
126:44 - as our main script which it is like that
126:49 - now inside of this module I'm going to
126:50 - write a very basic function if you
126:52 - haven't seen that video yet go check
126:54 - that out first um we just talked about
126:56 - some basic functions and what they do in
126:58 - the use of them so I'm going to Define
127:00 - I'm just going to call it my funk like
127:03 - this it's going to take a parameter
127:04 - called X and all it's going to do is
127:07 - return x + 5 so very basic function like
127:12 - that but just for demonstration purposes
127:14 - here okay and now I have my module
127:17 - imported like this so I can actually use
127:19 - my module so I'm going to do print my
127:23 - module dot my funk because that's the
127:27 - name of my function and then inside I
127:29 - need to give it a number so what number
127:31 - do we want to use maybe we'll use
127:33 - six and we print this out and you see we
127:36 - get 11 so by simply all I did was create
127:39 - a new file put it inside of my um same
127:43 - directory as this script here and easy
127:47 - enough we were able to use it now I can
127:49 - actually create multiple functions in
127:50 - here so I can create
127:52 - Define another Funk like this that'll be
127:55 - the name this one will take X again and
127:57 - inside here I'm going to return X
128:00 - integer division five and then again we
128:04 - could use that one so instead of my funk
128:06 - we'll use another Funk like this and
128:08 - let's just type in a big number like
128:10 - that and see what we
128:13 - get there we go so again it's working
128:16 - perfectly fine so that's how uh modular
128:19 - programming is what it's called works in
128:21 - Python now obviously if you're going to
128:23 - be doing modular programming it's
128:25 - usually for larger uh programs and
128:28 - bigger programs where you want multiple
128:30 - files to keep things organized say maybe
128:32 - if you're doing a flight simulator you
128:34 - may have one module that includes all of
128:37 - your physics functions so you know that
128:40 - when you need to do physics you're going
128:41 - to import your physics function and then
128:43 - you can or module sorry and you can use
128:46 - the functions from there and the great
128:48 - thing about this is that these uh these
128:50 - modules are reusable in other python
128:53 - files I can import them and I can reuse
128:55 - these functions I don't have to
128:57 - constantly rewrite them inside of my
128:59 - script like this so this has been a very
129:02 - basic tutorial uh just an introduction
129:04 - to modular programming I showed the math
129:06 - module a little bit if you want to learn
129:08 - about some of the built-in uh sorry
129:11 - modules in Python then just go ahead and
129:14 - go to their website and you can see a
129:15 - bunch of the different ones that they
129:17 - have another one that we may be using
129:18 - later is called OS so the statement for
129:21 - that is just import OS and if you want
129:23 - to get started with game development you
129:25 - can look into pame which is this cool
129:28 - thing that I'm going to be doing a
129:29 - tutorial series on later so yeah that's
129:32 - been the video for today we talked a
129:34 - little bit about modular programming if
129:36 - you enjoyed please like And subscribe
129:38 - and I will see you again tomorrow with
129:40 - more
129:45 - content hey guys and welcome back to
129:47 - another YouTube video this is the 17th
129:50 - video in my P Python Programming series
129:53 - and today we're going to be talking
129:54 - about functions more advanced functions
129:56 - and something called optional parameters
129:59 - so let's just give a quick refresher of
130:01 - what a function is I'm just going to
130:02 - write one very quickly I did do another
130:04 - video on basic function so if you
130:06 - haven't seen that yet go check that one
130:07 - out first now here we've defined what
130:10 - we're going to call the function Funk
130:13 - and then inside of these brackets we put
130:16 - something called parameters if you
130:17 - remember that from the other video so in
130:19 - this case I'm just going to put X as my
130:21 - own only parameter and then I'm simply
130:23 - going to print x to the screen just like
130:26 - that so A very very basic function but
130:29 - it's just to give you a quick refresher
130:30 - of what it does now when we wanted to
130:32 - call our function all we had to do was
130:33 - write our function name and then put a
130:37 - brackets or the brackets like this and
130:39 - then inside of our brackets if we had a
130:40 - parameter set we had to do we had to
130:43 - give it that parameter so we could do
130:44 - three we could do hello let's just do
130:46 - hello in this case and we'll click F5
130:49 - and we get hello on the screen screen
130:51 - just like that now we can change this
130:53 - again to maybe Tim which is my name just
130:56 - like that and we get Tim printed this
130:58 - screen very basic very easy just like
131:00 - that okay so that's pretty much what a
131:03 - function is now what we're going to be
131:05 - talking about today is more uh in- depth
131:07 - on these parameters so you remember we
131:09 - can give it multiple parameters so we
131:10 - could do x uh and we could do maybe text
131:14 - like this so we had X and text and then
131:16 - we could print x to the screen and maybe
131:18 - we'll say if text is equal to
131:22 - um let's say one so the string one then
131:25 - maybe we'll
131:27 - print text is one otherwise so else we
131:32 - will
131:35 - print text is not one just like that
131:38 - very easy okay so now what we have to do
131:40 - when we call the function is we have to
131:42 - give it another parameter in this case
131:44 - I'm going to give it two and we'll see
131:46 - what
131:47 - happens we get Tim and then texter I
131:50 - misspelled that my bad is not one now if
131:53 - I change this parameter to one again
131:55 - we'll
131:55 - see that we get text is one now again
131:59 - that's just another example but in some
132:01 - cases when we call a function and we
132:03 - have many parameters or maybe we don't
132:05 - have many but we don't want to
132:07 - constantly be rewriting these parameters
132:10 - we want to have something called the
132:11 - default value for our parameters so X
132:15 - maybe we always want to give our
132:17 - function the value of x but in text here
132:20 - we always want it to be set to something
132:22 - unless we otherwise specify so in this
132:25 - case I'm going to say text and then the
132:28 - equal sign and I'm going to put two just
132:31 - like that now here I'm going to remove
132:35 - the one and you'll see what's will
132:37 - happen here we'll just run it to show
132:39 - you and then we'll go in what's actually
132:40 - happening so we get Tim and then text is
132:43 - not one so what actually happened here
132:46 - is since I didn't specify a value for
132:49 - text so I didn't do a and write
132:51 - something else here it defaulted to the
132:54 - value of two now we can prove that by
132:57 - just simply printing out text and
133:00 - showing you that it is actually
133:01 - two so we have Tim and two just like
133:05 - that um if I wanted to change this value
133:08 - now all I would have to do is simply put
133:11 - a comma here in the function and change
133:13 - it to whatever I want so in this case
133:15 - I'll do
133:16 - 67 and if we print it again you'll see
133:19 - we get
133:20 - 67 so that's how the optional parameter
133:22 - works now all you have to do to set an
133:25 - optional parameter is simply type an
133:27 - equal sign after your parameter so if I
133:31 - have X and I'll set it equal to three
133:33 - like that now when I call the function I
133:36 - actually don't have to give it any
133:38 - parameters because it already has the
133:40 - optional parameter of three and of two
133:43 - which are going to be the default values
133:44 - if I don't write anything in my function
133:47 - argument here so inside of these
133:49 - brackets and you'll see again we get
133:51 - three and two because those are the
133:53 - default
133:54 - values now there is one tricky thing
133:57 - that you have to understand about these
133:59 - optional parameters say you wanted to
134:01 - have X stay at the default value so you
134:05 - wanted it to be three and you didn't
134:06 - want to type three in the brackets like
134:08 - that but you wanted to change the text
134:11 - optional parameter to something like
134:14 - seven or eight or maybe another string
134:17 - well you can't actually do that in order
134:19 - to change this text optional parameter
134:21 - you would have to also set a value for x
134:24 - here so if I try to I'll say I just want
134:27 - to set the text to three so I'll do like
134:29 - three
134:30 - here it's actually not going to change
134:33 - um sorry what do you call it it's I'll
134:35 - change it something else so we can we
134:37 - can see it better five let's do five
134:39 - it's actually not going to change that
134:41 - second variable right it's going to
134:42 - change the first one automatically
134:44 - because that's just the order in which
134:46 - they're defined so if you want to if you
134:48 - have more than one optional parameter
134:51 - you will have to set a value for the one
134:53 - before in order to change the one
134:55 - afterwards like this so that's the only
134:58 - tricky part about these optional
134:59 - parameters other than that they're
135:01 - extremely useful again you would use
135:04 - them if you're constantly using a
135:06 - function and you don't want to have to
135:07 - keep writing in parameters you only want
135:09 - to give it a parameter in a very
135:11 - specific case then you would have that
135:13 - optional parameter already set so you
135:15 - don't have to keep typing a certain word
135:17 - you don't have to keep giving it a value
135:19 - like that so this is been a shorter
135:21 - video but this is the video on how to do
135:23 - an optional parameter they look just
135:25 - like this they're very simple and pretty
135:27 - basic and I hope you learned something
135:29 - today if you did please like And
135:31 - subscribe and I will see you again in
135:33 - another
135:39 - video hey guys welcome back to another
135:42 - video this is the 18th video in my
135:44 - Python Programming series and today
135:46 - we're going to be talking about
135:47 - something called a try and accept block
135:50 - of codes so just like we talked about
135:52 - the if else and L if block of code um
135:55 - and like we talked about the for Loop
135:57 - which is a block of code and like
135:59 - functions which are blocks of code uh
136:00 - we're going to be talking about the try
136:02 - and accept so in Python we use try and
136:05 - accept as our keywords in other
136:07 - languages you may have heard of try and
136:08 - catch statements um this is the same
136:11 - thing except in Python instead of catch
136:13 - we use accept Okay so let's talk about
136:16 - what a try and accept statement is
136:18 - sometimes in Python you want to do an
136:20 - operation or you want to try something
136:23 - but you don't know if it's really going
136:24 - to work or not there's some different
136:26 - variables that may come in sometimes it
136:28 - may work sometimes it may not work
136:30 - usually this depends on user input or
136:33 - what the user is doing in the program so
136:36 - a good example of this is maybe if we're
136:38 - validating a form so we'll do an example
136:40 - here we'll say text is equal
136:42 - to uh input like this and then we'll say
136:48 - username okay now in typical usernames
136:51 - you're only allowed certain characters
136:53 - maybe you can't do um a comma you
136:56 - couldn't do a star certain things like
136:58 - that right maybe we only want it to be
137:00 - text or we only want it to be numbers uh
137:02 - we just want to validate this we could
137:04 - use a huge if statement to do this um
137:07 - but
137:08 - instead there's something called a try
137:10 - and accept that we can use so in this
137:12 - case I want my username to only be
137:15 - numbers so I don't want it to be a
137:17 - string at all I want it to only be
137:19 - numbers so what I'm going to do is I'm
137:21 - going to make a new variable here and
137:23 - I'm going to call it number and all I'm
137:26 - going to do is I'm going to try to int
137:28 - the text like this okay so if you
137:31 - remember what the int does is that
137:33 - simply converts our string into an
137:35 - integer and then I'm going to print that
137:37 - to the screen so I'm going to print
137:38 - number to the screen now what what
137:41 - happens right here is uh if I try to
137:43 - type in a word like this you see we get
137:46 - an error it says there's an invalid
137:48 - literal for INT with base 10 now you
137:51 - don't have to understand what this error
137:52 - is pretty much all this means is that we
137:54 - can't convert hello into a number
137:56 - because there is really no number there
137:58 - how how does it know what number to make
138:00 - that into right so in this case we would
138:03 - use a try and accept look because if the
138:06 - user types in something that's
138:09 - invalid well we want them to type in
138:11 - something else we don't want the program
138:13 - to crash like it just did there so here
138:16 - I'm going to put a try like this
138:19 - followed by a colon and then I'm going
138:21 - to indent these two blocks right here so
138:25 - that means we're going to try this block
138:28 - of code okay and then underneath here
138:31 - I'm going to type accept just like that
138:34 - followed by a colon now there is a more
138:36 - advanced way to do this we can accept a
138:38 - specific type of error um but I'm not
138:41 - going to talk about that in this video
138:42 - this is just a very basic try and accept
138:44 - block and then under here uh I'm going
138:47 - to type what I want to happen if this
138:49 - block of code doesn't run meaning this
138:51 - block of code returns an error um and we
138:54 - can't actually execute it so in this
138:56 - case I'm just going to do uh I'll just
139:00 - print to the
139:01 - screen
139:03 - invalid username because remember we're
139:06 - only going to have our username
139:07 - contained numbers all right so now if I
139:10 - run the program and I try to type in
139:12 - something that is not a string so just I
139:14 - mean that is not a uh number like this
139:17 - it'll just say invalid username rather
139:20 - than crash ing the program which is what
139:22 - happened
139:23 - before and if I do try to type in
139:25 - something that is valid so maybe I type
139:27 - 1 2 3 4 it just gives me that username
139:30 - back right so it works like that um so
139:33 - that's pretty much how the try and
139:35 - accept works again this is a very basic
139:38 - example and that's what I try to do in
139:39 - my videos just give you the basics and
139:41 - then you can try to apply it to some
139:43 - projects you're doing um and some more
139:45 - advanced things so again what happens is
139:48 - it tries this block of code
139:51 - if that block of code doesn't run or an
139:53 - error happens instead of Simply crashing
139:56 - the program and giving us that red
139:57 - message it's going to go to this accept
139:59 - block and it's going to do whatever is
140:01 - in here now in this accept block again
140:04 - we could ask them to type in a new
140:05 - username we could display another
140:08 - message we could maybe um close the
140:10 - program on them we could do whatever we
140:12 - wanted to do in this accept block and
140:14 - it's extremely
140:15 - useful um so yeah that's pretty much how
140:18 - the try and accept works
140:21 - if you learned something please like And
140:23 - subscribe and I will see you again in
140:25 - another
140:32 - video hey guys welcome back to another
140:34 - video this is the 19th video in my
140:36 - Python Programming series and today
140:39 - we're going to be talking about a fairly
140:41 - complex topic some people find kind of
140:44 - confusing in their programs um it's very
140:46 - useful to understand and it's Global
140:48 - versus local variables so Global um
140:53 - pretty much means everywhere can be used
140:55 - in anything and local means specific to
140:58 - a certain uh block of code or to a
141:01 - certain class so let's just dive in
141:04 - right away with an example so in our
141:06 - program we have things called variables
141:08 - again we've talked about them before so
141:10 - I'm just going to say VAR up here equals
141:12 - 9 we'll say our um true this is
141:16 - lowercase here uh is just equal to true
141:19 - or actually let's call it Loop in
141:20 - instead just not to confuse anyone so
141:22 - Loop is equal to true and then maybe
141:25 - let's make a function we're just going
141:26 - to call this function Funk we'll give it
141:28 - a parameter of X and we're just going to
141:31 - say if x is equal
141:34 - to oops 2 equal sign 5 then
141:39 - return true and we'll set a variable up
141:42 - at the top of this function and we'll
141:44 - just call it uh
141:48 - Newar is equal to
141:51 - seven or yeah seven let's do that and
141:54 - then instead of returning true we'll
141:55 - actually return new VAR my bad new VAR
141:57 - just like that okay so here we have
142:01 - three variables we have the variable VAR
142:04 - which is equal to nine the variable Loop
142:06 - which is equal to true and then the
142:08 - variable Newar which is inside of our
142:10 - function and that's equal to
142:12 - 7 uh and then the parameter X which
142:15 - again can kind of be considered a
142:16 - variable but it is uh more specifically
142:19 - a parameter so I just want to show you
142:21 - right away what tries to happen if I
142:24 - print out the variable Newar so outside
142:28 - of my function in its own line I'm just
142:30 - going to say print Newar like
142:34 - that we click F5 and we get an error
142:37 - here it says the name Newar is not
142:40 - defined but how can that be possible we
142:43 - just made Newar right here in our
142:46 - function well this is where we get into
142:48 - local versus global variable
142:51 - so the variable Newar is actually known
142:54 - to be a local variable to the function
142:57 - uh Funk so that means the only thing
142:59 - that's able to access the variable
143:01 - change the variable and use the variable
143:03 - Newar is the function Funk so again if I
143:08 - put the print statement inside of my
143:09 - function and then I call my function it
143:12 - will work so here if I type Funk now and
143:15 - I'll give it value of
143:18 - two then Newar does print to the screen
143:21 - and we don't get an
143:22 - error so that is how uh the local
143:25 - variable works so again it's the same
143:28 - thing in any other type of function so
143:30 - if I write another function I do Define
143:33 - other Funk this one I won't give it a
143:36 - parameter and I'll just
143:37 - say
143:40 - Newar is equal to five like that so
143:43 - different than seven and then this
143:45 - function will print Newar well do we
143:48 - think it's going to print out seven or
143:49 - do we think it's is going to print out
143:51 - five so we'll show you like
143:54 - this if we
143:57 - run uh take zero positional arguments
143:59 - other fun oh my bad there's a two in
144:01 - there
144:02 - sorry it prints out five right so it
144:05 - doesn't look at this variable here it
144:07 - looks at the local variable in here
144:09 - called Newar now same thing if I put
144:12 - Newar up here outside of all of these
144:15 - functions and I set it equal to
144:17 - 23 and then I click F5 here to run it's
144:22 - still going to print out five that's
144:24 - because these
144:25 - functions they can see these variables
144:27 - up here but if there there's a variable
144:30 - already declared inside of their
144:32 - function they're going to use that one
144:34 - instead I know it's kind of confusing
144:36 - I'm going to talk a little bit more
144:37 - about how this works I just want to give
144:38 - some examples to start
144:40 - off okay so now we'll talk about global
144:43 - variables so local variables are ones
144:46 - that are declared usually inside of a
144:48 - function so that means outside of the
144:50 - function so again if we tried to print
144:52 - Newar out here um and I got rid of this
144:55 - up here we get the error like we got
144:57 - before right it says it's not
144:59 - defined so what about global variables
145:02 - well these Global variables are ones
145:04 - that anything in the program can see so
145:06 - VAR and loop would be known as Global
145:09 - variables in here if I try to print out
145:12 - our variable
145:14 - VAR and then I'll just call that
145:16 - function by doing Funk and I'll give it
145:19 - a value of two once again
145:22 - it will be able to see VAR and it does
145:24 - print it to the screen as nine that is
145:27 - because this is global it's not defined
145:30 - inside of a function or inside of a
145:31 - class and classes we'll talk about later
145:33 - don't worry about that um same thing if
145:35 - we try to print out Loop so if I change
145:38 - this to loop again it should
145:42 - work we get true printed out to the
145:44 - screen just like that so now there's the
145:47 - issue with changing variables in inside
145:50 - of a function so typically you want to
145:53 - avoid this you don't want to be
145:55 - dependent on these Global variables up
145:58 - here to make your functions work this is
146:00 - because if you remember in my other
146:02 - video I talked about modular programming
146:04 - where we can reuse
146:06 - functions well if I have a variable
146:08 - defined up here and my function is
146:12 - referencing that variable meaning it
146:13 - requires that variable to work then if I
146:16 - try to use this function in another one
146:18 - of my programs it's not not going to
146:20 - function properly because that Loop
146:22 - variable or that Global variable that I
146:24 - try to use is not going to be uh defined
146:27 - in that other program
146:29 - right so let's do an example here of how
146:33 - we can actually change a global variable
146:37 - so if I go here and I say
146:40 - Loop is equal to 7 so I call my function
146:44 - and it's going to set loop equal to 7
146:46 - it's um and then I try to print out the
146:49 - variable Loop Loop well what do you
146:52 - think is going to print to the screen
146:53 - give me a guess it's either going to be
146:55 - seven or it's either going to be true um
146:57 - what do you think right so I'm printing
146:59 - it underneath after I call this function
147:02 - Let's
147:03 - see we get true now even though we what
147:08 - looks like changed the variable in this
147:10 - function instead of actually changing
147:12 - This Global variable instead we created
147:14 - a new variable which is local to the
147:16 - function called Loop if we want to
147:19 - change the variable we have to use
147:21 - something called the global keyword so
147:24 - in Python what we have to do is at the
147:25 - top of our function we just type the
147:27 - word Global followed by the variable
147:30 - name that we want to change so in this
147:33 - case I'm going to say
147:34 - Loop now if we run this
147:38 - program we print out seven that's
147:41 - because this tells our function that
147:43 - we're going to look outside of the
147:45 - function here for the variable if it
147:47 - exists then we're going to change it
147:49 - just like like we did there so I know
147:52 - this has been kind of confusing I've
147:54 - kind of jumped around try to play around
147:57 - with these things and see uh if you're
147:59 - getting errors see if you can figure out
148:01 - what's going to print to the screen here
148:02 - if you want to change a global variable
148:04 - so one that you define at the top of
148:06 - your program here or outside of your
148:08 - functions then you must type the global
148:11 - keyword inside of your function followed
148:14 - by the name here again if I try to
148:16 - change the uh the variable down here so
148:18 - not inside of a function it will work so
148:19 - if I I do Loop is equal to
148:24 - false then uh oh we get seven again just
148:26 - because I called it up here so I won't
148:28 - call this function this time if I say
148:30 - Loop is equal to false then we will get
148:32 - false because it's not inside of a
148:34 - function so it is able to see and change
148:36 - this
148:37 - variable so really using the global
148:40 - keyword uh it's just inside of functions
148:42 - and just remember that if you do create
148:44 - a variable inside of your function it's
148:46 - local to your function meaning that
148:48 - unless you type this Global keyword
148:51 - first and then followed by the name of
148:54 - that
148:54 - variable everything outside of the
148:56 - function will not be able to see that
148:59 - variable so if you liked if you uh like
149:02 - this video and you learned something
149:04 - please like And subscribe and I will see
149:06 - you again in another video
149:20 - hey guys and welcome back to another
149:22 - YouTube video so in this video I'm
149:24 - actually starting a new series on
149:26 - classes and objects in Python now I'm
149:28 - going to start off fairly simple and
149:30 - just explain to you kind of what is a
149:31 - class what is an object how can we
149:33 - create our own and in future videos I'm
149:34 - going to get a lot more advanced and
149:36 - show you some really cool things that
149:37 - you can do with classes and objects that
149:39 - not only make your life a lot easier but
149:41 - are really cool in my opinion and I
149:43 - didn't even know you could do them until
149:45 - I was kind of searching around before
149:46 - making this video so make sure if you
149:48 - guys are interested in bringing your
149:50 - programming kind of to the next level
149:51 - and stepping out of the basics of python
149:53 - and moving into more of an intermediate
149:54 - to Advanced topic that you guys watch
149:56 - through the series because you're going
149:57 - to learn a lot and you're going to have
149:59 - a fundamental understanding of python
150:01 - that you never uh understood before if
150:03 - you can understand the topics I'm going
150:05 - to talk about okay so let's start by
150:07 - talking about objects what is an object
150:11 - well in Python an object is pretty much
150:14 - anything and you can see on this my
150:15 - screen here I have two variables x = 5 y
150:19 - = string
150:20 - now to us without any understanding of
150:22 - objects and classes this just looks like
150:24 - X is equal to an integer that's five and
150:27 - Y is a string and that string value is
150:29 - string now I just want to show you
150:31 - quickly and you might have seen that you
150:32 - can do this before if I print out the
150:35 - type of X and what do you call it we'll
150:38 - just do the same thing here with Y run
150:41 - our program you see we get class int and
150:44 - class string now this is pretty trivial
150:47 - you figured this was going to happen but
150:49 - what does this class actually mean here
150:52 - well pretty much whenever you create a
150:54 - new object in Python so whenever you
150:56 - create a variable something like that it
150:58 - automatically creates an instance of an
151:01 - object now X the way that you can also
151:04 - read this is X is equal to an instance
151:07 - of the in class and its value is five
151:10 - whereas Y is equal to an instance of the
151:12 - S Str class and its value is string now
151:15 - these classes allow us to have built-in
151:18 - functionality in Python now you might
151:19 - might take for granted the fact that we
151:21 - can do something like x + 7 right and
151:24 - obviously we know we're going to get 12
151:25 - when we do that or if we do like x - 6
151:28 - or x / 4 but someone actually coded this
151:32 - functionality into Python and you just
151:34 - can't see it when you're coding here um
151:36 - because it's kind of underneath and I'm
151:38 - going to actually show you a way that
151:39 - you can look at this built-in um code
151:43 - okay so just know that anytime you
151:45 - create a variable and anytime you kind
151:47 - of use any functions like for example if
151:49 - you use uh I don't know say like H is
151:52 - equal to what's something we can do like
151:55 - int y okay I know that's not going to
151:57 - work but whenever you use functions like
151:58 - this someone already coded these
152:00 - functions for you and they're typically
152:02 - built into a class of a certain type
152:05 - when you do something like y. strip you
152:08 - just take for take for granted the fact
152:10 - that you can use this strip method um
152:13 - and this is called a method but someone
152:15 - actually built this in and the reason
152:16 - you can use this is because it's a
152:18 - method on the CL class of St Str if I
152:21 - tried to do something like x. strip well
152:23 - clearly that's not going to work because
152:25 - X is not a string object so just
152:28 - understand that whenever you create
152:29 - anything in Python it is actually an
152:31 - object without you really knowing it or
152:33 - not okay so now I'm going to show you
152:36 - I'm just going to run this in debug mode
152:38 - so I can print some stuff out to the
152:39 - screen okay so I go console and python
152:43 - console okay so I'm using Pym but this
152:45 - works perfectly fine with regular idle
152:48 - in Python okay so if I type this help
152:51 - function and I pick a class and I'm
152:53 - going to pick int like this okay I type
152:55 - help on int you can see it prints me all
152:58 - this stuff now what does this actually
153:00 - mean well once we get to the top you can
153:02 - see it says class int of type object or
153:07 - inherit from object so pretty much
153:09 - whenever we create an integer and the
153:11 - way we create an integer in Python is
153:12 - simply by just saying like x = 5 xal 470
153:17 - whatever like that it automatically
153:19 - defaults this x is a type int and you
153:22 - can see here that it actually tells us
153:25 - exactly how this class works and this is
153:27 - really useful if you don't know
153:28 - documentation you can just type help on
153:30 - something and it'll read out all the
153:32 - class and everything for you so convert
153:34 - a number string to an integer return
153:36 - zero if no arguments are given that's
153:38 - what happens when you call the int
153:39 - function and when you give a base well
153:41 - then it tells you what it does there
153:43 - okay now it says methods defined here
153:46 - well these are actually all the methods
153:48 - that you can use on on the class integer
153:52 - so if you have abs you have ADD and bu
153:55 - seal div mod equal to Flo floor FL TI
153:58 - and I'm going to show you what all these
153:59 - actually mean uh and why they have the
154:01 - underscores on them later on okay so
154:04 - just wait for that you can see that
154:05 - there's a ton of different methods and a
154:07 - ton of functionality already built into
154:09 - this integer class size of string and
154:12 - you can just keep going two bytes and
154:15 - there's a ton and then class methods
154:16 - defined here we're going to talk about
154:18 - what those are later now I want to show
154:19 - you if I do the same thing on string so
154:22 - I say help on oops on S strr like this
154:27 - then we get the same thing except for
154:29 - string and this one is going to be what
154:31 - do you call it a little bit longer
154:32 - because there's more things you can do
154:33 - with string but you can see we have
154:34 - class string and it inherits from object
154:38 - and we'll talk about what all this means
154:39 - later just uh follow along for now
154:42 - create a new string object from a given
154:43 - object uh if encoding and so on okay and
154:46 - then it goes down here add contains
154:47 - equal and you can go through all of the
154:49 - different MTH methods that it has now
154:51 - obviously this is the same for Boolean
154:53 - values and for what do you call it uh
154:55 - floats and all other data types in
154:58 - Python now if any of you have ever seen
155:00 - Turtle before you know that if you
155:02 - create for example import Turtle okay
155:06 - wow I can't type today and you create
155:08 - like Tim
155:09 - equals Turtle do turtle like this what
155:13 - you're actually doing is creating a new
155:15 - instance of a turtle object so in this
155:19 - Turtle module there's a class named
155:21 - turtle and when you call this what's
155:23 - known as a Constructor you're actually
155:24 - creating a new turtle object and you're
155:27 - just naming it Tim or storing it in the
155:29 - variable Tim okay so what else should we
155:32 - talk about with objects here yeah so
155:34 - let's talk about the difference between
155:35 - methods and what do you call it
155:38 - functions quickly so a function everyone
155:39 - here should know is created with the
155:42 - Define key okay or like Define keyword
155:45 - so I say Define Funk give it a value X
155:48 - and we'll simply return
155:51 - x + one now we know to call this
155:53 - function what we can do is we can simply
155:55 - say like print and then Funk of five and
156:00 - we know that that should give us a value
156:02 - of six right because it just simply adds
156:04 - one to what we're giving and this is a
156:05 - function there's no question about it
156:07 - okay now a class is actually what you
156:10 - call with the dot operator so this sorry
156:14 - not a class a method so this dot uh
156:16 - right here turtle. turtle is a method
156:19 - that creates a new turtle object and
156:20 - I'll show you what I mean here so if I
156:22 - do something like print y do uper well
156:28 - this upper right here is not a function
156:31 - it's actually known as a method and it
156:33 - only applies to the class St Str so I'll
156:36 - just print this quickly to show you we
156:38 - get string in all capitals okay if I
156:40 - tried to do something like x. uper and I
156:43 - click the play button here well X has no
156:46 - uh method upper and you can see int
156:48 - object has no ATT upper okay and that's
156:51 - because well X is an object of type int
156:54 - and remember when we typed help on int
156:56 - well we didn't see any upper method
156:57 - there so we actually can't use that and
157:00 - that's why we can only use methods on
157:01 - their correct data types right so if you
157:04 - create a float and you do like uh I
157:06 - don't know like f equals like 5.5 then
157:10 - obviously if we try to do f. uper here
157:12 - this is going to crash as well because
157:14 - well float object has no attribute upper
157:17 - right it had doesn't have that class or
157:20 - that method sorry in it okay so a method
157:22 - is anything you're calling on an object
157:24 - itself right and a function is something
157:26 - that's going to take an object and apply
157:28 - an operation to it right so you can see
157:30 - here that uh five is passed into the
157:33 - function we don't have to do like X do
157:36 - function we just pass it in there and
157:38 - then it returns us a value now methods
157:41 - can return us values as well this one is
157:42 - returning us a value of all capital
157:44 - string it's just different how we
157:46 - actually call those things and they are
157:48 - very similar just the difference is the
157:51 - way that one of them you call on an
157:52 - object and one of them you have to just
157:54 - call and then pass an object through and
157:57 - sometimes these methods can take objects
157:59 - as well for example let's see if I do x
158:02 - dot or F do replace I think that's a
158:06 - thing all I'm going to have to do y.
158:09 - replace y. replace like this okay and
158:12 - then I'm going to pass it a I don't know
158:15 - what should we pass it let's pass it a s
158:19 - and we'll replace it with a blank string
158:21 - okay so we're passing a object of type
158:23 - string and we're passing another object
158:25 - of type string and that's what this
158:26 - method takes as well as we have to call
158:29 - it on the instance right so string so if
158:31 - I call this we get string and six
158:34 - because it simply replaced s with
158:37 - quotations okay so I think I'm going to
158:39 - cut the video here uh I hope you have a
158:42 - little bit of an understanding of what
158:44 - an object is because in the next video
158:46 - we're going to create our own objects
158:48 - and our own class classes uh and we're
158:50 - going to talk about that it just was
158:51 - fundamental that you guys understood
158:53 - this before moving on to the next video
158:55 - okay so that's been it for this video If
158:56 - you guys liked please make sure you
158:57 - leave a like And subscribe and I'll see
158:59 - you again in the next
159:04 - one hey guys and welcome back to the
159:07 - second video in this object and class
159:10 - tutorial Series in this video we're
159:12 - going to be going over creating your own
159:13 - objects and your own classes and what
159:16 - that looks like in Python so just go
159:18 - ahead and delete this code from the last
159:19 - video uh and start fresh so if you guys
159:22 - remember in the last video we talked all
159:24 - about objects talked about methods uh
159:26 - and that's all cool we kind of already
159:27 - understood a lot of that stuff like
159:29 - we've used those methods it Mak sense
159:30 - how they work uh but now how do we
159:33 - create our own and this is the whole
159:34 - goal of this tutorial series to create
159:36 - your own classes and your own objects
159:37 - and add functionality to your program so
159:39 - to create a new class and this is going
159:41 - to be a new like data type uh something
159:43 - like that we'll talk about that in a
159:44 - second you just simply type class and
159:46 - then whatever you want the name of your
159:47 - class to be so in Python they have in
159:49 - string list whatever okay we're going to
159:51 - create a class and I'm just going to
159:53 - call it dog now you probably have seen
159:55 - this example before if you do anything
159:58 - um what do you call it with like uh
160:00 - classes or objects because people like
160:02 - to use animals but it's a really good
160:03 - example so this is now creating a new
160:06 - class of dog now what we have to do
160:09 - whenever we create a class is we have to
160:11 - uh add some methods into it so remember
160:13 - I talked about methods or things that
160:14 - you call on the actual class itself so
160:17 - I'm just going to type
160:18 - Define nit uncore uncore and we're going
160:21 - to talk about what this does in a second
160:22 - and make sure you don't forget this self
160:24 - keyword uh this object keyword you can
160:26 - leave out if you want I just like to
160:27 - type it because I don't know it's just a
160:30 - habit right because we have class dog
160:33 - Define the NIT and I'm going to make one
160:35 - more method and we're going to call it
160:37 - speak okay and make sure you don't
160:39 - forget this self keyword we're going to
160:41 - talk about what all this does in a
160:42 - second okay pass and in here I'm going
160:44 - to say pass all right so we've now just
160:48 - created our own class
160:49 - it does not do anything but we've
160:51 - created our own class so what we
160:54 - actually do here is we're creating well
160:57 - new class it's equal to dog it inherits
160:59 - from object don't worry about that and
161:02 - this is what's known as The Constructor
161:04 - method now this uncore uncore nit uncore
161:08 - uncore needs to be in most of your
161:11 - classes okay so if you guys want
161:12 - anything to happen initially when you
161:14 - first create a class you need to make
161:16 - this a nit class and what happens is
161:18 - when we create a new object and the way
161:20 - we can do this is by doing something
161:21 - like I don't know Tim equals dog like
161:25 - that this method is automatically going
161:28 - to fire it's automatically going to go
161:30 - off we don't have to say Tim
161:34 - doore netore uncore we don't have to do
161:37 - that whenever we create a new object of
161:39 - type dog this is automatically going to
161:42 - happen so for example if every time I
161:45 - created a new object of dog I wanted to
161:46 - print out uh kn nice you made a dog like
161:52 - this then every time that we do this so
161:55 - if we say like
161:57 - fred equals dog as well then he's going
162:00 - to print this to the screen and I can
162:01 - prove this to you by simply running so
162:03 - he says nice you made a dog nice you
162:05 - made a dog all right we didn't have to
162:07 - call this a nit it just automatically
162:08 - happened whenever we created this dog so
162:11 - let's talk more about this a nit and
162:13 - what we can do with it so in classes
162:16 - there's things called attributes and
162:18 - methods all right methods are anything
162:20 - that you create using Define okay and
162:23 - they look just like functions except you
162:25 - have to call them using uh an object
162:28 - like we talked about in the last video
162:30 - and attributes are kind of like
162:32 - variables that belong to a certain
162:35 - object so to create a attribute you need
162:40 - to use this self keyword all right what
162:42 - this self keyword actually stands for is
162:45 - it stands for the instance that you're
162:48 - calling so him is known as an instance
162:51 - of type dog or of class dog now Fred is
162:55 - another instance of type dog now I'm
162:58 - just going to do this and then hopefully
162:59 - you guys can understand how this kind of
163:01 - works uh because it is somewhat
163:03 - difficult to explain okay so now what
163:06 - we're saying is we've created this
163:08 - initialization all right and we have now
163:12 - that it takes a name okay so what that
163:14 - actually means is we have to now type a
163:17 - name into uh our initial initializations
163:19 - whenever we create a dog we have to give
163:20 - it a name so in here I'm going to give
163:22 - it a name Tim and in here I'm going to
163:24 - give it a name Fred all right and don't
163:27 - worry if you guys are confused I'm going
163:28 - to explain this all in depth in a second
163:29 - okay and I'm just going to do this so
163:32 - that we can actually see what our name
163:33 - is
163:34 - print hi I am
163:38 - comma self. name and we'll talk about
163:40 - what self does in a second okay let's do
163:44 - tim. speak and Fred dope as well okay
163:49 - so let's print this and it says hi I'm
163:51 - Tim hi I'm Fred okay so how does this
163:55 - work so in this initialization this
163:57 - fires automatically when we create dog
164:00 - okay so by calling this we're
164:02 - automatically calling a nit so if we put
164:05 - a parameter in a nit so name that means
164:07 - that we now have to pass a parameter
164:09 - when we create our dog and just like a
164:11 - function we can create multiple
164:12 - parameters we can do like name age color
164:16 - kind we can do as many as we want okay
164:18 - uh and that works fine now what does
164:21 - this self do so this self actually
164:24 - represents the instance right so if I'm
164:26 - if I call dog equals Tim or dog Tim
164:30 - whatever and I set that equal to Tim
164:32 - well Tim is what's being passed into
164:34 - this self parameter here and notice how
164:36 - we have two parameters but we only pass
164:37 - one thing that's because self always
164:40 - needs to be here except in like really
164:42 - specific cases that we're going to talk
164:43 - about later so when we call self. name
164:48 - we're saying that tim. name is equal to
164:51 - whatever name we put in here and that's
164:54 - the same thing with Fred right so when
164:56 - we call it on Fred then we say well
164:59 - fred. name is equal to Fred all right if
165:03 - we didn't do that and we said something
165:04 - like name equals name if I tried to
165:07 - print self. name that would just crash
165:10 - it wouldn't work because we don't know
165:12 - which instance has what name okay so
165:15 - this self means belong it kind of means
165:17 - like belongs to the in that you're
165:19 - calling it on I'm trying to explain this
165:20 - as good as I can because you you really
165:22 - to understand this I'm going to do
165:23 - another parameter here too okay so self.
165:26 - age equals H all right and let's just
165:30 - print this out and I
165:35 - am self.
165:37 - AG years old all right okay so let's
165:41 - print this out and see what we get
165:43 - missing one age sorry I got to put age
165:45 - in here
165:47 - 55 3 okay
165:49 - so now if I print this say hi I'm Tim
165:51 - and I'm 55 years old hi I am Fred and
165:53 - I'm 3 years old okay so each of these
165:57 - are instances of class dog and they each
165:59 - have a name and an age and you're able
166:01 - to call the speak method on them now
166:04 - with the speak method does is notice how
166:06 - when I call speak it automatically takes
166:08 - self because it has to know what
166:10 - instance I'm calling it on and that way
166:12 - it's able to access the name and the age
166:16 - now in here you can actually change the
166:18 - name and the age so I'm going to create
166:19 - a new method I'm going to say
166:22 - change like this okay and notice how it
166:24 - takes self no matter what it
166:26 - automatically types it in for me and
166:28 - here I'm going to do H all right now
166:30 - what I can do is I can say self. AG is
166:33 - equal to H and if I call let's see here
166:37 - tim. change age and I give it something
166:40 - like five now if I speak you can see
166:44 - that we get hi I am Tim and I 5 years
166:45 - old and we say hi I am Fred and I am 3
166:48 - years old
166:49 - now obviously you guys can create as
166:51 - many methods as you want you can do call
166:53 - them whatever you want just make sure
166:54 - whenever you create them they first of
166:56 - all have self because we have to know
166:57 - what instance we're calling it on so we
166:59 - can access those attributes all right
167:01 - and you can change these attributes
167:03 - however you like within those methods
167:05 - now I will show you what else you can do
167:07 - okay so say you wanted to access Tim's
167:10 - age and you didn't want to print out
167:12 - like hi I am all this you didn't want to
167:14 - speak you just want to know what his age
167:15 - is well what you can actually do is you
167:18 - can simply print tim.
167:21 - H and now you can see if I run the
167:23 - program we get five down at the bottom
167:25 - and you can do the same thing with name
167:27 - so tim. name and it gives us Tim like
167:31 - that so we're actually able to access
167:34 - the attributes of our object uh from
167:38 - just simply calling whatever that
167:39 - attribute is and in this case its name
167:42 - so whenever you want something to be
167:43 - like public to the uh instance so that
167:46 - they can see it throughout all the
167:47 - methods you need to simp you need to do
167:49 - self. and whatever you want to call it
167:51 - so I could uh say like self dot I don't
167:54 - know let's say Li it's going to stand
167:56 - for list could have a list of like 1
167:58 - three four and now if I call tim. Li you
168:04 - can see we get 134 and obviously if I
168:06 - call friend. Li well this is going to
168:09 - work as well we get
168:11 - 134 now the main benefit of classes is
168:15 - that you can create things um you can
168:17 - create multiple objects of a class so if
168:20 - I wanted to store like the name the age
168:23 - and a list for 300 dog objects if I
168:26 - wasn't using classes what I would have
168:28 - to do is I'd have to do
168:29 - like dog one name equals Tim and then
168:35 - I'd have to do dog one age equals 5 and
168:38 - then I'd do dog 2 Age equals Fred and
168:40 - you'd have to continually keep doing
168:42 - that with a ton of variables and
168:43 - obviously you don't want that so these
168:45 - classes allow you to create infinite
168:47 - amount of objects of that type class
168:48 - class and have all of these properties
168:50 - and attributes apply to
168:52 - them okay so what else should we talk
168:55 - about here uh maybe creating new
168:57 - attributes okay so attributes are
168:59 - anything that have this like self. name
169:00 - self. AG self. Li whatever and methods
169:03 - are with these defined Keys okay so if I
169:05 - create a new one and I say Define and
169:08 - add uh what do you call it weight okay
169:13 - say add weight I'm going to give it a
169:16 - weight and then we can say self. weight
169:19 - is equal to weight and what this does
169:22 - now is it creates a new instance
169:24 - attribute um that is going to be applied
169:27 - to this dog class now you see it's
169:29 - giving us an error here it says instance
169:31 - attribute weight to find outside of a
169:32 - nit that's because it wants us to Define
169:35 - that inside of this initialization but
169:37 - it's fine you can actually do it out
169:38 - here so now if I do Tim dot add weight
169:42 - and I give it a weight of like 70 okay
169:46 - and I'll print
169:50 - tim. weight like here let's see what we
169:52 - get we get 70 okay now what if I try to
169:56 - print fred.
169:57 - weight well let's see what happens we
170:00 - get Fred has no attribute weight or dog
170:02 - object has no attribute weight and
170:04 - that's because we have not yet added
170:06 - this by calling add weight on our
170:08 - instance Fred okay so I think I'm going
170:11 - to cut the video off here hopefully you
170:13 - guys have a basic understanding of how
170:16 - classes worked it is kind of difficult
170:17 - to explain it if you guys have any
170:19 - questions leave them down below cuz I
170:20 - feel like I might have butchered the
170:21 - explanation on some of it uh other than
170:23 - that in the next video we're going to go
170:25 - over I think inheritance and creating
170:27 - some more advanced methods and talking
170:30 - about how those work okay so if you guys
170:32 - enjoyed please make sure you leave a
170:33 - like And subscribe and I'll see you
170:34 - again in the next
170:39 - one hey guys and welcome to the third
170:42 - video in my python object and class
170:45 - tutorial series now in today's video I'm
170:47 - going to be going over inheritance and
170:49 - this is an extremely important and a
170:50 - little bit more complicated topic
170:52 - dealing with inheriting attributes and
170:54 - methods from other objects I just want
170:56 - to start off by quickly saying though if
170:58 - you guys are finding the videos a bit
171:00 - too slow for you and uh I'm kind of
171:02 - explaining things a lot of time the
171:03 - reason I do that is because I'm not sure
171:05 - the level of person that's going to be
171:07 - watching the video and I want to make
171:08 - sure that the people that will
171:11 - understand quickly can get the
171:12 - information within like the first few
171:13 - minutes and then the people that really
171:15 - need some extra reinforcement have that
171:17 - opportunity to watch through the entire
171:19 - like 11 or 12 minutes and have it
171:21 - explained to them multiple times so if
171:23 - you guys are finding it's a bit too slow
171:25 - um and you want to move faster just fast
171:27 - forward the video or skip uh to the next
171:28 - one if you guys are done with whatever
171:31 - I've been talking about because like in
171:32 - the last video for example I watched it
171:33 - back and I kind of explain the few uh
171:35 - the same thing a few times that's just
171:37 - for the people that need a bit of extra
171:38 - help and that's kind of what I aim to do
171:40 - with a lot of my videos so that people
171:42 - that need help can you know grab that if
171:44 - they want to okay so let's get started
171:47 - and I'm just going to modify this class
171:49 - just delete Li uh we'll get rid of
171:52 - change age and add weight and we're just
171:54 - going to have name age so on like that
171:56 - okay we can get rid of all this stuff
171:57 - down here now what I'm actually going to
171:59 - do is I'm going to create a new class
172:02 - and I'm going to call this cat okay now
172:06 - cat is going to have very similar
172:07 - attributes as dog in fact let's just
172:11 - copy them over okay so we'll paste them
172:13 - like here we have name age hi I am
172:16 - whatever okay now I'm just going to add
172:17 - one thing and in this case I'm going to
172:19 - add let's see color okay say self. color
172:24 - is equal to color okay now this cat
172:27 - object is obviously going to work the
172:28 - same as dog I don't think I need to show
172:30 - you now just take note of what I just
172:32 - did I just copied all of the stuff from
172:35 - here into cat now if you know anything
172:38 - about programming you know that
172:40 - programmers don't like to copy and paste
172:41 - and that you really shouldn't be copying
172:43 - and pasting code so python has actually
172:45 - come up with a solution to what I just
172:47 - did that allows us to not have to do
172:49 - that and that is called inheritance so
172:51 - I'm going to delete all this and I'm
172:52 - going to go back into cat and I'm going
172:54 - to type dog here now what this little
172:56 - bracket up here means is it means parent
173:00 - so whenever you're talking about
173:01 - inheritance you always have a parent or
173:03 - a super class and then you have a child
173:06 - or a like derived class okay and there's
173:09 - a bunch of different words for them
173:10 - they're not really that important just
173:11 - know parent and child is the most basic
173:13 - okay so in this case cat is going to
173:15 - inherit from dog which means dog is the
173:19 - parent class and cat is the child class
173:22 - and it is derived so it's taken from dog
173:25 - so that means if I do class dog and if
173:27 - all I do in here is just type one thing
173:29 - so I type netore uncore and in here I'm
173:33 - just going to put name age and color and
173:38 - I'm just going to do something that's
173:39 - going to look confusing I'm going to
173:40 - explain it after okay super
173:43 - doore
173:45 - netore uncore and I give it name age say
173:50 - self. color
173:53 - equals color and then I create a new
173:56 - object of cat so I'm just going to say
173:58 - Tim equals cat give it a name agent
174:01 - colors in this case we'll do Tim H5
174:05 - color blue blue cat I know okay so we do
174:09 - that we Press Play No errors okay I'm
174:12 - just going to show you if I do Tim
174:15 - dosp what do you think is going to
174:17 - happen take a guess
174:19 - says hi I'm Tim and I'm 5 years old now
174:21 - how the heck does all this work and what
174:23 - did you just do I know that's probably
174:24 - the question you're asking should
174:25 - probably fix that say color so the way
174:27 - this works is when you inherit from
174:29 - another object or another class sorry
174:32 - you actually inherit all of the
174:33 - properties and attributes and methods of
174:35 - that class so when I do tim. speake you
174:39 - can see well Tim is an object of type
174:42 - cat and Cat well I don't see speak here
174:44 - how does that work well since the speak
174:46 - method belongs already in the dog class
174:50 - and we're inheriting from the dog class
174:52 - it is actually carried on to the cat
174:55 - class and we're able to use it like that
174:57 - okay so Tim dope now what I did here
175:00 - with this super. anit I know this looks
175:03 - confusing but pretty much in the
175:05 - initialization of cat which is unique to
175:08 - cat because it has this added um
175:11 - parameter color I simply called the
175:13 - initialization of dog first which means
175:16 - that when I gave it name and I gave it a
175:18 - age it automatically added self. name
175:21 - and self. AG to my cat object of Tim you
175:25 - see how here I didn't type self. name
175:27 - equals name I didn't type self. AG
175:28 - equals age all I did was call The
175:31 - Constructor method or the initialization
175:32 - method of the superclass and the super
175:35 - class simply means dog um and it did
175:39 - that for me now in this example it seems
175:41 - like well why in the world would you
175:43 - want to do that um that like that
175:45 - doesn't make sense there's not that many
175:47 - lines whatever if you have really long
175:49 - methods and really long classes it makes
175:51 - a lot of sense to inherit so in this
175:53 - example it's hard to show but in long
175:55 - ones you do want to inherit now I want
175:57 - to show you that you can add and
175:59 - overload things from the uh parent class
176:04 - so for example the parent class has
176:05 - speak I'm going to add one more method
176:07 - in here I'm going to say Define let's
176:09 - just say talk okay and in here it's
176:12 - going to
176:13 - say print uh bark cuz it's a dog okay
176:18 - now obviously in our cat class if we
176:21 - want to talk we don't want to bark right
176:23 - and that's what's going to happen right
176:24 - now if we do tim. talk it's just going
176:26 - to say bark so if we wanted to change
176:28 - this we can actually
176:29 - overload this or override this method so
176:32 - if I do Define talk in here I can print
176:37 - and in here I'm not going to do bark I'm
176:38 - going to do meow okay like that little
176:42 - explanation point so now if I do tim.
176:45 - talk like this you can see that we get
176:48 - meow instead of bark and that goes for
176:52 - anything in inherited classes okay so
176:55 - anything that we do in here is going to
176:58 - override whatever is happening in this
177:00 - dog class so say we wanted to change
177:02 - speak we could say Define speak in here
177:05 - and then whatever we put in this speak
177:06 - method would overwrite what's in here
177:09 - now that's not to say that it's going to
177:11 - change if you create a dog dog object so
177:12 - if I do like I don't know let's say gym
177:16 - is equal to dog give it a name give it
177:20 - gy clearly age this an old dog we're 70
177:23 - okay and we do jy. talk well we're still
177:27 - going to get if I spell JY correctly
177:29 - bark right so we get bark and meow so we
177:32 - don't actually change anything in this
177:35 - class we just say that well if you
177:36 - create a class or if you create a cat
177:38 - object then it's going to have this talk
177:41 - method which overrides the talk method
177:42 - that we created in dog and this is the
177:44 - same if you do something with uh like
177:46 - these attributes so if I didn't like
177:48 - self. name and I just statically type in
177:51 - a name like I type uh Tech okay uh then
177:55 - when we do
177:57 - tim. speak now you would think that I
178:00 - it's going to get hello I am Tim because
178:03 - that was the name right and I am 5 years
178:05 - old but instead we're going to get Tech
178:07 - so it says hi I am Tech and I am 5 years
178:10 - old and that is because although we set
178:12 - name up here to be equal to whatever
178:14 - name we type in the in as a argument uh
178:17 - we are changing it to Tech and that
178:18 - overrides whatever happens in this dog
178:20 - class okay uh so I hope that makes sense
178:24 - now what else can we override from those
178:26 - classes well we can inherit like
178:28 - multiple times and we can inherit
178:30 - different classes from upper class I'm
178:32 - going to talk about the way you would
178:33 - want to do an inheritance okay so the
178:35 - way you typically want to inherit is you
178:37 - want to have one really General class
178:39 - that kind of applies that's a bit
178:41 - smaller that applies like a bunch of
178:43 - different classes so I'm going to delete
178:44 - these and I'm just going to type out
178:46 - them and show you an example of what I
178:47 - mean by General class so if I created a
178:49 - class and I called it vehicle like that
178:53 - okay is that how you spell vehicle I
178:55 - don't care we're just going to leave it
178:56 - like that okay and then I created an
178:59 - initialization in here okay and the
179:01 - initialization is going to take like uh
179:04 - price uh gas and color okay I know these
179:08 - are random but just just follow along
179:10 - self. price equals price self do gas
179:13 - equals gas and self
179:15 - do color equals color okay now I'm I'm
179:18 - just going to give it a method I'm going
179:19 - to call Define fill up tank like this
179:23 - okay and what's to say self. gas equals
179:27 - and we're just going to say that each
179:28 - gas tank has a maximum of 100 okay say
179:32 - Define um empty tank and this is just
179:36 - going to say self. gas equals z and
179:40 - we're going to say
179:42 - Define gas left and this is simply going
179:45 - to return self. gas okay
179:49 - and the reason I have this is because
179:51 - well in all vehicles we're probably
179:52 - going to want to have um gas right all
179:56 - of our vehicles are going to have gas if
179:57 - they're not electric obviously we're not
179:59 - going to deal with that for now um so
180:00 - fill up tank empty tank and gas left is
180:03 - probably something we want to know for
180:04 - all of our different Vehicles now for
180:06 - example if I create another class and I
180:08 - say class car okay and car is going to
180:12 - inherit from vehicle like that okay and
180:15 - all we're going to do for the init is
180:17 - we're just going to
180:18 - call the vehicle init so how we do that
180:21 - is do super doore uncore anitore uncore
180:25 - and obviously this needs now a
180:29 - price gas and a color so we're going to
180:33 - pass it price gas and color like that
180:38 - and then that's our initialization and
180:40 - in car all we're going to have is we're
180:42 - going to have a method and it's going to
180:44 - call
180:45 - let's actually let's add one more thing
180:48 - here speed okay self. speeed
180:52 - equals speed okay and then here as a
180:56 - method let's just have like beep okay
180:59 - and all this is going to do is simply
181:02 - print beep beep okay now I know these
181:05 - aren't great examples but just follow
181:07 - along so what we have now is we have the
181:08 - vehicle class okay and it has these
181:11 - things that do with gas and obviously
181:13 - gas is going to work for all of our
181:14 - different types of vehicles and and then
181:17 - we create a car class class that
181:18 - inherits from vehicle and in here all it
181:20 - does is it has an extra attribute called
181:21 - speed and it has a method called beep
181:24 - now if I create another class instead of
181:27 - car I want to do truck now truck is not
181:31 - going to say beep beep it's going to say
181:34 - honk honk like that okay and instead of
181:37 - having self. speed we're going to have
181:40 - self. tires okay equals tires because
181:44 - that's a a property that we're going to
181:45 - care about for our trucks because
181:49 - sometimes they get like six tires 18 you
181:51 - know what I mean that's what I mean by a
181:52 - truck okay so you can see that we have a
181:54 - really General class vehicle that simply
181:56 - has a cut a gas and a price and
181:59 - obviously within our truck and car class
182:01 - we're going to care about those
182:02 - attributes so price gas color but in
182:05 - truck we care about tires and when we
182:07 - click beep we want to say hwk hwk and
182:10 - for car we care about the speed that the
182:12 - car can go and when we uh call beep we
182:16 - want to print beep beep
182:18 - okay so that is an example of where you
182:21 - would use inheritance I know this is a
182:23 - really small example a lot of the
182:24 - classes you're going to end up building
182:26 - are going to be like massive and inherit
182:29 - from uh like other classes and you're
182:31 - going to have like large files full of
182:33 - classes but this is the best example I
182:34 - can kind of give you of when inheritance
182:36 - would be useful and same thing if I
182:38 - wanted to do like Define motorcycle then
182:41 - you could do the same thing there and
182:42 - for Wheels you do like self Wheels
182:43 - equals 2 like stuff like that okay so I
182:47 - think I'm going to end the video here
182:49 - hopefully you guys have an idea of how
182:50 - inheritance works one quick thing if I
182:52 - wanted to I could inherit from car as
182:55 - well so if something is inheriting from
182:56 - something you can also inherit from it
182:58 - so that would mean that now truck has
183:00 - all the attributes of car and all the
183:01 - attributes of vehicle because well car
183:03 - has the attributes of a vehicle so since
183:05 - car has it we're inheriting from car
183:07 - truck is going to get it as well just
183:08 - wanted to add that in before we end
183:09 - anyways make sure you guys leave a like
183:11 - And subscribe and I will see you again
183:12 - in the next video
183:18 - hey guys and welcome back to another
183:20 - object and classes tutorial video in
183:22 - today's video I'm going to be going
183:24 - overloading default python methods and
183:27 - why these are extremely useful now if
183:28 - you don't know what I'm talking about
183:29 - just stick around for one second and I
183:31 - will explain it so first of all I just
183:33 - want to talk about what I've already
183:34 - coded here I just have a very basic
183:35 - point class and you can see that our
183:37 - Point object has three kind of
183:39 - attributes in x y and then our
183:41 - coordinates which is self.x and self.y
183:43 - we have a very basic method that can
183:45 - simply move us by x and by y we type it
183:48 - in okay I've created four points down
183:50 - here and these are what we're going to
183:51 - use to kind of test out some examples
183:52 - that I'm about to create so in Python uh
183:55 - remember in my first video I was talking
183:57 - about the fact that if you create
183:58 - integer objects so for example I say
184:00 - like IAL 5 and like zal five if I wanted
184:05 - to add these together all I simply have
184:07 - to do is well put a plus sign right and
184:09 - python knows that this plus sign means
184:11 - Okay add these two things together now
184:13 - how does it know this and how does it
184:15 - know what to do well with integers is
184:17 - pretty straight straightforward but what
184:18 - if we start doing things like strings
184:20 - right if you do s and then you go like 6
184:24 - 7 8 how does python know how to add
184:27 - these two strings together well it would
184:29 - make sense to it just appended on top
184:31 - but someone actually had to code this
184:33 - functionality in and that's exactly what
184:35 - we're going to be doing in this video
184:36 - except with our custom Point object okay
184:39 - and you'll see what I mean in just a
184:40 - second so pretty much what we want to
184:43 - eventually do at the end of this video
184:44 - is be able to add multiply subtract um
184:48 - and compare points without having to
184:51 - reference their attributes outside of
184:53 - the class so right now uh if I do P1
184:56 - plus P2 our program is going to crash
184:57 - because it doesn't know what that means
184:59 - but by the end of this video we're going
185:00 - to be able to do that okay so that's
185:02 - what I'm going to show you right now so
185:04 - in Python there's a bunch of default
185:07 - kind of operations and methods that you
185:09 - can apply on classes and by default uh
185:13 - they're not defined right on our point
185:14 - class if we try to add to things right
185:15 - now that doesn't make sense so what
185:17 - we're going to is add that method so to
185:19 - do this to add the add operation you're
185:22 - just going to do Define underscore add
185:25 - okay and then in here you need to give
185:27 - another Point object so what happens
185:30 - when I try to add a point and another
185:33 - Point object well whatever we're going
185:36 - to return a new Point okay that is
185:40 - simply equal to self.x plus p.x and then
185:44 - self.y + p.y so what this is doing is
185:47 - since we're passing another Point object
185:50 - so when we do like P1 + P2 P2 becomes p
185:54 - and P1 becomes self so we're going to
185:57 - grab the coordinates of P1 add them to
185:59 - P2 and return that in a new Point object
186:02 - okay now the same works for subtract
186:06 - multiply and Division and for a few
186:08 - others as well so I'm just simply going
186:10 - to copy this okay and paste it one more
186:12 - time and instead of add now you could
186:14 - probably guess I'm going to put sub and
186:17 - what this is going to do is allow us to
186:19 - subtract points so it's going to be the
186:21 - exact same except now we're simply going
186:24 - to subtract the coordinates now with
186:27 - multiplication this one is simply Define
186:29 - underscore uncore Moore underscore and
186:32 - this going to allow us to use the ASX or
186:34 - the star uh to multiply two different
186:36 - point objects so same thing it takes a
186:38 - point and in this case when we multiply
186:41 - points I could return a new point with
186:42 - multiplied coordinates but the way it
186:44 - actually works if you know anything
186:45 - about vectors is we're simply going to
186:47 - return the scalar product which means
186:49 - you multiply the first two x coordinates
186:53 - get a value in this case we would get
186:54 - nine and then you actually add it to the
186:57 - y-coordinates multiplied together so in
186:58 - this case we'd have nine um what do you
187:01 - call it plus 8 and that would give us
187:03 - 17 we're not returning a new Point
187:05 - object it's a scaler or like just a
187:07 - number value okay so what we're going to
187:09 - do here is we're going to return
187:11 - self.x multiplied by p.x plus self.y
187:16 - multiplied by
187:18 - p.y and those are the three that I'm
187:20 - going to stick with right now and I'm
187:21 - going to show you a bunch more that we
187:23 - can use to compare Point objects using
187:25 - greater than equal then sign in just a
187:26 - second so I want to test if this is
187:28 - working so let's create a new point I'm
187:29 - going say 0 five is equal to p1+ P2 and
187:34 - I'm going to say 6 is equal to P4 minus
187:38 - P1 okay and then we'll even go as far as
187:41 - creating p7 and multiplying P2 and P3
187:46 - just to make sure everything's working
187:47 - so now I'm simply going to print to the
187:50 - screen P5 P6 and p7 and let's see what
187:54 - we get so you can see here I get main
187:58 - point object main point object and nine
188:02 - now the way that this worked and the
188:04 - reason that we're not actually getting a
188:06 - coordinate value is because I have to
188:07 - show you another method that we can use
188:09 - so that this was actually going to give
188:10 - us something meaningful because right
188:12 - now when we point print out our Point
188:13 - objects right cuz 0 5 is a new Point
188:16 - object cuz when we add point1 and point
188:18 - 2 we have returned sorry a new Point
188:21 - object right so if we want to make this
188:25 - meaningful and not just show us the
188:26 - address in memory uh where the point is
188:28 - stored which it currently is right now
188:30 - we need to add another method and this
188:32 - one is called Str Str okay and what this
188:36 - is going to do is this is going to be
188:38 - called every time we try to convert our
188:40 - Point object into a string so when we
188:43 - try to print our Point object it
188:45 - automatically looks for Str Str and and
188:47 - if it doesn't find it it gives us this
188:49 - kind of uh gibberish right here but if
188:51 - it does find it it's simply going to
188:53 - well use the value that we returned so
188:55 - in this case we want to return I think
188:58 - we'd want to return from string uh
189:00 - probably the self dot coordinates right
189:02 - so I want it to look something like this
189:04 - we have brackets and then Plus St Str
189:09 - and then
189:09 - self.x plus a comma Plus St Str
189:16 - self.y and plus and then another bracket
189:19 - like this okay so now if I try to print5
189:22 - 6 and 7 you can see what we get and
189:25 - there we go so now instead of getting
189:26 - that gibberish we get 66 -3 and -3 now
189:30 - keep in mind you can make this anything
189:32 - you want but you do have to return a
189:34 - string value here for this to
189:37 - work okay so the next methods we're
189:39 - going to talk about I'm just going to
189:40 - put them above string here just for good
189:43 - practice is going to be comparing two
189:45 - points so this is great now we can add
189:46 - we can subtract we can multiply but what
189:49 - if we want to compare so what if we want
189:51 - to see if0 one is greater than 2 or if 3
189:54 - is greater than point 4 well how do we
189:55 - do that we first have to determine how
189:59 - are we going to compare points are we
190:01 - simply going to compare the x's and the
190:03 - Y's or are we going to find like the
190:05 - magnitude of a point like what are we
190:07 - going to do to compare which is
190:09 - larger in my case I want to find the
190:12 - length of a point from the origin so in
190:14 - this case the way this would work um I
190:17 - think I can just bring up a little grid
190:18 - program here and just draw it for you
190:21 - quickly so if you have an origin like
190:24 - this okay I'm just using my mouse right
190:25 - now and you had a point here and a point
190:27 - here well from the origin this would
190:30 - have a distance and from the origin this
190:32 - would have a distance obviously this
190:33 - could be like a distance of seven this
190:35 - could be a distance of two and seven
190:37 - would win right because we don't really
190:38 - care about the negatives if you had
190:40 - something all the way over here with a
190:41 - larger distance then well we would want
190:43 - that to win right um so that's the way
190:45 - that we're going to compare them and
190:46 - I'll talk about that and how we do that
190:47 - in one second so to compare we have four
190:52 - major comparisons I think that we can do
190:54 - anyways I'll type them and we'll see so
190:56 - one of them is greater than and that is
190:59 - GT okay and then you can do self and you
191:02 - also need another Point object like this
191:05 - another one is greater than or equal to
191:07 - and greater than or equal to is simply
191:09 - GE okay and then same thing we need P we
191:13 - have less than so Define and you can
191:16 - probably guess LS or sorry LT what am I
191:20 - saying less
191:21 - than and then we also have less than or
191:24 - equal to so l e like
191:28 - that and we have one more and this is
191:30 - simply equal to so this is if we do the
191:32 - double equal sign then it's going to
191:34 - give us a comparison now in these
191:36 - methods we need to return a true or a
191:38 - false value so in greater than remember
191:41 - the way I said I wanted to compare them
191:43 - is to get like the magnitude of the
191:45 - point from the origin so I'm just going
191:46 - to add a method in here I'm just going
191:48 - to call it uh let's do length maybe okay
191:53 - and then in here I'm simply actually we
191:55 - don't need to take anything we're just
191:57 - going to
191:58 - return the math.sqrt and I'm going to
192:02 - import math right up here and this is
192:04 - simply how you get the length from the
192:06 - origin okay
192:08 - of
192:09 - self.x to the power of two
192:14 - plus what am I doing self.y
192:17 - the exponent to and this is going to
192:18 - give us the length Okay so import length
192:21 - so when I'm doing greater than I want to
192:23 - see if return self.x or what am I saying
192:29 - self. length is greater
192:32 - than P do length like this okay and I
192:35 - believe we do actually need these square
192:37 - brackets here so all this is going to do
192:39 - is it's a Boolean condition it says well
192:40 - if the length of ourself is greater than
192:43 - the other length well then we're simply
192:44 - greater than so let's just copy this and
192:46 - put it in here and in this case we're
192:48 - just going to do greater than or equal
192:49 - sign because this is greater than or
192:51 - equal to we'll copy this again change
192:53 - this around to less than and one more
192:56 - time and this is now just going to be
192:58 - less than or equal to now if we're
193:00 - seeing if two things are equal to each
193:01 - other well that's pretty easy as well
193:04 - all we can do is simply take this or
193:07 - actually the way we're going to do this
193:08 - is just see if the coordinates are the
193:10 - same because if we try doing the math.
193:12 - square root and we get like a large
193:13 - decimal number sometimes decimals kind
193:15 - of mess up in Python and they don't get
193:17 - the same Precision so let's just
193:20 - return if self.x equal equal p.x and
193:25 - self.y equals p.y because that would
193:28 - mean that they are the same points right
193:30 - okay so let's do some comparisons now so
193:32 - let's just simply print if P1 equals
193:36 - equals P2 and then we'll print if P1 is
193:41 - greater than P2 and we can print if P4
193:45 - is less than or equal to
193:48 - uh P3 okay and just test these out okay
193:51 - so we get false true and true and you
193:53 - guys are welcome to mess around with
193:55 - these and kind of figure those out for
193:57 - yourself so I will show you I'm not
193:59 - going to go through all of the methods
194:01 - because there's a lot of ones that you
194:02 - can overload but I'll show you how you
194:03 - can have a look at all of the different
194:06 - methods okay so I'm just going to pull
194:07 - up a web page here that has like a large
194:10 - list of all of the kind of built-in
194:12 - methods that you can override or like
194:14 - what do you call it overload um there is
194:16 - a way in Python to like see all of them
194:19 - and print them to the screen but I
194:21 - completely forget the command so I
194:22 - apologize one of you guys knows that
194:23 - command please let me know in the
194:24 - comments because I've been looking for
194:26 - it and I can't find it but anyways you
194:28 - can see here there's a ton like I think
194:31 - there's like a hundred or something of
194:32 - built-in ones you can use like ad sub Mo
194:34 - div true div Flor div can read through
194:37 - here and see what they all do some
194:39 - useful ones I will mention is probably
194:41 - Len I probably should have talked about
194:43 - that one but it's if you call the Len
194:45 - function on
194:47 - something so actually I'll show you Len
194:49 - really quickly just because I feel like
194:50 - I should have talked about so instead of
194:51 - doing length here I could have just done
194:54 - Define underscore uncore lencore uncore
194:58 - and what this would have done now is if
195:00 - I call like Len of P1 it's just going to
195:04 - return uh whatever value I have here so
195:06 - math. square root okay that's like a
195:08 - really useful one too so I don't know
195:09 - why I didn't talk about that but anyways
195:11 - so we go back to this page for one
195:12 - second and see real numbers slice slice
195:16 - can be useful if you're do deal with
195:17 - kind of like list objects that you're
195:19 - creating items and slices you can go
195:21 - through all these and kind of read them
195:23 - yourself I'm not going to talk about all
195:24 - of them CU I'm sure these you guys
195:25 - probably won't end up using very much um
195:27 - the ones that are very important are the
195:29 - ones I talked about yeah so you can see
195:30 - built-ins like there's something you can
195:32 - do with like dir built-ins to see them
195:34 - all uh and yeah I'll leave this link in
195:37 - the description in case any of you guys
195:38 - are interested in having a look at these
195:40 - but there is some way in Python again if
195:42 - you know that way please let me know
195:44 - okay guys so that's been it for this
195:45 - video in the next video I'm going to be
195:47 - talking about static and class methods
195:50 - and then in the future video I'm going
195:51 - to be talking about private private and
195:53 - public classes in Python so if you guys
195:56 - enjoyed the video please make sure you
195:57 - leave a like And subscribe and I'll see
195:58 - you again in the
196:03 - next hey guys and welcome back to the
196:06 - fifth video in my python objects and
196:09 - classes tutorial Series in today's video
196:11 - I'm going to be talking about class
196:13 - methods static methods and class
196:16 - variables now these are very important
196:18 - and very useful especially if you're
196:19 - coding large projects with multiple
196:21 - different classes and they are fairly
196:24 - complex but I'm going to try my best to
196:26 - explain them right now so pretty much
196:28 - you can see here I've already set up a
196:29 - class and I've already actually coded
196:31 - all the methods and class variables and
196:33 - all the stuff we're going to deal with
196:34 - and I'm just going to go through and
196:35 - talk about it because it just saves a
196:37 - bit of time and makes things a bit
196:38 - easier so first of all let's talk about
196:40 - class variables Now to create a regular
196:43 - variable within a class you can see that
196:46 - we have something like self. name equals
196:47 - name we've been over this we know how
196:49 - this works now when you create a class
196:51 - variable typically you do this at the
196:53 - top of the class and you just simply
196:56 - write like a variable just not inside of
196:58 - one of your methods so you can see up
197:01 - here I have a list says dogs equals and
197:04 - then a list if I wanted to have
197:05 - something like X I could say xal 5 or x
197:08 - equal 5 and I could put that at the top
197:11 - of my uh what do you call it class and
197:14 - then to reference that you have to be
197:16 - inside of the class so this sometimes is
197:18 - useful if you want to have variables
197:20 - that every object in your class is going
197:22 - to need to use and you don't want to
197:24 - have to do like self.x equal x within
197:27 - your initialization and it's just better
197:29 - practice to put variables that are going
197:32 - to be like statically uh used inside of
197:36 - the class if that kind of makes sense so
197:38 - the way that you reference these
197:40 - variables is the same as you would
197:41 - reference uh an attribute within your
197:44 - regular class so you can see here like I
197:46 - do self name equals name to create a new
197:48 - variable self. name when I want to
197:50 - reference it later I would have to type
197:52 - self. right it's the same way to
197:54 - reference these class variables so you
197:56 - can't or I guess you could but you
197:58 - wouldn't want to have um the same name
198:01 - as this like in here and if you did that
198:02 - it would just overwrite this uh so
198:05 - you'll see what I mean in just a second
198:06 - but anyways what I'm essentially doing
198:08 - here inside of my initialization is I'm
198:10 - appending every single dog object that
198:13 - we create into the list dogs now this
198:17 - list dogs be begins to the class dog not
198:20 - to the actual instance of dog so Tim and
198:23 - Jim if I reference dogs and I print that
198:26 - out will be the same value it doesn't
198:28 - change dogs or like dogs is not specific
198:30 - to Tim and it's not specific to Jim it's
198:33 - specific to the entire class uh for
198:35 - every dog object so it's the same for
198:38 - all that an XC like five is going to be
198:41 - the same for obviously Tim and Jim and
198:43 - all other dog objects I hope that kind
198:46 - of makes sense we'll walk through it in
198:47 - just a second okay so let's just first
198:50 - of all just print and figure out like
198:52 - what's the point of this uh class
198:54 - variable like what can we do with this
198:55 - well first of all the good thing about
198:58 - class variables is if you want to access
199:00 - them you don't have to have an instance
199:03 - of the dog object to do so so to see
199:07 - this typically like if I wanted to call
199:08 - so if I remove this class method I
199:10 - remove the static method you want to
199:11 - call method on a dog object you'd have
199:13 - to do the name of the dogs like Tim and
199:15 - then Dot bark or Tim do uh I don't know
199:19 - whatever else that we have like do add
199:21 - do add weight whatever you want to do
199:23 - okay but in this case we can just
199:25 - actually call it on the name of the
199:26 - class so if I do dog Dot and then you
199:30 - can see it's already coming up here do
199:31 - dogs like this we should be able to
199:33 - print this to the screen and you can see
199:35 - that we do end up being able to print
199:37 - this to the screen with a dog object and
199:39 - another dog object so the main
199:41 - difference here with class variables is
199:43 - that you can call them with you can
199:45 - still call like I could still do tim.
199:48 - doogs but it I can also call them with
199:51 - the actual name of the class and that's
199:53 - what makes it useful so you don't have
199:55 - to have an instance uh to call that what
199:58 - do you call it variable if that makes
200:00 - sense and I guess that's all I'm going
200:02 - to explain kind of for class variables
200:03 - because they're not that complicated and
200:04 - if you play around with them you should
200:05 - be able to figure that out figure them
200:07 - out okay so next we're going to talk
200:09 - about static and class methods now you
200:12 - can see here I have at static method and
200:14 - at class method these are known as
200:17 - decorators and you put these above your
200:20 - method like directly above them like
200:22 - this if you want to indicate that they
200:23 - are going to be a special type of method
200:25 - and that's what these two methods are so
200:27 - I'll start I'll first start talking
200:29 - about class methods because we kind of
200:30 - already have touched on it with class
200:31 - variables so the way that a class method
200:34 - works is that you can actually call it
200:36 - on simply the name of the class so you
200:38 - can see inside of here uh my parameters
200:41 - I only have one thing and it's called
200:43 - CLS it's not called self it's called CLS
200:46 - what this this means is the name of the
200:48 - class so if I remove Tim and Jim so I
200:52 - guess I can just comment that out like
200:53 - that whatever then what I can do is I
200:55 - can say dog Dot and then what do you
201:00 - call it numb dogs like this and this
201:02 - will actually work and you can see that
201:04 - I'm not calling it on an instance or
201:06 - like of the dog class or like a object
201:09 - of dog class I'm just simply calling it
201:11 - on the class so if I do this you can see
201:14 - that it gives me zero and that that
201:16 - works right now again you can call it on
201:21 - uh what do you call it like you can call
201:23 - it on an instance like if you say Tim
201:25 - equals dog and name Tim I can still call
201:29 - it on Tim and this is still going to
201:31 - work fine it's just that you don't need
201:34 - to do that right you can do it by just
201:37 - calling with the name now static methods
201:40 - are a little bit different they actually
201:42 - don't need the class to uh to be called
201:46 - so so it doesn't pass in the class so
201:49 - that means that you can't reference
201:50 - anything within the class so the whole
201:51 - point of having this class passed in
201:53 - when you call this method is so that you
201:56 - can use class variables and you can use
201:59 - other methods with in with inside the
202:01 - class so for example if within numb dogs
202:03 - I wanted to use a static method or I
202:05 - wanted to call an initialization or I
202:06 - wanted to do something that revolved
202:08 - around the dog class I would need the
202:10 - class name right so that's why it's
202:12 - passed through but with static methods
202:14 - we only pass whatever parameters we want
202:16 - so we don't have to have a self we don't
202:18 - have to have a class and we don't even
202:20 - have to have any parameters but in this
202:22 - case I'm giving one parameter n so I'm
202:25 - going to show you how this works so I've
202:27 - completely removed any instances of dog
202:29 - in my program there's no objects we're
202:31 - not printing anything whatever okay what
202:34 - I'm going to do now is I'm going to call
202:35 - Bark without passing through any object
202:39 - or any class name and you can see how
202:41 - this works so what I have to do to do
202:43 - this is it has to know obviously where
202:45 - bark is right so it's in inside the dog
202:47 - class so I have to start by typing dog
202:48 - but then I can type bark like this and
202:52 - give it a number and you can see here I
202:54 - just wrote a little comment barks's end
202:55 - time so if I run this you can see we get
202:57 - bark bark bark bark now notice that with
203:00 - inside this bark class I don't do
203:02 - anything like I don't touch any
203:04 - attributes I don't touch any class
203:05 - methods and there's actually no way for
203:07 - me to do that so if I were to try to say
203:10 - I wanted to get the value of the length
203:12 - of dogs right with inside this static
203:14 - method well I would be unable to do that
203:16 - because I don't have self right self is
203:20 - it's not working I don't have a class so
203:22 - how am I going to be able to call a
203:24 - class um variable or another class
203:27 - method I actually can't do that so the
203:29 - point of static methods is when you're
203:31 - just going to be using them as a
203:32 - function but you want to organize them
203:34 - within a class so a really good uh use
203:37 - of static methods for example is say you
203:39 - were created like a class and you called
203:42 - it math okay in here instead of having
203:45 - like an initialization ation and all
203:47 - this stuff you just had a bunch of
203:48 - static methods now why would why do you
203:50 - put them in this math class why not just
203:52 - create them as functions well the thing
203:53 - is you want to be able to import modules
203:56 - within python you guys have probably
203:58 - seen this before right you can import
204:00 - other files that you've created into
204:01 - like main files so when you create a
204:03 - bunch of um like math methods or
204:06 - whatever what You' do is you'd say class
204:09 - math and then you just say like at
204:12 - static method and then you do Define and
204:14 - you'd say like add like this okay and
204:17 - you say like X and X2 and then you could
204:20 - return x +
204:22 - X2 and that way you don't have to create
204:25 - an instance of math you don't have to
204:27 - say like m equals math right you can
204:29 - just say math. add give it two values
204:31 - and it will return it to you and you can
204:33 - do math. subtract and you can organize
204:35 - all like the functions that you wanted
204:36 - to use within that class and then class
204:40 - methods right are more used for like if
204:41 - you want to access class variables
204:43 - without having to pass in an object
204:45 - because it's just going to automat pass
204:46 - whatever the class name is that you're
204:48 - giving it I hope that that makes sense
204:51 - now these I'll touch on these really
204:53 - quickly in case I didn't really talk
204:54 - about them these are known as decorators
204:57 - um I know it's kind of a weird name but
204:58 - pretty much this just denotes the fact
205:00 - that you are creating a class method and
205:04 - you are creating a static method because
205:05 - otherwise it's probably going to get mad
205:07 - at you and tell you that you need to
205:08 - type in self or you need to type in like
205:10 - another parameter or something like that
205:11 - so by doing this not only is it a visual
205:13 - representation for anyone that's reading
205:15 - your code but you're also so just um
205:18 - telling python that this is going to be
205:19 - a static method this is going to be a
205:20 - class method obviously you can have as
205:22 - many static methods as you want as many
205:23 - class methods as you want and they're
205:25 - actually really useful so anyways I'm
205:27 - going to wrap up the video here if you
205:29 - guys have any questions about any of
205:30 - this stuff make sure you leave a comment
205:32 - down below and in the next video I'm
205:34 - going to be talking about public and
205:35 - private classes in Python anyways if you
205:38 - guys enjoyed the video please make sure
205:39 - you leave a like And subscribe and I
205:41 - will see you again in the next one
205:47 - hey guys and welcome to the fifth and
205:49 - final video in my python classes and
205:52 - objects tutorial Series so in today's
205:54 - video I'm going to be talking about
205:55 - public and private classes and how to
205:58 - import your own classes from other files
206:01 - into like a main file uh you'll kind of
206:03 - see what that really means as we move
206:05 - along so the first thing to talk about I
206:08 - guess would be what is the difference
206:09 - between public and private so I've
206:11 - brought an example here I've just kind
206:13 - of written this random example in Python
206:16 - to try to illustrate this to you so in
206:17 - other programming languages there's
206:19 - things known as private and public
206:21 - classes now private classes typically
206:23 - can only be used within the same file or
206:26 - within like a certain scope where public
206:29 - classes are accessed or can be accessed
206:32 - by everyone so private kind of means
206:34 - within something like it's not
206:36 - accessible outside of that whereas
206:38 - public means it's accessible everywhere
206:41 - now I have just a definition I found on
206:42 - Google that I'm just going to read
206:44 - because it's the best way to kind of
206:45 - explain it and I can talk about qu it
206:46 - after so in terms of java and we'll talk
206:48 - about this in a second uh public versus
206:51 - private class and this is the same for
206:52 - most languages means this so public is a
206:54 - Java keyword which declares a member's
206:56 - access as Public public members are
206:58 - visible to all their classes this means
206:59 - that any other class can access a public
207:01 - field or method further other classes
207:04 - can modify public Fields unless the
207:06 - field is declared as final okay so what
207:09 - does that all mean and why did I just
207:11 - give you an example in Java well in
207:13 - Python there's actually no such thing as
207:16 - private or public classes there is
207:19 - conventions that we use to declare like
207:22 - a pseudo like private or like a public
207:25 - class um but there's not really anything
207:27 - restricting us from using private
207:29 - classes so hopefully I can explain this
207:33 - but pretty much this first class up here
207:35 - is private and what makes this private
207:37 - is the fact that we have one underscore
207:40 - at the beginning of the class name now
207:43 - in python or in Java for example when
207:45 - you create a class you would do like
207:46 - like you could do something like this
207:48 - like public static class and then that
207:51 - would mean that this is a public class
207:53 - you could say like private class now in
207:55 - Python we don't have those so the way
207:57 - that we Define this just as a convention
208:00 - is you start with one underscore and
208:02 - then the class name now to create a
208:04 - public method or like attribute of a
208:07 - class it's the same thing you just use
208:09 - one underscore so for example you can
208:11 - see I have two display methods here one
208:13 - is a private method as it has an
208:15 - underscore and the the other one is
208:16 - public as it doesn't have an unders
208:18 - Square again like I've said it doesn't
208:21 - actually matter like you can still use
208:23 - this the regular way you'd use method by
208:24 - calling doore display but by putting
208:26 - this underscore here you're essentially
208:28 - telling other programmers and even maybe
208:30 - yourself later on in the future not to
208:32 - use this and you're saying this is
208:34 - private I don't want you to use it
208:36 - obviously if they decide to use it
208:38 - that's their decision but it's just
208:39 - telling you like don't mess with this
208:41 - don't use this it's private for a reason
208:43 - and typically when you private things
208:45 - that's because you don't want other
208:46 - classes to be able to use it and like
208:48 - mess with the class or do anything like
208:50 - that so same thing here when you create
208:51 - an entire class as private that means
208:54 - everything within the class is also
208:56 - private so I'm going to go over to this
208:58 - file now and you can see I have one file
209:00 - mod and one file tutorial one um now mod
209:02 - is this one that we just went through
209:04 - tutorial one is a new file and you can
209:05 - see that I'm actually importing mod uh
209:08 - so I'm importing this file now when I do
209:11 - that what that does is Imports all of
209:13 - the classes and functions that are
209:15 - within this file so for example if you
209:17 - wanted to organize your program you
209:19 - would have a bunch of different files
209:21 - that contain a lot of different classes
209:23 - and you would import them by simply
209:25 - typing this at the beginning of like
209:26 - your main script this way you can keep
209:28 - everything organized clean and neat and
209:30 - then you can see from Mod I'm importing
209:32 - not private so the way that this works
209:34 - in terms of importing individual classes
209:37 - is you type the name of the Python file
209:38 - in this case mod and then the name of
209:41 - the class or function that you wanted to
209:43 - import and in this case I want to import
209:44 - not private so I can simply do that now
209:47 - say I remove this line I say import from
209:50 - Mod import not private I'm still able to
209:52 - access not private just in a different
209:53 - way you can see now this goes red the
209:55 - way I would now do this is I'd say Mod
209:57 - Dot not private because it's saying
209:59 - we're looking within the mod file for
210:01 - the class or function not private but
210:04 - it's just easier to do it this way so
210:05 - that you don't have to type Mod Dot
210:07 - before all that stuff okay so I'm just
210:09 - going to show you this working I guess I
210:12 - have uh this not private class you can
210:14 - see we have two displays
210:16 - and when I run it we get high now I also
210:19 - want to show you the fact that although
210:20 - I told you that this class is private
210:22 - and that this method is private that we
210:24 - can still actually use them so if I
210:26 - simply do
210:27 - testore display you can see that this
210:30 - now works perfectly fine and it gives us
210:32 - hello so I just felt like I had to make
210:35 - this video although it's not really an
210:36 - important aspect in Python just because
210:38 - if you guys are going to be learning
210:39 - different programming languages you have
210:41 - to understand the difference between
210:42 - private and public classes it's very
210:45 - difficult to illustrate in Python
210:47 - because there's nothing that's truly
210:48 - public or private but just know that if
210:50 - you ever run across some classes that
210:52 - have underscores at the beginning of the
210:54 - name or underscores before method names
210:56 - for example like anit then that means
210:59 - that they are typically private or want
211:02 - to be private at least so you should
211:03 - probably not mess with them and not use
211:05 - them that goes for you as well if you
211:07 - are programming and you want to create
211:09 - stuff that you don't want people to kind
211:10 - of mess with just put an underscore
211:11 - before the name it's just a typical
211:13 - convention in Python uh to do that to
211:16 - create a private or public class anyways
211:19 - that's been it for this video and for
211:21 - the series I hope that you guys did
211:23 - enjoy the series and you did learn a lot
211:25 - if you did please consider subscribing
211:26 - and hitting that like button as it would
211:28 - mean a lot to
211:40 - me hey guys and welcome back to another
211:44 - YouTube video so in today's video I I'm
211:45 - going to be starting a new um tutorial
211:48 - series on intermediate programming with
211:51 - python um so that being said a
211:52 - prerequisite for these videos is going
211:54 - to be that you know a little bit about
211:56 - python you know the basics you know if
211:57 - statements for Loops lists so on um as
212:00 - I'm not going to be reteaching and
212:01 - touching on a lot of those aspects um
212:04 - which I'm going to consider trivial now
212:06 - um I'm going to be teaching some more
212:08 - advanced topics so if you guys are
212:09 - interested in that make sure you watch
212:11 - until the end of the series and you go
212:13 - through all the videos as a lot of the
212:14 - stuff I'm going to do is going to add
212:15 - add on um as we keep going on videos so
212:19 - something I show in the previous video
212:20 - I'm going to add on to it in the next
212:21 - one um and these videos are going to be
212:23 - a really good way to enhance your
212:24 - programming knowledge and to learn a lot
212:26 - more about python that being said a lot
212:28 - of the stuff I'm going to show here is
212:30 - specific to python um and probably will
212:32 - not work in other programming languages
212:35 - that being said let's get ahead and go
212:37 - ahead and get started with our first
212:38 - video and this one is going to be
212:40 - optional parameters now this is probably
212:42 - one of the simplest topics that I'm
212:43 - going to cover in this series but I
212:44 - figured it would be a good starting
212:46 - point so let's just um go up go ahead
212:49 - and go over what a parameter is um so
212:51 - you should already know this but just to
212:53 - catch some of you guys up I have a
212:55 - function here I've defined I call it
212:57 - funk it returns X to the^ of two um and
213:00 - our parameter in this case would be X
213:03 - anything in this bracket is a parameter
213:04 - note you can have multiple parameters so
213:06 - I can have x y z and so on now what we
213:10 - want to do is we want to create
213:11 - something called an optional parameter
213:14 - now again sorry the argument here um so
213:17 - when we I call my function I said call
213:18 - equals Funk five our argument five is
213:21 - passed into the parameter x x is used
213:24 - here and then if I run my program so I'm
213:26 - running it here uh oops have to drag my
213:29 - console over it's on a different window
213:31 - right now oh and I've accidentally
213:32 - opened up something else now
213:35 - have uh one second guys sorry about that
213:38 - okay I have my console which is here uh
213:41 - it prints 25 to the screen uh like
213:43 - expected okay so now we want to create
213:46 - something called an optional parameter
213:48 - so the the whole point of an optional
213:50 - parameter is so that we don't always
213:51 - have to keep typing in parameters um
213:54 - especially if we have uh more than one
213:56 - that we have to type in it can get
213:58 - tedious so the way that we can do this
213:59 - and it's actually really simple and it's
214:01 - extremely useful and I'll show you in a
214:03 - different example later simply beside
214:05 - your parameter so in this case X just
214:07 - put an equal sign and then put what you
214:09 - want it default value to be so in this
214:11 - case I'm just going to put uh one okay
214:14 - so now what what happens is if I call my
214:17 - function and I don't give it a value for
214:19 - x it's simply going to use one so we can
214:22 - show that so again run the program and I
214:24 - get one because one to the^ of two well
214:26 - is one and I didn't put anything in here
214:29 - and I didn't get an error now notice if
214:31 - I get rid of this equals one and I try
214:33 - to call we get an error because it's
214:35 - missing a uh potential argument X right
214:38 - so let's put that back xal 1 now what
214:41 - happens if I do put something in the
214:43 - brackets here of my function call so for
214:45 - example I pr x 5 when I run the program
214:48 - now we get 25 so if you ever put
214:51 - anything in uh your function instead of
214:55 - the uh like default instead of just
214:57 - leaving it blank in this case then it's
214:58 - going to overwrite this default
215:00 - parameter and it's going to make x equal
215:02 - to 5 instead of one now you might say
215:04 - well why is this useful I'm going to
215:06 - show you an example in just a second but
215:07 - I want to show how you can use multiple
215:09 - optional parameters um and how you can
215:11 - mix them with non-optional parameters so
215:14 - let's just rewrite this function um and
215:16 - in this case I'm going to take two
215:17 - parameters I'm just going to say like
215:19 - word
215:21 - and currents or let's say frequency like
215:25 - this okay and now all I'm going to do in
215:27 - this function is I'm simply going to
215:28 - print to the screen word multiplied by
215:34 - frequency like that okay and then here
215:37 - in my function call my word I'm going to
215:39 - say is Tim and frequency five now this
215:44 - should just print to the screen right do
215:46 - this and it does we get Tim Tim Tim Tim
215:49 - now what if I wanted to make the
215:51 - frequency um an optional parameter so
215:54 - all we have to do here is I'm going to
215:55 - change my frequency to be a default of
215:57 - one so that means now I have a parameter
216:01 - that's not optional which is word and a
216:03 - parameter that is optional frequency so
216:06 - when I run the program by just putting
216:07 - in my needed parameter I get Tim and
216:10 - just one time because that's the default
216:12 - value of frequency again we don't get an
216:15 - error um like you might expect and then
216:18 - same thing if I want to change the
216:20 - frequency so maybe I want to make the
216:21 - frequency 10 all I do is I type in a
216:24 - number for frequency so corresponding
216:27 - and then when I run the program I get
216:29 - Tim and then 10 times like that now what
216:33 - happens if I do something like this and
216:35 - I put 10 here um instead of frequency
216:38 - well you'll see what happens we get 10
216:41 - because 10 now is word and frequency is
216:43 - 1 and 10 * 1 well is equal to 10 okay so
216:48 - now let's go to multiple optional
216:50 - parameters um so now I'm going to say
216:53 - add and frequency and I want add to also
216:56 - be an optional parameter so in this case
216:58 - I'm going to say add is equal to 5
217:00 - frequency is equal to 1 okay um so what
217:03 - I'm going to do now is I'm just going to
217:04 - say word is
217:06 - times
217:08 - frequency plus add like that um and now
217:13 - in this case same thing I'll just do
217:16 - word in this case I'll say hello um so
217:18 - our default value for ad is five our
217:21 - default frequency for uh our default
217:23 - value for frequency is one so we should
217:26 - have 5 + 1 um which is six multiplied by
217:29 - word so we should get hello six times
217:31 - and we do and now again I can put put in
217:33 - a value um for add so in this case I'm
217:36 - going to say add is equal to zero
217:38 - frequency is still going to be one so
217:41 - now I get just one time to the screen
217:44 - hello so the way it we're is when you
217:45 - have optional parameters is say I wanted
217:48 - to type in a value for frequency but I
217:50 - wanted to leave add as the default value
217:53 - I'm not actually able to do that because
217:55 - of the order in which I've set these
217:56 - parameters so if I wanted add to still
217:58 - be five but I wanted to change frequency
218:00 - I would have to put five for ad and then
218:03 - I could put a value for frequency like
218:05 - three or something like that okay um and
218:07 - again if we show this ad is going to
218:09 - stay at five frequency is going to be
218:11 - three so we should get hello eight times
218:14 - in which we do
218:16 - um now if I wanted to change that around
218:18 - um and I wanted to say okay well I want
218:21 - ad to always be defaulted to a value
218:23 - like five and I'm hardly going to change
218:25 - that but frequency is going to be
218:26 - something I change a lot when I use my
218:28 - function then we would just flip these
218:30 - around so we' say frequency equal 1 add
218:34 - equals 5 like that so now this is going
218:36 - to uh go to frequency and this is going
218:39 - to go to add um like so I hope that
218:42 - makes sense so now I'm just going to go
218:43 - down and I'm going to show um some
218:46 - better examples to why this is kind of
218:48 - more useful so I've just created this
218:50 - class here um called car all right and I
218:54 - have you can see a bunch of parameters
218:56 - so I have five up here um not including
218:58 - self and then just one here in its
219:00 - method called display now these optional
219:02 - parameters can be used inside of methods
219:04 - as methods really are just functions
219:06 - that apply to a class right so I'll show
219:08 - you right now how this class kind of
219:10 - works um I've just created a new object
219:12 - called whip it's a new car object and we
219:14 - have four Fusion 2012 new um and these
219:17 - are the parameters that it takes right
219:19 - so it takes the make the model year
219:21 - condition and kilometers all of these
219:22 - are required I need to type these in no
219:24 - matter what the next one that I have my
219:27 - method is display um and what this is
219:29 - going to do is simply just print out to
219:30 - the screen um one of two messages if
219:33 - show all is equal to true it's going to
219:35 - print out everything including the
219:37 - condition and the kilometers of the car
219:39 - if not it's just going to print out the
219:40 - make model and year of the car so let's
219:42 - watch this uh run on the screen so this
219:44 - car is a Ford Fusion from 2012 it is new
219:46 - and has 0 km um like so so you can see
219:49 - that this is working well now what if I
219:51 - wanted to say um I want condition and I
219:55 - want kilometers to both be optional
219:57 - parameters so typically when you buy a
219:59 - car most people buy new cars so I'm
220:02 - going to say the condition is going to
220:03 - be defaulted to new and kilometers is
220:06 - going to be equal to zero because if
220:08 - you're buying a new car well then
220:09 - kilometers should be equal to zero so
220:12 - only if um I want to I'm going to change
220:15 - that so now same thing here if I go like
220:18 - this and I run the program we should get
220:21 - the same thing so this car is a Ford
220:23 - vision from 2012 it is new and has zero
220:25 - kmers and indeed we do we didn't need to
220:27 - type in those parameters because again
220:29 - they're optional um next one I'm going
220:31 - to show you is down here in display same
220:33 - thing I can set this equal to something
220:35 - like true so show all equals true and
220:37 - now when I call my
220:41 - display um it automatically shows all
220:44 - unless I specify otherwise by typing in
220:47 - false like so and then we get this car
220:50 - is a Ford Fusion from 2012 now this is
220:53 - really useful if you have a lot of
220:54 - different parameters it is especially
220:56 - useful when you're typing and working
220:58 - with classes so that's why I wanted to
220:59 - show you this example I hope that you
221:01 - guys are able to implement this in your
221:03 - programming um anyways that's been it
221:06 - for this video uh make sure you guys
221:08 - stay tuned for the next one which should
221:10 - be coming out in just a few days
221:18 - hey guys and welcome back to another
221:21 - YouTube video in today's video uh the
221:23 - second video in my uh intermediate
221:25 - python tutorials I'm going to be going
221:27 - over static and class methods um so
221:30 - pretty much these are just uh different
221:32 - things you can use uh within a class uh
221:35 - and I'm going to explain what they do
221:36 - and why they're useful so without
221:38 - further Ado let's go ahead and get
221:39 - started um so because these two things
221:42 - uh methods obviously a part of a class
221:44 - use a class we need to First create a
221:46 - class so in this instance I'm just going
221:47 - to make a class I'm going to call it
221:49 - person um it is of class object and then
221:53 - I'm just going to start off by making my
221:55 - initialization uh method here give it
221:58 - self I'm also going to give it name and
222:01 - age and we move to the next line so
222:03 - let's just assign our variables here
222:05 - here self. name equals
222:07 - name and self. AG is equal to H okay the
222:12 - next method I'm going to make um this
222:14 - one is going to be called get
222:18 - population this going type self um
222:21 - actually here I'm going to type CLS and
222:23 - I'm going to get into what this does uh
222:25 - in a little bit and I'm going to return
222:27 - CLS do population and now I just
222:31 - remembered that I actually forgot to
222:33 - make this up here I'm going to make a
222:35 - class
222:36 - variable um where I'm just going to say
222:39 - population is equal to 50 like so okay
222:43 - one more method this one I'm going to
222:44 - call the fine and then is adult and then
222:49 - in here I'm just going to put age I'm
222:50 - going to say
222:52 - return age greater than equal to 18 okay
222:57 - I'm also going to make one more method
222:59 - down here just to show you the
223:00 - difference between a bunch of these and
223:01 - I'm just going to call it Define
223:03 - um
223:04 - display okay and so it's going to take
223:08 - self um and that's actually all we need
223:11 - we're just going to print to the screen
223:13 - in this one we're going to say self do
223:16 - name and then
223:19 - comma
223:22 - is and then comma self. AG comma years
223:29 - old so this should if I did this right
223:31 - it's going to say whatever the person's
223:33 - name is is and then their age years old
223:35 - so for me 18 years old so now let's
223:39 - create a new instance of this class down
223:41 - here um so I'm just going to call this
223:43 - one new person going to set it equal to
223:47 - a person whose name is
223:50 - Tim and whose age is 18 like so and now
223:54 - I'm just going to go through this class
223:55 - and kind of uh go through what we've
223:58 - actually done here so pretty much what
224:00 - I've started off by doing is I've
224:01 - created a class variable population
224:03 - equals 50 I've done my uh Constructor
224:05 - method um which is just going to
224:06 - initialize my variable's name and age
224:08 - and then I've created two methods in
224:09 - here which actually aren't done and
224:11 - they're called get population um and is
224:14 - adult
224:15 - now the name of this video is class
224:17 - methods and static methods so one of
224:19 - this is a class is a class method and
224:21 - the other one is a static method um go
224:23 - ahead and guess which one you think is
224:26 - uh
224:27 - which so I'm going to tell you right now
224:29 - the first one is actually a class method
224:32 - and the next this one here is a static
224:34 - method and the way that we denote these
224:36 - in Python is by putting something called
224:38 - a
224:39 - decorator above these methods um so it's
224:42 - just an at sign and then the name uh so
224:45 - in that case static method or class
224:47 - method in this case static method now
224:49 - what is a class class method and what is
224:52 - a static method and the best way to
224:54 - explain these is to use an example um so
224:56 - pretty much a class method means that
224:59 - you can call it on any um instance of a
225:02 - class so you don't need to have uh for
225:06 - example I don't know what to say you
225:08 - don't have to have an object already
225:09 - created of that class you can just call
225:11 - it on the class so for here for example
225:14 - I've done something like new person and
225:15 - it typically if I didn't have any other
225:18 - um any static methods or class method I
225:20 - would just say like new person. display
225:22 - or new person.get population what this
225:24 - class method allows us to do is do
225:26 - something like this so we can do
225:29 - person.get
225:31 - population now person is simply the name
225:34 - of our class it's not the name of an
225:36 - object of that class so new person is an
225:39 - object of class person whereas person is
225:41 - just the name of the class and if I do
225:43 - that and I print this to the screen so I
225:45 - print person.get
225:47 - population assuming I have no errors
225:49 - here um oh it says it's cuz I haven't
225:52 - put uh the little brackets here my bad
225:54 - doget population it pops up to the
225:56 - screen and it gives us the value of 50
225:58 - and again we didn't have to create an
226:00 - object to use that method because it is
226:03 - a class method um I hope that makes
226:05 - sense I'll try to explain it maybe one
226:07 - more time really quickly pretty much you
226:09 - don't need to create an object of the
226:11 - class to use any methods that are
226:13 - decorated as class method
226:15 - now also in class method all that's
226:18 - passed to the class method um is well
226:21 - the class because it's not actually an
226:23 - object we don't need this self parameter
226:25 - here like we need um in our
226:27 - initialization method and in any other
226:29 - regular methods that we have um we just
226:31 - need one variable we can call whatever
226:33 - we want in this case I call it CLS which
226:35 - is going to store well what class you're
226:37 - getting pretty well and then we can add
226:40 - any other parameters that we want so I
226:42 - can add X could add y um Ely many after
226:45 - that we just need to make sure that we
226:47 - have at least one in there because for
226:49 - example if I remove this um CLS like
226:52 - that it's going to say take zero
226:54 - positional argument but one was given
226:56 - because the class name is automatically
226:58 - sent into um this method when we call it
227:02 - okay the next type of method is static
227:05 - method um and this one is similar to
227:08 - class method um except it can be called
227:11 - without using that class I want to say
227:14 - so doesn't take a self parameter and it
227:16 - doesn't take a class parameter um so you
227:18 - don't actually need anything in here in
227:20 - this case I have age just cuz I want to
227:21 - be able to compare age um but it doesn't
227:25 - need any parameters if I did something
227:26 - like this it would work fine so the way
227:28 - we denote that again is with the at sign
227:30 - static method just above where the
227:32 - method is defined um and to use this
227:35 - method I can do something like person do
227:38 - is adult and then in here if I put
227:41 - something like five we're going to get
227:43 - back the value of false which you can
227:45 - see here if I do a value like 21 we get
227:49 - a value of true now why is this useful
227:52 - what's different than class method um
227:54 - static method is just used when you
227:56 - don't need self and you don't again need
227:59 - that actual object and it's just a good
228:01 - organizational way of storing a bunch of
228:03 - methods so for example if you had like I
228:06 - don't know maybe a math class that you
228:07 - created um and you wanted to have a few
228:10 - math objects and then you wanted a bunch
228:12 - of static methods that were all stored
228:14 - under math so for example when you use
228:16 - the math module in Python you use
228:18 - math.round or math. so on that's an
228:21 - example of possibly a static method or
228:23 - just a function within the math class um
228:26 - you want to organize all your static
228:28 - methods which in within that class um so
228:30 - you would call like whatever the class
228:32 - name is math and then dot the method and
228:34 - then you give it an argument and it'll
228:35 - return that and work fine uh I hope that
228:38 - kind of makes sense it is hard to
228:40 - explain if you don't have like a lot of
228:42 - good use cases for it um class method
228:44 - meod it just takes the actual um class
228:47 - and then it can access anything within
228:49 - the class um that's public to the class
228:52 - so here you see I had do cs. population
228:56 - and population is a variable defined up
228:58 - here this static method it can't access
229:00 - this population um variable because um
229:04 - it doesn't have access to the class name
229:06 - right it it doesn't it's not pass that
229:07 - information um so it can only use the
229:10 - parameters that you pass it it can't use
229:12 - any that are defined within the class um
229:15 - and that's really the best way I can
229:17 - kind of explain it to you guys um and a
229:19 - good way to understand how to use this
229:21 - um and why they're useful is to use them
229:23 - in your own um use cases so again static
229:25 - method um You can call just by calling
229:28 - the person uh the name of the class and
229:30 - then that method um given whatever
229:32 - parameters it doesn't need any
229:33 - parameters if I do something like this
229:36 - and I'll just put like five greater than
229:38 - or equal 18 this still works um you
229:41 - don't need any parameters whereas a
229:43 - class method you need one parameter at
229:45 - least at minimum um which is going to be
229:47 - that class name and it has access to
229:50 - anything within the class so any
229:51 - variables you define um or other static
229:54 - methods within like within this class
229:55 - method you could call another static
229:57 - method um and so on so yeah I hope that
230:01 - makes sense to you guys it is kind of
230:02 - hard to explain the static and class
230:04 - methods but they are really useful um
230:06 - especially if you're trying to organize
230:07 - things um and when you get further on
230:10 - with object orientated programming in
230:11 - Python you definitely notice that you
230:13 - will use these a lot anyways that's been
230:15 - it for this video um please make sure
230:16 - you guys leave a like on the video and
230:18 - subscribe and I will see you again in
230:20 - the next
230:25 - one hey guys and welcome back to another
230:28 - YouTube video in today's video this is
230:30 - the third video in our uh intermediate
230:33 - python uh tutorials and I'm going to be
230:35 - going over the map function um so pretty
230:38 - much the map function is an extremely
230:40 - useful tool that allows us to well apply
230:43 - a function to list and then create a new
230:46 - list um with those new values and you'll
230:49 - understand what I mean as I go through
230:50 - an example here so before I even start
230:52 - using the map function I want to just
230:54 - present us with a problem um that the
230:56 - map function can solve and this is kind
230:57 - of the best way to understand it so I'm
230:59 - going to create a list um I'm just going
231:01 - to call it Li of integers up to uh 10
231:05 - like this so 9 and 10 okay um and now
231:08 - I'm going to create a function and I'm
231:10 - just going to call it funk and it's
231:11 - simply going to take one parameter X and
231:14 - all we're going to do is we're going to
231:15 - return x to the exponent x very simple
231:20 - okay now what this problem is it's very
231:24 - simple um I want you or I want to be
231:27 - able to apply this function X to every
231:30 - value in the list here so one uh to 10
231:34 - um and then have that stored in a new
231:36 - list so intuitively the way that you
231:39 - would want to do this U or the way that
231:40 - you would try to do this at least is you
231:42 - make something like new list is equal to
231:44 - this
231:45 - you'd write a for Loop you say 4X in Li
231:49 - and then You' say new list. aend um and
231:53 - then you would put well Funk and X like
231:57 - that and then if you printed out your
231:59 - new
232:00 - list you would get that value I don't
232:04 - know why print is showing up in a
232:05 - different color now but anyways um and
232:08 - there we go so we get 1 4 27 and so on
232:11 - and so forth okay um so now what we want
232:15 - to do is use the map function to do this
232:18 - faster so this is a very valid way to do
232:20 - this this works fine but I can actually
232:21 - shorten all four of these lines into one
232:25 - um by using the map function so let's go
232:27 - ahead and do that now so I'm going to
232:29 - start by typing uh actually we're just
232:31 - going to print because I want to print
232:33 - first starting with I'm going to do list
232:36 - um like that and I'll tell you why in a
232:38 - second I'm going to write my map
232:39 - function like so uh and now your map
232:42 - function takes two arguments um so it
232:45 - takes a function and it takes a list so
232:48 - let's give it our function which in this
232:49 - case is going to be called Funk and then
232:52 - let's give it our list so I actually
232:53 - don't need these double brackets here
232:55 - excuse me let's give it our list which
232:57 - in this case is Li so let's talk about
233:00 - what this really is doing right now so
233:02 - the map function takes a function which
233:05 - is Funk so the name of our function and
233:06 - it takes a list which is Li what it's
233:09 - going to do is it's going to apply this
233:11 - function to every element in the list
233:14 - and we can watch this happen we run the
233:16 - program and you see we get the exact
233:18 - same value as we did before um and
233:22 - that's extremely uh extremely useful in
233:24 - Python because a lot of times you want
233:26 - to apply a function or even possibly
233:28 - multiple functions
233:30 - onto um a VAR or onto a list or every
233:34 - element of the list and you don't want
233:35 - to have to type out that whole for Loop
233:37 - yes you can do that it works fine but
233:39 - the map function is just a shortcut to
233:41 - be able to do that um so let me just
233:43 - show you now uh maybe a few other
233:46 - examples that we can use so like using
233:49 - this map function there's another way
233:50 - that we can create this and it's totally
233:52 - preference which one you want to use I
233:53 - like using map just CU it's kind of cool
233:55 - um you can also use something called
233:56 - list comprehension um and this is
233:59 - something I would have shown in some my
234:00 - previous python tutorials uh like from
234:02 - way back like years ago on my channel
234:05 - but I'll go over it quickly now um and
234:07 - the way that this works is you can do
234:09 - the same things you can say funk X for X
234:13 - in
234:15 - Li now this is actually going to give us
234:17 - the exact same value as what we have up
234:19 - here with this map uh function Li for
234:22 - example because what we're going to do
234:23 - is we're going to say we're going to
234:24 - take this right here so whatever this
234:27 - expression is um and we're going to do
234:29 - it uh for every value of x in the list
234:32 - so that's exactly what this map function
234:34 - does um and it's just going to turn it
234:36 - into a list because we put our square
234:37 - brackets here so if I print this out see
234:39 - we get again the same value um and
234:42 - that's how list comprehension works now
234:44 - for list comprehension you can also add
234:46 - um like an expression in here so I can
234:48 - do something like if um let's say
234:52 - x uh modulus oops modulus 2 equals
234:57 - equals z and now it's only going to do
234:59 - this uh or put this into the list if x
235:03 - is divisible by two uh syntax eror oh I
235:07 - forgot my square bracket here my bad I
235:09 - don't know how even got rid of that
235:11 - let's run
235:12 - that oh it's because that is why all
235:16 - right excuse me on that okay so now we
235:18 - get 4 2 5 6 so it's only doing it for
235:21 - the even numbers of X um so yeah those
235:24 - are two really cool ways to kind of
235:26 - change a list or modify them apply a
235:28 - function to them in Python say Obviously
235:31 - you might want to use a function that's
235:32 - more advanced than this um this is just
235:34 - for a basic example and if you wanted to
235:35 - apply maybe two functions to it you
235:37 - could have X be changed here and then
235:40 - you could return like function two of x
235:44 - to the X here and then that would put um
235:47 - that value obviously in the map so again
235:50 - map takes two parameters a function and
235:52 - a list um and it will apply uh the
235:55 - function to every value in that list I
235:58 - hope this has been useful for you guys
236:00 - if you did enjoy the video please make
236:01 - sure you leave a like And subscribe and
236:03 - I'm going to be moving on to some more
236:05 - complicated and um other examples using
236:08 - map and other functions um in the next
236:10 - video so make sure you stay tuned for
236:12 - that
236:18 - hey guys and welcome to the fourth video
236:20 - in my intermediate python tutorials and
236:23 - in today's video I'm going to be going
236:24 - over the filter function so this one is
236:27 - very similar to what I did in the last
236:28 - video which is the map function um but
236:31 - obviously it has a few differences but
236:32 - the filter and map function are nice to
236:34 - learn back toback because they can be
236:36 - used together um and a lot of people do
236:38 - use them together when they're making uh
236:40 - programs so I'm just going to go ahead
236:42 - and start off by typing out two fun
236:44 - functions here uh that we're going to be
236:45 - using in our examples so I'm just going
236:48 - to make one function called add seven
236:50 - which is simply going to return seven
236:52 - and I'm going to make another one which
236:53 - is called is odd and it's just going to
236:56 - return if the number is an odd number so
236:58 - the way we do that again is X modulus 2
237:00 - does not equal zero like that okay
237:04 - pretty straightforward now I'm just
237:06 - going to make a new list in this case
237:07 - I'm just going to go 1 2 3 4 5 6 7 8 and
237:10 - nine and then we'll even add a 10 in
237:13 - there and and now I'm going to go over
237:15 - uh what the filter function does so I
237:18 - want to assign our uh a new variable
237:20 - here create a new one I'm just going to
237:21 - call this B and I'm going to make it
237:23 - equal to
237:24 - list filter which is the name of our
237:27 - function just like this and now filter
237:29 - function actually takes the same
237:30 - arguments that our map function did in
237:33 - the last video it takes a function and
237:35 - it takes an iterable uh list so we can
237:38 - take a string as well um but typically
237:40 - we just pass it a list something that's
237:42 - iterable and that you can go over um so
237:44 - what I'm going to put in here for our
237:46 - first function is I'm going to put is
237:48 - odd and then I'm going to give a list a
237:52 - now the way filter function works is if
237:54 - this value so it's going to it's going
237:56 - to do the same thing the map function
237:57 - does it's going to pass every element in
237:59 - our iterable item uh in this case the
238:02 - list to the function is odd so it's
238:03 - going to start with one it's going to
238:04 - pass one in there it's going to say one
238:06 - modules 2 does not equal z um which is
238:09 - true so it's going to give us a true
238:11 - value and then it's that's going to be
238:13 - added to the list because this function
238:16 - returned a true value now say we put two
238:18 - in here and we go and we say 2 is X two
238:21 - modules two well that does equal zero so
238:24 - we get a false value returned here now
238:27 - two is not added to the list this is
238:29 - essentially filtering out elements based
238:32 - on um a predefined function so obviously
238:35 - you can make your function that you want
238:36 - to check um a lot longer and a lot more
238:40 - extensive so you're filtering out more
238:41 - items but this is extremely useful when
238:43 - you're solving problems so rather than
238:45 - going through a for Loop and checking
238:46 - every single item um like we might have
238:49 - done with the map function to add things
238:51 - into a list we can just simply call
238:53 - filter um give it the function that we
238:55 - want to filter um based on and then a
238:57 - list and it's going to return that new
238:59 - list so let's just go ahead and run the
239:00 - program here and make sure that
239:01 - everything's working fine um so I'm just
239:03 - going to print out a to the screen and
239:05 - I'm going to print out B and we can see
239:08 - that B has essentially filtered out all
239:10 - of the elements um that were even so we
239:13 - get 2 6 8 10 they are all gone so now I
239:16 - want to show you how we can implement
239:18 - this with our map function um why is
239:20 - this useful what can we use the map
239:22 - function for so I'm make another list
239:24 - here and I'm going to call it C and this
239:27 - time I'm just going to do list map and
239:30 - then inside a map I'm going to do filter
239:33 - but before filter I'm just going to
239:34 - apply another function so in this case
239:36 - I'm going to do add seven and then in
239:39 - filter here I'm actually just going to
239:40 - change this to B because I'm going to
239:41 - type the same thing now let's go over
239:43 - what I just did here
239:44 - so essentially what's going to happen
239:46 - now is we're using the map function
239:48 - which if you don't know go back and
239:49 - watch the previous video um and we're
239:51 - going to apply this new list B which has
239:54 - been filtered um so we filtered out this
239:57 - original list U now we have 1 3 5 7 n so
240:00 - far and based on that list we're going
240:02 - to add seven to every element in that
240:04 - list now again if you wanted to save a
240:06 - line I could just get rid of B here and
240:09 - I could simply paste that in here
240:12 - removing list like that um and this
240:15 - would work fine so let's go ahead and
240:17 - see what actually happens here again
240:19 - we're just taking this new filtered list
240:22 - and now we're applying another function
240:23 - to it um in this case add seven so let's
240:25 - make sure that this is indeed working I
240:27 - haven't made a mistake here so we'll
240:28 - print a again and I will print C and you
240:33 - can see um that we do indeed get that so
240:36 - our one add seven we get eight our three
240:39 - add seven we get 10 5 7 and so on you
240:42 - can see how this works
240:44 - now these are extremely straightforward
240:46 - examples but if you're doing a list and
240:48 - for example you wanted to filter out any
240:50 - elements that contained a certain digit
240:52 - or um that met a certain criteria then
240:54 - you could create a more advanced filter
240:56 - function uh function to filter based off
240:58 - of that had a whole bunch of criteria
241:00 - and then it's going to return a true or
241:01 - false value so I'll show you here if I
241:03 - do something like just return
241:05 - true uh and I don't return a condition
241:08 - per se um then every element in my list
241:10 - is going to be um sent through because
241:12 - nothing's going to be filtered out so
241:14 - again if I print C
241:16 - here all of our elements are here so we
241:18 - have 10 elements because we're always
241:21 - returning true same thing if I always
241:22 - return
241:23 - false then none of our elements are
241:25 - going to be printed because well it's
241:28 - always false so the way to think about
241:30 - it is um I'll uncomment out this for a
241:33 - second is what this filter function does
241:35 - is it's going to apply a function that
241:36 - gives us a true or false value um to
241:40 - every element in the list if when that
241:42 - element is applied to that function we
241:44 - get a True Value then it's going to be
241:45 - created in that new list which filter
241:48 - returns to us um like that now again
241:51 - yeah this is really useful for solving
241:52 - problems and I just want to show you
241:53 - what happens if I do something like
241:55 - return one um and I'll print C to the
241:58 - screen
241:59 - here you can see we get every um every
242:02 - element out of here so pretty much the
242:04 - way is uh in Python something is said to
242:07 - be true as long as it's not zero if it's
242:09 - a number so like if I pass something
242:10 - like high well if you say is high true
242:14 - technically high is true um again if I
242:17 - print
242:18 - C uh we're still going to get every
242:20 - element although I didn't pass the value
242:22 - true um High technically evaluates to a
242:25 - true value in Python the only thing
242:27 - that's not going to evaluate to a true
242:28 - value is something like zero so now if I
242:31 - print C you can see we get an empty list
242:34 - um just wanted to add that in at the end
242:36 - there um teach you something you might
242:37 - not have known there um so anyways
242:39 - that's been it for the filter function
242:41 - in the next video I'm going to tie these
242:43 - all together with something called
242:44 - lambdas and what they look like is that
242:48 - uh you can see it highlights here as a
242:49 - keyword and pretty much this is a kind
242:51 - of function that we can use so we don't
242:52 - have to keep creating all these other
242:54 - ones at the beginning of our program um
242:56 - and they're extremely useful and they're
242:57 - really cool so make sure you guys stay
242:59 - tuned for the next video and I'm going
243:00 - to be explaining how we can use those
243:01 - with list uh maps and on their own
243:04 - anyways if you guys enjoyed please make
243:05 - sure you leave a like And subscribe and
243:07 - I will see you again in the next video
243:15 - hey guys and welcome back to the fifth
243:17 - video in my Advanced Python programming
243:19 - tutorials in today's video I'm going to
243:21 - be going over Lambda uh I think that's
243:24 - the way you say it at least uh excuse me
243:26 - if I'm going to say it wrong this whole
243:27 - video which pretty much stands for an
243:29 - anonymous function now these are
243:31 - extremely useful um and they don't take
243:34 - up very much space in your program which
243:36 - is really good I'm going to show you
243:37 - exactly how they work um and what they
243:39 - do so I first want to just start off by
243:41 - defining a regular function again this
243:43 - is one example I've been using a lot I'm
243:44 - just going to say Define funk say like
243:46 - return x + 5 that's what our function is
243:49 - going to do it's simply going to add
243:50 - five uh to the number whatever we give
243:52 - it so right if I print something like
243:54 - Funk of two we should get
243:57 - seven there we go and we get seven to
244:00 - the screen now for an extremely basic
244:02 - function like this um often times you
244:05 - don't want to have to write a function
244:07 - definition and take up uh like two lines
244:09 - of code like this um it's easier to
244:11 - write it in a different way and it looks
244:13 - uh like more smooth maybe more slick in
244:15 - your program and I'm going to show you
244:16 - how to do that so that's one way that we
244:18 - can do it by making a function like that
244:20 - another way and this is using Lambda is
244:22 - to do something like this so the name of
244:23 - our function say funk I'll say funk 2 is
244:27 - equal to and then we're going to type
244:29 - our keyword Lambda like this you can see
244:31 - it highlights um in Orange just like our
244:34 - definition key here for our function
244:36 - we're going to give it a parameter or
244:38 - multiple parameters I think you can use
244:40 - multiple parameters at least and then
244:42 - we're simply going to State what it
244:43 - returns
244:44 - so the way this works is you type Lambda
244:47 - the parameter um or multiple parameters
244:49 - which we're going to try in a second uh
244:51 - a colon and then whatever value you're
244:53 - going to return so the thing with Lambda
244:55 - is it's used when you have one uh return
244:59 - or one expression in your function so
245:02 - something like this so again I can do
245:04 - return x + 5 over 4 like I could do a
245:06 - whole expression as long as that
245:08 - expression fits on one line um then
245:10 - that's perfectly fine to return and I'll
245:12 - show you how this works so if I say
245:16 - print Funk 2 and I just give it number
245:21 - like
245:22 - nine there we go we get 14 and seven so
245:26 - it works just like a regular function um
245:28 - and it kind of just looks like a
245:29 - variable so we're saying function two is
245:31 - equal to an anonymous function that's
245:34 - what Lambda stands for anonymous
245:35 - function with the parameter X and simply
245:37 - going to return x + 5 now these are
245:39 - really useful um for using with the map
245:42 - function and the filter function which
245:43 - I'm going to show you later so you don't
245:44 - have to constantly create a new function
245:46 - up at the top of your program and you
245:48 - can also use them inside of other
245:50 - functions so let's let's uh start by
245:52 - doing that so we're going to say funk 2
245:55 - simply just going to copy it and paste
245:57 - it into my other function and then I'm
245:59 - going to return Funk 2 of
246:03 - X+ 85 let's try that and now if I call
246:08 - my
246:09 - function we can see that we get 92 like
246:12 - so now this again is really useful
246:15 - because you want to um often times
246:18 - create another function or use something
246:20 - multiple times within a function um but
246:22 - you might not want to like write a new
246:24 - one up here like Funk two um you just
246:27 - want it to be only used within that
246:28 - function and in that case you would use
246:30 - Lambda as it keeps it all contained and
246:32 - at the top of your function you can
246:34 - write a bunch of other mini functions um
246:36 - that you can then use multiple times
246:38 - within your program it's hard to see the
246:39 - use case for it in small examples like
246:41 - this but they are extremely useful um
246:43 - especially in like more in-depth code
246:46 - longer code so now I'm going to show you
246:48 - with multiple parameters so I believe
246:51 - and I'm not sure but we'll see if we can
246:53 - do this um so we're going to try and
246:55 - we're going to make Funk 3 is equal to
246:58 - Lambda x y and then we're simply just
247:01 - going to return X+ y so let's just see
247:03 - if we call fun three and let's give it a
247:06 - value like five and five and we'll print
247:10 - that to the screen as well
247:14 - see there we go so that does work as
247:16 - well so you can give this infinitely uh
247:19 - an infinite amount of parameters just
247:20 - like you'd be able to do something like
247:22 - this in our function um and you can also
247:24 - I believe do optional parameters so I
247:26 - can do something like yal 4 and then if
247:29 - I put five we should be getting a value
247:31 - of nine here and there we are so you can
247:33 - use optional parameters um you can do
247:35 - everything that you'd be able to do with
247:36 - a regular function except you can just
247:39 - return one expression um like that okay
247:42 - so let's now use this with our map
247:45 - function and our filter function so in
247:49 - earlier videos uh I used the map
247:51 - function and to recall what that does
247:53 - I'm just going to create a list quickly
247:54 - say a
247:56 - equals 1 2 3 4 5 6 7 8 9 oops n and 10
248:01 - like that and I'm now just going to say
248:04 - let's say new
248:07 - list equals list
248:12 - map and then we're going to have a
248:13 - function in this case I'll just write
248:15 - funk for now and then we give it a list
248:17 - right like a so uh what I want to do now
248:20 - is actually want to just put a function
248:23 - in here uh without having to create a
248:25 - new one up here like I don't want to
248:26 - Define Funk so this is a perfect example
248:29 - where we can use Lambda we don't even
248:31 - have to make a variable like equal to
248:32 - the function anymore we can just type
248:34 - Lambda right in here so Lambda and then
248:37 - we so X and we'll say x + 5 so now we
248:40 - again should simply just be adding five
248:42 - um to each of the El elements in a and
248:44 - then print so we're just print new list
248:45 - to the screen now and see if this is
248:48 - indeed working and there you go we can
248:50 - see we started at one so six uh all the
248:52 - way up to 15 like so again that saves us
248:55 - now having to make a function at the top
248:58 - of our program that we're only going to
248:59 - use for one specific case which is this
249:02 - map function um and again we also don't
249:05 - have to create like Funk equals Lambda
249:09 - up here but you can if you want if
249:10 - you're going to use it in a different
249:11 - case you can just type it right in this
249:13 - same line as uh your map function or as
249:16 - your fil with your filter function so
249:17 - this works the same with the filter
249:18 - function I'll do
249:20 - filter like so um it's going to be our
249:23 - function I guess uh yeah I believe this
249:27 - works with the filter function oh yes it
249:29 - does okay so what this is going to do
249:31 - now is we're just going to return X
249:34 - modulus 2 equal equal Z so again now
249:37 - given X we're going to see if it's
249:38 - divisible by two uh if it is we return
249:40 - true we add that element to the list
249:42 - otherwise we will not we check now we
249:44 - get 2 4 6 8 10 and there we go so you
249:47 - can see why Lambda is extremely useful
249:50 - it's really cool um especially if you
249:51 - want to create a lot of mini functions
249:53 - or you want to create functions within
249:54 - functions um so keep everything nice and
249:56 - organized and it's a nice trick to be
249:58 - able to use in Python so with that being
250:00 - said that's been the end of the video
250:02 - today if you guys did enjoy and you did
250:04 - learn something please make sure you
250:05 - leave a like And subscribe to the
250:06 - channel and I will see you again in the
250:08 - next tutorial
250:14 - hey guys and welcome back to another
250:16 - YouTube video so this is the sixth video
250:19 - in my python intermediate tutorials and
250:21 - today's video I'm going to be talking
250:23 - about Collections and more specifically
250:25 - counter which is a part of the
250:27 - collections module so what is the
250:29 - collections module pretty much it's a
250:31 - built-in module in Python that's going
250:33 - to allow us to have different kinds of
250:35 - data types so that we can store
250:36 - information sort through information um
250:38 - and do some cool things these are
250:40 - extremely useful um the second I found
250:42 - out about them I using them all the time
250:44 - because a lot of the stuff that would
250:45 - usually take you a few for Loops or a
250:47 - few lines um you can do in one line or
250:49 - two lines with these uh new collection
250:51 - types so I just want to first off and
250:53 - start by saying that in Python it has
250:56 - something called containers um so
250:58 - containers are pretty much uh a data
251:00 - type or an object that's going to store
251:02 - multiple objects so it's like a
251:04 - container like a list is an example of a
251:06 - container uh a set is an example of a
251:08 - container a dictionary and a tuple as
251:10 - well um these are the four main ones
251:12 - with pyth
251:13 - and in the collections module they
251:15 - introduce five new ones um which are
251:17 - similar to these but they all have their
251:19 - own methods um and cool things you can
251:21 - do with them so the one I'm going to
251:22 - talk about today is counter uh but the
251:24 - other ones are listed here DQ named
251:26 - Tuple ordered dictionary and default
251:28 - dictionary you can kind of get an idea
251:30 - what some of them are by reading them um
251:32 - but let's get into the counter one for
251:34 - right now okay so first thing we need to
251:36 - do whenever we're using collections as
251:37 - we need to import it um so this first
251:39 - line up here is unnecessary but I just
251:41 - did that to show you and we're going to
251:43 - import import counter from collections
251:44 - so we can reference it directly without
251:46 - doing collections. counter okay so I'm
251:49 - just going to start by creating a new
251:50 - counter so I'm going to say C equals
251:52 - counter um now when you create a new
251:54 - counter what goes in here as the
251:56 - arguments um can just be any uh I want
251:59 - to say like collection data type or any
252:02 - uh container so for example you put a
252:03 - dictionary set um tle you can put a list
252:07 - uh and you can also do something which
252:08 - is weird with these keywords I'll show
252:10 - you that in a second so for example I
252:12 - could create a counter like this by just
252:15 - putting a string and it's going to count
252:16 - all the letters in the string and return
252:18 - them to me and I'll show you that in a
252:19 - second I could create another counter
252:21 - where in here I have a list so I can say
252:24 - like a a b c and we'll just do one more
252:31 - C like that and I could put a dictionary
252:34 - so I could do something like this I'll
252:36 - just make a small one so we don't take
252:38 - too
252:41 - long uh oops like that
252:44 - B2 and you can also put uh these
252:46 - keywords which is what I was talking
252:47 - about it's kind of cool because you
252:49 - don't have to type out or like use a for
252:51 - Loop to create a list like this um I
252:52 - could do something like oops cats equals
252:56 - 4 dogs equals seven like that and I can
253:00 - continue on with keywords um and I don't
253:02 - have to actually put the quotation marks
253:03 - around these I can just name them
253:04 - exactly what they are so let's just go
253:06 - ahead and start printing some of these
253:07 - to the screen to see what actually
253:09 - happens um when I create a new counter
253:12 - object and what does that look like in
253:13 - Python so we'll just print all these um
253:16 - just to give us an idea of what they
253:17 - really
253:18 - are okay so there we go so it says we
253:20 - have a counter object uh it is its own
253:22 - object it's not like a list or
253:24 - dictionary it's its own thing um it says
253:26 - a we have two uh I believe this is an L
253:29 - we have two G1 D1 um and then same thing
253:32 - here A B C dogs cats so you can see it
253:35 - looks like a dictionary in terms of it
253:37 - has a key value pair but it works a
253:39 - little bit differently so now if we want
253:42 - to reference um a specific item which is
253:44 - typically what we want to do from our
253:46 - counter we can just put the square
253:48 - brackets and put the name of that item
253:50 - or the key so in this case I'm going to
253:52 - put cats and you can see now we get four
253:55 - as that's the Direct Value related to
253:57 - cats um and something cool with this
254:00 - counter and a reason why I use it
254:02 - specifically is I can put an item in
254:04 - here um that doesn't exist in the
254:06 - counter it doesn't have a key set and
254:08 - that will actually not return an error
254:10 - like might happen with the dictionary so
254:12 - for example I put ay like I don't know
254:14 - let's see
254:16 - pet then it just gives me zero instead
254:18 - of returning an error so if I were to do
254:20 - this with a dictionary let say d equals
254:22 - like I don't know uh Cat 2 and then I
254:27 - Tred to do D pet like this and get the
254:30 - value uh we get an error uh because pet
254:34 - the key pet does not exist in our uh in
254:37 - our dictionary okay so let's move on to
254:39 - some more methods and why these are
254:41 - extremely useful um so we can see here
254:45 - um one of the methods that we can use is
254:47 - we can actually just list all of the
254:48 - elements out and this is useful if you
254:50 - want to like sum something um so let's
254:52 - just say list and then c. elements like
254:57 - that and what this is going to do if I
254:59 - print it to the screen is it's simply
255:01 - just going to print out all of the
255:02 - elements in our counter so we say cats
255:05 - cats cats cats dogs dogs dogs like that
255:09 - um and since here we said cats equals 4
255:12 - dogs equal 7 um then it prints it out
255:15 - like in a made list with that many uh
255:17 - indices which can sometimes be useful
255:19 - I'm just going to change this to be
255:20 - named D so that we can now print out the
255:22 - one like this with A1
255:24 - B2 and you can see we get a b b um like
255:28 - so I if I do the same thing I'll change
255:30 - this to e we print it again um then
255:33 - again we get another list that just has
255:35 - all of the elements in it so that's one
255:37 - useful method uh c. elements another
255:40 - useful element uh or method sorry is
255:43 - most common now this one by far is
255:45 - probably one of the most useful ones um
255:47 - and you can simply just type this so the
255:49 - name of your counter object and then
255:53 - most underscore common and then in the
255:54 - brackets here you're going to put how
255:55 - many elements you want so if you wanted
255:58 - to find the number one most common
255:59 - element you'd put one if you want to
256:01 - find two you put two so let's print this
256:03 - to the screen and see what we
256:05 - get
256:07 - so and you can see we get the most
256:09 - common elements are a and c and it
256:11 - actually also returns us a count of
256:14 - those elements as well so it says a
256:16 - which occurs two times and C which
256:18 - occurs two times and that's returned to
256:20 - us in a tupple or Tuple however you want
256:22 - to call it uh which is really useful
256:25 - okay so now another one we're going to
256:27 - use uh I'm just going to copy something
256:29 - I have open here just to save a spit of
256:30 - time in terms of creating counter
256:31 - objects so I'm going to delete all this
256:33 - and I'm going to make uh one counter
256:35 - which is equal to a uh or C and then I'm
256:38 - just making a list which is uh D and
256:40 - it's a b b c like this okay so you can
256:43 - do something um as well with these
256:44 - counter objects you can subtract Counts
256:47 - from them uh from using other idal
256:49 - objects or you can add uh like the count
256:51 - of objects to them so one method is
256:54 - called subtract oops like this and it
256:59 - does pretty much exactly what it uh it
257:00 - says so we're going to take this counter
257:02 - object this has to be called on a
257:04 - counter object by the way um it says
257:06 - with these counts and we're going to
257:07 - subtract whatever the counts are from D
257:10 - of similar items so we have 1 a two B's
257:13 - and a c so if I do this and I print just
257:17 - the screen we should let's do a quick
257:19 - calculation here get a is equal to Three
257:21 - B is equal to z c is z and d is still -2
257:25 - uh none oh it's CU I didn't convert this
257:27 - to a list sorry about
257:30 - that let's do this
257:33 - maybe non type object is not ital all
257:35 - right just give me a second guys there
257:37 - is a way that we can oh it's because
257:39 - we're doing this so C do subtract
257:42 - doesn't doesn't actually return anything
257:44 - we just have to print C after we call
257:46 - that method okay so there we go and we
257:48 - do get um what we had there okay so yeah
257:50 - C is Nea 1 because 0 - one gives us
257:52 - negative 1 um and there we are so it is
257:56 - working exactly like it should be okay
257:58 - the next one is update so I'll run this
258:02 - now c. update and this is the exact same
258:04 - thing as subtract except it's simply
258:07 - just going to add the counts of whatever
258:08 - iterable object you give it so in this
258:10 - case I'm going to put D and note here
258:12 - that I'm using a list but I could be
258:13 - using like a dictionary could be using
258:15 - another counter object um I could be
258:18 - using a set uh a tuple uh whatever you
258:21 - want to say there it's still going to uh
258:23 - like work for update so let's see here
258:25 - and oh I didn't print
258:28 - C let's do
258:30 - that and there we go so we went
258:32 - originally so we changed our counter by
258:35 - subtracting and then we just updated by
258:36 - adding so it should be the same as our
258:38 - original counter which it is okay so
258:40 - that's working well the next one that
258:42 - I'm going to talk about now is clear um
258:44 - this one does pretty much what it states
258:47 - uh so if you see here we do c do CLE and
258:51 - then I'll print C to the screen and all
258:53 - it's going to do is just remove all of
258:55 - the counts so we now have an empty
258:57 - counter object that we can use to count
258:59 - something else to add to to subtract so
259:01 - on okay so that's it for the methods
259:04 - pretty well there's one or two more but
259:06 - I don't find them very useful so I'm not
259:07 - going to show them right now um but
259:09 - there's something cool that you can do
259:11 - with these counters and there's a few
259:13 - operations that are applied to them so
259:15 - you can actually add counters using the
259:17 - plus sign you do like this C plus D um
259:19 - you can do c minus D you can subtract
259:22 - them you can add them and then the two
259:24 - operations which you wouldn't
259:25 - necessarily uh know intuitively is you
259:27 - can do something called intersection and
259:29 - Union of counters so let's just first
259:31 - show what happens when I add these two
259:33 - counters together so C plus d oops and
259:36 - this needs to be a cter
259:38 - now because this isn't going to work if
259:40 - it's a list there we go so make that
259:42 - account counter and I'll print C minus
259:46 - D and then we'll print another one after
259:48 - that so if I add them and subtract them
259:51 - um you can see that uh it works like
259:54 - this so when I add them we get the
259:56 - counts added up like this and when we
259:58 - subtract uh we get it subtracted as
260:02 - well now some of you might be uh
260:04 - wondering here why we don't have the
260:06 - elements B C or D shown in our counter
260:10 - uh and that is because if the ele count
260:13 - is less than Z or equal to Z it's not
260:16 - going to be shown in our counter when we
260:18 - do these operations by adding and
260:20 - subtracting so because of that um you
260:23 - can see like why that happened because B
260:25 - is two here and we have two BS so that
260:28 - created zero C is already zero and D was
260:30 - -2 so when we subtracted it's not going
260:33 - to bother showing those uh in our new
260:36 - counter now the next operations that we
260:38 - can do is something called Union and um
260:42 - inter intersection so the first one I
260:44 - guess I'm going to show is intersection
260:46 - and the way that you can think of
260:47 - intersection is like the minimum
260:49 - elements in each of the uh the list so
260:52 - we're going to have C intersecting with
260:55 - D um in this case we should get AAL 1
260:58 - Bal 2 and C 0 D -2 so let's just see if
261:02 - this works and there we go we get B is 2
261:05 - a is 1 and we're not showing the other
261:06 - ones again
261:07 - because they um like they're equal to
261:10 - zero or less than zero so they not being
261:12 - shown and this is the and sign is what
261:14 - I'm doing to do this intersection
261:16 - between the counters the next one that
261:19 - we can do is called Union and this one
261:21 - you can think of as the max Elements
261:22 - shown in each of our counters um so it's
261:25 - going to take a equal to 4 because
261:26 - that's our Max it's going to take b
261:28 - equal to two that's the max between here
261:30 - Cal 1 and then again it shouldn't be
261:33 - showing us D because that's -2 so there
261:36 - we go we get a is four B is 2 and C is 1
261:39 - so this is pretty much going through
261:40 - looking at the counters and just taking
261:42 - maximum element whereas before when we
261:44 - did our intersection it's taking the
261:47 - minimum shown of all those elements so
261:50 - that has pretty much been it for this
261:52 - video and counters uh from The
261:55 - Collection there's a few things that you
261:56 - can do with them as well a few other
261:58 - methods if you want to learn about those
262:00 - uh just go to just look up collections
262:02 - counter python uh you can read through
262:04 - the documentation and you can look at
262:06 - some more examples that I didn't show
262:07 - here specifically other than that I hope
262:09 - you guys enjoyed the video if you did
262:11 - play please make sure you leave a like
262:13 - And subscribe and I will see you again
262:14 - in the next
262:19 - one hey guys and welcome back to another
262:22 - video in today's video I am going to be
262:24 - continuing with my intermediate python
262:26 - uh tutorials and we're going to be
262:27 - moving on to something called named
262:30 - Tuple uh or tupple whichever one you
262:32 - prefer um which is a part of the
262:34 - collections data type or module class
262:38 - whatever you want to call it so in the
262:39 - previous video I introduced you kind of
262:41 - to the collection module in Python and I
262:44 - showed you counter which is really
262:45 - useful um today I'm going to be showing
262:47 - you named Tuple which is another data
262:49 - type or class whatever you want to call
262:51 - it within that module um and pretty much
262:54 - this is the description of it I'm just
262:55 - going to read it right off of the uh
262:57 - documentation here because it explains
262:58 - it better than I could come up with um
263:00 - so let's go ahead and do that named
263:02 - tupes assigned meaning to each position
263:04 - in a tuple and allow for more readable
263:05 - self-documenting code they can be used
263:08 - wherever regular tupes are used and they
263:09 - add the ability to access field by names
263:11 - instead of position index so you should
263:14 - understand a bit of that but if you
263:15 - don't obviously I'm going to go through
263:17 - exactly how this works and how we can
263:19 - use it so the main difference between a
263:20 - name Tuple and a regular tupal is you
263:23 - can access things by element and it's
263:24 - just a lot nicer to read in your program
263:27 - uh so they might come in handy if you're
263:28 - coding large things or if other people
263:30 - are going to be reading your code so
263:32 - let's go ahead and first off start by
263:33 - importing collections like this and then
263:36 - we're just going to from
263:38 - collections we are going to import named
263:41 - Tuple
263:44 - oops okay so now that we've done that
263:48 - what we're going to do down here is I'm
263:50 - just going to create something that I'm
263:51 - kind of going to go and show you what
263:53 - exactly it does so I'm just making new
263:55 - variable point I'm going to set it equal
263:57 - to a named Tuple with name
264:01 - point and then it's going to have Fields
264:04 - X Y and Z and I'm going to show how this
264:07 - works okay so what I've just done here
264:10 - is I've said point is going to be equal
264:12 - to a new object which is a named tupple
264:15 - or tubble um the name of the tub is
264:17 - point and it has Fields x y and z now
264:20 - this looks a little weird you might be
264:22 - confused what we're going to do whenever
264:24 - we want to create a new point that is in
264:26 - the form of this name tubal is we're
264:28 - going to treat this like a class and
264:30 - we're going to do something like this
264:31 - we're going to say new p is equal to
264:34 - point and then we need to give our uh
264:37 - parameters so in this or arguments so in
264:38 - this case in X Y and Z so I'm just going
264:40 - to say 3 four five like so
264:43 - now you might be looking at this be XYZ
264:45 - this is one string um this might be the
264:48 - name of one parameter the way that this
264:50 - works and it's actually really useful is
264:52 - that it's automatically going to break
264:54 - up this string XYZ into three different
264:57 - parameters so I'm just going to print
264:58 - this to the screen to kind of show um
265:01 - what I mean here so I'm just going to
265:02 - print new p and you can see that we have
265:04 - x = 3 y = 4 and Z equals 5 now what
265:08 - happened here is when we gave an
265:09 - iterable object as our different
265:11 - parameters
265:12 - you can see that we get uh it just
265:14 - breaks it up by space so I do something
265:17 - like gy and then I run this here you can
265:19 - see now g y is equal to 4 I can add
265:21 - another one um on the end like
265:24 - H uh oh and then we're just missing one
265:26 - argument so I'd have to add another
265:28 - number in here so that we get H is equal
265:30 - to 8 I can also do the same thing with
265:32 - the list per se so if I have a list and
265:33 - I want all of these to be the names of
265:35 - like so like X Y uh and let's just do
265:39 - like L and we run this takes four okay I
265:43 - keep forgetting to fix this anyways uh
265:46 - you can see we get x y l any iterable
265:49 - object will work I'm not exactly sure
265:51 - how a dictionary works but I'm pretty
265:52 - sure it takes the keys so let's just go
265:54 - ahead and have a look at this one we'll
265:56 - just say x um
266:00 - zero y z um Zed zero now this might
266:07 - crash but I just want to see if this
266:09 - actually works oh yeah it does work so
266:10 - it just takes the key names ignor the
266:12 - values we get X Y and Z and then I guess
266:16 - you can do the same thing with any other
266:17 - iterable object those are the only ones
266:18 - I can think of that are useful right now
266:21 - so anyways when we want to create a new
266:22 - tupple uh or a new name tupple what
266:24 - we're going to do is just say whatever
266:27 - the name of that's going to be is equal
266:29 - to point which we've set up here to be
266:31 - this type um with these like parameters
266:34 - attributes and then we just give it
266:36 - those parameters now there's a lot of
266:38 - really cool things and methods that go
266:40 - along with this named tle and that's
266:42 - that's why it's useful so first of all
266:43 - you can do something like this new p.x
266:47 - um new p.y and new p oops. z like so and
266:53 - now what this is going to do is it's
266:54 - going to allow us to access each element
266:57 - by its uh index so by its name which you
266:59 - can't do with a regular tle so you see
267:02 - we get three four five to the screen
267:04 - like that and we can use the same
267:06 - operations that we use on basic Tes so I
267:09 - can do something like new P0 like that
267:12 - um and oops my mod thing just popped up
267:14 - somewhere else and you can see we get
267:15 - three um because that's the first one
267:17 - that shows up we can also print this so
267:20 - it looks uh in the form of a dictionary
267:22 - so I'm just going to say underscore is
267:25 - dict like this I believe this is the
267:27 - method or not is as sorry and when we
267:30 - print this to the screen you'll see what
267:32 - shows
267:33 - up and it says an order dictionary and
267:35 - it gives us a list and then it gives us
267:37 - the all the Tes within so X3 y 4 Z 5 um
267:42 - kind of a different form if you want to
267:43 - play with that and use that we can also
267:45 - print out all the field names um which
267:47 - is useful say you forget the fields we
267:49 - can do new P do and then fields and it
267:52 - gives us a tle with those fields in it
267:55 - the next method that we can use is the
267:57 - replace method um this one's pretty
267:59 - straightforward but all you have to do
268:00 - simply is type I don't know let's see
268:02 - here new P doore replace and just make
268:07 - sure you guys remember to put these
268:08 - underscore here all the methods pretty
268:10 - well for this uh required underscore
268:12 - don't ask me why but that's the way
268:14 - they're written they need underscore and
268:15 - then you're going to put a key name so
268:17 - say I wanted to replace Y and I can say
268:19 - equals to 6 uh so we'll run that and
268:22 - then if I just go here and just to show
268:24 - you that we did change that let's print
268:27 - new P like that and you can see oh why
268:30 - did not change to uh to six that's weird
268:33 - let's let me just see if I print this to
268:34 - the screen if this is going to
268:38 - change it should have worked
268:42 - new P like so let's check and Y is not
268:45 - changing to four um that's very
268:48 - interesting why that is not working okay
268:52 - so I just had a quick look at the
268:53 - documentation and the reason why I can't
268:55 - do what I'm trying to do here with this
268:57 - replace uh is because this replace
269:00 - doesn't actually change the Tuple object
269:04 - it it's not capable of doing that so
269:06 - what we have to do is we have to assign
269:09 - a new variable or new object to that so
269:12 - pretty much what this does is it returns
269:13 - a new named tupal uh which we then can
269:16 - set to in this case the same name it
269:19 - it's going to do the same thing that we
269:20 - tried to do except we just need this new
269:22 - P equals to hope that makes sense so now
269:24 - if I run the program we can see that
269:27 - finally this is working we are changing
269:29 - X or I was trying to change y before but
269:31 - I switched it to X to see if there was
269:33 - an issue there uh you could see that
269:34 - that is working like that so anyways um
269:37 - that is pretty much it I'll show one
269:40 - last method here if you guys are still
269:42 - watching so pretty much we can do
269:43 - something like a new a new point so say
269:45 - P2 is equal to point doore
269:49 - make and then I'm going to put a little
269:52 - list in here I'll just say like a b c
269:56 - now what this is going to do is same
269:58 - similar thing to up here is it's just
270:00 - going to automatically grab all of these
270:02 - elements in our list and assign them to
270:05 - XYZ accordingly in our named tle so you
270:08 - can see if I print P the screen now
270:12 - and we give it a run no errors
270:14 - everything's working fine xal a yal b
270:17 - zal
270:22 - c hey guys and welcome back to the eth
270:24 - video in my intermediate python
270:26 - tutorials in today's video I'm going to
270:28 - be continuing with the collections
270:30 - module and we're going to be talking
270:31 - about a data type known as the deck so
270:35 - yes this says DQ right here and the
270:37 - title of the thing is spelled DQ um but
270:39 - the way that you pronounce it is deck uh
270:42 - and I just found that from reading the
270:44 - documentation otherwise I was going to
270:45 - go through this whole video saying DQ
270:47 - anyways uh deck is the proper way to say
270:50 - this word so if I do end up saying DQ
270:53 - throughout the video please don't leave
270:54 - an angry comment about it uh I don't
270:56 - know why I just keep saying it but
270:58 - anyways deck is the proper way so why
271:00 - would we want to use a deck over uh a
271:02 - typical list so pretty much it kind of
271:03 - looks the same as a list and I'll show
271:05 - you in just a second but the reason why
271:06 - we' use a deck is because it's faster in
271:08 - terms of adding elements to the end and
271:11 - the beginning of a list so rather than
271:14 - using a list you want to use a deck
271:15 - because it's going to be faster whereas
271:17 - if you're trying to randomly access
271:18 - elements within uh a container so a list
271:21 - then you're going to want to use a list
271:23 - over a deck and if that's confusing
271:25 - don't worry I'll kind of show you how we
271:27 - uh as we go through so let's start by
271:28 - creating a deck and see how that works
271:30 - so I'm just going to say d and that's
271:32 - going to be stand for a deck is going to
271:33 - be equal to a deck and then this just
271:36 - takes an iterable argument so in this
271:38 - case I'm going to take type in hello but
271:40 - I could give it something like a list a
271:41 - DI iary uh so on so anyways D equals uh
271:46 - deck hello now if I run the program
271:49 - press F5 and I simply print D to the
271:52 - screen here you can see that we get deck
271:54 - and then h e l l o i just split that up
271:58 - into what looks like a list but it's
271:59 - actually a deck okay so now let's go
272:02 - through uh a few methods that we can use
272:05 - on this so obviously we can use
272:06 - something like
272:07 - append so we can append an element to
272:09 - the end so I can append something like
272:11 - four
272:12 - uh I can pend another element do
272:14 - something like five and if we run this
272:16 - and then print it
272:18 - again you can oops didn't mean to do
272:22 - that then you can see we get hello and
272:25 - then four five so on so you can append
272:28 - uh a nice thing is you can actually
272:29 - append to the beginning of the list as
272:30 - well so I can say append left instead of
272:34 - just regular append and now you can see
272:36 - when we run the program and we print D I
272:40 - don't know why that didn't work let's
272:41 - see here we get five and then hello four
272:44 - so that's a nice method as well we can
272:46 - do the same thing with popping which is
272:48 - removing elements from the deck uh so I
272:51 - can do pop in this case and I'm not
272:53 - going to do four in here so I do d. pop
272:56 - and then I can also do d. poop left and
272:58 - what pop left is going to do is it's
273:00 - simply going to remove the first element
273:02 - in Our Deck rather than the last so pop
273:05 - uh this works on lists as well and
273:07 - dictionaries and stuff you can remove
273:09 - the last element or whatever index you
273:11 - type in here like five two whatever
273:13 - that's the one it's going to remove pop
273:15 - left simply removes the first one so
273:17 - I'll do this and
273:19 - then print D and you can see that we are
273:21 - left with eell because we removed o and
273:24 - we removed the H okay another method
273:27 - that we can use is clear uh this one is
273:29 - simply going to remove everything from
273:31 - the deck so that's pretty standard if I
273:35 - print D
273:37 - again then you can see that we have an
273:39 - empty deck now okay the next few that
273:41 - I'm going to talk about here I believe
273:43 - you can use on some other containers in
273:45 - Python but they do work on this deck as
273:47 - well so let's go through that so now
273:48 - that we already cleared Our Deck let's
273:49 - just go ahead and add some more things
273:51 - to it so what we can do is we can do
273:53 - something called extend and what extend
273:56 - is going to do is it takes an iterable
273:57 - argument which means anything that's a
273:59 - container so like a list a string uh
274:01 - something like that and it's going to
274:03 - put it at the end of our list so if I
274:06 - have something like
274:08 - 456 and I run the program
274:12 - and I print D you can see we get four
274:14 - five6 at the end of our list now to show
274:16 - you what happens if you already have
274:17 - something in I called it a list but our
274:19 - deck is if I extend again I'll extend
274:22 - something like so we can see it better
274:25 - hello then what we get
274:27 - is print D we get 456 and then hello so
274:32 - this is a way that to add multiple
274:34 - things into your deck so again if I make
274:37 - like a list and I go like 1 2 3 this is
274:39 - going to work as well so we should get
274:41 - four five 1 2 3 and print D and there we
274:46 - go we get that as well so if you ever
274:47 - don't want to run through like a for
274:49 - Loop to add an entire list into a deck
274:52 - then you can simply use extend extend
274:54 - also works really nicely um with extend
274:58 - left which is going to add to the
274:59 - beginning of our list so now we have a
275:01 - list of 4 5 6 1 2 3 let's see what
275:04 - happens if we extend the word hey um to
275:06 - the left side of the list so I'm going
275:10 - to print that and you can see we get y
275:13 - 45 61 2 3 you might say well why didn't
275:16 - we just get H well it's because we're
275:18 - actually extending to the left so we're
275:20 - going to add this in the reverse order
275:23 - and that should make sense because if
275:25 - you're extending this first and then you
275:26 - extend this and then you extend this y
275:28 - should be the first element on the left
275:30 - side of Our Deck like that okay so now
275:34 - we're going to use um a few other
275:36 - methods so this one is probably the most
275:38 - useful one that the deck has and the
275:40 - reason why you would use it if
275:42 - especially if you're going to be dealing
275:43 - with things at the beginning and the end
275:45 - specifically and it is known as
275:47 - rotate so what this does is it takes a
275:51 - integer in here either positive or
275:53 - negative if you put a positive in
275:55 - integer in here it's going to rotate all
275:57 - of the elements by that amount to the
275:59 - right otherwise it's going to if you put
276:02 - a negative element in there rotate
276:03 - everything to the left so just see what
276:05 - happens if I put negative 1 in here to
276:07 - rotate to the left and then we'll print
276:09 - down here sorry it's at the bottom of
276:10 - the screen right now and you can see
276:12 - that we went from this one which was the
276:15 - last uh D or whatever when I printed it
276:17 - and now we've rotated everything over so
276:19 - three's moved over to the position of
276:21 - Two And when we get all the way over to
276:23 - here we've switched e and Y so E's moved
276:25 - over here and Y has been rotated back to
276:28 - the end of the list now you can actually
276:30 - rotate with other uh numbers as well so
276:32 - rotate by two and then you can see if I
276:36 - print D down
276:37 - here that we get a rotated two elements
276:40 - over now and this is is really useful
276:42 - when you're trying to solve certain
276:43 - problems uh to be able to use this
276:45 - rotate again you can do the same thing
276:46 - with positive so if I just rotate it by
276:48 - one now and I
276:51 - simply print D you can see that now
276:53 - we've rotated to the right side so three
276:55 - which was originally here has now been
276:57 - moved up to the beginning of the list
277:00 - okay so now that we've talked about that
277:01 - there's one last really useful thing um
277:04 - that I left out on purpose because I
277:05 - wanted to show now that we can do with
277:08 - these decks so when we initi iate Our
277:12 - Deck here we give it an iterable object
277:13 - we don't have to give it anything it'll
277:15 - just create a blank one if we do that
277:17 - but there's something that it has called
277:19 - Max Len now if I do something like Max
277:22 - Len 5 and I'm just going to remove all
277:24 - this and I'll show you how this works so
277:27 - I have a max line of five and I have a
277:29 - string that has five characters in it if
277:32 - I try to add something to my deck here
277:35 - so I'll just do I'll just simply I'm
277:36 - going to print it here just so it saves
277:37 - us some time going to print D and then
277:40 - I'm going to go d. and let's do one and
277:43 - then print D again let's just Watch What
277:46 - Happens so you can see we get we have a
277:49 - max line of five we start with hello and
277:51 - then when we add one H is actually
277:54 - removed from our deck now the reason
277:56 - that happens is because when we set this
277:58 - max length when we start adding things
278:00 - into the list it needs to remove
278:02 - something to maintain that um attribute
278:04 - of a maximum length of five so it
278:06 - removes the first element from our deck
278:10 - uh and that's really useful as well if
278:11 - you're solving problems because then you
278:13 - don't have to deal with removing things
278:14 - every time you add something to the end
278:15 - or removing like a slice of for example
278:18 - list if you're going to be adding more
278:20 - than one thing so if I
278:22 - extend like something like let's see
278:24 - here one two 3 now we should see that h
278:28 - e and l should all be removed and we
278:30 - should have L1 23 so let's try it and
278:32 - there we go we get hello and we get
278:35 - l123 and we didn't have to deal with
278:37 - figuring out how many elements we need
278:38 - to take from the left side from the
278:40 - right side because of this Max Len now
278:43 - just to note you can't change this Max
278:45 - len by doing something like d. Max Len
278:48 - equals five it's uh or I guess we'll do
278:51 - like six because it's already five you
278:53 - can only access what the max Len is by
278:56 - just doing is simply this
279:01 - print ma d. Max L and this should just
279:03 - give us five uh and it does but if I try
279:06 - to do what I was showing you there so d.
279:08 - Max Len equals 5 you'll see the error
279:11 - that comes up and it says this attribute
279:13 - of Max Len is not writable so we can't
279:15 - actually change it after we've initiated
279:17 - that value so anyways that's pretty much
279:20 - been it for deck within collections this
279:23 - is really useful and you might not see a
279:24 - use for it now but if you start solving
279:26 - some more advanced problems using this
279:28 - deck will make your life a lot easier
279:29 - with those methods that I went through
279:30 - and I'm going to copy all of them down
279:32 - uh into like a little paste bin thing so
279:34 - you can click the link in the
279:35 - description there if you want to see all
279:36 - of them in a list um so you don't have
279:38 - to specifically memorize that other than
279:40 - that you can always just go to the
279:42 - documentation and have a look if you
279:43 - just search up like DQ collections
279:45 - python it goes through what all of these
279:47 - do again I forgot to talk about reverse
279:50 - but it's pretty straightforward you can
279:51 - use reverse and if you're followed up to
279:53 - here you probably probably already know
279:55 - that one so anyways that's been it for
279:57 - this video um if you guys enjoyed the
279:59 - video please make sure you leave a like
280:01 - And subscribe and I will see you again
280:03 - in the next one
280:16 - hello everyone and welcome to the first
280:18 - video in our python expert level
280:20 - tutorial series now what I'm going to be
280:22 - doing in this series is teaching you
280:24 - about some expert level features in
280:25 - Python how they work how to implement
280:28 - them and then getting into how you can
280:29 - actually use them and why you would use
280:31 - them in your python code now it's worth
280:33 - noting that a lot of the features I'm
280:34 - about to show you as much as they're
280:36 - very useful and complicated and you know
280:38 - Advanced and expert level you don't
280:39 - necessarily need to use them there's a
280:41 - time and a place and as you guys learn
280:43 - this you should refrain from using these
280:45 - features just to almost show off and
280:47 - actually make sure that you understand
280:49 - the purpose of using them and use them
280:50 - in the correct context that's what a lot
280:53 - of the focus of this series is going to
280:54 - be is giving some meaningful examples
280:56 - that try to tell you when you would
280:58 - actually use this feature or at least
280:59 - help you understand really why it works
281:02 - so that you could think about a
281:03 - situation when it might want to be
281:04 - implemented now quick disclaimer here if
281:06 - you guys are not python you know
281:08 - intermediates already or you're not
281:10 - familiar or fluent in python this is
281:12 - going to be a difficult tutorial series
281:13 - for you to follow along with you know
281:14 - you're welcome to as always but just
281:16 - keep that in mind I do have a lot of
281:17 - python tutorials on my channel that a
281:19 - more beginner level if you want to
281:20 - follow along with those before maybe
281:22 - jumping into something like this now in
281:24 - this video what I'm going to be doing
281:25 - specifically is talking about some very
281:27 - interesting and cool features in Python
281:30 - these are not anything specific they're
281:31 - nothing you may not have seen before but
281:34 - it's something that you need to kind of
281:36 - understand before we can move into the
281:37 - more advanced things so we're just going
281:39 - to be talking about how python code
281:41 - actually runs and why we can type out
281:43 - some weird lines like I'm going to show
281:45 - you um in the next few minutes anyways
281:48 - what I'm going to do now is briefly
281:49 - discuss how python code is actually ran
281:52 - and executed now I will say right now
281:54 - I'm not going to go into extreme detail
281:55 - I'm hopefully going to give you enough
281:57 - information so that you understand on
281:59 - kind of a surface level but if you do
282:01 - want to read into this I would recommend
282:02 - it because understanding how your
282:04 - program is actually compiled interpreted
282:06 - and eventually ran on your machine is
282:08 - very important and it definitely helps
282:09 - you understand why a lot of the things
282:11 - in the language work the way they do so
282:14 - most of you would have probably heard
282:16 - that python is an interpreted
282:17 - programming language but what does that
282:19 - really mean well to understand that we
282:21 - need to define the difference between a
282:22 - compiler and an interpreter and talk
282:24 - about how they work together because
282:26 - although python is interpreted it is
282:28 - actually compiled as well into bite code
282:30 - before it is actually interpreted so the
282:32 - way that python works and actually we'll
282:34 - go back to the definitions first so a
282:36 - compiler what does a compiler do well a
282:38 - compiler takes some highlevel code typ
282:41 - Ally high level code and translat
282:43 - translates it into a lower level so for
282:46 - example the python compiler that we use
282:48 - is going to take our python code which
282:50 - would be considered highlevel code
282:51 - that's furthest away from the hardware
282:53 - right and translates that into something
282:55 - called bik code which is a little bit
282:57 - harder for us to understand and closer
282:59 - to the computer's level so that it can
283:01 - actually be used and ran on our machine
283:03 - so what does an interpreter do well an
283:05 - interpreter takes some kind of code
283:08 - typically B code and interprets and runs
283:11 - that that code so it will read that
283:12 - codee and translate it on the fly into
283:15 - machine code that can be executed by our
283:17 - computer rather than doing this
283:19 - translation beforehand when you use
283:21 - something like C what you typically do
283:24 - and depending on the compiler that
283:25 - you're going to use there's tons of
283:26 - different versions and methods of doing
283:27 - this you will compile your code directly
283:30 - into machine code which means that it
283:31 - can be ran directly on the operating
283:33 - system that you're using and you don't
283:35 - actually need an interpreter to
283:37 - interpret your code and run it now I
283:39 - know this seems like a lot but this is
283:40 - something that we kind of need to
283:42 - understand so now I'm going to go into
283:43 - the way that Python's kind of execution
283:45 - chain is when you actually you know
283:46 - press that F5 button or do whatever it
283:48 - is you're going to do but essentially
283:50 - what happens in Python is you write your
283:52 - highlevel code which is going to be on
283:54 - your desktop you know in your text
283:55 - editor your python code and then when
283:58 - you press that run button or you go to
284:00 - execute that code what happens is it's
284:02 - translated into something called bite
284:04 - code now this translation is simply just
284:07 - a tool that checks all of the Syntax for
284:09 - your python code and then converts it
284:11 - into some equivalent code that can be
284:13 - read by The Interpreter that we're going
284:15 - to use so what happens is if you have
284:17 - invalid syntax like say I just type CL
284:20 - or something and that's not defined or I
284:21 - mess up and I don't have a colon or
284:23 - something like that then we get an error
284:25 - because the translation can't happen
284:27 - because the format of our code is
284:28 - incorrect and hence you know invalid
284:31 - syntax that's the error that you would
284:32 - get now assuming that your syntax is
284:34 - correct then what happens is you'll move
284:36 - on to the next stage where everything
284:38 - will be translated into bite code and
284:39 - then that bite code will run through the
284:41 - compiler and the compiler will translate
284:43 - that bite code in like a live time into
284:46 - machine code that runs and executes on
284:48 - your machine so this is why there's a
284:50 - lot of issues with python running on say
284:52 - mobile devices or on other devices that
284:54 - don't have a python interpreter because
284:56 - this bik code cannot be directly
284:58 - understood by the CPU you need some kind
285:00 - of interpreter to run it so hopefully
285:02 - that clears it up a little bit on how
285:04 - that works the basic summary is you know
285:06 - you write your high level code
285:07 - translated into bite code that bite code
285:10 - is then translated through an
285:11 - interpreter in live time as it's reading
285:14 - line by line so one at a time not all at
285:16 - the same time into machine code where it
285:19 - is executed and that's how your program
285:21 - runs this is different than a lot of
285:23 - other languages and each language has a
285:24 - very kind of complicated process of
285:27 - compiling and interpreting and running
285:29 - code so anyways I hope that kind of
285:31 - cleared it up a little bit but this
285:33 - feature of being interpreted and having
285:35 - a lot of things happening live is what
285:37 - we're really going to dig into here so
285:39 - the first thing that I want to show
285:41 - is something that's unique in Python
285:43 - that's not unique in a compiled language
285:45 - and that is the fact that a lot of
285:46 - checks and a lot of things that you
285:48 - typically can't even write with you
285:50 - could not compile code that exists these
285:52 - types of things in other languages you
285:54 - can do in Python so let me just show you
285:56 - what I mean all I'm going to do is
285:58 - create a class dog and inside the anip
286:01 - method um I'm simply going to call a
286:04 - method that does not exist called bark
286:06 - so this is my file um intro. piy we have
286:09 - a class dog a nit and a method self.
286:11 - bark that's being called but that method
286:13 - does not exist in the class body now for
286:15 - any of you that program in other
286:16 - languages you'd say okay well this is
286:18 - not going to work right if we don't have
286:21 - this method the compiler is going to
286:22 - pick that up it's going to say okay we
286:24 - cannot compile this code you need to
286:25 - Define that method or you need to remove
286:27 - the statement whereas in Python we do uh
286:31 - what was this python intro. py no issues
286:35 - we're totally fine we're good to go this
286:38 - is something that's unique about python
286:40 - is that a lot of the code is actually
286:41 - executed at runtime not at compile time
286:45 - all that the compiler really does for us
286:47 - in Python is just translate this code
286:49 - into B code it doesn't necessarily check
286:51 - that all this code is a valid now this a
286:53 - good thing and this is a bad thing we'll
286:55 - talk about why later on but that's
286:58 - something to understand that you can
286:59 - make errors like this in your python
287:01 - code and they will not be caught until
287:03 - runtime which can actually be a huge
287:05 - problem when you know you can't test
287:07 - every single aspect of your application
287:09 - your app gets through goes into a
287:11 - production environment something happens
287:12 - in runtime you didn't check it cuz the
287:14 - compiler didn't pick it up and now all
287:16 - of a sudden your code has crashed right
287:18 - so that's something to consider Okay so
287:20 - we've done that um that's fine that's
287:22 - just something I wanted to discuss and
287:23 - show you and that's kind of the way that
287:25 - python Works everything is actually
287:26 - happening kind of live it translates but
287:29 - then the runtime environment is what
287:31 - picks up on a lot of these errors okay
287:34 - so now let's get into some cooler things
287:35 - and talk about some strange things that
287:37 - we can do in Python that we can't really
287:38 - do in other languages so I'm going to
287:40 - Define a function and I'm actually going
287:42 - to make this function called make class
287:45 - so Define make class now what I'm going
287:47 - to do in here is get a parameter called
287:49 - X and I'm actually going to define a
287:51 - class inside of this function called dog
287:54 - just like we did before so I'm going to
287:56 - say class dog let say Define uncore
287:58 - uncore netore uncore we'll take a self
288:01 - value we'll take a name and then we'll
288:04 - just say self. name equals name okay now
288:08 - what I'm actually going to do is say
288:09 - Define print underscore value what I'm
288:12 - going to get this to do is simply print
288:14 - the value of x so we'll say print X like
288:18 - that and then I'm going to go down here
288:20 - and I'm going to actually
288:22 - return uh the dog like this now notice
288:26 - that I didn't return an instance of the
288:28 - dog by putting the brackets I simply
288:30 - returned dog itself which is actually a
288:33 - reference to the class not actually the
288:36 - uh the object so what I'm going to do
288:38 - down here now is I'm going to say CLS
288:40 - equals make uncore class and I'm just
288:43 - going to print out CLS and show you what
288:45 - this is so let's say CLS let's give the
288:47 - value 10 in here let's go and let's see
288:50 - first of all is this going to work does
288:52 - this not work why does this work what is
288:54 - this even doing well we'll talk about it
288:57 - okay so this actually worked so see what
288:59 - happened here we had this function
289:01 - called make class took an argument X and
289:03 - then we had a class dog that we defined
289:06 - inside of this function now first of all
289:08 - this should look strange to you but but
289:10 - the reason we can do this is because
289:12 - again the python compiler does not check
289:15 - if this is valid or not it doesn't
289:17 - really care so long as you have valid
289:20 - syntax so long as the format is correct
289:22 - your python code can run and it can
289:23 - execute and that's fine and that's
289:26 - exactly what's Happening Here we can
289:28 - define a class inside of a function
289:30 - because that's just the way python works
289:32 - we read from the top to the bottom left
289:34 - to write and that's totally fine that's
289:36 - totally valid now what have I actually
289:39 - done inside this function though well
289:40 - I've created a class that uses a value
289:43 - from the actual function argument here
289:46 - and then we actually return the class
289:47 - itself not an instance of that class now
289:50 - notice that's something that we can do
289:52 - in python as well since python code is
289:54 - running live it's kind of executing on
289:57 - the fly all of these things that we've
289:59 - defined here are actually being stored
290:00 - in memory so this um dog class here
290:03 - actually has a memory location for it
290:06 - that's why we can actually see this same
290:08 - thing with this function same thing with
290:10 - our VAR variable um and same thing with
290:12 - anything else that we Define that's
290:13 - something that's true about python is
290:15 - that all these things are actually
290:16 - defined and stored in memory which means
290:18 - we can interact with them live which is
290:20 - what we're doing right now so when I
290:23 - printed CLS we can see that I got
290:25 - main.m class. local.dog now let's just
290:28 - translate this a little bit although I'm
290:29 - sure most of you understand this main
290:31 - simply means this came from our main
290:33 - module which is a module we ran make
290:35 - class is the name of the uh I guess what
290:38 - is it function that we defined here
290:39 - locals Define what's inside of this
290:42 - function and then dog tells us the
290:44 - actual name of the class so that's what
290:45 - we printed out here but now let's see
290:47 - how we can actually use this so what I'm
290:49 - going to do is actually make an instance
290:50 - of this now I'm going to say d equals
290:53 - CLS name Tim and I'm actually going to
290:55 - say d. printor value like that and let's
291:00 - run this now so now we actually get the
291:02 - value 10 so what I've done is I've said
291:05 - okay well this CLS variable is actually
291:07 - a class since it's a class what I can do
291:10 - is use the way that I would typically
291:11 - use a class it's literally just another
291:13 - name for dog so we'll put our brackets
291:15 - we'll create an instance of it which
291:17 - makes self. name um you know equal name
291:20 - I can show you that as well by just
291:21 - printing d.name and then what we'll do
291:24 - is call the method on our object now the
291:26 - prints the value that we gave when we
291:28 - actually created this class so you can
291:30 - almost think of this um function that
291:32 - we've defined here as a I guess class
291:35 - Constructor where it's creating the
291:37 - class for us then we can use the class
291:40 - so I think that's pretty interesting
291:41 - that's something that's cool and again
291:43 - if we wanted to I could Define another
291:45 - function inside of here we can do
291:47 - another class inside of this class I can
291:49 - make seven classes inside of this
291:51 - function there is no limit to what you
291:53 - can do so long as you're using the
291:55 - correct syntax and you know it's not
291:57 - going to crash at run time right so
291:59 - that's something to consider now let's
292:00 - show some other weird cool things that
292:02 - we can do in Python um that's actually
292:04 - using some other kind of syntax so what
292:06 - I'm going to do now is I'm actually just
292:07 - going to make a for Loop and you might
292:09 - kind of be thinking about what I'm I'm
292:10 - going to do here so I'll say 4 I in
292:12 - range 10 what I'm going to do is Define
292:14 - a function I'm going to call this
292:16 - function just uh I don't know let's do
292:18 - show and all this is going to do is
292:20 - simply print the value I and let's just
292:23 - do I * 2 why not make it a little bit
292:25 - cooler now I'll call the function show
292:27 - here and let's run the code and no
292:30 - surprise to any of you when I run this
292:32 - that this should work fine and we get
292:34 - all of our values printing out so we can
292:36 - obviously do things like this I can
292:38 - define a function inside of a for Loop
292:40 - what I've done here is well only one
292:41 - show will actually ever exist at the end
292:44 - of this kind of runtime but I've defined
292:46 - 10 different shows that do 10 different
292:48 - things and I've called them directly
292:50 - after and then they get overridden and I
292:52 - do them again so that's something that's
292:54 - cool and again another feature of python
292:55 - that you can't really do in some other
292:57 - languages now what happens if I take
292:59 - this show and I put it outside of the
293:01 - for Loop so it's not running at the same
293:02 - time as this function is defined at well
293:04 - let's run this we see we just get 18 the
293:07 - last show that was defined is the one
293:09 - that exists and the one that's created
293:11 - now why would you ever do something like
293:12 - this I don't really know maybe if you
293:14 - had a lot of content inside of this for
293:15 - Loop and you had a function you were
293:17 - going to use it multiple times but only
293:18 - locally you could Define it up here
293:21 - again doesn't make that much sense to me
293:22 - to do that but just showing you some of
293:23 - the features of the language okay so now
293:26 - let's show some other things that we can
293:28 - do um I'm trying to think of something
293:30 - that would be cool okay so let's do
293:32 - another one here let's say Define Funk
293:35 - what I'm actually going to do here is
293:36 - take some value let's just say x and I'm
293:38 - going to return a function from this
293:41 - function if the value of x is a certain
293:43 - value so I'm going to say if x equals
293:46 - equals let's just say one then what
293:48 - we're actually going to do is make a new
293:50 - function we'll say Define uh I'll just
293:52 - say like RV which will just be return
293:55 - value and then inside here we don't need
293:57 - any parameters all we'll do is say
293:59 - print X is equal to 1 okay otherwise
294:06 - we'll do is say Define RV and then we'll
294:10 - say
294:12 - print X is not one okay now we'll return
294:16 - this function RV and if you guys
294:18 - remember from what we've done before
294:19 - what I can do is say Okay newor Funk
294:23 - equals Funk of let's just do value one
294:26 - and then I can actually call my new
294:27 - function like that because notice if I
294:30 - don't do this right then let's have a
294:32 - look at this here nothing gets printed
294:34 - out to the screen but if I call my new
294:36 - function by putting my two braces
294:38 - outside of it here then what we get is X
294:41 - is is equal to one and we could change
294:43 - this obviously and then we would get a
294:45 - different value where we get X is not
294:48 - one so we can do interesting cool kind
294:50 - of like paradigms like this again I
294:52 - don't know why you would use this
294:53 - there's easier ways to accomplish this
294:55 - but it's something to consider is that
294:57 - this can actually happen and any
294:59 - arguments that we use here obviously we
295:00 - can use inside of these functions as
295:03 - well and we can get into some pretty
295:04 - complicated things when we start
295:05 - defining functions inside of functions
295:07 - inside of functions Okay so last thing
295:10 - that I want to show you is just a cool
295:11 - thing that we can do to actually look at
295:13 - some of the details of our objects
295:15 - because remember that I said everything
295:17 - in Python pretty much Happens Live this
295:20 - function is an object um this function
295:22 - is an object our Val variables are an
295:24 - object any classes are an object which
295:26 - allows us to do what I'm doing where
295:27 - we're passing them through and around
295:29 - the program they'll have their unique
295:31 - memory address and so long as we can
295:32 - reference that we can use it so let's
295:35 - actually see how we can inspect and look
295:37 - at some of our functions so first of all
295:39 - I'm just going to show you you know you
295:40 - probably seen this before we can look at
295:41 - the ID of our function if we'd like to
295:44 - just by doing this um now if I print
295:46 - this out this should give us the memory
295:48 - address location of our function which
295:49 - we can get right here um and there's a
295:52 - lot of other things that we can do as
295:54 - well and one thing that I want to show
295:55 - you is actually by importing the inspect
295:58 - module so the inspect module can show us
296:01 - some pretty cool things because of the
296:03 - fact that all of our python objects
296:05 - classes all of that are actually live we
296:07 - can interact with them we can inspect
296:10 - them we can ask questions about them um
296:12 - and get that value back from The
296:13 - Interpreter so what I can actually do in
296:15 - here is say print inspect dot uh what is
296:19 - this we can do I'll do get members for
296:21 - now just to show you so get members I
296:24 - won't really discuss exactly what this
296:25 - does but it's just going to show you
296:27 - some details about the function so let's
296:29 - look at this here we can see we get all
296:31 - of this little information and we can
296:32 - obviously use this if we wanted to let's
296:34 - see if we can pick anything out in
296:36 - particular um that stands out nothing
296:40 - okay so here we go function. Funk locals
296:42 - RV at this memory address location so it
296:45 - just gives us all this details that's
296:47 - called new funk is down here the name of
296:49 - it so we can get some stuff like that um
296:51 - not extremely useful we can't use that
296:53 - at other times another really cool thing
296:55 - is we can actually get the source which
296:57 - is the source code of a specific
296:59 - function method class whatever you want
297:01 - so here when I do this it actually tells
297:03 - us the source code of the specific
297:05 - python function now why would this be
297:08 - useful well if we wanted to see exactly
297:10 - what was happening in some kind of thing
297:12 - that we were using that was maybe
297:13 - Library code we couldn't access that
297:15 - actual code we could have a look at the
297:17 - source code like this so now I want to
297:20 - show you another useful thing of this
297:21 - inspect module if I were to import some
297:24 - module and this is kind of a good use
297:26 - case of it say like Q right which is a
297:28 - python
297:29 - built-in um what is it from from Q in
297:32 - for Q This is a built-in data structure
297:34 - from Python and I wanted to look at the
297:35 - code of it obviously there's other ways
297:37 - to do this but if you wanted to just
297:39 - quickly do it in your terminal
297:41 - then what you could do is do something
297:42 - like that and now we can actually see
297:44 - all of the code that's been used by
297:46 - python itself to create this object or
297:48 - create this class so I think I'm going
297:50 - to wrap it up here it's been about 15
297:51 - minutes I hope that this gives you guys
297:53 - a good understanding of python a little
297:55 - bit more how we can pass objects around
297:57 - how we can look at their values we can
297:59 - inspect things we can look at the source
298:01 - code and just remember that everything
298:02 - in Python is pretty well happening live
298:04 - all these objects are defined in memory
298:07 - and well since they're defined in memory
298:08 - we can do a lot of cool things with them
298:10 - like pass them around the program and
298:12 - since the python is an interpreted
298:13 - language we can do all these crazy
298:15 - things where we Define classes inside of
298:17 - functions functions inside of classes
298:19 - inside of functions that we can go crazy
298:21 - and we'll continue to do that as we get
298:23 - further into this tutorial Series so if
298:25 - you guys enjoyed make sure you leave a
298:26 - like subscribe and I will see you guys
298:27 - in another expert Python
298:33 - tutorial hello everybody and welcome to
298:36 - video 2 in the python expert tutorial
298:38 - Series in this video we're going to be
298:40 - doing is talking about Dunder slashmagic
298:42 - methods and the python data model now
298:44 - this is very important this is something
298:46 - that I guarantee you've seen before but
298:48 - you probably just haven't understood
298:49 - what it actually was or why it was
298:51 - working the way that it did and this is
298:53 - actually going to give you a great
298:54 - insight into the way that a lot of
298:55 - things in Python actually operate
298:57 - because until you see this you kind of
298:59 - just take them for granted so what I
299:01 - want to do is give you a very basic
299:02 - example of two objects in Python um just
299:05 - kind of being used and interacting
299:06 - together I'm going to show you how we
299:08 - can create the same thing with our own
299:10 - python objects and even modify existing
299:13 - python objects to implement uh
299:15 - implementations or operations that we
299:16 - want so what I'm going to do to start is
299:19 - I'm going to just make two uh variables
299:20 - here I'm just going to make a list I'm
299:21 - say 1 2 3 and I'll make another list
299:24 - that just says you know four five like
299:26 - that now we know that with lists we can
299:28 - add them together by using the plus sign
299:31 - right we know that that's fine that
299:33 - we're allowed to do that so let's
299:34 - actually have a look at how that looks
299:35 - we get that list and it adds them
299:37 - together now why does that work we don't
299:39 - really no we kind of just assume that
299:41 - that's a feature in Python that we can
299:43 - add list together right and that's
299:44 - totally fine for our intermediate kind
299:46 - of understanding so what about length
299:48 - right I can get the length of a list
299:50 - that works fine too so if I look here I
299:53 - get a length of three and there's all
299:54 - kinds of things that I can do on a list
299:56 - like I can index something on a list I
299:57 - can put you know X1 and that gives me
300:00 - some value here and you're like well why
300:02 - are you showing me all this stuff
300:03 - because you're going to see that this
300:05 - kind of syntax that we're using right
300:07 - here on this object because this list is
300:11 - actually an object and I'll prove it to
300:12 - you just by printing the type of it and
300:14 - telling you that is actually a part of a
300:15 - class you can see class list is
300:18 - implemented under the hood now you might
300:21 - not understand what I mean by that right
300:22 - now but I'm actually going to import
300:25 - inspect and show you and then we'll get
300:27 - into a little bit deeper of this
300:28 - understanding so what I'm going to do is
300:30 - actually just say
300:32 - print
300:34 - inspect doget source of list Now list
300:38 - this is going to be ridiculous when we
300:40 - look at this in the terminal um list is
300:42 - a buil-in class oh it won't let me uh
300:43 - look at the source of the buil-in class
300:45 - okay that's fine we don't need to look
300:46 - at it for now um but anyways the whole
300:49 - point of this is that these objects here
300:53 - this is an object this list is they're
300:54 - both objects we take for granted the
300:57 - fact that we can perform certain
300:58 - operations on these objects using some
301:01 - special python syntax right like even
301:02 - being able to multiply list together
301:04 - like I can do X multiplies by 3 right
301:07 - that's kind of a special syntax why is
301:09 - it that we're able to to do that well
301:10 - that's because this operation is
301:12 - implemented on the list object itself
301:14 - and it tells the list object how to
301:16 - behave such that it sees a
301:19 - multiplication sign right after it or
301:20 - such that it sees a plus sign or it sees
301:22 - this index or it sees a call we
301:25 - Implement that functionality and because
301:27 - we can do that we can Implement that on
301:28 - our own objects now let's do one more
301:31 - example so obviously we saw when we
301:33 - printed out the value of this right we
301:35 - printed out X um we just printed like it
301:38 - just looked exactly like this it printed
301:40 - 1 2 3 right or in fact actually let me
301:43 - show you if I do a space here and I just
301:45 - print X let's have a look at what we get
301:47 - here we can see that this gets uniformly
301:50 - spaced even though there wasn't a space
301:52 - here so it's not the fact that it's just
301:54 - printing out exactly what this looks
301:55 - like there is something under the hood
301:57 - that's telling python what this list
302:00 - object looks like and what to print when
302:02 - we decide to print it out so let's
302:04 - create our own object now actually so
302:06 - I'm just going to say
302:08 - class person like this and let's just
302:11 - Define in a knit method now this is
302:13 - actually a double underscore method or a
302:15 - Dunder method or magic method whatever
302:17 - you'd like to call it we'll talk about
302:18 - how this one works in a little bit
302:20 - although I'm sure you guys understand so
302:22 - we'll just make our object uh person I'm
302:24 - going to say p equals person like this
302:27 - Make an instance give it a name of say
302:29 - Tim and then if we print the value of P
302:32 - well if we were you know if we looked at
302:34 - the list before and we saw that the list
302:36 - printed 1 2 3 4 just printed exactly
302:38 - what it looked like we we would assume
302:40 - that when we print P it should just
302:42 - print person Tim right it should print
302:44 - this well when we look at it it doesn't
302:47 - do that and I'm sure you've seen this
302:48 - before it prints the memory address
302:50 - location now the reason it does that is
302:53 - because we have not told person what to
302:55 - do when we try to print it it does not
302:58 - know what that what we should show so by
303:00 - default it shows the information that it
303:02 - thinks would be valuable which is simply
303:04 - just its memory address location right
303:06 - that's its like
303:07 - representation internally in the python
303:10 - program so how can we change this well
303:12 - we can Implement what we call a Dunder
303:14 - method or magic method which is called
303:17 - repper now I'm sure you've seen this
303:19 - before but essentially what rapper does
303:21 - is allows us to define the string
303:23 - representation of an object um from
303:26 - inside of it so what I'm going to do is
303:27 - make an F string and I'm simply going to
303:29 - say person and then in here self. name
303:33 - so now when we decide to print this out
303:36 - what we get is person Tim and I'll just
303:38 - do it one more time instead of getting
303:41 - that crappy you know just gibberish of
303:43 - memory address location so this is the
303:45 - first thing that we can do is we can
303:46 - Implement methods such as this on our
303:48 - own objects um to implement some kind of
303:50 - functionality now let's show a few
303:53 - others and why this is so powerful so
303:55 - there's actually a whole list of what we
303:57 - call Dunder methods and this is what's
303:59 - part of the Python data model and some
304:01 - people call these just data model
304:02 - methods and essentially um you guys can
304:04 - read through this if you want I'll leave
304:06 - the link in the description someone
304:07 - remind me if I forget if we scroll scr
304:10 - down to the bottom here we'll start to
304:12 - see that there's all kinds of these
304:14 - double underscore methods that we can
304:15 - actually Implement on our own objects
304:17 - and obviously I'm not going to go
304:18 - through all of them because there's just
304:20 - so many to kind of talk about uh but
304:22 - let's keep going down here so for
304:23 - example new nit Dell repper right we
304:26 - have this one here string bytes format
304:30 - uh ltle e EQ NE GT G we'll talk about
304:33 - what all those are hash um bull right
304:35 - get attribute set attribute dur Dell
304:38 - attribute multiplication there's all
304:39 - these kind of things that we can do so
304:41 - what I'm going to do is actually do a
304:42 - weird one and I'm going to U implement
304:44 - the multiplication Dore method so what
304:47 - this tells python to do actually um is
304:51 - what happens when we use a
304:53 - multiplication operation on objects of
304:56 - this type on objects of type person so
304:58 - what I'm actually going to do in mole
305:00 - here I'm going to assume actually X is
305:02 - going to be some integer and what I'm
305:04 - going to do is just take the person's
305:06 - name and multiply it by whatever the
305:07 - integer is and that's the operation
305:09 - we'll implement when we use the star or
305:11 - the asteris on the person object so what
305:13 - I mean by this is I'm just simply going
305:15 - to say
305:17 - selfname equals self. name time x and
305:21 - I'll even do a little just um thing up
305:23 - here I'll say if uh Type X is not int
305:29 - then we'll simply just throw an
305:30 - exception so we'll say
305:32 - raise exception we'll just
305:35 - say invalid
305:38 - argument must B in uh or in yeah
305:41 - whatever it doesn't really matter what
305:42 - we put there but that's fine okay so
305:44 - we'll say p equals person now what I'm
305:46 - going to do is simply print p uh we
305:49 - won't print that actually we'll just say
305:50 - p * 4 and then we'll print p and let's
305:53 - have a look at what this gives us okay
305:56 - person tim tim tim tim tim right so we
305:58 - can actually Implement whatever
306:00 - functionality we want using this upper
306:02 - level python syntax by implementing some
306:04 - kind of lower level Dunder method and
306:06 - that's what the whole point of this
306:07 - video was to do was to show you that
306:09 - everything that we use in Python all of
306:11 - these different symbols can be
306:13 - implemented on a lower level on our own
306:15 - objects and these are again our like
306:16 - data model uh methods right so we can
306:18 - create objects such that we can add them
306:20 - we can multiply them we can have
306:22 - representations we can do a call on them
306:24 - we can do all kinds of crazy things for
306:26 - example let's do Define uncore call
306:29 - let's just do self let's take some
306:30 - argument why not why and let's just
306:32 - print this value so what I'm going to do
306:36 - is now instead of printing P I'm just
306:38 - going to do p and put value four in
306:41 - there and now let's watch what happens
306:43 - so if I go like this we get the value
306:46 - four printing out we could even change
306:48 - this called this
306:51 - function right four so what happens is
306:55 - we can implement the fact that these two
306:57 - brackets what these two brackets do if
306:59 - they are on an object which is really
307:01 - cool it allows us to make objects that
307:03 - are much more usable much more readable
307:05 - and just almost seem like they fit in
307:06 - with the standard python documentation
307:08 - because I don't need to necessarily call
307:10 - a method I could actually just put the
307:11 - brackets now anything you can think of
307:14 - with this kind of syntax you can
307:15 - probably implement for example Define
307:17 - underscore uncore lencore uncore self
307:21 - return the Len of self. name maybe
307:25 - that's how long a person is unless
307:26 - you're going to ask for their height or
307:27 - something like that then what we could
307:29 - do is print the Len of P right so if we
307:33 - go like this we get three as that's the
307:36 - name so that's kind of the idea behind
307:38 - these Dunder meth in these data model
307:40 - methods the whole point is everything
307:42 - that's above even something like
307:44 - division you know greater than or equal
307:46 - to um less than whatever it is equals
307:49 - index all of these things can be
307:51 - implemented and if you want to see the
307:52 - implementation details of how all these
307:54 - work then you can read through this data
307:56 - model U documentation because there is a
307:58 - ton of them the whole point is you don't
308:00 - need to memorize these you just need to
308:01 - know that they exist and then you can
308:03 - think about for example if I have a
308:05 - class and I want to implement some kind
308:07 - of functionality maybe I have a
308:08 - polinomial class I want to add them or
308:10 - multiply them together then rather than
308:12 - having to make my own method called
308:14 - multiply what I can do is simply
308:16 - implement the mole um double uncore
308:19 - method and then that will allow me to
308:20 - use a star on it now notice you're going
308:23 - to want to make these types safe because
308:25 - obviously I multiplied by an integer but
308:26 - you could technically multiply two
308:28 - people together um you can do all kinds
308:30 - of things such as that okay so now I'm
308:32 - just going to show you something
308:33 - interesting this is just maybe to kind
308:34 - of inline you a bit or to show you
308:36 - something that we could actually do in
308:37 - theory so what I'm going to do is import
308:40 - actually let me say from Q import q and
308:46 - import inspect now what I'm going to do
308:49 - is just make a q object so I'm just
308:50 - going to say qal Q if you don't know Q
308:53 - it's just a built-in data structure in
308:54 - Python works as a q pretty
308:56 - straightforward and print Q okay so I
308:59 - just want to print Q to just show you
309:01 - that Q does not actually Implement a
309:03 - rapper method so let's just do this um
309:05 - and you can see that we're getting some
309:07 - random you know kind of memory address
309:09 - out to the screen so if I wanted to
309:11 - actually see why this wasn't giving me
309:14 - that representation I could have a look
309:16 - into Q itself so I can
309:18 - say
309:20 - print
309:22 - inspect uh doget Source like that and
309:25 - then I could print my just Q object like
309:28 - this not Q object sorry Q class have a
309:31 - look at the source code and we'll see
309:32 - that if we scroll through it here we
309:35 - don't have any Dunder methods that are
309:36 - implementing any functionality so let's
309:39 - say you wanted to make your own Q class
309:41 - that worked very similar to the python Q
309:43 - class but you wanted to do things like
309:44 - allow the plus sign or you wanted to do
309:46 - things like allow the minus sign well
309:48 - what you could do is you could say from
309:50 - Q import Q as Q like that then you could
309:54 - say your own
309:55 - class class Q is extends from q and then
310:00 - you can Implement your own Dunder
310:01 - methods so that you could override this
310:03 - so for example Define uncore rapper like
310:07 - this and then what I want to do is maybe
310:09 - I want to show a q but I want to say how
310:11 - many elements are in the Q well then in
310:14 - that case what I would do is return q
310:17 - and then I would say q and then I guess
310:19 - in this case going to be self
310:21 - doore Q length or Q size something like
310:26 - that now now what I do if I create a q
310:29 - say uh you know qu equals Q like so and
310:34 - I decide to print out
310:36 - qu like that so let's have a look
310:40 - and we can see we get Q with zero items
310:42 - now the reason I knew to use Q size is
310:43 - because I read through the source code
310:44 - and I saw that Q size returns a length
310:46 - of self doq and I see here we have self.
310:49 - q equals DQ uh what else do we have all
310:52 - these other things so this Q actually
310:53 - just implements a DQ object uh where's
310:56 - the init it's right here it can read
310:58 - through you can understand how this
311:00 - works so if you wanted to actually add
311:02 - something to the que right using maybe
311:04 - the plus sign and you didn't want to
311:05 - implement something else then what I
311:07 - could do is say Define underscore uncore
311:08 - add
311:09 - _ self um item like that and then what I
311:14 - would simply do here is okay let's add
311:16 - that to the Q so we'll say self dop put
311:20 - and then item so now if I want to add
311:22 - something to my Q I can say Q + 9 and it
311:25 - doesn't even need to be equals I can
311:26 - literally just do+ 9 and if we come here
311:29 - and we run this now we have an object CU
311:31 - with length one right and I could keep
311:33 - doing this I do Q + 7 right like that
311:38 - and then if I wanted to I could
311:39 - literally Implement a negative sign so I
311:41 - can say Q minus we have to put something
311:44 - here but if I want then I'd say Define
311:45 - uncore
311:47 - subcore
311:48 - self item and then all I can do is say s
311:51 - let's just say
311:53 - self. getet like that and that's all we
311:57 - need to do so now if we run this we
311:59 - should see Q as length one and even
312:01 - though I mean I don't like I just put a
312:02 - minus sign like this actually I'm
312:04 - curious if this will even work um Q
312:06 - minus imbal syntax so I could do like Q
312:07 - minus none if I wanted to uh and then
312:10 - that still will remove that item for me
312:12 - so this is the idea right these aunder
312:13 - methods allow you to implement these
312:15 - kind of syntax things this higher level
312:17 - syntax and this is what's called again
312:19 - the data model in Python this is how all
312:21 - these different objects work and these
312:23 - Dunder methods can be very useful
312:25 - there's a lot of different ones I'm not
312:26 - going to go through all of them but the
312:27 - whole point is that you understand that
312:29 - each one of these kind of unique pieces
312:31 - of syntax in the higher level of python
312:33 - maps to a lower level Dunder method that
312:35 - implements that imp implements that
312:37 - operation right so that's the way that
312:40 - this works so yeah so hopefully that
312:42 - kind of cleared things up on Dunder
312:44 - methods and Magic methods they're really
312:46 - not that complicated they're very useful
312:48 - and when you're creating classes where
312:50 - these operations make a lot of sense to
312:52 - do like adding subtracting multiplying
312:54 - especially working with numeric values
312:56 - being able to avoid having to create
312:57 - your own methods like Define add x y and
313:01 - being able to just implement the dunder
313:03 - method add and use the plus sign can
313:04 - make things a lot more intuitive um and
313:06 - just easier to read in your programs so
313:08 - anyways that has been it I hope you guys
313:10 - enjoyed this video on Dunder methods
313:12 - magic methods and the python data model
313:14 - as always if there's anything you'd like
313:16 - to see in the future videos please do
313:17 - leave a comment down below like
313:19 - subscribe and I will see you in the next
313:25 - video hello everyone and welcome back to
313:27 - another python expert tutorial series
313:29 - what we're going to be doing in this
313:30 - video is covering meta classes a fairly
313:32 - complex but very interesting topic in
313:34 - Python so we're going to start from the
313:36 - very beginning and start understanding
313:38 - how classes are actually created
313:40 - instantiated um the way they work on a
313:42 - lower level in Python and then from
313:44 - there we're going to move into what meta
313:45 - classes are how they actually work and
313:48 - why we would even want to use them now
313:50 - I'm just going to preface this video by
313:51 - saying meta classes are an extremely
313:53 - complex thing I'm only going to be
313:55 - showing kind of the basic implementation
313:57 - of meta classes here if you really do
313:59 - want to use these you're going to have
314:00 - to look up the documentation and
314:02 - implementation details on your own and
314:04 - there's very few instances in which you
314:06 - need a meta Class A lot of what I'm
314:08 - about to show you can be accomplished in
314:09 - other ways and typically you're going to
314:11 - want to use another way other than a
314:13 - meta class just because these are seen
314:14 - as very complicated and almost sometimes
314:16 - bad practice depending on what you're
314:18 - trying to do so these should really only
314:20 - be used by experts I mean I'm showing
314:22 - them to you guys so you can get an
314:23 - intuition on how they work and if you
314:25 - see one you'll understand what it does
314:27 - but you shouldn't really be putting
314:29 - these into your own code and using them
314:30 - unless you absolutely need to so before
314:32 - we get into the content again a quick
314:34 - thank you to kite for sponsoring this
314:36 - video series they have a download link
314:38 - in the uh in the description down below
314:40 - you can download them for free they are
314:41 - essentially a very good python
314:43 - autocomplete so you can see if I start
314:45 - typing some things like this we get a
314:47 - kite completion thing popping up and
314:48 - anyways that's what they are they're
314:49 - free you can download that from the link
314:51 - in the description all right so let's go
314:53 - ahead and get started now the first
314:55 - thing that I want to do is really
314:57 - discuss how classes work and what
314:59 - classes are so we saw in the previous
315:02 - example and I believe two videos ago I
315:04 - did something crazy like this right and
315:06 - I made a class and I find it inside of a
315:09 - function and then in that function I
315:11 - actually just returned the class itself
315:14 - and this is totally fine this is valid
315:15 - syntax you can see I just ran the code
315:17 - down here we don't get any errors that's
315:19 - fine the reason we can do something like
315:22 - this in Python and not in other
315:23 - languages is because in Python classes
315:26 - are actually objects now the property of
315:29 - an object essentially means that we can
315:30 - interact with it at runtime we can pass
315:32 - it around through um parameters through
315:35 - variables we can store it we can save it
315:37 - we can modify it we can interact right
315:39 - that's what an object is now a lot of
315:41 - people are going to say well how is a
315:42 - class an object I thought a class
315:45 - created objects for us well that's very
315:47 - true a class does create objects for us
315:50 - but that doesn't mean that it's not an
315:52 - object itself and if a class is an
315:54 - object if you believe what I'm saying
315:56 - and I'll prove it to you in a second
315:57 - then that means we must have had some
315:59 - higher level class that created that
316:01 - object for us right just like if I Make
316:03 - an instance of high and I do something
316:05 - like that that means we must have this
316:07 - class High such that we can make an
316:09 - object you know and have the instance
316:11 - for it so what we're going to be getting
316:13 - into here with meta classes is the basic
316:16 - idea is a class defines the rules for an
316:19 - object right it defines the attributes
316:21 - the parameters the methods the things
316:22 - that are allowed the operations that can
316:24 - be performed that's what a class does
316:26 - for an object what a meta class does is
316:29 - Define the rules for a class so when you
316:31 - create a class you will use the meta
316:34 - class to create it this happens
316:35 - automatically you don't need to type
316:37 - anything specifically but we're going to
316:38 - hook in to it later and see how it
316:39 - really operates and that meta class
316:42 - defines how this class is created and
316:44 - that's the basic concept here so I'm
316:47 - going to make another class and I know
316:48 - this is confusing but as we go through
316:50 - here you're going to start to slowly
316:51 - understand with these examples and all
316:53 - I'm going to do is just print an
316:55 - instance of this class so let's look at
316:57 - it we can see this tells us it's an
316:59 - object main test object at some
317:01 - gibberish location so now let's print
317:04 - above this just the class
317:07 - itself okay look at that class main.
317:11 - test now the reason we're able to do
317:13 - this again is because this is an object
317:14 - so I know this doesn't explicitly say
317:16 - object but this class is an object now I
317:19 - want to look at something else so we
317:21 - know we have this method in Python
317:23 - called type and I can look at the type
317:25 - of a uh a class or an instance or an
317:28 - object and I see what it is so let's
317:29 - look at it when we do the type of test
317:32 - we get that is in class main if I were
317:34 - to print say the type of an integer
317:37 - right like the type of two let's have a
317:40 - look that's class int right and we could
317:42 - print you know the type of whatever we
317:43 - want we could print the type of a
317:45 - function so we say
317:47 - Define Funk like that and then just
317:50 - we'll just say pass in there and we do
317:52 - Funk what's that that's class function
317:55 - right so that exists in a function so
317:56 - this is an object this function is an
317:58 - object everything in Python is an object
318:00 - and that means they have a type and they
318:02 - were created somehow so what is the type
318:05 - of a class well let's look at it so
318:08 - we'll delete all this and then we'll
318:10 - just
318:11 - print the type of and I somehow hit
318:15 - insert accidentally there of test so
318:18 - what do you think this type is is it of
318:20 - type test is this class of that type no
318:23 - it is of Class Type now I know this
318:25 - seems ridiculous this means nothing to
318:27 - you right now we're going to dive into
318:28 - what this is but essentially this is
318:30 - what we would refer to as the meta class
318:32 - so this type is what essentially defines
318:35 - the rules and creates this class for us
318:38 - when we type this class syntax we will
318:41 - call a type Constructor using the
318:44 - different things in our class to make
318:46 - this class object that we can then use
318:48 - to make objects and use to interact with
318:50 - in the program so what is Type how does
318:53 - this type thing work well if I told you
318:55 - that this class all this is doing the
318:57 - syntax is just calling this type class
319:00 - then we should explicitly be able to
319:02 - create our own objects without typing
319:04 - out the syntax like this we should just
319:06 - be able to use the type class itself
319:08 - which is true and what I'm about to show
319:10 - you so I've just created class test it
319:12 - it has passed it has nothing in it right
319:14 - now I'm going to show you how we can
319:15 - make this without actually having to
319:17 - type this kind of syntax and writing out
319:19 - class in fact and this seems ridiculous
319:22 - I agree python should have done a better
319:23 - job when they defined this but I believe
319:25 - it's something to do with just backwards
319:27 - compatibility we can make a class by
319:29 - doing this and just watch and then we'll
319:31 - talk about exactly how it
319:35 - operates so this line of code is
319:38 - completely equivalent to this these two
319:42 - things are completely equivalent there's
319:43 - absolutely nothing different about them
319:46 - and I can use test here the same way I
319:48 - can use test here just like I can create
319:50 - an instance of test I can create an
319:52 - instance of this other test so let's do
319:54 - it let's let's prove it to you so if I
319:56 - print test and Make an instance boom
319:59 - main test object Works totally fine no
320:02 - issues with that what else can I do I
320:04 - can print the class and again same thing
320:06 - we have that object totally fine that's
320:08 - because this function here essentially
320:11 - creates the class for us using these
320:14 - different arguments a name this is the
320:17 - internal representation of the class any
320:19 - bases which means anything that we
320:21 - inherit from so like a super class or a
320:24 - parent class and then any attributes so
320:26 - let me start showing you what I mean uh
320:28 - and then hopefully this should make some
320:29 - more sense so I'm going to set an
320:30 - attribute of five I'm going to say t
320:33 - equals test Make an instance and just
320:35 - print that attribute uh go like this of
320:39 - t.x so just like this works on a regular
320:42 - class we can do that we get our value
320:44 - five now just like in regular classes as
320:46 - well I can Define attributes outside of
320:48 - the class so you say something like t.
320:51 - Wy why not set that equal to let's just
320:54 - say hello want to print Wy sure let's go
320:58 - for it uh T.W one second
321:03 - guys oh T is not defined so that needs
321:06 - to go above so I can explain meta
321:08 - classes but apparently cannot just
321:09 - create regular classes okay so that's
321:10 - totally fine that works we have t equals
321:13 - test and then T.W equal hello we can
321:15 - print that attribute that's totally fine
321:17 - so that's how we can create classes
321:18 - using type now what about methods what
321:20 - about sub I'm going to show you all that
321:22 - so we'll do that now uh and then we'll
321:24 - get into actually meta classes and how
321:26 - this is even useful to us so what I'm
321:28 - going to do is make another class I'm
321:30 - just going to call this class Fu let's
321:31 - just make a method in here just called
321:33 - print uh actually not print let's do
321:35 - like show and then all we'll do in here
321:37 - is take one attribute we'll say self and
321:40 - just
321:41 - print hi why not right just do that so
321:44 - if I want to now have an inheritance
321:47 - what I can do is simply type the name of
321:49 - the Class A Comma just to make sure this
321:51 - registers as a tble Here and Now test
321:53 - will inherit from F which means that if
321:55 - I want to use the method show I can do
321:58 - that and I can run that like that and we
321:59 - get that now I shouldn't have printed
322:01 - that out because I forgot that wasn't a
322:02 - return value but you can see we get high
322:04 - that works totally fine this is how you
322:06 - do this right now what if I want you add
322:09 - methods right so to add a method is a
322:10 - little bit different but essentially
322:12 - what you're going to do is just Define a
322:13 - function that will be the method
322:14 - signature so in this case let's say you
322:17 - know add
322:19 - attribute put self like that then here
322:22 - we just say self. Z equals 9 why not
322:25 - right we'll do that and then in here
322:28 - we'll Define our attribute so we'll say
322:30 - addore
322:31 - attribute colon guess what we're going
322:33 - to do add attribute no brackets now make
322:36 - our instance let's call t. add attribute
322:40 - and then let's
322:42 - print t. Z like that and let's look at
322:45 - this and there we go we get the value
322:47 - nine that works fine so this is how we
322:49 - use type this is how we create a class
322:52 - and this is very important to understand
322:53 - as we get into the next part of the
322:55 - tutorial here because if you can
322:56 - understand how we use this to create our
322:58 - own classes then you're going to
323:00 - understand the next part and why when we
323:02 - have a syntax like this all this really
323:05 - does is pass that information to another
323:08 - class called type that creates the class
323:11 - for us and returns an object that
323:13 - represents that class now I know this
323:14 - was a lot I hope this you guys
323:16 - understand at this point now we're
323:18 - actually going to get into meta classes
323:19 - this was just the underlying information
323:20 - we need to understand all right so
323:22 - welcome to the next part of the tutorial
323:24 - what we're going to be doing now is
323:25 - actually getting into meta classes and
323:27 - showing how they work so again the basic
323:29 - principle here is to remember that a
323:30 - meta class is above the classes you're
323:33 - creating yourself so if you create
323:34 - something like class dog right and you
323:37 - do that what's actually happening is all
323:39 - this information that you typee out the
323:41 - syntax gets passed to some meta class
323:44 - the thing above it that actually takes
323:46 - that and returns to you an object that
323:48 - represents that class and that's the
323:50 - whole point here so what we're going to
323:51 - do is actually make our own meta classes
323:53 - so rather than using that built-in type
323:55 - class and you could see on all of our
323:57 - objects when we looked at the type of
323:59 - them they were of type type we're simply
324:01 - going to make our own meta class that
324:03 - inherits from type so does a very
324:05 - similar thing but we're going to change
324:07 - slightly how objects are constructed so
324:09 - you can really understand how this works
324:11 - now you might get lost a little bit at
324:13 - the beginning when I start typing some
324:14 - of this stuff out but hopefully you
324:15 - should start to follow along as we go
324:17 - through and explain how all this works
324:19 - so let's get started I'm going to start
324:21 - just by creating a meta class and I'm
324:22 - going to call this meta now whenever you
324:24 - make a meta class what you have to do is
324:26 - make it inherit from type uh not
324:29 - necessarily but for our purposes that's
324:30 - what we're going to say it has to
324:32 - inherit from type to make a meta class
324:34 - the reason for that is because type does
324:36 - some other things when it's creating an
324:37 - object right and if you don't inherit
324:39 - from this well your class is just going
324:41 - to be not a meta class now because it's
324:43 - going to be using type to create this
324:45 - kind of class if that makes any sense
324:48 - whatsoever but hopefully that does what
324:50 - we're going to do now is I'm actually
324:52 - going to define a new method like this
324:55 - and for those of you that don't know
324:56 - what new does as a Dunder method or
324:58 - magic method like we talked about before
325:00 - essentially this is called before the
325:02 - init method so this is the first thing
325:04 - that is always called when a object is
325:06 - created or instantized or whatever you
325:08 - want want to call it this is always
325:09 - called first so what you can actually do
325:11 - here is hook into this and modify the
325:13 - way an object is constructed by changing
325:16 - what happens in this new method whereas
325:18 - the init all the init is doing is after
325:20 - this new method gets called and the
325:22 - object is constructed what it does is it
325:25 - um initializes uh it changes the values
325:28 - it takes some parameters in like that's
325:29 - what it does right whereas new is just
325:32 - called beforehand to modify the
325:33 - construction of the object okay so what
325:35 - I'm going to do in here is I'm going to
325:37 - take self
325:38 - I'm going to take class name and
325:40 - remember this is what's going to be
325:42 - called whenever we create another class
325:44 - that uses this as a meta class we're
325:45 - going to say class name we're going to
325:47 - say bases and bases is what we put
325:50 - remember in that type argument when we
325:52 - want to do inheritance we have the name
325:54 - we had the bases and we have the
325:55 - attributes and guess what this last
325:57 - one's going to be it's going to be
325:58 - attributes so essentially we're saying
326:00 - okay when we create this new method the
326:03 - construction of a class which happens in
326:06 - this meta class needs to contain the
326:07 - class name the bases and the attributes
326:10 - so that that way we can look at them we
326:11 - can do something with them and we can
326:13 - return to you a class that has those
326:15 - pieces of information right as an object
326:17 - so what I'm going to do now is simply
326:19 - just return the type of in this case
326:22 - it's going to be class uncore name bases
326:26 - and htrs now this is very simple we're
326:28 - not really going to do anything other
326:29 - than this but I'm also just going to
326:31 - print out the
326:33 - attributes so you can see what they look
326:35 - like okay now what I'm going to do is
326:37 - I'm going to make another class I'm
326:38 - going to call it dog this is going to
326:40 - have a meta
326:42 - class that's equal to meta like that and
326:47 - then in here all we'll do is just say x
326:49 - = 5 y = 8 just so we can look at some
326:51 - things when we print these attributes
326:53 - out and then we'll create an instance of
326:55 - dog so we'll say d equals dog like that
326:58 - and run the code all right so look at
327:01 - this what has happened well actually I'm
327:04 - even going to get rid of this and just
327:05 - show you that even if I don't create an
327:07 - instance this still runs right you can
327:08 - see no instances this is still running
327:11 - the reason for this is because the
327:12 - default meta class of dog is type right
327:15 - that's what it runs and that's how the
327:17 - class is created what we've done is
327:19 - we've overridden that we've changed it
327:20 - to our own meta class and essentially
327:23 - we've added our own little piece here
327:25 - that just prints out the attributes and
327:27 - then returns to us an object remember
327:29 - this is an equivalent way of creating
327:31 - this class by just literally typing this
327:33 - line and this is what happens this is
327:35 - what we get so we can see that we have
327:36 - the attribute module is equal to main
327:38 - the qual name dog so that's the name of
327:41 - this class right and then we have our
327:43 - attributes so X5 Y8 that we've defined
327:46 - down below now what if we Define a
327:48 - method called hello and we
327:52 - print say hi inside of here well then
327:57 - you can see we have dog. hello at some
327:59 - memory location that's mapped to by
328:01 - hello and that's a function so that's
328:03 - how this works now knowing this
328:05 - information meta classes can be very
328:07 - powerful because for example let's see
328:10 - like I can hook into the construction of
328:12 - this class and I can modify the
328:14 - construction of it if I want now this is
328:16 - something you would never do what I'm
328:18 - going to do is actually change all of
328:19 - the attributes that I have here to be um
328:24 - what do you call uppercase so I'm going
328:25 - to change this x to be a capital x this
328:27 - y to be a capital Y and this function
328:29 - hello to be Capital hello so all
328:32 - capitals I won't bother changing I can't
328:34 - change these underscore methods but I'll
328:36 - show you how we do this okay so let's
328:38 - start programming this so what I'm going
328:39 - to do is I'm going to make a blank
328:41 - dictionary I'm just going to call it a
328:43 - because notice down here that all of my
328:45 - attributes are actually in a dictionary
328:47 - right so what I'm going to do is modify
328:49 - this attributes dictionary based on the
328:51 - attributes that we passed in and make
328:52 - them all capital assuming that they're
328:54 - not they don't start with two
328:55 - underscores so what I'm going to do is
328:56 - say for item in hrs. items and I'm not
329:00 - sure if the syntax is 100% correct so
329:02 - there might be a mistake here we're
329:03 - going to say if item do starts with and
329:07 - in this cas case it's going to be
329:09 - underscore
329:10 - uncore then what we'll do is simply just
329:12 - add it back into the dictionaries
329:14 - actually yeah we'll just add it back
329:15 - into the dictionary so we'll say a in
329:17 - this case item equals
329:20 - ATS and then item like that so
329:23 - essentially since this is dictionary the
329:25 - way this is going to work right is we're
329:26 - just assigning this item to this new
329:28 - dictionary it's just literally the same
329:29 - thing right okay otherwise so if it
329:31 - doesn't start with a double underscore
329:33 - we need to change it to be uppercase so
329:34 - we're going to say a and in this case
329:36 - item. uper like that equals
329:41 - atrs item then we'll change the
329:44 - attributes here to be a which will be
329:45 - our modified attributes and that means
329:47 - when we return this dog class this
329:48 - should work assuming I haven't made a
329:50 - mistake which is likely but let's look
329:51 - at it and let's see what I got wrong all
329:54 - right so I guess I forgotten the fact
329:56 - that when we do something like this I
329:57 - need to actually Loop through with name
330:00 - value rather than just item so name will
330:02 - be the attribute name value obviously
330:05 - the value mapped with it just means
330:06 - we're going to have to change a few
330:07 - things here which we say name so having
330:09 - to do that we can change that to Val we
330:11 - can say name and that's yeah so name
330:13 - here this will be Val like that and I
330:17 - think we should be good on that front
330:18 - let's run that um and let's have a look
330:20 - at this air name Val is not defined of
330:23 - course I've made it value let's run and
330:25 - there we go we get good okay so let's I
330:29 - haven't proved to you really what
330:30 - happened but let's just step through
330:31 - this code cuz I did make a few errors so
330:33 - it might be confusing so we started by
330:35 - printing the attributes we then made a
330:37 - blank list uh a blank dictionary sorry
330:39 - that's going to represent our new
330:40 - attributes and then we've looped through
330:42 - all of the attributes so we just do do
330:43 - items to get uh the name and the value
330:46 - and we said if the name starts with a
330:48 - double underscore just add the proper
330:50 - value back in otherwise what we'll do is
330:52 - add the uppercase attribute with that
330:55 - corresponding value so we've changed
330:56 - them to Upper uh to uppercase
330:58 - essentially so let's actually print the
331:00 - values down here so the new values just
331:02 - have a look at the difference and you
331:04 - can see if we scroll up here that notice
331:07 - hello has been changed to Capital hello
331:09 - X to capital X and Y to Capital y so now
331:13 - let's do another proof just to make sure
331:14 - that all of you believe me that this is
331:16 - okay to do and let's go down here and
331:19 - say d equals dog create an instance and
331:22 - let's try to say see what d.x is so just
331:24 - print
331:26 - d.x well what is the error let's look at
331:29 - this here dog object has no attribute X
331:33 - what's but we defined X up here that's
331:35 - because we've changed it to be a capital
331:37 - X and notice that when I do that that's
331:39 - totally fine and same goes with hello I
331:42 - can't access that but when we change
331:43 - that to Capital hello we're totally fine
331:46 - because again we've modified the
331:48 - construction of the object all right so
331:51 - now that we kind of understand how meta
331:53 - classes work we've seen that we can hook
331:55 - into them we can change the way that
331:56 - objects are created we can en Force
331:58 - certain constraints I can change all of
331:59 - the attributes to be capital I can do
332:02 - whatever I want right I could change the
332:04 - bases I could remove an inheritance if I
332:06 - didn't want that to be allowed
332:08 - essentially this is why they call it
332:10 - magic because with this kind of hook
332:12 - into the creation of classes you can
332:15 - really enforce quite a bit of
332:17 - constraints on how classes are created
332:19 - so for example if you want every single
332:21 - class in a specific module to never be
332:24 - allowed to use a certain attribute or to
332:26 - only have or to have to have that
332:28 - attribute you could set meta classes for
332:31 - those or for that actual specific module
332:33 - which I'm not going to talk about now
332:35 - and then when that module's run it will
332:37 - check The Meta class right it will go
332:39 - through the meta class that's how we
332:40 - create the classes itself and make sure
332:42 - that all of these classes kind of
332:44 - conform to that structure that you've
332:46 - defined now this is specifically nice
332:48 - for when you're writing kind of Library
332:49 - code and you want your user code to be
332:51 - very specific let's say they're
332:52 - inheriting from a specific type um you
332:55 - could check if they're inheriting from
332:57 - you know whatever type it is that you
332:58 - want if they do inherit from that type
333:00 - you can enforce the fact that they have
333:01 - a specific function or specific method
333:04 - in that class that's needed to make that
333:06 - work so that's some of the things that
333:08 - you can do with meta classes again
333:10 - they're very complicated there's not
333:12 - really like a need to use them so you
333:13 - don't necessarily need to implement them
333:15 - into your program but sometimes they're
333:17 - cool and understanding how this class
333:19 - construction Works to me is even a
333:20 - better benefit of using the meta class
333:22 - itself so I believe there was one last
333:24 - thing that I wanted to cover here
333:27 - although it's not coming to me at the
333:28 - top of my head I mean I think that's
333:30 - pretty much it I don't know what more
333:32 - more I can show you guys you can have
333:34 - meta classes that inherit other meta
333:36 - classes you can do very very complex
333:38 - things with that but I think honestly
333:40 - for now we're going to wrap the video up
333:42 - at this I hope you guys enjoyed I hope
333:44 - you understand now how classes are
333:46 - created how meta classes work and what
333:48 - the heck they even are and I hope that
333:50 - you understand that you don't need to
333:53 - use this and the point of this video is
333:54 - to introduce you to the concept and make
333:56 - you more familiar with the way that
333:57 - classes and objects actually work in
333:59 - Python so anyways that has been it I
334:01 - hope you enjoyed make sure you leave a
334:02 - like if you did subscribe to the channel
334:04 - and I will see you in another expert
334:05 - Python tutorial
334:11 - hello everybody and welcome back to
334:12 - another expert Python tutorial so in
334:15 - today's video we are going to be talking
334:16 - about decorators which are a pretty cool
334:18 - and useful tool they're not super
334:20 - complex but essentially they allow us to
334:22 - modify the behavior of a function
334:24 - without actually changing any of its
334:26 - code now this is useful because
334:28 - sometimes you want to be able to add and
334:30 - remove decorators while debugging a
334:32 - function or maybe you want to change the
334:35 - behavior of all of your functions and
334:36 - rather than going in and changing all of
334:38 - the code you could create a decorator
334:41 - which will allow you to Simply you know
334:42 - use one line of code to change the
334:44 - behavior of all of these different
334:46 - functions so I'll show you how this
334:47 - works and what a decorator actually is
334:49 - to start by just going through a bit of
334:50 - a kind of recap of how python passes
334:53 - objects around and why we can actually
334:55 - even use decorator a quick reminder
334:57 - before we get started that kite is the
334:59 - sponsor of this series kite is the best
335:01 - AI auto complete for python on the
335:03 - market and you can get it for free in
335:04 - the link in the description it
335:06 - integrates with the all the popular
335:08 - idees and text editors so subline VSS
335:10 - code adom Vim you name it chances are
335:13 - kite is you know compatible with that
335:15 - again you can download that from the
335:16 - link in the description so the first
335:18 - thing I'm going to do is I'm going to
335:19 - create a function called Funk now what I
335:21 - want to do is just show you that if this
335:23 - function takes a string I can actually
335:26 - return another function in here that
335:28 - does something with this argument and
335:30 - we've seen this before in the previous
335:32 - expert python tutorials but I want to
335:33 - just make this very clear on how this
335:34 - works so I'm going to call this function
335:36 - a wrapper because it's in side of this
335:38 - function it's not going to take anything
335:40 - as an argument and what I'm simply going
335:42 - to do in here is say
335:44 - print
335:46 - started
335:48 - print string and
335:52 - print ended like that and we'll do a
335:54 - capital and I guess actually this string
335:56 - sorry does not need to be in a string it
335:58 - needs to be like that so we print the
336:00 - variable and then what I'm going to do
336:01 - here is simply return the wrapper
336:04 - function like that so if I do this now
336:06 - what happens if I say x equals Funk like
336:09 - that and I put in my string let's say
336:11 - hello and I run this program you can see
336:14 - we get started hello and end
336:17 - it now the reason that happened is
336:19 - because we returned here the wrapper
336:22 - being called right these two brackets
336:24 - but if I remove this and I do this now
336:26 - nothing happens so what we've actually
336:28 - done if I print out the value of x is
336:31 - you see we store a function in here that
336:34 - was returned from this function which is
336:36 - actually equal to this and then if we
336:38 - wanted to call this function we could
336:39 - put our little braces like that and here
336:42 - we go we get started hello and ended so
336:44 - I just want to show you that this is
336:46 - possible and the reason this is possible
336:47 - is because functions in Python are
336:49 - objects which means that we can pass
336:51 - them around we can throw them around our
336:53 - program and you can see up here that
336:55 - this is the location of the object you
336:57 - know function wrapper from funk. locals
337:01 - okay so now that we understand that
337:03 - let's bring it up a little Notch and see
337:05 - what happens if we actually instead of
337:07 - just just passing a string in here pass
337:09 - another function so I Define a fun
337:12 - function I'll call it funk two like that
337:14 - and all we'll do in here is just
337:16 - print something we'll say I am Funk 2
337:21 - why not I'll get rid of this and now
337:23 - rather than passing a string in here why
337:26 - don't we actually just call some
337:28 - function so let's put F in
337:30 - here let's put I don't want Funk two I
337:32 - just want F let's call whatever function
337:35 - is called so we'll do print started call
337:37 - whatever ever function was in here and
337:38 - then print ended and then return this
337:41 - function so let's see how this works so
337:44 - now if I can move this down a bit let's
337:46 - say x equals
337:49 - Funk Funk 2 let's print X and then let's
337:54 - call X so what we're doing here for
337:56 - anyone that's confused is we've created
337:58 - this function which accepts a function
338:00 - as an argument right or as a parameter
338:02 - then what we do in here is we Define a
338:04 - function that prints started calls
338:06 - whatever function was passed in prints
338:09 - ended and then returns this function so
338:12 - this is not actually going to do
338:13 - anything until it is called so when we
338:15 - return this we'll store it in a variable
338:17 - X and then when we want to use this
338:20 - interior function here we call it with
338:23 - this right the X and the brackets so
338:25 - let's have a look at how this works
338:27 - contrl B and you can see started I am
338:29 - Funk to ended fun Funk uh rapper locals
338:32 - right and the idea here is that I can do
338:35 - the same thing with say funk three right
338:37 - right if I print let's
338:40 - say I am Funk 3 like that now rather
338:44 - than passing Funk two I can pass Funk
338:46 - three and we can see now we get the same
338:48 - thing happening except Funk three and in
338:50 - fact we could do it you know I could say
338:52 - y equals Funk Funk 2 and then we can do
338:57 - the same thing and just call Y down here
338:59 - and now both of them are going to work
339:00 - and they're both going going to be
339:01 - different so started I am Funk 3 started
339:04 - I am Funk two ended so with this in mind
339:07 - we can start looking at kind of what a
339:08 - decorator is now almost but I just want
339:10 - to show you a way that let's say you
339:12 - know this function right here which
339:14 - we're going to call our decorator we
339:15 - don't want to have to do this weird call
339:18 - right where we use our decorator
339:19 - function to call function three we just
339:21 - want to call function three and have it
339:24 - do this behavior and you know do
339:26 - whatever function three is right how
339:28 - would we get that to work how would we
339:30 - get that to happen we rather than me
339:31 - having to call Funk and pass Funk 3 and
339:34 - Call Funk and pass Funk 2 how can we do
339:37 - this another way well what I can
339:40 - actually do is kind of a cool sneaky
339:41 - line here in Python where I do this I
339:44 - say funk three is equal to Funk at Funk
339:48 - 3 now this seems like a weird line of
339:52 - code but essentially what this is going
339:53 - to allow us to do now is rather than
339:56 - having to call function and pass Funk 3
339:58 - in we can actually use Funk 3 which is a
340:00 - variable now which stores the function
340:04 - that is returned from the call of Funk
340:07 - with function three which means that if
340:09 - we
340:10 - call Funk 3 like that then what's going
340:13 - to happen is it's going to run this
340:15 - function that was created from this call
340:17 - so this is a way that we can kind of
340:19 - change that behavior we can say okay so
340:22 - Funk 3 I always want this whatever's
340:24 - inside this wrapper function to happen
340:26 - whenever I call it so all I need to do
340:28 - to Define that is write this line of
340:31 - code and now every time I call Funk 3
340:33 - from anywhere in my program it'll do
340:34 - this and if we run this we can see that
340:37 - happens and that works fine and we can
340:39 - do the same thing with funk 2 um yeah
340:42 - Funk 2 equals Funk Funk 2 and then we'll
340:47 - call Funk two like that and we can see
340:49 - that it works for both of them so this
340:52 - is where we now get into the concept of
340:54 - a decorator things are going to get a
340:55 - little bit more complicated but now all
340:57 - I'm going to show you is what a
340:58 - decorator does versus what we've done so
341:01 - this kind of line of code here is weird
341:03 - right like it's not something you really
341:05 - want to write you don't really know
341:06 - where to put it it's like just not ideal
341:08 - to have to write this line of code so
341:10 - python has thought of this for us and
341:13 - what they've introduced is a syntax that
341:15 - essentially allows us to do this um just
341:17 - in a better way and all it is is using
341:19 - this at sign and putting the name of
341:21 - your decorated function so like that
341:23 - just on top so now this line here pretty
341:26 - much just replaces this line like they
341:29 - are exact identical copy they do the
341:32 - same thing this just looks a little bit
341:33 - nicer and it's a little bit easier to
341:35 - understand what's happening when you
341:36 - have you know this decorator syntax
341:38 - above the function and you can actually
341:40 - decorate your function with more than
341:42 - one decorator if you want we're not
341:43 - going to talk about that right now uh
341:45 - but that's something to note so pretty
341:47 - much to replace these lines of code all
341:49 - I have to do is put at the name of the
341:51 - function that I want to run before right
341:54 - and then now if I do fun three and fun
341:56 - two we can see we get the same thing so
341:58 - we get started I Funk 3 ended started I
342:00 - am fun two ended so this is how this
342:03 - works so whenever you're creating a
342:04 - decorator function you need to kind of
342:06 - implement this raer functionality where
342:08 - the first thing takes the function
342:11 - itself and the second function here well
342:14 - this just takes the um or what is this
342:16 - this creates the function that's going
342:17 - to be called when this is returned right
342:20 - or when you actually call this function
342:21 - so essentially you're changing your said
342:23 - Funk 2 is now going to be equal to
342:25 - whatever this is and usually inside of
342:27 - here you're going to use the function
342:29 - now there's a lot of problems that I'm
342:31 - sure some of you can think of here so
342:32 - what happens if I say fun 2 takes an
342:35 - argument X and instead of saying uh I am
342:38 - fun 2 all it does is just print out x
342:41 - what happens now well if I run this and
342:44 - I even let's give an argument let's give
342:46 - five here you can see we're getting an
342:47 - error right and the reason we're getting
342:49 - an error this huge error what it say
342:51 - rapper takes zero positional arguments
342:53 - but one was given so the issue is that
342:56 - when we actually call Funk two what
342:58 - we're actually going to be calling from
342:59 - this line of code is this wrapper
343:01 - function so this wrapper function needs
343:03 - to have the same amount of arguments
343:05 - that function two has so how can we do
343:07 - that how can we fix that well we could
343:10 - just put an X here like this right and
343:12 - then let's comment out fun three let's
343:15 - run this uh oh sorry my bad we got to
343:18 - throw an X in here that was what the
343:20 - issue was before so we have our X's
343:22 - there and then this works right so I put
343:23 - an X in the wrapper I put an X here
343:25 - which means that when I call this x will
343:27 - be passed to this wrapper X and then we
343:29 - can use that to call the function and
343:32 - that's totally fine but what happens now
343:34 - when I want to use Funk three and Funk 3
343:36 - does doesn't take any arguments but this
343:38 - takes arguments the whole point of
343:40 - decorators is to be able to use this on
343:42 - multiple functions and we get missing
343:44 - one required positional argument x uh
343:46 - Funk three there's an issue you know
343:48 - things are happening so what what do we
343:51 - do here how do we fix this well this is
343:52 - where we use what we call the unpack
343:54 - operator I believe or the Splat operator
343:56 - or something but essentially you can put
343:58 - star args star star
344:01 - quars like this and what this will allow
344:03 - you to do is accept any number of
344:06 - position or keyword arguments so
344:09 - essentially this says okay we don't know
344:10 - how many arguments are going to be
344:12 - coming in here there could be an
344:13 - infinite amount so rather than just
344:15 - trying to guess or figure it out or
344:16 - write a different rapper function for
344:18 - every single amount what we'll do is
344:20 - simply write star args star star quars
344:22 - which tells us except all of the
344:24 - arguments that are passed in except all
344:25 - the keyword arguments and what we can
344:27 - actually do is simply pass whatever
344:29 - these are to this function so let's do
344:32 - this here star star quarks so now what's
344:35 - going to happen is any arguments pass in
344:37 - we'll just automatically pass to F same
344:40 - with quars and if there's none we just
344:41 - won't pass anything so this kind of
344:43 - handles any amount of arguments and now
344:45 - we'll see that when we run this we don't
344:47 - get any error and this works fine for
344:49 - any number of arguments so even if I
344:51 - were to add you know X Y in here
344:53 - something like that and then we call
344:55 - this with like
344:56 - 56 and run that still same thing this is
345:00 - working doesn't matter how many
345:01 - arguments we have we're perfectly fine
345:04 - okay so that's good but what happens
345:05 - when we return a
345:07 - value from function 2 well what happens
345:10 - then so let's say x
345:13 - equals print X and right now so we can
345:16 - see that we're returning y from function
345:18 - 2 right but if I call this and I print X
345:22 - we don't get y return to us so how can
345:24 - we fix this right so what we actually
345:26 - need to do is since we're calling the
345:29 - actual function here inside of the
345:31 - wrapper we need to store the return
345:33 - value I'm going to store that as RV so
345:37 - that I can return it at the end of this
345:39 - wrapper function so since this wrapper
345:41 - function is returned from here this
345:44 - could return a value as well and well we
345:46 - don't want to return immediately so like
345:48 - I could just write the line return F
345:51 - like that and that would work fine but
345:52 - we want to do something after the
345:54 - function is called so to you know solve
345:56 - this we do RV and then we can return RV
345:58 - so store the return value of this
346:00 - function return it at the end and now if
346:02 - I print this you can see that we get our
346:03 - return value of six so that is how we
346:06 - return turn values that is how we pass
346:08 - in different amounts of parameters and
346:10 - now I'm just going to show you a few
346:12 - actual useful um decorator functions
346:14 - that you might want to use so you're
346:15 - probably looking at me like well what's
346:17 - the point of this right now like why do
346:18 - we have this well a good example is say
346:21 - you want to validate input say you want
346:23 - to have a bunch of functions that accept
346:25 - some numeric input and that numeric
346:26 - input is always going to be between the
346:28 - value 1 and 10 right rather than
346:31 - checking the parameters every single
346:33 - time inside of your function what you
346:36 - could do is you can use a decorator that
346:38 - checks them for you right and then all
346:39 - you would have to do every single time
346:41 - you want to validate that your input is
346:43 - correct is throw a decorator over top of
346:45 - your function that says validate input
346:46 - or whatever it's called Write the
346:48 - appropriate code inside of a decorated
346:50 - function and this these kind of
346:51 - functions like this and then you're good
346:53 - to go so that is kind of the idea behind
346:56 - decorators that you can modify the
346:58 - behavior of a function add functionality
347:00 - to it without modifying the code and
347:02 - sometimes you don't want to touch the
347:03 - code of a function because you want to
347:05 - make sure that you're not breaking
347:06 - anything you don't know how it's been
347:07 - written but you want to add something on
347:09 - top for example maybe timing how fast
347:11 - the function runs and this is a very
347:13 - common example I'll show you this as
347:15 - kind of our last example to using
347:16 - decorators um so yeah we'll do a timing
347:19 - one so essentially if I want to time how
347:21 - long a function takes to run every
347:23 - single time right then I can create a
347:25 - timer decorator so you know what
347:26 - actually let's do it from the start
347:27 - let's erase all of this um and do one
347:29 - from the beginning so I'm going to say
347:30 - Define timer which is the name of my
347:32 - decorator it's going to take in a
347:34 - function we'll Define a wrapper this
347:37 - will take STAR
347:38 - args uh star star quars like that again
347:42 - quar stands for keyword arguments what
347:44 - we're going to do here is start by
347:46 - importing time we're going to
347:49 - say uh let's say
347:51 - start equals
347:54 - time.time like that and then we'll just
347:58 - print started or actually we could do
348:01 - something else let's do this let's say
348:04 - uh RV
348:07 - equals Funk like that and then let's say
348:10 - end or guess we'll say
348:12 - total equals time. time minus start and
348:17 - then we'll
348:21 - print time like that and we can put
348:25 - total and then we will return
348:29 - RV and return wrapper like that oops I
348:34 - did not mean for those okay so now that
348:35 - we have that let's create function let's
348:37 - just say
348:38 - defined test and then here we're just
348:41 - going to say 4ore in
348:44 - range 1 th000 let's just say pass and
348:48 - there we go so now if I want to decorate
348:49 - this function I can say at timer and
348:52 - what this will allow me to do now is
348:53 - when I run this function have it tell me
348:56 - how long this took to run so let's go
348:58 - ahead and just actually call test like
349:01 - that and see it ran in 0.0 seconds so I
349:04 - guess this rounded for us but I guess
349:06 - would I be able to do this make it take
349:08 - any longer if I add any more zeros there
349:10 - we go so we can see that is how much
349:11 - time this function took to run and if I
349:14 - wanted to add timer on another function
349:16 - well then I could do another one say
349:18 - test two like that and we can even just
349:21 - say time do
349:24 - sleep why is my capitals on 2 seconds
349:27 - and we'll decorate this one with at
349:29 - timer as well and now when we call test
349:32 - two and we run this give it a second and
349:35 - we should see that this takes 2. o1
349:37 - seconds so this is how decorators work
349:39 - again useful when you want to modify the
349:41 - behavior of a function without actually
349:44 - touching it without changing it you can
349:46 - add other decorators on top of an
349:48 - existing decorator I'd urge you to see
349:50 - you know how that actually works how
349:52 - you'd be able to do that you can test
349:53 - that out for yourself but for now that's
349:55 - pretty much it and a really useful
349:57 - example of decorators is a timer
349:58 - decorator when you're debugging you want
350:00 - to check what is really slowing down or
350:02 - how long something's taking another good
350:04 - example is having a logging decorator so
350:07 - having a decorator that essentially logs
350:09 - the calling of functions or what's
350:11 - happening in the program that's a good
350:12 - one to add here and then obviously
350:14 - validating input and checking return
350:16 - values and stuff like that is always a
350:18 - good example of when you might want to
350:19 - use decorative so with that being said I
350:21 - hope you guys enjoyed if you have any
350:22 - questions as always leave them down
350:23 - below and with that being said I will
350:25 - see you in the next expert Python
350:26 - tutorial
350:31 - series hello everyone and welcome back
350:33 - to another expert Python tutorial so in
350:36 - today's video we're going to be talking
350:37 - about generators now generators are a
350:39 - pretty straightforward and actually very
350:41 - useful expert level feature in Python
350:44 - and chances are you've probably seen
350:45 - them before now before we get into
350:47 - generators I do need to quickly mention
350:49 - that this uh Series has been sponsored
350:51 - by kite so kite is the AI autocomplete
350:53 - for python that I've been using
350:55 - throughout this entire series and just
350:56 - through my daily coding you can see that
350:58 - when I actually start typing something
351:00 - we get these nice suggestions top um
351:02 - popping up from kite with the little
351:03 - kite icon here it is just the best
351:06 - python autocomplete it works very
351:07 - quickly and actually saves you quite a
351:09 - bit of time and works for other modules
351:11 - that aren't just built-in python things
351:13 - so it's pretty useful if you guys want
351:14 - to download it there's a link in the
351:16 - description and it's free so you know go
351:17 - ahead and do yourself a favor if you do
351:19 - want that auto complete okay so now
351:22 - let's get into generators now actually
351:24 - before I discuss generators I want to
351:25 - show you the problem that generators
351:28 - help us solve so we should understand
351:30 - that in our computer we have a finite
351:32 - amount of memory a finite amount of RAM
351:35 - and when we run a computer program our
351:37 - program is loaded into that memory and
351:39 - when we're storing things manipulating
351:41 - variables lists all of that that's all
351:43 - stored in our computer's memory that's
351:45 - because that is the fastest way for us
351:47 - to retrieve and write data while we're
351:49 - in a program you know we could put some
351:52 - things on a hard drive but that's pretty
351:53 - slow and it really depends on what we're
351:55 - doing but most of the time we're working
351:56 - in Ram and what that means is that we
351:59 - are limited to the amount of ram that is
352:01 - in our physical computer when we're
352:03 - writing a computer program and in fact
352:05 - you know most of us will never even see
352:07 - the error that I'm about to show you but
352:09 - it is possible to actually fill up all
352:11 - of ram right to use all of ram to have
352:14 - nothing left and in fact that's what I'm
352:16 - going to try to do right now so if we
352:17 - look at the example on the screen and
352:19 - I've just started running the code
352:20 - you're going to see this takes a second
352:21 - to run what I'm trying to do is generate
352:24 - the sequence of all of the squares from
352:26 - the number zero up until I want to say
352:28 - this is like 100 million or 10 million
352:30 - or some number like that right and then
352:32 - what I'm going to do is Loop over all
352:33 - those numbers and print them out and
352:35 - you're going to notice that very shortly
352:37 - yes and there we go we get the error we
352:39 - get a memory error which essentially
352:41 - means that no we can't do this these
352:43 - numbers are too big we don't have enough
352:45 - room left in memory we're not allowed to
352:46 - use that much space no that's not
352:48 - allowed so how do we go ahead and how do
352:50 - we fix this well this is where we use a
352:53 - generator now before I actually create a
352:56 - generator I want to look at something
352:57 - here if all I'm doing in this specific
353:00 - application is just printing or
353:02 - processing say one value at a time which
353:04 - is what I'm doing when i'm looping over
353:06 - this list right one value at a time I'm
353:08 - processing it I'm not accessing other
353:10 - values I don't need values that are in
353:12 - the future I don't need values that are
353:13 - in the past then is it really necessary
353:16 - for me to create a list like this to
353:18 - Loop through and the answer is no
353:19 - obviously right in fact what I could do
353:22 - is replace this for loop with just a
353:24 - print statement right so I could replace
353:25 - this entire thing actually we'll just do
353:27 - it down here so let say 4 I in range and
353:30 - then we'll just type that same number
353:31 - whatever that's close enough and then
353:33 - what I can do is print I the exponent
353:36 - two like that right and this is the same
353:38 - thing and this is the idea behind
353:40 - generators this is not what we're going
353:42 - to do precisely to generate this
353:45 - sequence but generators allow us
353:47 - essentially to look at one value at a
353:49 - time and to not store the entire
353:52 - sequence of numbers when we don't need
353:53 - to do that and I'm actually going to
353:56 - code out our own kind of generator
353:58 - pattern here that just uses a class and
354:01 - some Dunder methods to illustrate what's
354:03 - actually happening inside of a generator
354:05 - when we use it now I understand that
354:06 - most of you probably still don't know
354:08 - what a generator is but after I write
354:10 - this class and start showing you
354:11 - hopefully this should make sense so what
354:13 - I'm going to call this is just gen and
354:15 - what I want this to do is the exact same
354:17 - thing that we did before where it's
354:18 - going to generate a sequence of all of
354:20 - the squares up to some number let's say
354:22 - that number is ADD so in this case I'm
354:24 - going to say let's define uncore uncore
354:27 - nit uncore uncore let's take self Let's
354:30 - Take N let's say self. n is equal to n
354:34 - and then let's say self. l is equal to Z
354:37 - so this is going to be the last number
354:39 - that we generated the square for and
354:41 - we're going to use this variable to keep
354:43 - track of the last number we generated
354:45 - the square for so that we know which
354:46 - next number to use and I'll show you how
354:48 - this works we're going to define a
354:50 - actually in this case we're going to do
354:52 - a Dunder method so underscore next it's
354:54 - going to take self and what it's going
354:55 - to do is return self. next now I know we
354:59 - haven't defined self. next yet well
355:01 - we're going to do that now so Define
355:02 - next self and in here what I'm going to
355:04 - do is generate that sequence that I did
355:06 - before except I'm just going to do it
355:08 - using these two variables I'm not going
355:10 - to do it using a for Loop like we had
355:12 - before and storing everything in a list
355:14 - so what I'm going to say is RV equals
355:17 - self. last to the exponent 2 so this is
355:20 - saying our return value is going to be
355:21 - equal to whatever this last number is
355:23 - that we have to the power two right so
355:25 - we're going to find the square for that
355:26 - then I'm going to say self. last plus
355:28 - equal 1 we're going to say if self. last
355:33 - and in this case equals equals self. n +
355:35 - 1
355:37 - um actually what I need to do is sorry
355:39 - put this at the beginning of my Loop so
355:41 - if self. last here equals equal self. n
355:45 - then what we're going to do is say raise
355:46 - stop iteration stop iteration is just an
355:49 - error that we can raise that essentially
355:51 - tells us hey no we can't go any further
355:53 - and then what we're going to do is
355:55 - return this RV okay so now I'm going to
355:57 - show you how we can use this so this we
356:00 - can actually use in a very similar way
356:01 - that we were kind of looping through the
356:02 - numbers before and we're going to say in
356:04 - this case g equals gen let's say we want
356:07 - to Loop up to you know some massive
356:09 - number like that and now if I want to
356:11 - actually Loop through this entire
356:12 - sequence what I can do and I mean some
356:14 - of you are saying oh this isn't big
356:15 - enough okay let's go bigger we'll say
356:17 - while in this case true we're going to
356:21 - say
356:22 - try
356:24 - print the next value of G right and what
356:29 - this underscore uncore next is allowing
356:30 - me to do is call this next function or
356:33 - method or whatever you want to call it
356:35 - on G here here and we can print the
356:37 - value and then I'm going to say accept
356:39 - stop iteration and then we're simply
356:42 - going to break this Loop like that and
356:45 - we should actually be good with that
356:47 - okay so what this is going to do now is
356:48 - Loop and I'm just going to make this
356:49 - number smaller just so we can see that
356:51 - it does actually just go up to 100 um
356:53 - but I promise you this does work with an
356:55 - infinite sequence and we'll watch and we
356:57 - can see that this works just like we
356:59 - would have before and we can generate
357:01 - all of the squares for these numbers now
357:03 - I can make this number absolutely
357:05 - massive I can make it you know that's
357:06 - super long number and this will be
357:07 - totally fine and in fact that's because
357:09 - we're not storing all of this in a list
357:11 - where we're storing all of the previous
357:13 - values all we're keeping track of is
357:15 - kind of the internal state of the next
357:17 - number we need to generate and this is
357:19 - the idea behind a generator is that we
357:21 - don't need to store every single value
357:23 - what we can do is just store you know
357:26 - almost the last value that we generated
357:28 - and then using that we can generate the
357:30 - next one right or we can figure out the
357:33 - next number to generate and obviously
357:35 - this kind pattern like you can write
357:37 - this if you want but what python has
357:38 - done for us is kind of come up with a
357:40 - pattern that makes this a little bit
357:41 - easier called the generator pattern so
357:44 - what I'm going to do now is pretty much
357:46 - take this class and I'm going to convert
357:47 - it to a generator and I'm going to show
357:49 - you how this works so I'm going to say
357:51 - Define gen and here this will just take
357:53 - the value n what I'm going to say in
357:55 - here say for I in range and in this case
357:59 - we'll say n then we're going to say
358:01 - yield I to the exponent 2 now I know
358:05 - this seems weird but it's essentially
358:06 - the way that this works is we instead of
358:08 - using this crazy pattern that we had
358:10 - before we're going to use the yield
358:11 - keyword now what the yield keyword does
358:14 - is as soon as we hit this it returns
358:16 - this value to wherever this was called
358:19 - from or wherever we were looping through
358:21 - and then it pauses this function so
358:24 - rather than stopping the execution of
358:25 - this function which is what a regular
358:27 - function would do when we hit the return
358:29 - keyword it just pauses it which means we
358:32 - actually keep track of what I was so we
358:35 - still know what that number is we still
358:37 - know you know what n is we still have
358:39 - all of the internal information of this
358:41 - function stored in memory we haven't
358:42 - gotten rid of that but we're just
358:45 - pausing when we hit this yield keyword
358:47 - that's what that means so think of yield
358:48 - as like a pause whereas for example
358:51 - return would be a stop of execution so
358:54 - we can use this generator by doing
358:56 - something like this g equals gen give it
359:00 - some number like this and then what we
359:02 - can do is say 4 I in G and then what we
359:05 - can do is simp simply print out I now
359:08 - this is going to work the exact same as
359:10 - all of the other examples I've seen I've
359:11 - shown you before and you can see that
359:13 - indeed it is working and we could run
359:15 - this you know infinitely and we're not
359:16 - actually going to ever run into a
359:18 - problem and in fact I probably should
359:19 - have made this number a little bit
359:20 - smaller because I feel like this is
359:21 - going to run for a long time but anyways
359:23 - that can go down there so this is the
359:25 - point of a generator and I know some of
359:26 - you are still confused but the way you
359:28 - have to think about it is we create this
359:31 - generator by creating this function gen
359:33 - with uh what do you call it you know
359:35 - 100,00 th000 or whatever it is whatever
359:37 - this number is 1 million and then what
359:39 - we can actually do is Loop through this
359:42 - and what happens when we Loop through
359:43 - this is it runs this for Loop up until
359:46 - it sees this yield keyword so it sees
359:48 - this yield keyword I to um squared right
359:51 - and then as soon as it sees that what it
359:53 - does is it pauses the function and says
359:55 - okay we don't need to run this anymore
359:57 - and then it waits until it's called
359:59 - again so until we Loop through it again
360:01 - with this for Loop the next method on it
360:03 - is called and then it returns to us the
360:05 - next year and because it's pausing
360:07 - rather than stopping execution this is
360:10 - totally fine and in fact we can actually
360:12 - look at how much memory this function is
360:14 - using versus if we were to do the same
360:16 - thing say with a list and we'll do that
360:18 - in a second but I want to show you that
360:20 - to use this generator I don't have to
360:23 - just Loop through with a for loop I can
360:24 - use that next method that I showed you
360:26 - before and if I do nextg and I run this
360:29 - you can see we get zero because
360:30 - obviously the first answer is zero and
360:32 - if we do this a few times we get zero
360:37 - 149 so this is how this works when we
360:40 - call the next method or the next
360:42 - function on our generator we get the
360:44 - next value so essentially up until it
360:46 - hits the next yield keyword and in fact
360:49 - we actually can use more than one yield
360:51 - keyword in our gen if we want and I
360:53 - could say yield one uh and we could do
360:56 - as many yields as we want so let's do
360:59 - this and then let's actually show what
361:02 - happens when we go past how many yield
361:04 - keywords we have so if we look at get
361:06 - this here we can see we get 10 100 1,000
361:09 - 10,000 and then we actually end up
361:12 - getting an error and there was a one up
361:13 - here just so you can see and that error
361:15 - is actually a stop iteration error right
361:17 - here because we don't have any more
361:19 - keywords yield inside this generator so
361:22 - there's nothing more to return so this
361:24 - works the exact same way that I showed
361:25 - you with that class that I did before
361:28 - where it keeps track of the internal
361:29 - state it knows what line it was on when
361:31 - it paused and then it goes to the next
361:33 - one until it hits the next yield keyword
361:35 - and that's when it pauses again and
361:37 - that's how a generator works and they're
361:38 - pretty useful there's some other things
361:40 - that we can do with them and in fact
361:42 - I'll show you um comparing the size of
361:44 - say a generator like the one we just
361:46 - created versus actually generating an
361:49 - entire list you can see in memory how
361:50 - much this is actually using so if we
361:52 - want to generate the sequence right we
361:54 - know this generator works we can use
361:55 - that now so let's run that and what I'm
361:58 - going to do now is import Sy I'm going
362:01 - to actually make that list that I did
362:03 - before so we're going to say x equals
362:05 - and in this case we'll say I to the
362:08 - exponent 2 for I in range and we'll just
362:11 - do uh let's say 10,000 like that and
362:14 - we'll replace 10,000 Here and Now what
362:16 - I'm going to do is just print out the
362:18 - size of both of these so I'm going to
362:19 - say
362:20 - sy. get size of and in this case the
362:24 - first size we'll look at is X which is
362:26 - that list and then we'll get the size of
362:29 - G and I'll show you the difference in
362:32 - memory so what this does is tell us how
362:34 - many bits or actually I believe how many
362:36 - bytes are being used by whatever object
362:38 - is we pass in so in this case the list
362:40 - and in this case the generator and
362:41 - you're going to see that we have a
362:42 - substantial difference so this first
362:44 - list is using 43,81941
363:05 - need it one at a time which is what
363:07 - we're doing when we say Loop through
363:08 - something then it's much better to use a
363:11 - generator to generate this sequence for
363:13 - us now there's a lot more that I can
363:15 - show you with a generator uh we can
363:18 - close a generator we can stop a
363:19 - generator we can send values to a
363:21 - generator but I'm going to leave that
363:23 - for people that are a little bit more
363:24 - advanced the point of this is to
363:26 - introduce you to this concept of the
363:28 - generator whereas when you're
363:29 - programming think about say if you're
363:31 - going to make a massive list like this
363:33 - with a bunch of values do I need of
363:36 - these values am I using one value at a
363:38 - time am I looping through am I printing
363:40 - it am I adding it to something or do I
363:42 - only need say the last value and this
363:45 - value or a few values and obviously you
363:47 - can make your generators more
363:48 - complicated than a simple for Loop you
363:50 - can do some more complex computations
363:52 - you can store variables inside of here
363:54 - because remember that this yield keyword
363:56 - just pauses the execution when this
363:58 - generator is called and what that means
364:00 - is that I can Loop through this this
364:02 - first generator say you know five times
364:05 - and then somewhere later in my program
364:07 - continue looping through it and it will
364:09 - you know resume where it left off and
364:12 - that's a useful kind of construct it's
364:13 - hard to show any examples in this you
364:15 - know short amount of time but hopefully
364:17 - this gave you an idea of when you would
364:18 - use a generator so with that being said
364:21 - I hope you guys enjoyed if you did make
364:22 - sure you leave a like subscribe to the
364:24 - channel and as always let me know if
364:26 - there's any other expert level features
364:27 - you would like to see in the comments
364:29 - down
364:33 - below hello everyone and and welcome to
364:36 - another expert Python tutorial so in
364:38 - today's video we're going to be talking
364:39 - about context managers now context
364:42 - managers are definitely one of the more
364:43 - useful topics that we're going to be
364:44 - talking about or that we have talked
364:46 - about so far and you'll find yourself
364:48 - using them a lot especially as you get
364:49 - into more advanced programming and
364:51 - dealing with things like shared memory
364:53 - and shared resources and unlocking and
364:55 - locking and yeah it just all those kind
364:57 - of things contact managers come in very
365:00 - handy essentially now I'm actually
365:02 - almost certain that all of you have seen
365:04 - context managers before in fact I'll
365:06 - show you a few examples here of times
365:08 - when you've used them and just not known
365:10 - that you've used them and that's kind of
365:11 - a common Trend here that I'm hoping you
365:13 - realize is a lot of the stuff that we're
365:14 - using it's not completely new to you
365:17 - it's not something you've never used
365:18 - before you just never really understood
365:20 - how or why it worked and that's what the
365:22 - point of this Series has been is to give
365:24 - you that appreciation and understanding
365:26 - of how these lower level things work so
365:28 - that you have more control over your
365:29 - code and if you need to change them or
365:31 - write your own versions you now know how
365:33 - or at least have the intuition to do so
365:35 - now again this video is sponsored by
365:37 - kite a big thank you again to them you
365:39 - can see whenever we start typing we got
365:40 - these little kite keywords popping up
365:42 - it's just a really good auto complete
365:44 - and again it's free if you want to
365:45 - download it it's from the link in the
365:46 - description you can find that okay so
365:48 - let's go ahead and get started with
365:49 - context managers now the first thing
365:51 - that I want to do is show you what
365:53 - problem context manager solved to us so
365:55 - I'm going to start or solve for us so
365:57 - I'm going to start by showing us the
365:58 - problem and then the solution with a
366:00 - context manager so essentially let's say
366:02 - we have some file and we want to we want
366:04 - to open a file right so want to open say
366:06 - file.txt we'll open it in right mode
366:09 - which just means create a new file if it
366:10 - doesn't exist yet and then what we'll do
366:11 - is say
366:12 - file. write let's say hello and then
366:16 - we'll say file. close okay pretty
366:20 - straightforward pretty basic this will
366:21 - work run this code nothing wrong with it
366:24 - but what actually is wrong with what I
366:26 - just wrote well looking at this at a
366:28 - surface level it seems like everything's
366:30 - totally fine I mean we've opened the
366:31 - file we've written one line to it in
366:33 - this case hello and then we've closed it
366:35 - now the issue occurs in this code if
366:38 - this line here so this file. right line
366:41 - doesn't work or it doesn't happen for
366:43 - example like if I just error this line
366:45 - by putting line X here and then we run
366:47 - this we can see that we don't make it
366:50 - down to this file. close line because we
366:53 - had some error on this right line so say
366:55 - we open the file and we start trying to
366:56 - write something happened something else
366:58 - had the file open we couldn't access it
367:00 - well now we've opened the file and we
367:03 - haven't closed it and that's an issue we
367:05 - need to make sure whenever we open a
367:07 - file or have some shared resource that
367:09 - we work with that we close it afterwards
367:11 - now a better example would probably be
367:13 - if I open this in read mode um as
367:16 - opposed to write mode because that would
367:17 - mean that this file already exists on
367:18 - the system but hopefully you get the
367:20 - point that the issue occurs when we open
367:23 - the file we do a bunch of stuff and we
367:25 - don't reach that file. close so the
367:27 - point is how can we make sure that we
367:29 - reach this file. close no matter what
367:31 - happens in between the open and in
367:33 - between the close well the way that we
367:36 - could do that is we could use a try and
367:38 - a finally statement right so we could
367:39 - leave what we have right here and we can
367:41 - just add a try like that and then we
367:43 - could add a finally uh down here if we
367:47 - indent that properly for the file. close
367:49 - so what this means is regardless of if
367:51 - this works or not we will eventually or
367:54 - finally close this file so that's good
367:56 - and we've just kind of fixed our area
367:57 - there and that's totally fine but
367:59 - there's an easier and better way to do
368:01 - this that allows there a little bit more
368:03 - functionality and what that is is a
368:05 - Conta text manager now this code right
368:07 - here is completely equivalent to what
368:10 - I'm about to write so with open file.txt
368:13 - we'll open in R mode again we'll call
368:16 - this as file to be consistent and we'll
368:19 - just simply say file. WR and in this
368:22 - case Hello so these two kind of blocks
368:25 - so this block up here and this block
368:27 - actually do the exact same thing and the
368:29 - way that this works is this open method
368:32 - here actually defines what we should do
368:35 - when we use it as a context manager when
368:37 - we exit and when we enter so when we
368:40 - enter what that means is okay when we
368:42 - open this file when we write this code
368:45 - what's the first thing that needs to
368:46 - happen well the first thing needs to
368:48 - happen is we need to open the file and
368:50 - we need to return that so we can store
368:52 - that as the file object that's the thing
368:53 - that's happening when we enter this
368:55 - context manager and we can tell we're
368:57 - using a context manager because we're
368:58 - using the with keyword and that's the
369:00 - most common way and kind of the only
369:02 - examples I'm going to show you here is
369:03 - using the with keyword in pth
369:06 - then what we do is we do something
369:08 - whatever we have inside here we could
369:09 - print something we could you know fil
369:11 - out right we could do a for Loop doesn't
369:13 - matter and then when this is done so all
369:15 - of the code in here regardless of there
369:17 - if there was an exception or not we will
369:20 - call the exit method and what the exit
369:23 - method does is some kind of code that
369:25 - allows us to close our file properly and
369:28 - make sure that everything works so
369:29 - essentially the context manager is kind
369:31 - of like a hidden way to make sure that
369:33 - whenever we do one operation we do
369:36 - another one regardless of what happens
369:38 - in between and again that's really
369:40 - useful for things like opening and
369:41 - closing files and for locking and
369:43 - unlocking shared memory so now I'm going
369:45 - to show you how we can actually write
369:47 - our own context manager that does the
369:49 - same thing that we've just shown here so
369:50 - we have this open F function and we say
369:52 - with open file. txtr as file file. WR
369:57 - hello we understand that after this runs
369:59 - regardless if there's an exception or
370:01 - not we close the file but how does that
370:03 - actually work well let's try to do that
370:05 - so what I'm going to do now is I'm just
370:06 - going to make a class and we're going to
370:08 - write this context manager so I'm going
370:10 - to say class file I'm going to say
370:12 - Define nit and since we just want to do
370:14 - the same thing we did before we're going
370:16 - to take a file name and a method in our
370:18 - nit and we're going to say self. file
370:21 - equals open file name method now it's
370:25 - important to note that when we make a
370:27 - context manager we don't necessarily
370:29 - need to use it as a context manager all
370:31 - the time in fact I'm going to start
370:33 - writing a context manager here and show
370:34 - you the methods we need to implement to
370:36 - do that but right now you know the
370:38 - function that we have here we can use
370:40 - this fine even though you know it's
370:41 - going to be a context manager we can
370:43 - instantiate it and we can use it as we
370:45 - usually would we just aren't going to
370:46 - call these special methods that I'm
370:48 - about to wct so we have the first method
370:50 - which is called enter now remember enter
370:52 - I told you is the first thing that
370:54 - happens and what this function needs to
370:56 - do is return to us some value that we're
370:59 - going to use in the context manager
371:01 - right when we wrote for example with
371:03 - something um as you know F then this
371:07 - something is going to call this enter
371:09 - method so we're going to store
371:10 - whatever's returned from enter in F so
371:12 - that's what we should get there so here
371:14 - what we're going to do on the enter is
371:16 - simply return self. file and again that
371:18 - should be the open file object then what
371:20 - we're going to do is Define an exit
371:23 - method so underscore uncore exit uncore
371:25 - uncore and notice these are special
371:26 - Dunder methods because they're going to
371:28 - be called in a special way automatically
371:30 - from python because we're going to use
371:32 - the context manager syntax so here
371:34 - actually takes three arguments and the
371:36 - three arguments or parameters I guess we
371:38 - have our type I believe we have I'm
371:40 - going to look to make sure I haven't
371:41 - messed this up we have value and then we
371:45 - have Trace back so essentially what this
371:48 - does is regardless of whether or not we
371:51 - get an exception between when we open or
371:53 - so between when we enter and between
371:55 - when we exit if we get an exception it's
371:57 - actually going to call this exit method
371:59 - with that exception so that we can
372:01 - handle the exception in here the way
372:02 - that we would like and I'll talk about
372:04 - how that works a little bit more in a
372:05 - second but let's just do what we wanted
372:07 - to do which is self. file. close so for
372:10 - now we're actually going to omit the
372:12 - fact that uh we're going to deal with
372:14 - these parameters although we'll talk
372:15 - about them later so in here I'm actually
372:17 - just going to write some code um some
372:19 - print statement so that we can see what
372:21 - happens when we enter and when we exit
372:23 - these methods so print enter print exit
372:27 - so now what I'm going to do is I'm going
372:28 - to set up the same thing I did before
372:30 - except this time instead of saying with
372:31 - open I'm going to say with file and the
372:34 - reason I'm allowed to do this is because
372:36 - I have this enter and exit method
372:37 - defining that this is a context manager
372:39 - and I'm going to say with file we have
372:41 - let's say you know file.txt let's put
372:45 - that in say read mode um actually we'll
372:48 - put it in write mode and then we'll put
372:50 - that as F we can say f. write hello as
372:55 - the classic example that we've been
372:57 - using and now let's actually run this
372:59 - code and let's look at these print
373:01 - statements and make sure this works okay
373:03 - so we get enter and exit and inside here
373:06 - I'm actually just going to put a print
373:07 - statement that says middle just so we
373:10 - can see how this works so even though I
373:12 - have it explicitly called this exit or
373:14 - this enter method we can see that they
373:16 - do get called so enter middle exit and
373:19 - they get called in the appropriate
373:20 - timing right so this stuff happens in
373:23 - between the enter and the exit and now
373:25 - what I'm going to do is simply put an
373:27 - exception in here so I'll say you know
373:28 - put some letters here just to make sure
373:30 - this crashes let's run this um and
373:33 - actually sorry that's going to be a
373:34 - syntax see if there's any way that I can
373:36 - get this just to crash uh let's just say
373:39 - raise exception like that and now let's
373:42 - see if we still get um all right yes we
373:44 - do so we can see we get enter middle
373:47 - exit and then we get the exception
373:48 - raised afterwards even though we raised
373:51 - the exception before we got to this exit
373:53 - method so what this essentially says is
373:55 - regardless of if there's an exception or
373:57 - not we're going to call this exit method
373:59 - and the point of this is so that we can
374:00 - actually handle an exception inside of
374:02 - our exit method if we need to so I know
374:04 - this is kind of confusing to see in my
374:06 - Trace down here because there's all this
374:07 - text but look what's happening right we
374:09 - can see that in line 17 an exception was
374:12 - raised but the thing is we still called
374:15 - this exit print um and we still closed
374:17 - the file even though that exception was
374:19 - raised which again is the advantage of a
374:21 - context manager okay so what I want to
374:23 - do now is show you what this type value
374:26 - and Trace back actually is so we notice
374:29 - that what happens is essentially any
374:31 - exception that's raised inside of here
374:33 - actually gets sent to this a exit
374:35 - function where it can be handled and
374:37 - that's why we see this exit popping up
374:39 - here because we enter we do this middle
374:42 - stop some exception was raised in the
374:44 - middle that's fine so we immediately go
374:46 - to this exit function where we pass that
374:48 - exception and we wait to see if it gets
374:50 - handled and that's why all of this code
374:52 - in the exit function runs before we
374:54 - decide that we're going to crash the
374:56 - program or that something's going to
374:57 - happen so what I'm going to do now is
374:59 - show you how we can actually handle an
375:01 - exception inside of this exit function
375:02 - and again what type value and traceback
375:04 - are
375:05 - so now we'll keep printing exit but
375:08 - we're also going to print all of the
375:10 - different values that are here so we'll
375:11 - just use an F string and we're just
375:13 - going to do a bunch of commas so that we
375:14 - can see what all these are so type value
375:18 - and in this case Trace back so let's run
375:20 - this now we're still going to get a
375:21 - crash in our code but now we can see
375:23 - that we have class exception none and
375:26 - then a trace back at some location so if
375:29 - we wanted to we could look at this
375:31 - traceback we could look at the type of
375:32 - the exception and we can actually handle
375:34 - it and in fact the way that we handle an
375:37 - exception from our exit is if we
375:39 - determine that this exception is fine
375:41 - that we shouldn't crash the program that
375:43 - all is good what we're actually allowed
375:45 - to do is return the key value true so if
375:49 - we return true from this exit method
375:52 - here that's going to tell python that we
375:54 - gracefully handed handled this exception
375:57 - which means we don't need to crash the
375:59 - code we don't need to run or you know
376:00 - see all this Trace back in the output
376:02 - here we're fine and we're good to go and
376:04 - in fact if I run this you can see that
376:06 - by simply adding this return true here
376:08 - we no longer get a crash in our program
376:10 - and everything is fine now be careful
376:12 - with this because you don't want to just
376:14 - add return true if there is actually
376:16 - exceptions and they need to be handled
376:18 - properly in fact a better practice would
376:20 - probably be to do something like if type
376:23 - equals equals and then whatever type of
376:25 - exception you were looking for maybe I
376:27 - raised like a file not found exception
376:29 - or something and we were looking for
376:30 - that specific one then what you could do
376:32 - is handle that exception inside of here
376:35 - and then return true in that instance
376:37 - and in fact this still works because the
376:38 - type was exception um but I'm trying to
376:41 - see if I can raise like yeah so let's
376:43 - say file um exists error like let's do
376:45 - something like that and run this and you
376:47 - can see now because that wasn't just a
376:49 - regular exception this crashed because
376:51 - we didn't handle that properly so that's
376:54 - how we can handle errors inside of this
376:56 - exit function you just return true if
376:59 - when you check through this error that's
377:01 - passed in here um you get you know some
377:04 - valid stuff and can handle it right and
377:06 - if you don't return true and there's no
377:08 - error like we've seen that's totally
377:09 - fine so if we don't raise some exception
377:12 - regardless of if we return true or not
377:14 - everything works fine and we're good to
377:16 - go and that is one of the massive
377:17 - advantages of context managers okay so
377:20 - now I'm going to show you how we can
377:21 - actually create the same context manager
377:24 - because this seems a little bit
377:25 - complicated using a generator so we've
377:27 - talked about generators and we talked
377:29 - about decorators what we can actually do
377:32 - is import something called context lib
377:35 - so we can import context lib like that
377:37 - and from Context lib there's actually a
377:39 - decorator in here that allows us to
377:42 - decorate a generator that becomes a
377:45 - context manager and I'm going to show
377:46 - you how that works okay so let's do the
377:48 - same example we did before with opening
377:49 - a file but now using a different kind
377:52 - well not really different kind but just
377:53 - a different way of creating this uh
377:56 - context manager so what I'm actually
377:57 - going to do is I'm going to write this
377:59 - decorator and The Decorator is context
378:01 - li. context manager like that there's no
378:04 - brackets at the end and in fact what we
378:06 - could have done is said from Context lib
378:09 - like this import context manager and
378:11 - this is a built-in library in Python and
378:13 - that will just allow us to do this
378:15 - rather than having that um dot
378:17 - beforehand so let's do that I'm going to
378:19 - say Define file like this and what I'm
378:22 - actually going to do is take again the
378:24 - file name and the method and inside here
378:27 - I'm going to say okay file equals open
378:31 - and in this case we'll say file name
378:33 - method then I'm going to yield cuz again
378:35 - this is a generator the file object and
378:38 - then I'm going to file. close so what
378:41 - this means essentially is that the first
378:44 - thing we're going to do is say file
378:45 - we're going to create this file object
378:47 - we're going to yield this to wherever
378:48 - we're being called from and then when
378:50 - this function resumes again you can
378:52 - think of this as the enter right and
378:54 - this as the exit we're going to close
378:56 - the file and in fact in here again we
378:58 - can handle some exceptions we can do
378:59 - things like that and this is a quicker
379:01 - easier way to actually make a context
379:03 - manager so now I can say with file and
379:07 - in this case let's just say you know
379:09 - what what have we been doing I don't
379:10 - know let's just say text.txt let's
379:12 - switch it up here let's go W mode and
379:15 - we'll say as F and we can say
379:18 - f.r let's say hello like that and if we
379:21 - run this code that's perfectly fine that
379:23 - works and now when we add our print
379:24 - statement so we'll say
379:26 - print uh enter like that and we'll
379:30 - print exit like that and then we can
379:32 - print middle and we can see how this is
379:34 - is actually working okay so enter middle
379:38 - exit so this decorator allows us to turn
379:41 - this generator object into a context
379:43 - manager it works pretty much exactly the
379:45 - same as I talked about before there is
379:47 - more to go in and kind of dive in with
379:49 - this uh this syntax right here I
379:52 - typically recommend to people just to
379:53 - use the class syntax just because it
379:55 - allows you to do some more things into
379:57 - something more people are familiar with
379:59 - but if you want to use this context
380:00 - manager decorator and do some things
380:02 - with this generator kind of syntax um to
380:05 - use a context manager you're more than
380:06 - welcome to and that's why I showed you
380:08 - so I think with that I'm going to wrap
380:10 - the video up here an interesting idea
380:13 - though if you guys want to mess around
380:14 - with context managers is to think about
380:16 - locks in threading so actually from the
380:18 - threading module in Python I can't
380:19 - remember the syntax right now off the
380:21 - top of my head you can have shared
380:23 - memory um and you can have locks and
380:26 - yeah like memory locks which essentially
380:27 - allow you to wait for another resource
380:30 - to give up this lock so that you can
380:32 - access a resource so the point is like
380:34 - say we have one variable X here that's
380:36 - going to be accessed by two different
380:37 - threads well we can't access and change
380:39 - X at the same time so we create a memory
380:42 - lock and what one thread will have to do
380:44 - is wait for that lock to be available
380:46 - before it's able to access the object
380:48 - and you can actually implement this
380:49 - functionality with a context manager so
380:52 - that your threads you make sure they
380:54 - unlock the resource before they finish
380:56 - changing it so that's something that's
380:57 - interesting if you want to mess with
380:58 - that I don't really have that much time
381:00 - in this video so I'm not going to do
381:01 - that um but yeah so with that being said
381:04 - this has been context managers I hope
381:05 - you guys enjoyed if you did make sure
381:07 - you leave a like subscribe to the
381:08 - channel and as always let me know if
381:10 - there's any other expert level features
381:11 - you would like to see

Cleaned transcript:

hello everyone and welcome to the complete python course this course is designed to teach you everything you need to know about the Python programming language this is going to assume you're a complete beginner you have no knowledge of python and bring you through right from the beginning all the way up to expert and advanced level features so this course is actually a combination of a bunch of videos that I've created over the past few years it starts with beginner Python Programming goes to objectoriented programming then into intermediate and advanced level features so those are the four main section of this course it's kind of split up in those four sections and within those sections there's a bunch of topics now if you want to figure out what section to jump to or you want to see what's involved in the course look in the description there'll be a bunch of different timestamps that show all of the different topics that are covered and feel free to skip through and go to the ones that you find the most interesting so with that being said this video is taking a very long time to compile and create so I would appreciate if you guys leave a like you subscribe and you consider becoming a channel member if you want to support me on a monthly basis so with that being said let's go ahead and get into the full python course hey guys so welcome back um today I'm going to be doing a Python tutorial Series so this is the first episode in the series it's kind of an introduction showing you how to download python how to install it and then going into data types and variables so the first important thing to understand about the Python programming language so don't worry if you've never programmed before um I'm going to be going over everything very slowly and in depth so that you can understand I recommend that you follow along with everything I'm doing in the tutorial uh pause the video at certain points rewind if you don't understand um it's important you understand these parts so that we can move forward into more complex ideas so obviously the first um thing that we're going to have to do if we're going to learn python is we have to install it on our computer so uh we're just going to go to the python website up here python.org downloads right here and all you're going to do is just click download python 3.6.1 now I'm not going to do that because I already have python installed and downloaded on my computer but pretty much once you uh download this it's going to pop up down here in your downloads folder just run the exe it's very simple um and you'll be running python in no time so now pause the video go ahead and do that and then we can go to the next steps okay so once you've done that you're going to notice that you have an application that looks like this it's called idle um Python and then it'll have the version so I'm using version 3.5 um don't worry if you have a version that is larger than that so 3.6 or even one that's before that most of the things that I do in this will work in all the versions of python okay so go ahead and run the idle you'll notice the first thing that pops up is the python shell as you can see at the top here the shell now this right here is not where we're going to write all our programs it's the console kind of so here I can type any lines of code for example I want to print a name like this and it'll run right away so that's not what we're going to do you can play around with this if you want but we're going to go to file and we're going to click new file and then here we go so now we have a new document that we're going to be working on and we're going to be programming in so I'm going to go ahead and I'm going to save this right away as tutorial one into my tutorial folder which I believe is on my desktop right here yep right there awesome okay so there we go we've saved it and now we're ready to learn a little bit about data types so pretty much python is a fairly basic language in comparison to a lot of other ones a lot of things that it does is uh more simple than other languages but it is important to understand the basic data type so there's four main data types in Python there is a few more but we're just going to talk about these ones right now um the first one is an integer so that can be uh a short form int that stands for integer now um an integer is any number so such as 1 4 76 any whole number it's important that is a whole number it could be a negative number as well5 um zero those are are all integers okay now we have strings now the short form for Strings is St now pretty much a string is anything embedded in quotations so like this uh this is my name Tim that is a string and then we also have something like this this would be a string and even like this this would be a string so although there is a number in here since it is between these two quotations here it is a string so even if I did another number like like that string um now it's also important to understand that it doesn't matter if you use the single quotations or the double quotations sometimes we use the single quotations because inside of our actual quotations we want to use double quotations or maybe um if we use the double quotations because we want to use the single quotations inside of our actual string like that okay so those are just a few examples um now we have Boolean variables uh or data types sorry so Boolean data types is something like true and false so true and false pretty basic um these are reserved words in Python um meaning that they're highlighted in yellow and that you cannot use them for variable names that's going to be important later on um just know that they are important words uh true and false and they do start with capitals so um for example if I typee true like this uh it's not highlighting Orange right so that's because true um in Python the keyword for that starts with a capital so true and false um then we have the um decimals which are the float uh data type like this so anything with a decimal floating point so 1.23 um anything like that any decimal number with a floating decimal point uh would be a float okay so those are the four basic um data types um there is a few more that I'll go on to later on but you just have to understand these ones right now so now that we know these data types I'll give a quick little quiz here so I'm just going to put a few things right here and then I want you to pause the video and go ahead and try to determine what type of data type these things are okay so go ahead pause the video and then I'll go over the answers in a second okay so we'll start with the first one here uh hello it's the same example that I have up here except in single quotations so we can see that it is a string data type okay so that is the short form Str Str now we have the number 123 that would be the integer data type we have another number here that has a decimal point so 3.22 that would be a float we have the keyword true this data type is a Boolean data type then we have two in quotations this is very important we don't want to get this mixed up this is a string some people may think that it's an integer because it's two but no it actually is a string because it is inside of the quotations and then same thing here three inside of the double quotations again is a string not an integer okay so now that we have an idea of the basic data types um I'm going to show you how to create a variable so pretty much you may have heard of variables before in math or something like that um in math we tend to use X as a variable we say x may be five x may be four anything like that um it's the same thing in Python now declaring a variable in Python is very easy all you have to do is type the variable name so in this case I'm going to use name and then simply give it a value so this value as you may remember is a string this is my name and I'm just storing it in the variable name now if I want to access that variable I want to see what that variable is I can print it to the console by simply typing the variable name which is name so now we'll see what happens um if I run the program just going run run module I'm going to use F5 from now on so that's the uh thing and you can see it prints out Tim just like that okay now um say we did that we have name equals Tim we printed it to the screen now maybe we want to change that variable well it's very easy again all we have to do is just type the value name and now maybe we're going to change it to Bob and now we want to see what the new VAR new variable is so we will print it to the screen we'll print name cck F5 to run that and we'll see name and or sorry Tim and then Bob so like we have here name equals Tim print name name equals Bob print name right so we've set it like that okay so that's pretty basic um now you can create variables of different data types so for example if we had a variable age I would use an integer data type so like 18 for that variable and then again if I wanted to print into the screen I would type print and then the variable name like that okay 18 perfect right so we printed that to the screen um again if the variable names um there's a few restrictions on variable names so here you just see I've used three lowercase letters um your variable names can contain underscores um they cannot contain dashes um they can only contain underscores text and they cannot start with a number I believe so if I try to do one one name equals 2 for example I run into an invalid syntax error because we can't name a variable starting with a number now I can end it with a number I believe let us try yep so that's fine it's let us do that name equals one I could do name underscore um person maybe yeah namore person you see if I run that program everything's fine there um but I can't put something like a star in my variable name you see how we've got an invalid syntax there right this is because these symbols represent something else in the Python language so just know for names um we can use capitals if we'd like I could use name like that run the program that works fine but I cannot start it with numbers so I cannot put a number there um and I cannot contain anything other than underscores texts and numbers in or at the end of the variable name now here's a quiz for you if I make a variable called name and do another variable called name um are they the same thing now that's a good question um are these two the same thing um no they are not the same thing so capitals do matter in Python the all capitals variable name is different than the variable name so again name like this is different than all of those variables there okay so I think I've covered um a little bit on variables and data types today um this is the complete Basics just wanting to get everyone caught up um in the next video we'll go into some more advanced things maybe uh operations of variables adding them together subtracting multiplying um buing conditions things like that okay so I hope you enjoyed the video today um stay tuned and we're going to have another one out tomorrow um and like the video if you if it was good and subscribe so yeah thank you hey guys so welcome to the second video in the series um if you remember in the last video we talked about data types and variables uh we went briefly into some of the things that python can do um today I'm going to be talking about operators and we're going to be doing some print statements some input um a little a few small console applications just applying some of the knowledge that we've learned so pretty much the first thing I want to do is I want to go back and I want to review what we did in the last lesson very quickly so we talked about variables and data types so for example the X variable we could set it to something equal to two like that uh a name we may equal to our name right so I make that equal to Tim um so there we go we have the name right there equal to 10 we'll start with that okay now if you remember in the last one I didn't talk about this but I used something called print now the print statement pretty much takes an argument so inside of these brackets the thing that is inside that brackets is called the argument so it takes a uh a string argument usually so I will give it the name so now you'll see again we did this in the last one just want to review I'm clicking F5 simply to run the program when I go to the console it simply puts Tim onto the console just like that right okay um very basic we already did that so now let's say well we want to do something else so let's let's print here and we're just going to put a string and we're just going to type this in ourselves so let's say hello comma what is your name that's going to print to the console now we want to get what the user's name is now there's a way to do this in Python it's very simple we're going to make a variable name it makes sense to put the variable name here and do an equal sign because it's a variable right we're going to type the word input just like this now what's going to happen if I run the program here I'll show you is it's going to say hello what is your name and it's going to actually allow me now to type into the console which I couldn't do before now nothing happens after when I click enter because we don't have anything else after that but it's allowing me to type okay so now well we want to print out what the name is that was said so let's just simply type print and then name all right and we have hello what is your name I say oh well my name's Tim it says Tim all right now well we just printed out the name but maybe we want to go a little more advanced than that we want to say well hello Tim how are you doing Tim something like that right so I'm going to just put a comma here going to separate these two things and I'm going to put in a string and I'm just going to type what I like to type so I'm going to say hello with a comma and then you see that I have this other comma here that is outside of the quotations meaning it's not a string it's actually just separating the two arguments in here and you'll notice what happens now when I print is it goes hello what is your name so I say oh my name's Tim it says hello Tim right so that's pretty straightforward I hope that's easy to understand we're just using the input to get an input and then we're printing it back out to the screen okay so let's do um let's go into the next part of this now we'll use that again later but let's talk about operators so operator that term may sound familiar to you um in math uh we use things called operators so these four operators hopefully should look familiar to you um this is a plus sign this is the addition operator we have the minus sign which is the subtraction operator the division sign which is the well division operator and then the multiplication sign which is again the multiplication uh operator so there's a few more operators that we'll talk about but these are the four basic ones in Python now you remember how I talked to you about data types this is where this comes in when we use these operators it's important that we use them on certain data types so for example um in math I could do something like 3 + 4 right so what is 3 + 4 equal well that is equal to 7 so the computer can actually do that math operation by using that operator to return those values so let's let's give an example here quickly so I have uh let's do num one we're going to use variables here uh remember I can use a number in the variable as long as it's not at the beginning and I'm going to give it a value of 45 and then we'll do num two and we're going to give it a value of three now if I want to print to the console um let's say num one plus num 2 well you can guess what that's going to give us it's going to give us 45 + 3 I hope if this is not an error yeah so that gave us 48 right so oops didn't mean to make that full screen num 1 plus num two is 48 all right so now what about minus let's try this 42 basic um we can do multiplication here with the multiplication sign there we go 135 and then we'll try again with the division sign just to show you all of them we get 15.0 like that okay so that's pretty straightforward um those four basic operators now in Python there's a few more operators that we want to talk about now for example in math we have something called exponents right so how do we do exponents in Python well it's actually two stars is how you do an exponent all right and now maybe there's something called integer division um which I'll get into later but I'll just show you the operator for it right now it's two slashes that means uh I'll give you an example a math example here 64 / by um let's do 10 um would give us usually in math a value of 6.4 right that's if you use one division sign sorry what am I doing times I mean divided by would give us 64 I have 6.4 but now if we do two division signs here like this it actually gives us a value of six that's because it just um it doesn't worry about the remainder at all it just tells us um how many times 10 can go into 64 um and that's all it can go in six times evenly so it gives us a whole number as our answer that's called integer division this double double slash like this okay and then we have another operator which is actually the modulus operator um so this is the percentage sign and this gives us the remainder so here if I do five 5 modulus 2 then the remainder of that is actually 1 because 5 / two is four then with a remainder of one right so it's not going to give us the decimal points it's again just going to give us the remainder if I did five / by four again the remainder is one 5id by 3 the remainder would be two like that okay so that's what the modulus sign um gives us so we'll put modulus here and then there's probably a few others that I'm forgetting about but we can go into those later so now um same thing let's keep using our number variables here and now let's introduce a third variable called num3 now um I want to show you how we can use the variables so num one and let's see if you remember what this operator is uh so that's the exponent operator so that means num one which is going to be our base uh which is 45 raised to the power of four because we're going to use num two and we can print num three press okay and you can see we get a pretty large number um that's because of how exponents work and then same thing here if we want to do maybe integer division see what we're going to get we get 11 right a whole number and then say we want to do modulus we get one okay so now let's tie all these things together with the operators that we've used the variables the prints and the inputs so um let's start by just get doing a little print statement and saying pick a number okay pretty basic we're going to pick a number and then we're going to take the input so we're going to say num one again is equal to the input of that okay so we got the input in Num one um now let's say print pick another number all right so now we're going to pick another number so we're going to do num two is equal to input like that and now what we're going to do is we're going to introduce our third variable so we'll call it sum because we're going to add these is equal to num one plus num 2 and now actually you can't use sum because it's a reserve word so let's just do in all capital sum because remember how we talked about variables capitals and lowercase are different and then we're going to print to the console the sum like that okay so we run the program says pick a number uh let's pick a number let's say four and let's do 32 now what do you think it's going to be oh oops okay so yeah someone equal num one plus num two okay so this is why um I talked about data types so I'm actually uh Happy this happened it's because what actually happens when we get the input of something is it gives us the type of a string um which in this case is not what we wanted to do so um you saw there I'll run it again um it's a good mistake that this happened actually we have four and we have a three and it gave us 43 that's just because we added the string four to the string three um so that simply gave us 43 but now we know in actual math that 4 + 3 equal 7 so if we want to do um the integers we have to actually convert these variables into integers so in order to do that remember I showed you the keyword um int like this before we're just going to put brackets around our two variables here like this integers and now hopefully we should get the correct answer when we do four and we do three and you can see we've got seven so um I didn't mean for that to happen originally but I'm happy it did because it shows us why data types are important so when we take the input of something we're typing it from the keyboard and that is actually a string so um here we can print again um don't worry about what I'm doing right now but I just want to show you the type which is going to give us if it's a string if it's an integer of num two just to show you what the type actually is so we pick a number we pick two and we pick three it tells us that three is actually a string so that's why when we added originally three and two or two and three or whatever it was um it gave us just them added together so two and three rather than what it should be which is five okay now same thing here if we had a number and we wanted to convert it into a string all we would do is we would type Str Str around the number so for example three and then that would give us three just like that so A String so now we've kind of gone over a conversion of variables um conversion of numbers data types how to get input from the console using the input like this um and some basic operators of python so uh review this I hope you followed along and then in the next next lesson we'll move into some more advanced operators and we'll maybe start with conditions okay I hope you enjoyed uh please subscribe like the video and I'll see you in the next video hey guys uh welcome back to the third video in my Python Programming tutorial series um today we're going to be talking about something called conditions so I hope you remember from the other videos we talked about input printing we did variables data types and then we talked about operators so operators like plus minus um division integer division modulus right uh multiplication all those operators today we're going to be talking about a few more operators and then getting into conditions so here in my file right here um I've put down four basic comparison operators so pretty much a comparison is something that's going to return a value of true or false so here we have um let's say if a real world example is Tim equal to Joe well no they're not because Tim obviously spelled differently than Joe so that's going to be giving us a value of false um same thing if we want to go into numbers we say 18 is greater than two well is that true yes it is so that condition gives us a value of true uh it's a very simple concept but it's something that we have to understand as we go into decision Visions later on which will be in the next video okay so these comparison operators I'll read them off and just kind of give a definition of each of them so the first one can e be a less than or a greater than sign uh same thing with the second one right so it's just going to compare if something's less than greater than um usually these are used for integer values um that data type uh we also can use them for Strings but it's a little more complex and I'm not going to get into that right now maybe in a more advanced tutorial later on now the equivalent operator so the equal sign here now a lot of people think well if I'm comparing something why wouldn't I just use one equal sign like this well that's a very good question and a lot of people get mixed up on this it is actually two equal signs that's because in Python um the one equal sign is a declaration um declaration operator so for example if I put a variable X and I want to set it equal to four right um this is is what we do with the one equal sign we're setting values right so when we did name is equal to Tim things like that we're using one equal sign now if we're going to check something we're going to compare them we have to use two because two equal signs and one equal sign have a very different meaning so it's important to keep that in mind that the comparison operator for equivalency is two equal signs okay the next one is not equal to um so we have an exclamation mark and then we have the equal sign like this okay so an example of not equal to because some people may get confused here is say if four not equal to 5 oops what did I type there not equal to 5 okay so what do you think this would give us just think about it for a second well what it's actually going to return to us is true because the condition is if four is not equal to 5 and here we can see obviously four is not equal to 5 so now again if I give another example we put five here we say five not equal to 5 well that would return a value of false because five is indeed equal to five now we can do the same thing with strings so for example we have hello oops spelled incorrectly there we go and Tim uh now you can probably guess by yourself that this is going to return true because him is indeed not equal to hello okay uh it's pretty straightforward um but a lot of people may get mixed up with the not equal to if it's returning true or false okay so those are the four basic comparison operators that we're going to use so we have equal to U not equal to and then greater than and less than so greater than and less than again we use for numbers so one less than two again that's going to return true like that okay so now um we're going to start printing from some things to the console and maybe doing a little bit of a quiz here um just to see how you guys are going to do so a booing condition I'm going to store it in a variable so I'm going to say name uh oops actually we're not going to do that we're just going to print to the console 2 less than three okay now you guys guess and uh tell me what you think is going to be returned to the console it's either going to be true or false I'll give you a hint right now now it gives us a value of true that's because this condition 2 is less than three um is true it's equal to three right um so now if we switch the sign and we make it greater than like that well you can guess what's going to come up so we click enter and we get false that's because this condition returns a value of false okay now we'll do another condition here all right um hello equal to Hilo okay um and guess yourself what this one's going to return false okay that's because they are spelled differently um now we're going to do the not equal sign just to show that one as well hello not equal to hello and we'll see that gives us true because they are not the same um fairly straightforward but a lot of people do get these things mixed up now I'll show you what happens when I try to just do one equal sign like this see we get keyword can't be an expression that's because we're trying to declare a variable here but we cannot do that okay because we're just using one equal sign here we need to use two all right okay so now let's try another example maybe a more advanced one uh this is a little bit of a trick okay I want to see if you guys remember from my last tutorial what I talked about so take a guess right now what you think is going to be returned you think it's going to be true or do you think it's going to be false well it was false okay um that's because again what we talked about in Python um capitals matter right so any capital letter is different than a lowercase letter so something like this um yeah it's going to return false all right it's important to understand that okay so we' very briefly uh gone into conditions now um I'm going to write a few on the side here you guys can go ahead um I'll put them in print statements and test yourself and see if you get them right or not okay I'm going to add a few tricks from the other lesson um try to kind of apply some of our knowledge and see if we can get them correct okay so just give me a minute here I'm just going to write a few out and then we'll go through the answers afterwards okay so you know what we'll just we'll just do these ones for right now and we'll do a few other examples okay so these are a little more advanced than what I was talking about before but they are conditions we have a left side of the condition and we have a right side of the condition so I hope you've taken a guess now of what you think these are going to be cuz I'm about to print out the answer right now Okay so we've gotten true false and false all right so for the first one two less than three that's an example I already gave that gives us a value of true because that condition is true uh now we have two 3 + 4 greater than 5 um so you can do the math there and see that that is going to be false and then this one some people may have gotten a little bit of a little bit confused on cuz I actually use the words false and true in my condition that's going to return false or true so I have print false equals equals true well is false the same thing as true no it's not so obviously we going to be returned with the value false Okay so we've talked a little bit about conditions now um in the next tutorial we're going to be doing something called decision so I'll give you a sneak peek on what that is something like this okay so stay tuned for that um the next episode should be up tomorrow um and yeah I hope you guys enjoyed the video go ahead like And subscribe and yeah share with your friends thanks bye hey guys guys uh welcome back to the fourth video in my Python Programming tutorial Series today we're going to be talking about decisions so we're going to be using the if else and L if statements in Python so pretty much I gave you a little example last time on what these are but if condition equals true then do this sorry not his do this okay so pretty much the syntax for the basic if statement which is what we are going to cover first is like this so if you remember my last tutorial I talked about conditions if you haven't seen that go back and look at that first because that's going to be an important part of today's lesson and you have to understand that so if condition is true then we are going to do this now let's just dig into the syntax a little bit here um so you're going to start with the keyword if then we're going to put a condition so the condition could be something like this if 1 is less than two if tree is equal to plant something like that okay anything that can return a true or false value you can use variable names you can say if x is equal to Y anything like that is condition and it uses a conditional operator like I talked about in the last video and then you are going to end your condition with a semicolon or sorry not a semicolon like this with a regular colon and then you going to Simply click enter and it should tab you in one line now it's very important that you have this indentation um if you have your code like this it's not going to work python reads the lines because of indentation so it's very important that you have whatever statements you want to run after the condition returns true indented properly and this will also be very important as we move further on in different tutorials and we have have lots of different indentation levels within the program okay so let's do a real example now instead of uh this kind of pseudo code here so we'll start off by just getting some input from the user so let's say let's get their age okay so age is equal to input like this and then just if you put something inside of the input like this uh it actually gives a prompt to the user so we'll say input your AG like that and then we will say if the age is equal to 16 then we will print to the screen hey your oops 16 like that okay um all right so let's go ahead and just test it out right away I know I haven't really explained it but I just want to show you how this works okay so we have input put your age so I'll say two as my age and we can see that nothing happens okay um now I want to show you one more I hope you've caught this trick already from what I talked about in the last videos but we'll see now you notice here I'm going to put in 16 and nothing's going to happen now the reason for that is because 16 here is different than the 16 that we get from age if you remember whenever we're getting a number or anything from the console we actually get it as a string so this 16 that we're getting actually looks like this now in Python again we have different data types right so this is an integer data type well this is a string so when we're comparing integers and strings um they're different so we have to convert our age variable into an integer before we can compare it like that okay now we'll try again say if int age equals 16 so now we put 16 in and says hey you're 16 like that okay um perfect so that's pretty straightforward um now we can also do some other conditions so let's do a greater than 16 now okay so this is another conditional operator that we talked about before um and yeah we'll go ahead we'll try it now so we'll say 15 now nothing happened because obviously 15 is not greater than 16 now if we put in 17 it works okay great um all right and also uh I just want to show you there's another operator that we didn't talk about last time a conditional operator and it's the greater than or equal to and the less than or equal to so to convert your um greater than sign into a greater than or equal to sign all you have to do is add an equal sign like this and now anything greater than or equal to 16 will work whereas before it had to be strictly greater than 16 and same thing with the less than sign like that okay uh I just forgot to talk about in the other video so I figured I'd put it in here all right um great so let's go into another example then so let's say um it's great it's telling us we're 16 um or let's in this case we're going to be older than 16 right so hey you're older than 16 but what if we want to message when we are younger than 16 well the way to do this is using something called an lse statement so the Syntax for this uh it simply has to come after an if statement you can't just leave your own else statement like this that will not work it has to be after an if statement is placed and then all you have to do is put a call in and click enter and make sure the indentation is the same as the indentation for the first if okay so now we're just going to print you are younger than 16 okay and we can go ahead we can try this to see if the else is going to work and we say well we're 15 and you are younger than 16 great okay um so just to explain this a little more how this really works when we're reading through the code well python reads code line by line like this now when it reaches this if statement it checks this condition to see if it is true or false so since this condition um was false in the last example we say if false it says Okay so we're not going to run this line of code we're going to skip to the else statement and we're going to do this okay so if we had typed anything in that does not return true so makes this condition not return true then it would go to this else statement like this okay um yeah and then same thing say we type in a number 17 um and that is greater than 16 it's not going to do the L statement it's just going to do the if statement okay um I hope that makes sense now we're going to go into another layer okay so let's get into a new example here um let's talk about height for a roller coaster okay so for some roller coasters uh you have to be taller than a certain height and you actually can't be too tall right so again we'll get the input from the console so we'll just say height is equal to input and we're just going to do this in meters like 1 meter 2 meter 3 meter just to make it really easy okay I know that's not a realistic height but just for the purpose of this example so we say height is equal to input um again we have to remember that when we're going to check the condition we have to make sure we put it in the int because as we get it from the console it's going to be a string okay so we'll say if height is less than 1 M we're going to say you cannot ride so we're going to print to the screen you cannot ride okay now we only want to allow the user to ride if their height is in between 1 M but less than 2 m okay so as you can see I've introduced a new word here called L if all right so this means if this condition up here is false then we're going to go to this one we're going to check if this condition is true or false if it's true we're going to run whatever's in here um otherwise we're going to keep going so you can have as many l ifs as you possibly want um in a decision statement like this okay um you can only have one else though because else is just the default so anything you type in um that doesn't equal any of these statements so like if isn't true Al if isn't true the other L if isn't true then it'll go to the lse statement okay so L if the height is so if it's less than one you can't ride and if it is greater greater than two you also can't ride so we're going to say you cannot ride I'm going to say and we'll say over 2 m and then we'll put here just so we can distinct them under one meter okay and then now we're going to add in the lse statement like this and we're going to say print you can write okay so I know I just did a lot there so we'll go through it quickly we pretty much have a condition up here we already talked about the if statement so if this condition is true we're going to print this and we're going to skip everything else we're not even going to bother reading it because we know that it's not going to be any of those conditions okay so now we do the L if here right so we say well if this condition is false we're going to go ahead and we're going to check this condition so we say oh well this one's true so then we're going to execute this line of code which is the print and we're not not going to do this else statement now say we go through these two and they're both false okay so this returned false and this return false then we're going to go to the else and we're automatically just going to print whatever is in the else statement like that okay so we'll go ahead uh we'll run the program and we'll try it out make sure I haven't made any errors here okay so the input um I didn't give a prompt so I'm just going to type in the height uh a number all right so we'll say one you can ride great okay um that is because again we have the strictly less than sign now if we wanted it to be you have to be over one foot we just put an equal sign here and then same thing here okay so we'll do that and now I'll show you again if I put in one you cannot ride under 1 meter okay so less than or equal to one right okay um let's try again now we'll do it maybe a number greater than two so let's say put four it says you cannot ride because you are over 2 m and then again if we do like a decimal number maybe uh 1.1 Okay so we've run into an error there that's fine just because we can't convert a floating decimal point into an integer but yeah I hope you get the point from that example here um these are just the basic if L if and L statements I'll do one more just to show you here we could do another L if here saying for example um if in height is equal to remember we do two equal signs right not one then we're going to say print while you are tall okay so as you can see we can do infinite elf State L if statements like this and we can only have one lse statement and one if statement at the beginning okay uh so we'll run this one just to show you one more time how this works I'll put in five so five uh you cannot write over two 2 m okay so that's because what actually happened here is we went if we checked this condition now it turns out that um five is greater than two so we did this one and we didn't bother reading the rest now if I wanted to change this uh so that it would check the five first all I would have to do is put this LF statement I'll do it right now above the other L if statement like this and now if I type in 5 it'll work wow you are tall okay so uh that's it for the if L if and L statements um in the next tutorial we're going to go into something called chain conditionals and do some more advanced examples of this we're going to do some addition subtraction and some more things with other operators okay so I hope you enjoyed um please don't forget to like And subscribe the video and I'll see you again tomorrow in another video hey guys uh welcome back to another video this is the fifth video in my Python Programming series and today we're going to be talking about chained conditionals and nested if statements um so pretty much chained conditionals are just adding multiple conditions in one uh one line with using words like and and or okay uh we also have keyword not that we're going to talk about as well so if you haven't seen the last videos in my series go ahead and get watch those now because they are prerequisite for this video all right so let's get right ahead and start um so if you remember before we have something called conditions so for example if we have the variable X I'll set that to two and the variable Y which is equal to three we could have a condition like xal equal y now obviously we know from the last video that this is going to give us a value of false oops and I cannot type today sorry um and that is because two is not equal to three pretty straightforward I hope you have all understood that from the last video all right so what we want to do in this now is we're going to want to check multiple conditions um so we'll put a condition here so if x is equal to Y and then we can put a word in like this the and word um now we'll add another condition so if x + y is equal to 5 Okay so this first condition is going to give us a value of false so if x is equal to Y because they are not the same but now x + y does indeed equal 5 so that is going to give us a value of true so where I'm highlighting we have true and then where I'm highlighting now again we have false so because we have the keyword and this if statement is not going to run so I'll put a print here just to show you we're going to print out true or let's just say ran and you'll see when I run the program nothing is going to happen happen that is because when we use the and keyword it means both conditions on either side must be true so if we change this to something like if Y is equal to 3 now that is going to be true and we'll print out ran okay so that's pretty basic now let's do the or keyword so we'll put or right here and we'll change this condition back to if Y is equal to X and now take a guess on what you think is going to happen well pretty much with the or keyword it means either of the conditions have to be true so if Y is equal to X or x + y is equal to 5 then we are going to run this line now since X+ y does equal 5 we have a true here and again Y is not equal to X so we have a false and you'll see that the program is going to run that's because only one of the condition conditions has to be true for it to run okay so that is the and in the OR keyword they are pretty straightforward and pretty basic now I'd like to point out that you can actually add as many conditions as You' like so now I can have an or I can have an and um I could have another condition I could do as many as I'd possibly can imagine as many as I'd like to do um so now we'll put an lse statement in here and we'll change this just a little bit to use another keyword we'll just put a side face here to show that we didn't run it that we ran the else okay um so now there's something called the not word okay so we're going to put not right here around it and then I will show you what it does so pretty much not reverses anything that you have inside of the brackets of the knot so in here we have if Y is equal to X or x + y is equal to 5 so we know again that this gives us a value of true um so now since true is inside of the KN true becomes false now we have if false um so obviously that's going to bring us to the else statement um which is going to print the sad face so I'll show you that that does indeed work so we have the sad face right now if we change these so that both of these conditions are false you'll see that we have false false um which is going to give us an overall value of false um and then we're going to have the not which is going to change that into a true and will allow us to run it just like that ran um um so yeah so that's how the not the and and the ore work uh and now let's get into nested Loops or sorry not nested Loops Nest nested if statements so we'll do a basic if statement here if x is equal to 2 um if Y is equal to 3 um and then we'll add our El's like this and we'll put some print statements in here okay uh just give me a second while I type out the print statements and then we will go into what this is going to do x = 2 and Y = 3 um so you may have guessed already but pretty much we can actually add as many if statements embedded or nested as we'd like so I could add another if statement here and just constantly keep checking um now the reason I showed you chain conditionals is because if I didn't want to go through the hassle of adding all of these uh nested statements I could just do an and right here and check for another condition but sometimes we do want to do uh nested statements so we'll say here x = 2 y does not equal uh what is it three okay so uh I know I just did that pretty quickly but let's walk through it now so we have if x is equal to 2 then we're going to run whatever is in here because it is indented uh so now we come in here and we say well is y equal to 3 let's say it is now we're going to print out this statement and we're going to be done with this loop with this uh bit of codes we're going to skip down to the end of the program where we have nothing else um then so let's say we do another example X is equal to 2 but y equal 4 so that means we're actually going to run the else which means now we've got print X is equal to 2 but y does not equal 3 and then the last case is X is not equal to 2 so we don't even bother checking if Y is equal to 3 we just go down and we print X does not equal 2 so we'll change around the variables and we'll show you how this works just very quickly so we can see X is equal to 2 and Y is equal to 3 that is because obviously up here two and three now if I want to change Y and we change it to four we get X is equal to two but Y is not equal to three so that means we ran this one in here now let's change it so that X is equal to 4 as well and we can see we get X does not equal 2 all right so that's uh the basics on nested statements and chained conditionals I hope you found this video helpful um stay tuned for more videos we're going to be getting into some more advanced topics and in the next video we're going to be covering Loops um yeah so if you like the video uh please subscribe and like and I'll see you in the next one hey guys welcome back to another video this is the sixth video in my Python Programming series and today we're going to be talking about for Loops again if you missed the other videos in the series please go back and watch them first as it's going to be hard to understand if you haven't seen them already Okay so let's get right into it today we're going to be talking about four Loops um and a loop is a new thing now if you're a beginner in Python and I'll talk about how they work we're going to start off by just writing one out um getting right into it with the syntax so 4X in range and then we're going to put a number which is going to be our starting position so in this case I'm going to put zero um and then a stop point so 10 okay and then we're simply going to print out X now I know we did this pretty quickly but let's talk about what this is and the syntax so a for Loop is going to run a certain amount of times so in this case we're going to start at zero and we're going to go to 10 this means the for Loop is actually going to run 10 times so what's going to happen is we are going to have our variable X which is right here and every time the for Loop runs X is going to be increased by one now we can increase it by more if we'd like to by adding another comma here but by default it is set to one like this I've just put it in so that you can visualize it so really we have something start a stop Oops stop and an end start stop step sorry my bad and I'll just put commas here to show you how it works so you can see we have our zero that's our starting number our stop which is 10 and our step which is going to be one so I know you don't quite understand yet but you will after I show you a few examples so we have X is our variable which is going to be holding the number um of what iteration we are through now iteration uh just means how many times we've already looped through this Loop okay so let's uh do an example here all right so we have X and we've just started running this for Loop now right now X is zero we're going to print X we're going to print zero to the screen and then we're going to add one to X now this time we come through the loop we say well is X less than 10 yes it is so now we're going to print x x is one now we're adding um two okay so now X is 2 is 2 less than 10 yes 2 is less than 10 so let's print two okay and we keep going until eventually we print nine then X has one added to it so it becomes 10 well 10 is not less than 10 so we're not going to print out 10 all right I know I just talked a lot there but let's see it in action all right so just like I said we print out the numbers 0 through 9 now this may seem weird um because I have the value 10 here so you'd say well why doesn't it print out 10 it's because of the way the loop works so like I said really what's Happening Here is this um plus equals 1 so pretty much this means we're just adding one to the variable X um you can also write it like this x = x + 1 like that all right so we print out X and then we add one to X and we have to be less than 10 for this Loop to run so on the ninth iteration we have well 9 is equal to 9 + 1 so X is equal to 9 + 1 uh we get the value 10 now again 10 is not less than 10 so we are not going to print out 10 um yeah so that's pretty much how a for Loop Works um it's pretty basic this is the syntax we have four and then a variable name so this doesn't have to be X we could use anything we'd like to use could use hello I could use um any other word it could be as long as I want as short as I want doesn't matter um then we have the word in which is highlighted in Orange and then range now the range takes a different amount of arguments pretty much an argument is whatever is inside this brackets so like at the beginning how I showed you we just did zero and 10 this means we have a start and we have a stop so we start at zero and we go to 10 now I can also I can actually put one argument in here like this 10 and that just means that we just have a stop so by default python will say well we're just going to start at zero and we're going to step by one now I haven't showed you the step yet so we'll do that um so again we're going to start at zero we're going to stop at 10 and we're going to step This Time by two now what step is is how much we add to X every time so before I showed you we had x = x + 1 um in this case since the step is is two it's going to be by two like that okay um so let's go ahead let's run this we have 0 2 4 6 8 and you notice how we again do not print out 10 because 10 is not less than 10 okay again uh we'll do another example with the step let's put five in this time now you can guess what's going to happen 05 it actually only prints out two things because we start at zero so we print 0 and then we add five we get five now 5 + 5 again is not less than 10 so we are not going to print out 10 okay so that is the tutorial on the for loop we're going to do another type of for Loop where we're going to use something called a list a little bit later on but right now we're just using this one this is the basic one I encourage you to play around with it yourself um and yeah so if you like the video please go ahead and like it and subscribe and I will see you again for another video thanks goodbye hey guys welcome back to the seventh video in my Python Programming Series today we're going to be talking about wow Loops so in the last video we talked about for loops and before that we talked a lot about conditions um so it's going to be important to understand those things before we can move on today to this video so if you haven't seen those videos go back in my channel and check those out first okay so let's get right into it today we're going to be talking about while Loops so let's first of all just put an example down and get the syntax okay so we have while condition then we are going to do what is ever is inside the loop so it seems simple enough um but they can get fairly complex um so well condition is equal to uh true so for example this condition here this could be a variable um well that is equal to true then we're going to do whatever is inside of this Loop so again we keep talking about conditions um they're very important in Python we really need to understand them before we can move into more complex topics okay so uh well condition equal to true we're going to do whatever is in this Loop so how does this really work well uh pretty much what happens is we have the W Loop here we have the condition so this is true this means we're going to do this now what happens is we actually come back up to the top after we've done this and we say well is this condition still true um well yes it is so that means now we're going to do this again and we just continuously do this until eventually the condition is equal to false or we have a keyword appear called Break like this now I'll do an example so we can understand this but this is just the basic syntax we have while we have a condition and then we have a colon followed by an indented block which will be whatever is going to run okay so let's start off by using a variable we're going to just call it loop we're going to set it equal to true now we're going to make our while loop we're going to say while loop um Now by just putting a loop here it defaults to say while loop is equal to false um putting Loop there is the exact same thing as typing this um it's just shorter to put Loop instead of doing the equals equals true okay we're going to get some input from the console so we're going to say name is equal to input and then I'm just going to put in here uh insert something okay and then we're going to put an if statement which we talked about in another video so if you haven't seen that go back and check that out we're going to say if name is equal to stop um then we are going to break out of the loop by typing break or we could also do this we could set the condition equal to false so we set the variable up here equal to false now I know I just typed a lot there so let's um talk about what really is going to happen so we have our condition we say while loop is equal to True um right now we set it equal to True up at the top so it's going to automatically run at least once now we get input from the console um and store it in the variable name now we have a basic if statement here that pretty much says if name is equal to stop well then we're going to stop the loop um and we're going to break out of it otherwise we're going to keep asking the user for to insert something until eventually they type stop so let's see how this all works okay so insert something I say one 123 it didn't like that once me insert something again I say we okay what about hello keeps going okay now I'm going to type stop and you see that the program stops running okay so again I'll show you that we can do this by just setting the variable equal to false same thing again if I type hi keeps going I type stop it's going to stop and then maybe if we get rid of the variable here we can also just type in the word break like that and same thing again if I type in some random things and then I type stop it stops okay so pretty much the way that the break keyword works is by simply saying okay are we inside any Loops right now um it checks whatever Loop you're inside so right now we're inside the while loop and it says okay well I've this line has now run so what we're going to do is we're going to get out of the loop so it pretty much will now start reading from the next blank line in the file um meaning that it's going to get out of this Loop um and just continue going down the program okay and that's pretty much it for Wow Loops we can talk a little bit more about why we would use a w Loop instead of using a for Loop um the reason we might use a w Loop is for something like this so for example if you want to ask someone to insert a password so we have password like this um and we'll just change this variable with password so pass for short um and now maybe we wanted to check we wanted to say um well oops well let's just do password because pass is a keyword in Python I forgot about that um password and we want to make sure that the password has for example at least one letter in it well we're going to keep asking the user to reinput their password until it meets these certain criteria so for example it might have to have one Capital it might have to have one letter in it uh it may have to have a few numbers something like that right so we would keep asking the user for a password um until they gave it to us correctly now the reason we wouldn't use a for Loop for this is because a for Loop um usually we know how long we want to run the for Loop for um that's why we put a number in the range so for example we put 10 or we put 12 while as a w Loop we don't know how long we're going to run it for so for example someone could get the password first try like they could put it incorrectly um with the right criteria or it could take them 30 tries right we don't know how long it's going to take them okay so that's it for today's video um if you like the video please like it and subscribe and I will see you again tomor tomorrow with a uh new video hey guys guys welcome back to the eth video in my Python Programming Series today we're going to be talking about lists now lists can be fairly complex uh but they are a very important part of python and they are very important to understand so a list is another data type so before we talked about strings integers booleans and floating decimal points so floats um and today we're going to talk about list so lists again are their own data type so let's just start off by doing an example right now so pretty much uh a list which is denoted by the square brackets here uh is a collection of different data types it could be the same data types or it can be different data types so for an example I'm going to put a apple in here in my list I'm going to put a comma and I'm going to add another item so maybe we'll put a pair and then maybe we'll put a number as well okay so we have the list fruits and in the list we have three items um now everything here separated by a comma is known as an item so for an example our apple is an item our pair is an item and the integer three is an item now you can see that they're all different data types or sorry there is different data types we have two strings and we have one integer value um now this is fine you can store um different data types in one list um okay so now let's just print the list to the console so we can see what it looks like print it out and you'll see we simply get what exactly what we we've typed uh into the idle so we get apple pair and 3 now if we want to access an individual item in the list we need to do something um a little different so right now we just printed out the whole list but say we want to just print out pair um now what we're going to do is we're going to use the square brackets so we're going to do the list name so fruits and then we're going to put square brackets right beside it no spaces and then inside of the square brackets we're going to type in what's known as the indic of that item um so the way indices work in Python is when you create a list everything is automatically assigned in indic um so in this list we have indices 0 through two now it may seem weird that we start at zero instead of one but that's just the way that computers count um and the way that they work so we have to understand that apple is going to be assigned the integer value of zero so the indic zero meaning I would put zero in here if I wanted to access Apple because that's the first element in our list and then we have pair so that's the second element or item um now that's actually going to be represented by one here so fruits one will give us the value of pair and then fruits two will give us the value of three um now this is uh sometimes difficult for some people to understand but just really try to remember that the first item always is zero so if you would like to access the second item in your list you're going to type in one um into to the indic thing here okay so I'm just going to run this and show you how this works and you see we get pair okay that's because um we have the first indic which represents the second item which is pair okay um now there's some other things we can do with list as well so if we want to add something to our list there's a few ways that we can do it um the first way uh which is the only one I'm going to show you right now is probably the easiest and simply what we're going to type is fruits followed by the dot uh so a DOT a period and then we're going to type a pend okay now this means to add to the end of the list so inside of a pen I'm going to put the element or the item that I'd like to add so say we want to add uh another fruit let's think of another fruit that we could add maybe a strawberry okay we want to add strawberry into the list I'm just going to get rid of three so it makes more sense okay so right now in our list up here we have fruits which is a variable name um containing the list that has Apple and pear now we want to add strawberry to the list so let's start off by printing the list before we add it so we'll print off fruits and then we're going to print fruits one more time after we add this item to the list and you see we have the first list which is what we defined originally and then when we added or appended strawberry to the end of it it added it in just like this so that is a way that we are able to add things into a list um by using dot append now there is another way um it's known as the slice operator using something called insert um but we're not going to do that right now we're going to talk about the slice operator in a later tutorial so stay tuned for that okay so fruits. append we've added strawberry um now if we wanted to add another item we could do the same thing and we could do append again and we could put in another fruit maybe we want to put in a blueberry okay just like that and again we'll see that it does the same thing we have apple pear and then apple pear strawberry blueberry okay um all right so that's it for adding to the list um now what about changing something in our list uh so let's just add right here at the beginning we'll put in Strawberry so we have three items and now let's say we want to change the middle item in our list to a different fruit say we don't like pairs we want to remove it we want to change that so what we're going to do is we're simply going to type the um the name again so fruits followed by the square brackets and then the indic of the item you want to change um so again remember if we want to change pair we're going to use the Indy one um not two because this is the way that it works we're going to use one and then we're going to change it to whatever we'd like to change it to so say I want to change it to Blueberry I can do that like so and then again we can print out fruits and we'll see if it works okay so we get apple blueberry and strawberry that's because we''ve changed uh the item at indic one into blueberry and we've replaced that we replaced Paar with blueberry pretty much okay um so that's how that works for list for changing items again um we you lists are very useful for storing large amounts of information so this is a very small list but in many programs we use something called multidimensional list uh which I'm going to talk about again in another tutorial um and yeah so one more thing before we end it here uh there's another data type called a tuple so a tupal um it's kind of hard word to pronounce but it's used for coordinates and it's also used um for things like colors and rectangles um it can also be used just to hold information as well but it's a different type of data type um than a list so we're going to talk about it quickly uh okay so a tuple pretty much looks like this so if we set a position and we set it equal to something like this not in square brackets in the regular round brackets and then we simply put um the items in like this now we see we get um it looks very similar to a list the way that it works again we can use different data types so I could put something like hello in here as well well um but it does function a little differently and again things like colors we would also store in a tuple so we would use like 255 255 255 that's simply white in uh red green blue colors and again if we print out the type of the color you can see that we get a class tupal okay so I'm not going to go too in depth with the tuples here I just wanted you to understand what they are because we may be using them in some later tutorials okay so I hope you learned how to use lists and a little bit about tups today they're going to be important in the next tutorial um so yeah I hope you enjoyed if you did please like And subscribe and I will see you in the next video hey guys welcome back uh today we're doing the ninth video in my Python Programming series and today we're going to be talking more uh more about for Loops so a more advanced type of for Loop in terms terms of iterating through a list so you may remember a few videos ago we talked about for loops and I mentioned that there are two main type of for Loops that we can use um and the one that we talked about there was looked like this so we had for X in range and then we had a range like this and we simply printed out the numbers like this so we see we got 1 to 10 just like that okay uh so that was the for Loop we talked about there um but the one we're going to be doing today is is a little bit different so I'll leave this here for an example uh so the first thing we need to do is we need to make a list because we're actually going to be iterating through every item or every element in the list so again I'm just going to use the same example I used in the other video fruits and I'm going to make it equal to we're going to have apples pears and strawberries strawberries just like that okay so we have our fruits here and now um we're going to get right into the syntax for this new for Loop so we're going to do four and then any variable name we'd like so in this case I'm going to use fruit and then we're going to use the keyword in once again and then instead of typing range this time we're going to type the name of the list we want to iterate through so in this case it's going to be called fruits just like that and now um we can print out the fruit sorry the fruit just like that so pretty much what is going to happen is we have a list with three items in it we have apples pears and strawberries now we want to print every fruit in that list so we do that by saying for fruit in fruits meaning for every item in fruits so one two and three items we simply want to print out that fruit so this Loop is going to run three times and we're just going to print out every fruit inside of the list just like this and there you go we have apples pears and strawberries just like that um so yeah that's pretty much how you can iterate through a list and same thing if I want to add more elements to the list so 8 um 90 just like that again it'll just simply print out all of the items in the list now uh why might we do this you say well there's a few reasons we may want to iterate by item rather than by indic so the other one uh the in range is known as iterating by indic or by index well this one is known as iterating by item so there's a few reasons we might want to do this but the first one is if we only want to print something out uh if it's a certain value so we just want to check through all of the items in the list and see if there are certain value and if they are then we're going to print it out or we're going to do something specific to that item uh so in this case I'm going to say if fruit is equal to for example pairs then I want to print out pairs so we'll just print out the fruit but if it's not equal to pairs so anything else then I will print out not pairs like that so this is an example of how we can look through every item in the list um and simply check if it is a certain value and then if it is we're going to print it to the screen so we'll try this and we see we have not pairs pairs and Then followed by a few more not pairs um so that's a good way to do it by item um otherwise we can still do this using Indy uh it's just a little more complicated or not as efficient so we could do 4X in range and then in this case we'll do zero and six because we have to do it six times because there's six items in the list and then we'll put a colon and then we'll say the same thing so except this time we're going to say if fruits followed by the square brackets and then X because this is going to be our indic equals equals pairs then we want to print fruit or fruit X oops otherwise we'll print not a pair just like we did in the other loop not a pair okay so we'll run that and we see we get it twice just because I had two for Loops there so it does work uh the exact same way except you can see that this one takes longer to write because we actually have to put the list name followed by the square brackets whereas in this Loop all we have to do is simply type in Fruit um because it's automatically going through the list um another reason too we may want to do that is because in this case we had to actually see how many items were in the list by counting um and then we had to put that number in whereas here it'll just stop at the end of the list automatically um now we could do this so Len this is a new word so I'm just showing this now uh this means length and then inside we can put something like a string or a list so in this case I'm going to put the length of fruits and that would give us a value of six and you'll see if I just get rid of this that it'll work the same way again um um by using the length of fruits okay so that is how to iterate through a list by item uh I hope you enjoyed if you did please leave a like And subscribe and stay tuned for more videos in this series hey guys welcome back today we're going to be doing the 10th video in my Python Programming series and today we're going to be talking about string Methods um so a method is simply something you can call on a string by using the delimiter of a period followed by whatever the method is and then brackets like this now sometimes we have to put some things inside of the brackets um but most of the time we can just leave them with empty brackets okay so let's get right into an example we're going to start by talking about the dot. strip method um now what this one does is it pretty much removes all of the leading and trailing white spaces from a word or from a string sorry so we'll start by just making a variable and we'll make it equal to the input from the console and we'll just say input something like that and then we're just going to print out our input so oops print out text do strip okay so again what strip does is just going to remove all the white spaces before and after the word and it's best to show you with an example um so you can see if we type a few spaces so 1 2 3 4 and then I type hello and then a few more spaces and I click enter it simply gives us hello that's because it had removed all of the spaces from the string while as if I don't have the dot strip here so if I get rid of that and we run it and I do some spaces again and I type hellow and some more spaces it's going to give us those spaces as a part of the string and most the time so when we have a string we want to remove these spaces so that's why we use do strip did I spell that right strip yeah just like that okay um all right so that one's pretty straightforward just removes these spaces now you may want to do this if you're checking um if a string is equal to a certain thing and you're getting a user input and they may have accidentally typed the space before or after the word right okay so now we'll move on to the Len um so this one is actually not a method because you don't call it using a DOT um using a period followed by the word it's actually known as a function which I'll get into later so this just means that it takes something inside of the brackets um so this stands for length Len and pretty much what it does is Returns the length of a string or of a list so right now we're going to use a string and we're going to put text in here and I'll show you again what it does um 1 2 3 4 5 remember although this is a number since I'm typing it in the console it actually gives me a string value so this will work and it says that the length of this is five again uh that one's pretty useful I used it in the last video um to determine how many times we had to iterate through a list because we got the length of the list all right now for lower so pretty much what lower does um is it turns everything into lower cases in our word um so again it's best to just show using an example if I type something like this uh uh with a few lower cases a few capitals and I click enter you see we get everything in lowercase letters all right and now for Dot Upper you can probably guess what this one's going to do it's the exact same thing except in this case everything is going to uppercase so like this and you see we get all uppercase letters all right um and now for the last string method that I'm going to talk about although there is T tons of different string Methods um there's probably over 40 or 50 I'm going to leave the link down below to all of the string Methods on the python website so you can go check them out if you'd like to see some more um so this one is called do spit now this one I'd say is probably one of the most useful methods that I um that I use all the time and what it does is it actually creates a list out of the string that you give it um so inside of these brackets you're going to put what's called a delimiter and what a delimiter is is pretty much what you want to split by so for example I'm going to put a period in here just so we can get an example so we have text dosit and inside of the brackets for dos split we have a period so it's best to just show an example oh invalid syntax I think I have one too many brackets there yes I do okay so we'll run it so I input something I'm going to type hello. tim. by. High just a few random words and you can see they're all separated by a period or by a DOT now when I click enter you see we actually get a list with all of the words and you notice that we don't actually have a period in this list that's because the way that do split works is it gets rid of the delimiter so since the delimiter was a period it's not going to include the period in this list now this may be kind of confusing um we'll do a few more examples so hope you hopefully you can understand so usually what you do um is you would you you would leave these uh brackets blank so you wouldn't put anything in them and by default Python's going to say okay well I guess you want to eliminate by a space um so the way that we can do this again um what'll happen is if I type a sentence like my name is Tim um and I click enter you see it separates by spaces and we have no spaces in our list because it removes those spaces now you could also diiminate by anything you like so I could do an a for example um now if click F5 and we just type a bunch of letters and I put an A and then another a you see we get um the letters and again there's a space at the end because I typed a space right um so yeah okay so that's how dot split works now splits very useful um if you want to do certain things with a list we're going to talk a bit more about it later on um but those are some basic string Methods that we talked about today again there are tons more on the python website which I will link down below um if you like the video please like And subscribe and I will see you again later hey guys welcome back to the 11th video in my Python Programming Series in today's video we're going to be talking about the sliced operator um which is a cool thing that we can use on lists and and strings in Python so if you remember in the previous video if we wanted to access an element in our list we did fruits so the name of our list here which I've already got defined as apples pear and strawberry um and then we would do the items so for example fruits one and we can print that to the screen um just to remind us what this did and we got pair just like that because that is the second item but to reference that we have to use one because in computers we start at zero right um okay yeah and I just wanted to mention I didn't don't think I did this in the list video that you can actually do this on strings as well so say I wanted to access the E there I would just do text one and we get the E because that is the second uh item in this string or character maybe I wanted to do the 11th one then that would give us another E because 11 is right here at the end of like so yeah now what does the slice operator look like so pretty much the slice operator is these two square brackets but inside of them you're going to put two colons just like this now these colons in between them we type some words uh or we're going to put some numbers but in this case I'm just going to show you with words so we have start stop and step um that's what goes where these colons are now if I remove this colon that means I just have a start and a stop and then if I remove this colon I just have a start and that's how we reference what element we want to uh we want to print out right right if we had just put a number there so we'll add the back in and this now we're going to use numbers so the start stop and step works exactly the same way as the range function so you may remember when I did a for Loop we did 4X in range and then inside of the range we did some numbers like this so we would start at one stop at two and step by three like that right so it works the exact same way except in this case we're going to be using um it on lists and on strings right without these numbers so the range like this okay so let's just do an example um so let's start at zero and let's end at this o so the O is 1 2 3 4 five um but if I want to actually include the O I have to put five because remember five would be the space here um and if we stop on let's say four here you'll see what's going to happen um it's not going to print out the O uh because when we stop we do not include that number remember from the range function so if we want to have the O we'll stop at five just like that hello um okay yeah uh now if we wanted to start just from the beginning say we didn't know um all we have to do is just put nothing there and it's going to default start from the beginning so it'll give us the same thing and then if we wanted to start from somewhere so say we want to start at two and we just want to go all the way to the end now we say we don't know how long our string is we don't want to count all of these things and say oh well let's stop at 17 or whatever number it may be by just leaving this blank it'll actually default to stop at the end of the string and you'll see that so we get l l o I like python right it stopped at the end of the string automatically okay so now let's talk about the uh the step feature so if we want to start at the beginning and we want to stop at the end we'll just put nothing in between these two colons because it's going to default from the beginning and default to the end but now we want to skip every other letter that means we're going to put a two here for the step so that way we're going to get h l o then we're going to skip the space here we're going to get I skip the space get L and so on so I'll show you and you see we get that um a bunch of gibberish like this maybe you want to go every third letter that means we would step by three like this and there we go we get a few less letters and same thing we could do four five um and continually going now say we want to start at the third letter or the fourth because we're typing three here so L um we want to stop at the end and we want to step by three then you can see what's going to happen there so we get l i i TN right so a bunch of gibberish okay now this works again same thing for fruits uh it just I don't have as many items in the fruits list so that's why I was showing you with text but if I put the colon in here and we put another colon uh let's say we start at let's start at one so that means we're going to start at pair and let's just go to the end and we'll print that out and again we get Paar and strawberry so we didn't include the apples because we started at pear right so yeah that's pretty much how the slice operator works now there is one other cool thing we can do with the slice operator um and it's called the insert function or the insert kind of uh thing with the slice operator so if you remember uh we H when we wanted to add something to a list we use dot append right so I showed you that in my list video we did fruits. append and then maybe we want to add blueberries like this I know that's spelled incorrectly but there we go we'll fix that quickly blueberries okay and then we can print out fruits once again just to see what it looks like so if you remember this just adds it to the end of the list but say we don't want to add blueberries to the end of the list we want to add it in between Pairs we want to add it in between Apples and pear um we want to add it at the beginning we want to add it somewhere else right how would we do that well we can use the slice operator to do that so instead of using the dot of pend we'll use a slice operator so we'll go like this and this time we're going to just put one callon and then type the indic see where we want to insert it so if we want to insert it at the beginning we're just going to type zero and then zero like this we do need to do them on both sides and then an equal sign and we'll set it equal to whatever you want in this case we'll just put B for Simplicity and you'll see we get B at the beginning of our list now say we want it in between Apples and pear well in that case we would put one and we put one again like this and we get apples comma B comma pear comma strawberries just like that now if we want to add it to the end um we would have to find out what number that is so we do 3 three I believe that should work we'll see yeah so that adds it to the end for us um and then if we want to insert it in between pear and strawberry we would do 2 two like that and there we go we get it in between there so that's how the insert works for the slice operator um I hope you learned how to use a slice operator today we will be using it a little later in some other videos and doing some more complex things with it um if you liked the video please like And subscribe and I will see you again in the next one hey guys welcome back to another video this is the 12th video in my Python Programming series and today we're going to be talking about functions so this is a function up here um we're going to talk more about the syntax and what a function does but it's first important to understand what is a function well if you're in math you know that a function pretty much you pass it an x value and then it does something to that x value and you get a yalue back well it's a similar idea here in Python except there's different types of functions that can do different things so the first function I've just written right here um pretty much I've named it add two and what happens is we give it an x value and then it simply returns x + 2 now this doesn't have to make sense to you right now I just want to show an example of what a function looks like so if we wanted to make our own function what we would type is we'd type DF this stands for definition um and then the function name so maybe in this case I want to do another math related function so I'll do subtract two and oops two as a word and then I'm going to put two brackets and inside of the brackets we're going to put something that's called a parameter so in this case I can name it anything I want I'm going to put number in here and then I'm going to do a colon click enter it should tab me in one space and I'm simply going to return X or sorry number minus 2 now I'm I'll talk about what all this really does um a little bit later but I just want to give some examples so now if we want to call our function or want to actually use these functions we have to do something we can't just leave it like this I'll show you if I run this right now nothing's going to happen what we actually have to do is we have to do a um call statement so what I can do is I can do add to and then in here we have a parameter X but what's actually going to happen is I have to give add to a number because we're going to add two to that number and it's going to be returned so let's say seven now you'll see what's going to happen here uh I'll run it quickly and nothing prints out to the screen that's simply because we haven't printed anything what actually happens is in this add to call statement we have it sets x equal to 7 so it comes up here and it says okay we're going to add two to S so we have X here we add two and then we're going to return that back down here so pretty much we call this function and it returns it right here now I have to set this equal to a variable or simply print it out to the screen so I'll set it equal to a variable right now so I'll say new number is equal to add to 7 and now if I print out new number like this we get nine okay so that that's how that works all right now what about subtract two so we can do the same thing here with seven so we do subtract two we'll leave seven in here for number and you'll see we get five so that works correctly now I can do it again I could do 12 and we get 10 and maybe I could even change what I want to do in these functions so this one's called add two but maybe I wanted to add two to X and then I wanted to square it so then I would do that and then if we go back to the add two so I'm going to put 12 + 2^ 2 which should be 14 squar which will be a pretty big number which will give us 196 just like that so you can kind of see um and understand how these functions are working they have a parameter this is what that's called up here so a variable name I could do X I could do y I could do Zed doesn't matter I can do any letter I want any name I want um it makes sense to call it something that makes sense in terms of the function so here x works fine but if I was doing a string so maybe we want to write another function let's let's do another function here and we'll do Define and we'll call we'll say print string and now inside of here I'm just going to put string like that as our parameter name and then we're simply just going to print the string to the screen so now what actually happens is instead of setting something equal to a variable all I have to do is I have to do print string this is my call statement and then in here I'm going to give it a string so I'm just going to type hello and you'll see if we run the function we get hello and we didn't print it down here we just printed it from the function so I know I've gone kind of fast but the easiest way to understand the functions are to show examples of them and how they're working pretty much there's a parameter I'm going to give the parameter I'm in the argument of the call statement so this in the definition of the function is called a parameter and in the call statement in between the brackets it's called an argument um so those are just some key words now I can actually use these functions as many times as I want so I can print string again and I could print my name is Tim just like that and you'll see it should do it twice yeah there we go so that's why these functions are extremely useful because say for example I'm writing a big program and I know that I would need to do a certain thing multiple times well I don't want to have to constantly write it out um in the main line of my program here when I can just have a function that's going to do it for me and all I have to do is call that function using a simple call statement like this so we haven't really done many big programs yet where functions make sense but you'll see when you start programming that you're going to be using a lot of functions um to do things because you're going to be repeating code um now these are very basic functions we have subtract two add two but you can have like physics functions for example if I know I'm need to find the uh acceleration of an object then maybe I would make another function here and i' do Define excel I'll just do like that uh short form and then I'll put in mass and the force like that so you see I can actually have more than one um parameter I can have two parameters here and I'm going to say a is equal to mass Time Force I know that's not correct but we could do something like that mass time force and then I could return the variable a and now if I I called my Excel function and I printed that to the screen well that would give me what the acceleration would be right um so that those are just some examples of why functions are extremely useful well we're going to talk more about functions I'll do a more advanced tutorial um a little later on but this is just an introduction so that you can hopefully understand how they work pretty much you have if you're writing a function you have the deaf keyword um you have the function name so this case it's highlighted in blue so I did add two then you have brackets and say for example when we do a function we can actually do one without a parameter so I could do Define do something and in here I could simply print high right I don't need to have any parameters that just means when I call this function so do something I don't put anything inside of the brackets right we just do this and we see hi hello my name is Tim right um so yeah doesn't have to have parameters it can have multiple parameters um if for example in this acceleration function you have multiple parameters that means that when you call the function so I'll do an example here then you're going to have to put two numbers in or two strings so I do 2 comma 5 like that and we'll print this to the to the screen because we don't print it in that function so we can see what we're getting so yeah we get hi hello my name is Tim and then 10 right so acceleration 2 okay um so yeah that's just the basics of functions we're going to talk more about them uh in more in depth later but just try to understand how they work and yeah so if you like the video please like And subscribe and I will see you again later hey guys welcome back this is the 13th video in my Python Programming series and today we're going to be talking about reading from a file so specifically a text file and we're going to be using something called file.io in Python so the first thing we need to do before we can read from a file is we need to create a file so I'm just simply going to go and find the directory where my python tutorials are so oops not here they are right here in the tutorials folder um and now you see I've got all my python uh scripts right here and all I'm going to do is I'm going to right click and I'm going to click new and then I'm going to find text document like that now I can name it whatever I like I'm just going to name it file for right now file. text now you may want to populate the uh text document so put some words in here so I'm just going to put a bunch of different words hello Tim python Learning Easy just some random random words in my text file I'm going to save that um and now we can go to reading in the text file so it is important that when you make the text text file you do have to save it in the same directory as your python script so if I were to put the text file here on my desktop and I have my python script in the tutorials folder here it's not going to be able to find the file properly um you would have to do something which is a path joining which I'm not going to talk about in this video but maybe in a later one so make sure that you save your file in the same directory uh and same folder as where your script is okay so now that we've done that we're going to read from the file so the first thing we need to do is we need to create a variable so we're going to name this file you can name it whatever you'd like and you're going to set it equal to the keyword open and then inside of open all you're going to do is you're going to type the name of your file so file. text a comma and then the mode you want to open your file in so in this case we want to read it so we're simply going to put a lowercase R inside of the quotations just like that and now that's pretty simple that's all you have to do in python to open up the file and to prepare to read it now make sure you do put R in here if you put nothing or you put a W for example which would be write mode it's actually going to clear the whole file which you don't want to happen you want to leave the contents of the file in there right so we need to open it in read mode with this R that's very important um now what we're going to do is we're simply going to read all of the things from the file so we've opened the file now we need to read it so in order to read the file uh we have to type a few things so we can do it in multiple different ways the first way I'm going to show you is this so I'm going to make another variable I'm going to call it f and this one we're going to make it equal to file. read lines like this okay and then we can simply print out F just to show you what's going to happen you see we get all of the words that are in the file now there's an interesting thing here you may notice that there's a back sln attached to all of the words except for the last one that's because I'm going to open up the text file again and show you um you notice here I didn't actually type back sln but every time we click enter like this it actually creates something called an escape character which is that back sln so if we want to read in the file we're going to have to remove that um character afterwards right so it's just something to keep in mind that if you have things on different lines each of the end of the lines is going to have a back sln on that line that you don't actually see here in the text document but python will read that in okay so we don't need to save that um yeah so let's move into the second way to read it properly now so we have f equals file. read lines now we want to remove all of these back slashes uh get rid of these ends from our lines so there's a way we have to do that and it's by using a for Loop so we're going to do a for Loop just going to say for line in F because now F has read all of our lines so we're going to do what's called iterating by item if you remember from my other videos so each line so every item in this F list here that just created by file. readlines we're going to remove that character and we're going to create a new list so let's make a new list we'll call it new list just make it a blank list like this new list and then here we're going to say um what is it new list. a p and if you remember what a pen does that simply means add to the end um of this new list and then we're going to add the line and we're going to use the slice operator to remove that back sln so we're going to Simply do the colon and then1 now what this does is we it will H take all of line except for the last character so negative one um I didn't talk about this in the other video but negative 1 pretty much just goes to the last character but does not include the last character when you do negative 1 like this so just just follow along for now you don't have to completely understand it but just put that negative one and now if I print out new list we'll see what we get new list F5 and you see we get rid of all of the back slash ends now we have one issue here um down here on ease uh it should say easy but we've actually removed the last back sln from that string so if we don't want to do that now we need to actually add an if state statement into our for Loop so inside of the for loop we're going to type if and then we'll say line and we'll put a negative 1 again to represent the last character in that line equals equals back sln and then we'll simply tab this in because remember everything in Python needs to be indented properly for it to be read um and now we'll try this and we'll see if this works and there we go so we got hello Tim Python and learning but now we forgotten one thing we haven't actually included easy so now we need to do an else statement so we have else and then we'll do new list do append and we'll simply append the line just like that and now we can print it out and we will see what happens and we get hello Tim python learning and easy now there is an easier way to do this I just want to show this example because you may want to do something where you're checking through all of the lines and you want to see if the last character maybe the first character is equal to a certain item and depending on what that string is or depending on what it is you may want to add it to a new list you may want to do something to it so I just want to show you a way that we can do that pretty much this is iterating through every line in the file so file here so F creates a list of every line and then we go through every line of it and we see we say if the end of it has this back sln then we're going to remove the back sln um otherwise we'll just add that line into our list right okay so now the easier way that we can do this is actually with something that's called The Strip string method so in my other video I talked about this strip method that removes the spaces but what we can actually do with this uh is we can remove what do you call it sorry we can remove the back sln with the strip method as well so all we have to do here now it's a lot simpler is do new list do append and then inside of here we're simply going to type line. strip and now this will automatically remove those back SL ends and we'll see if this works there we go so we get everything and you can see it's a lot simpler and we don't even have to do the if statement um for the easy like that so that pretty much is how you read a file in using python there are some other ways to do this but this is the most basic and easiest way to understand we've also talked about how to remove that it's called an escape character at the end of the string that back sln and in the next video we're going to talk about writing to a file I hope you learned something if you did please like And subscribe and I will see you again in another video hey guys and welcome back today this is the 14th video in my Python Programming series and we are going to be talking about writing to a file so in the last video we talked about reading from a file and now we're going to be writing to it so the first thing we need to do is create a file so we already have a file created here called file. text I did that in the last video and inside we have nothing so I'm just going to put the word hello in here so that we can test something out later okay now it is again important that you have this file in the same directory as your script so tutorial 14 which is the script I'm using right now uh is in the same directory that's important otherwise python will not be able to read that file properly okay so now we're going to do the same thing we did in the last video we're going to do file is equal to open the file name so in this case file. text oops that has to be the lowercase my bad file. text and the mode so in the last one we used R but in this case we're going to use W and that stands for right now there's one thing we need to do which I forgot to do in the last video and that is close the file so we do need to actually close the file so that it saves our changes which I forgot to do in the last video and it's very important that we do that so my apologies but here we go file. close and again if we had changed this name to anything else then we would do that name do close because the file is contained in the variable file like that okay so now we want to write to the file so all we have to do is type the variable name so file and then do write which is very simple and inside here I'll put a new word I'm going to put python like that now before we run it let's notice what is inside of our file. text so in here we have the word hello now I'm going to run the script and nothing happen here obviously because we just wrote to the file but when we open the file again you see now it says python now what actually happened was we removed the word that was in there before so hello and we over wrote it with python so what happens in this mode here W is it actually clears the entire entire file and then it writes what you want to write to it so if you have this W here it is going to clear the entire file now there's a way to get around this but I'm not going to be showing that in this video today okay okay so let's write something else to our file so file. write and then I am learning how to write to a file just like that and again we'll run the script and we'll open the text file and you see we get everything here on the same line so that's okay um but you may want this to be on different lines so how would we do that well if you're remember from the last video there was something called an escape character that we got when we read in the file we had that little back sln attached now that's the same thing we need to do when we're re writing to the file if we want things to go on a different line so on this line here I'm going to type the backs slash and then the N uh and now what's going to happen is it's going to have this Escape character which is going to tell python we need to move to the next line and then it is going to type this right here so we can show what's going to happen here we go F5 and then if we open up the file once again you see Python and then I am learning how to write to a file so that happened again because we use that back sln the Escape character now same thing we could use this in between uh a line so if we wanted to write a large thing and we want it on different lines then we can put the Escape character in there like that same thing open the file again and we'll see what happens and we see we get it on a different line so that's how you can write things to a different line uh now this has been a pretty short video today but that's really all it is uh to writing something to a to a file in Python now in the next video I'm going to show how we can write and read to a file at the same time so that would involve not wiping the entire file when we open it but if you learned something today please like And subscribe and I will see you again in another video hey guys and welcome back today this is the 15th video in my Python Programming series and we are going to be talking about some more methods that we can use on strings and on lists these methods are I'm going to put them in a comment so that I remember is theind and the do count method and now these can be used on strings and on lists so let's go right ahead and give an example so the do find method this is this is a uh very useful method in Python it's not in a lot of other languages so it is specific to python so what we can do is we're going to make a variable we're going to call it string now we can set this equal to whatever we want so let's just say hello for this case for Simplicity and then we're simply going to print string oops if I spelled it correctly string doind and then inside of theind brackets here so the argument for this meth meod we are going to put in what we want to find so we want to see if we can find the indic of any of these letters here so if I put in L you'll see what happens is I get two and that's because there's an L the first l in the string is found at the indic of two just like that um now you may be confused right now I haven't completely explained it but that's fine so as you can see we have two L's in the string right now when I put in this l in the brackets it gives me a value of two now that is where the first L is found in the string if I put in O for example you'll see it gives me four and there's only one o in the string so it gives me the value of where that o is which is the fourth indic of the string the fourth index uh if I put in h you see we get zero and now notice what happens if I put in a number or a letter that's not actually in the string so I'll put in seven for example the string seven and you see we actually get1 that's because if python does not find that inside of the string it's going to tell you that it's negative one so rather than zero it gives you negative 1 just like that so this is useful because maybe we want to check in a password for example if it contains a certain elements so maybe if there's a dash in there we don't want them to be able to use that password or maybe we're not allowing a certain character or we need a certain character to be in a password or a string this is where find is useful um and it'll tell us if that's in the string or not now there's actually another useful uh string method here that is do count now it does a similar thing except instead of finding the index of the letter it counts how many of them there are in the string so now we're going to go to do count so we'll go do count like this and again inside of the brackets we're just going to put a string uh so let's do L and you see if we F5 here we get the value of two that's because obviously there are two L's in our string now I'm just going to type a bunch of random letters and show you that this does work for all kinds of things so if I type in a for example see how many A's I typed we have six A's in that string now let's try a zed I know I didn't use Zed here I'm pretty sure at least oops that's my bad uh we forgotten a uh parenthesis there sorry okay and we get zero right so instead of 1 it counts and it says well there are zero of them in the string so we're going to return zero again we can use this to find if there's a certain character in the string so if we say you can only have a maximum of three numbers in your string well we could count and we could say if there whatever how many numbers right um the dot find is different than this because it actually tells us where that is so if I do find again and now maybe I put in an a well we know there's six A's in the string but which a is this one going to give us so it says five because that is the first place that an a occurred in the string so we see here at the fifth indic or index that's where the first a is it's not going to give us the A's from back here if we wanted to find the A's back here we' have to use a for Loop and we'd have to Loop through the string in different parts of the string to find where all the A's were um again yeah so that's how you use doind and do count it's very useful if you want to check certain things so I'll show you an example here if we wanted to check a string how we would use the count method or the do find method so I'm going to say if string. count and I don't want to allow any let's say underscores in my string is greater than zero so that just means uh if it's I guess we could also say not equal to zero so if it has if it contains at least one of these underscores then we're not going to allow it so we're going to print to the screen not good just like that okay just to show how this works now here instead of actually having a preset string we're just going to get input from the console so we can do this a few times and see so input and we'll say please type something as the prompt like that and otherwise so in L state in here if it doesn't contain any underscores we will print good like that okay so now I'm going to type hello that was our first string and oh what happened there good so we get good sorry I don't something glitched uh in the program there we'll rerun it I'm not sure what happened there F5 please type something I type hello there we go now we get good I'm not sure what happened the other one okay so now let's do it again and this time we're going to include an underscore so we'll do underscore uncore hello it's going to say not good because it counted these underscores and it said well there is more than zero underscores so it's not good and then same thing if we put an underscore in the middle of the word or we put a ton of underscores so h e l o whatever just like that uh not good because there's underscores in the word just like that and yeah that's pretty much how the doind and the do count methods work there's a ton of uses for these and it's really useful um that they have this method because in a lot of other programming languages they don't have this count and find so it makes it a lot harder if you're trying to find how many things are in a string or if you're trying to find the index of a letter so I hope you learned something I hope you enjoyed if you did please like And subscribe and I will see you again tomorrow for another video hey guys welcome back this is the 16th video in my Python Programming series and today we're going to be talking about python modules and import statements so this is something new that I haven't talked about yet but python is a modular programming language meaning that we can use multiple files together to create one program and you'll understand what I mean later in the video when I show some examples um but yeah so pretty much in Python at the beginning of all your Python scripts what you typically do is you write something like this it says import and you can see this highlights an orangey yellow meaning that it is a keyword in Python now there are many builtin modules or what they called um in Python that contain a list of functions and classes that we can use in our python script so for example the math module import math this allows me to do things like dot square root or it's the square root function which I believe is like this and then you can put something inside of it um so yeah there's plenty of cool things like that there's another module it's called pame Uh we're going to be doing this later I'm going to be talking about game development with python if you want to see that leave a comment down below and I'll get it started soon and then we have import we can also import something called OS and this gives us uh opportunity to do things like file paths and lots of different things like that we can import images we can import tons of different things into our files um in Python so we're just going to use the math module today for demonstration purposes but pretty much what happens is there's a bunch of builtin modules in Python so this one is known as a builtin module math uh when you download and install python it pretty much you download that module the pame module that I was talking about is not a builtin module that means you actually have to go to the internet you have to find it and install it on your computer before you can import it into your Python program and now what's really cool about python is that it's an open Source language meaning that you can actually create your own modules um and they contain functions classes and you can use them in many of your different programs or you can also send them to a friend maybe or post them online for other people to be able to use so let's get right into it and uh let's do some things here so if we want to use this math module we have to first start by typing math so the name of our module here okay so math and then afterwards we're going to do the name of a function or a class in that um that math module so you see a bunch of things pop up there uh in that little box so if I do the dot again in wait a second it should pop up yeah so there we go and you see we have cosine s tangent all that stuff uh degrees factorial all these things inside of our math module so these are new things that we wouldn't be able to use before so I'll show you if we do math.pi and I print that to the screen well we should get an endless number of digits like this math. Pi uh is it running there we go so it just had to print a bunch of numbers so math.pi it didn't print all of them I think it only went to 10 decimal points um so yeah and then I'll show you if I comment out this uh this import math what'll happen if I try to do this we get an error because well math is not defined we didn't import it at the top of our program so we'll uncomment this now now I can do things like math. degrees uh degrees simply turn something that is in radians into degrees so if I did math. Pi in here for example and we print that to the screen we get 180 degrees like that uh they also have the math. radians I believe which does the opposite so it turns a degree into a radian so if we did 60 degrees here like that and we get 1.47 which is about pi over 3 uh radians like that so yeah there's lots of cool things that we can do with these modules now I'll actually show you an example of how we can use our own modules and how we can import our own modules into our function so I'm going to just start by typing import I'm going to type my module just like this okay um now I haven't actually created this module yet we're going to do that in just a second now I'm going to go and I'm going to find the directory that my main script is in so it's in tutorials up here I've got this open and remember uh how we had the file in here as well because it has to be in the same directory so I'm going to create a new file in that directory so file new file I'm going to save this one as my module now spelling is very important again capitals do matter uh and it has to be in the same directory as our main script which it is like that now inside of this module I'm going to write a very basic function if you haven't seen that video yet go check that out first um we just talked about some basic functions and what they do in the use of them so I'm going to Define I'm just going to call it my funk like this it's going to take a parameter called X and all it's going to do is return x + 5 so very basic function like that but just for demonstration purposes here okay and now I have my module imported like this so I can actually use my module so I'm going to do print my module dot my funk because that's the name of my function and then inside I need to give it a number so what number do we want to use maybe we'll use six and we print this out and you see we get 11 so by simply all I did was create a new file put it inside of my um same directory as this script here and easy enough we were able to use it now I can actually create multiple functions in here so I can create Define another Funk like this that'll be the name this one will take X again and inside here I'm going to return X integer division five and then again we could use that one so instead of my funk we'll use another Funk like this and let's just type in a big number like that and see what we get there we go so again it's working perfectly fine so that's how uh modular programming is what it's called works in Python now obviously if you're going to be doing modular programming it's usually for larger uh programs and bigger programs where you want multiple files to keep things organized say maybe if you're doing a flight simulator you may have one module that includes all of your physics functions so you know that when you need to do physics you're going to import your physics function and then you can or module sorry and you can use the functions from there and the great thing about this is that these uh these modules are reusable in other python files I can import them and I can reuse these functions I don't have to constantly rewrite them inside of my script like this so this has been a very basic tutorial uh just an introduction to modular programming I showed the math module a little bit if you want to learn about some of the builtin uh sorry modules in Python then just go ahead and go to their website and you can see a bunch of the different ones that they have another one that we may be using later is called OS so the statement for that is just import OS and if you want to get started with game development you can look into pame which is this cool thing that I'm going to be doing a tutorial series on later so yeah that's been the video for today we talked a little bit about modular programming if you enjoyed please like And subscribe and I will see you again tomorrow with more content hey guys and welcome back to another YouTube video this is the 17th video in my P Python Programming series and today we're going to be talking about functions more advanced functions and something called optional parameters so let's just give a quick refresher of what a function is I'm just going to write one very quickly I did do another video on basic function so if you haven't seen that yet go check that one out first now here we've defined what we're going to call the function Funk and then inside of these brackets we put something called parameters if you remember that from the other video so in this case I'm just going to put X as my own only parameter and then I'm simply going to print x to the screen just like that so A very very basic function but it's just to give you a quick refresher of what it does now when we wanted to call our function all we had to do was write our function name and then put a brackets or the brackets like this and then inside of our brackets if we had a parameter set we had to do we had to give it that parameter so we could do three we could do hello let's just do hello in this case and we'll click F5 and we get hello on the screen screen just like that now we can change this again to maybe Tim which is my name just like that and we get Tim printed this screen very basic very easy just like that okay so that's pretty much what a function is now what we're going to be talking about today is more uh in depth on these parameters so you remember we can give it multiple parameters so we could do x uh and we could do maybe text like this so we had X and text and then we could print x to the screen and maybe we'll say if text is equal to um let's say one so the string one then maybe we'll print text is one otherwise so else we will print text is not one just like that very easy okay so now what we have to do when we call the function is we have to give it another parameter in this case I'm going to give it two and we'll see what happens we get Tim and then texter I misspelled that my bad is not one now if I change this parameter to one again we'll see that we get text is one now again that's just another example but in some cases when we call a function and we have many parameters or maybe we don't have many but we don't want to constantly be rewriting these parameters we want to have something called the default value for our parameters so X maybe we always want to give our function the value of x but in text here we always want it to be set to something unless we otherwise specify so in this case I'm going to say text and then the equal sign and I'm going to put two just like that now here I'm going to remove the one and you'll see what's will happen here we'll just run it to show you and then we'll go in what's actually happening so we get Tim and then text is not one so what actually happened here is since I didn't specify a value for text so I didn't do a and write something else here it defaulted to the value of two now we can prove that by just simply printing out text and showing you that it is actually two so we have Tim and two just like that um if I wanted to change this value now all I would have to do is simply put a comma here in the function and change it to whatever I want so in this case I'll do 67 and if we print it again you'll see we get 67 so that's how the optional parameter works now all you have to do to set an optional parameter is simply type an equal sign after your parameter so if I have X and I'll set it equal to three like that now when I call the function I actually don't have to give it any parameters because it already has the optional parameter of three and of two which are going to be the default values if I don't write anything in my function argument here so inside of these brackets and you'll see again we get three and two because those are the default values now there is one tricky thing that you have to understand about these optional parameters say you wanted to have X stay at the default value so you wanted it to be three and you didn't want to type three in the brackets like that but you wanted to change the text optional parameter to something like seven or eight or maybe another string well you can't actually do that in order to change this text optional parameter you would have to also set a value for x here so if I try to I'll say I just want to set the text to three so I'll do like three here it's actually not going to change um sorry what do you call it it's I'll change it something else so we can we can see it better five let's do five it's actually not going to change that second variable right it's going to change the first one automatically because that's just the order in which they're defined so if you want to if you have more than one optional parameter you will have to set a value for the one before in order to change the one afterwards like this so that's the only tricky part about these optional parameters other than that they're extremely useful again you would use them if you're constantly using a function and you don't want to have to keep writing in parameters you only want to give it a parameter in a very specific case then you would have that optional parameter already set so you don't have to keep typing a certain word you don't have to keep giving it a value like that so this is been a shorter video but this is the video on how to do an optional parameter they look just like this they're very simple and pretty basic and I hope you learned something today if you did please like And subscribe and I will see you again in another video hey guys welcome back to another video this is the 18th video in my Python Programming series and today we're going to be talking about something called a try and accept block of codes so just like we talked about the if else and L if block of code um and like we talked about the for Loop which is a block of code and like functions which are blocks of code uh we're going to be talking about the try and accept so in Python we use try and accept as our keywords in other languages you may have heard of try and catch statements um this is the same thing except in Python instead of catch we use accept Okay so let's talk about what a try and accept statement is sometimes in Python you want to do an operation or you want to try something but you don't know if it's really going to work or not there's some different variables that may come in sometimes it may work sometimes it may not work usually this depends on user input or what the user is doing in the program so a good example of this is maybe if we're validating a form so we'll do an example here we'll say text is equal to uh input like this and then we'll say username okay now in typical usernames you're only allowed certain characters maybe you can't do um a comma you couldn't do a star certain things like that right maybe we only want it to be text or we only want it to be numbers uh we just want to validate this we could use a huge if statement to do this um but instead there's something called a try and accept that we can use so in this case I want my username to only be numbers so I don't want it to be a string at all I want it to only be numbers so what I'm going to do is I'm going to make a new variable here and I'm going to call it number and all I'm going to do is I'm going to try to int the text like this okay so if you remember what the int does is that simply converts our string into an integer and then I'm going to print that to the screen so I'm going to print number to the screen now what what happens right here is uh if I try to type in a word like this you see we get an error it says there's an invalid literal for INT with base 10 now you don't have to understand what this error is pretty much all this means is that we can't convert hello into a number because there is really no number there how how does it know what number to make that into right so in this case we would use a try and accept look because if the user types in something that's invalid well we want them to type in something else we don't want the program to crash like it just did there so here I'm going to put a try like this followed by a colon and then I'm going to indent these two blocks right here so that means we're going to try this block of code okay and then underneath here I'm going to type accept just like that followed by a colon now there is a more advanced way to do this we can accept a specific type of error um but I'm not going to talk about that in this video this is just a very basic try and accept block and then under here uh I'm going to type what I want to happen if this block of code doesn't run meaning this block of code returns an error um and we can't actually execute it so in this case I'm just going to do uh I'll just print to the screen invalid username because remember we're only going to have our username contained numbers all right so now if I run the program and I try to type in something that is not a string so just I mean that is not a uh number like this it'll just say invalid username rather than crash ing the program which is what happened before and if I do try to type in something that is valid so maybe I type 1 2 3 4 it just gives me that username back right so it works like that um so that's pretty much how the try and accept works again this is a very basic example and that's what I try to do in my videos just give you the basics and then you can try to apply it to some projects you're doing um and some more advanced things so again what happens is it tries this block of code if that block of code doesn't run or an error happens instead of Simply crashing the program and giving us that red message it's going to go to this accept block and it's going to do whatever is in here now in this accept block again we could ask them to type in a new username we could display another message we could maybe um close the program on them we could do whatever we wanted to do in this accept block and it's extremely useful um so yeah that's pretty much how the try and accept works if you learned something please like And subscribe and I will see you again in another video hey guys welcome back to another video this is the 19th video in my Python Programming series and today we're going to be talking about a fairly complex topic some people find kind of confusing in their programs um it's very useful to understand and it's Global versus local variables so Global um pretty much means everywhere can be used in anything and local means specific to a certain uh block of code or to a certain class so let's just dive in right away with an example so in our program we have things called variables again we've talked about them before so I'm just going to say VAR up here equals 9 we'll say our um true this is lowercase here uh is just equal to true or actually let's call it Loop in instead just not to confuse anyone so Loop is equal to true and then maybe let's make a function we're just going to call this function Funk we'll give it a parameter of X and we're just going to say if x is equal to oops 2 equal sign 5 then return true and we'll set a variable up at the top of this function and we'll just call it uh Newar is equal to seven or yeah seven let's do that and then instead of returning true we'll actually return new VAR my bad new VAR just like that okay so here we have three variables we have the variable VAR which is equal to nine the variable Loop which is equal to true and then the variable Newar which is inside of our function and that's equal to 7 uh and then the parameter X which again can kind of be considered a variable but it is uh more specifically a parameter so I just want to show you right away what tries to happen if I print out the variable Newar so outside of my function in its own line I'm just going to say print Newar like that we click F5 and we get an error here it says the name Newar is not defined but how can that be possible we just made Newar right here in our function well this is where we get into local versus global variable so the variable Newar is actually known to be a local variable to the function uh Funk so that means the only thing that's able to access the variable change the variable and use the variable Newar is the function Funk so again if I put the print statement inside of my function and then I call my function it will work so here if I type Funk now and I'll give it value of two then Newar does print to the screen and we don't get an error so that is how uh the local variable works so again it's the same thing in any other type of function so if I write another function I do Define other Funk this one I won't give it a parameter and I'll just say Newar is equal to five like that so different than seven and then this function will print Newar well do we think it's going to print out seven or do we think it's is going to print out five so we'll show you like this if we run uh take zero positional arguments other fun oh my bad there's a two in there sorry it prints out five right so it doesn't look at this variable here it looks at the local variable in here called Newar now same thing if I put Newar up here outside of all of these functions and I set it equal to 23 and then I click F5 here to run it's still going to print out five that's because these functions they can see these variables up here but if there there's a variable already declared inside of their function they're going to use that one instead I know it's kind of confusing I'm going to talk a little bit more about how this works I just want to give some examples to start off okay so now we'll talk about global variables so local variables are ones that are declared usually inside of a function so that means outside of the function so again if we tried to print Newar out here um and I got rid of this up here we get the error like we got before right it says it's not defined so what about global variables well these Global variables are ones that anything in the program can see so VAR and loop would be known as Global variables in here if I try to print out our variable VAR and then I'll just call that function by doing Funk and I'll give it a value of two once again it will be able to see VAR and it does print it to the screen as nine that is because this is global it's not defined inside of a function or inside of a class and classes we'll talk about later don't worry about that um same thing if we try to print out Loop so if I change this to loop again it should work we get true printed out to the screen just like that so now there's the issue with changing variables in inside of a function so typically you want to avoid this you don't want to be dependent on these Global variables up here to make your functions work this is because if you remember in my other video I talked about modular programming where we can reuse functions well if I have a variable defined up here and my function is referencing that variable meaning it requires that variable to work then if I try to use this function in another one of my programs it's not not going to function properly because that Loop variable or that Global variable that I try to use is not going to be uh defined in that other program right so let's do an example here of how we can actually change a global variable so if I go here and I say Loop is equal to 7 so I call my function and it's going to set loop equal to 7 it's um and then I try to print out the variable Loop Loop well what do you think is going to print to the screen give me a guess it's either going to be seven or it's either going to be true um what do you think right so I'm printing it underneath after I call this function Let's see we get true now even though we what looks like changed the variable in this function instead of actually changing This Global variable instead we created a new variable which is local to the function called Loop if we want to change the variable we have to use something called the global keyword so in Python what we have to do is at the top of our function we just type the word Global followed by the variable name that we want to change so in this case I'm going to say Loop now if we run this program we print out seven that's because this tells our function that we're going to look outside of the function here for the variable if it exists then we're going to change it just like like we did there so I know this has been kind of confusing I've kind of jumped around try to play around with these things and see uh if you're getting errors see if you can figure out what's going to print to the screen here if you want to change a global variable so one that you define at the top of your program here or outside of your functions then you must type the global keyword inside of your function followed by the name here again if I try to change the uh the variable down here so not inside of a function it will work so if I I do Loop is equal to false then uh oh we get seven again just because I called it up here so I won't call this function this time if I say Loop is equal to false then we will get false because it's not inside of a function so it is able to see and change this variable so really using the global keyword uh it's just inside of functions and just remember that if you do create a variable inside of your function it's local to your function meaning that unless you type this Global keyword first and then followed by the name of that variable everything outside of the function will not be able to see that variable so if you liked if you uh like this video and you learned something please like And subscribe and I will see you again in another video hey guys and welcome back to another YouTube video so in this video I'm actually starting a new series on classes and objects in Python now I'm going to start off fairly simple and just explain to you kind of what is a class what is an object how can we create our own and in future videos I'm going to get a lot more advanced and show you some really cool things that you can do with classes and objects that not only make your life a lot easier but are really cool in my opinion and I didn't even know you could do them until I was kind of searching around before making this video so make sure if you guys are interested in bringing your programming kind of to the next level and stepping out of the basics of python and moving into more of an intermediate to Advanced topic that you guys watch through the series because you're going to learn a lot and you're going to have a fundamental understanding of python that you never uh understood before if you can understand the topics I'm going to talk about okay so let's start by talking about objects what is an object well in Python an object is pretty much anything and you can see on this my screen here I have two variables x = 5 y = string now to us without any understanding of objects and classes this just looks like X is equal to an integer that's five and Y is a string and that string value is string now I just want to show you quickly and you might have seen that you can do this before if I print out the type of X and what do you call it we'll just do the same thing here with Y run our program you see we get class int and class string now this is pretty trivial you figured this was going to happen but what does this class actually mean here well pretty much whenever you create a new object in Python so whenever you create a variable something like that it automatically creates an instance of an object now X the way that you can also read this is X is equal to an instance of the in class and its value is five whereas Y is equal to an instance of the S Str class and its value is string now these classes allow us to have builtin functionality in Python now you might might take for granted the fact that we can do something like x + 7 right and obviously we know we're going to get 12 when we do that or if we do like x 6 or x / 4 but someone actually coded this functionality into Python and you just can't see it when you're coding here um because it's kind of underneath and I'm going to actually show you a way that you can look at this builtin um code okay so just know that anytime you create a variable and anytime you kind of use any functions like for example if you use uh I don't know say like H is equal to what's something we can do like int y okay I know that's not going to work but whenever you use functions like this someone already coded these functions for you and they're typically built into a class of a certain type when you do something like y. strip you just take for take for granted the fact that you can use this strip method um and this is called a method but someone actually built this in and the reason you can use this is because it's a method on the CL class of St Str if I tried to do something like x. strip well clearly that's not going to work because X is not a string object so just understand that whenever you create anything in Python it is actually an object without you really knowing it or not okay so now I'm going to show you I'm just going to run this in debug mode so I can print some stuff out to the screen okay so I go console and python console okay so I'm using Pym but this works perfectly fine with regular idle in Python okay so if I type this help function and I pick a class and I'm going to pick int like this okay I type help on int you can see it prints me all this stuff now what does this actually mean well once we get to the top you can see it says class int of type object or inherit from object so pretty much whenever we create an integer and the way we create an integer in Python is simply by just saying like x = 5 xal 470 whatever like that it automatically defaults this x is a type int and you can see here that it actually tells us exactly how this class works and this is really useful if you don't know documentation you can just type help on something and it'll read out all the class and everything for you so convert a number string to an integer return zero if no arguments are given that's what happens when you call the int function and when you give a base well then it tells you what it does there okay now it says methods defined here well these are actually all the methods that you can use on on the class integer so if you have abs you have ADD and bu seal div mod equal to Flo floor FL TI and I'm going to show you what all these actually mean uh and why they have the underscores on them later on okay so just wait for that you can see that there's a ton of different methods and a ton of functionality already built into this integer class size of string and you can just keep going two bytes and there's a ton and then class methods defined here we're going to talk about what those are later now I want to show you if I do the same thing on string so I say help on oops on S strr like this then we get the same thing except for string and this one is going to be what do you call it a little bit longer because there's more things you can do with string but you can see we have class string and it inherits from object and we'll talk about what all this means later just uh follow along for now create a new string object from a given object uh if encoding and so on okay and then it goes down here add contains equal and you can go through all of the different MTH methods that it has now obviously this is the same for Boolean values and for what do you call it uh floats and all other data types in Python now if any of you have ever seen Turtle before you know that if you create for example import Turtle okay wow I can't type today and you create like Tim equals Turtle do turtle like this what you're actually doing is creating a new instance of a turtle object so in this Turtle module there's a class named turtle and when you call this what's known as a Constructor you're actually creating a new turtle object and you're just naming it Tim or storing it in the variable Tim okay so what else should we talk about with objects here yeah so let's talk about the difference between methods and what do you call it functions quickly so a function everyone here should know is created with the Define key okay or like Define keyword so I say Define Funk give it a value X and we'll simply return x + one now we know to call this function what we can do is we can simply say like print and then Funk of five and we know that that should give us a value of six right because it just simply adds one to what we're giving and this is a function there's no question about it okay now a class is actually what you call with the dot operator so this sorry not a class a method so this dot uh right here turtle. turtle is a method that creates a new turtle object and I'll show you what I mean here so if I do something like print y do uper well this upper right here is not a function it's actually known as a method and it only applies to the class St Str so I'll just print this quickly to show you we get string in all capitals okay if I tried to do something like x. uper and I click the play button here well X has no uh method upper and you can see int object has no ATT upper okay and that's because well X is an object of type int and remember when we typed help on int well we didn't see any upper method there so we actually can't use that and that's why we can only use methods on their correct data types right so if you create a float and you do like uh I don't know like f equals like 5.5 then obviously if we try to do f. uper here this is going to crash as well because well float object has no attribute upper right it had doesn't have that class or that method sorry in it okay so a method is anything you're calling on an object itself right and a function is something that's going to take an object and apply an operation to it right so you can see here that uh five is passed into the function we don't have to do like X do function we just pass it in there and then it returns us a value now methods can return us values as well this one is returning us a value of all capital string it's just different how we actually call those things and they are very similar just the difference is the way that one of them you call on an object and one of them you have to just call and then pass an object through and sometimes these methods can take objects as well for example let's see if I do x dot or F do replace I think that's a thing all I'm going to have to do y. replace y. replace like this okay and then I'm going to pass it a I don't know what should we pass it let's pass it a s and we'll replace it with a blank string okay so we're passing a object of type string and we're passing another object of type string and that's what this method takes as well as we have to call it on the instance right so string so if I call this we get string and six because it simply replaced s with quotations okay so I think I'm going to cut the video here uh I hope you have a little bit of an understanding of what an object is because in the next video we're going to create our own objects and our own class classes uh and we're going to talk about that it just was fundamental that you guys understood this before moving on to the next video okay so that's been it for this video If you guys liked please make sure you leave a like And subscribe and I'll see you again in the next one hey guys and welcome back to the second video in this object and class tutorial Series in this video we're going to be going over creating your own objects and your own classes and what that looks like in Python so just go ahead and delete this code from the last video uh and start fresh so if you guys remember in the last video we talked all about objects talked about methods uh and that's all cool we kind of already understood a lot of that stuff like we've used those methods it Mak sense how they work uh but now how do we create our own and this is the whole goal of this tutorial series to create your own classes and your own objects and add functionality to your program so to create a new class and this is going to be a new like data type uh something like that we'll talk about that in a second you just simply type class and then whatever you want the name of your class to be so in Python they have in string list whatever okay we're going to create a class and I'm just going to call it dog now you probably have seen this example before if you do anything um what do you call it with like uh classes or objects because people like to use animals but it's a really good example so this is now creating a new class of dog now what we have to do whenever we create a class is we have to uh add some methods into it so remember I talked about methods or things that you call on the actual class itself so I'm just going to type Define nit uncore uncore and we're going to talk about what this does in a second and make sure you don't forget this self keyword uh this object keyword you can leave out if you want I just like to type it because I don't know it's just a habit right because we have class dog Define the NIT and I'm going to make one more method and we're going to call it speak okay and make sure you don't forget this self keyword we're going to talk about what all this does in a second okay pass and in here I'm going to say pass all right so we've now just created our own class it does not do anything but we've created our own class so what we actually do here is we're creating well new class it's equal to dog it inherits from object don't worry about that and this is what's known as The Constructor method now this uncore uncore nit uncore uncore needs to be in most of your classes okay so if you guys want anything to happen initially when you first create a class you need to make this a nit class and what happens is when we create a new object and the way we can do this is by doing something like I don't know Tim equals dog like that this method is automatically going to fire it's automatically going to go off we don't have to say Tim doore netore uncore we don't have to do that whenever we create a new object of type dog this is automatically going to happen so for example if every time I created a new object of dog I wanted to print out uh kn nice you made a dog like this then every time that we do this so if we say like fred equals dog as well then he's going to print this to the screen and I can prove this to you by simply running so he says nice you made a dog nice you made a dog all right we didn't have to call this a nit it just automatically happened whenever we created this dog so let's talk more about this a nit and what we can do with it so in classes there's things called attributes and methods all right methods are anything that you create using Define okay and they look just like functions except you have to call them using uh an object like we talked about in the last video and attributes are kind of like variables that belong to a certain object so to create a attribute you need to use this self keyword all right what this self keyword actually stands for is it stands for the instance that you're calling so him is known as an instance of type dog or of class dog now Fred is another instance of type dog now I'm just going to do this and then hopefully you guys can understand how this kind of works uh because it is somewhat difficult to explain okay so now what we're saying is we've created this initialization all right and we have now that it takes a name okay so what that actually means is we have to now type a name into uh our initial initializations whenever we create a dog we have to give it a name so in here I'm going to give it a name Tim and in here I'm going to give it a name Fred all right and don't worry if you guys are confused I'm going to explain this all in depth in a second okay and I'm just going to do this so that we can actually see what our name is print hi I am comma self. name and we'll talk about what self does in a second okay let's do tim. speak and Fred dope as well okay so let's print this and it says hi I'm Tim hi I'm Fred okay so how does this work so in this initialization this fires automatically when we create dog okay so by calling this we're automatically calling a nit so if we put a parameter in a nit so name that means that we now have to pass a parameter when we create our dog and just like a function we can create multiple parameters we can do like name age color kind we can do as many as we want okay uh and that works fine now what does this self do so this self actually represents the instance right so if I'm if I call dog equals Tim or dog Tim whatever and I set that equal to Tim well Tim is what's being passed into this self parameter here and notice how we have two parameters but we only pass one thing that's because self always needs to be here except in like really specific cases that we're going to talk about later so when we call self. name we're saying that tim. name is equal to whatever name we put in here and that's the same thing with Fred right so when we call it on Fred then we say well fred. name is equal to Fred all right if we didn't do that and we said something like name equals name if I tried to print self. name that would just crash it wouldn't work because we don't know which instance has what name okay so this self means belong it kind of means like belongs to the in that you're calling it on I'm trying to explain this as good as I can because you you really to understand this I'm going to do another parameter here too okay so self. age equals H all right and let's just print this out and I am self. AG years old all right okay so let's print this out and see what we get missing one age sorry I got to put age in here 55 3 okay so now if I print this say hi I'm Tim and I'm 55 years old hi I am Fred and I'm 3 years old okay so each of these are instances of class dog and they each have a name and an age and you're able to call the speak method on them now with the speak method does is notice how when I call speak it automatically takes self because it has to know what instance I'm calling it on and that way it's able to access the name and the age now in here you can actually change the name and the age so I'm going to create a new method I'm going to say change like this okay and notice how it takes self no matter what it automatically types it in for me and here I'm going to do H all right now what I can do is I can say self. AG is equal to H and if I call let's see here tim. change age and I give it something like five now if I speak you can see that we get hi I am Tim and I 5 years old and we say hi I am Fred and I am 3 years old now obviously you guys can create as many methods as you want you can do call them whatever you want just make sure whenever you create them they first of all have self because we have to know what instance we're calling it on so we can access those attributes all right and you can change these attributes however you like within those methods now I will show you what else you can do okay so say you wanted to access Tim's age and you didn't want to print out like hi I am all this you didn't want to speak you just want to know what his age is well what you can actually do is you can simply print tim. H and now you can see if I run the program we get five down at the bottom and you can do the same thing with name so tim. name and it gives us Tim like that so we're actually able to access the attributes of our object uh from just simply calling whatever that attribute is and in this case its name so whenever you want something to be like public to the uh instance so that they can see it throughout all the methods you need to simp you need to do self. and whatever you want to call it so I could uh say like self dot I don't know let's say Li it's going to stand for list could have a list of like 1 three four and now if I call tim. Li you can see we get 134 and obviously if I call friend. Li well this is going to work as well we get 134 now the main benefit of classes is that you can create things um you can create multiple objects of a class so if I wanted to store like the name the age and a list for 300 dog objects if I wasn't using classes what I would have to do is I'd have to do like dog one name equals Tim and then I'd have to do dog one age equals 5 and then I'd do dog 2 Age equals Fred and you'd have to continually keep doing that with a ton of variables and obviously you don't want that so these classes allow you to create infinite amount of objects of that type class class and have all of these properties and attributes apply to them okay so what else should we talk about here uh maybe creating new attributes okay so attributes are anything that have this like self. name self. AG self. Li whatever and methods are with these defined Keys okay so if I create a new one and I say Define and add uh what do you call it weight okay say add weight I'm going to give it a weight and then we can say self. weight is equal to weight and what this does now is it creates a new instance attribute um that is going to be applied to this dog class now you see it's giving us an error here it says instance attribute weight to find outside of a nit that's because it wants us to Define that inside of this initialization but it's fine you can actually do it out here so now if I do Tim dot add weight and I give it a weight of like 70 okay and I'll print tim. weight like here let's see what we get we get 70 okay now what if I try to print fred. weight well let's see what happens we get Fred has no attribute weight or dog object has no attribute weight and that's because we have not yet added this by calling add weight on our instance Fred okay so I think I'm going to cut the video off here hopefully you guys have a basic understanding of how classes worked it is kind of difficult to explain it if you guys have any questions leave them down below cuz I feel like I might have butchered the explanation on some of it uh other than that in the next video we're going to go over I think inheritance and creating some more advanced methods and talking about how those work okay so if you guys enjoyed please make sure you leave a like And subscribe and I'll see you again in the next one hey guys and welcome to the third video in my python object and class tutorial series now in today's video I'm going to be going over inheritance and this is an extremely important and a little bit more complicated topic dealing with inheriting attributes and methods from other objects I just want to start off by quickly saying though if you guys are finding the videos a bit too slow for you and uh I'm kind of explaining things a lot of time the reason I do that is because I'm not sure the level of person that's going to be watching the video and I want to make sure that the people that will understand quickly can get the information within like the first few minutes and then the people that really need some extra reinforcement have that opportunity to watch through the entire like 11 or 12 minutes and have it explained to them multiple times so if you guys are finding it's a bit too slow um and you want to move faster just fast forward the video or skip uh to the next one if you guys are done with whatever I've been talking about because like in the last video for example I watched it back and I kind of explain the few uh the same thing a few times that's just for the people that need a bit of extra help and that's kind of what I aim to do with a lot of my videos so that people that need help can you know grab that if they want to okay so let's get started and I'm just going to modify this class just delete Li uh we'll get rid of change age and add weight and we're just going to have name age so on like that okay we can get rid of all this stuff down here now what I'm actually going to do is I'm going to create a new class and I'm going to call this cat okay now cat is going to have very similar attributes as dog in fact let's just copy them over okay so we'll paste them like here we have name age hi I am whatever okay now I'm just going to add one thing and in this case I'm going to add let's see color okay say self. color is equal to color okay now this cat object is obviously going to work the same as dog I don't think I need to show you now just take note of what I just did I just copied all of the stuff from here into cat now if you know anything about programming you know that programmers don't like to copy and paste and that you really shouldn't be copying and pasting code so python has actually come up with a solution to what I just did that allows us to not have to do that and that is called inheritance so I'm going to delete all this and I'm going to go back into cat and I'm going to type dog here now what this little bracket up here means is it means parent so whenever you're talking about inheritance you always have a parent or a super class and then you have a child or a like derived class okay and there's a bunch of different words for them they're not really that important just know parent and child is the most basic okay so in this case cat is going to inherit from dog which means dog is the parent class and cat is the child class and it is derived so it's taken from dog so that means if I do class dog and if all I do in here is just type one thing so I type netore uncore and in here I'm just going to put name age and color and I'm just going to do something that's going to look confusing I'm going to explain it after okay super doore netore uncore and I give it name age say self. color equals color and then I create a new object of cat so I'm just going to say Tim equals cat give it a name agent colors in this case we'll do Tim H5 color blue blue cat I know okay so we do that we Press Play No errors okay I'm just going to show you if I do Tim dosp what do you think is going to happen take a guess says hi I'm Tim and I'm 5 years old now how the heck does all this work and what did you just do I know that's probably the question you're asking should probably fix that say color so the way this works is when you inherit from another object or another class sorry you actually inherit all of the properties and attributes and methods of that class so when I do tim. speake you can see well Tim is an object of type cat and Cat well I don't see speak here how does that work well since the speak method belongs already in the dog class and we're inheriting from the dog class it is actually carried on to the cat class and we're able to use it like that okay so Tim dope now what I did here with this super. anit I know this looks confusing but pretty much in the initialization of cat which is unique to cat because it has this added um parameter color I simply called the initialization of dog first which means that when I gave it name and I gave it a age it automatically added self. name and self. AG to my cat object of Tim you see how here I didn't type self. name equals name I didn't type self. AG equals age all I did was call The Constructor method or the initialization method of the superclass and the super class simply means dog um and it did that for me now in this example it seems like well why in the world would you want to do that um that like that doesn't make sense there's not that many lines whatever if you have really long methods and really long classes it makes a lot of sense to inherit so in this example it's hard to show but in long ones you do want to inherit now I want to show you that you can add and overload things from the uh parent class so for example the parent class has speak I'm going to add one more method in here I'm going to say Define let's just say talk okay and in here it's going to say print uh bark cuz it's a dog okay now obviously in our cat class if we want to talk we don't want to bark right and that's what's going to happen right now if we do tim. talk it's just going to say bark so if we wanted to change this we can actually overload this or override this method so if I do Define talk in here I can print and in here I'm not going to do bark I'm going to do meow okay like that little explanation point so now if I do tim. talk like this you can see that we get meow instead of bark and that goes for anything in inherited classes okay so anything that we do in here is going to override whatever is happening in this dog class so say we wanted to change speak we could say Define speak in here and then whatever we put in this speak method would overwrite what's in here now that's not to say that it's going to change if you create a dog dog object so if I do like I don't know let's say gym is equal to dog give it a name give it gy clearly age this an old dog we're 70 okay and we do jy. talk well we're still going to get if I spell JY correctly bark right so we get bark and meow so we don't actually change anything in this class we just say that well if you create a class or if you create a cat object then it's going to have this talk method which overrides the talk method that we created in dog and this is the same if you do something with uh like these attributes so if I didn't like self. name and I just statically type in a name like I type uh Tech okay uh then when we do tim. speak now you would think that I it's going to get hello I am Tim because that was the name right and I am 5 years old but instead we're going to get Tech so it says hi I am Tech and I am 5 years old and that is because although we set name up here to be equal to whatever name we type in the in as a argument uh we are changing it to Tech and that overrides whatever happens in this dog class okay uh so I hope that makes sense now what else can we override from those classes well we can inherit like multiple times and we can inherit different classes from upper class I'm going to talk about the way you would want to do an inheritance okay so the way you typically want to inherit is you want to have one really General class that kind of applies that's a bit smaller that applies like a bunch of different classes so I'm going to delete these and I'm just going to type out them and show you an example of what I mean by General class so if I created a class and I called it vehicle like that okay is that how you spell vehicle I don't care we're just going to leave it like that okay and then I created an initialization in here okay and the initialization is going to take like uh price uh gas and color okay I know these are random but just just follow along self. price equals price self do gas equals gas and self do color equals color okay now I'm I'm just going to give it a method I'm going to call Define fill up tank like this okay and what's to say self. gas equals and we're just going to say that each gas tank has a maximum of 100 okay say Define um empty tank and this is just going to say self. gas equals z and we're going to say Define gas left and this is simply going to return self. gas okay and the reason I have this is because well in all vehicles we're probably going to want to have um gas right all of our vehicles are going to have gas if they're not electric obviously we're not going to deal with that for now um so fill up tank empty tank and gas left is probably something we want to know for all of our different Vehicles now for example if I create another class and I say class car okay and car is going to inherit from vehicle like that okay and all we're going to do for the init is we're just going to call the vehicle init so how we do that is do super doore uncore anitore uncore and obviously this needs now a price gas and a color so we're going to pass it price gas and color like that and then that's our initialization and in car all we're going to have is we're going to have a method and it's going to call let's actually let's add one more thing here speed okay self. speeed equals speed okay and then here as a method let's just have like beep okay and all this is going to do is simply print beep beep okay now I know these aren't great examples but just follow along so what we have now is we have the vehicle class okay and it has these things that do with gas and obviously gas is going to work for all of our different types of vehicles and and then we create a car class class that inherits from vehicle and in here all it does is it has an extra attribute called speed and it has a method called beep now if I create another class instead of car I want to do truck now truck is not going to say beep beep it's going to say honk honk like that okay and instead of having self. speed we're going to have self. tires okay equals tires because that's a a property that we're going to care about for our trucks because sometimes they get like six tires 18 you know what I mean that's what I mean by a truck okay so you can see that we have a really General class vehicle that simply has a cut a gas and a price and obviously within our truck and car class we're going to care about those attributes so price gas color but in truck we care about tires and when we click beep we want to say hwk hwk and for car we care about the speed that the car can go and when we uh call beep we want to print beep beep okay so that is an example of where you would use inheritance I know this is a really small example a lot of the classes you're going to end up building are going to be like massive and inherit from uh like other classes and you're going to have like large files full of classes but this is the best example I can kind of give you of when inheritance would be useful and same thing if I wanted to do like Define motorcycle then you could do the same thing there and for Wheels you do like self Wheels equals 2 like stuff like that okay so I think I'm going to end the video here hopefully you guys have an idea of how inheritance works one quick thing if I wanted to I could inherit from car as well so if something is inheriting from something you can also inherit from it so that would mean that now truck has all the attributes of car and all the attributes of vehicle because well car has the attributes of a vehicle so since car has it we're inheriting from car truck is going to get it as well just wanted to add that in before we end anyways make sure you guys leave a like And subscribe and I will see you again in the next video hey guys and welcome back to another object and classes tutorial video in today's video I'm going to be going overloading default python methods and why these are extremely useful now if you don't know what I'm talking about just stick around for one second and I will explain it so first of all I just want to talk about what I've already coded here I just have a very basic point class and you can see that our Point object has three kind of attributes in x y and then our coordinates which is self.x and self.y we have a very basic method that can simply move us by x and by y we type it in okay I've created four points down here and these are what we're going to use to kind of test out some examples that I'm about to create so in Python uh remember in my first video I was talking about the fact that if you create integer objects so for example I say like IAL 5 and like zal five if I wanted to add these together all I simply have to do is well put a plus sign right and python knows that this plus sign means Okay add these two things together now how does it know this and how does it know what to do well with integers is pretty straight straightforward but what if we start doing things like strings right if you do s and then you go like 6 7 8 how does python know how to add these two strings together well it would make sense to it just appended on top but someone actually had to code this functionality in and that's exactly what we're going to be doing in this video except with our custom Point object okay and you'll see what I mean in just a second so pretty much what we want to eventually do at the end of this video is be able to add multiply subtract um and compare points without having to reference their attributes outside of the class so right now uh if I do P1 plus P2 our program is going to crash because it doesn't know what that means but by the end of this video we're going to be able to do that okay so that's what I'm going to show you right now so in Python there's a bunch of default kind of operations and methods that you can apply on classes and by default uh they're not defined right on our point class if we try to add to things right now that doesn't make sense so what we're going to is add that method so to do this to add the add operation you're just going to do Define underscore add okay and then in here you need to give another Point object so what happens when I try to add a point and another Point object well whatever we're going to return a new Point okay that is simply equal to self.x plus p.x and then self.y + p.y so what this is doing is since we're passing another Point object so when we do like P1 + P2 P2 becomes p and P1 becomes self so we're going to grab the coordinates of P1 add them to P2 and return that in a new Point object okay now the same works for subtract multiply and Division and for a few others as well so I'm just simply going to copy this okay and paste it one more time and instead of add now you could probably guess I'm going to put sub and what this is going to do is allow us to subtract points so it's going to be the exact same except now we're simply going to subtract the coordinates now with multiplication this one is simply Define underscore uncore Moore underscore and this going to allow us to use the ASX or the star uh to multiply two different point objects so same thing it takes a point and in this case when we multiply points I could return a new point with multiplied coordinates but the way it actually works if you know anything about vectors is we're simply going to return the scalar product which means you multiply the first two x coordinates get a value in this case we would get nine and then you actually add it to the ycoordinates multiplied together so in this case we'd have nine um what do you call it plus 8 and that would give us 17 we're not returning a new Point object it's a scaler or like just a number value okay so what we're going to do here is we're going to return self.x multiplied by p.x plus self.y multiplied by p.y and those are the three that I'm going to stick with right now and I'm going to show you a bunch more that we can use to compare Point objects using greater than equal then sign in just a second so I want to test if this is working so let's create a new point I'm going say 0 five is equal to p1+ P2 and I'm going to say 6 is equal to P4 minus P1 okay and then we'll even go as far as creating p7 and multiplying P2 and P3 just to make sure everything's working so now I'm simply going to print to the screen P5 P6 and p7 and let's see what we get so you can see here I get main point object main point object and nine now the way that this worked and the reason that we're not actually getting a coordinate value is because I have to show you another method that we can use so that this was actually going to give us something meaningful because right now when we point print out our Point objects right cuz 0 5 is a new Point object cuz when we add point1 and point 2 we have returned sorry a new Point object right so if we want to make this meaningful and not just show us the address in memory uh where the point is stored which it currently is right now we need to add another method and this one is called Str Str okay and what this is going to do is this is going to be called every time we try to convert our Point object into a string so when we try to print our Point object it automatically looks for Str Str and and if it doesn't find it it gives us this kind of uh gibberish right here but if it does find it it's simply going to well use the value that we returned so in this case we want to return I think we'd want to return from string uh probably the self dot coordinates right so I want it to look something like this we have brackets and then Plus St Str and then self.x plus a comma Plus St Str self.y and plus and then another bracket like this okay so now if I try to print5 6 and 7 you can see what we get and there we go so now instead of getting that gibberish we get 66 3 and 3 now keep in mind you can make this anything you want but you do have to return a string value here for this to work okay so the next methods we're going to talk about I'm just going to put them above string here just for good practice is going to be comparing two points so this is great now we can add we can subtract we can multiply but what if we want to compare so what if we want to see if0 one is greater than 2 or if 3 is greater than point 4 well how do we do that we first have to determine how are we going to compare points are we simply going to compare the x's and the Y's or are we going to find like the magnitude of a point like what are we going to do to compare which is larger in my case I want to find the length of a point from the origin so in this case the way this would work um I think I can just bring up a little grid program here and just draw it for you quickly so if you have an origin like this okay I'm just using my mouse right now and you had a point here and a point here well from the origin this would have a distance and from the origin this would have a distance obviously this could be like a distance of seven this could be a distance of two and seven would win right because we don't really care about the negatives if you had something all the way over here with a larger distance then well we would want that to win right um so that's the way that we're going to compare them and I'll talk about that and how we do that in one second so to compare we have four major comparisons I think that we can do anyways I'll type them and we'll see so one of them is greater than and that is GT okay and then you can do self and you also need another Point object like this another one is greater than or equal to and greater than or equal to is simply GE okay and then same thing we need P we have less than so Define and you can probably guess LS or sorry LT what am I saying less than and then we also have less than or equal to so l e like that and we have one more and this is simply equal to so this is if we do the double equal sign then it's going to give us a comparison now in these methods we need to return a true or a false value so in greater than remember the way I said I wanted to compare them is to get like the magnitude of the point from the origin so I'm just going to add a method in here I'm just going to call it uh let's do length maybe okay and then in here I'm simply actually we don't need to take anything we're just going to return the math.sqrt and I'm going to import math right up here and this is simply how you get the length from the origin okay of self.x to the power of two plus what am I doing self.y the exponent to and this is going to give us the length Okay so import length so when I'm doing greater than I want to see if return self.x or what am I saying self. length is greater than P do length like this okay and I believe we do actually need these square brackets here so all this is going to do is it's a Boolean condition it says well if the length of ourself is greater than the other length well then we're simply greater than so let's just copy this and put it in here and in this case we're just going to do greater than or equal sign because this is greater than or equal to we'll copy this again change this around to less than and one more time and this is now just going to be less than or equal to now if we're seeing if two things are equal to each other well that's pretty easy as well all we can do is simply take this or actually the way we're going to do this is just see if the coordinates are the same because if we try doing the math. square root and we get like a large decimal number sometimes decimals kind of mess up in Python and they don't get the same Precision so let's just return if self.x equal equal p.x and self.y equals p.y because that would mean that they are the same points right okay so let's do some comparisons now so let's just simply print if P1 equals equals P2 and then we'll print if P1 is greater than P2 and we can print if P4 is less than or equal to uh P3 okay and just test these out okay so we get false true and true and you guys are welcome to mess around with these and kind of figure those out for yourself so I will show you I'm not going to go through all of the methods because there's a lot of ones that you can overload but I'll show you how you can have a look at all of the different methods okay so I'm just going to pull up a web page here that has like a large list of all of the kind of builtin methods that you can override or like what do you call it overload um there is a way in Python to like see all of them and print them to the screen but I completely forget the command so I apologize one of you guys knows that command please let me know in the comments because I've been looking for it and I can't find it but anyways you can see here there's a ton like I think there's like a hundred or something of builtin ones you can use like ad sub Mo div true div Flor div can read through here and see what they all do some useful ones I will mention is probably Len I probably should have talked about that one but it's if you call the Len function on something so actually I'll show you Len really quickly just because I feel like I should have talked about so instead of doing length here I could have just done Define underscore uncore lencore uncore and what this would have done now is if I call like Len of P1 it's just going to return uh whatever value I have here so math. square root okay that's like a really useful one too so I don't know why I didn't talk about that but anyways so we go back to this page for one second and see real numbers slice slice can be useful if you're do deal with kind of like list objects that you're creating items and slices you can go through all these and kind of read them yourself I'm not going to talk about all of them CU I'm sure these you guys probably won't end up using very much um the ones that are very important are the ones I talked about yeah so you can see builtins like there's something you can do with like dir builtins to see them all uh and yeah I'll leave this link in the description in case any of you guys are interested in having a look at these but there is some way in Python again if you know that way please let me know okay guys so that's been it for this video in the next video I'm going to be talking about static and class methods and then in the future video I'm going to be talking about private private and public classes in Python so if you guys enjoyed the video please make sure you leave a like And subscribe and I'll see you again in the next hey guys and welcome back to the fifth video in my python objects and classes tutorial Series in today's video I'm going to be talking about class methods static methods and class variables now these are very important and very useful especially if you're coding large projects with multiple different classes and they are fairly complex but I'm going to try my best to explain them right now so pretty much you can see here I've already set up a class and I've already actually coded all the methods and class variables and all the stuff we're going to deal with and I'm just going to go through and talk about it because it just saves a bit of time and makes things a bit easier so first of all let's talk about class variables Now to create a regular variable within a class you can see that we have something like self. name equals name we've been over this we know how this works now when you create a class variable typically you do this at the top of the class and you just simply write like a variable just not inside of one of your methods so you can see up here I have a list says dogs equals and then a list if I wanted to have something like X I could say xal 5 or x equal 5 and I could put that at the top of my uh what do you call it class and then to reference that you have to be inside of the class so this sometimes is useful if you want to have variables that every object in your class is going to need to use and you don't want to have to do like self.x equal x within your initialization and it's just better practice to put variables that are going to be like statically uh used inside of the class if that kind of makes sense so the way that you reference these variables is the same as you would reference uh an attribute within your regular class so you can see here like I do self name equals name to create a new variable self. name when I want to reference it later I would have to type self. right it's the same way to reference these class variables so you can't or I guess you could but you wouldn't want to have um the same name as this like in here and if you did that it would just overwrite this uh so you'll see what I mean in just a second but anyways what I'm essentially doing here inside of my initialization is I'm appending every single dog object that we create into the list dogs now this list dogs be begins to the class dog not to the actual instance of dog so Tim and Jim if I reference dogs and I print that out will be the same value it doesn't change dogs or like dogs is not specific to Tim and it's not specific to Jim it's specific to the entire class uh for every dog object so it's the same for all that an XC like five is going to be the same for obviously Tim and Jim and all other dog objects I hope that kind of makes sense we'll walk through it in just a second okay so let's just first of all just print and figure out like what's the point of this uh class variable like what can we do with this well first of all the good thing about class variables is if you want to access them you don't have to have an instance of the dog object to do so so to see this typically like if I wanted to call so if I remove this class method I remove the static method you want to call method on a dog object you'd have to do the name of the dogs like Tim and then Dot bark or Tim do uh I don't know whatever else that we have like do add do add weight whatever you want to do okay but in this case we can just actually call it on the name of the class so if I do dog Dot and then you can see it's already coming up here do dogs like this we should be able to print this to the screen and you can see that we do end up being able to print this to the screen with a dog object and another dog object so the main difference here with class variables is that you can call them with you can still call like I could still do tim. doogs but it I can also call them with the actual name of the class and that's what makes it useful so you don't have to have an instance uh to call that what do you call it variable if that makes sense and I guess that's all I'm going to explain kind of for class variables because they're not that complicated and if you play around with them you should be able to figure that out figure them out okay so next we're going to talk about static and class methods now you can see here I have at static method and at class method these are known as decorators and you put these above your method like directly above them like this if you want to indicate that they are going to be a special type of method and that's what these two methods are so I'll start I'll first start talking about class methods because we kind of already have touched on it with class variables so the way that a class method works is that you can actually call it on simply the name of the class so you can see inside of here uh my parameters I only have one thing and it's called CLS it's not called self it's called CLS what this this means is the name of the class so if I remove Tim and Jim so I guess I can just comment that out like that whatever then what I can do is I can say dog Dot and then what do you call it numb dogs like this and this will actually work and you can see that I'm not calling it on an instance or like of the dog class or like a object of dog class I'm just simply calling it on the class so if I do this you can see that it gives me zero and that that works right now again you can call it on uh what do you call it like you can call it on an instance like if you say Tim equals dog and name Tim I can still call it on Tim and this is still going to work fine it's just that you don't need to do that right you can do it by just calling with the name now static methods are a little bit different they actually don't need the class to uh to be called so so it doesn't pass in the class so that means that you can't reference anything within the class so the whole point of having this class passed in when you call this method is so that you can use class variables and you can use other methods with in with inside the class so for example if within numb dogs I wanted to use a static method or I wanted to call an initialization or I wanted to do something that revolved around the dog class I would need the class name right so that's why it's passed through but with static methods we only pass whatever parameters we want so we don't have to have a self we don't have to have a class and we don't even have to have any parameters but in this case I'm giving one parameter n so I'm going to show you how this works so I've completely removed any instances of dog in my program there's no objects we're not printing anything whatever okay what I'm going to do now is I'm going to call Bark without passing through any object or any class name and you can see how this works so what I have to do to do this is it has to know obviously where bark is right so it's in inside the dog class so I have to start by typing dog but then I can type bark like this and give it a number and you can see here I just wrote a little comment barks's end time so if I run this you can see we get bark bark bark bark now notice that with inside this bark class I don't do anything like I don't touch any attributes I don't touch any class methods and there's actually no way for me to do that so if I were to try to say I wanted to get the value of the length of dogs right with inside this static method well I would be unable to do that because I don't have self right self is it's not working I don't have a class so how am I going to be able to call a class um variable or another class method I actually can't do that so the point of static methods is when you're just going to be using them as a function but you want to organize them within a class so a really good uh use of static methods for example is say you were created like a class and you called it math okay in here instead of having like an initialization ation and all this stuff you just had a bunch of static methods now why would why do you put them in this math class why not just create them as functions well the thing is you want to be able to import modules within python you guys have probably seen this before right you can import other files that you've created into like main files so when you create a bunch of um like math methods or whatever what You' do is you'd say class math and then you just say like at static method and then you do Define and you'd say like add like this okay and you say like X and X2 and then you could return x + X2 and that way you don't have to create an instance of math you don't have to say like m equals math right you can just say math. add give it two values and it will return it to you and you can do math. subtract and you can organize all like the functions that you wanted to use within that class and then class methods right are more used for like if you want to access class variables without having to pass in an object because it's just going to automat pass whatever the class name is that you're giving it I hope that that makes sense now these I'll touch on these really quickly in case I didn't really talk about them these are known as decorators um I know it's kind of a weird name but pretty much this just denotes the fact that you are creating a class method and you are creating a static method because otherwise it's probably going to get mad at you and tell you that you need to type in self or you need to type in like another parameter or something like that so by doing this not only is it a visual representation for anyone that's reading your code but you're also so just um telling python that this is going to be a static method this is going to be a class method obviously you can have as many static methods as you want as many class methods as you want and they're actually really useful so anyways I'm going to wrap up the video here if you guys have any questions about any of this stuff make sure you leave a comment down below and in the next video I'm going to be talking about public and private classes in Python anyways if you guys enjoyed the video please make sure you leave a like And subscribe and I will see you again in the next one hey guys and welcome to the fifth and final video in my python classes and objects tutorial Series so in today's video I'm going to be talking about public and private classes and how to import your own classes from other files into like a main file uh you'll kind of see what that really means as we move along so the first thing to talk about I guess would be what is the difference between public and private so I've brought an example here I've just kind of written this random example in Python to try to illustrate this to you so in other programming languages there's things known as private and public classes now private classes typically can only be used within the same file or within like a certain scope where public classes are accessed or can be accessed by everyone so private kind of means within something like it's not accessible outside of that whereas public means it's accessible everywhere now I have just a definition I found on Google that I'm just going to read because it's the best way to kind of explain it and I can talk about qu it after so in terms of java and we'll talk about this in a second uh public versus private class and this is the same for most languages means this so public is a Java keyword which declares a member's access as Public public members are visible to all their classes this means that any other class can access a public field or method further other classes can modify public Fields unless the field is declared as final okay so what does that all mean and why did I just give you an example in Java well in Python there's actually no such thing as private or public classes there is conventions that we use to declare like a pseudo like private or like a public class um but there's not really anything restricting us from using private classes so hopefully I can explain this but pretty much this first class up here is private and what makes this private is the fact that we have one underscore at the beginning of the class name now in python or in Java for example when you create a class you would do like like you could do something like this like public static class and then that would mean that this is a public class you could say like private class now in Python we don't have those so the way that we Define this just as a convention is you start with one underscore and then the class name now to create a public method or like attribute of a class it's the same thing you just use one underscore so for example you can see I have two display methods here one is a private method as it has an underscore and the the other one is public as it doesn't have an unders Square again like I've said it doesn't actually matter like you can still use this the regular way you'd use method by calling doore display but by putting this underscore here you're essentially telling other programmers and even maybe yourself later on in the future not to use this and you're saying this is private I don't want you to use it obviously if they decide to use it that's their decision but it's just telling you like don't mess with this don't use this it's private for a reason and typically when you private things that's because you don't want other classes to be able to use it and like mess with the class or do anything like that so same thing here when you create an entire class as private that means everything within the class is also private so I'm going to go over to this file now and you can see I have one file mod and one file tutorial one um now mod is this one that we just went through tutorial one is a new file and you can see that I'm actually importing mod uh so I'm importing this file now when I do that what that does is Imports all of the classes and functions that are within this file so for example if you wanted to organize your program you would have a bunch of different files that contain a lot of different classes and you would import them by simply typing this at the beginning of like your main script this way you can keep everything organized clean and neat and then you can see from Mod I'm importing not private so the way that this works in terms of importing individual classes is you type the name of the Python file in this case mod and then the name of the class or function that you wanted to import and in this case I want to import not private so I can simply do that now say I remove this line I say import from Mod import not private I'm still able to access not private just in a different way you can see now this goes red the way I would now do this is I'd say Mod Dot not private because it's saying we're looking within the mod file for the class or function not private but it's just easier to do it this way so that you don't have to type Mod Dot before all that stuff okay so I'm just going to show you this working I guess I have uh this not private class you can see we have two displays and when I run it we get high now I also want to show you the fact that although I told you that this class is private and that this method is private that we can still actually use them so if I simply do testore display you can see that this now works perfectly fine and it gives us hello so I just felt like I had to make this video although it's not really an important aspect in Python just because if you guys are going to be learning different programming languages you have to understand the difference between private and public classes it's very difficult to illustrate in Python because there's nothing that's truly public or private but just know that if you ever run across some classes that have underscores at the beginning of the name or underscores before method names for example like anit then that means that they are typically private or want to be private at least so you should probably not mess with them and not use them that goes for you as well if you are programming and you want to create stuff that you don't want people to kind of mess with just put an underscore before the name it's just a typical convention in Python uh to do that to create a private or public class anyways that's been it for this video and for the series I hope that you guys did enjoy the series and you did learn a lot if you did please consider subscribing and hitting that like button as it would mean a lot to me hey guys and welcome back to another YouTube video so in today's video I I'm going to be starting a new um tutorial series on intermediate programming with python um so that being said a prerequisite for these videos is going to be that you know a little bit about python you know the basics you know if statements for Loops lists so on um as I'm not going to be reteaching and touching on a lot of those aspects um which I'm going to consider trivial now um I'm going to be teaching some more advanced topics so if you guys are interested in that make sure you watch until the end of the series and you go through all the videos as a lot of the stuff I'm going to do is going to add add on um as we keep going on videos so something I show in the previous video I'm going to add on to it in the next one um and these videos are going to be a really good way to enhance your programming knowledge and to learn a lot more about python that being said a lot of the stuff I'm going to show here is specific to python um and probably will not work in other programming languages that being said let's get ahead and go ahead and get started with our first video and this one is going to be optional parameters now this is probably one of the simplest topics that I'm going to cover in this series but I figured it would be a good starting point so let's just um go up go ahead and go over what a parameter is um so you should already know this but just to catch some of you guys up I have a function here I've defined I call it funk it returns X to the^ of two um and our parameter in this case would be X anything in this bracket is a parameter note you can have multiple parameters so I can have x y z and so on now what we want to do is we want to create something called an optional parameter now again sorry the argument here um so when we I call my function I said call equals Funk five our argument five is passed into the parameter x x is used here and then if I run my program so I'm running it here uh oops have to drag my console over it's on a different window right now oh and I've accidentally opened up something else now have uh one second guys sorry about that okay I have my console which is here uh it prints 25 to the screen uh like expected okay so now we want to create something called an optional parameter so the the whole point of an optional parameter is so that we don't always have to keep typing in parameters um especially if we have uh more than one that we have to type in it can get tedious so the way that we can do this and it's actually really simple and it's extremely useful and I'll show you in a different example later simply beside your parameter so in this case X just put an equal sign and then put what you want it default value to be so in this case I'm just going to put uh one okay so now what what happens is if I call my function and I don't give it a value for x it's simply going to use one so we can show that so again run the program and I get one because one to the^ of two well is one and I didn't put anything in here and I didn't get an error now notice if I get rid of this equals one and I try to call we get an error because it's missing a uh potential argument X right so let's put that back xal 1 now what happens if I do put something in the brackets here of my function call so for example I pr x 5 when I run the program now we get 25 so if you ever put anything in uh your function instead of the uh like default instead of just leaving it blank in this case then it's going to overwrite this default parameter and it's going to make x equal to 5 instead of one now you might say well why is this useful I'm going to show you an example in just a second but I want to show how you can use multiple optional parameters um and how you can mix them with nonoptional parameters so let's just rewrite this function um and in this case I'm going to take two parameters I'm just going to say like word and currents or let's say frequency like this okay and now all I'm going to do in this function is I'm simply going to print to the screen word multiplied by frequency like that okay and then here in my function call my word I'm going to say is Tim and frequency five now this should just print to the screen right do this and it does we get Tim Tim Tim Tim now what if I wanted to make the frequency um an optional parameter so all we have to do here is I'm going to change my frequency to be a default of one so that means now I have a parameter that's not optional which is word and a parameter that is optional frequency so when I run the program by just putting in my needed parameter I get Tim and just one time because that's the default value of frequency again we don't get an error um like you might expect and then same thing if I want to change the frequency so maybe I want to make the frequency 10 all I do is I type in a number for frequency so corresponding and then when I run the program I get Tim and then 10 times like that now what happens if I do something like this and I put 10 here um instead of frequency well you'll see what happens we get 10 because 10 now is word and frequency is 1 and 10 * 1 well is equal to 10 okay so now let's go to multiple optional parameters um so now I'm going to say add and frequency and I want add to also be an optional parameter so in this case I'm going to say add is equal to 5 frequency is equal to 1 okay um so what I'm going to do now is I'm just going to say word is times frequency plus add like that um and now in this case same thing I'll just do word in this case I'll say hello um so our default value for ad is five our default frequency for uh our default value for frequency is one so we should have 5 + 1 um which is six multiplied by word so we should get hello six times and we do and now again I can put put in a value um for add so in this case I'm going to say add is equal to zero frequency is still going to be one so now I get just one time to the screen hello so the way it we're is when you have optional parameters is say I wanted to type in a value for frequency but I wanted to leave add as the default value I'm not actually able to do that because of the order in which I've set these parameters so if I wanted add to still be five but I wanted to change frequency I would have to put five for ad and then I could put a value for frequency like three or something like that okay um and again if we show this ad is going to stay at five frequency is going to be three so we should get hello eight times in which we do um now if I wanted to change that around um and I wanted to say okay well I want ad to always be defaulted to a value like five and I'm hardly going to change that but frequency is going to be something I change a lot when I use my function then we would just flip these around so we' say frequency equal 1 add equals 5 like that so now this is going to uh go to frequency and this is going to go to add um like so I hope that makes sense so now I'm just going to go down and I'm going to show um some better examples to why this is kind of more useful so I've just created this class here um called car all right and I have you can see a bunch of parameters so I have five up here um not including self and then just one here in its method called display now these optional parameters can be used inside of methods as methods really are just functions that apply to a class right so I'll show you right now how this class kind of works um I've just created a new object called whip it's a new car object and we have four Fusion 2012 new um and these are the parameters that it takes right so it takes the make the model year condition and kilometers all of these are required I need to type these in no matter what the next one that I have my method is display um and what this is going to do is simply just print out to the screen um one of two messages if show all is equal to true it's going to print out everything including the condition and the kilometers of the car if not it's just going to print out the make model and year of the car so let's watch this uh run on the screen so this car is a Ford Fusion from 2012 it is new and has 0 km um like so so you can see that this is working well now what if I wanted to say um I want condition and I want kilometers to both be optional parameters so typically when you buy a car most people buy new cars so I'm going to say the condition is going to be defaulted to new and kilometers is going to be equal to zero because if you're buying a new car well then kilometers should be equal to zero so only if um I want to I'm going to change that so now same thing here if I go like this and I run the program we should get the same thing so this car is a Ford vision from 2012 it is new and has zero kmers and indeed we do we didn't need to type in those parameters because again they're optional um next one I'm going to show you is down here in display same thing I can set this equal to something like true so show all equals true and now when I call my display um it automatically shows all unless I specify otherwise by typing in false like so and then we get this car is a Ford Fusion from 2012 now this is really useful if you have a lot of different parameters it is especially useful when you're typing and working with classes so that's why I wanted to show you this example I hope that you guys are able to implement this in your programming um anyways that's been it for this video uh make sure you guys stay tuned for the next one which should be coming out in just a few days hey guys and welcome back to another YouTube video in today's video uh the second video in my uh intermediate python tutorials I'm going to be going over static and class methods um so pretty much these are just uh different things you can use uh within a class uh and I'm going to explain what they do and why they're useful so without further Ado let's go ahead and get started um so because these two things uh methods obviously a part of a class use a class we need to First create a class so in this instance I'm just going to make a class I'm going to call it person um it is of class object and then I'm just going to start off by making my initialization uh method here give it self I'm also going to give it name and age and we move to the next line so let's just assign our variables here here self. name equals name and self. AG is equal to H okay the next method I'm going to make um this one is going to be called get population this going type self um actually here I'm going to type CLS and I'm going to get into what this does uh in a little bit and I'm going to return CLS do population and now I just remembered that I actually forgot to make this up here I'm going to make a class variable um where I'm just going to say population is equal to 50 like so okay one more method this one I'm going to call the fine and then is adult and then in here I'm just going to put age I'm going to say return age greater than equal to 18 okay I'm also going to make one more method down here just to show you the difference between a bunch of these and I'm just going to call it Define um display okay and so it's going to take self um and that's actually all we need we're just going to print to the screen in this one we're going to say self do name and then comma is and then comma self. AG comma years old so this should if I did this right it's going to say whatever the person's name is is and then their age years old so for me 18 years old so now let's create a new instance of this class down here um so I'm just going to call this one new person going to set it equal to a person whose name is Tim and whose age is 18 like so and now I'm just going to go through this class and kind of uh go through what we've actually done here so pretty much what I've started off by doing is I've created a class variable population equals 50 I've done my uh Constructor method um which is just going to initialize my variable's name and age and then I've created two methods in here which actually aren't done and they're called get population um and is adult now the name of this video is class methods and static methods so one of this is a class is a class method and the other one is a static method um go ahead and guess which one you think is uh which so I'm going to tell you right now the first one is actually a class method and the next this one here is a static method and the way that we denote these in Python is by putting something called a decorator above these methods um so it's just an at sign and then the name uh so in that case static method or class method in this case static method now what is a class class method and what is a static method and the best way to explain these is to use an example um so pretty much a class method means that you can call it on any um instance of a class so you don't need to have uh for example I don't know what to say you don't have to have an object already created of that class you can just call it on the class so for here for example I've done something like new person and it typically if I didn't have any other um any static methods or class method I would just say like new person. display or new person.get population what this class method allows us to do is do something like this so we can do person.get population now person is simply the name of our class it's not the name of an object of that class so new person is an object of class person whereas person is just the name of the class and if I do that and I print this to the screen so I print person.get population assuming I have no errors here um oh it says it's cuz I haven't put uh the little brackets here my bad doget population it pops up to the screen and it gives us the value of 50 and again we didn't have to create an object to use that method because it is a class method um I hope that makes sense I'll try to explain it maybe one more time really quickly pretty much you don't need to create an object of the class to use any methods that are decorated as class method now also in class method all that's passed to the class method um is well the class because it's not actually an object we don't need this self parameter here like we need um in our initialization method and in any other regular methods that we have um we just need one variable we can call whatever we want in this case I call it CLS which is going to store well what class you're getting pretty well and then we can add any other parameters that we want so I can add X could add y um Ely many after that we just need to make sure that we have at least one in there because for example if I remove this um CLS like that it's going to say take zero positional argument but one was given because the class name is automatically sent into um this method when we call it okay the next type of method is static method um and this one is similar to class method um except it can be called without using that class I want to say so doesn't take a self parameter and it doesn't take a class parameter um so you don't actually need anything in here in this case I have age just cuz I want to be able to compare age um but it doesn't need any parameters if I did something like this it would work fine so the way we denote that again is with the at sign static method just above where the method is defined um and to use this method I can do something like person do is adult and then in here if I put something like five we're going to get back the value of false which you can see here if I do a value like 21 we get a value of true now why is this useful what's different than class method um static method is just used when you don't need self and you don't again need that actual object and it's just a good organizational way of storing a bunch of methods so for example if you had like I don't know maybe a math class that you created um and you wanted to have a few math objects and then you wanted a bunch of static methods that were all stored under math so for example when you use the math module in Python you use math.round or math. so on that's an example of possibly a static method or just a function within the math class um you want to organize all your static methods which in within that class um so you would call like whatever the class name is math and then dot the method and then you give it an argument and it'll return that and work fine uh I hope that kind of makes sense it is hard to explain if you don't have like a lot of good use cases for it um class method meod it just takes the actual um class and then it can access anything within the class um that's public to the class so here you see I had do cs. population and population is a variable defined up here this static method it can't access this population um variable because um it doesn't have access to the class name right it it doesn't it's not pass that information um so it can only use the parameters that you pass it it can't use any that are defined within the class um and that's really the best way I can kind of explain it to you guys um and a good way to understand how to use this um and why they're useful is to use them in your own um use cases so again static method um You can call just by calling the person uh the name of the class and then that method um given whatever parameters it doesn't need any parameters if I do something like this and I'll just put like five greater than or equal 18 this still works um you don't need any parameters whereas a class method you need one parameter at least at minimum um which is going to be that class name and it has access to anything within the class so any variables you define um or other static methods within like within this class method you could call another static method um and so on so yeah I hope that makes sense to you guys it is kind of hard to explain the static and class methods but they are really useful um especially if you're trying to organize things um and when you get further on with object orientated programming in Python you definitely notice that you will use these a lot anyways that's been it for this video um please make sure you guys leave a like on the video and subscribe and I will see you again in the next one hey guys and welcome back to another YouTube video in today's video this is the third video in our uh intermediate python uh tutorials and I'm going to be going over the map function um so pretty much the map function is an extremely useful tool that allows us to well apply a function to list and then create a new list um with those new values and you'll understand what I mean as I go through an example here so before I even start using the map function I want to just present us with a problem um that the map function can solve and this is kind of the best way to understand it so I'm going to create a list um I'm just going to call it Li of integers up to uh 10 like this so 9 and 10 okay um and now I'm going to create a function and I'm just going to call it funk and it's simply going to take one parameter X and all we're going to do is we're going to return x to the exponent x very simple okay now what this problem is it's very simple um I want you or I want to be able to apply this function X to every value in the list here so one uh to 10 um and then have that stored in a new list so intuitively the way that you would want to do this U or the way that you would try to do this at least is you make something like new list is equal to this you'd write a for Loop you say 4X in Li and then You' say new list. aend um and then you would put well Funk and X like that and then if you printed out your new list you would get that value I don't know why print is showing up in a different color now but anyways um and there we go so we get 1 4 27 and so on and so forth okay um so now what we want to do is use the map function to do this faster so this is a very valid way to do this this works fine but I can actually shorten all four of these lines into one um by using the map function so let's go ahead and do that now so I'm going to start by typing uh actually we're just going to print because I want to print first starting with I'm going to do list um like that and I'll tell you why in a second I'm going to write my map function like so uh and now your map function takes two arguments um so it takes a function and it takes a list so let's give it our function which in this case is going to be called Funk and then let's give it our list so I actually don't need these double brackets here excuse me let's give it our list which in this case is Li so let's talk about what this really is doing right now so the map function takes a function which is Funk so the name of our function and it takes a list which is Li what it's going to do is it's going to apply this function to every element in the list and we can watch this happen we run the program and you see we get the exact same value as we did before um and that's extremely uh extremely useful in Python because a lot of times you want to apply a function or even possibly multiple functions onto um a VAR or onto a list or every element of the list and you don't want to have to type out that whole for Loop yes you can do that it works fine but the map function is just a shortcut to be able to do that um so let me just show you now uh maybe a few other examples that we can use so like using this map function there's another way that we can create this and it's totally preference which one you want to use I like using map just CU it's kind of cool um you can also use something called list comprehension um and this is something I would have shown in some my previous python tutorials uh like from way back like years ago on my channel but I'll go over it quickly now um and the way that this works is you can do the same things you can say funk X for X in Li now this is actually going to give us the exact same value as what we have up here with this map uh function Li for example because what we're going to do is we're going to say we're going to take this right here so whatever this expression is um and we're going to do it uh for every value of x in the list so that's exactly what this map function does um and it's just going to turn it into a list because we put our square brackets here so if I print this out see we get again the same value um and that's how list comprehension works now for list comprehension you can also add um like an expression in here so I can do something like if um let's say x uh modulus oops modulus 2 equals equals z and now it's only going to do this uh or put this into the list if x is divisible by two uh syntax eror oh I forgot my square bracket here my bad I don't know how even got rid of that let's run that oh it's because that is why all right excuse me on that okay so now we get 4 2 5 6 so it's only doing it for the even numbers of X um so yeah those are two really cool ways to kind of change a list or modify them apply a function to them in Python say Obviously you might want to use a function that's more advanced than this um this is just for a basic example and if you wanted to apply maybe two functions to it you could have X be changed here and then you could return like function two of x to the X here and then that would put um that value obviously in the map so again map takes two parameters a function and a list um and it will apply uh the function to every value in that list I hope this has been useful for you guys if you did enjoy the video please make sure you leave a like And subscribe and I'm going to be moving on to some more complicated and um other examples using map and other functions um in the next video so make sure you stay tuned for that hey guys and welcome to the fourth video in my intermediate python tutorials and in today's video I'm going to be going over the filter function so this one is very similar to what I did in the last video which is the map function um but obviously it has a few differences but the filter and map function are nice to learn back toback because they can be used together um and a lot of people do use them together when they're making uh programs so I'm just going to go ahead and start off by typing out two fun functions here uh that we're going to be using in our examples so I'm just going to make one function called add seven which is simply going to return seven and I'm going to make another one which is called is odd and it's just going to return if the number is an odd number so the way we do that again is X modulus 2 does not equal zero like that okay pretty straightforward now I'm just going to make a new list in this case I'm just going to go 1 2 3 4 5 6 7 8 and nine and then we'll even add a 10 in there and and now I'm going to go over uh what the filter function does so I want to assign our uh a new variable here create a new one I'm just going to call this B and I'm going to make it equal to list filter which is the name of our function just like this and now filter function actually takes the same arguments that our map function did in the last video it takes a function and it takes an iterable uh list so we can take a string as well um but typically we just pass it a list something that's iterable and that you can go over um so what I'm going to put in here for our first function is I'm going to put is odd and then I'm going to give a list a now the way filter function works is if this value so it's going to it's going to do the same thing the map function does it's going to pass every element in our iterable item uh in this case the list to the function is odd so it's going to start with one it's going to pass one in there it's going to say one modules 2 does not equal z um which is true so it's going to give us a true value and then it's that's going to be added to the list because this function returned a true value now say we put two in here and we go and we say 2 is X two modules two well that does equal zero so we get a false value returned here now two is not added to the list this is essentially filtering out elements based on um a predefined function so obviously you can make your function that you want to check um a lot longer and a lot more extensive so you're filtering out more items but this is extremely useful when you're solving problems so rather than going through a for Loop and checking every single item um like we might have done with the map function to add things into a list we can just simply call filter um give it the function that we want to filter um based on and then a list and it's going to return that new list so let's just go ahead and run the program here and make sure that everything's working fine um so I'm just going to print out a to the screen and I'm going to print out B and we can see that B has essentially filtered out all of the elements um that were even so we get 2 6 8 10 they are all gone so now I want to show you how we can implement this with our map function um why is this useful what can we use the map function for so I'm make another list here and I'm going to call it C and this time I'm just going to do list map and then inside a map I'm going to do filter but before filter I'm just going to apply another function so in this case I'm going to do add seven and then in filter here I'm actually just going to change this to B because I'm going to type the same thing now let's go over what I just did here so essentially what's going to happen now is we're using the map function which if you don't know go back and watch the previous video um and we're going to apply this new list B which has been filtered um so we filtered out this original list U now we have 1 3 5 7 n so far and based on that list we're going to add seven to every element in that list now again if you wanted to save a line I could just get rid of B here and I could simply paste that in here removing list like that um and this would work fine so let's go ahead and see what actually happens here again we're just taking this new filtered list and now we're applying another function to it um in this case add seven so let's make sure that this is indeed working I haven't made a mistake here so we'll print a again and I will print C and you can see um that we do indeed get that so our one add seven we get eight our three add seven we get 10 5 7 and so on you can see how this works now these are extremely straightforward examples but if you're doing a list and for example you wanted to filter out any elements that contained a certain digit or um that met a certain criteria then you could create a more advanced filter function uh function to filter based off of that had a whole bunch of criteria and then it's going to return a true or false value so I'll show you here if I do something like just return true uh and I don't return a condition per se um then every element in my list is going to be um sent through because nothing's going to be filtered out so again if I print C here all of our elements are here so we have 10 elements because we're always returning true same thing if I always return false then none of our elements are going to be printed because well it's always false so the way to think about it is um I'll uncomment out this for a second is what this filter function does is it's going to apply a function that gives us a true or false value um to every element in the list if when that element is applied to that function we get a True Value then it's going to be created in that new list which filter returns to us um like that now again yeah this is really useful for solving problems and I just want to show you what happens if I do something like return one um and I'll print C to the screen here you can see we get every um every element out of here so pretty much the way is uh in Python something is said to be true as long as it's not zero if it's a number so like if I pass something like high well if you say is high true technically high is true um again if I print C uh we're still going to get every element although I didn't pass the value true um High technically evaluates to a true value in Python the only thing that's not going to evaluate to a true value is something like zero so now if I print C you can see we get an empty list um just wanted to add that in at the end there um teach you something you might not have known there um so anyways that's been it for the filter function in the next video I'm going to tie these all together with something called lambdas and what they look like is that uh you can see it highlights here as a keyword and pretty much this is a kind of function that we can use so we don't have to keep creating all these other ones at the beginning of our program um and they're extremely useful and they're really cool so make sure you guys stay tuned for the next video and I'm going to be explaining how we can use those with list uh maps and on their own anyways if you guys enjoyed please make sure you leave a like And subscribe and I will see you again in the next video hey guys and welcome back to the fifth video in my Advanced Python programming tutorials in today's video I'm going to be going over Lambda uh I think that's the way you say it at least uh excuse me if I'm going to say it wrong this whole video which pretty much stands for an anonymous function now these are extremely useful um and they don't take up very much space in your program which is really good I'm going to show you exactly how they work um and what they do so I first want to just start off by defining a regular function again this is one example I've been using a lot I'm just going to say Define funk say like return x + 5 that's what our function is going to do it's simply going to add five uh to the number whatever we give it so right if I print something like Funk of two we should get seven there we go and we get seven to the screen now for an extremely basic function like this um often times you don't want to have to write a function definition and take up uh like two lines of code like this um it's easier to write it in a different way and it looks uh like more smooth maybe more slick in your program and I'm going to show you how to do that so that's one way that we can do it by making a function like that another way and this is using Lambda is to do something like this so the name of our function say funk I'll say funk 2 is equal to and then we're going to type our keyword Lambda like this you can see it highlights um in Orange just like our definition key here for our function we're going to give it a parameter or multiple parameters I think you can use multiple parameters at least and then we're simply going to State what it returns so the way this works is you type Lambda the parameter um or multiple parameters which we're going to try in a second uh a colon and then whatever value you're going to return so the thing with Lambda is it's used when you have one uh return or one expression in your function so something like this so again I can do return x + 5 over 4 like I could do a whole expression as long as that expression fits on one line um then that's perfectly fine to return and I'll show you how this works so if I say print Funk 2 and I just give it number like nine there we go we get 14 and seven so it works just like a regular function um and it kind of just looks like a variable so we're saying function two is equal to an anonymous function that's what Lambda stands for anonymous function with the parameter X and simply going to return x + 5 now these are really useful um for using with the map function and the filter function which I'm going to show you later so you don't have to constantly create a new function up at the top of your program and you can also use them inside of other functions so let's let's uh start by doing that so we're going to say funk 2 simply just going to copy it and paste it into my other function and then I'm going to return Funk 2 of X+ 85 let's try that and now if I call my function we can see that we get 92 like so now this again is really useful because you want to um often times create another function or use something multiple times within a function um but you might not want to like write a new one up here like Funk two um you just want it to be only used within that function and in that case you would use Lambda as it keeps it all contained and at the top of your function you can write a bunch of other mini functions um that you can then use multiple times within your program it's hard to see the use case for it in small examples like this but they are extremely useful um especially in like more indepth code longer code so now I'm going to show you with multiple parameters so I believe and I'm not sure but we'll see if we can do this um so we're going to try and we're going to make Funk 3 is equal to Lambda x y and then we're simply just going to return X+ y so let's just see if we call fun three and let's give it a value like five and five and we'll print that to the screen as well see there we go so that does work as well so you can give this infinitely uh an infinite amount of parameters just like you'd be able to do something like this in our function um and you can also I believe do optional parameters so I can do something like yal 4 and then if I put five we should be getting a value of nine here and there we are so you can use optional parameters um you can do everything that you'd be able to do with a regular function except you can just return one expression um like that okay so let's now use this with our map function and our filter function so in earlier videos uh I used the map function and to recall what that does I'm just going to create a list quickly say a equals 1 2 3 4 5 6 7 8 9 oops n and 10 like that and I'm now just going to say let's say new list equals list map and then we're going to have a function in this case I'll just write funk for now and then we give it a list right like a so uh what I want to do now is actually want to just put a function in here uh without having to create a new one up here like I don't want to Define Funk so this is a perfect example where we can use Lambda we don't even have to make a variable like equal to the function anymore we can just type Lambda right in here so Lambda and then we so X and we'll say x + 5 so now we again should simply just be adding five um to each of the El elements in a and then print so we're just print new list to the screen now and see if this is indeed working and there you go we can see we started at one so six uh all the way up to 15 like so again that saves us now having to make a function at the top of our program that we're only going to use for one specific case which is this map function um and again we also don't have to create like Funk equals Lambda up here but you can if you want if you're going to use it in a different case you can just type it right in this same line as uh your map function or as your fil with your filter function so this works the same with the filter function I'll do filter like so um it's going to be our function I guess uh yeah I believe this works with the filter function oh yes it does okay so what this is going to do now is we're just going to return X modulus 2 equal equal Z so again now given X we're going to see if it's divisible by two uh if it is we return true we add that element to the list otherwise we will not we check now we get 2 4 6 8 10 and there we go so you can see why Lambda is extremely useful it's really cool um especially if you want to create a lot of mini functions or you want to create functions within functions um so keep everything nice and organized and it's a nice trick to be able to use in Python so with that being said that's been the end of the video today if you guys did enjoy and you did learn something please make sure you leave a like And subscribe to the channel and I will see you again in the next tutorial hey guys and welcome back to another YouTube video so this is the sixth video in my python intermediate tutorials and today's video I'm going to be talking about Collections and more specifically counter which is a part of the collections module so what is the collections module pretty much it's a builtin module in Python that's going to allow us to have different kinds of data types so that we can store information sort through information um and do some cool things these are extremely useful um the second I found out about them I using them all the time because a lot of the stuff that would usually take you a few for Loops or a few lines um you can do in one line or two lines with these uh new collection types so I just want to first off and start by saying that in Python it has something called containers um so containers are pretty much uh a data type or an object that's going to store multiple objects so it's like a container like a list is an example of a container uh a set is an example of a container a dictionary and a tuple as well um these are the four main ones with pyth and in the collections module they introduce five new ones um which are similar to these but they all have their own methods um and cool things you can do with them so the one I'm going to talk about today is counter uh but the other ones are listed here DQ named Tuple ordered dictionary and default dictionary you can kind of get an idea what some of them are by reading them um but let's get into the counter one for right now okay so first thing we need to do whenever we're using collections as we need to import it um so this first line up here is unnecessary but I just did that to show you and we're going to import import counter from collections so we can reference it directly without doing collections. counter okay so I'm just going to start by creating a new counter so I'm going to say C equals counter um now when you create a new counter what goes in here as the arguments um can just be any uh I want to say like collection data type or any uh container so for example you put a dictionary set um tle you can put a list uh and you can also do something which is weird with these keywords I'll show you that in a second so for example I could create a counter like this by just putting a string and it's going to count all the letters in the string and return them to me and I'll show you that in a second I could create another counter where in here I have a list so I can say like a a b c and we'll just do one more C like that and I could put a dictionary so I could do something like this I'll just make a small one so we don't take too long uh oops like that B2 and you can also put uh these keywords which is what I was talking about it's kind of cool because you don't have to type out or like use a for Loop to create a list like this um I could do something like oops cats equals 4 dogs equals seven like that and I can continue on with keywords um and I don't have to actually put the quotation marks around these I can just name them exactly what they are so let's just go ahead and start printing some of these to the screen to see what actually happens um when I create a new counter object and what does that look like in Python so we'll just print all these um just to give us an idea of what they really are okay so there we go so it says we have a counter object uh it is its own object it's not like a list or dictionary it's its own thing um it says a we have two uh I believe this is an L we have two G1 D1 um and then same thing here A B C dogs cats so you can see it looks like a dictionary in terms of it has a key value pair but it works a little bit differently so now if we want to reference um a specific item which is typically what we want to do from our counter we can just put the square brackets and put the name of that item or the key so in this case I'm going to put cats and you can see now we get four as that's the Direct Value related to cats um and something cool with this counter and a reason why I use it specifically is I can put an item in here um that doesn't exist in the counter it doesn't have a key set and that will actually not return an error like might happen with the dictionary so for example I put ay like I don't know let's see pet then it just gives me zero instead of returning an error so if I were to do this with a dictionary let say d equals like I don't know uh Cat 2 and then I Tred to do D pet like this and get the value uh we get an error uh because pet the key pet does not exist in our uh in our dictionary okay so let's move on to some more methods and why these are extremely useful um so we can see here um one of the methods that we can use is we can actually just list all of the elements out and this is useful if you want to like sum something um so let's just say list and then c. elements like that and what this is going to do if I print it to the screen is it's simply just going to print out all of the elements in our counter so we say cats cats cats cats dogs dogs dogs like that um and since here we said cats equals 4 dogs equal 7 um then it prints it out like in a made list with that many uh indices which can sometimes be useful I'm just going to change this to be named D so that we can now print out the one like this with A1 B2 and you can see we get a b b um like so I if I do the same thing I'll change this to e we print it again um then again we get another list that just has all of the elements in it so that's one useful method uh c. elements another useful element uh or method sorry is most common now this one by far is probably one of the most useful ones um and you can simply just type this so the name of your counter object and then most underscore common and then in the brackets here you're going to put how many elements you want so if you wanted to find the number one most common element you'd put one if you want to find two you put two so let's print this to the screen and see what we get so and you can see we get the most common elements are a and c and it actually also returns us a count of those elements as well so it says a which occurs two times and C which occurs two times and that's returned to us in a tupple or Tuple however you want to call it uh which is really useful okay so now another one we're going to use uh I'm just going to copy something I have open here just to save a spit of time in terms of creating counter objects so I'm going to delete all this and I'm going to make uh one counter which is equal to a uh or C and then I'm just making a list which is uh D and it's a b b c like this okay so you can do something um as well with these counter objects you can subtract Counts from them uh from using other idal objects or you can add uh like the count of objects to them so one method is called subtract oops like this and it does pretty much exactly what it uh it says so we're going to take this counter object this has to be called on a counter object by the way um it says with these counts and we're going to subtract whatever the counts are from D of similar items so we have 1 a two B's and a c so if I do this and I print just the screen we should let's do a quick calculation here get a is equal to Three B is equal to z c is z and d is still 2 uh none oh it's CU I didn't convert this to a list sorry about that let's do this maybe non type object is not ital all right just give me a second guys there is a way that we can oh it's because we're doing this so C do subtract doesn't doesn't actually return anything we just have to print C after we call that method okay so there we go and we do get um what we had there okay so yeah C is Nea 1 because 0 one gives us negative 1 um and there we are so it is working exactly like it should be okay the next one is update so I'll run this now c. update and this is the exact same thing as subtract except it's simply just going to add the counts of whatever iterable object you give it so in this case I'm going to put D and note here that I'm using a list but I could be using like a dictionary could be using another counter object um I could be using a set uh a tuple uh whatever you want to say there it's still going to uh like work for update so let's see here and oh I didn't print C let's do that and there we go so we went originally so we changed our counter by subtracting and then we just updated by adding so it should be the same as our original counter which it is okay so that's working well the next one that I'm going to talk about now is clear um this one does pretty much what it states uh so if you see here we do c do CLE and then I'll print C to the screen and all it's going to do is just remove all of the counts so we now have an empty counter object that we can use to count something else to add to to subtract so on okay so that's it for the methods pretty well there's one or two more but I don't find them very useful so I'm not going to show them right now um but there's something cool that you can do with these counters and there's a few operations that are applied to them so you can actually add counters using the plus sign you do like this C plus D um you can do c minus D you can subtract them you can add them and then the two operations which you wouldn't necessarily uh know intuitively is you can do something called intersection and Union of counters so let's just first show what happens when I add these two counters together so C plus d oops and this needs to be a cter now because this isn't going to work if it's a list there we go so make that account counter and I'll print C minus D and then we'll print another one after that so if I add them and subtract them um you can see that uh it works like this so when I add them we get the counts added up like this and when we subtract uh we get it subtracted as well now some of you might be uh wondering here why we don't have the elements B C or D shown in our counter uh and that is because if the ele count is less than Z or equal to Z it's not going to be shown in our counter when we do these operations by adding and subtracting so because of that um you can see like why that happened because B is two here and we have two BS so that created zero C is already zero and D was 2 so when we subtracted it's not going to bother showing those uh in our new counter now the next operations that we can do is something called Union and um inter intersection so the first one I guess I'm going to show is intersection and the way that you can think of intersection is like the minimum elements in each of the uh the list so we're going to have C intersecting with D um in this case we should get AAL 1 Bal 2 and C 0 D 2 so let's just see if this works and there we go we get B is 2 a is 1 and we're not showing the other ones again because they um like they're equal to zero or less than zero so they not being shown and this is the and sign is what I'm doing to do this intersection between the counters the next one that we can do is called Union and this one you can think of as the max Elements shown in each of our counters um so it's going to take a equal to 4 because that's our Max it's going to take b equal to two that's the max between here Cal 1 and then again it shouldn't be showing us D because that's 2 so there we go we get a is four B is 2 and C is 1 so this is pretty much going through looking at the counters and just taking maximum element whereas before when we did our intersection it's taking the minimum shown of all those elements so that has pretty much been it for this video and counters uh from The Collection there's a few things that you can do with them as well a few other methods if you want to learn about those uh just go to just look up collections counter python uh you can read through the documentation and you can look at some more examples that I didn't show here specifically other than that I hope you guys enjoyed the video if you did play please make sure you leave a like And subscribe and I will see you again in the next one hey guys and welcome back to another video in today's video I am going to be continuing with my intermediate python uh tutorials and we're going to be moving on to something called named Tuple uh or tupple whichever one you prefer um which is a part of the collections data type or module class whatever you want to call it so in the previous video I introduced you kind of to the collection module in Python and I showed you counter which is really useful um today I'm going to be showing you named Tuple which is another data type or class whatever you want to call it within that module um and pretty much this is the description of it I'm just going to read it right off of the uh documentation here because it explains it better than I could come up with um so let's go ahead and do that named tupes assigned meaning to each position in a tuple and allow for more readable selfdocumenting code they can be used wherever regular tupes are used and they add the ability to access field by names instead of position index so you should understand a bit of that but if you don't obviously I'm going to go through exactly how this works and how we can use it so the main difference between a name Tuple and a regular tupal is you can access things by element and it's just a lot nicer to read in your program uh so they might come in handy if you're coding large things or if other people are going to be reading your code so let's go ahead and first off start by importing collections like this and then we're just going to from collections we are going to import named Tuple oops okay so now that we've done that what we're going to do down here is I'm just going to create something that I'm kind of going to go and show you what exactly it does so I'm just making new variable point I'm going to set it equal to a named Tuple with name point and then it's going to have Fields X Y and Z and I'm going to show how this works okay so what I've just done here is I've said point is going to be equal to a new object which is a named tupple or tubble um the name of the tub is point and it has Fields x y and z now this looks a little weird you might be confused what we're going to do whenever we want to create a new point that is in the form of this name tubal is we're going to treat this like a class and we're going to do something like this we're going to say new p is equal to point and then we need to give our uh parameters so in this or arguments so in this case in X Y and Z so I'm just going to say 3 four five like so now you might be looking at this be XYZ this is one string um this might be the name of one parameter the way that this works and it's actually really useful is that it's automatically going to break up this string XYZ into three different parameters so I'm just going to print this to the screen to kind of show um what I mean here so I'm just going to print new p and you can see that we have x = 3 y = 4 and Z equals 5 now what happened here is when we gave an iterable object as our different parameters you can see that we get uh it just breaks it up by space so I do something like gy and then I run this here you can see now g y is equal to 4 I can add another one um on the end like H uh oh and then we're just missing one argument so I'd have to add another number in here so that we get H is equal to 8 I can also do the same thing with the list per se so if I have a list and I want all of these to be the names of like so like X Y uh and let's just do like L and we run this takes four okay I keep forgetting to fix this anyways uh you can see we get x y l any iterable object will work I'm not exactly sure how a dictionary works but I'm pretty sure it takes the keys so let's just go ahead and have a look at this one we'll just say x um zero y z um Zed zero now this might crash but I just want to see if this actually works oh yeah it does work so it just takes the key names ignor the values we get X Y and Z and then I guess you can do the same thing with any other iterable object those are the only ones I can think of that are useful right now so anyways when we want to create a new tupple uh or a new name tupple what we're going to do is just say whatever the name of that's going to be is equal to point which we've set up here to be this type um with these like parameters attributes and then we just give it those parameters now there's a lot of really cool things and methods that go along with this named tle and that's that's why it's useful so first of all you can do something like this new p.x um new p.y and new p oops. z like so and now what this is going to do is it's going to allow us to access each element by its uh index so by its name which you can't do with a regular tle so you see we get three four five to the screen like that and we can use the same operations that we use on basic Tes so I can do something like new P0 like that um and oops my mod thing just popped up somewhere else and you can see we get three um because that's the first one that shows up we can also print this so it looks uh in the form of a dictionary so I'm just going to say underscore is dict like this I believe this is the method or not is as sorry and when we print this to the screen you'll see what shows up and it says an order dictionary and it gives us a list and then it gives us the all the Tes within so X3 y 4 Z 5 um kind of a different form if you want to play with that and use that we can also print out all the field names um which is useful say you forget the fields we can do new P do and then fields and it gives us a tle with those fields in it the next method that we can use is the replace method um this one's pretty straightforward but all you have to do simply is type I don't know let's see here new P doore replace and just make sure you guys remember to put these underscore here all the methods pretty well for this uh required underscore don't ask me why but that's the way they're written they need underscore and then you're going to put a key name so say I wanted to replace Y and I can say equals to 6 uh so we'll run that and then if I just go here and just to show you that we did change that let's print new P like that and you can see oh why did not change to uh to six that's weird let's let me just see if I print this to the screen if this is going to change it should have worked new P like so let's check and Y is not changing to four um that's very interesting why that is not working okay so I just had a quick look at the documentation and the reason why I can't do what I'm trying to do here with this replace uh is because this replace doesn't actually change the Tuple object it it's not capable of doing that so what we have to do is we have to assign a new variable or new object to that so pretty much what this does is it returns a new named tupal uh which we then can set to in this case the same name it it's going to do the same thing that we tried to do except we just need this new P equals to hope that makes sense so now if I run the program we can see that finally this is working we are changing X or I was trying to change y before but I switched it to X to see if there was an issue there uh you could see that that is working like that so anyways um that is pretty much it I'll show one last method here if you guys are still watching so pretty much we can do something like a new a new point so say P2 is equal to point doore make and then I'm going to put a little list in here I'll just say like a b c now what this is going to do is same similar thing to up here is it's just going to automatically grab all of these elements in our list and assign them to XYZ accordingly in our named tle so you can see if I print P the screen now and we give it a run no errors everything's working fine xal a yal b zal c hey guys and welcome back to the eth video in my intermediate python tutorials in today's video I'm going to be continuing with the collections module and we're going to be talking about a data type known as the deck so yes this says DQ right here and the title of the thing is spelled DQ um but the way that you pronounce it is deck uh and I just found that from reading the documentation otherwise I was going to go through this whole video saying DQ anyways uh deck is the proper way to say this word so if I do end up saying DQ throughout the video please don't leave an angry comment about it uh I don't know why I just keep saying it but anyways deck is the proper way so why would we want to use a deck over uh a typical list so pretty much it kind of looks the same as a list and I'll show you in just a second but the reason why we' use a deck is because it's faster in terms of adding elements to the end and the beginning of a list so rather than using a list you want to use a deck because it's going to be faster whereas if you're trying to randomly access elements within uh a container so a list then you're going to want to use a list over a deck and if that's confusing don't worry I'll kind of show you how we uh as we go through so let's start by creating a deck and see how that works so I'm just going to say d and that's going to be stand for a deck is going to be equal to a deck and then this just takes an iterable argument so in this case I'm going to take type in hello but I could give it something like a list a DI iary uh so on so anyways D equals uh deck hello now if I run the program press F5 and I simply print D to the screen here you can see that we get deck and then h e l l o i just split that up into what looks like a list but it's actually a deck okay so now let's go through uh a few methods that we can use on this so obviously we can use something like append so we can append an element to the end so I can append something like four uh I can pend another element do something like five and if we run this and then print it again you can oops didn't mean to do that then you can see we get hello and then four five so on so you can append uh a nice thing is you can actually append to the beginning of the list as well so I can say append left instead of just regular append and now you can see when we run the program and we print D I don't know why that didn't work let's see here we get five and then hello four so that's a nice method as well we can do the same thing with popping which is removing elements from the deck uh so I can do pop in this case and I'm not going to do four in here so I do d. pop and then I can also do d. poop left and what pop left is going to do is it's simply going to remove the first element in Our Deck rather than the last so pop uh this works on lists as well and dictionaries and stuff you can remove the last element or whatever index you type in here like five two whatever that's the one it's going to remove pop left simply removes the first one so I'll do this and then print D and you can see that we are left with eell because we removed o and we removed the H okay another method that we can use is clear uh this one is simply going to remove everything from the deck so that's pretty standard if I print D again then you can see that we have an empty deck now okay the next few that I'm going to talk about here I believe you can use on some other containers in Python but they do work on this deck as well so let's go through that so now that we already cleared Our Deck let's just go ahead and add some more things to it so what we can do is we can do something called extend and what extend is going to do is it takes an iterable argument which means anything that's a container so like a list a string uh something like that and it's going to put it at the end of our list so if I have something like 456 and I run the program and I print D you can see we get four five6 at the end of our list now to show you what happens if you already have something in I called it a list but our deck is if I extend again I'll extend something like so we can see it better hello then what we get is print D we get 456 and then hello so this is a way that to add multiple things into your deck so again if I make like a list and I go like 1 2 3 this is going to work as well so we should get four five 1 2 3 and print D and there we go we get that as well so if you ever don't want to run through like a for Loop to add an entire list into a deck then you can simply use extend extend also works really nicely um with extend left which is going to add to the beginning of our list so now we have a list of 4 5 6 1 2 3 let's see what happens if we extend the word hey um to the left side of the list so I'm going to print that and you can see we get y 45 61 2 3 you might say well why didn't we just get H well it's because we're actually extending to the left so we're going to add this in the reverse order and that should make sense because if you're extending this first and then you extend this and then you extend this y should be the first element on the left side of Our Deck like that okay so now we're going to use um a few other methods so this one is probably the most useful one that the deck has and the reason why you would use it if especially if you're going to be dealing with things at the beginning and the end specifically and it is known as rotate so what this does is it takes a integer in here either positive or negative if you put a positive in integer in here it's going to rotate all of the elements by that amount to the right otherwise it's going to if you put a negative element in there rotate everything to the left so just see what happens if I put negative 1 in here to rotate to the left and then we'll print down here sorry it's at the bottom of the screen right now and you can see that we went from this one which was the last uh D or whatever when I printed it and now we've rotated everything over so three's moved over to the position of Two And when we get all the way over to here we've switched e and Y so E's moved over here and Y has been rotated back to the end of the list now you can actually rotate with other uh numbers as well so rotate by two and then you can see if I print D down here that we get a rotated two elements over now and this is is really useful when you're trying to solve certain problems uh to be able to use this rotate again you can do the same thing with positive so if I just rotate it by one now and I simply print D you can see that now we've rotated to the right side so three which was originally here has now been moved up to the beginning of the list okay so now that we've talked about that there's one last really useful thing um that I left out on purpose because I wanted to show now that we can do with these decks so when we initi iate Our Deck here we give it an iterable object we don't have to give it anything it'll just create a blank one if we do that but there's something that it has called Max Len now if I do something like Max Len 5 and I'm just going to remove all this and I'll show you how this works so I have a max line of five and I have a string that has five characters in it if I try to add something to my deck here so I'll just do I'll just simply I'm going to print it here just so it saves us some time going to print D and then I'm going to go d. and let's do one and then print D again let's just Watch What Happens so you can see we get we have a max line of five we start with hello and then when we add one H is actually removed from our deck now the reason that happens is because when we set this max length when we start adding things into the list it needs to remove something to maintain that um attribute of a maximum length of five so it removes the first element from our deck uh and that's really useful as well if you're solving problems because then you don't have to deal with removing things every time you add something to the end or removing like a slice of for example list if you're going to be adding more than one thing so if I extend like something like let's see here one two 3 now we should see that h e and l should all be removed and we should have L1 23 so let's try it and there we go we get hello and we get l123 and we didn't have to deal with figuring out how many elements we need to take from the left side from the right side because of this Max Len now just to note you can't change this Max len by doing something like d. Max Len equals five it's uh or I guess we'll do like six because it's already five you can only access what the max Len is by just doing is simply this print ma d. Max L and this should just give us five uh and it does but if I try to do what I was showing you there so d. Max Len equals 5 you'll see the error that comes up and it says this attribute of Max Len is not writable so we can't actually change it after we've initiated that value so anyways that's pretty much been it for deck within collections this is really useful and you might not see a use for it now but if you start solving some more advanced problems using this deck will make your life a lot easier with those methods that I went through and I'm going to copy all of them down uh into like a little paste bin thing so you can click the link in the description there if you want to see all of them in a list um so you don't have to specifically memorize that other than that you can always just go to the documentation and have a look if you just search up like DQ collections python it goes through what all of these do again I forgot to talk about reverse but it's pretty straightforward you can use reverse and if you're followed up to here you probably probably already know that one so anyways that's been it for this video um if you guys enjoyed the video please make sure you leave a like And subscribe and I will see you again in the next one hello everyone and welcome to the first video in our python expert level tutorial series now what I'm going to be doing in this series is teaching you about some expert level features in Python how they work how to implement them and then getting into how you can actually use them and why you would use them in your python code now it's worth noting that a lot of the features I'm about to show you as much as they're very useful and complicated and you know Advanced and expert level you don't necessarily need to use them there's a time and a place and as you guys learn this you should refrain from using these features just to almost show off and actually make sure that you understand the purpose of using them and use them in the correct context that's what a lot of the focus of this series is going to be is giving some meaningful examples that try to tell you when you would actually use this feature or at least help you understand really why it works so that you could think about a situation when it might want to be implemented now quick disclaimer here if you guys are not python you know intermediates already or you're not familiar or fluent in python this is going to be a difficult tutorial series for you to follow along with you know you're welcome to as always but just keep that in mind I do have a lot of python tutorials on my channel that a more beginner level if you want to follow along with those before maybe jumping into something like this now in this video what I'm going to be doing specifically is talking about some very interesting and cool features in Python these are not anything specific they're nothing you may not have seen before but it's something that you need to kind of understand before we can move into the more advanced things so we're just going to be talking about how python code actually runs and why we can type out some weird lines like I'm going to show you um in the next few minutes anyways what I'm going to do now is briefly discuss how python code is actually ran and executed now I will say right now I'm not going to go into extreme detail I'm hopefully going to give you enough information so that you understand on kind of a surface level but if you do want to read into this I would recommend it because understanding how your program is actually compiled interpreted and eventually ran on your machine is very important and it definitely helps you understand why a lot of the things in the language work the way they do so most of you would have probably heard that python is an interpreted programming language but what does that really mean well to understand that we need to define the difference between a compiler and an interpreter and talk about how they work together because although python is interpreted it is actually compiled as well into bite code before it is actually interpreted so the way that python works and actually we'll go back to the definitions first so a compiler what does a compiler do well a compiler takes some highlevel code typ Ally high level code and translat translates it into a lower level so for example the python compiler that we use is going to take our python code which would be considered highlevel code that's furthest away from the hardware right and translates that into something called bik code which is a little bit harder for us to understand and closer to the computer's level so that it can actually be used and ran on our machine so what does an interpreter do well an interpreter takes some kind of code typically B code and interprets and runs that that code so it will read that codee and translate it on the fly into machine code that can be executed by our computer rather than doing this translation beforehand when you use something like C what you typically do and depending on the compiler that you're going to use there's tons of different versions and methods of doing this you will compile your code directly into machine code which means that it can be ran directly on the operating system that you're using and you don't actually need an interpreter to interpret your code and run it now I know this seems like a lot but this is something that we kind of need to understand so now I'm going to go into the way that Python's kind of execution chain is when you actually you know press that F5 button or do whatever it is you're going to do but essentially what happens in Python is you write your highlevel code which is going to be on your desktop you know in your text editor your python code and then when you press that run button or you go to execute that code what happens is it's translated into something called bite code now this translation is simply just a tool that checks all of the Syntax for your python code and then converts it into some equivalent code that can be read by The Interpreter that we're going to use so what happens is if you have invalid syntax like say I just type CL or something and that's not defined or I mess up and I don't have a colon or something like that then we get an error because the translation can't happen because the format of our code is incorrect and hence you know invalid syntax that's the error that you would get now assuming that your syntax is correct then what happens is you'll move on to the next stage where everything will be translated into bite code and then that bite code will run through the compiler and the compiler will translate that bite code in like a live time into machine code that runs and executes on your machine so this is why there's a lot of issues with python running on say mobile devices or on other devices that don't have a python interpreter because this bik code cannot be directly understood by the CPU you need some kind of interpreter to run it so hopefully that clears it up a little bit on how that works the basic summary is you know you write your high level code translated into bite code that bite code is then translated through an interpreter in live time as it's reading line by line so one at a time not all at the same time into machine code where it is executed and that's how your program runs this is different than a lot of other languages and each language has a very kind of complicated process of compiling and interpreting and running code so anyways I hope that kind of cleared it up a little bit but this feature of being interpreted and having a lot of things happening live is what we're really going to dig into here so the first thing that I want to show is something that's unique in Python that's not unique in a compiled language and that is the fact that a lot of checks and a lot of things that you typically can't even write with you could not compile code that exists these types of things in other languages you can do in Python so let me just show you what I mean all I'm going to do is create a class dog and inside the anip method um I'm simply going to call a method that does not exist called bark so this is my file um intro. piy we have a class dog a nit and a method self. bark that's being called but that method does not exist in the class body now for any of you that program in other languages you'd say okay well this is not going to work right if we don't have this method the compiler is going to pick that up it's going to say okay we cannot compile this code you need to Define that method or you need to remove the statement whereas in Python we do uh what was this python intro. py no issues we're totally fine we're good to go this is something that's unique about python is that a lot of the code is actually executed at runtime not at compile time all that the compiler really does for us in Python is just translate this code into B code it doesn't necessarily check that all this code is a valid now this a good thing and this is a bad thing we'll talk about why later on but that's something to understand that you can make errors like this in your python code and they will not be caught until runtime which can actually be a huge problem when you know you can't test every single aspect of your application your app gets through goes into a production environment something happens in runtime you didn't check it cuz the compiler didn't pick it up and now all of a sudden your code has crashed right so that's something to consider Okay so we've done that um that's fine that's just something I wanted to discuss and show you and that's kind of the way that python Works everything is actually happening kind of live it translates but then the runtime environment is what picks up on a lot of these errors okay so now let's get into some cooler things and talk about some strange things that we can do in Python that we can't really do in other languages so I'm going to Define a function and I'm actually going to make this function called make class so Define make class now what I'm going to do in here is get a parameter called X and I'm actually going to define a class inside of this function called dog just like we did before so I'm going to say class dog let say Define uncore uncore netore uncore we'll take a self value we'll take a name and then we'll just say self. name equals name okay now what I'm actually going to do is say Define print underscore value what I'm going to get this to do is simply print the value of x so we'll say print X like that and then I'm going to go down here and I'm going to actually return uh the dog like this now notice that I didn't return an instance of the dog by putting the brackets I simply returned dog itself which is actually a reference to the class not actually the uh the object so what I'm going to do down here now is I'm going to say CLS equals make uncore class and I'm just going to print out CLS and show you what this is so let's say CLS let's give the value 10 in here let's go and let's see first of all is this going to work does this not work why does this work what is this even doing well we'll talk about it okay so this actually worked so see what happened here we had this function called make class took an argument X and then we had a class dog that we defined inside of this function now first of all this should look strange to you but but the reason we can do this is because again the python compiler does not check if this is valid or not it doesn't really care so long as you have valid syntax so long as the format is correct your python code can run and it can execute and that's fine and that's exactly what's Happening Here we can define a class inside of a function because that's just the way python works we read from the top to the bottom left to write and that's totally fine that's totally valid now what have I actually done inside this function though well I've created a class that uses a value from the actual function argument here and then we actually return the class itself not an instance of that class now notice that's something that we can do in python as well since python code is running live it's kind of executing on the fly all of these things that we've defined here are actually being stored in memory so this um dog class here actually has a memory location for it that's why we can actually see this same thing with this function same thing with our VAR variable um and same thing with anything else that we Define that's something that's true about python is that all these things are actually defined and stored in memory which means we can interact with them live which is what we're doing right now so when I printed CLS we can see that I got main.m class. local.dog now let's just translate this a little bit although I'm sure most of you understand this main simply means this came from our main module which is a module we ran make class is the name of the uh I guess what is it function that we defined here locals Define what's inside of this function and then dog tells us the actual name of the class so that's what we printed out here but now let's see how we can actually use this so what I'm going to do is actually make an instance of this now I'm going to say d equals CLS name Tim and I'm actually going to say d. printor value like that and let's run this now so now we actually get the value 10 so what I've done is I've said okay well this CLS variable is actually a class since it's a class what I can do is use the way that I would typically use a class it's literally just another name for dog so we'll put our brackets we'll create an instance of it which makes self. name um you know equal name I can show you that as well by just printing d.name and then what we'll do is call the method on our object now the prints the value that we gave when we actually created this class so you can almost think of this um function that we've defined here as a I guess class Constructor where it's creating the class for us then we can use the class so I think that's pretty interesting that's something that's cool and again if we wanted to I could Define another function inside of here we can do another class inside of this class I can make seven classes inside of this function there is no limit to what you can do so long as you're using the correct syntax and you know it's not going to crash at run time right so that's something to consider now let's show some other weird cool things that we can do in Python um that's actually using some other kind of syntax so what I'm going to do now is I'm actually just going to make a for Loop and you might kind of be thinking about what I'm I'm going to do here so I'll say 4 I in range 10 what I'm going to do is Define a function I'm going to call this function just uh I don't know let's do show and all this is going to do is simply print the value I and let's just do I * 2 why not make it a little bit cooler now I'll call the function show here and let's run the code and no surprise to any of you when I run this that this should work fine and we get all of our values printing out so we can obviously do things like this I can define a function inside of a for Loop what I've done here is well only one show will actually ever exist at the end of this kind of runtime but I've defined 10 different shows that do 10 different things and I've called them directly after and then they get overridden and I do them again so that's something that's cool and again another feature of python that you can't really do in some other languages now what happens if I take this show and I put it outside of the for Loop so it's not running at the same time as this function is defined at well let's run this we see we just get 18 the last show that was defined is the one that exists and the one that's created now why would you ever do something like this I don't really know maybe if you had a lot of content inside of this for Loop and you had a function you were going to use it multiple times but only locally you could Define it up here again doesn't make that much sense to me to do that but just showing you some of the features of the language okay so now let's show some other things that we can do um I'm trying to think of something that would be cool okay so let's do another one here let's say Define Funk what I'm actually going to do here is take some value let's just say x and I'm going to return a function from this function if the value of x is a certain value so I'm going to say if x equals equals let's just say one then what we're actually going to do is make a new function we'll say Define uh I'll just say like RV which will just be return value and then inside here we don't need any parameters all we'll do is say print X is equal to 1 okay otherwise we'll do is say Define RV and then we'll say print X is not one okay now we'll return this function RV and if you guys remember from what we've done before what I can do is say Okay newor Funk equals Funk of let's just do value one and then I can actually call my new function like that because notice if I don't do this right then let's have a look at this here nothing gets printed out to the screen but if I call my new function by putting my two braces outside of it here then what we get is X is is equal to one and we could change this obviously and then we would get a different value where we get X is not one so we can do interesting cool kind of like paradigms like this again I don't know why you would use this there's easier ways to accomplish this but it's something to consider is that this can actually happen and any arguments that we use here obviously we can use inside of these functions as well and we can get into some pretty complicated things when we start defining functions inside of functions inside of functions Okay so last thing that I want to show you is just a cool thing that we can do to actually look at some of the details of our objects because remember that I said everything in Python pretty much Happens Live this function is an object um this function is an object our Val variables are an object any classes are an object which allows us to do what I'm doing where we're passing them through and around the program they'll have their unique memory address and so long as we can reference that we can use it so let's actually see how we can inspect and look at some of our functions so first of all I'm just going to show you you know you probably seen this before we can look at the ID of our function if we'd like to just by doing this um now if I print this out this should give us the memory address location of our function which we can get right here um and there's a lot of other things that we can do as well and one thing that I want to show you is actually by importing the inspect module so the inspect module can show us some pretty cool things because of the fact that all of our python objects classes all of that are actually live we can interact with them we can inspect them we can ask questions about them um and get that value back from The Interpreter so what I can actually do in here is say print inspect dot uh what is this we can do I'll do get members for now just to show you so get members I won't really discuss exactly what this does but it's just going to show you some details about the function so let's look at this here we can see we get all of this little information and we can obviously use this if we wanted to let's see if we can pick anything out in particular um that stands out nothing okay so here we go function. Funk locals RV at this memory address location so it just gives us all this details that's called new funk is down here the name of it so we can get some stuff like that um not extremely useful we can't use that at other times another really cool thing is we can actually get the source which is the source code of a specific function method class whatever you want so here when I do this it actually tells us the source code of the specific python function now why would this be useful well if we wanted to see exactly what was happening in some kind of thing that we were using that was maybe Library code we couldn't access that actual code we could have a look at the source code like this so now I want to show you another useful thing of this inspect module if I were to import some module and this is kind of a good use case of it say like Q right which is a python builtin um what is it from from Q in for Q This is a builtin data structure from Python and I wanted to look at the code of it obviously there's other ways to do this but if you wanted to just quickly do it in your terminal then what you could do is do something like that and now we can actually see all of the code that's been used by python itself to create this object or create this class so I think I'm going to wrap it up here it's been about 15 minutes I hope that this gives you guys a good understanding of python a little bit more how we can pass objects around how we can look at their values we can inspect things we can look at the source code and just remember that everything in Python is pretty well happening live all these objects are defined in memory and well since they're defined in memory we can do a lot of cool things with them like pass them around the program and since the python is an interpreted language we can do all these crazy things where we Define classes inside of functions functions inside of classes inside of functions that we can go crazy and we'll continue to do that as we get further into this tutorial Series so if you guys enjoyed make sure you leave a like subscribe and I will see you guys in another expert Python tutorial hello everybody and welcome to video 2 in the python expert tutorial Series in this video we're going to be doing is talking about Dunder slashmagic methods and the python data model now this is very important this is something that I guarantee you've seen before but you probably just haven't understood what it actually was or why it was working the way that it did and this is actually going to give you a great insight into the way that a lot of things in Python actually operate because until you see this you kind of just take them for granted so what I want to do is give you a very basic example of two objects in Python um just kind of being used and interacting together I'm going to show you how we can create the same thing with our own python objects and even modify existing python objects to implement uh implementations or operations that we want so what I'm going to do to start is I'm going to just make two uh variables here I'm just going to make a list I'm say 1 2 3 and I'll make another list that just says you know four five like that now we know that with lists we can add them together by using the plus sign right we know that that's fine that we're allowed to do that so let's actually have a look at how that looks we get that list and it adds them together now why does that work we don't really no we kind of just assume that that's a feature in Python that we can add list together right and that's totally fine for our intermediate kind of understanding so what about length right I can get the length of a list that works fine too so if I look here I get a length of three and there's all kinds of things that I can do on a list like I can index something on a list I can put you know X1 and that gives me some value here and you're like well why are you showing me all this stuff because you're going to see that this kind of syntax that we're using right here on this object because this list is actually an object and I'll prove it to you just by printing the type of it and telling you that is actually a part of a class you can see class list is implemented under the hood now you might not understand what I mean by that right now but I'm actually going to import inspect and show you and then we'll get into a little bit deeper of this understanding so what I'm going to do is actually just say print inspect doget source of list Now list this is going to be ridiculous when we look at this in the terminal um list is a builin class oh it won't let me uh look at the source of the builin class okay that's fine we don't need to look at it for now um but anyways the whole point of this is that these objects here this is an object this list is they're both objects we take for granted the fact that we can perform certain operations on these objects using some special python syntax right like even being able to multiply list together like I can do X multiplies by 3 right that's kind of a special syntax why is it that we're able to to do that well that's because this operation is implemented on the list object itself and it tells the list object how to behave such that it sees a multiplication sign right after it or such that it sees a plus sign or it sees this index or it sees a call we Implement that functionality and because we can do that we can Implement that on our own objects now let's do one more example so obviously we saw when we printed out the value of this right we printed out X um we just printed like it just looked exactly like this it printed 1 2 3 right or in fact actually let me show you if I do a space here and I just print X let's have a look at what we get here we can see that this gets uniformly spaced even though there wasn't a space here so it's not the fact that it's just printing out exactly what this looks like there is something under the hood that's telling python what this list object looks like and what to print when we decide to print it out so let's create our own object now actually so I'm just going to say class person like this and let's just Define in a knit method now this is actually a double underscore method or a Dunder method or magic method whatever you'd like to call it we'll talk about how this one works in a little bit although I'm sure you guys understand so we'll just make our object uh person I'm going to say p equals person like this Make an instance give it a name of say Tim and then if we print the value of P well if we were you know if we looked at the list before and we saw that the list printed 1 2 3 4 just printed exactly what it looked like we we would assume that when we print P it should just print person Tim right it should print this well when we look at it it doesn't do that and I'm sure you've seen this before it prints the memory address location now the reason it does that is because we have not told person what to do when we try to print it it does not know what that what we should show so by default it shows the information that it thinks would be valuable which is simply just its memory address location right that's its like representation internally in the python program so how can we change this well we can Implement what we call a Dunder method or magic method which is called repper now I'm sure you've seen this before but essentially what rapper does is allows us to define the string representation of an object um from inside of it so what I'm going to do is make an F string and I'm simply going to say person and then in here self. name so now when we decide to print this out what we get is person Tim and I'll just do it one more time instead of getting that crappy you know just gibberish of memory address location so this is the first thing that we can do is we can Implement methods such as this on our own objects um to implement some kind of functionality now let's show a few others and why this is so powerful so there's actually a whole list of what we call Dunder methods and this is what's part of the Python data model and some people call these just data model methods and essentially um you guys can read through this if you want I'll leave the link in the description someone remind me if I forget if we scroll scr down to the bottom here we'll start to see that there's all kinds of these double underscore methods that we can actually Implement on our own objects and obviously I'm not going to go through all of them because there's just so many to kind of talk about uh but let's keep going down here so for example new nit Dell repper right we have this one here string bytes format uh ltle e EQ NE GT G we'll talk about what all those are hash um bull right get attribute set attribute dur Dell attribute multiplication there's all these kind of things that we can do so what I'm going to do is actually do a weird one and I'm going to U implement the multiplication Dore method so what this tells python to do actually um is what happens when we use a multiplication operation on objects of this type on objects of type person so what I'm actually going to do in mole here I'm going to assume actually X is going to be some integer and what I'm going to do is just take the person's name and multiply it by whatever the integer is and that's the operation we'll implement when we use the star or the asteris on the person object so what I mean by this is I'm just simply going to say selfname equals self. name time x and I'll even do a little just um thing up here I'll say if uh Type X is not int then we'll simply just throw an exception so we'll say raise exception we'll just say invalid argument must B in uh or in yeah whatever it doesn't really matter what we put there but that's fine okay so we'll say p equals person now what I'm going to do is simply print p uh we won't print that actually we'll just say p * 4 and then we'll print p and let's have a look at what this gives us okay person tim tim tim tim tim right so we can actually Implement whatever functionality we want using this upper level python syntax by implementing some kind of lower level Dunder method and that's what the whole point of this video was to do was to show you that everything that we use in Python all of these different symbols can be implemented on a lower level on our own objects and these are again our like data model uh methods right so we can create objects such that we can add them we can multiply them we can have representations we can do a call on them we can do all kinds of crazy things for example let's do Define uncore call let's just do self let's take some argument why not why and let's just print this value so what I'm going to do is now instead of printing P I'm just going to do p and put value four in there and now let's watch what happens so if I go like this we get the value four printing out we could even change this called this function right four so what happens is we can implement the fact that these two brackets what these two brackets do if they are on an object which is really cool it allows us to make objects that are much more usable much more readable and just almost seem like they fit in with the standard python documentation because I don't need to necessarily call a method I could actually just put the brackets now anything you can think of with this kind of syntax you can probably implement for example Define underscore uncore lencore uncore self return the Len of self. name maybe that's how long a person is unless you're going to ask for their height or something like that then what we could do is print the Len of P right so if we go like this we get three as that's the name so that's kind of the idea behind these Dunder meth in these data model methods the whole point is everything that's above even something like division you know greater than or equal to um less than whatever it is equals index all of these things can be implemented and if you want to see the implementation details of how all these work then you can read through this data model U documentation because there is a ton of them the whole point is you don't need to memorize these you just need to know that they exist and then you can think about for example if I have a class and I want to implement some kind of functionality maybe I have a polinomial class I want to add them or multiply them together then rather than having to make my own method called multiply what I can do is simply implement the mole um double uncore method and then that will allow me to use a star on it now notice you're going to want to make these types safe because obviously I multiplied by an integer but you could technically multiply two people together um you can do all kinds of things such as that okay so now I'm just going to show you something interesting this is just maybe to kind of inline you a bit or to show you something that we could actually do in theory so what I'm going to do is import actually let me say from Q import q and import inspect now what I'm going to do is just make a q object so I'm just going to say qal Q if you don't know Q it's just a builtin data structure in Python works as a q pretty straightforward and print Q okay so I just want to print Q to just show you that Q does not actually Implement a rapper method so let's just do this um and you can see that we're getting some random you know kind of memory address out to the screen so if I wanted to actually see why this wasn't giving me that representation I could have a look into Q itself so I can say print inspect uh doget Source like that and then I could print my just Q object like this not Q object sorry Q class have a look at the source code and we'll see that if we scroll through it here we don't have any Dunder methods that are implementing any functionality so let's say you wanted to make your own Q class that worked very similar to the python Q class but you wanted to do things like allow the plus sign or you wanted to do things like allow the minus sign well what you could do is you could say from Q import Q as Q like that then you could say your own class class Q is extends from q and then you can Implement your own Dunder methods so that you could override this so for example Define uncore rapper like this and then what I want to do is maybe I want to show a q but I want to say how many elements are in the Q well then in that case what I would do is return q and then I would say q and then I guess in this case going to be self doore Q length or Q size something like that now now what I do if I create a q say uh you know qu equals Q like so and I decide to print out qu like that so let's have a look and we can see we get Q with zero items now the reason I knew to use Q size is because I read through the source code and I saw that Q size returns a length of self doq and I see here we have self. q equals DQ uh what else do we have all these other things so this Q actually just implements a DQ object uh where's the init it's right here it can read through you can understand how this works so if you wanted to actually add something to the que right using maybe the plus sign and you didn't want to implement something else then what I could do is say Define underscore uncore add _ self um item like that and then what I would simply do here is okay let's add that to the Q so we'll say self dop put and then item so now if I want to add something to my Q I can say Q + 9 and it doesn't even need to be equals I can literally just do+ 9 and if we come here and we run this now we have an object CU with length one right and I could keep doing this I do Q + 7 right like that and then if I wanted to I could literally Implement a negative sign so I can say Q minus we have to put something here but if I want then I'd say Define uncore subcore self item and then all I can do is say s let's just say self. getet like that and that's all we need to do so now if we run this we should see Q as length one and even though I mean I don't like I just put a minus sign like this actually I'm curious if this will even work um Q minus imbal syntax so I could do like Q minus none if I wanted to uh and then that still will remove that item for me so this is the idea right these aunder methods allow you to implement these kind of syntax things this higher level syntax and this is what's called again the data model in Python this is how all these different objects work and these Dunder methods can be very useful there's a lot of different ones I'm not going to go through all of them but the whole point is that you understand that each one of these kind of unique pieces of syntax in the higher level of python maps to a lower level Dunder method that implements that imp implements that operation right so that's the way that this works so yeah so hopefully that kind of cleared things up on Dunder methods and Magic methods they're really not that complicated they're very useful and when you're creating classes where these operations make a lot of sense to do like adding subtracting multiplying especially working with numeric values being able to avoid having to create your own methods like Define add x y and being able to just implement the dunder method add and use the plus sign can make things a lot more intuitive um and just easier to read in your programs so anyways that has been it I hope you guys enjoyed this video on Dunder methods magic methods and the python data model as always if there's anything you'd like to see in the future videos please do leave a comment down below like subscribe and I will see you in the next video hello everyone and welcome back to another python expert tutorial series what we're going to be doing in this video is covering meta classes a fairly complex but very interesting topic in Python so we're going to start from the very beginning and start understanding how classes are actually created instantiated um the way they work on a lower level in Python and then from there we're going to move into what meta classes are how they actually work and why we would even want to use them now I'm just going to preface this video by saying meta classes are an extremely complex thing I'm only going to be showing kind of the basic implementation of meta classes here if you really do want to use these you're going to have to look up the documentation and implementation details on your own and there's very few instances in which you need a meta Class A lot of what I'm about to show you can be accomplished in other ways and typically you're going to want to use another way other than a meta class just because these are seen as very complicated and almost sometimes bad practice depending on what you're trying to do so these should really only be used by experts I mean I'm showing them to you guys so you can get an intuition on how they work and if you see one you'll understand what it does but you shouldn't really be putting these into your own code and using them unless you absolutely need to so before we get into the content again a quick thank you to kite for sponsoring this video series they have a download link in the uh in the description down below you can download them for free they are essentially a very good python autocomplete so you can see if I start typing some things like this we get a kite completion thing popping up and anyways that's what they are they're free you can download that from the link in the description all right so let's go ahead and get started now the first thing that I want to do is really discuss how classes work and what classes are so we saw in the previous example and I believe two videos ago I did something crazy like this right and I made a class and I find it inside of a function and then in that function I actually just returned the class itself and this is totally fine this is valid syntax you can see I just ran the code down here we don't get any errors that's fine the reason we can do something like this in Python and not in other languages is because in Python classes are actually objects now the property of an object essentially means that we can interact with it at runtime we can pass it around through um parameters through variables we can store it we can save it we can modify it we can interact right that's what an object is now a lot of people are going to say well how is a class an object I thought a class created objects for us well that's very true a class does create objects for us but that doesn't mean that it's not an object itself and if a class is an object if you believe what I'm saying and I'll prove it to you in a second then that means we must have had some higher level class that created that object for us right just like if I Make an instance of high and I do something like that that means we must have this class High such that we can make an object you know and have the instance for it so what we're going to be getting into here with meta classes is the basic idea is a class defines the rules for an object right it defines the attributes the parameters the methods the things that are allowed the operations that can be performed that's what a class does for an object what a meta class does is Define the rules for a class so when you create a class you will use the meta class to create it this happens automatically you don't need to type anything specifically but we're going to hook in to it later and see how it really operates and that meta class defines how this class is created and that's the basic concept here so I'm going to make another class and I know this is confusing but as we go through here you're going to start to slowly understand with these examples and all I'm going to do is just print an instance of this class so let's look at it we can see this tells us it's an object main test object at some gibberish location so now let's print above this just the class itself okay look at that class main. test now the reason we're able to do this again is because this is an object so I know this doesn't explicitly say object but this class is an object now I want to look at something else so we know we have this method in Python called type and I can look at the type of a uh a class or an instance or an object and I see what it is so let's look at it when we do the type of test we get that is in class main if I were to print say the type of an integer right like the type of two let's have a look that's class int right and we could print you know the type of whatever we want we could print the type of a function so we say Define Funk like that and then just we'll just say pass in there and we do Funk what's that that's class function right so that exists in a function so this is an object this function is an object everything in Python is an object and that means they have a type and they were created somehow so what is the type of a class well let's look at it so we'll delete all this and then we'll just print the type of and I somehow hit insert accidentally there of test so what do you think this type is is it of type test is this class of that type no it is of Class Type now I know this seems ridiculous this means nothing to you right now we're going to dive into what this is but essentially this is what we would refer to as the meta class so this type is what essentially defines the rules and creates this class for us when we type this class syntax we will call a type Constructor using the different things in our class to make this class object that we can then use to make objects and use to interact with in the program so what is Type how does this type thing work well if I told you that this class all this is doing the syntax is just calling this type class then we should explicitly be able to create our own objects without typing out the syntax like this we should just be able to use the type class itself which is true and what I'm about to show you so I've just created class test it it has passed it has nothing in it right now I'm going to show you how we can make this without actually having to type this kind of syntax and writing out class in fact and this seems ridiculous I agree python should have done a better job when they defined this but I believe it's something to do with just backwards compatibility we can make a class by doing this and just watch and then we'll talk about exactly how it operates so this line of code is completely equivalent to this these two things are completely equivalent there's absolutely nothing different about them and I can use test here the same way I can use test here just like I can create an instance of test I can create an instance of this other test so let's do it let's let's prove it to you so if I print test and Make an instance boom main test object Works totally fine no issues with that what else can I do I can print the class and again same thing we have that object totally fine that's because this function here essentially creates the class for us using these different arguments a name this is the internal representation of the class any bases which means anything that we inherit from so like a super class or a parent class and then any attributes so let me start showing you what I mean uh and then hopefully this should make some more sense so I'm going to set an attribute of five I'm going to say t equals test Make an instance and just print that attribute uh go like this of t.x so just like this works on a regular class we can do that we get our value five now just like in regular classes as well I can Define attributes outside of the class so you say something like t. Wy why not set that equal to let's just say hello want to print Wy sure let's go for it uh T.W one second guys oh T is not defined so that needs to go above so I can explain meta classes but apparently cannot just create regular classes okay so that's totally fine that works we have t equals test and then T.W equal hello we can print that attribute that's totally fine so that's how we can create classes using type now what about methods what about sub I'm going to show you all that so we'll do that now uh and then we'll get into actually meta classes and how this is even useful to us so what I'm going to do is make another class I'm just going to call this class Fu let's just make a method in here just called print uh actually not print let's do like show and then all we'll do in here is take one attribute we'll say self and just print hi why not right just do that so if I want to now have an inheritance what I can do is simply type the name of the Class A Comma just to make sure this registers as a tble Here and Now test will inherit from F which means that if I want to use the method show I can do that and I can run that like that and we get that now I shouldn't have printed that out because I forgot that wasn't a return value but you can see we get high that works totally fine this is how you do this right now what if I want you add methods right so to add a method is a little bit different but essentially what you're going to do is just Define a function that will be the method signature so in this case let's say you know add attribute put self like that then here we just say self. Z equals 9 why not right we'll do that and then in here we'll Define our attribute so we'll say addore attribute colon guess what we're going to do add attribute no brackets now make our instance let's call t. add attribute and then let's print t. Z like that and let's look at this and there we go we get the value nine that works fine so this is how we use type this is how we create a class and this is very important to understand as we get into the next part of the tutorial here because if you can understand how we use this to create our own classes then you're going to understand the next part and why when we have a syntax like this all this really does is pass that information to another class called type that creates the class for us and returns an object that represents that class now I know this was a lot I hope this you guys understand at this point now we're actually going to get into meta classes this was just the underlying information we need to understand all right so welcome to the next part of the tutorial what we're going to be doing now is actually getting into meta classes and showing how they work so again the basic principle here is to remember that a meta class is above the classes you're creating yourself so if you create something like class dog right and you do that what's actually happening is all this information that you typee out the syntax gets passed to some meta class the thing above it that actually takes that and returns to you an object that represents that class and that's the whole point here so what we're going to do is actually make our own meta classes so rather than using that builtin type class and you could see on all of our objects when we looked at the type of them they were of type type we're simply going to make our own meta class that inherits from type so does a very similar thing but we're going to change slightly how objects are constructed so you can really understand how this works now you might get lost a little bit at the beginning when I start typing some of this stuff out but hopefully you should start to follow along as we go through and explain how all this works so let's get started I'm going to start just by creating a meta class and I'm going to call this meta now whenever you make a meta class what you have to do is make it inherit from type uh not necessarily but for our purposes that's what we're going to say it has to inherit from type to make a meta class the reason for that is because type does some other things when it's creating an object right and if you don't inherit from this well your class is just going to be not a meta class now because it's going to be using type to create this kind of class if that makes any sense whatsoever but hopefully that does what we're going to do now is I'm actually going to define a new method like this and for those of you that don't know what new does as a Dunder method or magic method like we talked about before essentially this is called before the init method so this is the first thing that is always called when a object is created or instantized or whatever you want want to call it this is always called first so what you can actually do here is hook into this and modify the way an object is constructed by changing what happens in this new method whereas the init all the init is doing is after this new method gets called and the object is constructed what it does is it um initializes uh it changes the values it takes some parameters in like that's what it does right whereas new is just called beforehand to modify the construction of the object okay so what I'm going to do in here is I'm going to take self I'm going to take class name and remember this is what's going to be called whenever we create another class that uses this as a meta class we're going to say class name we're going to say bases and bases is what we put remember in that type argument when we want to do inheritance we have the name we had the bases and we have the attributes and guess what this last one's going to be it's going to be attributes so essentially we're saying okay when we create this new method the construction of a class which happens in this meta class needs to contain the class name the bases and the attributes so that that way we can look at them we can do something with them and we can return to you a class that has those pieces of information right as an object so what I'm going to do now is simply just return the type of in this case it's going to be class uncore name bases and htrs now this is very simple we're not really going to do anything other than this but I'm also just going to print out the attributes so you can see what they look like okay now what I'm going to do is I'm going to make another class I'm going to call it dog this is going to have a meta class that's equal to meta like that and then in here all we'll do is just say x = 5 y = 8 just so we can look at some things when we print these attributes out and then we'll create an instance of dog so we'll say d equals dog like that and run the code all right so look at this what has happened well actually I'm even going to get rid of this and just show you that even if I don't create an instance this still runs right you can see no instances this is still running the reason for this is because the default meta class of dog is type right that's what it runs and that's how the class is created what we've done is we've overridden that we've changed it to our own meta class and essentially we've added our own little piece here that just prints out the attributes and then returns to us an object remember this is an equivalent way of creating this class by just literally typing this line and this is what happens this is what we get so we can see that we have the attribute module is equal to main the qual name dog so that's the name of this class right and then we have our attributes so X5 Y8 that we've defined down below now what if we Define a method called hello and we print say hi inside of here well then you can see we have dog. hello at some memory location that's mapped to by hello and that's a function so that's how this works now knowing this information meta classes can be very powerful because for example let's see like I can hook into the construction of this class and I can modify the construction of it if I want now this is something you would never do what I'm going to do is actually change all of the attributes that I have here to be um what do you call uppercase so I'm going to change this x to be a capital x this y to be a capital Y and this function hello to be Capital hello so all capitals I won't bother changing I can't change these underscore methods but I'll show you how we do this okay so let's start programming this so what I'm going to do is I'm going to make a blank dictionary I'm just going to call it a because notice down here that all of my attributes are actually in a dictionary right so what I'm going to do is modify this attributes dictionary based on the attributes that we passed in and make them all capital assuming that they're not they don't start with two underscores so what I'm going to do is say for item in hrs. items and I'm not sure if the syntax is 100% correct so there might be a mistake here we're going to say if item do starts with and in this cas case it's going to be underscore uncore then what we'll do is simply just add it back into the dictionaries actually yeah we'll just add it back into the dictionary so we'll say a in this case item equals ATS and then item like that so essentially since this is dictionary the way this is going to work right is we're just assigning this item to this new dictionary it's just literally the same thing right okay otherwise so if it doesn't start with a double underscore we need to change it to be uppercase so we're going to say a and in this case item. uper like that equals atrs item then we'll change the attributes here to be a which will be our modified attributes and that means when we return this dog class this should work assuming I haven't made a mistake which is likely but let's look at it and let's see what I got wrong all right so I guess I forgotten the fact that when we do something like this I need to actually Loop through with name value rather than just item so name will be the attribute name value obviously the value mapped with it just means we're going to have to change a few things here which we say name so having to do that we can change that to Val we can say name and that's yeah so name here this will be Val like that and I think we should be good on that front let's run that um and let's have a look at this air name Val is not defined of course I've made it value let's run and there we go we get good okay so let's I haven't proved to you really what happened but let's just step through this code cuz I did make a few errors so it might be confusing so we started by printing the attributes we then made a blank list uh a blank dictionary sorry that's going to represent our new attributes and then we've looped through all of the attributes so we just do do items to get uh the name and the value and we said if the name starts with a double underscore just add the proper value back in otherwise what we'll do is add the uppercase attribute with that corresponding value so we've changed them to Upper uh to uppercase essentially so let's actually print the values down here so the new values just have a look at the difference and you can see if we scroll up here that notice hello has been changed to Capital hello X to capital X and Y to Capital y so now let's do another proof just to make sure that all of you believe me that this is okay to do and let's go down here and say d equals dog create an instance and let's try to say see what d.x is so just print d.x well what is the error let's look at this here dog object has no attribute X what's but we defined X up here that's because we've changed it to be a capital X and notice that when I do that that's totally fine and same goes with hello I can't access that but when we change that to Capital hello we're totally fine because again we've modified the construction of the object all right so now that we kind of understand how meta classes work we've seen that we can hook into them we can change the way that objects are created we can en Force certain constraints I can change all of the attributes to be capital I can do whatever I want right I could change the bases I could remove an inheritance if I didn't want that to be allowed essentially this is why they call it magic because with this kind of hook into the creation of classes you can really enforce quite a bit of constraints on how classes are created so for example if you want every single class in a specific module to never be allowed to use a certain attribute or to only have or to have to have that attribute you could set meta classes for those or for that actual specific module which I'm not going to talk about now and then when that module's run it will check The Meta class right it will go through the meta class that's how we create the classes itself and make sure that all of these classes kind of conform to that structure that you've defined now this is specifically nice for when you're writing kind of Library code and you want your user code to be very specific let's say they're inheriting from a specific type um you could check if they're inheriting from you know whatever type it is that you want if they do inherit from that type you can enforce the fact that they have a specific function or specific method in that class that's needed to make that work so that's some of the things that you can do with meta classes again they're very complicated there's not really like a need to use them so you don't necessarily need to implement them into your program but sometimes they're cool and understanding how this class construction Works to me is even a better benefit of using the meta class itself so I believe there was one last thing that I wanted to cover here although it's not coming to me at the top of my head I mean I think that's pretty much it I don't know what more more I can show you guys you can have meta classes that inherit other meta classes you can do very very complex things with that but I think honestly for now we're going to wrap the video up at this I hope you guys enjoyed I hope you understand now how classes are created how meta classes work and what the heck they even are and I hope that you understand that you don't need to use this and the point of this video is to introduce you to the concept and make you more familiar with the way that classes and objects actually work in Python so anyways that has been it I hope you enjoyed make sure you leave a like if you did subscribe to the channel and I will see you in another expert Python tutorial hello everybody and welcome back to another expert Python tutorial so in today's video we are going to be talking about decorators which are a pretty cool and useful tool they're not super complex but essentially they allow us to modify the behavior of a function without actually changing any of its code now this is useful because sometimes you want to be able to add and remove decorators while debugging a function or maybe you want to change the behavior of all of your functions and rather than going in and changing all of the code you could create a decorator which will allow you to Simply you know use one line of code to change the behavior of all of these different functions so I'll show you how this works and what a decorator actually is to start by just going through a bit of a kind of recap of how python passes objects around and why we can actually even use decorator a quick reminder before we get started that kite is the sponsor of this series kite is the best AI auto complete for python on the market and you can get it for free in the link in the description it integrates with the all the popular idees and text editors so subline VSS code adom Vim you name it chances are kite is you know compatible with that again you can download that from the link in the description so the first thing I'm going to do is I'm going to create a function called Funk now what I want to do is just show you that if this function takes a string I can actually return another function in here that does something with this argument and we've seen this before in the previous expert python tutorials but I want to just make this very clear on how this works so I'm going to call this function a wrapper because it's in side of this function it's not going to take anything as an argument and what I'm simply going to do in here is say print started print string and print ended like that and we'll do a capital and I guess actually this string sorry does not need to be in a string it needs to be like that so we print the variable and then what I'm going to do here is simply return the wrapper function like that so if I do this now what happens if I say x equals Funk like that and I put in my string let's say hello and I run this program you can see we get started hello and end it now the reason that happened is because we returned here the wrapper being called right these two brackets but if I remove this and I do this now nothing happens so what we've actually done if I print out the value of x is you see we store a function in here that was returned from this function which is actually equal to this and then if we wanted to call this function we could put our little braces like that and here we go we get started hello and ended so I just want to show you that this is possible and the reason this is possible is because functions in Python are objects which means that we can pass them around we can throw them around our program and you can see up here that this is the location of the object you know function wrapper from funk. locals okay so now that we understand that let's bring it up a little Notch and see what happens if we actually instead of just just passing a string in here pass another function so I Define a fun function I'll call it funk two like that and all we'll do in here is just print something we'll say I am Funk 2 why not I'll get rid of this and now rather than passing a string in here why don't we actually just call some function so let's put F in here let's put I don't want Funk two I just want F let's call whatever function is called so we'll do print started call whatever ever function was in here and then print ended and then return this function so let's see how this works so now if I can move this down a bit let's say x equals Funk Funk 2 let's print X and then let's call X so what we're doing here for anyone that's confused is we've created this function which accepts a function as an argument right or as a parameter then what we do in here is we Define a function that prints started calls whatever function was passed in prints ended and then returns this function so this is not actually going to do anything until it is called so when we return this we'll store it in a variable X and then when we want to use this interior function here we call it with this right the X and the brackets so let's have a look at how this works contrl B and you can see started I am Funk to ended fun Funk uh rapper locals right and the idea here is that I can do the same thing with say funk three right right if I print let's say I am Funk 3 like that now rather than passing Funk two I can pass Funk three and we can see now we get the same thing happening except Funk three and in fact we could do it you know I could say y equals Funk Funk 2 and then we can do the same thing and just call Y down here and now both of them are going to work and they're both going going to be different so started I am Funk 3 started I am Funk two ended so with this in mind we can start looking at kind of what a decorator is now almost but I just want to show you a way that let's say you know this function right here which we're going to call our decorator we don't want to have to do this weird call right where we use our decorator function to call function three we just want to call function three and have it do this behavior and you know do whatever function three is right how would we get that to work how would we get that to happen we rather than me having to call Funk and pass Funk 3 and Call Funk and pass Funk 2 how can we do this another way well what I can actually do is kind of a cool sneaky line here in Python where I do this I say funk three is equal to Funk at Funk 3 now this seems like a weird line of code but essentially what this is going to allow us to do now is rather than having to call function and pass Funk 3 in we can actually use Funk 3 which is a variable now which stores the function that is returned from the call of Funk with function three which means that if we call Funk 3 like that then what's going to happen is it's going to run this function that was created from this call so this is a way that we can kind of change that behavior we can say okay so Funk 3 I always want this whatever's inside this wrapper function to happen whenever I call it so all I need to do to Define that is write this line of code and now every time I call Funk 3 from anywhere in my program it'll do this and if we run this we can see that happens and that works fine and we can do the same thing with funk 2 um yeah Funk 2 equals Funk Funk 2 and then we'll call Funk two like that and we can see that it works for both of them so this is where we now get into the concept of a decorator things are going to get a little bit more complicated but now all I'm going to show you is what a decorator does versus what we've done so this kind of line of code here is weird right like it's not something you really want to write you don't really know where to put it it's like just not ideal to have to write this line of code so python has thought of this for us and what they've introduced is a syntax that essentially allows us to do this um just in a better way and all it is is using this at sign and putting the name of your decorated function so like that just on top so now this line here pretty much just replaces this line like they are exact identical copy they do the same thing this just looks a little bit nicer and it's a little bit easier to understand what's happening when you have you know this decorator syntax above the function and you can actually decorate your function with more than one decorator if you want we're not going to talk about that right now uh but that's something to note so pretty much to replace these lines of code all I have to do is put at the name of the function that I want to run before right and then now if I do fun three and fun two we can see we get the same thing so we get started I Funk 3 ended started I am fun two ended so this is how this works so whenever you're creating a decorator function you need to kind of implement this raer functionality where the first thing takes the function itself and the second function here well this just takes the um or what is this this creates the function that's going to be called when this is returned right or when you actually call this function so essentially you're changing your said Funk 2 is now going to be equal to whatever this is and usually inside of here you're going to use the function now there's a lot of problems that I'm sure some of you can think of here so what happens if I say fun 2 takes an argument X and instead of saying uh I am fun 2 all it does is just print out x what happens now well if I run this and I even let's give an argument let's give five here you can see we're getting an error right and the reason we're getting an error this huge error what it say rapper takes zero positional arguments but one was given so the issue is that when we actually call Funk two what we're actually going to be calling from this line of code is this wrapper function so this wrapper function needs to have the same amount of arguments that function two has so how can we do that how can we fix that well we could just put an X here like this right and then let's comment out fun three let's run this uh oh sorry my bad we got to throw an X in here that was what the issue was before so we have our X's there and then this works right so I put an X in the wrapper I put an X here which means that when I call this x will be passed to this wrapper X and then we can use that to call the function and that's totally fine but what happens now when I want to use Funk three and Funk 3 does doesn't take any arguments but this takes arguments the whole point of decorators is to be able to use this on multiple functions and we get missing one required positional argument x uh Funk three there's an issue you know things are happening so what what do we do here how do we fix this well this is where we use what we call the unpack operator I believe or the Splat operator or something but essentially you can put star args star star quars like this and what this will allow you to do is accept any number of position or keyword arguments so essentially this says okay we don't know how many arguments are going to be coming in here there could be an infinite amount so rather than just trying to guess or figure it out or write a different rapper function for every single amount what we'll do is simply write star args star star quars which tells us except all of the arguments that are passed in except all the keyword arguments and what we can actually do is simply pass whatever these are to this function so let's do this here star star quarks so now what's going to happen is any arguments pass in we'll just automatically pass to F same with quars and if there's none we just won't pass anything so this kind of handles any amount of arguments and now we'll see that when we run this we don't get any error and this works fine for any number of arguments so even if I were to add you know X Y in here something like that and then we call this with like 56 and run that still same thing this is working doesn't matter how many arguments we have we're perfectly fine okay so that's good but what happens when we return a value from function 2 well what happens then so let's say x equals print X and right now so we can see that we're returning y from function 2 right but if I call this and I print X we don't get y return to us so how can we fix this right so what we actually need to do is since we're calling the actual function here inside of the wrapper we need to store the return value I'm going to store that as RV so that I can return it at the end of this wrapper function so since this wrapper function is returned from here this could return a value as well and well we don't want to return immediately so like I could just write the line return F like that and that would work fine but we want to do something after the function is called so to you know solve this we do RV and then we can return RV so store the return value of this function return it at the end and now if I print this you can see that we get our return value of six so that is how we return turn values that is how we pass in different amounts of parameters and now I'm just going to show you a few actual useful um decorator functions that you might want to use so you're probably looking at me like well what's the point of this right now like why do we have this well a good example is say you want to validate input say you want to have a bunch of functions that accept some numeric input and that numeric input is always going to be between the value 1 and 10 right rather than checking the parameters every single time inside of your function what you could do is you can use a decorator that checks them for you right and then all you would have to do every single time you want to validate that your input is correct is throw a decorator over top of your function that says validate input or whatever it's called Write the appropriate code inside of a decorated function and this these kind of functions like this and then you're good to go so that is kind of the idea behind decorators that you can modify the behavior of a function add functionality to it without modifying the code and sometimes you don't want to touch the code of a function because you want to make sure that you're not breaking anything you don't know how it's been written but you want to add something on top for example maybe timing how fast the function runs and this is a very common example I'll show you this as kind of our last example to using decorators um so yeah we'll do a timing one so essentially if I want to time how long a function takes to run every single time right then I can create a timer decorator so you know what actually let's do it from the start let's erase all of this um and do one from the beginning so I'm going to say Define timer which is the name of my decorator it's going to take in a function we'll Define a wrapper this will take STAR args uh star star quars like that again quar stands for keyword arguments what we're going to do here is start by importing time we're going to say uh let's say start equals time.time like that and then we'll just print started or actually we could do something else let's do this let's say uh RV equals Funk like that and then let's say end or guess we'll say total equals time. time minus start and then we'll print time like that and we can put total and then we will return RV and return wrapper like that oops I did not mean for those okay so now that we have that let's create function let's just say defined test and then here we're just going to say 4ore in range 1 th000 let's just say pass and there we go so now if I want to decorate this function I can say at timer and what this will allow me to do now is when I run this function have it tell me how long this took to run so let's go ahead and just actually call test like that and see it ran in 0.0 seconds so I guess this rounded for us but I guess would I be able to do this make it take any longer if I add any more zeros there we go so we can see that is how much time this function took to run and if I wanted to add timer on another function well then I could do another one say test two like that and we can even just say time do sleep why is my capitals on 2 seconds and we'll decorate this one with at timer as well and now when we call test two and we run this give it a second and we should see that this takes 2. o1 seconds so this is how decorators work again useful when you want to modify the behavior of a function without actually touching it without changing it you can add other decorators on top of an existing decorator I'd urge you to see you know how that actually works how you'd be able to do that you can test that out for yourself but for now that's pretty much it and a really useful example of decorators is a timer decorator when you're debugging you want to check what is really slowing down or how long something's taking another good example is having a logging decorator so having a decorator that essentially logs the calling of functions or what's happening in the program that's a good one to add here and then obviously validating input and checking return values and stuff like that is always a good example of when you might want to use decorative so with that being said I hope you guys enjoyed if you have any questions as always leave them down below and with that being said I will see you in the next expert Python tutorial series hello everyone and welcome back to another expert Python tutorial so in today's video we're going to be talking about generators now generators are a pretty straightforward and actually very useful expert level feature in Python and chances are you've probably seen them before now before we get into generators I do need to quickly mention that this uh Series has been sponsored by kite so kite is the AI autocomplete for python that I've been using throughout this entire series and just through my daily coding you can see that when I actually start typing something we get these nice suggestions top um popping up from kite with the little kite icon here it is just the best python autocomplete it works very quickly and actually saves you quite a bit of time and works for other modules that aren't just builtin python things so it's pretty useful if you guys want to download it there's a link in the description and it's free so you know go ahead and do yourself a favor if you do want that auto complete okay so now let's get into generators now actually before I discuss generators I want to show you the problem that generators help us solve so we should understand that in our computer we have a finite amount of memory a finite amount of RAM and when we run a computer program our program is loaded into that memory and when we're storing things manipulating variables lists all of that that's all stored in our computer's memory that's because that is the fastest way for us to retrieve and write data while we're in a program you know we could put some things on a hard drive but that's pretty slow and it really depends on what we're doing but most of the time we're working in Ram and what that means is that we are limited to the amount of ram that is in our physical computer when we're writing a computer program and in fact you know most of us will never even see the error that I'm about to show you but it is possible to actually fill up all of ram right to use all of ram to have nothing left and in fact that's what I'm going to try to do right now so if we look at the example on the screen and I've just started running the code you're going to see this takes a second to run what I'm trying to do is generate the sequence of all of the squares from the number zero up until I want to say this is like 100 million or 10 million or some number like that right and then what I'm going to do is Loop over all those numbers and print them out and you're going to notice that very shortly yes and there we go we get the error we get a memory error which essentially means that no we can't do this these numbers are too big we don't have enough room left in memory we're not allowed to use that much space no that's not allowed so how do we go ahead and how do we fix this well this is where we use a generator now before I actually create a generator I want to look at something here if all I'm doing in this specific application is just printing or processing say one value at a time which is what I'm doing when i'm looping over this list right one value at a time I'm processing it I'm not accessing other values I don't need values that are in the future I don't need values that are in the past then is it really necessary for me to create a list like this to Loop through and the answer is no obviously right in fact what I could do is replace this for loop with just a print statement right so I could replace this entire thing actually we'll just do it down here so let say 4 I in range and then we'll just type that same number whatever that's close enough and then what I can do is print I the exponent two like that right and this is the same thing and this is the idea behind generators this is not what we're going to do precisely to generate this sequence but generators allow us essentially to look at one value at a time and to not store the entire sequence of numbers when we don't need to do that and I'm actually going to code out our own kind of generator pattern here that just uses a class and some Dunder methods to illustrate what's actually happening inside of a generator when we use it now I understand that most of you probably still don't know what a generator is but after I write this class and start showing you hopefully this should make sense so what I'm going to call this is just gen and what I want this to do is the exact same thing that we did before where it's going to generate a sequence of all of the squares up to some number let's say that number is ADD so in this case I'm going to say let's define uncore uncore nit uncore uncore let's take self Let's Take N let's say self. n is equal to n and then let's say self. l is equal to Z so this is going to be the last number that we generated the square for and we're going to use this variable to keep track of the last number we generated the square for so that we know which next number to use and I'll show you how this works we're going to define a actually in this case we're going to do a Dunder method so underscore next it's going to take self and what it's going to do is return self. next now I know we haven't defined self. next yet well we're going to do that now so Define next self and in here what I'm going to do is generate that sequence that I did before except I'm just going to do it using these two variables I'm not going to do it using a for Loop like we had before and storing everything in a list so what I'm going to say is RV equals self. last to the exponent 2 so this is saying our return value is going to be equal to whatever this last number is that we have to the power two right so we're going to find the square for that then I'm going to say self. last plus equal 1 we're going to say if self. last and in this case equals equals self. n + 1 um actually what I need to do is sorry put this at the beginning of my Loop so if self. last here equals equal self. n then what we're going to do is say raise stop iteration stop iteration is just an error that we can raise that essentially tells us hey no we can't go any further and then what we're going to do is return this RV okay so now I'm going to show you how we can use this so this we can actually use in a very similar way that we were kind of looping through the numbers before and we're going to say in this case g equals gen let's say we want to Loop up to you know some massive number like that and now if I want to actually Loop through this entire sequence what I can do and I mean some of you are saying oh this isn't big enough okay let's go bigger we'll say while in this case true we're going to say try print the next value of G right and what this underscore uncore next is allowing me to do is call this next function or method or whatever you want to call it on G here here and we can print the value and then I'm going to say accept stop iteration and then we're simply going to break this Loop like that and we should actually be good with that okay so what this is going to do now is Loop and I'm just going to make this number smaller just so we can see that it does actually just go up to 100 um but I promise you this does work with an infinite sequence and we'll watch and we can see that this works just like we would have before and we can generate all of the squares for these numbers now I can make this number absolutely massive I can make it you know that's super long number and this will be totally fine and in fact that's because we're not storing all of this in a list where we're storing all of the previous values all we're keeping track of is kind of the internal state of the next number we need to generate and this is the idea behind a generator is that we don't need to store every single value what we can do is just store you know almost the last value that we generated and then using that we can generate the next one right or we can figure out the next number to generate and obviously this kind pattern like you can write this if you want but what python has done for us is kind of come up with a pattern that makes this a little bit easier called the generator pattern so what I'm going to do now is pretty much take this class and I'm going to convert it to a generator and I'm going to show you how this works so I'm going to say Define gen and here this will just take the value n what I'm going to say in here say for I in range and in this case we'll say n then we're going to say yield I to the exponent 2 now I know this seems weird but it's essentially the way that this works is we instead of using this crazy pattern that we had before we're going to use the yield keyword now what the yield keyword does is as soon as we hit this it returns this value to wherever this was called from or wherever we were looping through and then it pauses this function so rather than stopping the execution of this function which is what a regular function would do when we hit the return keyword it just pauses it which means we actually keep track of what I was so we still know what that number is we still know you know what n is we still have all of the internal information of this function stored in memory we haven't gotten rid of that but we're just pausing when we hit this yield keyword that's what that means so think of yield as like a pause whereas for example return would be a stop of execution so we can use this generator by doing something like this g equals gen give it some number like this and then what we can do is say 4 I in G and then what we can do is simp simply print out I now this is going to work the exact same as all of the other examples I've seen I've shown you before and you can see that indeed it is working and we could run this you know infinitely and we're not actually going to ever run into a problem and in fact I probably should have made this number a little bit smaller because I feel like this is going to run for a long time but anyways that can go down there so this is the point of a generator and I know some of you are still confused but the way you have to think about it is we create this generator by creating this function gen with uh what do you call it you know 100,00 th000 or whatever it is whatever this number is 1 million and then what we can actually do is Loop through this and what happens when we Loop through this is it runs this for Loop up until it sees this yield keyword so it sees this yield keyword I to um squared right and then as soon as it sees that what it does is it pauses the function and says okay we don't need to run this anymore and then it waits until it's called again so until we Loop through it again with this for Loop the next method on it is called and then it returns to us the next year and because it's pausing rather than stopping execution this is totally fine and in fact we can actually look at how much memory this function is using versus if we were to do the same thing say with a list and we'll do that in a second but I want to show you that to use this generator I don't have to just Loop through with a for loop I can use that next method that I showed you before and if I do nextg and I run this you can see we get zero because obviously the first answer is zero and if we do this a few times we get zero 149 so this is how this works when we call the next method or the next function on our generator we get the next value so essentially up until it hits the next yield keyword and in fact we actually can use more than one yield keyword in our gen if we want and I could say yield one uh and we could do as many yields as we want so let's do this and then let's actually show what happens when we go past how many yield keywords we have so if we look at get this here we can see we get 10 100 1,000 10,000 and then we actually end up getting an error and there was a one up here just so you can see and that error is actually a stop iteration error right here because we don't have any more keywords yield inside this generator so there's nothing more to return so this works the exact same way that I showed you with that class that I did before where it keeps track of the internal state it knows what line it was on when it paused and then it goes to the next one until it hits the next yield keyword and that's when it pauses again and that's how a generator works and they're pretty useful there's some other things that we can do with them and in fact I'll show you um comparing the size of say a generator like the one we just created versus actually generating an entire list you can see in memory how much this is actually using so if we want to generate the sequence right we know this generator works we can use that now so let's run that and what I'm going to do now is import Sy I'm going to actually make that list that I did before so we're going to say x equals and in this case we'll say I to the exponent 2 for I in range and we'll just do uh let's say 10,000 like that and we'll replace 10,000 Here and Now what I'm going to do is just print out the size of both of these so I'm going to say sy. get size of and in this case the first size we'll look at is X which is that list and then we'll get the size of G and I'll show you the difference in memory so what this does is tell us how many bits or actually I believe how many bytes are being used by whatever object is we pass in so in this case the list and in this case the generator and you're going to see that we have a substantial difference so this first list is using 43,81941 need it one at a time which is what we're doing when we say Loop through something then it's much better to use a generator to generate this sequence for us now there's a lot more that I can show you with a generator uh we can close a generator we can stop a generator we can send values to a generator but I'm going to leave that for people that are a little bit more advanced the point of this is to introduce you to this concept of the generator whereas when you're programming think about say if you're going to make a massive list like this with a bunch of values do I need of these values am I using one value at a time am I looping through am I printing it am I adding it to something or do I only need say the last value and this value or a few values and obviously you can make your generators more complicated than a simple for Loop you can do some more complex computations you can store variables inside of here because remember that this yield keyword just pauses the execution when this generator is called and what that means is that I can Loop through this this first generator say you know five times and then somewhere later in my program continue looping through it and it will you know resume where it left off and that's a useful kind of construct it's hard to show any examples in this you know short amount of time but hopefully this gave you an idea of when you would use a generator so with that being said I hope you guys enjoyed if you did make sure you leave a like subscribe to the channel and as always let me know if there's any other expert level features you would like to see in the comments down below hello everyone and and welcome to another expert Python tutorial so in today's video we're going to be talking about context managers now context managers are definitely one of the more useful topics that we're going to be talking about or that we have talked about so far and you'll find yourself using them a lot especially as you get into more advanced programming and dealing with things like shared memory and shared resources and unlocking and locking and yeah it just all those kind of things contact managers come in very handy essentially now I'm actually almost certain that all of you have seen context managers before in fact I'll show you a few examples here of times when you've used them and just not known that you've used them and that's kind of a common Trend here that I'm hoping you realize is a lot of the stuff that we're using it's not completely new to you it's not something you've never used before you just never really understood how or why it worked and that's what the point of this Series has been is to give you that appreciation and understanding of how these lower level things work so that you have more control over your code and if you need to change them or write your own versions you now know how or at least have the intuition to do so now again this video is sponsored by kite a big thank you again to them you can see whenever we start typing we got these little kite keywords popping up it's just a really good auto complete and again it's free if you want to download it it's from the link in the description you can find that okay so let's go ahead and get started with context managers now the first thing that I want to do is show you what problem context manager solved to us so I'm going to start or solve for us so I'm going to start by showing us the problem and then the solution with a context manager so essentially let's say we have some file and we want to we want to open a file right so want to open say file.txt we'll open it in right mode which just means create a new file if it doesn't exist yet and then what we'll do is say file. write let's say hello and then we'll say file. close okay pretty straightforward pretty basic this will work run this code nothing wrong with it but what actually is wrong with what I just wrote well looking at this at a surface level it seems like everything's totally fine I mean we've opened the file we've written one line to it in this case hello and then we've closed it now the issue occurs in this code if this line here so this file. right line doesn't work or it doesn't happen for example like if I just error this line by putting line X here and then we run this we can see that we don't make it down to this file. close line because we had some error on this right line so say we open the file and we start trying to write something happened something else had the file open we couldn't access it well now we've opened the file and we haven't closed it and that's an issue we need to make sure whenever we open a file or have some shared resource that we work with that we close it afterwards now a better example would probably be if I open this in read mode um as opposed to write mode because that would mean that this file already exists on the system but hopefully you get the point that the issue occurs when we open the file we do a bunch of stuff and we don't reach that file. close so the point is how can we make sure that we reach this file. close no matter what happens in between the open and in between the close well the way that we could do that is we could use a try and a finally statement right so we could leave what we have right here and we can just add a try like that and then we could add a finally uh down here if we indent that properly for the file. close so what this means is regardless of if this works or not we will eventually or finally close this file so that's good and we've just kind of fixed our area there and that's totally fine but there's an easier and better way to do this that allows there a little bit more functionality and what that is is a Conta text manager now this code right here is completely equivalent to what I'm about to write so with open file.txt we'll open in R mode again we'll call this as file to be consistent and we'll just simply say file. WR and in this case Hello so these two kind of blocks so this block up here and this block actually do the exact same thing and the way that this works is this open method here actually defines what we should do when we use it as a context manager when we exit and when we enter so when we enter what that means is okay when we open this file when we write this code what's the first thing that needs to happen well the first thing needs to happen is we need to open the file and we need to return that so we can store that as the file object that's the thing that's happening when we enter this context manager and we can tell we're using a context manager because we're using the with keyword and that's the most common way and kind of the only examples I'm going to show you here is using the with keyword in pth then what we do is we do something whatever we have inside here we could print something we could you know fil out right we could do a for Loop doesn't matter and then when this is done so all of the code in here regardless of there if there was an exception or not we will call the exit method and what the exit method does is some kind of code that allows us to close our file properly and make sure that everything works so essentially the context manager is kind of like a hidden way to make sure that whenever we do one operation we do another one regardless of what happens in between and again that's really useful for things like opening and closing files and for locking and unlocking shared memory so now I'm going to show you how we can actually write our own context manager that does the same thing that we've just shown here so we have this open F function and we say with open file. txtr as file file. WR hello we understand that after this runs regardless if there's an exception or not we close the file but how does that actually work well let's try to do that so what I'm going to do now is I'm just going to make a class and we're going to write this context manager so I'm going to say class file I'm going to say Define nit and since we just want to do the same thing we did before we're going to take a file name and a method in our nit and we're going to say self. file equals open file name method now it's important to note that when we make a context manager we don't necessarily need to use it as a context manager all the time in fact I'm going to start writing a context manager here and show you the methods we need to implement to do that but right now you know the function that we have here we can use this fine even though you know it's going to be a context manager we can instantiate it and we can use it as we usually would we just aren't going to call these special methods that I'm about to wct so we have the first method which is called enter now remember enter I told you is the first thing that happens and what this function needs to do is return to us some value that we're going to use in the context manager right when we wrote for example with something um as you know F then this something is going to call this enter method so we're going to store whatever's returned from enter in F so that's what we should get there so here what we're going to do on the enter is simply return self. file and again that should be the open file object then what we're going to do is Define an exit method so underscore uncore exit uncore uncore and notice these are special Dunder methods because they're going to be called in a special way automatically from python because we're going to use the context manager syntax so here actually takes three arguments and the three arguments or parameters I guess we have our type I believe we have I'm going to look to make sure I haven't messed this up we have value and then we have Trace back so essentially what this does is regardless of whether or not we get an exception between when we open or so between when we enter and between when we exit if we get an exception it's actually going to call this exit method with that exception so that we can handle the exception in here the way that we would like and I'll talk about how that works a little bit more in a second but let's just do what we wanted to do which is self. file. close so for now we're actually going to omit the fact that uh we're going to deal with these parameters although we'll talk about them later so in here I'm actually just going to write some code um some print statement so that we can see what happens when we enter and when we exit these methods so print enter print exit so now what I'm going to do is I'm going to set up the same thing I did before except this time instead of saying with open I'm going to say with file and the reason I'm allowed to do this is because I have this enter and exit method defining that this is a context manager and I'm going to say with file we have let's say you know file.txt let's put that in say read mode um actually we'll put it in write mode and then we'll put that as F we can say f. write hello as the classic example that we've been using and now let's actually run this code and let's look at these print statements and make sure this works okay so we get enter and exit and inside here I'm actually just going to put a print statement that says middle just so we can see how this works so even though I have it explicitly called this exit or this enter method we can see that they do get called so enter middle exit and they get called in the appropriate timing right so this stuff happens in between the enter and the exit and now what I'm going to do is simply put an exception in here so I'll say you know put some letters here just to make sure this crashes let's run this um and actually sorry that's going to be a syntax see if there's any way that I can get this just to crash uh let's just say raise exception like that and now let's see if we still get um all right yes we do so we can see we get enter middle exit and then we get the exception raised afterwards even though we raised the exception before we got to this exit method so what this essentially says is regardless of if there's an exception or not we're going to call this exit method and the point of this is so that we can actually handle an exception inside of our exit method if we need to so I know this is kind of confusing to see in my Trace down here because there's all this text but look what's happening right we can see that in line 17 an exception was raised but the thing is we still called this exit print um and we still closed the file even though that exception was raised which again is the advantage of a context manager okay so what I want to do now is show you what this type value and Trace back actually is so we notice that what happens is essentially any exception that's raised inside of here actually gets sent to this a exit function where it can be handled and that's why we see this exit popping up here because we enter we do this middle stop some exception was raised in the middle that's fine so we immediately go to this exit function where we pass that exception and we wait to see if it gets handled and that's why all of this code in the exit function runs before we decide that we're going to crash the program or that something's going to happen so what I'm going to do now is show you how we can actually handle an exception inside of this exit function and again what type value and traceback are so now we'll keep printing exit but we're also going to print all of the different values that are here so we'll just use an F string and we're just going to do a bunch of commas so that we can see what all these are so type value and in this case Trace back so let's run this now we're still going to get a crash in our code but now we can see that we have class exception none and then a trace back at some location so if we wanted to we could look at this traceback we could look at the type of the exception and we can actually handle it and in fact the way that we handle an exception from our exit is if we determine that this exception is fine that we shouldn't crash the program that all is good what we're actually allowed to do is return the key value true so if we return true from this exit method here that's going to tell python that we gracefully handed handled this exception which means we don't need to crash the code we don't need to run or you know see all this Trace back in the output here we're fine and we're good to go and in fact if I run this you can see that by simply adding this return true here we no longer get a crash in our program and everything is fine now be careful with this because you don't want to just add return true if there is actually exceptions and they need to be handled properly in fact a better practice would probably be to do something like if type equals equals and then whatever type of exception you were looking for maybe I raised like a file not found exception or something and we were looking for that specific one then what you could do is handle that exception inside of here and then return true in that instance and in fact this still works because the type was exception um but I'm trying to see if I can raise like yeah so let's say file um exists error like let's do something like that and run this and you can see now because that wasn't just a regular exception this crashed because we didn't handle that properly so that's how we can handle errors inside of this exit function you just return true if when you check through this error that's passed in here um you get you know some valid stuff and can handle it right and if you don't return true and there's no error like we've seen that's totally fine so if we don't raise some exception regardless of if we return true or not everything works fine and we're good to go and that is one of the massive advantages of context managers okay so now I'm going to show you how we can actually create the same context manager because this seems a little bit complicated using a generator so we've talked about generators and we talked about decorators what we can actually do is import something called context lib so we can import context lib like that and from Context lib there's actually a decorator in here that allows us to decorate a generator that becomes a context manager and I'm going to show you how that works okay so let's do the same example we did before with opening a file but now using a different kind well not really different kind but just a different way of creating this uh context manager so what I'm actually going to do is I'm going to write this decorator and The Decorator is context li. context manager like that there's no brackets at the end and in fact what we could have done is said from Context lib like this import context manager and this is a builtin library in Python and that will just allow us to do this rather than having that um dot beforehand so let's do that I'm going to say Define file like this and what I'm actually going to do is take again the file name and the method and inside here I'm going to say okay file equals open and in this case we'll say file name method then I'm going to yield cuz again this is a generator the file object and then I'm going to file. close so what this means essentially is that the first thing we're going to do is say file we're going to create this file object we're going to yield this to wherever we're being called from and then when this function resumes again you can think of this as the enter right and this as the exit we're going to close the file and in fact in here again we can handle some exceptions we can do things like that and this is a quicker easier way to actually make a context manager so now I can say with file and in this case let's just say you know what what have we been doing I don't know let's just say text.txt let's switch it up here let's go W mode and we'll say as F and we can say f.r let's say hello like that and if we run this code that's perfectly fine that works and now when we add our print statement so we'll say print uh enter like that and we'll print exit like that and then we can print middle and we can see how this is is actually working okay so enter middle exit so this decorator allows us to turn this generator object into a context manager it works pretty much exactly the same as I talked about before there is more to go in and kind of dive in with this uh this syntax right here I typically recommend to people just to use the class syntax just because it allows you to do some more things into something more people are familiar with but if you want to use this context manager decorator and do some things with this generator kind of syntax um to use a context manager you're more than welcome to and that's why I showed you so I think with that I'm going to wrap the video up here an interesting idea though if you guys want to mess around with context managers is to think about locks in threading so actually from the threading module in Python I can't remember the syntax right now off the top of my head you can have shared memory um and you can have locks and yeah like memory locks which essentially allow you to wait for another resource to give up this lock so that you can access a resource so the point is like say we have one variable X here that's going to be accessed by two different threads well we can't access and change X at the same time so we create a memory lock and what one thread will have to do is wait for that lock to be available before it's able to access the object and you can actually implement this functionality with a context manager so that your threads you make sure they unlock the resource before they finish changing it so that's something that's interesting if you want to mess with that I don't really have that much time in this video so I'm not going to do that um but yeah so with that being said this has been context managers I hope you guys enjoyed if you did make sure you leave a like subscribe to the channel and as always let me know if there's any other expert level features you would like to see
