With timestamps:

00:00 - we all know that data structures and
00:01 - algorithms is a must topic for anyone
00:04 - wanting to become a software engineer so
00:06 - in this video I'll break down for you
00:08 - exactly what you need to learn the order
00:10 - in which you should learn it and give
00:11 - you some details on what you should
00:13 - focus on for each individual topic I'll
00:15 - even share with you some resources and
00:17 - tips to learn this as effectively as
00:19 - possible now if you want a text based
00:21 - version of this road map or something to
00:22 - follow along with then join my school
00:24 - Community I have it in there completely
00:26 - for free we have over 8,000 members in
00:29 - the school community you can join for
00:31 - free from the link in the description I
00:32 - look forward to seeing you there so
00:34 - let's get right into it with the first
00:36 - thing you absolutely need to master
00:38 - which is big on notation and time
00:40 - complex the analysis you need to
00:42 - understand how to look at a piece of
00:43 - code and understand how efficient that
00:46 - code is does it run in linear time does
00:48 - it run in exponential time does it run
00:50 - in logarithmic time you should
00:52 - understand how to evaluate that and you
00:54 - should know which code is more efficient
00:56 - than others now it's really important
00:58 - that you spend a lot of time in this
00:59 - section and you really get this down
01:01 - this is not something you can skip you
01:03 - need to really understand this to the
01:05 - point where I can put any piece of code
01:07 - in front of you and you can tell me what
01:09 - the time complexity of that is now
01:11 - usually we're going to do this in bigo
01:13 - notation it's not going to be harmful to
01:15 - learn about big Theta notation and the
01:16 - other types of notation but often times
01:19 - we're just going to use bigo notation so
01:20 - as long as you understand that that's
01:22 - completely fine now the reason we need
01:24 - to know this so deeply is because this
01:26 - is going to really translate to every
01:29 - area of data structures and algorithms
01:31 - the whole reason we use different data
01:32 - structures is because of the efficiency
01:34 - of them for different types of
01:36 - operations so if you don't really
01:38 - understand time complexity and
01:39 - efficiency it's going to be impossible
01:41 - to master anything else on this list so
01:43 - please spend a lot of time here
01:45 - absolutely Master this and while you're
01:47 - looking at time complexity you can also
01:49 - look at space complexity now in my eyes
01:52 - this is pretty much the same thing just
01:53 - applied to memory and space it's pretty
01:56 - easy to learn space complexity once you
01:58 - know time complexity so get those down
02:00 - time complexity space complexity and
02:02 - then move into the next topic so now
02:04 - that we're masters of Big O notation and
02:06 - time complexity it's time to get into
02:08 - our basic data structures I've got a
02:10 - long list here just bear with you I'm
02:12 - going to go through them one by one so
02:14 - the first one you're going to want to
02:15 - look at is arrays now you've probably
02:17 - seen an array before but you may not
02:19 - have really gone into the details and
02:21 - understood the time complexity of
02:23 - various operations so here our goal is
02:25 - to understand what an array is how it
02:27 - works and what the different operations
02:29 - are and their efficiency so adding an
02:31 - element removing an element locating an
02:34 - element adding an element at the front
02:35 - adding an element at the back resizing
02:38 - an array and then Dynamic arrays versus
02:40 - fixed size arrays so a dynamic array is
02:42 - one that can grow in size whereas a
02:44 - fixed size array is one that only has a
02:46 - certain number of elements here our goal
02:48 - should be to understand how arrays work
02:50 - behind the scenes and how we grow or
02:52 - Shrink them depending on the operations
02:54 - we're performing now once we look at
02:56 - arrays we want to start looking at
02:58 - linked lists now these are probably the
03:00 - most basic type of data structure and we
03:02 - want to understand how we create
03:03 - references between different nodes how
03:05 - we Traverse a linked list how we add an
03:07 - element how we remove an element and all
03:10 - of the different time complexity of
03:12 - those operations one thing you're going
03:14 - to see here is that for all of these
03:15 - different data structures what we're
03:17 - focused on is four main operations
03:20 - creating deleting inserting and locating
03:23 - in some cases there's a few more but
03:25 - generally speaking those are the four
03:26 - things we do with the data structure and
03:28 - we want to know which data structures
03:30 - are best at what different type of
03:32 - operation so that's why we're really
03:34 - focusing on the efficiency of those
03:36 - operations so we know later on which
03:38 - data structure we should pick for a
03:40 - specific problem that we're encountering
03:43 - okay so once we learned singly linked
03:45 - list we're now going to learn double
03:46 - linked list now this is a linked list
03:48 - that goes in both directions pretty much
03:50 - you can look it up you'll see exactly
03:52 - how it works and same thing with a
03:53 - single link list we're going to want to
03:55 - understand how to add remove find and
03:58 - when we would use double versus single
04:00 - what the advantages are once we look at
04:02 - that we're going to start getting into
04:04 - cu's and stacks now A Q is a data
04:06 - structure that will maintain the order
04:08 - in which elements are inserted this is
04:10 - just like a q where you would line up
04:12 - right you're in a line that is a q so
04:14 - again we want to understand how we add
04:16 - how we delete how we find an element how
04:19 - we create a queue and here we'll also
04:21 - want to look at how we Implement a queue
04:23 - because the implementation is going to
04:24 - dictate the time complex the various
04:26 - different operations now after we learn
04:28 - about Q of course we're going to be
04:30 - learning about a stack a stack is just
04:32 - like a stack of plates whatever goes on
04:34 - the top is the first thing to come off
04:36 - so the first element on is actually the
04:38 - last element off and the last element on
04:40 - is the first element out we have lifo
04:43 - last in first out that's kind of a
04:45 - common term here when we're talking
04:47 - about something like a stack there's a
04:49 - way to say it in reverse as well but a
04:51 - stack is another data structure we're
04:52 - going to want to learn again adding
04:53 - elements removing elements how we
04:55 - implement it and when we would use a
04:57 - stack versus using something like a q so
04:59 - now we've learned about those we're
05:00 - going to start getting into trees now
05:02 - here's where it gets a little bit more
05:03 - complex and we start to see some data
05:05 - structures that aren't quite as familiar
05:07 - because they're not linear they're in a
05:09 - tree likee structure now so this is
05:11 - where you'll start to see kind of some
05:12 - new Concepts but it gets pretty
05:13 - interesting so the first thing we're
05:15 - going to look at is just basic trees and
05:17 - we're going to specifically look at a
05:19 - binary tree a binary tree is a tree in
05:21 - which one node can have at most two
05:23 - different children and with the binary
05:25 - tree we have a lot of different
05:26 - properties and ways to Traverse the tree
05:29 - to add an element to the tree to remove
05:31 - an element to the tree to locate if if
05:33 - an element exists sorry to create the
05:35 - tree when we're starting out so we're
05:37 - going to want to look at all of those
05:38 - different things and when we start
05:40 - looking at trees there's going to be
05:41 - three traversals that we're going to
05:43 - want to focus on the postorder the
05:45 - pre-order and the inorder traversal
05:47 - these are very important to understand
05:49 - so make sure you spend some time once
05:51 - you've learned about the basics of trees
05:53 - to know how those traversals work now
05:56 - we're also going to want to learn about
05:57 - some different tree properties like the
05:59 - height of of a tree the depth of a node
06:01 - within the tree we're going to want to
06:03 - understand what a complete binary tree
06:04 - is what a full binary tree is what a
06:06 - perfect binary trees there's all these
06:08 - different properties of trees and even
06:10 - though you don't need to memorize all of
06:12 - them you should have at least seen them
06:13 - once so make sure you go through all of
06:15 - those different Core Concepts there's
06:17 - probably some I'm forgetting here but
06:18 - those are the main ones I can think of
06:20 - off the top of my head now once we've
06:22 - learned about binary trees we're going
06:23 - to start learning about binary search
06:25 - trees now a binary search tree is very
06:27 - similar to what we learned before but in
06:29 - this case we use the tree to more
06:31 - efficiently locate elements and we sort
06:33 - them or sore them sorry in more of a
06:35 - sorted order now it's not a linear
06:37 - sorted order like we would have seen
06:39 - before with the binary search tree all
06:41 - of the children to the right of a parent
06:43 - are going to have a greater than value
06:45 - and all of the children to the left of a
06:47 - parents are going to have a value less
06:49 - than that now this allows us to create
06:50 - an efficient data structure for locating
06:53 - different elements but there's some
06:54 - other properties of this that we're
06:55 - going to want to understand like how do
06:56 - we insert an element in a binary search
06:59 - tra how do we remove an element how do
07:01 - we locate an element Etc so look at both
07:04 - regular binary trees and then binary
07:06 - search trees once we look at binary
07:08 - search trees we're going to start
07:09 - looking at heaps now heaps are similar
07:11 - to binary search trees but they work a
07:13 - little bit different and again we're
07:15 - focusing on those main operations like
07:17 - creating a heap inserting deleting
07:19 - locating Etc now with the Heap we're
07:22 - going to want to look at a Min Heap and
07:23 - a Max Heap and we'll try to see how a
07:25 - heap can actually work as something
07:27 - known as a priority Q which is another
07:29 - data structure that we should kind of
07:30 - learn about in Tangent with the Heap now
07:33 - once we learn about heaps we're going to
07:34 - move on to graphs now when we talk about
07:37 - graphs we're going to be talking about
07:38 - nodes or vertices that are connected
07:40 - with different edges we have so many
07:42 - different properties of graphs like
07:43 - directed graphs undirected graphs
07:45 - weighted graphs unweighted graphs and we
07:47 - need to understand how to represent
07:49 - graphs and how to Traverse them so we
07:51 - could have adjacency list adjacency
07:53 - matrices Edge list there's all different
07:55 - types of properties of graphs and here's
07:57 - where you can get into graph Theory and
07:58 - get real really really complicated start
08:00 - talking about Cycles within graphs and
08:02 - all kinds of fancy algorithms you don't
08:04 - need to get too crazy here but you want
08:06 - to understand what a graph is how you
08:08 - represent a graph the different types of
08:10 - representations and which is
08:11 - advantageous in which scenario now once
08:14 - we understand graphs and we get that
08:15 - terminology out of the way we're going
08:17 - to start looking at hashing now hashing
08:19 - is not overly complex this isn't
08:21 - something I would spend a ton of time on
08:23 - but we want to understand what a hash is
08:25 - how we hash and how we use this for
08:27 - something like a hash map that way we
08:29 - understand how some data structures that
08:31 - we use every single day actually operate
08:34 - and the efficiency of those data
08:35 - structures so that wraps up our basic
08:37 - data structures I know this is
08:39 - overwhelming and it's a lot of content
08:41 - but this really is what you need to know
08:43 - just as the basics in data structures
08:45 - and algorithms and now we're going to
08:47 - get into the algorithms all right so now
08:49 - we're going to start diving into
08:50 - algorithms but I do want to let you know
08:52 - that if you do want to learn all of this
08:54 - and you actually want some practice and
08:56 - ways to evaluate if you actually know
08:58 - what you're learning then you can check
08:59 - out my course with course careers this
09:02 - is a full software development course it
09:03 - doesn't just teach data structures and
09:05 - algorithms but it has an entire section
09:07 - dedicated to this where I break down all
09:09 - of the topics that I'm listing to you
09:11 - right now I explain everything that you
09:13 - need to know and not only that we give
09:15 - you a bunch of practice exercises
09:17 - quizzes Etc so you actually know if
09:19 - you're ingesting this content and
09:21 - understanding what the heck we're
09:22 - talking about you can check it out from
09:24 - the link in the description with that
09:25 - said though let's get into our
09:27 - algorithms okay so now now we've learned
09:29 - our data structures we're going to start
09:31 - talking about algorithms now these
09:33 - algorithms will use the various data
09:34 - structures that we've talked about and a
09:36 - lot of them are just famous computer
09:38 - science algorithms that you should be
09:39 - aware of and you should implement or
09:41 - write once in your life so let's start
09:44 - going through them now there's kind of
09:45 - different categories of algorithms so
09:47 - bear with me as I walk through them the
09:49 - first type of algorithm we're going to
09:50 - want to learn about is recursion now
09:53 - recursion is Simply Now recursion is
09:55 - Simply Now recursion is simply if you
09:57 - got that horrible computer science leave
09:59 - a comment down below but recursion is
10:01 - simply calling the same function from
10:03 - the same function so it's pretty much
10:05 - doing the same thing over and over when
10:07 - we create a recursive algorithm we have
10:09 - something known as a base case and a
10:11 - recursive case you can learn more about
10:13 - it this is not going to be an entire
10:14 - video on recursion next we have
10:17 - searching algorithms now these you may
10:19 - have already seen at this point but a
10:21 - searching algorithm is something we use
10:22 - to locate something within a data
10:24 - structure so we have a linear search
10:26 - which means simply scanning something
10:28 - from left to right and trying to find an
10:30 - element and then we have something like
10:31 - binary search which is a way that we can
10:34 - sort or sorry search very quickly within
10:36 - a sorted list you want to learn both of
10:38 - those and you should know how to
10:40 - implement them and write them out next
10:42 - we have sorting algorithms now sorting
10:44 - is a very famous thing in computer
10:46 - science obviously we need to do this all
10:48 - the time so it's important to understand
10:50 - these different algorithms and the
10:51 - efficiency of each of them within
10:53 - sorting algorithms we have so many
10:55 - different options I'm going to list a
10:56 - few here and if you follow any reputable
10:58 - curric ulum then these will probably all
11:00 - be taught so we have insertion sort
11:02 - selection sort bubble sort merge sort
11:05 - Heap Sort quick sort uh there's probably
11:07 - a few others that I'm forgetting but
11:08 - those are the main famous ones that you
11:10 - want to be aware of you don't
11:11 - necessarily need to write all of these
11:13 - out but you should understand how they
11:15 - work and what sorting algorithm is used
11:17 - as the default implementation for a
11:19 - programming language you write it so
11:21 - next we're moving on to graph algorithms
11:23 - now at this point we really want to
11:24 - focus on depth first search and breadth
11:27 - first search and make sure we can
11:28 - implement those and really understand
11:30 - how they work so with depth first search
11:32 - we're using a stack with breath for
11:34 - search we're using a q we want to really
11:36 - make sure we're good at these because
11:37 - these are very famous algorithms and
11:39 - they're used in a ton of different
11:40 - problems now as well as that I'd
11:42 - recommend looking at Cru skull's
11:44 - algorithm and Prim algorithm for finding
11:46 - a minimum spanning tree these aren't as
11:48 - important but they are pretty famous
11:50 - algorithms and they can show up in some
11:52 - more complicated data structures and
11:54 - algorithms type questions moving on from
11:56 - our graph algorithms we have our path
11:59 - finding algorithms now these are quite a
12:00 - bit different they are a more efficient
12:02 - way to find the shortest path within a
12:04 - graph in this case we have the AAR path
12:07 - finding algorithm and Dyas algorithm
12:09 - start with Dyas then you can look at AAR
12:12 - AAR is just a slight variation of Dyas
12:14 - so it's not that much more difficult to
12:16 - learn and it can always be fun to write
12:18 - programs that actually model these uh
12:20 - pathf finding algorithms in fact I found
12:22 - those really fun when I first learned
12:24 - them so maybe here you want to take a
12:25 - break and actually write out a data
12:26 - structure as an algorithms visualizer
12:28 - where you kind do a pathf finding
12:29 - algorithm just an idea anyways let's
12:31 - move on to the next algorithms I'm going
12:33 - to go a little bit faster here these are
12:35 - important to understand but you can
12:36 - really only learn them when you apply
12:38 - them to a specific problem so as much as
12:40 - you can look at the theory these are
12:42 - going to be more ones you focus on when
12:43 - you see a problem that requires this
12:45 - type of solution now here we have greedy
12:48 - algorithms we have divide and conquer
12:50 - algorithms this is kind of a general
12:52 - classification but something to be aware
12:54 - of we have dynamic programming and then
12:56 - we have backtracking algorithms now
12:58 - again kind of four categories of
13:00 - algorithms that are hard to learn
13:02 - theoretically and that are easier when
13:03 - you actually apply them into a problem
13:06 - okay so that wraps up the algorithm
13:08 - section now it's worth noting that there
13:10 - are tons of different algorithms you can
13:12 - learn but these are the most famous and
13:14 - if I was going to name the few that you
13:15 - should really focus on uh they would be
13:17 - the following so linear search binary
13:21 - search depth for search breath first
13:24 - search and then you want to understand
13:26 - sorting algorithms like the merge sort
13:28 - and the quick sort algorithm if you only
13:31 - had to learn a few algorithms on this
13:32 - list those would be the few I would
13:34 - really really dive into and make sure
13:35 - you fully understand the reason for that
13:37 - is these are the most commonly used and
13:40 - I would say they're the most fundamental
13:41 - in terms of computer science knowledge
13:43 - the other ones are important don't get
13:44 - me wrong but if you're only going to
13:46 - learn a few of them really focus on
13:48 - those specific few so at this point for
13:50 - 95% of you you have all the knowledge
13:52 - you need to really start practicing this
13:55 - and if you do have something like a
13:56 - coding interview start preparing for
13:58 - That interview by doing data structures
14:00 - and algorithm style questions however if
14:02 - you really want to get to the next level
14:04 - there are some more advanced data
14:06 - structures and some math you may want to
14:07 - learn which I'm going to share with you
14:09 - now now I just want to emphasize that
14:11 - for most of you you do not need to know
14:13 - this even myself I'm not master these
14:15 - different data structures so I'm just
14:17 - going to quickly run through a list of
14:18 - the advanced ones again that are
14:20 - completely optional that you may want to
14:22 - look at if you really want to get to the
14:24 - next level but keep in mind most of you
14:26 - do not need to know this and you'll be
14:27 - completely fine with what I said before
14:29 - okay so let's get into it here we have
14:31 - tries B trees AVL trees red black trees
14:36 - skipless segment trees Fenwick tree and
14:39 - the disjoint set now there's about a
14:41 - billion other data structures I could
14:42 - share here as well but these are the
14:44 - more popular Advanced ones now if you've
14:46 - learned all that and you really feel
14:47 - like punishing yourself still I'll give
14:49 - you a few math topics you can learn
14:50 - that'll give you a much deeper
14:52 - understanding but again this is fully
14:54 - optional I've actually learned all of
14:56 - this math I can't remember any of it to
14:58 - this day today but I do remember when I
14:59 - was learning I was like okay that's kind
15:01 - of cool and now I feel like I understand
15:03 - this a bit better anyways we have
15:04 - combinat Tronics we have probability
15:07 - discrete math and discrete structures
15:09 - now discrete math and discret structures
15:10 - are two courses that I took in
15:12 - University I could not tell you what I
15:13 - learned I don't remember most of it but
15:15 - it was based on like mathematical proofs
15:18 - and actually going through some pretty
15:20 - deep math that kind of allows us to
15:22 - understand why certain data structures
15:24 - have different uh time complexities how
15:27 - we actually prove the time complexity of
15:29 - algorithms Etc not something I feel like
15:31 - you really need to know I don't think
15:33 - I've ever used this in real life but if
15:35 - you do really want to get into the
15:37 - nitty-gritty you can learn those type of
15:39 - mathematical topics okay so that's going
15:41 - to wrap up this complete road map I just
15:44 - want to go through everything you need
15:46 - to learn that you have one video that
15:48 - has everything and you can kind of
15:50 - reference this if you're looking for a
15:51 - road map or a guide now keep in mind I
15:54 - do have the text based version in the
15:55 - school Community completely free you can
15:57 - join from the link in the description
15:59 - and if you want a great resource that
16:01 - really has all of this packaged into one
16:03 - place you can check out my course with
16:05 - course careers I'll wrap of the video
16:07 - here if you guys enjoy make sure to
16:08 - leave a like subscribe to the channel
16:10 - and I will see you in the next
16:12 - [Music]
16:19 - one

Cleaned transcript:

we all know that data structures and algorithms is a must topic for anyone wanting to become a software engineer so in this video I'll break down for you exactly what you need to learn the order in which you should learn it and give you some details on what you should focus on for each individual topic I'll even share with you some resources and tips to learn this as effectively as possible now if you want a text based version of this road map or something to follow along with then join my school Community I have it in there completely for free we have over 8,000 members in the school community you can join for free from the link in the description I look forward to seeing you there so let's get right into it with the first thing you absolutely need to master which is big on notation and time complex the analysis you need to understand how to look at a piece of code and understand how efficient that code is does it run in linear time does it run in exponential time does it run in logarithmic time you should understand how to evaluate that and you should know which code is more efficient than others now it's really important that you spend a lot of time in this section and you really get this down this is not something you can skip you need to really understand this to the point where I can put any piece of code in front of you and you can tell me what the time complexity of that is now usually we're going to do this in bigo notation it's not going to be harmful to learn about big Theta notation and the other types of notation but often times we're just going to use bigo notation so as long as you understand that that's completely fine now the reason we need to know this so deeply is because this is going to really translate to every area of data structures and algorithms the whole reason we use different data structures is because of the efficiency of them for different types of operations so if you don't really understand time complexity and efficiency it's going to be impossible to master anything else on this list so please spend a lot of time here absolutely Master this and while you're looking at time complexity you can also look at space complexity now in my eyes this is pretty much the same thing just applied to memory and space it's pretty easy to learn space complexity once you know time complexity so get those down time complexity space complexity and then move into the next topic so now that we're masters of Big O notation and time complexity it's time to get into our basic data structures I've got a long list here just bear with you I'm going to go through them one by one so the first one you're going to want to look at is arrays now you've probably seen an array before but you may not have really gone into the details and understood the time complexity of various operations so here our goal is to understand what an array is how it works and what the different operations are and their efficiency so adding an element removing an element locating an element adding an element at the front adding an element at the back resizing an array and then Dynamic arrays versus fixed size arrays so a dynamic array is one that can grow in size whereas a fixed size array is one that only has a certain number of elements here our goal should be to understand how arrays work behind the scenes and how we grow or Shrink them depending on the operations we're performing now once we look at arrays we want to start looking at linked lists now these are probably the most basic type of data structure and we want to understand how we create references between different nodes how we Traverse a linked list how we add an element how we remove an element and all of the different time complexity of those operations one thing you're going to see here is that for all of these different data structures what we're focused on is four main operations creating deleting inserting and locating in some cases there's a few more but generally speaking those are the four things we do with the data structure and we want to know which data structures are best at what different type of operation so that's why we're really focusing on the efficiency of those operations so we know later on which data structure we should pick for a specific problem that we're encountering okay so once we learned singly linked list we're now going to learn double linked list now this is a linked list that goes in both directions pretty much you can look it up you'll see exactly how it works and same thing with a single link list we're going to want to understand how to add remove find and when we would use double versus single what the advantages are once we look at that we're going to start getting into cu's and stacks now A Q is a data structure that will maintain the order in which elements are inserted this is just like a q where you would line up right you're in a line that is a q so again we want to understand how we add how we delete how we find an element how we create a queue and here we'll also want to look at how we Implement a queue because the implementation is going to dictate the time complex the various different operations now after we learn about Q of course we're going to be learning about a stack a stack is just like a stack of plates whatever goes on the top is the first thing to come off so the first element on is actually the last element off and the last element on is the first element out we have lifo last in first out that's kind of a common term here when we're talking about something like a stack there's a way to say it in reverse as well but a stack is another data structure we're going to want to learn again adding elements removing elements how we implement it and when we would use a stack versus using something like a q so now we've learned about those we're going to start getting into trees now here's where it gets a little bit more complex and we start to see some data structures that aren't quite as familiar because they're not linear they're in a tree likee structure now so this is where you'll start to see kind of some new Concepts but it gets pretty interesting so the first thing we're going to look at is just basic trees and we're going to specifically look at a binary tree a binary tree is a tree in which one node can have at most two different children and with the binary tree we have a lot of different properties and ways to Traverse the tree to add an element to the tree to remove an element to the tree to locate if if an element exists sorry to create the tree when we're starting out so we're going to want to look at all of those different things and when we start looking at trees there's going to be three traversals that we're going to want to focus on the postorder the preorder and the inorder traversal these are very important to understand so make sure you spend some time once you've learned about the basics of trees to know how those traversals work now we're also going to want to learn about some different tree properties like the height of of a tree the depth of a node within the tree we're going to want to understand what a complete binary tree is what a full binary tree is what a perfect binary trees there's all these different properties of trees and even though you don't need to memorize all of them you should have at least seen them once so make sure you go through all of those different Core Concepts there's probably some I'm forgetting here but those are the main ones I can think of off the top of my head now once we've learned about binary trees we're going to start learning about binary search trees now a binary search tree is very similar to what we learned before but in this case we use the tree to more efficiently locate elements and we sort them or sore them sorry in more of a sorted order now it's not a linear sorted order like we would have seen before with the binary search tree all of the children to the right of a parent are going to have a greater than value and all of the children to the left of a parents are going to have a value less than that now this allows us to create an efficient data structure for locating different elements but there's some other properties of this that we're going to want to understand like how do we insert an element in a binary search tra how do we remove an element how do we locate an element Etc so look at both regular binary trees and then binary search trees once we look at binary search trees we're going to start looking at heaps now heaps are similar to binary search trees but they work a little bit different and again we're focusing on those main operations like creating a heap inserting deleting locating Etc now with the Heap we're going to want to look at a Min Heap and a Max Heap and we'll try to see how a heap can actually work as something known as a priority Q which is another data structure that we should kind of learn about in Tangent with the Heap now once we learn about heaps we're going to move on to graphs now when we talk about graphs we're going to be talking about nodes or vertices that are connected with different edges we have so many different properties of graphs like directed graphs undirected graphs weighted graphs unweighted graphs and we need to understand how to represent graphs and how to Traverse them so we could have adjacency list adjacency matrices Edge list there's all different types of properties of graphs and here's where you can get into graph Theory and get real really really complicated start talking about Cycles within graphs and all kinds of fancy algorithms you don't need to get too crazy here but you want to understand what a graph is how you represent a graph the different types of representations and which is advantageous in which scenario now once we understand graphs and we get that terminology out of the way we're going to start looking at hashing now hashing is not overly complex this isn't something I would spend a ton of time on but we want to understand what a hash is how we hash and how we use this for something like a hash map that way we understand how some data structures that we use every single day actually operate and the efficiency of those data structures so that wraps up our basic data structures I know this is overwhelming and it's a lot of content but this really is what you need to know just as the basics in data structures and algorithms and now we're going to get into the algorithms all right so now we're going to start diving into algorithms but I do want to let you know that if you do want to learn all of this and you actually want some practice and ways to evaluate if you actually know what you're learning then you can check out my course with course careers this is a full software development course it doesn't just teach data structures and algorithms but it has an entire section dedicated to this where I break down all of the topics that I'm listing to you right now I explain everything that you need to know and not only that we give you a bunch of practice exercises quizzes Etc so you actually know if you're ingesting this content and understanding what the heck we're talking about you can check it out from the link in the description with that said though let's get into our algorithms okay so now now we've learned our data structures we're going to start talking about algorithms now these algorithms will use the various data structures that we've talked about and a lot of them are just famous computer science algorithms that you should be aware of and you should implement or write once in your life so let's start going through them now there's kind of different categories of algorithms so bear with me as I walk through them the first type of algorithm we're going to want to learn about is recursion now recursion is Simply Now recursion is Simply Now recursion is simply if you got that horrible computer science leave a comment down below but recursion is simply calling the same function from the same function so it's pretty much doing the same thing over and over when we create a recursive algorithm we have something known as a base case and a recursive case you can learn more about it this is not going to be an entire video on recursion next we have searching algorithms now these you may have already seen at this point but a searching algorithm is something we use to locate something within a data structure so we have a linear search which means simply scanning something from left to right and trying to find an element and then we have something like binary search which is a way that we can sort or sorry search very quickly within a sorted list you want to learn both of those and you should know how to implement them and write them out next we have sorting algorithms now sorting is a very famous thing in computer science obviously we need to do this all the time so it's important to understand these different algorithms and the efficiency of each of them within sorting algorithms we have so many different options I'm going to list a few here and if you follow any reputable curric ulum then these will probably all be taught so we have insertion sort selection sort bubble sort merge sort Heap Sort quick sort uh there's probably a few others that I'm forgetting but those are the main famous ones that you want to be aware of you don't necessarily need to write all of these out but you should understand how they work and what sorting algorithm is used as the default implementation for a programming language you write it so next we're moving on to graph algorithms now at this point we really want to focus on depth first search and breadth first search and make sure we can implement those and really understand how they work so with depth first search we're using a stack with breath for search we're using a q we want to really make sure we're good at these because these are very famous algorithms and they're used in a ton of different problems now as well as that I'd recommend looking at Cru skull's algorithm and Prim algorithm for finding a minimum spanning tree these aren't as important but they are pretty famous algorithms and they can show up in some more complicated data structures and algorithms type questions moving on from our graph algorithms we have our path finding algorithms now these are quite a bit different they are a more efficient way to find the shortest path within a graph in this case we have the AAR path finding algorithm and Dyas algorithm start with Dyas then you can look at AAR AAR is just a slight variation of Dyas so it's not that much more difficult to learn and it can always be fun to write programs that actually model these uh pathf finding algorithms in fact I found those really fun when I first learned them so maybe here you want to take a break and actually write out a data structure as an algorithms visualizer where you kind do a pathf finding algorithm just an idea anyways let's move on to the next algorithms I'm going to go a little bit faster here these are important to understand but you can really only learn them when you apply them to a specific problem so as much as you can look at the theory these are going to be more ones you focus on when you see a problem that requires this type of solution now here we have greedy algorithms we have divide and conquer algorithms this is kind of a general classification but something to be aware of we have dynamic programming and then we have backtracking algorithms now again kind of four categories of algorithms that are hard to learn theoretically and that are easier when you actually apply them into a problem okay so that wraps up the algorithm section now it's worth noting that there are tons of different algorithms you can learn but these are the most famous and if I was going to name the few that you should really focus on uh they would be the following so linear search binary search depth for search breath first search and then you want to understand sorting algorithms like the merge sort and the quick sort algorithm if you only had to learn a few algorithms on this list those would be the few I would really really dive into and make sure you fully understand the reason for that is these are the most commonly used and I would say they're the most fundamental in terms of computer science knowledge the other ones are important don't get me wrong but if you're only going to learn a few of them really focus on those specific few so at this point for 95% of you you have all the knowledge you need to really start practicing this and if you do have something like a coding interview start preparing for That interview by doing data structures and algorithm style questions however if you really want to get to the next level there are some more advanced data structures and some math you may want to learn which I'm going to share with you now now I just want to emphasize that for most of you you do not need to know this even myself I'm not master these different data structures so I'm just going to quickly run through a list of the advanced ones again that are completely optional that you may want to look at if you really want to get to the next level but keep in mind most of you do not need to know this and you'll be completely fine with what I said before okay so let's get into it here we have tries B trees AVL trees red black trees skipless segment trees Fenwick tree and the disjoint set now there's about a billion other data structures I could share here as well but these are the more popular Advanced ones now if you've learned all that and you really feel like punishing yourself still I'll give you a few math topics you can learn that'll give you a much deeper understanding but again this is fully optional I've actually learned all of this math I can't remember any of it to this day today but I do remember when I was learning I was like okay that's kind of cool and now I feel like I understand this a bit better anyways we have combinat Tronics we have probability discrete math and discrete structures now discrete math and discret structures are two courses that I took in University I could not tell you what I learned I don't remember most of it but it was based on like mathematical proofs and actually going through some pretty deep math that kind of allows us to understand why certain data structures have different uh time complexities how we actually prove the time complexity of algorithms Etc not something I feel like you really need to know I don't think I've ever used this in real life but if you do really want to get into the nittygritty you can learn those type of mathematical topics okay so that's going to wrap up this complete road map I just want to go through everything you need to learn that you have one video that has everything and you can kind of reference this if you're looking for a road map or a guide now keep in mind I do have the text based version in the school Community completely free you can join from the link in the description and if you want a great resource that really has all of this packaged into one place you can check out my course with course careers I'll wrap of the video here if you guys enjoy make sure to leave a like subscribe to the channel and I will see you in the next one
