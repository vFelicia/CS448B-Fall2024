With timestamps:

00:00 - hello everybody and welcome back to
00:01 - their Python coding interview question
00:03 - today we're gonna be doing a medium
00:05 - question from algal expert dot IO which
00:08 - is personally the website I am using
00:09 - when have been using to prepare for
00:11 - coding interviews I have coming up I'm
00:13 - actually gonna be doing a really
00:15 - exciting video soon where I'm going to
00:17 - be doing a mock coding interview with
00:19 - the creator of this website I believe
00:21 - his name is Clemente or Clemente I don't
00:24 - know exactly how you say it I'm gonna
00:25 - butcher it but you guys will see that
00:26 - coming up soon so if you're excited
00:28 - about that leave a like but anyways the
00:30 - reason I use this platform is not just
00:32 - because you know I get paid to use it
00:33 - which I don't by the people that own
00:36 - this is because I actually really like
00:37 - the way that kind of information is
00:39 - presented and how easy it is to quickly
00:41 - go on the website and start practicing
00:42 - your coding skills you guys know for me
00:45 - personally I'm very busy the last thing
00:47 - I have time to do is search online to
00:49 - find all these different questions and
00:50 - then write my own test cases for them
00:52 - and do it in a Python window on my
00:54 - computer and try to see if I'm correct
00:55 - here and you guys will see as we go
00:57 - through it's really easy to save your
00:58 - answers you can mark them as in progress
01:00 - you can change your language you can get
01:01 - some hints like you would get in the
01:03 - regular coding interview you can set a
01:05 - timer you have test cases you know
01:07 - immediately if your codes working or not
01:08 - and that's kind of what you're paying
01:10 - for when you use this platform so if you
01:11 - guys do want this it really is a great
01:13 - resource I wouldn't recommend it to you
01:14 - if I didn't mean that and I've used tons
01:16 - of other platforms and even people have
01:18 - tried to pay me to promote theirs and
01:20 - you know I have stuck with this one so
01:22 - there's 10% discount code down below but
01:24 - let's get started with this question
01:25 - which is River sizes now River sizes
01:28 - this I'm gonna zoom in on this and we'll
01:30 - read through this last video I didn't
01:32 - really go through the question
01:33 - extensively and some people got confused
01:34 - so let's make sure we really understand
01:36 - this before we dig in so you were given
01:38 - a two-dimensional array matrix of
01:40 - potentially unequal height and width
01:41 - containing only zeros and ones that just
01:43 - means you know this does not have to be
01:45 - uniform length and width it could be way
01:47 - longer than it is height wise anyways
01:49 - each zero represents land each one
01:51 - represents predator river a river
01:53 - consists of any number of ones that are
01:54 - either horizontally or vertically
01:56 - adjacent but not diagonally numbers of
01:58 - adjacent ones forming a river determine
02:00 - its size write a function to return all
02:02 - of the river sizes represented in the
02:04 - input matrix they do not have to be in
02:06 - order okay so essentially the way that
02:09 - this works is we have these ones here
02:12 - which represents
02:13 - our rivers and the way that you can kind
02:15 - of think of a river is any ones that are
02:16 - touching each other form a river and the
02:18 - rivers can be in owls and they can go
02:19 - all around and they don't just have to
02:20 - be straight lines which is originally
02:22 - what I thought when I read this question
02:23 - so essentially for like these ones are
02:26 - rivers so the one on the left side I'll
02:27 - zoom in maybe a bit more so you guys can
02:29 - see so this one and this one are River
02:32 - this one this one this one this one and
02:35 - this one are River and they form this
02:36 - kind of El structure like that so how
02:39 - are we gonna go about solving the
02:40 - solution I'm gonna bring up my drawing
02:42 - tablet we're gonna walk through I'm
02:43 - gonna explain my solution then we'll
02:44 - code it out here and kind of figure out
02:46 - how this works all right so this is an
02:49 - example of what our input matrix might
02:50 - look like now I want to start by just
02:52 - identifying the rivers here so you guys
02:54 - understand which ones they are so we're
02:55 - gonna say that this is a river right
02:57 - here so all of the red underlines I'll
02:59 - do some different colors so we can see
03:00 - here I'm gonna say that this green is a
03:03 - river right here and then let's pick
03:05 - another color let's go with you know
03:07 - purple we'll say that this one is a
03:10 - river right here so essentially what we
03:12 - need to do in our code is write some
03:14 - function it's going to be able to look
03:15 - through all of these different ones its
03:17 - input matrix and determine the length of
03:19 - all these rivers so in this case we want
03:21 - to have you know three for this one we
03:22 - want to have five and we want to have
03:24 - five for this other River that goes like
03:26 - that so how can we do this well there's
03:30 - only really a few ways about going to do
03:32 - this that make practical sense and we're
03:35 - gonna want to use a graph traversal
03:36 - algorithm to do this and I'm gonna do
03:39 - this in a depth first search way and
03:41 - I'll kind of explain how that works and
03:43 - what that algorithm is as we go but just
03:45 - think about how you might you know
03:46 - approach this problem it's one thing if
03:48 - all you need to find is rivers that go
03:50 - horizontally and vertically that's
03:52 - actually fairly easy because you can
03:53 - just check every single horizontal row
03:55 - every single vertical row and do kind of
03:57 - some comparisons and store the rivers
03:59 - you've already seen but when we do this
04:01 - and we can have you know chains that
04:03 - look something like that as a river how
04:05 - do we do that well what I'm gonna do is
04:08 - a depth-first search process now if you
04:10 - don't know what depth-first search is
04:11 - essentially it's kind of looking for a
04:14 - path through a graph so it's a way to
04:16 - traverse a graph to find the longest
04:18 - path kind of first whereas if you're
04:20 - doing a breadth-first search way you're
04:22 - going to iteratively kind of
04:23 - and Edwards so anyways we're gonna start
04:26 - and this doesn't it doesn't matter this
04:28 - is the one but we're gonna start by
04:29 - looping through every single position in
04:31 - our matrix we're gonna loop through each
04:33 - row and each column and just look at
04:35 - every single position that's gonna be a
04:37 - kind of our first process what we're
04:39 - gonna do is when we get to a position
04:40 - we're gonna see if the element at that
04:42 - position is a 1 if it's a 1 that means
04:45 - we found you know the start or maybe
04:47 - possibly even like the middle of a river
04:49 - and what we're gonna do is try to find
04:51 - any river that's attached to it so like
04:53 - the longest river or whatever river is
04:55 - attached to this one we're gonna try to
04:57 - find that and figure out what the length
04:58 - of that is so how do we do that
05:00 - well when we find a1 we found you know
05:03 - okay this is a start of a river or
05:04 - something like that what we need to do
05:06 - is look at all of the neighbors of this
05:08 - one and determine if there's any ones
05:10 - beside it because that would be the rest
05:11 - of the river right so we're gonna look
05:13 - up we're gonna look right we're gonna
05:15 - look down and we're gonna look left now
05:18 - obviously we can't look left and we
05:20 - can't look up because there's nothing
05:21 - there so we won't look in those
05:22 - positions but what we can do is look
05:25 - here at this zero and look here at this
05:27 - one now let me just erase all of these
05:29 - so that we have a cleaner thing here so
05:31 - what we'll do is we'll look at this zero
05:32 - and we'll say okay so is this a zero or
05:34 - is this a 1 well obviously it's a zero
05:36 - so that means there's no river kind of
05:38 - going this way on the right side we
05:40 - don't need to continue doing anything
05:42 - past the zero we'll just stop there next
05:45 - though what we do is we look at this one
05:47 - and we say okay so we have one we have
05:48 - another one so our River now is of
05:51 - length two we've seen both of these ones
05:53 - they're part of our River so what I'm
05:55 - gonna do is actually mark the fact that
05:58 - these ones have been discovered that
06:00 - we've looked at them that we've seen
06:01 - them because currently we have a river
06:04 - of length two that contain these ones we
06:06 - want to make sure that when we look
06:07 - through you know later on in the
06:09 - sequence of this program we don't
06:11 - reconsider these ones so I'm gonna
06:13 - create a kind of a set over here
06:15 - in think of it as a hash to the think of
06:17 - as a set it doesn't really matter I'm
06:18 - gonna store the position of these ones
06:21 - so I'm gonna say okay so I've looked at
06:22 - this one it's in position what position
06:24 - is it zero zero because that's the
06:27 - position in the matrix right so we say
06:28 - that's 0 that's 0 and I'm dot dot that
06:31 - should be one two three four five and
06:33 - then one two three four Oh oops oops
06:36 - this ship
06:37 - for okay so let's say that goes to four
06:39 - and we'll do the same thing here to
06:42 - position four so let's say that is you
06:44 - know position zero zero so we mark that
06:46 - we say we've seen that one already now
06:48 - same thing with the one we look at this
06:51 - one so okay that's the one let's mark
06:52 - this one what's that position that's
06:54 - actually gonna be position one zero
06:55 - because we're gonna read from the row
06:57 - and then the column after that and the
06:59 - reason we do this is because when we get
07:01 - to this next one what we're gonna do is
07:03 - continue the process of looking at all
07:05 - the neighbors of this one trying to find
07:07 - if this River expands or goes anywhere
07:09 - else so what we're gonna do is well
07:11 - we're gonna look up we're gonna look
07:13 - left we're gonna look down and we're
07:16 - gonna look right but now you can see
07:18 - where an issue might occur if we look up
07:20 - we're gonna see the same river that
07:22 - we've already seen right and well we
07:24 - don't want to count that River because
07:25 - we've already seen it we've already
07:26 - marked it we already know it's part of
07:28 - our River and we really shouldn't go
07:29 - back to it and start looking in all the
07:31 - different directions from that River so
07:33 - what we do when we look in all these
07:35 - different directions do we say okay well
07:36 - if we look in this direction and we find
07:38 - a one that hasn't yet been marked that
07:41 - we haven't seen in this set here only
07:43 - then will we consider so in this case
07:45 - when we go here we can see that this
07:47 - isn't marked yet so we'd consider it now
07:49 - what we're gonna do from here is
07:50 - consider all the neighbors that aren't
07:52 - marked so in this instance we'll look at
07:54 - this one because this is you know one of
07:56 - the neighbors of it and then same thing
07:57 - from this one we're gonna look in every
07:59 - position we're gonna look for any ones
08:01 - that aren't marked so we won't look here
08:02 - because that's marked obviously so what
08:04 - we'll do then is we'll go to the next
08:07 - one then same thing here we'll go to the
08:10 - next one continually marking all of
08:12 - these positions in our list so in this
08:14 - case we're gonna mark position 1 1 we
08:16 - need to mark position 2 1 I think and
08:19 - then we need to mark position what
08:21 - should this be 2 - I think that's the
08:25 - correct position yeah so we'll go to 2
08:27 - marked and then this now has made up our
08:30 - first River we've marked all these
08:32 - positions and while we've been doing
08:34 - this we've been keeping track of the
08:36 - length of that River I don't know what I
08:38 - just wrote there which I'm gonna say is
08:39 - a fine right so the length of this river
08:41 - is 5 so we've kept track of that as
08:43 - we've gone through and found all these
08:44 - ones
08:44 - now we'll add that to one of the rivers
08:46 - that we found which is 5 ok so we did
08:49 - that we looked through all of these so
08:50 - let me erase the
08:51 - let's talk about the next step that
08:52 - we're gonna do so get rid of all this
08:54 - all that okay so now we already looked
08:57 - at this one so we found all these other
08:59 - ones from this one that are connected to
09:01 - it we've marked all of those now we're
09:03 - going to move to this next position
09:04 - which is a zero since it's a zero we
09:06 - don't need to consider anything because
09:07 - there's obviously no river there same
09:09 - thing here
09:09 - we don't need to consider it same thing
09:11 - here don't need to consider it now we
09:13 - hit another one so what do we do
09:15 - alright let's reopen up this set here
09:18 - let's start by marking the fact that
09:20 - okay we've considered this our current
09:21 - River length is 1 we've looked at this
09:24 - one what position is this in that's in
09:26 - position 0 4 so we'll mark that now what
09:29 - are we gonna do we're gonna look left up
09:32 - right down right so we look at all these
09:36 - we realize that ok obviously to the left
09:38 - is a zero we don't need to look at that
09:39 - down what's that oh it's a 1 ok so let's
09:42 - look at that alright one looks up looks
09:45 - left looks right looks down sees ok well
09:48 - this one's already marked we're actually
09:49 - gonna mark this one that we've seen it
09:51 - so what position is this that's position
09:53 - 1 4 then we say ok let's go to the next
09:55 - one which is this one let's mark it
09:57 - what's this one well this should
09:59 - actually be 2 4 and now our current
10:01 - River length is 3 there's no more else
10:04 - that we can go because those are all
10:05 - zeros obviously so we stop we add 3 into
10:09 - our list of rivers so now we have a list
10:11 - of let's say what is it 5 & 3 so 5 comma
10:16 - 3 and now we can continue the process so
10:19 - where do we left leave off well we had
10:21 - looked at this one already so now we'll
10:23 - go to the next one we'll look at this
10:24 - one oh wait this is a one okay so did we
10:26 - start the process again no we don't the
10:29 - reason we don't start the process of
10:30 - looking for other rivers is because
10:32 - we've marked this one and we can see
10:34 - that position should actually be 1 0
10:36 - which is right here so we don't even
10:38 - bother considering it we'd go to this
10:40 - one same thing it's already in our set
10:42 - so we don't need to look at it because
10:44 - it's already part of a river 0 that's a
10:46 - 0 we don't look at it 0 we don't look at
10:48 - it 1
10:49 - ok well that we've already looked at
10:50 - it's a part of the set don't look at it
10:52 - and you guys get the process 0 don't
10:53 - look at it one don't look at its in the
10:55 - set 1 don't look at it 0 don't look at
10:57 - it
10:57 - 1 it's in set we don't care all of these
11:00 - obviously we're not gonna look through
11:01 - until eventually we hit this one say ok
11:03 - it's a 1 it's
11:04 - in the set so let's consider it and then
11:06 - we're gonna chain go all the way here
11:08 - look at all these ones mark all these
11:11 - ones notice that you know that's another
11:13 - River add five then we're at the end
11:15 - here so we just returned that list and
11:18 - this is exactly what we're gonna do and
11:20 - this is the process that we're gonna
11:22 - follow so I hope that makes sense I've
11:23 - dug into it pretty in-depth I've talked
11:25 - about it for about 10 minutes kind of
11:26 - this depth-first search approach which
11:29 - is kind of what this is we're just
11:30 - looking through all of the neighbors of
11:32 - all these different things and kind of
11:33 - traversing the graph now it's time to
11:35 - apply this in Python it's a little bit
11:37 - of an advanced algorithm but try to stay
11:39 - with me and you know try to write it
11:40 - yourself first and then you come back
11:42 - again
11:42 - I'll go expert you can use this question
11:44 - for free so you guys can actually go to
11:45 - algo expert on and perform this question
11:48 - on the website for free you don't need
11:49 - to sign in or pay for it to do it
11:51 - because this is a free question then
11:53 - obviously if you guys like it you can
11:54 - take advantage of that discount and use
11:55 - some other questions let me put away
11:57 - some of my stuff and we'll get here and
11:58 - start coding all right so let's start
12:00 - coding this problem now I'll make this
12:02 - fullscreen I hopefully this is big
12:03 - enough for me for you guys let me know
12:05 - in the comments if it's too small
12:06 - actually it will go fullscreen on
12:09 - everything here okay there we go all
12:11 - right so what's the first thing that we
12:12 - need to do well we need to create this
12:14 - kind of set that we're gonna keep track
12:16 - of all of the marked rivers in and we
12:18 - also need a list that we're gonna keep
12:19 - track of all the river lengths in that
12:21 - we discover so what I'm gonna do is I'm
12:23 - gonna start by creating a set which is
12:25 - we're gonna call marked so this look
12:27 - keep track of all the rivers we've
12:28 - already seen and now we'll keep track of
12:30 - I guess rivers that we've seen in a list
12:33 - what we're gonna do next is what I've
12:36 - explained and I'm just gonna follow kind
12:37 - of the algorithm that I explained to you
12:38 - guys in the following page we're gonna
12:40 - loop through every single position in
12:41 - the matrix so starting from the very top
12:43 - left going to the very bottom right
12:45 - we're gonna say four row in range the
12:49 - length of matrix like that then we're
12:53 - gonna say for call in range B Len of
12:59 - matrix like this and then row like so
13:05 - now the reason we're doing this is
13:06 - because this is going to essentially
13:08 - tell us you know how long each row is
13:10 - because we know these might not
13:11 - necessarily be the same in terms of
13:13 - length and width so for each row in our
13:16 - matrix we'll figure out how long
13:17 - Rowe is and then loop through every
13:18 - single position okay so now that we've
13:20 - done that the first thing that we need
13:22 - to do is we need to look at the current
13:24 - position in our matrix so our row call
13:26 - position we need to see if that's a 1
13:28 - and we need to make sure that we haven't
13:30 - already looked at it in the market set
13:32 - so to do that we're gonna say if in this
13:34 - case the matrix and we'll say row call
13:39 - equals equals 1 and in this case we'll
13:43 - say row call not in marked so if that's
13:48 - true which essentially again means you
13:50 - know it's a 1 and it's not in the mark
13:51 - set what do we need to do well we need
13:53 - to start looking at all the different
13:55 - positions around it so what we're gonna
13:57 - do is start by essentially saying our
13:59 - current River length is equal to 1 at
14:03 - the current moment we found one which
14:05 - means this river has length 1 what we're
14:07 - gonna do next is actually set up
14:09 - something that I'm gonna call a stack
14:11 - and I'm gonna set up our actually sorry
14:14 - add this position to mark now we'll talk
14:17 - about what this is gonna do in a second
14:18 - so I'm gonna say mark dot add and I'm
14:20 - gonna add row call which is essentially
14:22 - saying okay we're going to put this
14:24 - position that we've seen in the marked
14:26 - set so we know not to look at it again
14:28 - what I'm also gonna do is add row call
14:30 - in to my stack now if you guys haven't
14:32 - seen stacks before I'll briefly kind of
14:34 - go through how they work but it's a
14:36 - fairly simple data structure this is
14:37 - gonna allow us to do kind of a
14:39 - depth-first search of this all the ones
14:41 - that we can find attached to this river
14:43 - so what I'm gonna do now is say well
14:45 - stack I'm gonna say current equals stack
14:49 - dot pop and we'll talk about what this
14:52 - does okay so what this means is
14:54 - essentially while stacks so if there's
14:55 - anything in our stack because what we're
14:58 - gonna do is every time we find a one
15:01 - that is neighboring the current one that
15:03 - we looked at we're gonna add that to our
15:05 - stack which we're gonna call here so
15:06 - that we can look at all of the neighbors
15:08 - of that one during the next kind of
15:10 - iteration of this searching traversing
15:12 - process so what we do is we're gonna say
15:15 - the current like node the current one
15:18 - we're looking at is gonna come from the
15:19 - end of the stack so whatever we pop off
15:21 - that's what it is going to come from the
15:23 - end so in this case when we start we'll
15:24 - just get this row column which is the
15:26 - first one that we have that's
15:27 - one we're gonna look at what we're gonna
15:29 - do next is get all the neighbors of this
15:32 - and then look at all of those neighbors
15:34 - and see you know one of those neighbors
15:36 - are they ones are they zero should we
15:37 - look at them
15:38 - should we add one to our current River
15:40 - life do we see another one that's
15:41 - adjacent to it what do we do so what we
15:43 - need to do to do that though is create a
15:45 - function that can give us all of the
15:47 - neighbors based on a current position in
15:49 - our matrix so what we're gonna do is say
15:51 - define get underscore neighbors if I
15:57 - could spell neighbors correctly and I
15:59 - don't know if you spell it
16:00 - Oh urs or if it's o RS but we'll just go
16:03 - with this for right now because why not
16:05 - and what this is going to take is a
16:07 - position and the matrix what we're gonna
16:10 - do in here is essentially find what the
16:13 - position of the left neighbor the top
16:14 - neighbor the right neighbor and the
16:15 - bottom neighbor is so to do this is
16:17 - pretty straightforward we're gonna start
16:19 - by saying y comma x equals position
16:22 - which is just gonna decompose this
16:24 - topple for us and essentially tell us
16:25 - the two components of it so we can use
16:27 - those independently and now what I'm
16:29 - gonna say is if X is greater than I
16:33 - should say greater than 1 greater than
16:36 - or equal to 1 what we'll do is and we'll
16:39 - create a list here we'll call it NS
16:40 - which just stands for neighbors we're
16:42 - gonna say NS dot append and in this case
16:46 - we're gonna do X or say Y X minus 1 now
16:51 - this is going to give us the left
16:53 - neighbor so we can put a little comment
16:54 - here that says left and why am i doing
16:56 - comments in Java
16:57 - I've been reading too much Java next
16:59 - what we're gonna do is check the so that
17:02 - was left neighbor will check the right
17:03 - neighbor so we'll say if X is less than
17:05 - and in this case we're actually gonna
17:07 - say is the length of matrix 0 minus 1
17:13 - now the reason we're doing this is
17:14 - because we're going to add 1 to X so we
17:16 - need to make sure it's less than
17:17 - whatever the length minus 1 is so that
17:19 - we don't get an index error so we'll say
17:20 - NS dot append
17:22 - Y X plus 1 and I will do the same thing
17:25 - for Y so if Y is less than or sorry not
17:28 - less than greater than or equal to 1
17:31 - then what we'll do is NS dot append and
17:33 - we'll say Y minus 1 X and then same
17:37 - thing with the other component so if Y
17:38 - is less than
17:40 - the line of matrix minus one because
17:43 - that'll give us the Rose NS dot append
17:45 - and in this case it should be y plus 1x
17:49 - now we'll simply return that list so
17:51 - return an S and that will give us all of
17:53 - our neighbors okay
17:55 - awesome so I think that makes sense so
17:58 - far so now what we'll do is get all the
17:59 - neighbors of this current position so to
18:01 - do that what we'll simply say is okay
18:03 - and actually we'll say neighbors Y not
18:08 - equals get underscore neighbors of
18:12 - position which is actually going to be
18:14 - row call and matrix awesome so now that
18:19 - we do that we're gonna have a list
18:20 - stored in here of all the neighbors so
18:23 - what we need to do is look through all
18:24 - these neighbors first of all see if
18:25 - there one see if we've already looked at
18:27 - them or not and if we haven't then we'll
18:29 - do is add one to our current River
18:31 - length and then add that to the stack so
18:33 - that we can look at all these neighbors
18:34 - again and again and again and kind of
18:36 - traverse through all of these and I'll
18:37 - dig into it in a second so what we're
18:39 - gonna do now is say for n in neighbors
18:43 - so this again will give us those
18:44 - positions I think I need an H there I do
18:47 - now we're going to say is if N or
18:49 - actually I'll say Y x equals n just so
18:54 - we can decompose this and make it a
18:55 - little bit easier so we'll say if matrix
18:59 - yeah if matrix y x equals equals 1 and y
19:04 - x not in marked which essentially means
19:09 - we haven't looked at this river already
19:11 - then what we'll do is we'll add it to
19:14 - mark so say marked dot add Y X will say
19:19 - cur underscore River underscore length
19:21 - plus equals 1 because this is another
19:23 - component of the river that we found so
19:25 - we need to add it and then finally what
19:27 - we will do is add it to the stack so
19:29 - it's a stack dot append and if I could
19:33 - get the right symbols here we will
19:36 - append Y X now the reason we're doing
19:38 - this appending to the stack is because
19:40 - we need to add that one and I think I
19:42 - can go back to my drawing example maybe
19:44 - this will make things a bit clearer like
19:46 - okay well this is an absolute mess now
19:48 - but if we're here right and we find this
19:50 - other one well we need to add this one
19:52 - to the stack
19:53 - back so that we can look at the
19:54 - neighbors of this one next right and
19:56 - then whenever we find another one or
19:57 - maybe there's two ones we add both of
19:59 - them to the stack so that we can look at
20:01 - all of their neighbors during the next
20:02 - iteration when we pop things off the
20:04 - stack now I know this might be kind of
20:06 - confusing to some of you guys if you
20:07 - haven't seen an algorithm like this
20:08 - before we're actually almost done so
20:10 - what we're gonna do now is essentially
20:12 - once the stack is empty we're gonna add
20:14 - to the rivers list so we're gonna say
20:16 - rivers dot append current River length
20:20 - Soaker underscore River underscore
20:23 - length and then at the very end of our
20:25 - program will return rivers now that
20:29 - should actually be it I'm just gonna do
20:30 - a quick glance of my other screen I do
20:32 - have the solution up right now to make
20:33 - sure I haven't absolutely butchered it
20:35 - and it looks like we're doing all right
20:37 - and yeah that should actually be it so
20:40 - essentially the process is right loop
20:42 - through every single position make sure
20:44 - that the position we're looking at is
20:46 - either one and it's not marked if that's
20:49 - true if it's a one it's not marked we'll
20:50 - say okay so we're gonna look for a river
20:52 - now attached to this one it has a
20:54 - current River length of one it's we're
20:56 - gonna add it to the marked list so we
20:58 - don't look at it again we're gonna
20:59 - create this stack that starts just just
21:01 - having this position then what we'll do
21:03 - is we'll pop that off the stack which
21:04 - actually means remove this element set
21:06 - it equal to current then what we do is
21:09 - we're gonna say neighbors equals get
21:11 - neighbors row call matrix so this
21:13 - actually should be current my bad guys
21:15 - this shouldn't be wrote call the reason
21:17 - it needs to be current is because we're
21:18 - gonna actually change the neighbors
21:20 - we're getting based on the thing we just
21:22 - popped off the stack so sorry this is
21:24 - current matrix this will give us all of
21:27 - the neighbors for that specific position
21:29 - and assuming I didn't mess up this
21:31 - function that should be alright then
21:33 - what we're gonna do is look through all
21:34 - of the neighbors essentially say okay
21:36 - let's break down their components let's
21:38 - check if this neighbor is a one so if
21:40 - it's a one in the matrix and if it's not
21:42 - yet marked what we'll do is we'll add it
21:44 - to the marked set
21:44 - we'll set current River length plus one
21:46 - because we just found another one that's
21:48 - a part of this River we'll add it to the
21:50 - stack so that we can then look at all
21:51 - the neighbors of that one and see if
21:53 - there's any other you know rivers that
21:54 - are extending and going off finally once
21:57 - that's done so we don't have nothing
21:58 - left in the stack that we found the end
22:00 - of the river what we'll do is append the
22:01 - current River length then we will return
22:04 - rivers now returning rivers will just
22:06 - return this final list this is a little
22:08 - bit of a messy coat but let's run this
22:10 - and see if we've done all right or not
22:12 - so let's zoom out run code log into run
22:16 - code okay so I'm gonna log in and run
22:17 - the code and then let's see if this
22:18 - works okay so we passed now I would like
22:37 - to say that I actually just had to copy
22:39 - the code like my solution back in here
22:42 - it's the exact same as what I wrote but
22:43 - you might notice some variable names are
22:44 - a little bit different because for some
22:47 - reason it deleted my code when I signed
22:49 - back in to run the code anyway so there
22:52 - we go we passed our outputs are good and
22:54 - I mean we can see them can have a look
22:56 - at the raw output here saying how long
22:57 - it ran in and we can have a look at
22:59 - these test cases to see you know what we
23:01 - were tested up against and if that
23:02 - actually worked
23:03 - we'd also write our own test cases if we
23:05 - want to inside of your tests like you
23:07 - can modify them and if we have a look
23:09 - here we'll have a look at our optimal
23:10 - space-time complexity so we have owh
23:13 - time owh space which is actually I
23:16 - believe what this algorithm runs in so
23:18 - if you guys want to challenge yourself
23:19 - leave a comment down below and tell me
23:21 - if I'm right or wrong on the space-time
23:23 - complexity of this algorithm I'm trying
23:25 - to get it centered in the page here so
23:27 - that we can have a look at all of it but
23:29 - does this that I've written here run in
23:31 - owh time where W is the width and H is
23:34 - the length of our matrix I'm gonna go on
23:38 - a limb and say yes it does the reason I
23:41 - say that is because obviously these two
23:44 - loops are gonna be WH right then what
23:46 - we're gonna do in here is we're only
23:48 - ever gonna execute this a maximum of W
23:51 - times each times because we're adding
23:54 - all these things into our marked set and
23:56 - looking up an element in a set takes a
23:58 - one time on average it can take longer
24:00 - to find if it's in there but on average
24:02 - takes a one time so what's gonna happen
24:05 - is this will only run a maximum of WH
24:07 - times so technically we would have to WH
24:10 - is our maximum amount of
24:12 - runs that we can potentially have
24:13 - because in combination of all these
24:15 - loops the some of that will be less than
24:17 - WH so we can remove that constant and
24:20 - then have WH as our running time
24:22 - complexity now in terms of space what
24:25 - we're using is well essentially a set
24:27 - here that could potentially have maximum
24:29 - WH elements for every single element
24:31 - being a river so one massive River is
24:33 - the entire matrix that's possible and
24:35 - then rivers here well this can have I
24:39 - mean in theory it can have as many
24:40 - rivers as are actually in the matrix so
24:44 - that's gonna give us two WH for space
24:46 - but since again we can remove that
24:47 - constant we'll have WH for space and
24:49 - that should be good
24:51 - I'm sure someone can come up with a
24:52 - reason why this might not run in WH why
24:56 - am i running like WH squared or
24:57 - something like that but if you can
24:59 - that's awesome leave a comment down
25:00 - below and I think that has been after
25:02 - this video as always if you guys enjoyed
25:04 - make sure to leave a like you know
25:06 - always get a 10% discount on algo expert
25:08 - using the code I have in the description
25:09 - and with that being said I will see you
25:11 - guys in another video

Cleaned transcript:

hello everybody and welcome back to their Python coding interview question today we're gonna be doing a medium question from algal expert dot IO which is personally the website I am using when have been using to prepare for coding interviews I have coming up I'm actually gonna be doing a really exciting video soon where I'm going to be doing a mock coding interview with the creator of this website I believe his name is Clemente or Clemente I don't know exactly how you say it I'm gonna butcher it but you guys will see that coming up soon so if you're excited about that leave a like but anyways the reason I use this platform is not just because you know I get paid to use it which I don't by the people that own this is because I actually really like the way that kind of information is presented and how easy it is to quickly go on the website and start practicing your coding skills you guys know for me personally I'm very busy the last thing I have time to do is search online to find all these different questions and then write my own test cases for them and do it in a Python window on my computer and try to see if I'm correct here and you guys will see as we go through it's really easy to save your answers you can mark them as in progress you can change your language you can get some hints like you would get in the regular coding interview you can set a timer you have test cases you know immediately if your codes working or not and that's kind of what you're paying for when you use this platform so if you guys do want this it really is a great resource I wouldn't recommend it to you if I didn't mean that and I've used tons of other platforms and even people have tried to pay me to promote theirs and you know I have stuck with this one so there's 10% discount code down below but let's get started with this question which is River sizes now River sizes this I'm gonna zoom in on this and we'll read through this last video I didn't really go through the question extensively and some people got confused so let's make sure we really understand this before we dig in so you were given a twodimensional array matrix of potentially unequal height and width containing only zeros and ones that just means you know this does not have to be uniform length and width it could be way longer than it is height wise anyways each zero represents land each one represents predator river a river consists of any number of ones that are either horizontally or vertically adjacent but not diagonally numbers of adjacent ones forming a river determine its size write a function to return all of the river sizes represented in the input matrix they do not have to be in order okay so essentially the way that this works is we have these ones here which represents our rivers and the way that you can kind of think of a river is any ones that are touching each other form a river and the rivers can be in owls and they can go all around and they don't just have to be straight lines which is originally what I thought when I read this question so essentially for like these ones are rivers so the one on the left side I'll zoom in maybe a bit more so you guys can see so this one and this one are River this one this one this one this one and this one are River and they form this kind of El structure like that so how are we gonna go about solving the solution I'm gonna bring up my drawing tablet we're gonna walk through I'm gonna explain my solution then we'll code it out here and kind of figure out how this works all right so this is an example of what our input matrix might look like now I want to start by just identifying the rivers here so you guys understand which ones they are so we're gonna say that this is a river right here so all of the red underlines I'll do some different colors so we can see here I'm gonna say that this green is a river right here and then let's pick another color let's go with you know purple we'll say that this one is a river right here so essentially what we need to do in our code is write some function it's going to be able to look through all of these different ones its input matrix and determine the length of all these rivers so in this case we want to have you know three for this one we want to have five and we want to have five for this other River that goes like that so how can we do this well there's only really a few ways about going to do this that make practical sense and we're gonna want to use a graph traversal algorithm to do this and I'm gonna do this in a depth first search way and I'll kind of explain how that works and what that algorithm is as we go but just think about how you might you know approach this problem it's one thing if all you need to find is rivers that go horizontally and vertically that's actually fairly easy because you can just check every single horizontal row every single vertical row and do kind of some comparisons and store the rivers you've already seen but when we do this and we can have you know chains that look something like that as a river how do we do that well what I'm gonna do is a depthfirst search process now if you don't know what depthfirst search is essentially it's kind of looking for a path through a graph so it's a way to traverse a graph to find the longest path kind of first whereas if you're doing a breadthfirst search way you're going to iteratively kind of and Edwards so anyways we're gonna start and this doesn't it doesn't matter this is the one but we're gonna start by looping through every single position in our matrix we're gonna loop through each row and each column and just look at every single position that's gonna be a kind of our first process what we're gonna do is when we get to a position we're gonna see if the element at that position is a 1 if it's a 1 that means we found you know the start or maybe possibly even like the middle of a river and what we're gonna do is try to find any river that's attached to it so like the longest river or whatever river is attached to this one we're gonna try to find that and figure out what the length of that is so how do we do that well when we find a1 we found you know okay this is a start of a river or something like that what we need to do is look at all of the neighbors of this one and determine if there's any ones beside it because that would be the rest of the river right so we're gonna look up we're gonna look right we're gonna look down and we're gonna look left now obviously we can't look left and we can't look up because there's nothing there so we won't look in those positions but what we can do is look here at this zero and look here at this one now let me just erase all of these so that we have a cleaner thing here so what we'll do is we'll look at this zero and we'll say okay so is this a zero or is this a 1 well obviously it's a zero so that means there's no river kind of going this way on the right side we don't need to continue doing anything past the zero we'll just stop there next though what we do is we look at this one and we say okay so we have one we have another one so our River now is of length two we've seen both of these ones they're part of our River so what I'm gonna do is actually mark the fact that these ones have been discovered that we've looked at them that we've seen them because currently we have a river of length two that contain these ones we want to make sure that when we look through you know later on in the sequence of this program we don't reconsider these ones so I'm gonna create a kind of a set over here in think of it as a hash to the think of as a set it doesn't really matter I'm gonna store the position of these ones so I'm gonna say okay so I've looked at this one it's in position what position is it zero zero because that's the position in the matrix right so we say that's 0 that's 0 and I'm dot dot that should be one two three four five and then one two three four Oh oops oops this ship for okay so let's say that goes to four and we'll do the same thing here to position four so let's say that is you know position zero zero so we mark that we say we've seen that one already now same thing with the one we look at this one so okay that's the one let's mark this one what's that position that's actually gonna be position one zero because we're gonna read from the row and then the column after that and the reason we do this is because when we get to this next one what we're gonna do is continue the process of looking at all the neighbors of this one trying to find if this River expands or goes anywhere else so what we're gonna do is well we're gonna look up we're gonna look left we're gonna look down and we're gonna look right but now you can see where an issue might occur if we look up we're gonna see the same river that we've already seen right and well we don't want to count that River because we've already seen it we've already marked it we already know it's part of our River and we really shouldn't go back to it and start looking in all the different directions from that River so what we do when we look in all these different directions do we say okay well if we look in this direction and we find a one that hasn't yet been marked that we haven't seen in this set here only then will we consider so in this case when we go here we can see that this isn't marked yet so we'd consider it now what we're gonna do from here is consider all the neighbors that aren't marked so in this instance we'll look at this one because this is you know one of the neighbors of it and then same thing from this one we're gonna look in every position we're gonna look for any ones that aren't marked so we won't look here because that's marked obviously so what we'll do then is we'll go to the next one then same thing here we'll go to the next one continually marking all of these positions in our list so in this case we're gonna mark position 1 1 we need to mark position 2 1 I think and then we need to mark position what should this be 2 I think that's the correct position yeah so we'll go to 2 marked and then this now has made up our first River we've marked all these positions and while we've been doing this we've been keeping track of the length of that River I don't know what I just wrote there which I'm gonna say is a fine right so the length of this river is 5 so we've kept track of that as we've gone through and found all these ones now we'll add that to one of the rivers that we found which is 5 ok so we did that we looked through all of these so let me erase the let's talk about the next step that we're gonna do so get rid of all this all that okay so now we already looked at this one so we found all these other ones from this one that are connected to it we've marked all of those now we're going to move to this next position which is a zero since it's a zero we don't need to consider anything because there's obviously no river there same thing here we don't need to consider it same thing here don't need to consider it now we hit another one so what do we do alright let's reopen up this set here let's start by marking the fact that okay we've considered this our current River length is 1 we've looked at this one what position is this in that's in position 0 4 so we'll mark that now what are we gonna do we're gonna look left up right down right so we look at all these we realize that ok obviously to the left is a zero we don't need to look at that down what's that oh it's a 1 ok so let's look at that alright one looks up looks left looks right looks down sees ok well this one's already marked we're actually gonna mark this one that we've seen it so what position is this that's position 1 4 then we say ok let's go to the next one which is this one let's mark it what's this one well this should actually be 2 4 and now our current River length is 3 there's no more else that we can go because those are all zeros obviously so we stop we add 3 into our list of rivers so now we have a list of let's say what is it 5 & 3 so 5 comma 3 and now we can continue the process so where do we left leave off well we had looked at this one already so now we'll go to the next one we'll look at this one oh wait this is a one okay so did we start the process again no we don't the reason we don't start the process of looking for other rivers is because we've marked this one and we can see that position should actually be 1 0 which is right here so we don't even bother considering it we'd go to this one same thing it's already in our set so we don't need to look at it because it's already part of a river 0 that's a 0 we don't look at it 0 we don't look at it 1 ok well that we've already looked at it's a part of the set don't look at it and you guys get the process 0 don't look at it one don't look at its in the set 1 don't look at it 0 don't look at it 1 it's in set we don't care all of these obviously we're not gonna look through until eventually we hit this one say ok it's a 1 it's in the set so let's consider it and then we're gonna chain go all the way here look at all these ones mark all these ones notice that you know that's another River add five then we're at the end here so we just returned that list and this is exactly what we're gonna do and this is the process that we're gonna follow so I hope that makes sense I've dug into it pretty indepth I've talked about it for about 10 minutes kind of this depthfirst search approach which is kind of what this is we're just looking through all of the neighbors of all these different things and kind of traversing the graph now it's time to apply this in Python it's a little bit of an advanced algorithm but try to stay with me and you know try to write it yourself first and then you come back again I'll go expert you can use this question for free so you guys can actually go to algo expert on and perform this question on the website for free you don't need to sign in or pay for it to do it because this is a free question then obviously if you guys like it you can take advantage of that discount and use some other questions let me put away some of my stuff and we'll get here and start coding all right so let's start coding this problem now I'll make this fullscreen I hopefully this is big enough for me for you guys let me know in the comments if it's too small actually it will go fullscreen on everything here okay there we go all right so what's the first thing that we need to do well we need to create this kind of set that we're gonna keep track of all of the marked rivers in and we also need a list that we're gonna keep track of all the river lengths in that we discover so what I'm gonna do is I'm gonna start by creating a set which is we're gonna call marked so this look keep track of all the rivers we've already seen and now we'll keep track of I guess rivers that we've seen in a list what we're gonna do next is what I've explained and I'm just gonna follow kind of the algorithm that I explained to you guys in the following page we're gonna loop through every single position in the matrix so starting from the very top left going to the very bottom right we're gonna say four row in range the length of matrix like that then we're gonna say for call in range B Len of matrix like this and then row like so now the reason we're doing this is because this is going to essentially tell us you know how long each row is because we know these might not necessarily be the same in terms of length and width so for each row in our matrix we'll figure out how long Rowe is and then loop through every single position okay so now that we've done that the first thing that we need to do is we need to look at the current position in our matrix so our row call position we need to see if that's a 1 and we need to make sure that we haven't already looked at it in the market set so to do that we're gonna say if in this case the matrix and we'll say row call equals equals 1 and in this case we'll say row call not in marked so if that's true which essentially again means you know it's a 1 and it's not in the mark set what do we need to do well we need to start looking at all the different positions around it so what we're gonna do is start by essentially saying our current River length is equal to 1 at the current moment we found one which means this river has length 1 what we're gonna do next is actually set up something that I'm gonna call a stack and I'm gonna set up our actually sorry add this position to mark now we'll talk about what this is gonna do in a second so I'm gonna say mark dot add and I'm gonna add row call which is essentially saying okay we're going to put this position that we've seen in the marked set so we know not to look at it again what I'm also gonna do is add row call in to my stack now if you guys haven't seen stacks before I'll briefly kind of go through how they work but it's a fairly simple data structure this is gonna allow us to do kind of a depthfirst search of this all the ones that we can find attached to this river so what I'm gonna do now is say well stack I'm gonna say current equals stack dot pop and we'll talk about what this does okay so what this means is essentially while stacks so if there's anything in our stack because what we're gonna do is every time we find a one that is neighboring the current one that we looked at we're gonna add that to our stack which we're gonna call here so that we can look at all of the neighbors of that one during the next kind of iteration of this searching traversing process so what we do is we're gonna say the current like node the current one we're looking at is gonna come from the end of the stack so whatever we pop off that's what it is going to come from the end so in this case when we start we'll just get this row column which is the first one that we have that's one we're gonna look at what we're gonna do next is get all the neighbors of this and then look at all of those neighbors and see you know one of those neighbors are they ones are they zero should we look at them should we add one to our current River life do we see another one that's adjacent to it what do we do so what we need to do to do that though is create a function that can give us all of the neighbors based on a current position in our matrix so what we're gonna do is say define get underscore neighbors if I could spell neighbors correctly and I don't know if you spell it Oh urs or if it's o RS but we'll just go with this for right now because why not and what this is going to take is a position and the matrix what we're gonna do in here is essentially find what the position of the left neighbor the top neighbor the right neighbor and the bottom neighbor is so to do this is pretty straightforward we're gonna start by saying y comma x equals position which is just gonna decompose this topple for us and essentially tell us the two components of it so we can use those independently and now what I'm gonna say is if X is greater than I should say greater than 1 greater than or equal to 1 what we'll do is and we'll create a list here we'll call it NS which just stands for neighbors we're gonna say NS dot append and in this case we're gonna do X or say Y X minus 1 now this is going to give us the left neighbor so we can put a little comment here that says left and why am i doing comments in Java I've been reading too much Java next what we're gonna do is check the so that was left neighbor will check the right neighbor so we'll say if X is less than and in this case we're actually gonna say is the length of matrix 0 minus 1 now the reason we're doing this is because we're going to add 1 to X so we need to make sure it's less than whatever the length minus 1 is so that we don't get an index error so we'll say NS dot append Y X plus 1 and I will do the same thing for Y so if Y is less than or sorry not less than greater than or equal to 1 then what we'll do is NS dot append and we'll say Y minus 1 X and then same thing with the other component so if Y is less than the line of matrix minus one because that'll give us the Rose NS dot append and in this case it should be y plus 1x now we'll simply return that list so return an S and that will give us all of our neighbors okay awesome so I think that makes sense so far so now what we'll do is get all the neighbors of this current position so to do that what we'll simply say is okay and actually we'll say neighbors Y not equals get underscore neighbors of position which is actually going to be row call and matrix awesome so now that we do that we're gonna have a list stored in here of all the neighbors so what we need to do is look through all these neighbors first of all see if there one see if we've already looked at them or not and if we haven't then we'll do is add one to our current River length and then add that to the stack so that we can look at all these neighbors again and again and again and kind of traverse through all of these and I'll dig into it in a second so what we're gonna do now is say for n in neighbors so this again will give us those positions I think I need an H there I do now we're going to say is if N or actually I'll say Y x equals n just so we can decompose this and make it a little bit easier so we'll say if matrix yeah if matrix y x equals equals 1 and y x not in marked which essentially means we haven't looked at this river already then what we'll do is we'll add it to mark so say marked dot add Y X will say cur underscore River underscore length plus equals 1 because this is another component of the river that we found so we need to add it and then finally what we will do is add it to the stack so it's a stack dot append and if I could get the right symbols here we will append Y X now the reason we're doing this appending to the stack is because we need to add that one and I think I can go back to my drawing example maybe this will make things a bit clearer like okay well this is an absolute mess now but if we're here right and we find this other one well we need to add this one to the stack back so that we can look at the neighbors of this one next right and then whenever we find another one or maybe there's two ones we add both of them to the stack so that we can look at all of their neighbors during the next iteration when we pop things off the stack now I know this might be kind of confusing to some of you guys if you haven't seen an algorithm like this before we're actually almost done so what we're gonna do now is essentially once the stack is empty we're gonna add to the rivers list so we're gonna say rivers dot append current River length Soaker underscore River underscore length and then at the very end of our program will return rivers now that should actually be it I'm just gonna do a quick glance of my other screen I do have the solution up right now to make sure I haven't absolutely butchered it and it looks like we're doing all right and yeah that should actually be it so essentially the process is right loop through every single position make sure that the position we're looking at is either one and it's not marked if that's true if it's a one it's not marked we'll say okay so we're gonna look for a river now attached to this one it has a current River length of one it's we're gonna add it to the marked list so we don't look at it again we're gonna create this stack that starts just just having this position then what we'll do is we'll pop that off the stack which actually means remove this element set it equal to current then what we do is we're gonna say neighbors equals get neighbors row call matrix so this actually should be current my bad guys this shouldn't be wrote call the reason it needs to be current is because we're gonna actually change the neighbors we're getting based on the thing we just popped off the stack so sorry this is current matrix this will give us all of the neighbors for that specific position and assuming I didn't mess up this function that should be alright then what we're gonna do is look through all of the neighbors essentially say okay let's break down their components let's check if this neighbor is a one so if it's a one in the matrix and if it's not yet marked what we'll do is we'll add it to the marked set we'll set current River length plus one because we just found another one that's a part of this River we'll add it to the stack so that we can then look at all the neighbors of that one and see if there's any other you know rivers that are extending and going off finally once that's done so we don't have nothing left in the stack that we found the end of the river what we'll do is append the current River length then we will return rivers now returning rivers will just return this final list this is a little bit of a messy coat but let's run this and see if we've done all right or not so let's zoom out run code log into run code okay so I'm gonna log in and run the code and then let's see if this works okay so we passed now I would like to say that I actually just had to copy the code like my solution back in here it's the exact same as what I wrote but you might notice some variable names are a little bit different because for some reason it deleted my code when I signed back in to run the code anyway so there we go we passed our outputs are good and I mean we can see them can have a look at the raw output here saying how long it ran in and we can have a look at these test cases to see you know what we were tested up against and if that actually worked we'd also write our own test cases if we want to inside of your tests like you can modify them and if we have a look here we'll have a look at our optimal spacetime complexity so we have owh time owh space which is actually I believe what this algorithm runs in so if you guys want to challenge yourself leave a comment down below and tell me if I'm right or wrong on the spacetime complexity of this algorithm I'm trying to get it centered in the page here so that we can have a look at all of it but does this that I've written here run in owh time where W is the width and H is the length of our matrix I'm gonna go on a limb and say yes it does the reason I say that is because obviously these two loops are gonna be WH right then what we're gonna do in here is we're only ever gonna execute this a maximum of W times each times because we're adding all these things into our marked set and looking up an element in a set takes a one time on average it can take longer to find if it's in there but on average takes a one time so what's gonna happen is this will only run a maximum of WH times so technically we would have to WH is our maximum amount of runs that we can potentially have because in combination of all these loops the some of that will be less than WH so we can remove that constant and then have WH as our running time complexity now in terms of space what we're using is well essentially a set here that could potentially have maximum WH elements for every single element being a river so one massive River is the entire matrix that's possible and then rivers here well this can have I mean in theory it can have as many rivers as are actually in the matrix so that's gonna give us two WH for space but since again we can remove that constant we'll have WH for space and that should be good I'm sure someone can come up with a reason why this might not run in WH why am i running like WH squared or something like that but if you can that's awesome leave a comment down below and I think that has been after this video as always if you guys enjoyed make sure to leave a like you know always get a 10% discount on algo expert using the code I have in the description and with that being said I will see you guys in another video
