With timestamps:

00:00 - hey guys and welcome back to another
00:01 - YouTube video so in today's video I'm
00:03 - gonna be showing you a path finding
00:05 - algorithm and this algorithm is called
00:06 - breaths first search algorithm now I
00:09 - don't know if I said that correctly or
00:11 - not so feel free to correct me in the
00:13 - comments if I'm butchering the name but
00:15 - essentially what this is is it's a cue
00:17 - based algorithm it's very simple that
00:19 - allows us to find the shortest possible
00:20 - path from one point to another point in
00:23 - a maze that looks something like this
00:24 - now you can use this to do tons of
00:27 - different things path finding is just
00:29 - one of the nice applications and visual
00:31 - applications that we can show you with
00:32 - it but essentially what it does and what
00:34 - this algorithm can do for us is generate
00:36 - a list of every single possible move or
00:39 - subset of a problem that we can do and
00:42 - we can try all of those different things
00:43 - until eventually we reach result that's
00:45 - favorable or that we want so in this
00:47 - case we're gonna generate for example in
00:49 - a maze like this we're gonna generate
00:51 - every single possible valid move that
00:53 - you could make in this move so every
00:54 - single possible path you could have
00:56 - we're gonna try that path and we're
00:58 - gonna see that if it goes from the start
01:00 - point to the end point and the way we're
01:02 - gonna determine if it's the shortest
01:04 - path is how I'm gonna top what I'm going
01:05 - to talk about throughout this video so
01:07 - let's start with a demonstration and
01:08 - then I want to move into talking about a
01:10 - queue so we're gonna explain that and
01:12 - then we'll talk about the breaths first
01:13 - search algorithm how that works and then
01:14 - we'll get into implementing it so I
01:16 - already have this obviously coded and
01:18 - I'll show you that when I run this
01:20 - program you can see that it generates
01:22 - the shortest path for this maze so this
01:24 - is the start point and this is the end
01:26 - point and you can see these plus signs
01:27 - represent actually the only path that
01:29 - leads us to this end node ok now if I
01:33 - have another may so I've maced two so
01:35 - let's run this and just do a comparison
01:37 - here so amazed to change that and you
01:42 - can see that again we get the shortest
01:44 - path from there to the end point here
01:46 - and obviously I can mess around at this
01:48 - endpoint if I want to show you and prove
01:49 - to you that I did not just actually hard
01:52 - code this what I can do is put X here
01:55 - put a pound sign where's this like that
01:59 - and there we go you get did I make
02:04 - mistake here let's run this one more
02:05 - time
02:06 - oh I'm messing up the wrong maze my bad
02:08 - okay I thought I really made a horrible
02:10 - mistake there okay so I was changing the
02:12 - wrong maze anyways
02:13 - change the end coordinate to be here now
02:15 - we'll run that and you can see now that
02:17 - again it's finding us the shortest path
02:19 - which will be this to get to the end
02:21 - node and I'm gonna talk about exactly
02:23 - how this works and how we can kind of
02:24 - implement this okay so let's go to the
02:27 - drawing board now and talk about our
02:29 - first problem where our first kind of
02:31 - thing which is a queue so what is a
02:34 - queue you might have heard of queue
02:35 - before maybe in pool maybe and just like
02:37 - a list kind of data structure but
02:38 - essentially just a data structure that
02:40 - has a few different properties
02:42 - associated with it so the queue that
02:43 - we're going to talk about is called FIFO
02:45 - now you might have seen this before and
02:47 - you might have been like whoa what the
02:48 - heck does this mean it's actually super
02:49 - straightforward it stands for first in
02:51 - first out and that obviously means to
02:53 - the first element to go into the queue
02:55 - has priority of coming out of the queue
02:57 - first it's a very basic and standard
03:00 - data structure if you guys are in
03:01 - computer science or are taking a course
03:03 - you'll probably learn about it at some
03:05 - point hopefully at least in first-year
03:07 - University so first in first out okay
03:10 - that's the queue that we're gonna be
03:11 - using so to give you a quick
03:12 - demonstration of what I mean by that
03:13 - let's create a queue and let's add some
03:16 - elements so this is going to be my queue
03:17 - it's hard to like keep redrawing the
03:19 - queues but anyways you get what I mean
03:20 - so this is gonna be my queue data
03:22 - structure and what I want to do is I
03:24 - want to add the elements one four and
03:27 - five to my queue so the first element
03:30 - I'm gonna add is gonna be one okay so
03:32 - one comes into my queue and it's
03:33 - actually gonna start let's start it here
03:35 - at the end okay so we can get rid of
03:37 - this line so put one here so this is the
03:40 - first element in our queue and we could
03:42 - put a little one above it just to
03:43 - represent that it is the first one okay
03:45 - now the next element I want to add into
03:47 - my queue is four so what we're gonna do
03:50 - is we're gonna push for to the end of
03:52 - the queue so four will go here and what
03:54 - that means is I go to my eraser tool
03:56 - here our one gets pushed over here to
03:59 - the beginning of the queue now so one is
04:02 - here your 4 is here this is the first
04:03 - element added and this is the second
04:05 - element added so now at this point in
04:07 - time if I wanted to remove an element
04:08 - from the queue which one would be
04:10 - removed well we don't really have a
04:12 - choice it would be one and that is
04:14 - because it has the highest priority and
04:16 - it was the first element added to the
04:18 - queue so if I wanted to remove an
04:19 - element what I would do is I would
04:21 - remove one so we can simply erase one
04:23 - like this okay that would mean a four
04:26 - would shift in
04:27 - - like the first position in the queue
04:28 - okay so it moves over and then if we
04:31 - wanted to remove another element from
04:32 - the queue well the only element left in
04:33 - the queue is for so we'd take four and
04:35 - we'd move it over to the queue and we'd
04:37 - remove that okay so let's say now we
04:39 - have four in the queue one has been
04:41 - removed we've already added and removed
04:42 - it we want to add five well we can add
04:44 - five in here like that now this is the
04:47 - first element of the queue this is the
04:48 - second element the queue so if we want
04:49 - to remove an element we remove four it
04:52 - comes out like that and then five would
04:53 - be shipped over and be the first element
04:55 - in the queue I hope that makes sense
04:57 - it's pretty straightforward you as I
04:58 - understand as we go through some
04:59 - examples so how can we use this queue to
05:02 - generate like a subset of every single
05:05 - possible solution so let's do a really
05:07 - basic example with binary numbers so by
05:10 - neri my horrible writing skills okay so
05:12 - binary numbers you can either have a 0
05:14 - or a 1 right so say we want to generate
05:17 - all the binary numbers up to let's say
05:19 - 15 okay how can we do that using a queue
05:23 - well what we want to do I'll just put
05:25 - this in here in brackets 15 is we're
05:28 - gonna start by let's say set up a queue
05:30 - so we're gonna say Q equals 2 and this
05:33 - will just be like a blank queue for
05:34 - right now okay what we're gonna do is
05:36 - we're gonna add two things into the
05:38 - queue we're gonna start actually with
05:39 - nothing and we're gonna go through a
05:40 - while loop or a for loop in this case
05:42 - we're gonna say for blank because it
05:44 - doesn't actually matter what this value
05:45 - is in range okay and we'll do 15 because
05:49 - we want to generate 15 numbers what
05:51 - we're gonna do is we're gonna start so
05:53 - this actually in the start would just
05:54 - blank in it okay just nothing we're
05:56 - gonna start by D queuing and what D
05:59 - queuing means is it means removing
06:00 - something from the queue so you might
06:02 - hear this says DQ means remove from the
06:04 - queue then there's something called on
06:05 - queue which means add to the queue and
06:06 - on queue adds to the end of the Q DQ
06:08 - removes from the front of the queue
06:10 - first in first at right okay so if we're
06:12 - doing for D queuing we're gonna say like
06:14 - X alright equals Q dot get now get is
06:19 - just getting be like the first element
06:21 - in the queue from us okay so x equals Q
06:24 - dot get so X in this case is going to be
06:25 - equal to a blank string and now what
06:27 - we're going to do is we're going to add
06:28 - two elements into the queue so we're
06:31 - going to start by adding will say y
06:32 - equals and we're gonna do X plus and
06:36 - then in this case 0 okay because we're
06:39 - doing the binary number 0
06:40 - and then we're gonna do Z equals x plus
06:45 - one so now what we've done is we what
06:48 - we've removed this blank string from the
06:50 - queue so our queue now looks like this
06:51 - okay
06:52 - and then what we've done is we've added
06:53 - two elements into the queue so the first
06:55 - element we added was 0 because blank
06:57 - plus 0 is 0 and then we added 1 so now
07:00 - we have 0 and we have 1 ok so imagine
07:02 - this both of these I don't have enough
07:05 - room just say add to queue ok we're just
07:09 - gonna say that we added those alright ok
07:11 - so we do that and this is our for loop
07:13 - and this is what we're gonna do to
07:14 - generate the subset so now let's look at
07:16 - the next loop of our for loop okay so
07:19 - our queue is 0-1 I'm just gonna leave
07:22 - this undid so I can are undone or
07:24 - whatever so I can add things so now what
07:26 - happens when we get something from the
07:28 - queue what do we get we get 0 right
07:31 - because well we 0 is the first element
07:34 - so we're gonna grab that and now we're
07:36 - gonna add another thing to the queue so
07:39 - does yours remove 0 is gone so let's
07:41 - erase this erase 0 okay and now what do
07:45 - we have X is 0 so that means Y is gonna
07:47 - be equal to 0 0 right and what is Zed
07:51 - well Z is 0 1 ok so there we go now we
07:56 - have 1 0 0 0 1 ok so let's do the next
07:59 - thing let's try the next one
08:00 - okay so now we're gonna queue again
08:01 - we're going to start and what is our
08:03 - first element the queue that's 1 so
08:05 - we're gonna remove one from the queue so
08:07 - let's do one ok we'll move these
08:10 - brackets over just to save us a bit of
08:12 - room here ok so we have 1 so X is equal
08:15 - to 1 and then we do what y equals x plus
08:18 - 0 so that means now we're gonna get 1 0
08:20 - in our queue and then what's the next
08:22 - thing we're gonna get we're going to get
08:23 - X plus 1 which stands for 1 1 so now you
08:26 - can see we have 0 0 0 1 1 0 1 1 in our
08:30 - queue and obviously we can keep
08:32 - repeating this process and if I do it
08:34 - one more time essentially what's going
08:35 - to happen is we're gonna remove 0 0 so
08:37 - that gets will get rid of 0 0 ok and
08:39 - then the next thing that we're gonna add
08:40 - into her Q is 0 0 0 so 0 0 0 and then
08:44 - we're gonna add 0 0 1 ok we're gonna add
08:48 - those to the end and we're gonna grab 0
08:49 - 1 and then we're gonna go 0 1 0 and
08:51 - we're gonna go 0 1 1
08:53 - I'm going to keep on keep on keep on
08:55 - generating these until eventually we hit
08:57 - the binary number 15 or until this loop
08:59 - has ran 15 times okay and I hope that
09:02 - makes sense in terms of how to generate
09:03 - that so see how much time we're at nine
09:05 - minutes yeah that's not bad
09:06 - so that is how we can generate a subset
09:09 - of every single binary number so how do
09:11 - we now apply this into pathfinding well
09:13 - it's a very similar approach so in
09:16 - binary numbers we had two things we had
09:18 - 0 & 1 with our path we have 4 things we
09:21 - have up right down left and right so
09:26 - what do we do now if we want to add
09:28 - these 4 things to our queue well it's
09:31 - the exact same process we're gonna start
09:32 - with a queue and all the queue is gonna
09:34 - happen it is a blank string ok nothing
09:36 - now all we're gonna do is we're just
09:38 - gonna loop so let's just say loop we'll
09:39 - write some pseudocode here and all we're
09:41 - gonna do is we're gonna DQ the first
09:43 - element so we're gonna say X is equal to
09:45 - Q dot get so we're getting that first
09:47 - element which is going to be a blank
09:49 - string and then what we're gonna do is
09:50 - instead of just adding two things we're
09:52 - gonna add four things so we're gonna say
09:54 - X plus equals or no what am I saying X
09:57 - plus equals will say like add one so the
10:02 - first thing to add to the queue will be
10:03 - equal to X plus and in this case U and
10:06 - then the next one so add two will be
10:09 - equal to X plus and we'll do D like that
10:12 - and we'll go and we'll do L and we'll do
10:14 - our as well and we'll add those and
10:17 - we'll continue through the process and
10:19 - it will generate every single possible
10:21 - like solution to UDL are on that we
10:24 - could have and we'll I'll show you how
10:27 - like we'll print it out and we'll be
10:29 - able to look at all of them in a second
10:30 - okay but that's how we do it for path
10:32 - finding now the only thing with path
10:34 - finding is we could have invalid paths
10:36 - so let's actually clear this so for
10:37 - example if we draw a 3 by 3 grid so if
10:40 - we do something like this okay so 3 by 3
10:46 - quick little grid here and we say like
10:48 - this is an obstacle our start point is
10:50 - here in our end point is here we want to
10:52 - get from the start to the end well the
10:54 - way we do this is again we're gonna
10:56 - generate all the possible moves so the
10:57 - first move we would have well the only
11:00 - valid moves we can do is we can go this
11:02 - way when go left or we can go down right
11:05 - because if we try to go backwards sorry
11:06 - right and we try to go up those are not
11:08 - valid moves so we're not gonna add them
11:10 - to the queue and I'll show you how we
11:11 - implement that in Python but essentially
11:13 - just only add valid moves to the queue
11:16 - so that when we're checking if we've
11:17 - reached this destination and we're only
11:19 - checking valid moves there's no point in
11:20 - checking moves outside of the range
11:22 - right okay so we have two possible moves
11:24 - so our moves right now in our queue are
11:26 - gonna be equal to what left and down
11:29 - okay
11:30 - so now we repeat the process we'll dql
11:33 - so let's dql and we'll look at now we're
11:36 - looking at this move okay so now I was
11:38 - removed from the queue so if we go
11:40 - where's my eraser and we removed el and
11:43 - let's open up this queue again okay so
11:46 - we removed el now we're at el what's the
11:48 - only valid boost we can do well we can
11:50 - go right or we can go left okay so the
11:54 - two moves will add from that our now
11:56 - we're gonna have left left we're gonna
11:58 - have left right and those are the two
12:01 - moves now down let's look at what down
12:03 - is okay so now we're down so we'll DQ
12:05 - that
12:06 - so we'll say down what are the moves we
12:07 - can possibly do well we can't go right
12:09 - okay we could can we can go up we cannot
12:13 - go left and we can go down so the two
12:15 - moves we can do our here and here so
12:17 - let's just undo all those arrows quickly
12:19 - so what we're gonna do then obviously is
12:21 - we'll add will say one of the moves is
12:23 - down down another move is down up okay
12:27 - now D is removed and let's just pretend
12:30 - this keeps going quickly on to over here
12:33 - I chose the wrong pat object and that we
12:36 - can just continue repeating this process
12:38 - and eventually what's gonna happen is
12:39 - we're gonna get a move that's either
12:41 - equal to what do you call it left left
12:44 - down down down or we're gonna get a move
12:48 - that's equal to down down left left left
12:51 - now each of these are only five moves
12:55 - so either path is perfectly valid to go
12:57 - and that's how we're gonna generate the
12:59 - path to find our point now I hope that
13:02 - makes sense that's probably like the
13:04 - longest but easiest way I can explain
13:06 - this to you and how that works but
13:08 - essentially we're gonna generate every
13:09 - single possible path we're gonna check
13:11 - before we add something into the queue
13:12 - if it's a valid path for example going
13:14 - here so going down and going left is not
13:16 - valid so we won't bother adding it to
13:18 - the
13:18 - you and then what we're gonna do is
13:20 - every time we generate a new path we're
13:22 - gonna check if that path reaches the end
13:24 - and if it does we can simply stop
13:26 - because we know we found the shortest
13:28 - path now how do we know we found the
13:30 - shortest path well every time we DQ and
13:32 - we add things to the queue we're adding
13:33 - one step to the path so if we just found
13:36 - a path we would have generated every
13:38 - single possible path that takes five
13:40 - steps and we found one that reached the
13:42 - end we know that we're at the shortest
13:44 - path because we would have found a path
13:46 - earlier if there was a shorter one and I
13:48 - hope that makes sense in terms of how
13:49 - that works okay so that's enough for the
13:51 - drawing so let's do a quick talk about
13:53 - this implementation here all the source
13:55 - code is gonna be up on my website tech
13:56 - with Tim done that if you guys want to
13:57 - use this sorry I'm just putting away my
13:59 - drawing table here so I can get my
14:02 - keyboard ready to go but essentially uh
14:03 - most of this code is just the cosmetic
14:06 - stuff like creating the maze printing
14:09 - the maze outright valid checking if it's
14:12 - a valid position finding the ED so let's
14:15 - just go to the algorithm and this is the
14:16 - part that I was explaining to you I'm
14:18 - not gonna talk about all these but
14:19 - essentially we create a queue now Python
14:21 - already has an implementation for a
14:22 - queue if you simply import queue then
14:24 - you can use that and we can put things
14:26 - into the queue by doing dot put alright
14:29 - so I start by putting a blank string
14:30 - like I was talking about before okay and
14:32 - then I'm just setting this variable add
14:34 - equal to blank and I just is gonna
14:36 - represent like the first path that we
14:38 - have okay I'm gonna create a maze
14:40 - because the maze is gonna be what I want
14:42 - to traverse through and see if I've
14:44 - reached the end or not and well Wow I
14:47 - have not found the end of the maze so
14:49 - while find end is not true what I mean I
14:52 - give it maze and I give it add and add
14:54 - as represents the path that we just
14:55 - recently used okay I could probably call
14:58 - that path it would make more sense but
15:00 - that's what ad represents essentially
15:01 - while we have not found the end we're
15:04 - gonna continue doing the process that
15:05 - I'm going to talk about here so we're
15:07 - gonna DQ we're gonna get the first
15:09 - element from the queue in this case
15:10 - we're gonna numbs dog get and nums just
15:12 - represents all of the different things
15:14 - in our queue okay because I did nums
15:16 - equals QQ all right we're going to say
15:19 - 4j left/right up/down now all this is
15:21 - doing essentially is we're first gonna
15:23 - start by creating a new thing to put
15:25 - into the queue the first thing we're
15:27 - gonna do is we're gonna get the last
15:28 - element that we DQ'd we're gonna add
15:30 - first of all left to it then we're
15:32 - add right to it then we're gonna up to
15:33 - it then we're gonna add down to it
15:34 - that's how the for-loop works and before
15:36 - we actually add it to the queue we're
15:39 - gonna make sure it's a valid path so we
15:40 - say if this path so what we've just
15:42 - generated is valid in the given maze
15:44 - then we'll add it to the queue otherwise
15:47 - just go to the next one don't bother
15:48 - adding it because why would I add a path
15:50 - that's not valid we can't take that path
15:52 - so there's no point using it and we're
15:53 - going to loop through this until
15:55 - eventually we find the end in which case
15:57 - this loop will break and then our path
15:59 - will be equal to what do you call it
16:01 - whatever path like whatever the last
16:03 - path and the queue is so for example
16:06 - like if you you had a list a length of
16:08 - 67 the 67th path would be the one that
16:11 - would lead you to the end position and
16:14 - that's because we stopped at that point
16:16 - so the last element is obviously gonna
16:18 - be the path so I'll demonstrate again
16:20 - for you one more time and you can kind
16:22 - of see right maybe this makes more sense
16:24 - on how its works now so we started by
16:26 - generating this position because it was
16:28 - the only valid position right and then
16:30 - this position generated either right or
16:32 - left and then this one generated left or
16:36 - down and right and it just keeps going
16:38 - and generating every single possible
16:40 - position until eventually we hit here so
16:44 - like every single possible movement
16:46 - almost was generated here but once we
16:49 - eventually hit here we just stopped and
16:51 - we said this is the path down left down
16:53 - down right down down and you can see how
16:55 - that works on the maze okay so anyways
16:58 - that is Brett's first search algorithm
17:00 - explained extremely in-depth if you guys
17:02 - have any questions about that please
17:04 - don't hesitate to ask me if you guys
17:05 - want to mess around with this example
17:06 - make your own mazes please head to my
17:08 - website go ahead and download it use it
17:10 - on it's completely for free I want you
17:12 - guys to learn and experiment with this
17:13 - and I think it's pretty cool how this
17:14 - actually works and as always if you guys
17:16 - are new here please make sure you leave
17:18 - a like and subscribe to the channel I
17:20 - will see you again in another video
17:21 - [Music]

Cleaned transcript:

hey guys and welcome back to another YouTube video so in today's video I'm gonna be showing you a path finding algorithm and this algorithm is called breaths first search algorithm now I don't know if I said that correctly or not so feel free to correct me in the comments if I'm butchering the name but essentially what this is is it's a cue based algorithm it's very simple that allows us to find the shortest possible path from one point to another point in a maze that looks something like this now you can use this to do tons of different things path finding is just one of the nice applications and visual applications that we can show you with it but essentially what it does and what this algorithm can do for us is generate a list of every single possible move or subset of a problem that we can do and we can try all of those different things until eventually we reach result that's favorable or that we want so in this case we're gonna generate for example in a maze like this we're gonna generate every single possible valid move that you could make in this move so every single possible path you could have we're gonna try that path and we're gonna see that if it goes from the start point to the end point and the way we're gonna determine if it's the shortest path is how I'm gonna top what I'm going to talk about throughout this video so let's start with a demonstration and then I want to move into talking about a queue so we're gonna explain that and then we'll talk about the breaths first search algorithm how that works and then we'll get into implementing it so I already have this obviously coded and I'll show you that when I run this program you can see that it generates the shortest path for this maze so this is the start point and this is the end point and you can see these plus signs represent actually the only path that leads us to this end node ok now if I have another may so I've maced two so let's run this and just do a comparison here so amazed to change that and you can see that again we get the shortest path from there to the end point here and obviously I can mess around at this endpoint if I want to show you and prove to you that I did not just actually hard code this what I can do is put X here put a pound sign where's this like that and there we go you get did I make mistake here let's run this one more time oh I'm messing up the wrong maze my bad okay I thought I really made a horrible mistake there okay so I was changing the wrong maze anyways change the end coordinate to be here now we'll run that and you can see now that again it's finding us the shortest path which will be this to get to the end node and I'm gonna talk about exactly how this works and how we can kind of implement this okay so let's go to the drawing board now and talk about our first problem where our first kind of thing which is a queue so what is a queue you might have heard of queue before maybe in pool maybe and just like a list kind of data structure but essentially just a data structure that has a few different properties associated with it so the queue that we're going to talk about is called FIFO now you might have seen this before and you might have been like whoa what the heck does this mean it's actually super straightforward it stands for first in first out and that obviously means to the first element to go into the queue has priority of coming out of the queue first it's a very basic and standard data structure if you guys are in computer science or are taking a course you'll probably learn about it at some point hopefully at least in firstyear University so first in first out okay that's the queue that we're gonna be using so to give you a quick demonstration of what I mean by that let's create a queue and let's add some elements so this is going to be my queue it's hard to like keep redrawing the queues but anyways you get what I mean so this is gonna be my queue data structure and what I want to do is I want to add the elements one four and five to my queue so the first element I'm gonna add is gonna be one okay so one comes into my queue and it's actually gonna start let's start it here at the end okay so we can get rid of this line so put one here so this is the first element in our queue and we could put a little one above it just to represent that it is the first one okay now the next element I want to add into my queue is four so what we're gonna do is we're gonna push for to the end of the queue so four will go here and what that means is I go to my eraser tool here our one gets pushed over here to the beginning of the queue now so one is here your 4 is here this is the first element added and this is the second element added so now at this point in time if I wanted to remove an element from the queue which one would be removed well we don't really have a choice it would be one and that is because it has the highest priority and it was the first element added to the queue so if I wanted to remove an element what I would do is I would remove one so we can simply erase one like this okay that would mean a four would shift in like the first position in the queue okay so it moves over and then if we wanted to remove another element from the queue well the only element left in the queue is for so we'd take four and we'd move it over to the queue and we'd remove that okay so let's say now we have four in the queue one has been removed we've already added and removed it we want to add five well we can add five in here like that now this is the first element of the queue this is the second element the queue so if we want to remove an element we remove four it comes out like that and then five would be shipped over and be the first element in the queue I hope that makes sense it's pretty straightforward you as I understand as we go through some examples so how can we use this queue to generate like a subset of every single possible solution so let's do a really basic example with binary numbers so by neri my horrible writing skills okay so binary numbers you can either have a 0 or a 1 right so say we want to generate all the binary numbers up to let's say 15 okay how can we do that using a queue well what we want to do I'll just put this in here in brackets 15 is we're gonna start by let's say set up a queue so we're gonna say Q equals 2 and this will just be like a blank queue for right now okay what we're gonna do is we're gonna add two things into the queue we're gonna start actually with nothing and we're gonna go through a while loop or a for loop in this case we're gonna say for blank because it doesn't actually matter what this value is in range okay and we'll do 15 because we want to generate 15 numbers what we're gonna do is we're gonna start so this actually in the start would just blank in it okay just nothing we're gonna start by D queuing and what D queuing means is it means removing something from the queue so you might hear this says DQ means remove from the queue then there's something called on queue which means add to the queue and on queue adds to the end of the Q DQ removes from the front of the queue first in first at right okay so if we're doing for D queuing we're gonna say like X alright equals Q dot get now get is just getting be like the first element in the queue from us okay so x equals Q dot get so X in this case is going to be equal to a blank string and now what we're going to do is we're going to add two elements into the queue so we're going to start by adding will say y equals and we're gonna do X plus and then in this case 0 okay because we're doing the binary number 0 and then we're gonna do Z equals x plus one so now what we've done is we what we've removed this blank string from the queue so our queue now looks like this okay and then what we've done is we've added two elements into the queue so the first element we added was 0 because blank plus 0 is 0 and then we added 1 so now we have 0 and we have 1 ok so imagine this both of these I don't have enough room just say add to queue ok we're just gonna say that we added those alright ok so we do that and this is our for loop and this is what we're gonna do to generate the subset so now let's look at the next loop of our for loop okay so our queue is 01 I'm just gonna leave this undid so I can are undone or whatever so I can add things so now what happens when we get something from the queue what do we get we get 0 right because well we 0 is the first element so we're gonna grab that and now we're gonna add another thing to the queue so does yours remove 0 is gone so let's erase this erase 0 okay and now what do we have X is 0 so that means Y is gonna be equal to 0 0 right and what is Zed well Z is 0 1 ok so there we go now we have 1 0 0 0 1 ok so let's do the next thing let's try the next one okay so now we're gonna queue again we're going to start and what is our first element the queue that's 1 so we're gonna remove one from the queue so let's do one ok we'll move these brackets over just to save us a bit of room here ok so we have 1 so X is equal to 1 and then we do what y equals x plus 0 so that means now we're gonna get 1 0 in our queue and then what's the next thing we're gonna get we're going to get X plus 1 which stands for 1 1 so now you can see we have 0 0 0 1 1 0 1 1 in our queue and obviously we can keep repeating this process and if I do it one more time essentially what's going to happen is we're gonna remove 0 0 so that gets will get rid of 0 0 ok and then the next thing that we're gonna add into her Q is 0 0 0 so 0 0 0 and then we're gonna add 0 0 1 ok we're gonna add those to the end and we're gonna grab 0 1 and then we're gonna go 0 1 0 and we're gonna go 0 1 1 I'm going to keep on keep on keep on generating these until eventually we hit the binary number 15 or until this loop has ran 15 times okay and I hope that makes sense in terms of how to generate that so see how much time we're at nine minutes yeah that's not bad so that is how we can generate a subset of every single binary number so how do we now apply this into pathfinding well it's a very similar approach so in binary numbers we had two things we had 0 & 1 with our path we have 4 things we have up right down left and right so what do we do now if we want to add these 4 things to our queue well it's the exact same process we're gonna start with a queue and all the queue is gonna happen it is a blank string ok nothing now all we're gonna do is we're just gonna loop so let's just say loop we'll write some pseudocode here and all we're gonna do is we're gonna DQ the first element so we're gonna say X is equal to Q dot get so we're getting that first element which is going to be a blank string and then what we're gonna do is instead of just adding two things we're gonna add four things so we're gonna say X plus equals or no what am I saying X plus equals will say like add one so the first thing to add to the queue will be equal to X plus and in this case U and then the next one so add two will be equal to X plus and we'll do D like that and we'll go and we'll do L and we'll do our as well and we'll add those and we'll continue through the process and it will generate every single possible like solution to UDL are on that we could have and we'll I'll show you how like we'll print it out and we'll be able to look at all of them in a second okay but that's how we do it for path finding now the only thing with path finding is we could have invalid paths so let's actually clear this so for example if we draw a 3 by 3 grid so if we do something like this okay so 3 by 3 quick little grid here and we say like this is an obstacle our start point is here in our end point is here we want to get from the start to the end well the way we do this is again we're gonna generate all the possible moves so the first move we would have well the only valid moves we can do is we can go this way when go left or we can go down right because if we try to go backwards sorry right and we try to go up those are not valid moves so we're not gonna add them to the queue and I'll show you how we implement that in Python but essentially just only add valid moves to the queue so that when we're checking if we've reached this destination and we're only checking valid moves there's no point in checking moves outside of the range right okay so we have two possible moves so our moves right now in our queue are gonna be equal to what left and down okay so now we repeat the process we'll dql so let's dql and we'll look at now we're looking at this move okay so now I was removed from the queue so if we go where's my eraser and we removed el and let's open up this queue again okay so we removed el now we're at el what's the only valid boost we can do well we can go right or we can go left okay so the two moves will add from that our now we're gonna have left left we're gonna have left right and those are the two moves now down let's look at what down is okay so now we're down so we'll DQ that so we'll say down what are the moves we can possibly do well we can't go right okay we could can we can go up we cannot go left and we can go down so the two moves we can do our here and here so let's just undo all those arrows quickly so what we're gonna do then obviously is we'll add will say one of the moves is down down another move is down up okay now D is removed and let's just pretend this keeps going quickly on to over here I chose the wrong pat object and that we can just continue repeating this process and eventually what's gonna happen is we're gonna get a move that's either equal to what do you call it left left down down down or we're gonna get a move that's equal to down down left left left now each of these are only five moves so either path is perfectly valid to go and that's how we're gonna generate the path to find our point now I hope that makes sense that's probably like the longest but easiest way I can explain this to you and how that works but essentially we're gonna generate every single possible path we're gonna check before we add something into the queue if it's a valid path for example going here so going down and going left is not valid so we won't bother adding it to the you and then what we're gonna do is every time we generate a new path we're gonna check if that path reaches the end and if it does we can simply stop because we know we found the shortest path now how do we know we found the shortest path well every time we DQ and we add things to the queue we're adding one step to the path so if we just found a path we would have generated every single possible path that takes five steps and we found one that reached the end we know that we're at the shortest path because we would have found a path earlier if there was a shorter one and I hope that makes sense in terms of how that works okay so that's enough for the drawing so let's do a quick talk about this implementation here all the source code is gonna be up on my website tech with Tim done that if you guys want to use this sorry I'm just putting away my drawing table here so I can get my keyboard ready to go but essentially uh most of this code is just the cosmetic stuff like creating the maze printing the maze outright valid checking if it's a valid position finding the ED so let's just go to the algorithm and this is the part that I was explaining to you I'm not gonna talk about all these but essentially we create a queue now Python already has an implementation for a queue if you simply import queue then you can use that and we can put things into the queue by doing dot put alright so I start by putting a blank string like I was talking about before okay and then I'm just setting this variable add equal to blank and I just is gonna represent like the first path that we have okay I'm gonna create a maze because the maze is gonna be what I want to traverse through and see if I've reached the end or not and well Wow I have not found the end of the maze so while find end is not true what I mean I give it maze and I give it add and add as represents the path that we just recently used okay I could probably call that path it would make more sense but that's what ad represents essentially while we have not found the end we're gonna continue doing the process that I'm going to talk about here so we're gonna DQ we're gonna get the first element from the queue in this case we're gonna numbs dog get and nums just represents all of the different things in our queue okay because I did nums equals QQ all right we're going to say 4j left/right up/down now all this is doing essentially is we're first gonna start by creating a new thing to put into the queue the first thing we're gonna do is we're gonna get the last element that we DQ'd we're gonna add first of all left to it then we're add right to it then we're gonna up to it then we're gonna add down to it that's how the forloop works and before we actually add it to the queue we're gonna make sure it's a valid path so we say if this path so what we've just generated is valid in the given maze then we'll add it to the queue otherwise just go to the next one don't bother adding it because why would I add a path that's not valid we can't take that path so there's no point using it and we're going to loop through this until eventually we find the end in which case this loop will break and then our path will be equal to what do you call it whatever path like whatever the last path and the queue is so for example like if you you had a list a length of 67 the 67th path would be the one that would lead you to the end position and that's because we stopped at that point so the last element is obviously gonna be the path so I'll demonstrate again for you one more time and you can kind of see right maybe this makes more sense on how its works now so we started by generating this position because it was the only valid position right and then this position generated either right or left and then this one generated left or down and right and it just keeps going and generating every single possible position until eventually we hit here so like every single possible movement almost was generated here but once we eventually hit here we just stopped and we said this is the path down left down down right down down and you can see how that works on the maze okay so anyways that is Brett's first search algorithm explained extremely indepth if you guys have any questions about that please don't hesitate to ask me if you guys want to mess around with this example make your own mazes please head to my website go ahead and download it use it on it's completely for free I want you guys to learn and experiment with this and I think it's pretty cool how this actually works and as always if you guys are new here please make sure you leave a like and subscribe to the channel I will see you again in another video
