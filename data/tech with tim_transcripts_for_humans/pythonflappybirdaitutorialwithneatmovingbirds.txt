With timestamps:

00:00 - we say self dot tic underscore county
00:02 - plus equals one which means you know a
00:03 - tic happened a frame went by and now
00:07 - we've moved so we'll keep track of X how
00:09 - many times we move since the last jump
00:11 - all right the next thing we need to
00:12 - calculate is something called
00:13 - displacement and this is gonna be how
00:15 - many pixels were moving up or down this
00:19 - frame and this will be you know what we
00:20 - end up actually moving when we change
00:23 - the Y position of the bird so we're
00:26 - gonna say D equals and in this case
00:27 - we're gonna say self dot Val which is
00:30 - gonna be our velocity multiplied by self
00:33 - dot tic underscore count plus 1.5 times
00:38 - self dot tic underscore count to the
00:41 - exponent two now to any of you physics
00:44 - people this might look similar to a
00:45 - physics equation and that's because it
00:48 - is what this does is tells us based on
00:51 - our current Birds velocity how much
00:53 - we're moving up or how much we're moving
00:54 - down now self dot tick count is actually
00:56 - going to represent how many what he
01:00 - called like time like how many seconds
01:02 - we've been moving for so that's kind of
01:04 - why we use tick camp so every time that
01:06 - we change our direction or we apply a
01:08 - velocity of the birds we either move up
01:10 - or we've kind of stopped moving up this
01:12 - tick count is gonna be going up up up up
01:14 - up and then based on what that tick
01:17 - count is we'll get you know either
01:18 - removing up where we've reached the top
01:20 - of our jump and now we're moving down so
01:23 - what happens essentially you can think
01:24 - of it as as soon as we jump we reset
01:26 - tick count to zero we set the height of
01:29 - our bird to be self dot Y and we set our
01:31 - velocity to be negative ten point five
01:32 - so when tick count equals one what
01:34 - happens is we say negative ten point
01:36 - five times one so we have negative ten
01:39 - point five on this side so let's write
01:40 - this down here negative ten point five
01:42 - then we add that to one point five times
01:45 - self-thought tick count to the exponent
01:47 - two which ends up just evaluating to one
01:49 - because one tick count is one well 1 to
01:52 - the exponent 2 is 1 times 1.5 suruc
01:54 - which is one point five so that means
01:57 - that we're moving a total upwards
01:58 - velocity of negative nine so on this
02:03 - current frame we're moving nine pixels
02:05 - upwards then the next frame will be
02:07 - moving less pixels upward so like seven
02:09 - then five then three so on until
02:13 - eventually we get to Z and then we go
02:14 - down and we start moving positive again
02:16 - and that results in kind of an arc for
02:18 - our bird as it does its jump anyways I
02:22 - hope that that's kind of as simple as I
02:23 - can explain that so now what I'm gonna
02:25 - do is just kind of failsafe this and
02:27 - make sure that we don't have a velocity
02:29 - moving way too far up or way too far
02:32 - down and this is where what's called a
02:33 - terminal velocity so I'm gonna say if D
02:37 - is greater than or equal to 16 so if
02:39 - we're moving down more than 16 pixels or
02:42 - equal to 16 pixels let's just set this
02:45 - to be 16 pixels so that we don't stop we
02:48 - don't move down too fast we reach a
02:50 - point where we don't accelerate anymore
02:52 - so to do this I'm gonna say D equals D
02:55 - over the ABS of D times 16 so this
03:01 - essentially means whatever way that
03:03 - we're moving just actually I don't need
03:06 - to do this ABS I don't think I'm going
03:07 - to just do equals D
03:10 - divided by D times 16 which means I can
03:13 - actually just do 16 so essentially if
03:16 - we're moving down more than 16 just move
03:17 - down 16 all right so now we're gonna say
03:20 - if that's not happening let's do another
03:22 - if statement and we'll say if D is less
03:25 - than 0 what we'll do is say D minus
03:28 - equals 2 now what this is gonna do is
03:30 - say you know if we're moving upwards
03:32 - let's just move up a little bit more and
03:34 - this just kind of fine-tuned our
03:36 - movement a little bit you can mess with
03:37 - this number if you want the jump to be
03:39 - higher or lower but this is what a
03:41 - number I've come up with that kind of
03:42 - makes it jump nicely alright so now what
03:44 - we're gonna do is actually change our Y
03:46 - position based on this displacement so
03:48 - I'm gonna say self-thought y equals in
03:50 - this case self-thought y
03:52 - plus d so we'll just add whatever we
03:56 - calculated here to our current Y
03:58 - position so that way you know we'll move
03:59 - slowly up or slowly down and now we need
04:02 - to worry about actually tilting the bird
04:04 - so this is the reason we do this inside
04:07 - of move is because based on if we're
04:09 - moving up or down that's how we're gonna
04:10 - figure out whether we're tilting up or
04:12 - we're tilting down so I'm gonna start by
04:14 - saying if D is less than 0 or
04:17 - self-thought Y is less than self-thought
04:21 - height plus 50 now in this case what
04:24 - we're gonna do is we're going to tilt
04:25 - the bird upwards and what I'm checking
04:27 - here is saying if D is less than 0 which
04:29 - means we're moving upwards or
04:30 - self-thought wise less than self dot
04:32 - height plus 50 which essentially means
04:34 - that every time we jump we keep track of
04:36 - where we jumped from so let's actually
04:38 - do a quick picture here so let's say we
04:41 - jump from here we're gonna check if
04:42 - we're our bird position is currently
04:44 - above this position if it is that means
04:47 - we're still moving upwards so don't
04:50 - start falling down yet even if we're on
04:52 - this downward curve still make it look
04:54 - like we're kind of upwards a little bit
04:55 - and then as soon as we get a little bit
04:57 - below this point then we can start
04:59 - tilting the bird downwards that's kind
05:01 - of what that means essentially so we
05:04 - check this and if this happens will we
05:06 - say just say if self dot tilt is less
05:10 - than self-thought max rotation which is
05:13 - that number that we have up here just
05:15 - making sure we don't tilt the bird you
05:16 - know completely backwards or crazy
05:18 - direction then we'll say self dot tilt
05:21 - equals self thought max rotation so
05:24 - rather than like moving it up slowly
05:26 - because the max rotation is only 25
05:27 - we'll just immediately set the rotation
05:29 - of the bird to be 25 degrees all right
05:32 - next
05:33 - so if that's not true if we're not
05:36 - moving upwards and we don't want to tilt
05:38 - the bird upwards let's tilt the bird
05:39 - downwards now let's do a little bit
05:41 - different but it's not that much
05:42 - different we'll say if self thought tilt
05:44 - is greater than negative 90 what we'll
05:48 - do is say self thought tilt minus equals
05:51 - self dot rotation velocity which is just
05:53 - how much we're gonna be rotating the
05:55 - bird downwards now what this allows us
05:57 - to do is rotate the flappy bird
05:58 - completely 90 degrees so as it starts
06:01 - falling downwards faster and faster it
06:03 - looks like it's kind of nose-diving to
06:05 - the ground so that's what you don't use
06:07 - the max rotation because when we go up
06:09 - we don't want to tilt completely up we
06:11 - just want to tilt slightly when we go
06:12 - down we want to tilt all the way down to
06:14 - 90 degrees which is what we do here all
06:17 - right so now that we've done that we've
06:18 - actually finished the move method the
06:20 - jump method and the anit and the last
06:22 - one to do here is draw well actually
06:25 - that lied there's one more but it's not
06:26 - that big starting this we're going to
06:28 - say define self or what am I saying
06:31 - define draw self and win and win is
06:33 - simply going to represent the window
06:35 - we're drawing the bird on 2 now this
06:37 - one's a little bit confusing as well I
06:38 - apologize but we need to get through it
06:41 - so to animate our bird we need to keep
06:43 - track of how many ticks we've shown a
06:45 - current image 4 and when I say tick I
06:47 - just mean how many times is that while
06:49 - loop or our main game loop run and how
06:51 - many times have we already shown one
06:53 - image so I'm gonna keep track of that
06:54 - with self dot image count now what I'm
06:56 - gonna do is create a few if statements
06:58 - and it's probably not an efficient way
06:59 - to do it but it's the way I'm gonna do
07:01 - it anyways I'm gonna say if self dot IMG
07:04 - underscore count is less than self dot
07:07 - animation time then what I'm gonna do is
07:09 - say self dot IMG equals self IMG's zero
07:13 - again I repeat this is not the most
07:15 - efficient way to do this but it's the
07:17 - way that I've come up with all right so
07:19 - now what I'm going to do say L if self
07:21 - dot image count less than self dot
07:23 - animation time x not not 5 by 2 then I'm
07:28 - gonna say self dot IMG equals self dot I
07:32 - am
07:33 - ds1 now we're gonna do the same thing so
07:37 - I guess I should probably just copy this
07:38 - and can you guess what we're gonna
07:40 - change this to we're gonna change this
07:42 - to a 3 we're gonna change this to a 2
07:44 - we're gonna add I guess two more elif's
07:47 - so we're gonna do one more here where
07:48 - Isis to be a 4 and I change this to be a
07:52 - 1 like this and then what I'm gonna do
07:54 - is do one more Elif and this one is now
07:57 - gonna say 4 sorry 4 plus 1 and instead
08:01 - of having it less than we're gonna have
08:02 - two equal signs and then we're gonna
08:05 - change this image to be zero we're also
08:07 - gonna reset the image counts were going
08:09 - to say image count equals zero all right
08:13 - so let's kind of go through what I
08:14 - actually just did here so what I'm doing
08:16 - is I'm checking what image we should
08:19 - show based on the current image count so
08:21 - if the image count is less than 5 which
08:23 - is our self dot animation time then what
08:26 - we're gonna do is we're going to display
08:27 - the first flappy bird image now if we
08:30 - get to a point where the animation count
08:32 - is larger than this we're gonna check
08:33 - the next Elif statement which says if
08:35 - the animation time or the I guess the
08:37 - self-thought image count is less than 10
08:39 - we're gonna show the second flappy bird
08:42 - image which is this so we're gonna go
08:44 - from this to this one where the bird the
08:47 - wings are now level alright so next
08:49 - we're gonna say okay if we surpass that
08:51 - then we're gonna check if we're less
08:52 - than 15 for less than 15 we're gonna
08:55 - show the last image then we're gonna
08:57 - show the first image again and we're
08:59 - gonna show the what am I saying we're
09:02 - gonna show the second image again then
09:03 - we're gonna show the first image again
09:04 - and reset the image counter so this way
09:06 - we get the wings flapping up and then
09:08 - flapping down because if we just reset
09:10 - after the last image here then what we
09:13 - would end up having is the bird flaps up
09:15 - and then it instantly goes back to its
09:17 - starting position and it kind of looks
09:19 - like it skips a frame all right now the
09:20 - last thing to do here is just check one
09:22 - last condition so the thing is when our
09:24 - bird is tilted almost 90 degrees so
09:27 - going downwards we actually don't want
09:28 - it to be flapping its wings and changing
09:31 - the image so what we're gonna do is just
09:33 - do a quick check here and say if self
09:34 - thought tilt is less than or equal to
09:37 - negative 80 what we're gonna do is say
09:40 - self dot IMG equals self dot IMG is one
09:43 - which just means we're gonna go to the
09:45 - image where its wings are kind of level
09:47 - and then what we're gonna do is just
09:49 - display that image instead so that it
09:52 - looks like it just knows diving down
09:53 - it's not like flapping its wings going
09:55 - downwards because that doesn't really
09:56 - make any sense and it kind of looks kind
09:57 - of weird so then after that I'm gonna
09:59 - say self the IMG count equals self dot
10:02 - animation time multiplied by two so this
10:05 - way when we jump back up it doesn't kind
10:08 - of like skip a frame it starts at you
10:10 - know what it should be to show this
10:12 - image which is an animation count of 10
10:14 - all right anyways hopefully you guys
10:17 - understood how to do that now the last
10:19 - thing to actually draw this image is we
10:21 - need to rotate it around the center eye
10:24 - based on its current tilt so all these
10:27 - birds and we've already modified this it
10:29 - has a tilt so how do we actually tilt
10:31 - the image that we have because the image
10:33 - we have if I can find it from the
10:35 - desktop they're all level right like
10:38 - they're all level with the screen so how
10:39 - do I make it go up and go down well this
10:41 - is kind of complicated but I've written
10:44 - wrote I guess a
10:46 - function that does this for us now I
10:48 - want to clarify I actually found this on
10:50 - Stack Overflow unfortunately I can't
10:52 - remember where I found it but I'm just
10:53 - gonna type it out and kind of copy it to
10:56 - show you this is what how you actually
10:57 - rotate an image around its end and Poggi
10:59 - so I must say rotated image equals PI
11:02 - game dot
11:04 - transform dot
11:06 - rotates
11:08 - like that if I could spell that
11:10 - correctly and then I'm gonna take an
11:11 - image and an angle now the image I'm
11:14 - gonna do is self dot I am I guess it's
11:16 - just self dot image because that's what
11:18 - we're keeping track of here and then the
11:20 - angle is gonna be self dot tilt now what
11:23 - this will do is rotate the image for us
11:25 - but we need to kind of move it so it's
11:27 - actually in the center because if we do
11:28 - this it rotates the image around the top
11:30 - left hand corner and it just kind of
11:32 - makes our bird look kind of weird so to
11:34 - fix this we're gonna say new underscore
11:36 - rectangle equals in this case rotated
11:40 - image dot gets underscore X and we're
11:43 - gonna say Center equals image dot get
11:48 - rekt now image is actually gonna be self
11:50 - dot image my apologies and when we do
11:53 - get rekt we're gonna do this I'm gonna
11:56 - save top underscore left or not top
11:59 - underscore left just top left equals top
12:02 - left and then we're gonna say dot Center
12:07 - if I could find this year all right so
12:11 - that should be about right so actually
12:15 - my apologies here we don't need to type
12:16 - top left again what we do here is
12:17 - actually define the top left of our
12:19 - image which is gonna be self thought X
12:21 - self dot y and then we put this dot
12:23 - Center now again I honestly don't really
12:25 - know how this works I just copied it
12:26 - from Stack Overflow but I do know that
12:28 - it rotates the image around the center
12:30 - which is what we need to do I'll see if
12:32 - I can find that link and put it in the
12:33 - description anyways now since in our
12:35 - draw method we have the window that
12:37 - we're gonna be drawing this on - I'm
12:39 - gonna say win da blitz and then I'm
12:41 - going to blitt the rotated image
12:44 - around a certain position so I'm gonna
12:47 - say rotated image and then I'm gonna put
12:49 - it on new rect dot top left now I know
12:54 - it's kind of weird and you probably
12:55 - haven't seen this in PI game but this is
12:56 - just how we rotate image again I don't
12:58 - want to go through all of that all right
13:00 - the last method we need is something
13:02 - called get underscore mask and that's
13:04 - what we're gonna use when we get
13:05 - collision for du collision for our
13:07 - objects this one's pretty
13:08 - straightforward all we're gonna do is if
13:11 - I can actually find it because I'm just
13:12 - look my other screen here is we want to
13:14 - return a value that is high-gain dot
13:17 - mask dot from underscore image are not
13:21 - image surface and then the surface is
13:24 - gonna be self dot IMG we'll talk about
13:26 - masks later but we just need to
13:28 - implement that all right so I was gonna
13:29 - program the rest of the classes first
13:30 - but I figured since we just did all this
13:32 - work on this bird class let's actually
13:34 - just start getting into drawing some of
13:36 - this stuff here so we can see how this
13:37 - bird class actually works while it's
13:39 - still fresh in our minds so what I'm
13:40 - gonna do is start by creating a function
13:42 - called main this main function is gonna
13:44 - run the main loop of our game I'm also
13:47 - going to create another function called
13:49 - draw underscore window and this is
13:51 - what's gonna well draw the window for
13:53 - our game so it's gonna take a bird and
13:55 - actually we'll do window first it's
13:58 - gonna take a window and bird now what
14:00 - I'm gonna do in here is just really
14:01 - quickly draw the background image and
14:03 - then draw the bird on top of it just so
14:06 - we can see how the bird actually works
14:08 - when it's moving which what I'm gonna
14:09 - say is do win dot blitz and if you don't
14:12 - know what blit does it just means draw
14:14 - so it's like draw whatever you put in
14:16 - here on the window so in this case I'm
14:19 - gonna put our background image which is
14:21 - BG underscore image comma and then I'm
14:24 - just gonna put 0 0 to draw it 0 0 on our
14:26 - screen so let's do that so this is the
14:29 - top left position of the image where
14:31 - you're drawing anyways ok now I'm gonna
14:33 - say PI game dot display dot update which
14:37 - simply updates the display and kind of
14:38 - refreshes it and then I'm gonna draw the
14:40 - bird so I say win not win double it we
14:43 - already have a method for this it's
14:44 - called bird draw and we'll pass it that
14:46 - window and now when we do that we will
14:48 - call this draw method it'll handle all
14:50 - the animation all the tilting for us and
14:53 - draw the bird okay so now inside of our
14:56 - main loop here let's create a bird
14:57 - object let's just call it bird for
15:00 - simplicity here and we'll say bird bird
15:01 - we'll give it a starting position of I
15:03 - don't know 200 200 just so that we can
15:05 - see it and we'll update this later now
15:07 - what I'm gonna do really basically in
15:09 - here is create a while loop and just set
15:11 - up the main game loop for our PI game
15:13 - window so in here I'm gonna create
15:15 - another variable called run equals true
15:17 - I'm gonna say well run and then that way
15:19 - we can make run equal false later and
15:21 - the game if we need to now I'm gonna set
15:23 - up the basic PI game of event loop which
15:25 - is for event
15:27 - in pygame event done yet it's just gonna
15:31 - keep track of whenever something happens
15:32 - like whenever the user clicks the mouse
15:34 - or something we'll run this for boot for
15:37 - loop loop through all the events and
15:38 - then we can do something with that so
15:39 - the event we want to check for here is
15:41 - if event dot type
15:43 - equals equals pry game don't quit in all
15:46 - capitals then we're going to do is PI
15:49 - game quit now what this does is quit
15:52 - spiking so if we click on the red X in
15:55 - the top right hand corner of our PI game
15:56 - window we're gonna quit now actually I'm
15:59 - just gonna modify this a little bit to
16:00 - make this run equals false and I'm just
16:02 - gonna quit outside the loop so you know
16:04 - if we ever exit this loop we quit PI
16:06 - game and then consequently we can
16:08 - actually quit the program as well all
16:10 - right so let me just call main here and
16:12 - inside this while loop let's add one
16:14 - more line which calls our draw window
16:16 - function and now we'll pass that window
16:19 - as well as bird and if we call this we
16:23 - should be able to see our bird moving or
16:25 - actually will see our bird and then
16:26 - we'll be able to see it moving later so
16:28 - let's look at this now if I run and hit
16:29 - control B and subline text what is the
16:32 - issue video system not initialized oh I
16:35 - need to create a PI game window my bad
16:36 - let's do win equals PI game dot what do
16:41 - you call it display dot set underscore
16:44 - mode and then for the coordinates we're
16:46 - gonna go win underscore width win
16:48 - underscore height my apologies about
16:50 - that alright so now that we do that you
16:52 - can see we have this flappy bird and he
16:54 - is flapping his wings now this image is
16:56 - a little bit short for our screen which
16:58 - I mean guess that means we need to make
17:00 - the width a little bit shorter so let's
17:02 - make this width 500 and see if that
17:04 - makes it a little bit better and there
17:06 - we go so we have this bird he's flapping
17:08 - his wings but obviously he's not moving
17:10 - it so if we want to move him what we
17:11 - need to do is we need to call move on
17:14 - our bird so what I'm gonna say is bird
17:17 - dot move so this is what we're gonna
17:20 - call every frame so essentially every
17:22 - time our while loop ticks our birds
17:24 - gonna move so let's run this and see how
17:25 - it looks now and you can see our bird
17:27 - just falls down out of nowhere almost
17:29 - immediately and he falls very quickly so
17:32 - how can we fix this well we need to
17:34 - implement something called a clock so
17:36 - that we can actually set the frame rate
17:37 - or like the tick rate so how fast this
17:39 - while loops running to be at a
17:41 - consistent rate so it's not going to
17:42 - depend on how fast your computer is how
17:44 - fast it runs we're actually gonna set it
17:46 - so I'm gonna make a clock object this is
17:48 - called clock equals PI game time dot
17:52 - clock and now what I'm gonna do is every
17:54 - time I run this while loop I'm gonna
17:56 - call clock tick 30 which stands for
17:59 - we're gonna do at most 30 ticks every
18:02 - second so now if I run this and we do
18:04 - control B you can see our bird falls a
18:07 - much slower and he looks a lot better
18:09 - and you can even notice that he actually
18:10 - tilts down as he starts falling
18:12 - downwards so we know that we've done
18:14 - everything correctly for our bird class
18:16 - so here's we'll leave this in here for
18:18 - now I'm just going to comment out bird
18:20 - move and that's all we need to do to
18:22 - test our bird so next let's start coding
18:25 - our pipe class

Cleaned transcript:

we say self dot tic underscore county plus equals one which means you know a tic happened a frame went by and now we've moved so we'll keep track of X how many times we move since the last jump all right the next thing we need to calculate is something called displacement and this is gonna be how many pixels were moving up or down this frame and this will be you know what we end up actually moving when we change the Y position of the bird so we're gonna say D equals and in this case we're gonna say self dot Val which is gonna be our velocity multiplied by self dot tic underscore count plus 1.5 times self dot tic underscore count to the exponent two now to any of you physics people this might look similar to a physics equation and that's because it is what this does is tells us based on our current Birds velocity how much we're moving up or how much we're moving down now self dot tick count is actually going to represent how many what he called like time like how many seconds we've been moving for so that's kind of why we use tick camp so every time that we change our direction or we apply a velocity of the birds we either move up or we've kind of stopped moving up this tick count is gonna be going up up up up up and then based on what that tick count is we'll get you know either removing up where we've reached the top of our jump and now we're moving down so what happens essentially you can think of it as as soon as we jump we reset tick count to zero we set the height of our bird to be self dot Y and we set our velocity to be negative ten point five so when tick count equals one what happens is we say negative ten point five times one so we have negative ten point five on this side so let's write this down here negative ten point five then we add that to one point five times selfthought tick count to the exponent two which ends up just evaluating to one because one tick count is one well 1 to the exponent 2 is 1 times 1.5 suruc which is one point five so that means that we're moving a total upwards velocity of negative nine so on this current frame we're moving nine pixels upwards then the next frame will be moving less pixels upward so like seven then five then three so on until eventually we get to Z and then we go down and we start moving positive again and that results in kind of an arc for our bird as it does its jump anyways I hope that that's kind of as simple as I can explain that so now what I'm gonna do is just kind of failsafe this and make sure that we don't have a velocity moving way too far up or way too far down and this is where what's called a terminal velocity so I'm gonna say if D is greater than or equal to 16 so if we're moving down more than 16 pixels or equal to 16 pixels let's just set this to be 16 pixels so that we don't stop we don't move down too fast we reach a point where we don't accelerate anymore so to do this I'm gonna say D equals D over the ABS of D times 16 so this essentially means whatever way that we're moving just actually I don't need to do this ABS I don't think I'm going to just do equals D divided by D times 16 which means I can actually just do 16 so essentially if we're moving down more than 16 just move down 16 all right so now we're gonna say if that's not happening let's do another if statement and we'll say if D is less than 0 what we'll do is say D minus equals 2 now what this is gonna do is say you know if we're moving upwards let's just move up a little bit more and this just kind of finetuned our movement a little bit you can mess with this number if you want the jump to be higher or lower but this is what a number I've come up with that kind of makes it jump nicely alright so now what we're gonna do is actually change our Y position based on this displacement so I'm gonna say selfthought y equals in this case selfthought y plus d so we'll just add whatever we calculated here to our current Y position so that way you know we'll move slowly up or slowly down and now we need to worry about actually tilting the bird so this is the reason we do this inside of move is because based on if we're moving up or down that's how we're gonna figure out whether we're tilting up or we're tilting down so I'm gonna start by saying if D is less than 0 or selfthought Y is less than selfthought height plus 50 now in this case what we're gonna do is we're going to tilt the bird upwards and what I'm checking here is saying if D is less than 0 which means we're moving upwards or selfthought wise less than self dot height plus 50 which essentially means that every time we jump we keep track of where we jumped from so let's actually do a quick picture here so let's say we jump from here we're gonna check if we're our bird position is currently above this position if it is that means we're still moving upwards so don't start falling down yet even if we're on this downward curve still make it look like we're kind of upwards a little bit and then as soon as we get a little bit below this point then we can start tilting the bird downwards that's kind of what that means essentially so we check this and if this happens will we say just say if self dot tilt is less than selfthought max rotation which is that number that we have up here just making sure we don't tilt the bird you know completely backwards or crazy direction then we'll say self dot tilt equals self thought max rotation so rather than like moving it up slowly because the max rotation is only 25 we'll just immediately set the rotation of the bird to be 25 degrees all right next so if that's not true if we're not moving upwards and we don't want to tilt the bird upwards let's tilt the bird downwards now let's do a little bit different but it's not that much different we'll say if self thought tilt is greater than negative 90 what we'll do is say self thought tilt minus equals self dot rotation velocity which is just how much we're gonna be rotating the bird downwards now what this allows us to do is rotate the flappy bird completely 90 degrees so as it starts falling downwards faster and faster it looks like it's kind of nosediving to the ground so that's what you don't use the max rotation because when we go up we don't want to tilt completely up we just want to tilt slightly when we go down we want to tilt all the way down to 90 degrees which is what we do here all right so now that we've done that we've actually finished the move method the jump method and the anit and the last one to do here is draw well actually that lied there's one more but it's not that big starting this we're going to say define self or what am I saying define draw self and win and win is simply going to represent the window we're drawing the bird on 2 now this one's a little bit confusing as well I apologize but we need to get through it so to animate our bird we need to keep track of how many ticks we've shown a current image 4 and when I say tick I just mean how many times is that while loop or our main game loop run and how many times have we already shown one image so I'm gonna keep track of that with self dot image count now what I'm gonna do is create a few if statements and it's probably not an efficient way to do it but it's the way I'm gonna do it anyways I'm gonna say if self dot IMG underscore count is less than self dot animation time then what I'm gonna do is say self dot IMG equals self IMG's zero again I repeat this is not the most efficient way to do this but it's the way that I've come up with all right so now what I'm going to do say L if self dot image count less than self dot animation time x not not 5 by 2 then I'm gonna say self dot IMG equals self dot I am ds1 now we're gonna do the same thing so I guess I should probably just copy this and can you guess what we're gonna change this to we're gonna change this to a 3 we're gonna change this to a 2 we're gonna add I guess two more elif's so we're gonna do one more here where Isis to be a 4 and I change this to be a 1 like this and then what I'm gonna do is do one more Elif and this one is now gonna say 4 sorry 4 plus 1 and instead of having it less than we're gonna have two equal signs and then we're gonna change this image to be zero we're also gonna reset the image counts were going to say image count equals zero all right so let's kind of go through what I actually just did here so what I'm doing is I'm checking what image we should show based on the current image count so if the image count is less than 5 which is our self dot animation time then what we're gonna do is we're going to display the first flappy bird image now if we get to a point where the animation count is larger than this we're gonna check the next Elif statement which says if the animation time or the I guess the selfthought image count is less than 10 we're gonna show the second flappy bird image which is this so we're gonna go from this to this one where the bird the wings are now level alright so next we're gonna say okay if we surpass that then we're gonna check if we're less than 15 for less than 15 we're gonna show the last image then we're gonna show the first image again and we're gonna show the what am I saying we're gonna show the second image again then we're gonna show the first image again and reset the image counter so this way we get the wings flapping up and then flapping down because if we just reset after the last image here then what we would end up having is the bird flaps up and then it instantly goes back to its starting position and it kind of looks like it skips a frame all right now the last thing to do here is just check one last condition so the thing is when our bird is tilted almost 90 degrees so going downwards we actually don't want it to be flapping its wings and changing the image so what we're gonna do is just do a quick check here and say if self thought tilt is less than or equal to negative 80 what we're gonna do is say self dot IMG equals self dot IMG is one which just means we're gonna go to the image where its wings are kind of level and then what we're gonna do is just display that image instead so that it looks like it just knows diving down it's not like flapping its wings going downwards because that doesn't really make any sense and it kind of looks kind of weird so then after that I'm gonna say self the IMG count equals self dot animation time multiplied by two so this way when we jump back up it doesn't kind of like skip a frame it starts at you know what it should be to show this image which is an animation count of 10 all right anyways hopefully you guys understood how to do that now the last thing to actually draw this image is we need to rotate it around the center eye based on its current tilt so all these birds and we've already modified this it has a tilt so how do we actually tilt the image that we have because the image we have if I can find it from the desktop they're all level right like they're all level with the screen so how do I make it go up and go down well this is kind of complicated but I've written wrote I guess a function that does this for us now I want to clarify I actually found this on Stack Overflow unfortunately I can't remember where I found it but I'm just gonna type it out and kind of copy it to show you this is what how you actually rotate an image around its end and Poggi so I must say rotated image equals PI game dot transform dot rotates like that if I could spell that correctly and then I'm gonna take an image and an angle now the image I'm gonna do is self dot I am I guess it's just self dot image because that's what we're keeping track of here and then the angle is gonna be self dot tilt now what this will do is rotate the image for us but we need to kind of move it so it's actually in the center because if we do this it rotates the image around the top left hand corner and it just kind of makes our bird look kind of weird so to fix this we're gonna say new underscore rectangle equals in this case rotated image dot gets underscore X and we're gonna say Center equals image dot get rekt now image is actually gonna be self dot image my apologies and when we do get rekt we're gonna do this I'm gonna save top underscore left or not top underscore left just top left equals top left and then we're gonna say dot Center if I could find this year all right so that should be about right so actually my apologies here we don't need to type top left again what we do here is actually define the top left of our image which is gonna be self thought X self dot y and then we put this dot Center now again I honestly don't really know how this works I just copied it from Stack Overflow but I do know that it rotates the image around the center which is what we need to do I'll see if I can find that link and put it in the description anyways now since in our draw method we have the window that we're gonna be drawing this on I'm gonna say win da blitz and then I'm going to blitt the rotated image around a certain position so I'm gonna say rotated image and then I'm gonna put it on new rect dot top left now I know it's kind of weird and you probably haven't seen this in PI game but this is just how we rotate image again I don't want to go through all of that all right the last method we need is something called get underscore mask and that's what we're gonna use when we get collision for du collision for our objects this one's pretty straightforward all we're gonna do is if I can actually find it because I'm just look my other screen here is we want to return a value that is highgain dot mask dot from underscore image are not image surface and then the surface is gonna be self dot IMG we'll talk about masks later but we just need to implement that all right so I was gonna program the rest of the classes first but I figured since we just did all this work on this bird class let's actually just start getting into drawing some of this stuff here so we can see how this bird class actually works while it's still fresh in our minds so what I'm gonna do is start by creating a function called main this main function is gonna run the main loop of our game I'm also going to create another function called draw underscore window and this is what's gonna well draw the window for our game so it's gonna take a bird and actually we'll do window first it's gonna take a window and bird now what I'm gonna do in here is just really quickly draw the background image and then draw the bird on top of it just so we can see how the bird actually works when it's moving which what I'm gonna say is do win dot blitz and if you don't know what blit does it just means draw so it's like draw whatever you put in here on the window so in this case I'm gonna put our background image which is BG underscore image comma and then I'm just gonna put 0 0 to draw it 0 0 on our screen so let's do that so this is the top left position of the image where you're drawing anyways ok now I'm gonna say PI game dot display dot update which simply updates the display and kind of refreshes it and then I'm gonna draw the bird so I say win not win double it we already have a method for this it's called bird draw and we'll pass it that window and now when we do that we will call this draw method it'll handle all the animation all the tilting for us and draw the bird okay so now inside of our main loop here let's create a bird object let's just call it bird for simplicity here and we'll say bird bird we'll give it a starting position of I don't know 200 200 just so that we can see it and we'll update this later now what I'm gonna do really basically in here is create a while loop and just set up the main game loop for our PI game window so in here I'm gonna create another variable called run equals true I'm gonna say well run and then that way we can make run equal false later and the game if we need to now I'm gonna set up the basic PI game of event loop which is for event in pygame event done yet it's just gonna keep track of whenever something happens like whenever the user clicks the mouse or something we'll run this for boot for loop loop through all the events and then we can do something with that so the event we want to check for here is if event dot type equals equals pry game don't quit in all capitals then we're going to do is PI game quit now what this does is quit spiking so if we click on the red X in the top right hand corner of our PI game window we're gonna quit now actually I'm just gonna modify this a little bit to make this run equals false and I'm just gonna quit outside the loop so you know if we ever exit this loop we quit PI game and then consequently we can actually quit the program as well all right so let me just call main here and inside this while loop let's add one more line which calls our draw window function and now we'll pass that window as well as bird and if we call this we should be able to see our bird moving or actually will see our bird and then we'll be able to see it moving later so let's look at this now if I run and hit control B and subline text what is the issue video system not initialized oh I need to create a PI game window my bad let's do win equals PI game dot what do you call it display dot set underscore mode and then for the coordinates we're gonna go win underscore width win underscore height my apologies about that alright so now that we do that you can see we have this flappy bird and he is flapping his wings now this image is a little bit short for our screen which I mean guess that means we need to make the width a little bit shorter so let's make this width 500 and see if that makes it a little bit better and there we go so we have this bird he's flapping his wings but obviously he's not moving it so if we want to move him what we need to do is we need to call move on our bird so what I'm gonna say is bird dot move so this is what we're gonna call every frame so essentially every time our while loop ticks our birds gonna move so let's run this and see how it looks now and you can see our bird just falls down out of nowhere almost immediately and he falls very quickly so how can we fix this well we need to implement something called a clock so that we can actually set the frame rate or like the tick rate so how fast this while loops running to be at a consistent rate so it's not going to depend on how fast your computer is how fast it runs we're actually gonna set it so I'm gonna make a clock object this is called clock equals PI game time dot clock and now what I'm gonna do is every time I run this while loop I'm gonna call clock tick 30 which stands for we're gonna do at most 30 ticks every second so now if I run this and we do control B you can see our bird falls a much slower and he looks a lot better and you can even notice that he actually tilts down as he starts falling downwards so we know that we've done everything correctly for our bird class so here's we'll leave this in here for now I'm just going to comment out bird move and that's all we need to do to test our bird so next let's start coding our pipe class
