With timestamps:

00:02 - [Music]
00:06 - hello everyone and welcome back to the
00:09 - YouTube video so in today's video what
00:12 - I'm gonna be doing is exploring and
00:13 - walking through a real Microsoft code
00:16 - base
00:16 - now the reason I'm able to do this is
00:18 - because I'm working at Microsoft is a
00:19 - software engineer intern and I'm working
00:22 - on the Python extension team for Visual
00:25 - Studio code so if you don't know within
00:27 - Visual Studio code one of the more
00:29 - popular editors out there right now
00:30 - there's all these different extensions
00:32 - and what these extensions do is just
00:34 - bring different functionality different
00:35 - features syntax highlighting whatever
00:38 - there's a ton of different things that
00:39 - come with these extensions one of the
00:41 - more popular extensions is the Python
00:43 - extension which you can see has been
00:44 - downloaded by just over 21 million
00:46 - people and is supported and maintained
00:48 - by Microsoft now this is an open-source
00:51 - extension which means pretty much all
00:53 - the code that you are looking at or that
00:55 - I'm gonna be showing in this video
00:56 - actually all of it is available publicly
00:58 - online from this repository which I'll
01:00 - leave a link to in the description so
01:03 - here you can see all of the code for the
01:05 - extension that's publicly available
01:07 - because it's open source and this is
01:09 - what I work on every day I work on an
01:10 - open source project which means I can
01:12 - actually show you guys what I've done
01:13 - which i think is really cool so with
01:16 - that being said I will mention that this
01:18 - entire code base is pretty much written
01:19 - in typescript there is some react as
01:22 - well for the UI related features and I
01:25 - mean I'll be talking about that as we go
01:26 - through but this is quite complicated
01:28 - code it's not something that I imagine
01:30 - you guys will completely 100% understand
01:33 - but I am still gonna explain it and walk
01:35 - through some different features and
01:36 - since the extension is so massive I will
01:38 - kind of talk about you know some
01:40 - different random areas and try to give
01:41 - you a taste to kind of everything
01:42 - without going far too in-depth on one
01:45 - specific area all right so we're pretty
01:48 - much ready to get going
01:50 - the last thing I'll say is actually
01:52 - right now there's a really awesome deal
01:53 - going on on a bunch of pre premium
01:55 - programming courses if you guys are
01:57 - interested in potentially purchasing a
01:59 - whole whack of premium programming
02:01 - courses there's actually 33 of them that
02:03 - we have bundled together right now I've
02:05 - teamed up with 26 other content creators
02:08 - authors people that are well respected
02:10 - kind of in the industry and as teachers
02:12 - and they've
02:13 - taken all of their premium programming
02:15 - courses and I have a premium programming
02:17 - course as well and we've bundled them
02:19 - all together this is usually like
02:21 - thousands of dollars worth of courses if
02:23 - you combine all the value of all those
02:25 - courses together and we're selling it
02:26 - for a pretty good discount actually is
02:29 - about 94 percent discount I don't want
02:31 - to like will you with the big numbers
02:33 - you can check out all this stuff in the
02:34 - description down below but I just
02:36 - figured I'd make you guys aware and this
02:37 - is a great way if you want to support me
02:39 - or support some of the other creators to
02:41 - get a really good deal on a ton of
02:42 - different premium programming courses
02:44 - this is only gonna be available from
02:46 - June 22nd to June 26th and I believe
02:49 - there is an early bird discount if you
02:50 - purchase it on the first or second day
02:52 - anyways I don't want to talk about it
02:54 - too much there's a link in the
02:55 - description and feel free to check that
02:56 - out and just see if it even is of
02:58 - interest to you
02:59 - alright so let's actually start
03:00 - exploring this codebase walking through
03:02 - some different areas and yeah just kind
03:05 - of getting into it now I will start by
03:07 - saying that this codebase is massive
03:08 - there's a huge codebase I wouldn't
03:10 - anticipate or expect anyone to be able
03:12 - to understand it even just in a few
03:14 - months of actually using it because
03:15 - there's so much content in here and
03:17 - you'll see myself there's some areas
03:19 - here that I just don't actually know
03:21 - what they do or I haven't been exposed
03:22 - to them yet so I have a decent
03:24 - understanding but I'm gonna give us kind
03:25 - of like a high-level overview of the
03:27 - structure of this codebase then we'll
03:29 - get into some code that I've written
03:30 - myself that I do truly really understand
03:33 - and I'll talk about how that kind of
03:34 - works and that should hopefully give you
03:36 - a good idea of how we've done things
03:38 - inside of here and some of the design
03:40 - patterns and all that so the first thing
03:43 - that I'm gonna do here is just kind of
03:44 - show you the structure so you can see
03:46 - that there's a bunch of different
03:47 - folders here and a bunch of different
03:48 - random files now the core technology
03:51 - used in this code bases typescript so
03:53 - typescript is the main language and what
03:55 - happens is when we use this extension we
03:57 - compile that typescript code actually
03:59 - transpile it into JavaScript and then
04:01 - run that the reason we're using
04:02 - typescript from what I've heard is
04:04 - because it's way better to have a typed
04:07 - language when you're working on a
04:08 - project this large the reason for that
04:11 - is that I can just hover over things
04:13 - right and see exactly what type these
04:15 - items are and I can actually go and look
04:18 - at definitions of interfaces of classes
04:20 - I can click on for example like react
04:22 - thoughts CSS properties and go go to go
04:24 - to definition and I can actually see
04:26 - all of the stuff related to that so it's
04:29 - very powerful and it just makes
04:30 - developing and navigating a codebase way
04:33 - easier when you have strict typing and
04:35 - typescript is nice because it actually
04:37 - gives you the option to set typing or
04:39 - not so if you're in a situation where
04:41 - you don't want to have strict typing you
04:43 - can just not set a type for that
04:45 - variable or for that object or whatever
04:47 - it may be I mean it means you can save a
04:49 - little bit of time right but for example
04:51 - like four grid columns I can see what
04:53 - all of these different items are I can
04:55 - see if they're optional or not and it
04:57 - just makes it a lot easier when you're
04:59 - actually doing development now of course
05:01 - you may have noticed here that we're
05:03 - also using react so we use typescript
05:05 - mainly and then react as well to do all
05:07 - the UI related features we also use
05:10 - redux as a front-end state manager and
05:12 - also to handle communication between the
05:14 - extension and between IB actually you op
05:17 - so that leads me into the first thing
05:19 - that I wanted to say and I want to jump
05:21 - into this SRC folder so I'm not really
05:23 - going to talk about most of the other
05:24 - stuff here cuz it's not that important
05:26 - or interesting but SRC is where all of
05:29 - the source code for this project is
05:31 - inside of here we have five files and
05:34 - I'll briefly define what each of these
05:35 - are so client this is where most of the
05:39 - stuff happens client is where will be
05:41 - called the extension lives so because we
05:44 - have a user interface we need to have
05:46 - some kind of front-end back-end and a
05:47 - separation between them so we have the
05:49 - client which we call the extension which
05:52 - runs in a separate process and then we
05:54 - have the data science UI which is a user
05:57 - interface which runs again in a webview
05:59 - in a separate process so immediately we
06:03 - have two processes what that means for
06:06 - anyone that knows anything about multi
06:07 - processing or multi-threading is that we
06:10 - have to have a very robust communication
06:12 - system between these processes because
06:14 - when you have two separate processes you
06:17 - may have things like just sharing memory
06:19 - is not that easy being able to talk to
06:22 - one another I can't simply just use one
06:24 - of the classes from another process I
06:26 - need to actually send a message to that
06:29 - process have that message handled have a
06:31 - request sent maybe I send that with a
06:33 - payload some information some data and
06:35 - then have some response sent back so it
06:38 - gets very complicated very quick
06:40 - so those are the two main folders you
06:42 - have I pie widgets which is very
06:44 - specific to ipython widgets if you don't
06:47 - know what those are don't worry I'm not
06:48 - really gonna discuss them and then tests
06:50 - so inside of here is where we write all
06:53 - of our automated tests now we have a CLI
06:55 - on the github repository and what that
06:57 - does is make sure that every time you
06:59 - submit a new pull request so you make
07:01 - some kind of change to the repository it
07:03 - runs all of the tests that we've written
07:05 - here and make sure that they all pass so
07:08 - we have unit tests we have functional
07:09 - tests believe there's integration tests
07:11 - all different kinds of tests that test
07:13 - pretty well every feature that we have
07:15 - and everything that makes sense and you
07:18 - go for a pretty high code coverage you
07:20 - want to really test a good majority of
07:22 - the code that you have in the extension
07:24 - to make sure that when you make a change
07:26 - you don't break something and something
07:28 - some test fails essentially right this
07:30 - also means that we don't have to
07:31 - manually test anything every time that
07:34 - we go ahead and make it change we can
07:35 - just wait for that CLI on github to run
07:38 - and it will tell us hey you mess this up
07:40 - hey you need to change this and that
07:42 - whatever that's the point of test so
07:45 - anytime that we write some kind of new
07:48 - feature or we add or make a major change
07:50 - we write automated tests for that
07:52 - feature probably functional and unit
07:54 - tests maybe sometimes either/or depends
07:57 - on how big or what it is and within this
07:59 - we actually use two different testing
08:01 - frameworks one of which I believe is
08:03 - called TS mockito
08:05 - and then there's another one that is
08:07 - called something else was vs code test
08:09 - so I don't know what the other testing
08:12 - framework is forget the name of it but
08:15 - the main one I believe is TS mockito and
08:17 - that essentially allows you to mock
08:19 - objects I'm not really gonna go into all
08:22 - of that because that's kind of somewhat
08:23 - complicated but anyways that is the main
08:26 - idea behind kind of how this is all set
08:28 - up so I could of course go into clients
08:31 - and go into data science UI and show you
08:33 - all of the different features I'm not
08:35 - gonna do that what I will show you
08:36 - though is one area that I am familiar
08:38 - with in data science UI and kind of just
08:40 - talk a little bit about how that works
08:42 - and then I'll go over to the extension
08:45 - side and I'll talk about how we actually
08:47 - handle communication between these two
08:49 - processes and actually one of the new
08:51 - features that I've been adding so let's
08:53 - go into intro
08:54 - active common here you can notice that
08:56 - there's a bunch of different folders and
08:57 - these all represent different areas of
08:59 - the UI the way that this works is that
09:02 - we actually render what's called a
09:04 - webview so it literally is pretty much
09:06 - like kind of a mock HTML page or yeah
09:09 - like a mock browser inside of es code
09:12 - and that's where we render all of the
09:14 - react related components and all the UI
09:16 - related features so if I go here to
09:18 - variable Explorer this is something I'm
09:20 - quite familiar with because I've used it
09:22 - and I've been working on it we can see
09:24 - that this is react so if you look here
09:27 - we have a class it extends a react
09:29 - component it has a variable Explorer
09:31 - props and variable Explorer state now I
09:34 - don't really want to explain react to
09:36 - everyone but essentially there's two
09:37 - main areas or two main things in
09:39 - everything that we call a component now
09:42 - what a component is is essentially
09:44 - something that you render within HTML so
09:48 - you have this main parent component
09:50 - which is kind of like your app or your
09:52 - main window and then within that you
09:54 - render all of these other sub components
09:56 - and the whole point of doing that is
09:58 - that if I make a component for example
09:59 - like a variable Explorer which lets me
10:02 - view a bunch of variables I can render
10:04 - it in one area and then I can reuse it
10:06 - and render it somewhere else so it's
10:08 - just a better way of writing kind of
10:10 - complicated HTML related UIs and all
10:13 - those kind of things and what you can
10:15 - actually do inside of these components
10:17 - is write JavaScript or types great
10:18 - typescript code in this case and you can
10:21 - handle state of these components and
10:23 - properties of these components so
10:25 - properties are something you pass to the
10:27 - component when you render it for example
10:29 - say I want you know the background of a
10:31 - component to be blue then through the
10:33 - props of that component the properties
10:35 - of it I pass that I want to render it
10:37 - with blue then I look at that property
10:40 - inside of this component and I modify
10:42 - the HTML accordingly that's essentially
10:45 - how that works within each component you
10:47 - also have state so for example say you
10:49 - have a height something's resizable that
10:51 - would be a state of the component so you
10:53 - have a width that would be a state so
10:55 - you have the amount of time someone's
10:56 - click the button on that component that
10:58 - would be a state of the component and
11:00 - every time you change state in a
11:03 - component where you change the
11:04 - properties it rear Enders the component
11:06 - so that's the way that this works
11:08 - and this is what we use so I don't
11:11 - really like that's as much of an
11:12 - explanation as react as I really want to
11:14 - give you but this is the UI related
11:16 - stuff we just used react components and
11:18 - you can see for example here I'm
11:20 - rendering a draggable component that has
11:23 - all of this stuff inside of it this
11:26 - language inside of here is called JSX in
11:29 - here it's actually TSX I believe that
11:32 - stands for type script something but
11:35 - it's like a hybrid between typescript
11:38 - and HTML and you can see that I can
11:39 - actually write for example I know this
11:42 - inside of my HTML code and all of my
11:45 - classes are not defined by class they're
11:47 - defined by class name because that's
11:50 - what JSX uses where TSX uses as their
11:53 - kind of syntax for rendering HTML so
11:56 - anyways that's a whole nother lesson on
11:57 - its own is typescript and all that stuff
11:59 - but essentially what happens is you have
12:01 - a method inside of your components
12:03 - called render and that will be called
12:05 - automatically when any of the states are
12:07 - prompt change and then you have
12:08 - lifecycle methods which are something
12:10 - like should component update component
12:12 - did mount that happen when certain
12:14 - events are triggered so say the
12:16 - component just mounts so that means it
12:18 - just appears on the screen then what you
12:21 - do is well you can kind of hook in to
12:24 - this method and and do something so in
12:27 - this case what I'm doing is setting the
12:28 - initial height of the variable Explorer
12:30 - every single time this component mounts
12:32 - on the screen amounts actually I don't
12:34 - think that means it like loads I think
12:36 - that means sorry it means it loads it
12:39 - means it hasn't rendered yet but it
12:40 - loads so I set this before it renders
12:43 - the initial state onto the screen
12:44 - anyways again not super important but
12:46 - some of the examples of something that
12:48 - we do the UI is fairly straightforward
12:51 - it's just using react and if you know
12:54 - react then you understand pretty much
12:55 - the UI component okay so now what I'm
12:58 - gonna do is talk about how we actually
13:00 - send information between the user
13:01 - interface and the extension now the user
13:04 - interface you have to remember and
13:06 - imagine really is only responsible for
13:08 - rendering the UI right maybe it handles
13:10 - things like if you press a button maybe
13:12 - it you know displays information in a
13:14 - nice way but really it's not meant to do
13:16 - any super computationally heavy things
13:18 - it's not meant to store data
13:20 - persistently
13:21 - it doesn't save files it doesn't do a
13:23 - lot of the things that the Python
13:25 - extension does or needs to do so we have
13:28 - to have a way for essentially the user
13:30 - interface to connect and interact with
13:33 - the extension which has a lot of that
13:35 - heavy lifting or does a lot of that
13:36 - heavy lifting now a really common
13:38 - example is something like storing state
13:41 - so here I have this variable Explorer I
13:44 - know I haven't showed you guys what this
13:46 - variable Explorer is but essentially
13:47 - it's just an item where you can look at
13:49 - the state of variables in an I Python
13:51 - notebook now when you open this thing up
13:54 - you can resize it and you can change the
13:56 - size of it and you can toggle it so it's
13:58 - viewed or it's not viewed now obviously
14:01 - if I set it at a specific height and I
14:03 - close it when I open it back up I would
14:06 - expect that it stays at that height I
14:07 - don't want it to automatically resize to
14:10 - the default height every time because
14:12 - then I just have to constantly keep
14:13 - resizing it right so a problem that I
14:16 - solved this start here at Microsoft was
14:18 - let's make that happen let's make it so
14:20 - that first of all we can resize this
14:22 - variable Explorer because it was not
14:24 - resizable before and that if you resize
14:26 - it to a certain height it stays at that
14:29 - height unless you change it right so the
14:32 - way that we do that is first while I'm
14:33 - in the UI here so I'm in variable
14:35 - Explorer dot TSX I'm on the what's
14:37 - called not the client side the data
14:39 - science UI and well I have this method
14:42 - I've called in save current height that
14:44 - says this dot prompts dot set variable
14:46 - explorer height and then I pass the
14:48 - height of the container and the height
14:50 - of the grid this is just what the
14:53 - information we need to actually store
14:55 - the height of this variable Explorer and
14:56 - well I'm calling a method that says set
14:59 - very low Explorer height with that
15:00 - information now you don't need to know
15:02 - where I call this from or kind of how
15:04 - all the details operate but just imagine
15:06 - that what we need to do here in the UI
15:07 - is we want to set that height and we
15:09 - need to do that we need to do that
15:11 - setting from the extension side because
15:13 - we can't set and save persistent data
15:16 - from the user interface we can only do
15:18 - that from the extension which is running
15:20 - in a separate process so we need a way
15:21 - to communicate with it so what this
15:24 - actually does where this method is
15:26 - actually defined is inside of redux so
15:29 - redux is what allows us to actually kind
15:32 - of handle state changes and commute
15:34 - in between the extension and the user
15:37 - interface now there's some other things
15:38 - that do this as well but Redux is kind
15:41 - of one of the core tools that we use and
15:43 - I don't really want to explain too much
15:45 - into how Redux works but let me just go
15:47 - here to variables TS and types TS and
15:50 - show you what I mean so inside of types
15:53 - TS which is inside of the reducers
15:56 - folder here what we have is actually a
15:58 - definition of a bunch of different
16:00 - messages that can be sent between the
16:02 - user interface and other aspects of the
16:05 - user interface or the extension so for
16:08 - example we have ADD and focus new cell
16:10 - this is a message that we could send
16:12 - saying hey you know comment action type
16:14 - this happened send this through the
16:16 - extension let the extension handle it
16:18 - over there
16:19 - so essentially what we're doing is we're
16:21 - sending messages between the extension
16:23 - and the user interface were not for
16:25 - example like I'm not importing a class
16:27 - from the extension and using it I'm
16:29 - sending a message and then that message
16:31 - will get handled on the other side so
16:33 - it's a form of communication some kind
16:35 - of protocol that's going on so we define
16:38 - all of these messages here I'm trying to
16:41 - find where the variable Explorer one is
16:42 - we have toggle variable Explorer first
16:44 - of all that's a message that could be
16:45 - sent and set variable Explorer height so
16:48 - that's the message that we want to send
16:50 - when we set the variable Explorer height
16:52 - from the user interface we want to send
16:54 - this message to the extension so here
16:56 - inside of common action types let me see
16:58 - if I can find set variable explorer
17:00 - height so let's just ctrl F there and we
17:03 - can see that when I have common action
17:05 - type dot set variable Explorer height I
17:07 - am mapping that because this is a common
17:10 - action type mapping to the payload of I
17:13 - variable Explorer height so what this is
17:15 - saying is that when I use this message I
17:17 - want to pass information that is inside
17:21 - of them like that implements this
17:22 - interface to the extension so
17:25 - essentially I need to send data with
17:27 - this message as a payload and the data
17:29 - that's gonna come with this message will
17:31 - be I variable Explorer height now I
17:33 - variable explorers height is a interface
17:36 - and you could see that it's defined here
17:38 - as container height grid height so
17:41 - exactly the information that I'm sending
17:42 - to numbers is what I'm stating inside of
17:46 - here so if we go here that I
17:48 - want to send with this action hopefully
17:51 - that is clear so once that happens once
17:53 - we send it the action ah let's go to do
17:57 - I gotta find how all of this works now
18:00 - there's so many files to uh to explore
18:02 - let me go back to read X here so let's
18:03 - say that that action is sent and if I go
18:06 - back to variable explorer I'm just gonna
18:08 - have to tab back through a bunch of
18:10 - different things here okay so now we're
18:12 - in variable Dutch yes so this file here
18:15 - is inside a redux it's right beside
18:17 - types and what this does is essentially
18:20 - handle when a message gets sent what
18:23 - happens so when I send a message from
18:25 - the user interface so I called that
18:27 - method set variable explorer height from
18:29 - the variable explorer magically I don't
18:32 - want to go this far a message with
18:34 - common action type dot set variable
18:36 - explorer height gets sent it just gets
18:39 - sent out through read X and we pretty
18:41 - much say hey this is the information I
18:43 - want to send redux take care of it so
18:45 - that's what happens in the UI so redux
18:48 - says okay
18:49 - if we sent this message or if we sent
18:52 - this message whatever messages are sent
18:54 - here we're gonna accordingly call this
18:57 - mapping so what this is doing is pretty
18:59 - much mapping all of the messages that we
19:01 - want to handle inside of variables yes
19:04 - to their respective functions that are
19:06 - gonna handle the communication so we're
19:09 - still on the user interface side here
19:11 - and through redux I send a message that
19:14 - says hey we want to set the variable
19:15 - explore Heights with this information
19:18 - Redux picks that up and says okay you
19:21 - know I've got this message and then what
19:23 - it does is that says I'm gonna map this
19:25 - message to this function so let me go to
19:27 - this function here set variable explorer
19:29 - height and you can see that inside of
19:31 - here it's argument is a variable reducer
19:34 - argument that is I variable explorer
19:37 - height what this means is essentially
19:39 - we're wrapping what the information that
19:42 - we're going to send which is I variable
19:43 - Explorer height and we're going to
19:45 - return a new I variable state now this
19:48 - gets really confusing but all you really
19:50 - have to understand here is that I grab
19:52 - the information out of this payload
19:54 - which is what it's called and then what
19:56 - I do is I post to the extension this
19:59 - information so what I say now is
20:02 - okay we handle this message from redux
20:04 - okay Redux has taken this it's grabbed
20:07 - this information it's gonna do some kind
20:09 - of logic here and then what it's gonna
20:11 - do is send to the extension the argument
20:15 - which is going to be the payload here so
20:18 - it's gonna be the data so container
20:20 - height and grid Heights with the message
20:23 - interactive window messages set variable
20:26 - explorer height and then the container
20:27 - height and the grid height so what this
20:29 - is saying is let's communicate with the
20:30 - extension side and let's send them this
20:33 - information so that on the extension
20:35 - side we can set the variable Explorer
20:37 - height so if I go to interactive window
20:39 - messages set variable Explorer height
20:41 - let me go to references for this what
20:43 - I'm gonna do now is bring us over to the
20:44 - extension where this message will be
20:46 - handled so essentially all of this
20:48 - happened on the UI and then Redux said
20:51 - okay let's talk to the extension by
20:53 - sending a message so now we go to the X
20:57 - let's see here the extension I'm trying
21:00 - to figure out where I want to go into
21:01 - interactive base and if we look at
21:03 - interactive base now we're inside the
21:06 - extension side so we're in a different
21:07 - process we're separated away from the UI
21:09 - and there's this big on message event
21:12 - here that happens that it pretty much
21:14 - says hey when a mass message gets sent
21:16 - handle it here and then there's all
21:18 - these switch cases for all the different
21:21 - methods that can be sent or all the
21:22 - different messages that can be sent one
21:24 - of which is set variable explorer height
21:26 - so essentially we say if the message
21:28 - that was sent was set variable explorer
21:30 - height called this method with the
21:33 - payload and ignore any errors that
21:35 - happen there so what we can do now is go
21:37 - to this method so go set variable
21:39 - explorer height and here this is where
21:42 - the logic is handled to actually store
21:44 - this variable Explorer height so we say
21:46 - if payloads undefined then the updated
21:48 - heights equals the payload as this
21:50 - interface here or this object what we're
21:53 - gonna do now is some fancy thing that
21:56 - again is difficult to explain and
21:58 - essentially store this information in
22:00 - local storage so that if we want to grab
22:02 - it in the future we can and in fact
22:05 - right here this variable Explorer height
22:07 - request and what this does is simply get
22:09 - the information that's stored in storage
22:11 - and send it back to the user interface
22:13 - so that the user interface can take
22:16 - States and in rendering that that's what
22:19 - it does now I know there's there's just
22:21 - so much to explain here I'm trying my
22:23 - best to go as thorough as I can but
22:25 - let's go to one more thing now so after
22:27 - I've just done that this communication
22:28 - between extension and user interface let
22:31 - me talk about a kind of set of features
22:33 - that I'm working on right now and how
22:35 - this works so what I'm doing actually is
22:38 - working on a feature to be able to
22:39 - export a ipython notebook into PDF HTML
22:43 - or a Python script they already have
22:46 - Python script and v/s code but there's
22:48 - no feature for HTML or PDF so I've been
22:50 - working on that and I can say gladly
22:52 - that is pretty well fully functioning
22:54 - there's just a few more things we need
22:55 - to kind of iron out so what I have here
22:58 - is this folder called
22:59 - export on the extension side keep that
23:02 - in mind it handles all of the exporting
23:05 - and actually taking a file and changing
23:08 - the format of that file which is not
23:10 - that easy to do so here what I have is
23:13 - export manager dependency checker export
23:16 - manager file open our export manager
23:18 - file picker there's a lot of different
23:20 - things that have to happen when you want
23:21 - to export a file to a different format
23:24 - right and you can imagine that when I
23:26 - write this code what I'm trying to do is
23:28 - set it up in a way that I can very
23:30 - easily add another format to export to
23:34 - you because in the future we might want
23:35 - to export to something different right
23:37 - so I want to set up this code scalably
23:38 - so that it's very easy and I have a
23:40 - really good infrastructure if I want to
23:42 - add something more so I'm gonna start at
23:45 - export manager file opener because this
23:47 - is the kind of entry point into this
23:49 - feature so anytime that we want to
23:52 - actually export to a specific format
23:54 - this class will get called first and
23:57 - this export method will get called now
24:00 - before I even get into all this and
24:01 - start looking at some of this stuff what
24:03 - I want to do is talk about this
24:05 - injection so in this code base we use
24:07 - something called dependency injection
24:09 - and something called inversion of
24:11 - control now this is pretty much just a
24:14 - practice it's you know it's like a
24:15 - design pattern inside of software
24:17 - engineering which allows you to have all
24:19 - these kind of services if you want to
24:22 - think of them that way that run
24:23 - independently as what we call
24:25 - Singleton's that you can access at any
24:28 - time by simply in
24:30 - in them as a dependency into a class so
24:34 - here you can see that what I've done is
24:36 - I've injected the export manager
24:38 - dependency checker as the manager into
24:42 - this class in its constructor I've also
24:44 - injected the I document manager and this
24:47 - is another class that simply manages
24:49 - documents right I've implemented or
24:52 - injected the progress reporter the file
24:54 - system the application shell and the
24:57 - browser service into this constructor
25:00 - what that says is immediately when I
25:03 - start using export manager file opener
25:05 - pretty much find where these classes are
25:09 - and grab them bring them in and
25:12 - reference them using these names which
25:14 - means now I can use this service inside
25:16 - of this class to make a class injectable
25:20 - you simply define it as @ injectable and
25:22 - you add it into something called the
25:24 - service registry ok so I want to show
25:26 - you the service registry here what this
25:29 - does is simply register all of the
25:32 - services that we want to use in our
25:34 - dependency injections so whenever we
25:37 - have a class that we want to potentially
25:38 - inject into another class as a
25:40 - dependency what we do is register it
25:43 - inside of here and this pretty much just
25:45 - tells our program when we go to inject
25:47 - something what we take and where we get
25:50 - it from so what I've said for example in
25:52 - this export manager here is okay I'm
25:54 - gonna add a singleton which I won't
25:56 - really describe which is type I export
25:59 - manager so it implements this interface
26:00 - I can go to this interface here and you
26:02 - can see that all that says is that it
26:04 - must have an export method that takes a
26:06 - format and a model so that's what this
26:08 - type is we're gonna call this export
26:11 - manager and we're gonna use export
26:13 - manager as this class the idea behind
26:16 - this is that I don't really care what
26:18 - class I use when I inject a dependency I
26:21 - just simply refer to it using some name
26:23 - and then I get given the service
26:25 - corresponding with that so for example
26:28 - inside export manager file opener here
26:30 - if I implement or I inject export
26:33 - manager dependency checker I don't
26:35 - actually care what class implements this
26:37 - I just care that it works and it does
26:40 - what the interface states that it does
26:42 - so again we're getting very
26:43 - complicated here but the idea being that
26:45 - if at any point in time I actually want
26:48 - to change the implementation of export
26:50 - manager dependency checker all I do is
26:52 - change the class that this name
26:54 - references and nothing gets affected
26:57 - inside of any class that injects that
27:00 - dependency because it doesn't know what
27:02 - class its injecting it just knows it's
27:04 - injecting a class that's referenced by a
27:06 - name so I know that's confusing but that
27:09 - is how this works that's how the service
27:11 - registry works and this is what allows
27:12 - us to inject these items in here we
27:15 - state them and define them in the
27:16 - service registry and then we can use
27:18 - injection to take them in to any class
27:20 - from any point in this extension so that
27:23 - is how that works on the dependency
27:25 - injection so what I do here is
27:27 - essentially I have this is very
27:31 - confusing to explain because there's a
27:33 - lot to go through which I don't
27:34 - necessarily want to but this just takes
27:36 - some export format it takes the model so
27:38 - the notebook that we actually want to
27:39 - export does a bunch of stuff has a bunch
27:43 - of telemetry happen and that actually
27:45 - delegates all of these tasks now to the
27:47 - export manager file picker so it pretty
27:49 - much says okay we've called export
27:52 - manager file opener this now calls the
27:54 - export manager file picker the file
27:56 - picker actually says hey we need to get
27:59 - you to choose where you want to save
28:01 - this exported file to it gets it to
28:04 - choose that and then this now delegates
28:06 - to the export manager and says hey we
28:09 - picked that we wanted this type of file
28:11 - we want to save it here let's send that
28:14 - request over to the export manager so we
28:16 - can actually handle doing the export the
28:18 - export manager does a switch on the
28:20 - different formats takes the model
28:22 - whatever file the target that we need to
28:24 - save to that the export manager file
28:26 - picker has determined then it delegates
28:29 - to every specific export method so
28:31 - export to HTML is here PDF is here which
28:34 - isn't done yet and Python is here so
28:37 - essentially we have all these different
28:38 - classes they're responsible for very
28:40 - specific things we have an X where base
28:43 - class which has some functionality that
28:45 - is shared between all of the specific
28:47 - export methods and what we're doing is
28:49 - we're saying okay what we're gonna need
28:51 - to do when we export is we need to first
28:53 - of all open the exported file right once
28:55 - that file is exported we're gonna need
28:57 - to open that
28:57 - so we start with the file opener because
28:59 - if we call this opener if it can get an
29:02 - exported file from somewhere then it can
29:04 - just open it right that's all we're
29:06 - doing inside of here were pretty much
29:08 - figuring out hey did this export happen
29:10 - successfully if it did open the exported
29:12 - file great that's all this class needs
29:14 - to know and all it needs to do now
29:16 - export manager dependency checker okay
29:18 - well we need to call this because we
29:21 - need to make sure that we have the
29:22 - dependencies installed on the system
29:24 - before we can go ahead and actually pick
29:26 - files and start exporting something
29:28 - let's say this one works right okay boom
29:31 - everything's working fine then what we
29:32 - need to do is go to the export manager
29:34 - file picker we need to actually pick
29:36 - some file that we want to export to and
29:39 - then from there we need to actually
29:41 - export the file so once we pick where we
29:44 - want to save this file let's actually go
29:46 - now to export manager so delegate the
29:49 - tasks to him he'll take whatever we
29:51 - passed and then automatically say oh
29:53 - okay so if we're doing Python I need to
29:55 - do this if we're doing HTML I need to do
29:56 - this and then call one of these three
29:59 - specific classes which performs the
30:01 - actual export operation and then we go
30:04 - back up the chain and we eventually get
30:06 - you export manager file opener and now
30:08 - we're at the point where hey we
30:10 - successfully have a file we created it
30:12 - and we open that file up and that is the
30:14 - idea behind this export kind of folder
30:17 - and feature and functionality that I've
30:19 - been writing here and that is pretty
30:21 - much as much as I think I can explain
30:24 - without getting too exhausted going
30:27 - through this code base so I think I'm
30:29 - going to leave it here this is a
30:31 - difficult video to film because I want
30:34 - to show you guys everything but I can't
30:35 - write and there's a lot of stuff that
30:37 - has kind of prerequisite knowledge need
30:38 - to understand and I hope that at least I
30:41 - kind of give you guys some kind of idea
30:43 - of what's going on here and how things
30:45 - kind of work you don't need to
30:46 - understand all the specific code but now
30:48 - maybe you understand the complexity in a
30:50 - large-scale software system there's so
30:53 - much stuff happening and just even
30:55 - finding a way to communicate between
30:56 - different processes that are running is
30:58 - difficult in its own right and you even
31:00 - saw there's some messy code here because
31:02 - when you don't do something right the
31:04 - first time or you do it not a hundred
31:06 - percent correct you fall into the trap
31:08 - of just continuing to do it that way
31:10 - until you
31:11 - to a point where you have these massive
31:12 - files with a ton of stuff going on and
31:14 - it's too late to even change anything so
31:16 - with that being said I think I'm gonna
31:18 - end the video here if you guys made it
31:20 - to the end give yourself a pat on the
31:21 - back I'm sure not many people will make
31:23 - it this far and remember there is that
31:25 - big course discount happening right now
31:27 - for one week so June 22nd to June 26
31:30 - again more information about that in the
31:32 - description so if you enjoyed make sure
31:33 - you leave a like subscribe and I will
31:35 - see you guys in another YouTube video

Cleaned transcript:

hello everyone and welcome back to the YouTube video so in today's video what I'm gonna be doing is exploring and walking through a real Microsoft code base now the reason I'm able to do this is because I'm working at Microsoft is a software engineer intern and I'm working on the Python extension team for Visual Studio code so if you don't know within Visual Studio code one of the more popular editors out there right now there's all these different extensions and what these extensions do is just bring different functionality different features syntax highlighting whatever there's a ton of different things that come with these extensions one of the more popular extensions is the Python extension which you can see has been downloaded by just over 21 million people and is supported and maintained by Microsoft now this is an opensource extension which means pretty much all the code that you are looking at or that I'm gonna be showing in this video actually all of it is available publicly online from this repository which I'll leave a link to in the description so here you can see all of the code for the extension that's publicly available because it's open source and this is what I work on every day I work on an open source project which means I can actually show you guys what I've done which i think is really cool so with that being said I will mention that this entire code base is pretty much written in typescript there is some react as well for the UI related features and I mean I'll be talking about that as we go through but this is quite complicated code it's not something that I imagine you guys will completely 100% understand but I am still gonna explain it and walk through some different features and since the extension is so massive I will kind of talk about you know some different random areas and try to give you a taste to kind of everything without going far too indepth on one specific area all right so we're pretty much ready to get going the last thing I'll say is actually right now there's a really awesome deal going on on a bunch of pre premium programming courses if you guys are interested in potentially purchasing a whole whack of premium programming courses there's actually 33 of them that we have bundled together right now I've teamed up with 26 other content creators authors people that are well respected kind of in the industry and as teachers and they've taken all of their premium programming courses and I have a premium programming course as well and we've bundled them all together this is usually like thousands of dollars worth of courses if you combine all the value of all those courses together and we're selling it for a pretty good discount actually is about 94 percent discount I don't want to like will you with the big numbers you can check out all this stuff in the description down below but I just figured I'd make you guys aware and this is a great way if you want to support me or support some of the other creators to get a really good deal on a ton of different premium programming courses this is only gonna be available from June 22nd to June 26th and I believe there is an early bird discount if you purchase it on the first or second day anyways I don't want to talk about it too much there's a link in the description and feel free to check that out and just see if it even is of interest to you alright so let's actually start exploring this codebase walking through some different areas and yeah just kind of getting into it now I will start by saying that this codebase is massive there's a huge codebase I wouldn't anticipate or expect anyone to be able to understand it even just in a few months of actually using it because there's so much content in here and you'll see myself there's some areas here that I just don't actually know what they do or I haven't been exposed to them yet so I have a decent understanding but I'm gonna give us kind of like a highlevel overview of the structure of this codebase then we'll get into some code that I've written myself that I do truly really understand and I'll talk about how that kind of works and that should hopefully give you a good idea of how we've done things inside of here and some of the design patterns and all that so the first thing that I'm gonna do here is just kind of show you the structure so you can see that there's a bunch of different folders here and a bunch of different random files now the core technology used in this code bases typescript so typescript is the main language and what happens is when we use this extension we compile that typescript code actually transpile it into JavaScript and then run that the reason we're using typescript from what I've heard is because it's way better to have a typed language when you're working on a project this large the reason for that is that I can just hover over things right and see exactly what type these items are and I can actually go and look at definitions of interfaces of classes I can click on for example like react thoughts CSS properties and go go to go to definition and I can actually see all of the stuff related to that so it's very powerful and it just makes developing and navigating a codebase way easier when you have strict typing and typescript is nice because it actually gives you the option to set typing or not so if you're in a situation where you don't want to have strict typing you can just not set a type for that variable or for that object or whatever it may be I mean it means you can save a little bit of time right but for example like four grid columns I can see what all of these different items are I can see if they're optional or not and it just makes it a lot easier when you're actually doing development now of course you may have noticed here that we're also using react so we use typescript mainly and then react as well to do all the UI related features we also use redux as a frontend state manager and also to handle communication between the extension and between IB actually you op so that leads me into the first thing that I wanted to say and I want to jump into this SRC folder so I'm not really going to talk about most of the other stuff here cuz it's not that important or interesting but SRC is where all of the source code for this project is inside of here we have five files and I'll briefly define what each of these are so client this is where most of the stuff happens client is where will be called the extension lives so because we have a user interface we need to have some kind of frontend backend and a separation between them so we have the client which we call the extension which runs in a separate process and then we have the data science UI which is a user interface which runs again in a webview in a separate process so immediately we have two processes what that means for anyone that knows anything about multi processing or multithreading is that we have to have a very robust communication system between these processes because when you have two separate processes you may have things like just sharing memory is not that easy being able to talk to one another I can't simply just use one of the classes from another process I need to actually send a message to that process have that message handled have a request sent maybe I send that with a payload some information some data and then have some response sent back so it gets very complicated very quick so those are the two main folders you have I pie widgets which is very specific to ipython widgets if you don't know what those are don't worry I'm not really gonna discuss them and then tests so inside of here is where we write all of our automated tests now we have a CLI on the github repository and what that does is make sure that every time you submit a new pull request so you make some kind of change to the repository it runs all of the tests that we've written here and make sure that they all pass so we have unit tests we have functional tests believe there's integration tests all different kinds of tests that test pretty well every feature that we have and everything that makes sense and you go for a pretty high code coverage you want to really test a good majority of the code that you have in the extension to make sure that when you make a change you don't break something and something some test fails essentially right this also means that we don't have to manually test anything every time that we go ahead and make it change we can just wait for that CLI on github to run and it will tell us hey you mess this up hey you need to change this and that whatever that's the point of test so anytime that we write some kind of new feature or we add or make a major change we write automated tests for that feature probably functional and unit tests maybe sometimes either/or depends on how big or what it is and within this we actually use two different testing frameworks one of which I believe is called TS mockito and then there's another one that is called something else was vs code test so I don't know what the other testing framework is forget the name of it but the main one I believe is TS mockito and that essentially allows you to mock objects I'm not really gonna go into all of that because that's kind of somewhat complicated but anyways that is the main idea behind kind of how this is all set up so I could of course go into clients and go into data science UI and show you all of the different features I'm not gonna do that what I will show you though is one area that I am familiar with in data science UI and kind of just talk a little bit about how that works and then I'll go over to the extension side and I'll talk about how we actually handle communication between these two processes and actually one of the new features that I've been adding so let's go into intro active common here you can notice that there's a bunch of different folders and these all represent different areas of the UI the way that this works is that we actually render what's called a webview so it literally is pretty much like kind of a mock HTML page or yeah like a mock browser inside of es code and that's where we render all of the react related components and all the UI related features so if I go here to variable Explorer this is something I'm quite familiar with because I've used it and I've been working on it we can see that this is react so if you look here we have a class it extends a react component it has a variable Explorer props and variable Explorer state now I don't really want to explain react to everyone but essentially there's two main areas or two main things in everything that we call a component now what a component is is essentially something that you render within HTML so you have this main parent component which is kind of like your app or your main window and then within that you render all of these other sub components and the whole point of doing that is that if I make a component for example like a variable Explorer which lets me view a bunch of variables I can render it in one area and then I can reuse it and render it somewhere else so it's just a better way of writing kind of complicated HTML related UIs and all those kind of things and what you can actually do inside of these components is write JavaScript or types great typescript code in this case and you can handle state of these components and properties of these components so properties are something you pass to the component when you render it for example say I want you know the background of a component to be blue then through the props of that component the properties of it I pass that I want to render it with blue then I look at that property inside of this component and I modify the HTML accordingly that's essentially how that works within each component you also have state so for example say you have a height something's resizable that would be a state of the component so you have a width that would be a state so you have the amount of time someone's click the button on that component that would be a state of the component and every time you change state in a component where you change the properties it rear Enders the component so that's the way that this works and this is what we use so I don't really like that's as much of an explanation as react as I really want to give you but this is the UI related stuff we just used react components and you can see for example here I'm rendering a draggable component that has all of this stuff inside of it this language inside of here is called JSX in here it's actually TSX I believe that stands for type script something but it's like a hybrid between typescript and HTML and you can see that I can actually write for example I know this inside of my HTML code and all of my classes are not defined by class they're defined by class name because that's what JSX uses where TSX uses as their kind of syntax for rendering HTML so anyways that's a whole nother lesson on its own is typescript and all that stuff but essentially what happens is you have a method inside of your components called render and that will be called automatically when any of the states are prompt change and then you have lifecycle methods which are something like should component update component did mount that happen when certain events are triggered so say the component just mounts so that means it just appears on the screen then what you do is well you can kind of hook in to this method and and do something so in this case what I'm doing is setting the initial height of the variable Explorer every single time this component mounts on the screen amounts actually I don't think that means it like loads I think that means sorry it means it loads it means it hasn't rendered yet but it loads so I set this before it renders the initial state onto the screen anyways again not super important but some of the examples of something that we do the UI is fairly straightforward it's just using react and if you know react then you understand pretty much the UI component okay so now what I'm gonna do is talk about how we actually send information between the user interface and the extension now the user interface you have to remember and imagine really is only responsible for rendering the UI right maybe it handles things like if you press a button maybe it you know displays information in a nice way but really it's not meant to do any super computationally heavy things it's not meant to store data persistently it doesn't save files it doesn't do a lot of the things that the Python extension does or needs to do so we have to have a way for essentially the user interface to connect and interact with the extension which has a lot of that heavy lifting or does a lot of that heavy lifting now a really common example is something like storing state so here I have this variable Explorer I know I haven't showed you guys what this variable Explorer is but essentially it's just an item where you can look at the state of variables in an I Python notebook now when you open this thing up you can resize it and you can change the size of it and you can toggle it so it's viewed or it's not viewed now obviously if I set it at a specific height and I close it when I open it back up I would expect that it stays at that height I don't want it to automatically resize to the default height every time because then I just have to constantly keep resizing it right so a problem that I solved this start here at Microsoft was let's make that happen let's make it so that first of all we can resize this variable Explorer because it was not resizable before and that if you resize it to a certain height it stays at that height unless you change it right so the way that we do that is first while I'm in the UI here so I'm in variable Explorer dot TSX I'm on the what's called not the client side the data science UI and well I have this method I've called in save current height that says this dot prompts dot set variable explorer height and then I pass the height of the container and the height of the grid this is just what the information we need to actually store the height of this variable Explorer and well I'm calling a method that says set very low Explorer height with that information now you don't need to know where I call this from or kind of how all the details operate but just imagine that what we need to do here in the UI is we want to set that height and we need to do that we need to do that setting from the extension side because we can't set and save persistent data from the user interface we can only do that from the extension which is running in a separate process so we need a way to communicate with it so what this actually does where this method is actually defined is inside of redux so redux is what allows us to actually kind of handle state changes and commute in between the extension and the user interface now there's some other things that do this as well but Redux is kind of one of the core tools that we use and I don't really want to explain too much into how Redux works but let me just go here to variables TS and types TS and show you what I mean so inside of types TS which is inside of the reducers folder here what we have is actually a definition of a bunch of different messages that can be sent between the user interface and other aspects of the user interface or the extension so for example we have ADD and focus new cell this is a message that we could send saying hey you know comment action type this happened send this through the extension let the extension handle it over there so essentially what we're doing is we're sending messages between the extension and the user interface were not for example like I'm not importing a class from the extension and using it I'm sending a message and then that message will get handled on the other side so it's a form of communication some kind of protocol that's going on so we define all of these messages here I'm trying to find where the variable Explorer one is we have toggle variable Explorer first of all that's a message that could be sent and set variable Explorer height so that's the message that we want to send when we set the variable Explorer height from the user interface we want to send this message to the extension so here inside of common action types let me see if I can find set variable explorer height so let's just ctrl F there and we can see that when I have common action type dot set variable Explorer height I am mapping that because this is a common action type mapping to the payload of I variable Explorer height so what this is saying is that when I use this message I want to pass information that is inside of them like that implements this interface to the extension so essentially I need to send data with this message as a payload and the data that's gonna come with this message will be I variable Explorer height now I variable explorers height is a interface and you could see that it's defined here as container height grid height so exactly the information that I'm sending to numbers is what I'm stating inside of here so if we go here that I want to send with this action hopefully that is clear so once that happens once we send it the action ah let's go to do I gotta find how all of this works now there's so many files to uh to explore let me go back to read X here so let's say that that action is sent and if I go back to variable explorer I'm just gonna have to tab back through a bunch of different things here okay so now we're in variable Dutch yes so this file here is inside a redux it's right beside types and what this does is essentially handle when a message gets sent what happens so when I send a message from the user interface so I called that method set variable explorer height from the variable explorer magically I don't want to go this far a message with common action type dot set variable explorer height gets sent it just gets sent out through read X and we pretty much say hey this is the information I want to send redux take care of it so that's what happens in the UI so redux says okay if we sent this message or if we sent this message whatever messages are sent here we're gonna accordingly call this mapping so what this is doing is pretty much mapping all of the messages that we want to handle inside of variables yes to their respective functions that are gonna handle the communication so we're still on the user interface side here and through redux I send a message that says hey we want to set the variable explore Heights with this information Redux picks that up and says okay you know I've got this message and then what it does is that says I'm gonna map this message to this function so let me go to this function here set variable explorer height and you can see that inside of here it's argument is a variable reducer argument that is I variable explorer height what this means is essentially we're wrapping what the information that we're going to send which is I variable Explorer height and we're going to return a new I variable state now this gets really confusing but all you really have to understand here is that I grab the information out of this payload which is what it's called and then what I do is I post to the extension this information so what I say now is okay we handle this message from redux okay Redux has taken this it's grabbed this information it's gonna do some kind of logic here and then what it's gonna do is send to the extension the argument which is going to be the payload here so it's gonna be the data so container height and grid Heights with the message interactive window messages set variable explorer height and then the container height and the grid height so what this is saying is let's communicate with the extension side and let's send them this information so that on the extension side we can set the variable Explorer height so if I go to interactive window messages set variable Explorer height let me go to references for this what I'm gonna do now is bring us over to the extension where this message will be handled so essentially all of this happened on the UI and then Redux said okay let's talk to the extension by sending a message so now we go to the X let's see here the extension I'm trying to figure out where I want to go into interactive base and if we look at interactive base now we're inside the extension side so we're in a different process we're separated away from the UI and there's this big on message event here that happens that it pretty much says hey when a mass message gets sent handle it here and then there's all these switch cases for all the different methods that can be sent or all the different messages that can be sent one of which is set variable explorer height so essentially we say if the message that was sent was set variable explorer height called this method with the payload and ignore any errors that happen there so what we can do now is go to this method so go set variable explorer height and here this is where the logic is handled to actually store this variable Explorer height so we say if payloads undefined then the updated heights equals the payload as this interface here or this object what we're gonna do now is some fancy thing that again is difficult to explain and essentially store this information in local storage so that if we want to grab it in the future we can and in fact right here this variable Explorer height request and what this does is simply get the information that's stored in storage and send it back to the user interface so that the user interface can take States and in rendering that that's what it does now I know there's there's just so much to explain here I'm trying my best to go as thorough as I can but let's go to one more thing now so after I've just done that this communication between extension and user interface let me talk about a kind of set of features that I'm working on right now and how this works so what I'm doing actually is working on a feature to be able to export a ipython notebook into PDF HTML or a Python script they already have Python script and v/s code but there's no feature for HTML or PDF so I've been working on that and I can say gladly that is pretty well fully functioning there's just a few more things we need to kind of iron out so what I have here is this folder called export on the extension side keep that in mind it handles all of the exporting and actually taking a file and changing the format of that file which is not that easy to do so here what I have is export manager dependency checker export manager file open our export manager file picker there's a lot of different things that have to happen when you want to export a file to a different format right and you can imagine that when I write this code what I'm trying to do is set it up in a way that I can very easily add another format to export to you because in the future we might want to export to something different right so I want to set up this code scalably so that it's very easy and I have a really good infrastructure if I want to add something more so I'm gonna start at export manager file opener because this is the kind of entry point into this feature so anytime that we want to actually export to a specific format this class will get called first and this export method will get called now before I even get into all this and start looking at some of this stuff what I want to do is talk about this injection so in this code base we use something called dependency injection and something called inversion of control now this is pretty much just a practice it's you know it's like a design pattern inside of software engineering which allows you to have all these kind of services if you want to think of them that way that run independently as what we call Singleton's that you can access at any time by simply in in them as a dependency into a class so here you can see that what I've done is I've injected the export manager dependency checker as the manager into this class in its constructor I've also injected the I document manager and this is another class that simply manages documents right I've implemented or injected the progress reporter the file system the application shell and the browser service into this constructor what that says is immediately when I start using export manager file opener pretty much find where these classes are and grab them bring them in and reference them using these names which means now I can use this service inside of this class to make a class injectable you simply define it as @ injectable and you add it into something called the service registry ok so I want to show you the service registry here what this does is simply register all of the services that we want to use in our dependency injections so whenever we have a class that we want to potentially inject into another class as a dependency what we do is register it inside of here and this pretty much just tells our program when we go to inject something what we take and where we get it from so what I've said for example in this export manager here is okay I'm gonna add a singleton which I won't really describe which is type I export manager so it implements this interface I can go to this interface here and you can see that all that says is that it must have an export method that takes a format and a model so that's what this type is we're gonna call this export manager and we're gonna use export manager as this class the idea behind this is that I don't really care what class I use when I inject a dependency I just simply refer to it using some name and then I get given the service corresponding with that so for example inside export manager file opener here if I implement or I inject export manager dependency checker I don't actually care what class implements this I just care that it works and it does what the interface states that it does so again we're getting very complicated here but the idea being that if at any point in time I actually want to change the implementation of export manager dependency checker all I do is change the class that this name references and nothing gets affected inside of any class that injects that dependency because it doesn't know what class its injecting it just knows it's injecting a class that's referenced by a name so I know that's confusing but that is how this works that's how the service registry works and this is what allows us to inject these items in here we state them and define them in the service registry and then we can use injection to take them in to any class from any point in this extension so that is how that works on the dependency injection so what I do here is essentially I have this is very confusing to explain because there's a lot to go through which I don't necessarily want to but this just takes some export format it takes the model so the notebook that we actually want to export does a bunch of stuff has a bunch of telemetry happen and that actually delegates all of these tasks now to the export manager file picker so it pretty much says okay we've called export manager file opener this now calls the export manager file picker the file picker actually says hey we need to get you to choose where you want to save this exported file to it gets it to choose that and then this now delegates to the export manager and says hey we picked that we wanted this type of file we want to save it here let's send that request over to the export manager so we can actually handle doing the export the export manager does a switch on the different formats takes the model whatever file the target that we need to save to that the export manager file picker has determined then it delegates to every specific export method so export to HTML is here PDF is here which isn't done yet and Python is here so essentially we have all these different classes they're responsible for very specific things we have an X where base class which has some functionality that is shared between all of the specific export methods and what we're doing is we're saying okay what we're gonna need to do when we export is we need to first of all open the exported file right once that file is exported we're gonna need to open that so we start with the file opener because if we call this opener if it can get an exported file from somewhere then it can just open it right that's all we're doing inside of here were pretty much figuring out hey did this export happen successfully if it did open the exported file great that's all this class needs to know and all it needs to do now export manager dependency checker okay well we need to call this because we need to make sure that we have the dependencies installed on the system before we can go ahead and actually pick files and start exporting something let's say this one works right okay boom everything's working fine then what we need to do is go to the export manager file picker we need to actually pick some file that we want to export to and then from there we need to actually export the file so once we pick where we want to save this file let's actually go now to export manager so delegate the tasks to him he'll take whatever we passed and then automatically say oh okay so if we're doing Python I need to do this if we're doing HTML I need to do this and then call one of these three specific classes which performs the actual export operation and then we go back up the chain and we eventually get you export manager file opener and now we're at the point where hey we successfully have a file we created it and we open that file up and that is the idea behind this export kind of folder and feature and functionality that I've been writing here and that is pretty much as much as I think I can explain without getting too exhausted going through this code base so I think I'm going to leave it here this is a difficult video to film because I want to show you guys everything but I can't write and there's a lot of stuff that has kind of prerequisite knowledge need to understand and I hope that at least I kind of give you guys some kind of idea of what's going on here and how things kind of work you don't need to understand all the specific code but now maybe you understand the complexity in a largescale software system there's so much stuff happening and just even finding a way to communicate between different processes that are running is difficult in its own right and you even saw there's some messy code here because when you don't do something right the first time or you do it not a hundred percent correct you fall into the trap of just continuing to do it that way until you to a point where you have these massive files with a ton of stuff going on and it's too late to even change anything so with that being said I think I'm gonna end the video here if you guys made it to the end give yourself a pat on the back I'm sure not many people will make it this far and remember there is that big course discount happening right now for one week so June 22nd to June 26 again more information about that in the description so if you enjoyed make sure you leave a like subscribe and I will see you guys in another YouTube video
