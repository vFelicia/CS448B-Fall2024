With timestamps:

00:00 - hello everybody and welcome back so in
00:01 - this video you're gonna learn about
00:03 - object-oriented programming in Python
00:04 - and how you can create your own custom
00:06 - objects by making different classes in
00:09 - Python
00:10 - now this video is geared towards
00:11 - beginner so people that have some
00:13 - knowledge of Python have written Python
00:14 - code before but I've not yet stepped up
00:16 - into kind of the intermediate stage
00:18 - which I'm gonna call is this working
00:20 - with classes and objects and are looking
00:22 - to learn that so I'm restarting
00:23 - completely from the beginning if you
00:24 - have no knowledge of object-oriented
00:26 - programming that's totally fine in this
00:27 - series is meant for you if you're
00:29 - someone who just wants a refresher I'd
00:30 - recommend maybe watching the video on
00:32 - two x speed and slowing down when things
00:34 - get a bit more confusing or one you know
00:36 - you need to really learn that topic more
00:37 - so let's go ahead and get started and
00:40 - what we need to do to discuss
00:41 - object-oriented programming is first to
00:43 - find what an object is now a lot of
00:45 - people may think that when we talk about
00:47 - or object-oriented programming that's a
00:48 - completely new thing you know you've
00:50 - never seen an empath on before and it's
00:51 - a new kind of thing to tackle and to
00:53 - learn when in reality you actually see
00:56 - objects all the time when you're working
00:58 - with Python code and you just don't know
01:00 - that they're objects just because
01:01 - they're a little bit disguised and I'm
01:03 - gonna kind of take away that disguise
01:04 - and show you what all these different
01:06 - objects are so we may have heard of the
01:08 - notion of type before we see this
01:10 - function type and we know when we ask it
01:12 - what type a certain variable is or we
01:14 - ask it what types say you know a string
01:16 - is like this it spits out an answer to
01:18 - us and I'll show you what I mean by that
01:19 - so if I do print type of hello so we
01:22 - know that hello is a string datatype
01:24 - let's just see what we get in our
01:25 - console down here oops I didn't mean to
01:27 - do that
01:27 - we get class string so notice that this
01:31 - says class now most people just
01:32 - disregard the fact that it says this but
01:34 - this is actually very important what
01:35 - this is telling us is this right here
01:37 - this string that we typed in is actually
01:39 - an object of the class string right STR
01:43 - now what do you think is gonna happen
01:44 - when I put in X well we know that X is
01:47 - an integer so let's have a look here we
01:49 - can see that we get class int so notice
01:52 - that these different data types that
01:54 - we've called them before a string and an
01:56 - int are actually a part of a class and
01:58 - what that means is even though it
02:00 - doesn't look like we've created an
02:02 - object when we do something like x
02:03 - equals 1 we've said X is equal to the
02:06 - object which is a type integer with the
02:09 - value 1 that's exactly what we've done
02:11 - and the fact that we act
02:13 - create these kind of objects is very
02:15 - important in writing Python code and I
02:17 - know this hopefully shouldn't confuse
02:19 - any of you too much but if I write say a
02:21 - function so you know define hello and in
02:23 - here we just print hello like that and
02:26 - what I decide to do is I go okay let's
02:29 - look at the type of hello so notice I
02:31 - didn't call the function hello with the
02:33 - two brackets I'm just looking at the
02:34 - actual name of hello and we run this
02:37 - well if we add the final bracket at the
02:39 - end here we get class function so pretty
02:42 - much everything in Python that we work
02:44 - with is actually an object of some kind
02:46 - of class and later on in the video what
02:48 - we're gonna do is make our own classes
02:50 - so that we have our own specific types
02:52 - so these are what are called the
02:54 - built-in types these are built into the
02:56 - Python language and that's why they work
02:58 - a little bit differently than other
02:59 - classes that we'll work with later but
03:01 - just understand that whenever you create
03:03 - something in Python you are really
03:05 - creating an object which is an instance
03:08 - of a specific class in that class
03:10 - defines the way in which that object can
03:12 - interact with other things in our
03:14 - program and just show you what I mean by
03:16 - that let's just look at some common
03:18 - error messages and we'll see exactly
03:20 - what that means so we're gonna say x
03:21 - equals 1 y equals hello and watch what
03:24 - happens when I try to do something like
03:25 - print X plus y well we get some air
03:29 - let's go up and see here we get type
03:31 - error unsupported operand types for plus
03:33 - int and string so it's saying because
03:36 - our object x is an INT and our object Y
03:39 - is a string we cannot add them because
03:42 - the program does not know how to work
03:43 - with objects of those two types or in
03:46 - better words the addition operation is
03:48 - not defined for objects of int and
03:51 - objects of string at being added
03:53 - together so it's very important and
03:55 - pretty much the type that we have
03:57 - defines what we're allowed to do with
03:59 - the specific variable or with that
04:00 - specific object and it denotes the
04:03 - actions that we can perform you know
04:04 - plus minus all of that if I were to
04:07 - change this right to 2 and then we just
04:09 - do X plus y don't need to print it out
04:11 - we can see that that's totally fine and
04:12 - there's no issue because these are both
04:13 - ins which means that operation is
04:15 - defined for them ok so hopefully that is
04:18 - clear and that makes some sense I hope
04:21 - that gives you kind of understanding of
04:23 - what I mean by objects and now I'm gonna
04:24 - talk about methods because those are
04:26 - something that
04:27 - we can perform on objects so I'm sure
04:29 - that many of you seen this before I'm
04:30 - just gonna type string equals hello like
04:33 - that and many of you know that we can do
04:35 - something like print string if I can
04:38 - type this correctly dots up right so
04:41 - when I write this dot upper here what is
04:44 - that actually doing well let's look at
04:46 - here we obviously know that puts that
04:47 - all to uppercase but we're allowed to
04:50 - use this what we call method and this is
04:52 - a method whenever you have this a dot
04:53 - operator you have some name and then you
04:56 - have the two brackets at the end here
04:57 - and maybe there's some arguments that go
04:59 - inside of there that is usually a method
05:01 - that is acting on a specific object and
05:03 - in this case what it's doing is we have
05:05 - the method upper acting on the object of
05:08 - type string that is stored in this
05:10 - string variable and the reason we're
05:12 - allowed to use this method on it is
05:14 - because this is a string now notice that
05:16 - I can't do something like you know X
05:18 - equals one and then do X dot up and the
05:21 - reason I can't do that is because while
05:24 - it's gonna say right here int object
05:26 - notice int object has no attribute upper
05:28 - so these methods these different
05:30 - operations the things that we can do
05:32 - with these objects is based on the type
05:34 - of class that they are so that's
05:36 - something that we really need to nail in
05:37 - there and I hope that makes sense and
05:39 - now what I'm gonna show you is how we
05:40 - can actually create our own classes
05:42 - because hopefully that gave you a good
05:43 - enough explanation for what objects
05:45 - really are so to create our own class
05:48 - I'm gonna kind of do like a template
05:50 - here and then we'll go back through and
05:51 - discuss what everything is doing at once
05:53 - but just try to follow along for now so
05:54 - I'm gonna say class and we're just gonna
05:56 - do the classic kind of animal example to
05:58 - start here so I'm gonna say class dog
05:59 - and we're gonna define this
06:01 - initialization which we'll talk about
06:03 - later and actually no let's not even do
06:05 - that let's just say define bark like
06:08 - that and then what I'm gonna do in here
06:10 - is simply print work okay so what I've
06:13 - actually done here and I know this is
06:15 - gonna be weird for many of you that have
06:17 - not seen this before is created a class
06:19 - called duck what this means is I'm gonna
06:22 - make my own kind of blueprint now for
06:24 - any objects that are of type dog and I'm
06:26 - gonna start defining the operations that
06:29 - a dog is able to do now in this case
06:31 - I've created a method now a method is
06:33 - essentially just a function that goes
06:35 - inside of a class that's the easiest way
06:37 - to define it and for our basic example
06:39 - right now
06:40 - all of our methods are gonna start with
06:42 - a parameter called self and we're going
06:44 - to talk about what this self parameter
06:45 - means and how all this works later on
06:47 - but let's kind of build our way up to
06:49 - that so I'm gonna say D equals a dog
06:51 - down here and what I've done when I did
06:54 - this here is I'm actually saying okay
06:56 - I'm gonna have the variable D and I'm
06:58 - going to assign it to a instance of the
07:00 - class dog so this is class dog again you
07:03 - don't need to know how this works right
07:04 - now we're gonna talk about that in a
07:05 - second but when I write this line here
07:07 - and I put dog which is the name of my
07:08 - class and then two brackets like that
07:11 - I am instantiating right creating a new
07:13 - instance of the class dog so D is now
07:16 - gonna be an object that is of type dog
07:18 - and notice that we don't get any errors
07:20 - there and when I decide to print out
07:22 - type of D we're gonna see that we get
07:25 - class underscore underscore main
07:26 - underscore R squared dog now the reason
07:28 - we have these underscores is because
07:30 - this is telling us what module this
07:32 - class was defined in now by default the
07:35 - module that you run is called the main
07:37 - module that's why we have these two
07:38 - underscores main underscore underscore
07:40 - but we can see that this is again an
07:42 - object of the class dog and that means
07:45 - that whatever we define inside of here
07:48 - is going to be what is allowed or the
07:50 - operations that can be performed by a
07:52 - dog and one of those operations is bark
07:55 - so this is a method remember we've
07:57 - talked to a method just like dot upper
07:58 - before so if I want to use that method
08:01 - on an instance of my dog class because
08:04 - this is an instance of the class dog
08:06 - then what I can do is I can type well
08:08 - not upper but dot bark like that so I
08:11 - can call this method on my dog object
08:14 - again because it is a class dog and I've
08:16 - defined a method that works for dogs so
08:19 - when I do that we can see that we get
08:20 - bark and then it still obviously
08:22 - continues to print the type of that
08:24 - object so this is what we're getting out
08:27 - here so these are kind of how classes
08:28 - work we name the class typically the
08:31 - convention is to use an uppercase letter
08:33 - and usually you go camel case so you do
08:35 - like dog like you say we're gonna do two
08:37 - words you do like dog hello right so
08:39 - camel case like that and then inside of
08:41 - the method or inside the method inside
08:43 - of the class you can define a few
08:45 - different methods and operations that
08:47 - can be performed by this object so what
08:49 - I'm gonna do is I'm gonna say define I
08:51 - don't know let's just say meow I know
08:53 - this is wrong because it's not a dog and
08:56 - we'll talk about self in just a minute
08:57 - but I can define another method here and
08:59 - instead of printing something I could
09:01 - say return let's just say yeah like that
09:05 - so I don't necessarily need to print
09:06 - something I can return something I can
09:08 - have these methods take arguments so
09:10 - maybe I have meow and then I put X and
09:12 - maybe what I do is I return X plus 1 or
09:15 - something like that so maybe let's just
09:16 - call this add call this add underscore 1
09:19 - that'll be the name of our method so I
09:20 - can return X plus 1 and then what I
09:22 - could do if I want it here is like it's
09:24 - a dog add underscore 1 put 5 there and
09:27 - let's print out the value that we get
09:29 - let's have a look at this year and we
09:32 - can see that we get the value 6 so we
09:34 - can make methods that have different
09:35 - arguments associated with them or
09:37 - parameters like I've put X here and that
09:39 - just means that when I call that method
09:40 - I need to pass in a specific value or
09:43 - specific values so that that can operate
09:45 - and that can work so that is how the
09:48 - methods work so now we're gonna talk
09:50 - about itself but before we can do that
09:51 - we need to talk about what's called the
09:53 - anit method which you may have seen me
09:55 - typing at the beginning before I kind of
09:57 - gave up on X I didn't want to get that
09:58 - complex that fast so right now we have
10:00 - two methods we have this bark method and
10:03 - we have this add one method and I hope
10:05 - those makes sense on how those work and
10:06 - now we're gonna talk about this special
10:08 - method here and by the way this has two
10:10 - underscores so it has underscore
10:11 - underscore and then an it and then
10:13 - underscore underscore now this is a
10:16 - special method and what this pretty much
10:18 - allows us to do is instantiate the
10:20 - object right when it is created so this
10:23 - method will be called whenever we write
10:25 - this line so whenever we create a new
10:27 - dog instance by writing dog and then the
10:29 - two brackets let me get rid of this down
10:31 - here for right now this method will be
10:33 - called and it will pass any arguments
10:36 - that we put in here so maybe I put
10:37 - something like Tim in here it will pass
10:40 - that to this method so let's say that
10:43 - every time we create a dog and we want
10:45 - to give it a name immediately so to
10:46 - create a dog the criteria is that you
10:48 - must give it a name well what we would
10:51 - do in here is we would put the parameter
10:54 - name and then here we would pass in the
10:57 - name so what we need to do though is
10:59 - what we're passing in this name we need
11:01 - to store this in the dog object
11:03 - somewhere right we need to have this
11:05 - stored we need to be able to access this
11:07 - this is kind of the nice thing about
11:08 - objects and this is where we're gonna
11:10 - talk about attributes what we can do if
11:12 - we want to store this name is we can say
11:14 - self dot name equals name now it's
11:18 - important to note that this doesn't
11:19 - these don't need to match but what we've
11:21 - just done here is we've created what's
11:22 - called an attribute of the class dog
11:25 - which is name so what this means is
11:28 - essentially every time we create a new
11:30 - dog object we will pass a name through
11:32 - this parameter so self just stays here
11:34 - to denote the object itself so like
11:37 - every time one of these things is called
11:39 - we will pass a reference to which object
11:42 - it was called on so we can access things
11:44 - for each specific object and we'll talk
11:46 - about that more in a second but here
11:48 - what I've done is to find an attribute
11:49 - called name which is equal to the name
11:51 - that we passed in so what I'll do is
11:53 - immediately I'll just print inside of
11:56 - here the name so that we can see how
11:57 - this works and notice that when I run
11:59 - this now we get Tim printing out so even
12:02 - though I didn't explicitly call this an
12:04 - it method because I wrote this line here
12:06 - it passed this name that I put in here
12:09 - to the name parameter and then it
12:11 - printed out name here inside of the
12:13 - Anette and we also defined an attribute
12:15 - called name that is inside of this dog
12:19 - class so what self is doing is every
12:21 - time that any of these methods is called
12:23 - kind of invisibly you don't get to see
12:25 - it
12:26 - the actual reference to this dog object
12:28 - is passed so that we can access
12:30 - attributes that are specific to each dog
12:32 - and what I mean by that is I can make
12:34 - another dog so maybe I say d2 which is
12:37 - you know another instance of the class
12:39 - dog except this time I named it's Bill
12:42 - right and now we'll do the print
12:44 - statement again so we'll say print name
12:46 - just to show how this works and here we
12:48 - get Tim and we get Bill so we actually
12:50 - have two different dog objects now one
12:53 - named Tim and one named Bill and they
12:55 - both store different names inside of
12:57 - there you know
12:59 - instance if that's what you want to call
13:00 - it so let's just show how this attribute
13:02 - works so the point of this attribute is
13:04 - that it's stored permanently for each
13:06 - specific object so I can actually go
13:08 - ahead and go down here and print D dot
13:10 - name after that's defined and I can
13:12 - print D - dot name like that and when we
13:17 - look here we can see that those names
13:19 - get printed out so Tim and Bill
13:20 - notice that I remove the print statement
13:22 - from up here so these attributes when we
13:24 - do something like a self dot and then
13:26 - anything that we want we can call
13:27 - whatever we want is equal to some value
13:29 - we can reference them later on and we
13:31 - can reference them from methods inside
13:33 - of our class so an example of that is
13:35 - something like say define get underscore
13:38 - name so the first argument here is
13:40 - always gonna be self are the first
13:42 - parameter and the reason for that is
13:44 - because we need to invisibly pass the
13:46 - actual you know dog object itself so
13:49 - that we know which dog were accessing
13:51 - when we're gonna get say the name of the
13:53 - dog so here we're gonna say define get
13:55 - name and all we're gonna do is return
13:58 - self dot name like that so now rather
14:00 - than saying dot name we can call thought
14:02 - get underscore name which is a method
14:04 - right and we can do that down here as
14:06 - well get underscore name and then we see
14:09 - that we get Tim and we get Bill so that
14:12 - is the basics behind objects now of
14:14 - course I can make more attributes as
14:15 - well so I could do something like H so
14:17 - let's say my dogs I want them to have a
14:19 - name so let's say my dogs want them to
14:22 - have a name and an age well what I'll do
14:25 - now is I'll say okay so in our
14:26 - initialization for dog we're going to
14:28 - take a name and we're gonna take an H so
14:31 - we'll define the attributes in here so
14:33 - self dot age is equal to whatever age we
14:34 - passed in and now every time that I make
14:37 - a new dog object I need to pass a name
14:39 - and an age so these this Tim will be an
14:42 - old dog here bill will be a young one
14:44 - and we'll run this and we see that we
14:46 - get no issue and if I wanted to I can go
14:48 - ahead and define another method here so
14:49 - get age and we'll return self dot age
14:54 - like that and if we change this to get
14:56 - inch and we change this one down here to
15:00 - get age as well what is the issue here
15:03 - oops
15:04 - so I'm forgot to put myself in here so
15:06 - notice what happened when I forgot to
15:08 - put myself so that's actually a decent
15:09 - error to run into I didn't put self in
15:11 - here as a parameter and you can see I
15:14 - know that it's kind of messy here it
15:15 - says get age takes zero positional
15:16 - arguments but one we're given so what
15:18 - does that actually mean so it's saying
15:20 - it takes is your arguments which it did
15:22 - when I didn't himself here but one was
15:24 - given but I didn't give any arguments
15:26 - inside of the brackets well that's
15:27 - because when we call a method this right
15:30 - the actual dog object itself immediately
15:33 - kind of been
15:33 - Blee gets passed to that method as the
15:35 - self parameter so we know which dog it's
15:38 - talking about so now if I go ahead and I
15:39 - add self we can see that this works fine
15:41 - and we get thirty-four and we get twelve
15:42 - so that's important thing to remember
15:44 - now what we can actually do is we can
15:47 - create other methods that modify these
15:49 - attributes or create new attributes so I
15:51 - can do something like for example set
15:52 - age so I in sight define set age will
15:55 - give itself of course and then we'll put
15:56 - an age here what I can do now is say
15:59 - self thought age is equal to H and now
16:01 - what I'm gonna do for Tim and we'll get
16:03 - rid of Bill for now because I think we
16:04 - get the point on how it works for
16:05 - different objects isn't gonna say D dot
16:08 - set underscore age and I'm gonna change
16:09 - his age to 23 and when we print it out
16:12 - we can see that 23 actually gets printed
16:14 - out so we can modify and we can access
16:17 - these different attributes from methods
16:19 - inside our class and this is where thing
16:21 - gets things get very powerful because
16:23 - this allows us to access data that is
16:26 - stored within a specific object and do
16:28 - different things with it based on how
16:30 - different methods and different things
16:32 - are being called right and this just is
16:35 - pretty much the blueprint that defines
16:37 - how a dog actually works how it operates
16:40 - what it can do the methods associated
16:42 - with it and the attributes that exist
16:44 - now some of you may be saying well why
16:45 - do I need to do this right like this
16:47 - seems kind of redundant I could write in
16:50 - a different style well the nice thing
16:51 - about object-oriented programming is
16:53 - once you create one of these classes you
16:55 - can have an infinite amount of instances
16:57 - of this class without having to change
16:59 - anything so let's say for example that
17:01 - we'll leave that class up here right now
17:03 - but we want to simulate what we've just
17:05 - done here for the Tim dog right we want
17:07 - to have an age and we want to have a
17:09 - name and we want to be able to change
17:10 - his age and all that well many of you
17:12 - that were more beginner programmers
17:14 - would probably tell me we can do
17:15 - something like this we can say dog one
17:16 - underscore name equals Tim you could say
17:20 - dog one underscore age equals you know
17:24 - 34 and there you go you just defined
17:26 - these two attributes if you want to get
17:28 - it you can just access the variable if
17:29 - you want to change it you can just
17:30 - change the variable okay nice but what
17:33 - happens when I want to make 25,000 dogs
17:36 - or every time I run my code I want to
17:38 - make a different amount of dogs you
17:39 - can't find a way that you can write all
17:42 - these different variables that have one
17:43 - two three all the way up to 50,000 or
17:46 - however many dogs I have
17:47 - to represent that that's why we use
17:49 - objects is whenever we're going to be
17:51 - kind of reusing something there is some
17:53 - instances in which we make a class where
17:56 - that we're only going to use once or
17:58 - instantiate once but those are kind of
18:00 - more complex
18:01 - examples we won't get into here but then
18:02 - okay so some of you might tell me all
18:04 - right well Tim I can just do lists I can
18:06 - say dogs equals that we say dogs
18:08 - underscore name equals that right and
18:10 - here we can put well the first name is
18:13 - Tim and then we had fill so this will
18:16 - handle the idea that we can't just have
18:19 - all these different variables right so
18:20 - dogs age equals and then we go let's say
18:23 - I don't know 32 14 okay that's great but
18:27 - the issue with this is that it's really
18:29 - a pain when I want to access the dog's
18:32 - age the dog's name and then what if I
18:34 - had like 25 other attributes or methods
18:36 - associated with the dog this is just
18:39 - just a paint you don't want to deal with
18:40 - that because I have to now find the
18:42 - index of whatever dog I want in one list
18:44 - which is a very time-consuming operation
18:46 - in computing and then I need to
18:48 - reference that index and all the other
18:49 - lists for all the other attributes and
18:51 - it just becomes very messy very quickly
18:52 - and let's say I want to delete one
18:54 - instance like feed you know the dog
18:57 - object bill or something like that right
18:59 - then I need to find the index of this I
19:01 - need to find the index of all of the
19:03 - attributes and all the other lists and I
19:05 - need to delete them at the same time to
19:06 - make sure that all my data stays
19:08 - consistent and there's no kind of
19:09 - offsetting things or too many attributes
19:11 - in one list so it's just as a pain to do
19:13 - it like that so I hope this makes sense
19:15 - on why we would do object-oriented style
19:17 - and now what we'll do is go into one
19:19 - example where we create a more complex
19:21 - object and show kind of the advantage of
19:23 - that ok so a lot of people typically
19:25 - will stomp at kind of the previous
19:27 - example that I just gave you now I want
19:28 - to go a little bit further and show you
19:30 - the advantage of doing multiple classes
19:32 - so rather than just using one class I
19:34 - want to show you how different classes
19:36 - can kind of interact in an example where
19:38 - I have a bunch of students these
19:40 - students all have some grade assigned to
19:42 - them and they're all a part of a course
19:43 - and then that course will have some
19:45 - methods on it to do things like find the
19:47 - maximum grade of all students give us
19:50 - the average grade of all students tell
19:51 - us the lowest grade some things that you
19:53 - may actually want to do say if you were
19:55 - trying to model or create a system for
19:57 - you know a school or something like that
19:58 - right so this is obviously going to be a
20:00 - little bit more of an example as opposed
20:02 - to super practical but hopefully this
20:03 - should give you some more insight into
20:05 - how we would do something like that so
20:07 - I'm going to start by cleaning creating
20:08 - a class called student I'm gonna go a
20:10 - little bit faster here but I will slow
20:11 - down and talk about what I've done after
20:13 - so don't worry if you can't keep up so
20:15 - we're gonna have a student and each
20:16 - student is gonna have a name age and
20:17 - eighth grade so we're just gonna say
20:20 - self the name equals name self dot age
20:23 - equals age and then self dot grade
20:26 - equals grade
20:28 - now this numeric grade is gonna be
20:30 - between 0 and 100 so I'll just write
20:32 - that down here just so we know that and
20:34 - that should be good for our students so
20:37 - we could of course go in here and add
20:38 - some methods if we wanted something like
20:40 - get underscore grade and what does ID 1
20:42 - just so we have it in here and what we
20:44 - can do is return a self duck grade like
20:47 - that okay so this is this is where we're
20:49 - gonna leave our student now we could add
20:52 - a lot more things to this we could add a
20:53 - change grade we could you know add a
20:55 - test we can have weightings we can do
20:57 - all kinds of crazy stuff but for now
20:59 - we're gonna leave it at that so again
21:01 - we've defined three attributes here we
21:02 - have a name and age and a grade those
21:04 - are equal to the name age and grade that
21:07 - we pass in when we initially create a
21:08 - student and then we have one method
21:10 - remember this is a method and it simply
21:12 - returns a student's grade now I'm going
21:15 - to make a new class called course now
21:17 - what I'm gonna do in this course class
21:19 - is I'm gonna have the ability to add
21:21 - students to a course so when we create a
21:23 - new course what we're gonna need to do
21:25 - is we need to define the name of the
21:28 - course and the max underscore students
21:30 - that can be enrolled so in here we'll
21:33 - say self dot name equals name and self
21:36 - dot max underscore students equals max
21:40 - underscore students like that all right
21:43 - so what we're gonna do now is we're
21:45 - gonna add a method that will allow us to
21:47 - actually add students to this course but
21:50 - how are we gonna do that
21:51 - how are we gonna have students stored
21:53 - inside of a course object well what we
21:55 - can actually do is we can make a list of
21:58 - students so I'm gonna say self thought
21:59 - students equals a blank list now notice
22:02 - that I've made an attribute and I didn't
22:04 - assign it directly to one of these
22:06 - things that was passed into one of these
22:07 - parameters arguments whatever you'd like
22:09 - to call them that is totally fine in
22:11 - fact a lot of times will create
22:12 - attributes like self dot you know
22:14 - is active something like that equals
22:17 - false right we can do that that's
22:19 - totally fine and attributes are just
22:21 - whatever we decide to define and if we
22:23 - want to assign them to say the argument
22:25 - or parameter that's here that's fine and
22:29 - we can do that so there we go we have
22:30 - self-doubt students which is a blank
22:31 - list and I'm gonna start by creating a
22:33 - method here that's going to allow us to
22:35 - add a student object into this list so
22:38 - I'm going to say define add underscore
22:41 - student like that and in here antic self
22:44 - and we're actually going to take student
22:45 - now this student right here is actually
22:48 - going to be an instance of a student
22:50 - object and I'll show you what I mean by
22:52 - that in a second but all we're gonna do
22:53 - is say if the length of self dot
22:58 - students is less than and in this case
23:01 - self thought max underscore students
23:03 - then what we'll do is we'll say self dot
23:06 - students dot append student so we're
23:11 - gonna create a list of students inside
23:13 - of this you know this list right here
23:15 - right that's what we're gonna do and
23:17 - we're gonna add them in only if this is
23:20 - less than the maximum students in the
23:21 - class and what I'll do is I'll actually
23:23 - return true if the student was added
23:24 - successfully and then down here I'll
23:27 - return false if not so that we can tell
23:29 - maybe if we make a program down below if
23:32 - that student was added properly or not
23:33 - now I'm gonna add another method and
23:35 - here I'm gonna say define yet average
23:39 - great now wolf code that one out in a
23:41 - second but let's do an example of how we
23:44 - can actually now add students to these
23:46 - class so I'll make that a bit smaller so
23:47 - we can read it so let's make a few
23:49 - different students so let's say s 1
23:52 - equals student what do we need to pass
23:55 - for student and named agent grades let's
23:57 - call that Tim let's call that 19 and
24:00 - let's call that 95 Tim's a smart guy all
24:02 - right and then we'll do s2 equals
24:04 - student we're gonna say bill we'll put
24:07 - him at 19 as well and he's not as smart
24:10 - he is 75 and then let's do s3 equals and
24:14 - let's go
24:16 - Jill keep with the trend Tim billed Jill
24:19 - 19 and maybe she has a 65 ok
24:23 - so we've created three students here and
24:25 - these students are proper they should
24:27 - work fine let's run this
24:28 - make sure everything's all right now how
24:30 - can we actually add them to our course
24:32 - well the first thing we need to do is
24:33 - make our course so we're gonna say
24:34 - course equals course like that what do
24:38 - we need when we make a course we need a
24:39 - name and we need a maximum amount of
24:40 - students so let's name this course let's
24:44 - say science or something like that and
24:46 - let's say the maximum amount of students
24:48 - is actually gonna be 2 because I want to
24:49 - show what happens when we add a student
24:51 - past the maximum now we're going to add
24:54 - students so how do we add them well we
24:55 - have to call that method so course dot
24:57 - add students so there we go we can add
24:59 - student s1 and then let's do course dot
25:02 - add student again and let's add s2 so
25:06 - now let's run this we see everything
25:08 - works fine and let's actually make a
25:10 - thing that can you know print out some
25:12 - thing about our student or can show our
25:14 - students so what I could do is I could
25:16 - say let's print down here course dots
25:19 - and this students and let's have a look
25:22 - here and we get main student object on
25:24 - some gibberish location main student
25:26 - object at some gibberish location so
25:29 - what this is actually telling us is both
25:31 - of these things inside our list right
25:32 - now our student objects and notice what
25:36 - I can actually do is let's say I index
25:38 - the zeroth item in that list so the
25:39 - first student that we added and I decide
25:41 - to call dot name on it well then that
25:45 - should hopefully print out the name of
25:46 - that first student which is 10 so that's
25:49 - cool and that's how we do that right we
25:51 - can add things in to this course so now
25:53 - this course stores all of our students
25:55 - and since all of these students have a
25:57 - grade on them inside of our course we'll
25:59 - be able to access that so now that we've
26:01 - done that let's write this method that
26:03 - can get the average grade of all of the
26:05 - students that are enrolled in the course
26:07 - to do that what we're going to need to
26:09 - do is grab all the students from the
26:11 - students list we're gonna need to add
26:12 - that to an average and then we're gonna
26:14 - need to divide that value to figure out
26:16 - what that is so what we'll do is we'll
26:18 - say value equals 0 we're gonna say for
26:22 - student in in this case self dot
26:26 - students then we're gonna say value plus
26:31 - equals student the duck gets grade like
26:35 - that now notice that we could just type
26:37 - great if we wanted to but I usually just
26:40 - like to use the method because say
26:41 - we were to change any attribute later
26:43 - then this code wouldn't break so long as
26:46 - this method was still named the same
26:47 - thing and we can modify the method in
26:49 - here so they returned the proper grade
26:51 - like say we had a student enrolled in
26:52 - multiple courses then we could you know
26:55 - determine their grade in a different way
26:57 - and when we called get grade maybe we
26:58 - don't just return self grade we return
27:00 - something different so this still
27:01 - continues to work
27:02 - so we'll say value plus equals student
27:04 - get grade and now all will simply do is
27:07 - return in this case value divided by V
27:12 - Len of self dot students so let's see
27:15 - what the average grade of our courses so
27:17 - course get fabric grade will actually
27:19 - print that out like that and run that
27:23 - and we can see that the average grade is
27:24 - actually 85 and that makes sense with
27:26 - the grades that we have here so that's
27:28 - the idea behind what I'm trying to show
27:31 - you is that we have you know we can have
27:33 - different classes we can have attributes
27:34 - with them and when we can program an
27:36 - object-oriented style now it doesn't
27:38 - matter how many students we have or how
27:40 - many different courses we have and what
27:41 - students are enrolled in which in fact
27:44 - what we could do is we could make
27:45 - another course we can add the same
27:47 - students to it and then we would
27:49 - obviously have to change the way that
27:50 - their grade was calculated but that's
27:52 - something that we could do now let's
27:53 - just look at what happens when I decide
27:55 - to try to add that third student so
27:57 - course start add student like that and
28:00 - we decide to add student s3 we can see
28:02 - that we get the value false and notice
28:05 - that the average grade does not change
28:06 - because we didn't actually add that into
28:09 - the course right okay so we finished off
28:11 - the basics on classes and objects and
28:14 - how to create our own classes and
28:15 - hopefully that last example helped you
28:16 - to really kind of understand the
28:18 - advantage of doing this now what we're
28:20 - going to talk about here is something
28:21 - called inheritance now this is where we
28:23 - slowly start getting to a little bit
28:24 - more complex and some more difficult
28:26 - concepts so try to follow along but I
28:28 - don't find inheritance as that extremely
28:30 - difficult so the idea behind inheritance
28:33 - and we'll show what that is in a second
28:35 - is you have two classes that are very
28:37 - similar so let's say we have a general
28:40 - class called maybe alright let's do a
28:43 - better example let's say we have a class
28:44 - called dog and a class called cat and in
28:46 - fact let's actually code these out so
28:48 - that we can see this for real so let's
28:50 - say in the init method of the cat what
28:51 - we're gonna do is we're gonna have self
28:53 - name
28:54 - and age like that so we're going to say
28:56 - you know self dot name equals if I can
29:00 - type properly which apparently is not
29:02 - happening right now and then self dot
29:04 - age and then we'll do define speak and
29:07 - all we'll do in here is just print you
29:10 - know what is this cat yeah okay and then
29:13 - let's say we have a dog
29:14 - so we'll say class dog like that and
29:17 - we'll define underscore underscore net
29:19 - on our squander square put the self put
29:21 - the name put the age because that's all
29:23 - we want for that and we'll say self dot
29:24 - name equals name self dot age equals age
29:30 - and then define here speak and the only
29:33 - difference between these two classes is
29:34 - actually gonna be the fact that this
29:36 - prints bark instead of meow so notice
29:40 - that these two classes are almost
29:42 - identical in fact there's only one line
29:43 - of code that's different other than the
29:44 - class definition at the top so there
29:47 - must be a way that we don't need to
29:48 - write this twice that we can actually
29:50 - use what's called inheritance so that
29:52 - these dog and these cat classes can well
29:54 - inherit from an upper level class which
29:56 - means that all that functionality is
29:58 - defined in one place and we only need to
30:00 - write what's different about those two
30:02 - classes inside of them so ideally what I
30:04 - would like to have is to be able to
30:05 - remove this init class from both of
30:07 - these and just have the speak method
30:09 - because the only thing that's specific
30:11 - to a cat in a dog at least for my
30:13 - example is the fact that one of them
30:14 - says meow and one of them says bark so
30:17 - let's get show how we can actually do
30:18 - them so by removing that you know was an
30:22 - it method and just having these methods
30:25 - here what we need to do is make an upper
30:27 - level class which I'm actually gonna
30:29 - call pet so I'm gonna say class pet what
30:32 - I'm gonna do in here is define that an
30:34 - it method that we had before I'm
30:36 - actually gonna define a let's say show
30:39 - so this show method is just gonna show
30:41 - me all the things about my objects so
30:44 - I'm gonna say print and in here we're
30:46 - gonna say you know I'm actually gonna
30:47 - use an F string you may not know what
30:49 - that is but don't worry about it I am
30:52 - self taught name and I am self dot age
30:57 - years old okay so what I've done is I've
31:00 - defined this pet class and this pet
31:02 - class essentially is going to contain
31:04 - the functionality that I want the cat
31:06 - class and the dog
31:07 - class both to have and then in sign of
31:10 - the cat class and inside of the dog
31:11 - class what I'll do is I'll define the
31:14 - methods or the attributes or whatever it
31:16 - is that I need to do that are going to
31:18 - be different for this specific class so
31:21 - notice that pet is general we call this
31:23 - a generalization
31:25 - whereas cat and dog are more specific so
31:27 - how do I actually allow the cat class in
31:30 - the dog class to use this functionality
31:31 - well what I can do is simply add
31:34 - brackets and write pet
31:36 - now what this stands for is I am
31:39 - inheriting the upper level class pet so
31:43 - we're saying this is the general class
31:44 - this is a more specific class that's
31:47 - being created and inherits from pet and
31:49 - the same thing with dog let me show you
31:52 - how this works so let's create an
31:54 - instance first of all of the pet class
31:56 - and then we'll make one of the cat and
31:58 - the dog class and I'll show you how it
31:59 - works
32:00 - so let's say P equals pet notice that
32:03 - for pet we need a name and we need an
32:05 - age so let's say it's him let's put him
32:08 - at 19 and then let's do P dot Show so
32:11 - let's look at this year I am Tim and I
32:13 - am 19 years old so that is how the pet
32:15 - class works pretty straightforward now
32:18 - let's make a cat class so let's say C
32:20 - we're gonna say C equals cat I'm gonna
32:23 - say the cat's name will be Bill and that
32:26 - cat will be 34 like that and then let's
32:29 - do the same thing here see nutshell now
32:31 - notice that even though there's no
32:33 - method called show inside of cat it
32:35 - still pops up and says I am Bill and I'm
32:38 - 34 years old
32:39 - that is because it inherits inherits the
32:42 - properties from the pack class because
32:44 - I've defined that up here and notice
32:46 - that even though I didn't defined in an
32:48 - it method in here this still worked fine
32:50 - right there's you know this was okay we
32:53 - initialized because we use the anit
32:54 - method that was defined inside a pet and
32:56 - of course we can do the same thing with
32:58 - dog so we can say D equals dog what do
33:01 - we call this one before Jill 25 and
33:04 - let's do D dot shell like that we go I'm
33:07 - jail and I'm 25 years old so that works
33:10 - but now let's show what happens when we
33:12 - call speak on the cat and the dock so if
33:15 - I decide to call speak like that and
33:18 - we'll call it on both of them here
33:20 - you can see that we get me out and we
33:22 - get bark and again that's because this
33:24 - speak method is different for the cat
33:26 - class and different for the dog class
33:27 - and since its defined inside of here and
33:29 - we created an instance of cat when we
33:31 - make a cat instance well we're gonna use
33:34 - the speak method that's defined here and
33:36 - in fact what I could actually do is
33:38 - define speak up here and I could say
33:41 - define speak and I could say print I
33:44 - don't know what I say like that okay and
33:50 - then if I decide to change this from
33:53 - show to speak notice that we're calling
33:56 - speak three times speak is defined here
33:58 - and it's defined in both of our child
34:00 - classes is what we call them so when
34:01 - they when this is the upper level class
34:03 - the more general version any classes
34:05 - that inherit from it are known as the
34:07 - child classes or the derived classes um
34:10 - that's not that important to know but
34:11 - just you know figured out through that
34:13 - lingo out there and notice that when I
34:14 - run this we get I don't know what to say
34:16 - meow and bark so if there is a method
34:19 - defined in the lower-level class or the
34:21 - child class that is the same name as the
34:24 - upper level class it will automatically
34:26 - override that method so it will take
34:28 - over anything that's defined in here is
34:30 - more specific to this class so it will
34:32 - use that rather than using this upper
34:35 - one right and you might ask well why
34:36 - would we even bother defining one in
34:38 - here if it were just gonna take it over
34:39 - later well we might create another pet
34:42 - right maybe like a fish or something for
34:44 - example like I can do something like
34:45 - this class fish pet like that I can
34:50 - literally just define that and put pass
34:52 - inside of here and now what I can do is
34:54 - say okay let's say F equals fish and
34:57 - then we need a name so let's call this
35:00 - bubbles why not give it ten and now we
35:03 - can say F dot speak and notice that we
35:06 - get I don't know what to say
35:07 - for this fish class because there was no
35:09 - speak to find inside of here it used the
35:12 - speak that was defined in the upper
35:13 - level or parent class right the one that
35:16 - we inherited from so that is the basis
35:18 - behind inheritance now it gets a little
35:20 - bit more complicated I'm gonna show you
35:22 - the more complex out aspects because
35:24 - let's say I want to add one attribute to
35:27 - my cat so let's say that for cats we
35:28 - actually care what color those cats are
35:30 - as well well what I would need to do to
35:33 - do that is
35:34 - this initialization method right because
35:35 - I want to pass it and when I create a
35:37 - cat but I don't necessarily want to
35:39 - rewrite this whole thing so what I'm
35:40 - gonna do and I'm kinda need to rewrite
35:43 - the whole thing but you'll see why we
35:45 - would actually do this in a second I'm
35:47 - gonna say self name age cover like that
35:51 - and now all I'm gonna do let me say self
35:54 - dot color equals color so what some of
35:58 - you may say here now that we've defined
35:59 - the color in here is that what we should
36:00 - do is take this name and age right just
36:02 - copy it and paste it in here now that
36:05 - would be a correct answer but I'm gonna
36:07 - tell you why we shouldn't do that so the
36:10 - idea here is that sometimes in the
36:12 - initialization method of our parent
36:14 - other things are happening other than
36:16 - just redefining attributes right and in
36:19 - that instance it would not be correct
36:21 - for us to simply omit the fact that
36:24 - we're not gonna call this a net from the
36:26 - parent we're just gonna define the
36:27 - attributes because that could mean that
36:29 - we miss out on a very important you know
36:31 - function that's happening from inside of
36:33 - this initialization to give you an
36:34 - example like saying some web
36:36 - applications maybe this initialization
36:37 - actually calls a database right and an
36:40 - ask for some information for a database
36:42 - and it sets up the object using that it
36:44 - wouldn't necessarily be correct then for
36:46 - me to just you know take the attributes
36:48 - that we're in here and just redefine
36:50 - them as attributes here I would actually
36:52 - still need to call that initialization
36:54 - to make sure the object was set up
36:55 - properly so to ensure that that happens
36:57 - when we do an inheritance like this we
37:00 - do need to define the arguments that we
37:02 - need are the parameters that we need for
37:04 - the parents initialization so name age
37:06 - but there's a fancy way to call that so
37:09 - rather than you know rewriting this here
37:11 - I can actually explicitly call this and
37:14 - set up our object that way so to do that
37:16 - I'm gonna say self are super
37:19 - underscoring square net done underscore
37:20 - underscore name age now what this is
37:23 - saying is super stands for reference the
37:26 - superclass and the superclass is
37:28 - actually the pet class or the class that
37:30 - we inherit from here so that's what
37:32 - super stands for the class that we are
37:34 - have inherited from then underscore
37:36 - underscore net underscore underscore
37:37 - defines the method that we want to call
37:39 - right and then name and age are the
37:42 - arguments that we're going to pass to
37:43 - that so name and age notice I don't need
37:46 - to pass cell that's fine we don't
37:47 - self and it's gonna call that and what's
37:49 - gonna happen is it's gonna run
37:51 - whatever's inside this initialization
37:52 - then that's gonna set up the name and
37:54 - the age for our object so we will have
37:56 - those properties defined and then we
37:59 - will call self duck ah they're equals
38:00 - color or we will execute that line so
38:02 - now we have the cover right and if I
38:04 - just go ahead and want to define here
38:06 - show so I want to change this show
38:08 - method maybe for this cat object then
38:11 - what I can do is I say I am self that
38:12 - name and I'm self that age and I am and
38:15 - in this case self dot color right so we
38:19 - can change the show method in here and
38:21 - now let's go to cat let's change this to
38:23 - show let's add a color because we need
38:25 - to add a color now we have to find that
38:27 - in the Annette and let's run this and
38:29 - see what the issue is now that we're
38:30 - getting fish is not defined oh did I do
38:35 - I guess I've deleted fish or we got rid
38:39 - of it at some point I did not remember
38:40 - okay so anyways let's run this and we
38:43 - can see that we have I don't know what
38:44 - to say I'm Bill and I'm 34 years old and
38:46 - I am brown and then we get bark right so
38:48 - that is how that works for inheritance
38:50 - and this is how we call the super class
38:52 - or the upper level parent class right we
38:54 - need to call this initialization method
38:56 - before we just go ahead and do anything
38:58 - else because that parents initialization
39:00 - may be important it may do other things
39:02 - it may call another method right so we
39:04 - can't just simply skip that we need to
39:06 - call that explicitly by writing this
39:08 - line now this line is kind of
39:09 - complicated syntax you know it's easy to
39:11 - forget but try to remember it super
39:14 - again references the parent class pet
39:16 - and then we have an it and like that so
39:19 - I hope that gives you an idea on how
39:21 - inheritance works now it's hard to give
39:23 - really good inheritance examples without
39:25 - going more complex and more into detail
39:27 - so I'm gonna admit doing that for now
39:30 - but just remember that when you have
39:31 - classes that do a very similar thing
39:33 - they have almost everything identical
39:35 - except maybe a few attributes or a few
39:36 - methods it might be a good idea to what
39:38 - we call generalize and make a parent
39:41 - class that is a general class that
39:43 - defines functionality will be used in
39:45 - all of your child classes and that is a
39:48 - very common practice and object-oriented
39:50 - programming to use inheritance for
39:53 - example a very good example is for
39:56 - example a good example is something like
39:57 - person hierarchy so let's say you have
40:01 - you're working in an organization and
40:03 - the example we want to consider is we
40:05 - have managers and we have employees now
40:08 - managers have different access than
40:10 - employees but employees and managers
40:12 - have very similar properties they all
40:13 - have a name they'll have an age they'll
40:14 - have an ID they have a birthdate they
40:16 - have many different things that they are
40:18 - the same for both of them well if we
40:20 - were trying to model that system and we
40:21 - were gonna program that and make that
40:23 - what we would likely do is create an
40:25 - upper level general class called person
40:27 - that defines all of the attributes and
40:30 - all of the methods that are general to
40:32 - all people whether they are managers or
40:34 - employees and then we would create two
40:36 - child classes one for employee and one
40:39 - for manager and that would define the
40:40 - specific things that the manager can do
40:43 - and that the employee can do that are
40:45 - different from each other
40:46 - so that's the idea behind inheritance
40:47 - hopefully that makes sense and now let's
40:49 - move on to our next topic okay so now
40:51 - it's time to talk about static and class
40:53 - methods and class attributes and in fact
40:55 - we're actually going to start with class
40:57 - attributes now previously you would have
40:59 - seen that every time we defined an
41:01 - attribute for one of our objects we used
41:03 - self right and inside the class we had
41:05 - self every where self was referring to
41:07 - the instance in which we were talking
41:09 - about in that you know context right so
41:12 - here what we're gonna do now is talk
41:13 - about class attributes now class
41:15 - attributes are attributes that are
41:17 - specific to the class not to an instance
41:20 - or an object of that class so I'm gonna
41:23 - do a basic example where I just create a
41:25 - class person and I'm gonna say number of
41:28 - people equals 0 now in here I'm gonna
41:31 - define the NIT method and say to find an
41:33 - it like that and we're just gonna say
41:35 - each person will simply have a name keep
41:37 - it nice and simple like that so self
41:40 - that name equals name now let's make p1
41:41 - person we'll talk about what I've done
41:43 - in a second here in case anyone's
41:44 - confused and let's say p2 equals person
41:48 - let's make this Jill okay so we have
41:52 - this number of people thing and I'm sure
41:54 - a lot of you're like what the heck is
41:55 - that well this is a class attribute and
41:57 - the reason it's not a regular attribute
41:59 - is because it does not use self so
42:02 - because it's not defined inside any
42:03 - method because it does not have access
42:05 - to an instance of the class it is
42:08 - defined for the entire class which means
42:10 - that
42:11 - this is not specific again to any
42:13 - instance it's not gonna change with from
42:15 - person to person whereas we know
42:16 - something except that name will be
42:18 - different for each instance of the
42:20 - person class this is not different for
42:23 - each instance of the person class in
42:24 - fact it's the same so what I can show
42:27 - you is that I can actually go ahead and
42:28 - print say you know p1 dot number of
42:32 - people and that gives me the value 0 but
42:34 - what I can also do because this is not
42:36 - specific to the instance of any class is
42:39 - right person dot number of people and
42:42 - the reason I can write personally
42:43 - because again this is specific to the
42:45 - class not to the instance so we can
42:48 - access it by just using the name of the
42:50 - class and that actually means that I can
42:52 - change it using the name of the class as
42:53 - well so person dot number of people
42:56 - equals 8 right and then if I go ahead
42:58 - and say okay P 2 dot number of people
43:01 - notice that we get 8 even though I
43:04 - didn't explicitly change it on P 2 it
43:07 - changed for P 2 because this was
43:10 - specific to the class and when I
43:11 - reference this all this says is when I
43:14 - say P 2 number of people the way that
43:16 - Python interprets this is what is the
43:18 - type of P 2 okay that's person notice
43:20 - you can see it's popping up here it says
43:22 - person then let's say does it have an
43:24 - attribute called number of people know
43:26 - this person itself does not does the
43:28 - class have an attribute called number of
43:30 - people yes it does let's display back
43:32 - and since we change that to 8 that's why
43:34 - we're getting that value and of course
43:35 - if we do this for P 1 like we've shown
43:38 - right we'll get the same number we'll
43:40 - get P 1 number people get 8 and if we
43:42 - decide to change this halfway through
43:43 - right so we do person equals 9 obviously
43:46 - that will become 9 now just because we
43:48 - changed it right before we printed the
43:49 - next value so that is the basics we be
43:52 - behind class attributes there's a lot of
43:55 - different uses for them now in this case
43:57 - what I want to do is have a number of
43:58 - people so what I was gonna do is inside
44:00 - of here say person number of people plus
44:03 - equals 1 so that we keep track of how
44:06 - many people or how many instances we
44:08 - have created of this class person so now
44:10 - if I decide to print P you know person
44:13 - dot number of people and we'll do that
44:16 - after we create the second person as
44:17 - well see we get one two and this
44:19 - automatically increments it so that's a
44:21 - basic example of one you would use a
44:22 - class attribute they're not extremely
44:24 - you
44:24 - but you know is something that you may
44:26 - want to consider and sometimes say you
44:28 - want to define a constant something like
44:30 - maybe gravity or something that's going
44:32 - to apply to every single person that you
44:35 - want to be a constant value then you
44:37 - define that as a class attribute so that
44:39 - if you ever decide to take this class
44:41 - and use it somewhere else that constant
44:43 - is still defined as opposed to putting
44:44 - it up here like as opposed to saying
44:46 - gravity up here and making it equal to
44:48 - you know negative 9.8 meters per second
44:50 - at the top what you would do is you
44:52 - would make that a constant inside as a
44:54 - class attribute so that now every time
44:57 - you want to access the gravity property
44:59 - for you know a person what you would do
45:01 - is you can reference directly the
45:03 - person's class constant of gravity
45:05 - rather than a global constant which may
45:07 - not be there if you put this class in a
45:09 - different file and that's the idea
45:11 - behind this these classes as well is
45:13 - that they are exportable I can write a
45:15 - class in one file and I can take it and
45:17 - move it to another file and hopefully it
45:19 - should continue to work assuming it does
45:21 - not depend on anything from the previous
45:23 - file so ideally you want to make your
45:25 - classes as robust as possible which
45:26 - means that they don't need anything
45:28 - outside of their initial class
45:30 - definition unless that's gonna be
45:32 - another class that maybe it's
45:33 - interacting with like in the example
45:34 - before we had course and we had student
45:36 - but that is the idea behind class
45:38 - attributes now let's talk about class
45:40 - methods so class methods are defined a
45:44 - little bit differently than regular
45:46 - methods and in fact I'll show you how
45:47 - they work we have a good example kind of
45:49 - set up here so I'm gonna say define and
45:51 - in this case we're gonna say number of
45:55 - people like that instead of saying
45:57 - actually self we're gonna say CLS then
45:59 - what we're gonna do right here is return
46:01 - CLS number of people and we're gonna use
46:04 - what's called a decorator to denote that
46:07 - this specific method is a class method
46:09 - and to do that we write act class method
46:12 - directly above the function or but yeah
46:15 - I guess function method whatever you
46:16 - want to call so I know this seems a
46:18 - little bit weird but the idea behind
46:20 - this is this method here is not going to
46:23 - be acting on behalf of one instance it's
46:26 - not gonna be specific to an instance and
46:28 - in fact you can call it on an instance
46:30 - if you want but that's not really going
46:31 - to be very effective what this is meant
46:34 - to do is be called on the class itself
46:36 - so that it can deal with something like
46:38 - you know returning the number of people
46:41 - that are associated with this class so
46:43 - these are class methods they that means
46:45 - they act on the class itself they do not
46:47 - have access to any instance and that's
46:49 - why I've written CLS here instead of
46:52 - self because there's no object what it's
46:55 - doing is just acting on this class so
46:57 - for example say we wanted to add to the
46:59 - number of people then what I could say
47:01 - is class method define add person like
47:05 - that CLS and we'd say CLS dot was it
47:10 - number of people like that plus equals
47:14 - one so that would be these are class
47:15 - methods we denote them with at class
47:18 - method just so we know that they're not
47:20 - referencing you know itself like that
47:22 - they're referencing the class so let's
47:24 - actually have a look at how we use that
47:26 - now sure need to necessarily print the
47:28 - number of people anymore what we can do
47:30 - is we can go down here and say person
47:33 - dot number of people and I don't know
47:35 - why there's so many brackets showing up
47:37 - there geez but if we look at this uh
47:39 - what we would need to print it out first
47:41 - we should hopefully get the value of 2
47:43 - so let's look okay so we need to rename
47:47 - this so that this is not the same as the
47:49 - attribute because that's gonna be
47:50 - confusing so let's add an underscore
47:51 - there because I was realizing what the
47:53 - heck what's going on there and we can
47:55 - see that we get 0 oh so that is because
47:57 - I did not continue to add here so
47:59 - actually what I'm gonna do is and this
48:01 - actually be a good example so let's
48:02 - illustrate this here is I wanted to say
48:05 - too but I forgot that I forgot you know
48:07 - didn't continue adding this but what I
48:09 - can do is actually use the class method
48:11 - that I've defined here to add a person
48:13 - so I can say person dot add person like
48:17 - that inside of my in it and what that
48:19 - will do is call the class method on the
48:21 - class person and then it will add to the
48:23 - number of people so now when we run that
48:25 - we get two so that is how a class method
48:27 - works
48:28 - I don't need access to the instance to
48:30 - call it although I can use an instance
48:31 - to call it if I want I can simply
48:33 - reference the actual name of the class
48:35 - and this does not access any specific
48:38 - instance it only accesses these class
48:40 - attributes or anything specific to the
48:42 - class itself ok so that has big class
48:45 - methods now let's get rid of those and
48:47 - let's talk about static methods so
48:49 - sometimes I'm actually in delete the
48:50 - entire thing you want to create classes
48:52 - that kind of organize functions together
48:54 - so for example you know when you say
48:56 - like import math like that and then you
48:58 - get access to all these math functions
49:00 - like math dot abs or math dot square
49:03 - roots or whatever it is you're gonna use
49:04 - well what they sometimes end up doing in
49:07 - an object-oriented programming this is
49:09 - pretty common is when you have a bunch
49:11 - of functions that you would normally
49:12 - just define like you define like add one
49:14 - like this yeah I would do something you
49:17 - define add two like this well what you
49:20 - want to do is you want to actually
49:21 - organize them into a class and the
49:23 - reason you do that is just so it's a it
49:25 - stays a little bit structured you can
49:26 - move all those classes together to
49:28 - another module and continue to use them
49:30 - and to do something like this you want
49:32 - to use what's called a static method now
49:34 - let's make a class called math and what
49:37 - I'm gonna do in here is I'm gonna define
49:39 - some methods or some functions that I'd
49:41 - like to be able to use but that are not
49:43 - specific to an instance so I don't want
49:47 - them have to make an instance of this
49:48 - math class to be able to use these
49:50 - methods I want to be able to call them
49:51 - at any points and it doesn't matter if I
49:53 - have an instance of the math math class
49:55 - or not I would like to be able to use
49:57 - them so what I'm gonna do is actually
49:58 - create what's called a static method now
50:01 - static means not changing right it means
50:04 - staying the same and that is a really
50:06 - good way to describe what these methods
50:07 - do because they do not have access to an
50:09 - instance just like the class method all
50:11 - they do is something they do something
50:14 - but they don't change anything that's
50:16 - the idea behind a static method they
50:17 - don't change anything because they can't
50:20 - they don't have access to anything so in
50:21 - here what we're gonna do is just say
50:23 - define add five and in here I don't even
50:26 - need to put a cell for a CLS because
50:28 - this is not going to access anything all
50:30 - its gonna do is just act as a function
50:32 - that is defined inside of this class and
50:35 - again some of you I'm sure are yelling
50:37 - saying what's the point of doing that
50:38 - why don't I just define a function
50:39 - globally well it's more of an
50:41 - organizational thing and there's some
50:43 - more specific applications in which you
50:45 - would use a static method so I do need
50:46 - to show them to you so here we're gonna
50:48 - take a number and all we're gonna do in
50:50 - this method is return X plus five so now
50:53 - if I want to actually use this what I
50:54 - can do is I don't need to say like M
50:56 - equals math like that and make an
50:59 - instance that's not necessary I can
51:01 - simply write the name of the class and
51:03 - math dot add five let's put five in here
51:06 - let's have a look if I got rid of the s
51:09 - and we get the value ten so this is
51:11 - called a static method and we can make
51:13 - as many of these as we would like
51:15 - just as we can make as many class
51:16 - methods as we want so maybe we do add
51:18 - ten right and then we have bat like that
51:20 - and we can change this method to say add
51:22 - 10 and now if we run this we get 50 so
51:25 - that is a static method notice it
51:27 - doesn't need anything in fact what I can
51:28 - actually do is say define you know PR
51:30 - let's say that's gonna stand for print
51:32 - let's make this an @ static method and
51:36 - now let's just print run like I'm just
51:40 - showing that you that you don't need any
51:41 - attributes in there are arguments and
51:43 - let's just call PR and now you can see
51:44 - that we get run and since I printed the
51:47 - value of that it prints them none but
51:49 - there we go
51:49 - like that okay so that is static methods
51:53 - and class methods and to be honest with
51:55 - that that is pretty much everything you
51:57 - need to know about classes and objects
51:58 - at least at a beginner level now there
52:00 - is some more interesting things that we
52:02 - could talk about but in the idea of
52:04 - keeping this more for beginners and so
52:06 - that everyone can kind of understand
52:07 - doesn't get to confuse I'm number frame
52:09 - from discussing anything further but I
52:11 - hope this really gave you a fundamental
52:13 - knowledge of how classes and objects
52:14 - work in Python a little recap here is to
52:16 - remember that everything we work with is
52:19 - an object in some sense we have
52:21 - functions which are objects we have
52:22 - strings which are objects integers are
52:24 - objects and what an object does is it a
52:27 - in instance of some class and that class
52:29 - defines the properties and almost kind
52:32 - of the blueprint for that object it says
52:34 - okay so if we have a string we can use
52:36 - the method like upper lower if we have
52:38 - an INT we can add integers together and
52:40 - a class the type of an object is very
52:43 - important because it defines the
52:45 - behavior in which it can exhibit so that
52:47 - has been classes and objects in Python
52:50 - and introduction to object-oriented
52:51 - programming I hope you guys enjoyed if
52:53 - you did please make sure you leave a
52:55 - like these videos are not that easy to
52:56 - make and they are definitely time
52:57 - consuming so I would appreciate it
52:59 - subscribe to the channel and of course
53:01 - let me know if you have any questions or
53:02 - if there's anything you would like to
53:03 - see in the future

Cleaned transcript:

hello everybody and welcome back so in this video you're gonna learn about objectoriented programming in Python and how you can create your own custom objects by making different classes in Python now this video is geared towards beginner so people that have some knowledge of Python have written Python code before but I've not yet stepped up into kind of the intermediate stage which I'm gonna call is this working with classes and objects and are looking to learn that so I'm restarting completely from the beginning if you have no knowledge of objectoriented programming that's totally fine in this series is meant for you if you're someone who just wants a refresher I'd recommend maybe watching the video on two x speed and slowing down when things get a bit more confusing or one you know you need to really learn that topic more so let's go ahead and get started and what we need to do to discuss objectoriented programming is first to find what an object is now a lot of people may think that when we talk about or objectoriented programming that's a completely new thing you know you've never seen an empath on before and it's a new kind of thing to tackle and to learn when in reality you actually see objects all the time when you're working with Python code and you just don't know that they're objects just because they're a little bit disguised and I'm gonna kind of take away that disguise and show you what all these different objects are so we may have heard of the notion of type before we see this function type and we know when we ask it what type a certain variable is or we ask it what types say you know a string is like this it spits out an answer to us and I'll show you what I mean by that so if I do print type of hello so we know that hello is a string datatype let's just see what we get in our console down here oops I didn't mean to do that we get class string so notice that this says class now most people just disregard the fact that it says this but this is actually very important what this is telling us is this right here this string that we typed in is actually an object of the class string right STR now what do you think is gonna happen when I put in X well we know that X is an integer so let's have a look here we can see that we get class int so notice that these different data types that we've called them before a string and an int are actually a part of a class and what that means is even though it doesn't look like we've created an object when we do something like x equals 1 we've said X is equal to the object which is a type integer with the value 1 that's exactly what we've done and the fact that we act create these kind of objects is very important in writing Python code and I know this hopefully shouldn't confuse any of you too much but if I write say a function so you know define hello and in here we just print hello like that and what I decide to do is I go okay let's look at the type of hello so notice I didn't call the function hello with the two brackets I'm just looking at the actual name of hello and we run this well if we add the final bracket at the end here we get class function so pretty much everything in Python that we work with is actually an object of some kind of class and later on in the video what we're gonna do is make our own classes so that we have our own specific types so these are what are called the builtin types these are built into the Python language and that's why they work a little bit differently than other classes that we'll work with later but just understand that whenever you create something in Python you are really creating an object which is an instance of a specific class in that class defines the way in which that object can interact with other things in our program and just show you what I mean by that let's just look at some common error messages and we'll see exactly what that means so we're gonna say x equals 1 y equals hello and watch what happens when I try to do something like print X plus y well we get some air let's go up and see here we get type error unsupported operand types for plus int and string so it's saying because our object x is an INT and our object Y is a string we cannot add them because the program does not know how to work with objects of those two types or in better words the addition operation is not defined for objects of int and objects of string at being added together so it's very important and pretty much the type that we have defines what we're allowed to do with the specific variable or with that specific object and it denotes the actions that we can perform you know plus minus all of that if I were to change this right to 2 and then we just do X plus y don't need to print it out we can see that that's totally fine and there's no issue because these are both ins which means that operation is defined for them ok so hopefully that is clear and that makes some sense I hope that gives you kind of understanding of what I mean by objects and now I'm gonna talk about methods because those are something that we can perform on objects so I'm sure that many of you seen this before I'm just gonna type string equals hello like that and many of you know that we can do something like print string if I can type this correctly dots up right so when I write this dot upper here what is that actually doing well let's look at here we obviously know that puts that all to uppercase but we're allowed to use this what we call method and this is a method whenever you have this a dot operator you have some name and then you have the two brackets at the end here and maybe there's some arguments that go inside of there that is usually a method that is acting on a specific object and in this case what it's doing is we have the method upper acting on the object of type string that is stored in this string variable and the reason we're allowed to use this method on it is because this is a string now notice that I can't do something like you know X equals one and then do X dot up and the reason I can't do that is because while it's gonna say right here int object notice int object has no attribute upper so these methods these different operations the things that we can do with these objects is based on the type of class that they are so that's something that we really need to nail in there and I hope that makes sense and now what I'm gonna show you is how we can actually create our own classes because hopefully that gave you a good enough explanation for what objects really are so to create our own class I'm gonna kind of do like a template here and then we'll go back through and discuss what everything is doing at once but just try to follow along for now so I'm gonna say class and we're just gonna do the classic kind of animal example to start here so I'm gonna say class dog and we're gonna define this initialization which we'll talk about later and actually no let's not even do that let's just say define bark like that and then what I'm gonna do in here is simply print work okay so what I've actually done here and I know this is gonna be weird for many of you that have not seen this before is created a class called duck what this means is I'm gonna make my own kind of blueprint now for any objects that are of type dog and I'm gonna start defining the operations that a dog is able to do now in this case I've created a method now a method is essentially just a function that goes inside of a class that's the easiest way to define it and for our basic example right now all of our methods are gonna start with a parameter called self and we're going to talk about what this self parameter means and how all this works later on but let's kind of build our way up to that so I'm gonna say D equals a dog down here and what I've done when I did this here is I'm actually saying okay I'm gonna have the variable D and I'm going to assign it to a instance of the class dog so this is class dog again you don't need to know how this works right now we're gonna talk about that in a second but when I write this line here and I put dog which is the name of my class and then two brackets like that I am instantiating right creating a new instance of the class dog so D is now gonna be an object that is of type dog and notice that we don't get any errors there and when I decide to print out type of D we're gonna see that we get class underscore underscore main underscore R squared dog now the reason we have these underscores is because this is telling us what module this class was defined in now by default the module that you run is called the main module that's why we have these two underscores main underscore underscore but we can see that this is again an object of the class dog and that means that whatever we define inside of here is going to be what is allowed or the operations that can be performed by a dog and one of those operations is bark so this is a method remember we've talked to a method just like dot upper before so if I want to use that method on an instance of my dog class because this is an instance of the class dog then what I can do is I can type well not upper but dot bark like that so I can call this method on my dog object again because it is a class dog and I've defined a method that works for dogs so when I do that we can see that we get bark and then it still obviously continues to print the type of that object so this is what we're getting out here so these are kind of how classes work we name the class typically the convention is to use an uppercase letter and usually you go camel case so you do like dog like you say we're gonna do two words you do like dog hello right so camel case like that and then inside of the method or inside the method inside of the class you can define a few different methods and operations that can be performed by this object so what I'm gonna do is I'm gonna say define I don't know let's just say meow I know this is wrong because it's not a dog and we'll talk about self in just a minute but I can define another method here and instead of printing something I could say return let's just say yeah like that so I don't necessarily need to print something I can return something I can have these methods take arguments so maybe I have meow and then I put X and maybe what I do is I return X plus 1 or something like that so maybe let's just call this add call this add underscore 1 that'll be the name of our method so I can return X plus 1 and then what I could do if I want it here is like it's a dog add underscore 1 put 5 there and let's print out the value that we get let's have a look at this year and we can see that we get the value 6 so we can make methods that have different arguments associated with them or parameters like I've put X here and that just means that when I call that method I need to pass in a specific value or specific values so that that can operate and that can work so that is how the methods work so now we're gonna talk about itself but before we can do that we need to talk about what's called the anit method which you may have seen me typing at the beginning before I kind of gave up on X I didn't want to get that complex that fast so right now we have two methods we have this bark method and we have this add one method and I hope those makes sense on how those work and now we're gonna talk about this special method here and by the way this has two underscores so it has underscore underscore and then an it and then underscore underscore now this is a special method and what this pretty much allows us to do is instantiate the object right when it is created so this method will be called whenever we write this line so whenever we create a new dog instance by writing dog and then the two brackets let me get rid of this down here for right now this method will be called and it will pass any arguments that we put in here so maybe I put something like Tim in here it will pass that to this method so let's say that every time we create a dog and we want to give it a name immediately so to create a dog the criteria is that you must give it a name well what we would do in here is we would put the parameter name and then here we would pass in the name so what we need to do though is what we're passing in this name we need to store this in the dog object somewhere right we need to have this stored we need to be able to access this this is kind of the nice thing about objects and this is where we're gonna talk about attributes what we can do if we want to store this name is we can say self dot name equals name now it's important to note that this doesn't these don't need to match but what we've just done here is we've created what's called an attribute of the class dog which is name so what this means is essentially every time we create a new dog object we will pass a name through this parameter so self just stays here to denote the object itself so like every time one of these things is called we will pass a reference to which object it was called on so we can access things for each specific object and we'll talk about that more in a second but here what I've done is to find an attribute called name which is equal to the name that we passed in so what I'll do is immediately I'll just print inside of here the name so that we can see how this works and notice that when I run this now we get Tim printing out so even though I didn't explicitly call this an it method because I wrote this line here it passed this name that I put in here to the name parameter and then it printed out name here inside of the Anette and we also defined an attribute called name that is inside of this dog class so what self is doing is every time that any of these methods is called kind of invisibly you don't get to see it the actual reference to this dog object is passed so that we can access attributes that are specific to each dog and what I mean by that is I can make another dog so maybe I say d2 which is you know another instance of the class dog except this time I named it's Bill right and now we'll do the print statement again so we'll say print name just to show how this works and here we get Tim and we get Bill so we actually have two different dog objects now one named Tim and one named Bill and they both store different names inside of there you know instance if that's what you want to call it so let's just show how this attribute works so the point of this attribute is that it's stored permanently for each specific object so I can actually go ahead and go down here and print D dot name after that's defined and I can print D dot name like that and when we look here we can see that those names get printed out so Tim and Bill notice that I remove the print statement from up here so these attributes when we do something like a self dot and then anything that we want we can call whatever we want is equal to some value we can reference them later on and we can reference them from methods inside of our class so an example of that is something like say define get underscore name so the first argument here is always gonna be self are the first parameter and the reason for that is because we need to invisibly pass the actual you know dog object itself so that we know which dog were accessing when we're gonna get say the name of the dog so here we're gonna say define get name and all we're gonna do is return self dot name like that so now rather than saying dot name we can call thought get underscore name which is a method right and we can do that down here as well get underscore name and then we see that we get Tim and we get Bill so that is the basics behind objects now of course I can make more attributes as well so I could do something like H so let's say my dogs I want them to have a name so let's say my dogs want them to have a name and an age well what I'll do now is I'll say okay so in our initialization for dog we're going to take a name and we're gonna take an H so we'll define the attributes in here so self dot age is equal to whatever age we passed in and now every time that I make a new dog object I need to pass a name and an age so these this Tim will be an old dog here bill will be a young one and we'll run this and we see that we get no issue and if I wanted to I can go ahead and define another method here so get age and we'll return self dot age like that and if we change this to get inch and we change this one down here to get age as well what is the issue here oops so I'm forgot to put myself in here so notice what happened when I forgot to put myself so that's actually a decent error to run into I didn't put self in here as a parameter and you can see I know that it's kind of messy here it says get age takes zero positional arguments but one we're given so what does that actually mean so it's saying it takes is your arguments which it did when I didn't himself here but one was given but I didn't give any arguments inside of the brackets well that's because when we call a method this right the actual dog object itself immediately kind of been Blee gets passed to that method as the self parameter so we know which dog it's talking about so now if I go ahead and I add self we can see that this works fine and we get thirtyfour and we get twelve so that's important thing to remember now what we can actually do is we can create other methods that modify these attributes or create new attributes so I can do something like for example set age so I in sight define set age will give itself of course and then we'll put an age here what I can do now is say self thought age is equal to H and now what I'm gonna do for Tim and we'll get rid of Bill for now because I think we get the point on how it works for different objects isn't gonna say D dot set underscore age and I'm gonna change his age to 23 and when we print it out we can see that 23 actually gets printed out so we can modify and we can access these different attributes from methods inside our class and this is where thing gets things get very powerful because this allows us to access data that is stored within a specific object and do different things with it based on how different methods and different things are being called right and this just is pretty much the blueprint that defines how a dog actually works how it operates what it can do the methods associated with it and the attributes that exist now some of you may be saying well why do I need to do this right like this seems kind of redundant I could write in a different style well the nice thing about objectoriented programming is once you create one of these classes you can have an infinite amount of instances of this class without having to change anything so let's say for example that we'll leave that class up here right now but we want to simulate what we've just done here for the Tim dog right we want to have an age and we want to have a name and we want to be able to change his age and all that well many of you that were more beginner programmers would probably tell me we can do something like this we can say dog one underscore name equals Tim you could say dog one underscore age equals you know 34 and there you go you just defined these two attributes if you want to get it you can just access the variable if you want to change it you can just change the variable okay nice but what happens when I want to make 25,000 dogs or every time I run my code I want to make a different amount of dogs you can't find a way that you can write all these different variables that have one two three all the way up to 50,000 or however many dogs I have to represent that that's why we use objects is whenever we're going to be kind of reusing something there is some instances in which we make a class where that we're only going to use once or instantiate once but those are kind of more complex examples we won't get into here but then okay so some of you might tell me all right well Tim I can just do lists I can say dogs equals that we say dogs underscore name equals that right and here we can put well the first name is Tim and then we had fill so this will handle the idea that we can't just have all these different variables right so dogs age equals and then we go let's say I don't know 32 14 okay that's great but the issue with this is that it's really a pain when I want to access the dog's age the dog's name and then what if I had like 25 other attributes or methods associated with the dog this is just just a paint you don't want to deal with that because I have to now find the index of whatever dog I want in one list which is a very timeconsuming operation in computing and then I need to reference that index and all the other lists for all the other attributes and it just becomes very messy very quickly and let's say I want to delete one instance like feed you know the dog object bill or something like that right then I need to find the index of this I need to find the index of all of the attributes and all the other lists and I need to delete them at the same time to make sure that all my data stays consistent and there's no kind of offsetting things or too many attributes in one list so it's just as a pain to do it like that so I hope this makes sense on why we would do objectoriented style and now what we'll do is go into one example where we create a more complex object and show kind of the advantage of that ok so a lot of people typically will stomp at kind of the previous example that I just gave you now I want to go a little bit further and show you the advantage of doing multiple classes so rather than just using one class I want to show you how different classes can kind of interact in an example where I have a bunch of students these students all have some grade assigned to them and they're all a part of a course and then that course will have some methods on it to do things like find the maximum grade of all students give us the average grade of all students tell us the lowest grade some things that you may actually want to do say if you were trying to model or create a system for you know a school or something like that right so this is obviously going to be a little bit more of an example as opposed to super practical but hopefully this should give you some more insight into how we would do something like that so I'm going to start by cleaning creating a class called student I'm gonna go a little bit faster here but I will slow down and talk about what I've done after so don't worry if you can't keep up so we're gonna have a student and each student is gonna have a name age and eighth grade so we're just gonna say self the name equals name self dot age equals age and then self dot grade equals grade now this numeric grade is gonna be between 0 and 100 so I'll just write that down here just so we know that and that should be good for our students so we could of course go in here and add some methods if we wanted something like get underscore grade and what does ID 1 just so we have it in here and what we can do is return a self duck grade like that okay so this is this is where we're gonna leave our student now we could add a lot more things to this we could add a change grade we could you know add a test we can have weightings we can do all kinds of crazy stuff but for now we're gonna leave it at that so again we've defined three attributes here we have a name and age and a grade those are equal to the name age and grade that we pass in when we initially create a student and then we have one method remember this is a method and it simply returns a student's grade now I'm going to make a new class called course now what I'm gonna do in this course class is I'm gonna have the ability to add students to a course so when we create a new course what we're gonna need to do is we need to define the name of the course and the max underscore students that can be enrolled so in here we'll say self dot name equals name and self dot max underscore students equals max underscore students like that all right so what we're gonna do now is we're gonna add a method that will allow us to actually add students to this course but how are we gonna do that how are we gonna have students stored inside of a course object well what we can actually do is we can make a list of students so I'm gonna say self thought students equals a blank list now notice that I've made an attribute and I didn't assign it directly to one of these things that was passed into one of these parameters arguments whatever you'd like to call them that is totally fine in fact a lot of times will create attributes like self dot you know is active something like that equals false right we can do that that's totally fine and attributes are just whatever we decide to define and if we want to assign them to say the argument or parameter that's here that's fine and we can do that so there we go we have selfdoubt students which is a blank list and I'm gonna start by creating a method here that's going to allow us to add a student object into this list so I'm going to say define add underscore student like that and in here antic self and we're actually going to take student now this student right here is actually going to be an instance of a student object and I'll show you what I mean by that in a second but all we're gonna do is say if the length of self dot students is less than and in this case self thought max underscore students then what we'll do is we'll say self dot students dot append student so we're gonna create a list of students inside of this you know this list right here right that's what we're gonna do and we're gonna add them in only if this is less than the maximum students in the class and what I'll do is I'll actually return true if the student was added successfully and then down here I'll return false if not so that we can tell maybe if we make a program down below if that student was added properly or not now I'm gonna add another method and here I'm gonna say define yet average great now wolf code that one out in a second but let's do an example of how we can actually now add students to these class so I'll make that a bit smaller so we can read it so let's make a few different students so let's say s 1 equals student what do we need to pass for student and named agent grades let's call that Tim let's call that 19 and let's call that 95 Tim's a smart guy all right and then we'll do s2 equals student we're gonna say bill we'll put him at 19 as well and he's not as smart he is 75 and then let's do s3 equals and let's go Jill keep with the trend Tim billed Jill 19 and maybe she has a 65 ok so we've created three students here and these students are proper they should work fine let's run this make sure everything's all right now how can we actually add them to our course well the first thing we need to do is make our course so we're gonna say course equals course like that what do we need when we make a course we need a name and we need a maximum amount of students so let's name this course let's say science or something like that and let's say the maximum amount of students is actually gonna be 2 because I want to show what happens when we add a student past the maximum now we're going to add students so how do we add them well we have to call that method so course dot add students so there we go we can add student s1 and then let's do course dot add student again and let's add s2 so now let's run this we see everything works fine and let's actually make a thing that can you know print out some thing about our student or can show our students so what I could do is I could say let's print down here course dots and this students and let's have a look here and we get main student object on some gibberish location main student object at some gibberish location so what this is actually telling us is both of these things inside our list right now our student objects and notice what I can actually do is let's say I index the zeroth item in that list so the first student that we added and I decide to call dot name on it well then that should hopefully print out the name of that first student which is 10 so that's cool and that's how we do that right we can add things in to this course so now this course stores all of our students and since all of these students have a grade on them inside of our course we'll be able to access that so now that we've done that let's write this method that can get the average grade of all of the students that are enrolled in the course to do that what we're going to need to do is grab all the students from the students list we're gonna need to add that to an average and then we're gonna need to divide that value to figure out what that is so what we'll do is we'll say value equals 0 we're gonna say for student in in this case self dot students then we're gonna say value plus equals student the duck gets grade like that now notice that we could just type great if we wanted to but I usually just like to use the method because say we were to change any attribute later then this code wouldn't break so long as this method was still named the same thing and we can modify the method in here so they returned the proper grade like say we had a student enrolled in multiple courses then we could you know determine their grade in a different way and when we called get grade maybe we don't just return self grade we return something different so this still continues to work so we'll say value plus equals student get grade and now all will simply do is return in this case value divided by V Len of self dot students so let's see what the average grade of our courses so course get fabric grade will actually print that out like that and run that and we can see that the average grade is actually 85 and that makes sense with the grades that we have here so that's the idea behind what I'm trying to show you is that we have you know we can have different classes we can have attributes with them and when we can program an objectoriented style now it doesn't matter how many students we have or how many different courses we have and what students are enrolled in which in fact what we could do is we could make another course we can add the same students to it and then we would obviously have to change the way that their grade was calculated but that's something that we could do now let's just look at what happens when I decide to try to add that third student so course start add student like that and we decide to add student s3 we can see that we get the value false and notice that the average grade does not change because we didn't actually add that into the course right okay so we finished off the basics on classes and objects and how to create our own classes and hopefully that last example helped you to really kind of understand the advantage of doing this now what we're going to talk about here is something called inheritance now this is where we slowly start getting to a little bit more complex and some more difficult concepts so try to follow along but I don't find inheritance as that extremely difficult so the idea behind inheritance and we'll show what that is in a second is you have two classes that are very similar so let's say we have a general class called maybe alright let's do a better example let's say we have a class called dog and a class called cat and in fact let's actually code these out so that we can see this for real so let's say in the init method of the cat what we're gonna do is we're gonna have self name and age like that so we're going to say you know self dot name equals if I can type properly which apparently is not happening right now and then self dot age and then we'll do define speak and all we'll do in here is just print you know what is this cat yeah okay and then let's say we have a dog so we'll say class dog like that and we'll define underscore underscore net on our squander square put the self put the name put the age because that's all we want for that and we'll say self dot name equals name self dot age equals age and then define here speak and the only difference between these two classes is actually gonna be the fact that this prints bark instead of meow so notice that these two classes are almost identical in fact there's only one line of code that's different other than the class definition at the top so there must be a way that we don't need to write this twice that we can actually use what's called inheritance so that these dog and these cat classes can well inherit from an upper level class which means that all that functionality is defined in one place and we only need to write what's different about those two classes inside of them so ideally what I would like to have is to be able to remove this init class from both of these and just have the speak method because the only thing that's specific to a cat in a dog at least for my example is the fact that one of them says meow and one of them says bark so let's get show how we can actually do them so by removing that you know was an it method and just having these methods here what we need to do is make an upper level class which I'm actually gonna call pet so I'm gonna say class pet what I'm gonna do in here is define that an it method that we had before I'm actually gonna define a let's say show so this show method is just gonna show me all the things about my objects so I'm gonna say print and in here we're gonna say you know I'm actually gonna use an F string you may not know what that is but don't worry about it I am self taught name and I am self dot age years old okay so what I've done is I've defined this pet class and this pet class essentially is going to contain the functionality that I want the cat class and the dog class both to have and then in sign of the cat class and inside of the dog class what I'll do is I'll define the methods or the attributes or whatever it is that I need to do that are going to be different for this specific class so notice that pet is general we call this a generalization whereas cat and dog are more specific so how do I actually allow the cat class in the dog class to use this functionality well what I can do is simply add brackets and write pet now what this stands for is I am inheriting the upper level class pet so we're saying this is the general class this is a more specific class that's being created and inherits from pet and the same thing with dog let me show you how this works so let's create an instance first of all of the pet class and then we'll make one of the cat and the dog class and I'll show you how it works so let's say P equals pet notice that for pet we need a name and we need an age so let's say it's him let's put him at 19 and then let's do P dot Show so let's look at this year I am Tim and I am 19 years old so that is how the pet class works pretty straightforward now let's make a cat class so let's say C we're gonna say C equals cat I'm gonna say the cat's name will be Bill and that cat will be 34 like that and then let's do the same thing here see nutshell now notice that even though there's no method called show inside of cat it still pops up and says I am Bill and I'm 34 years old that is because it inherits inherits the properties from the pack class because I've defined that up here and notice that even though I didn't defined in an it method in here this still worked fine right there's you know this was okay we initialized because we use the anit method that was defined inside a pet and of course we can do the same thing with dog so we can say D equals dog what do we call this one before Jill 25 and let's do D dot shell like that we go I'm jail and I'm 25 years old so that works but now let's show what happens when we call speak on the cat and the dock so if I decide to call speak like that and we'll call it on both of them here you can see that we get me out and we get bark and again that's because this speak method is different for the cat class and different for the dog class and since its defined inside of here and we created an instance of cat when we make a cat instance well we're gonna use the speak method that's defined here and in fact what I could actually do is define speak up here and I could say define speak and I could say print I don't know what I say like that okay and then if I decide to change this from show to speak notice that we're calling speak three times speak is defined here and it's defined in both of our child classes is what we call them so when they when this is the upper level class the more general version any classes that inherit from it are known as the child classes or the derived classes um that's not that important to know but just you know figured out through that lingo out there and notice that when I run this we get I don't know what to say meow and bark so if there is a method defined in the lowerlevel class or the child class that is the same name as the upper level class it will automatically override that method so it will take over anything that's defined in here is more specific to this class so it will use that rather than using this upper one right and you might ask well why would we even bother defining one in here if it were just gonna take it over later well we might create another pet right maybe like a fish or something for example like I can do something like this class fish pet like that I can literally just define that and put pass inside of here and now what I can do is say okay let's say F equals fish and then we need a name so let's call this bubbles why not give it ten and now we can say F dot speak and notice that we get I don't know what to say for this fish class because there was no speak to find inside of here it used the speak that was defined in the upper level or parent class right the one that we inherited from so that is the basis behind inheritance now it gets a little bit more complicated I'm gonna show you the more complex out aspects because let's say I want to add one attribute to my cat so let's say that for cats we actually care what color those cats are as well well what I would need to do to do that is this initialization method right because I want to pass it and when I create a cat but I don't necessarily want to rewrite this whole thing so what I'm gonna do and I'm kinda need to rewrite the whole thing but you'll see why we would actually do this in a second I'm gonna say self name age cover like that and now all I'm gonna do let me say self dot color equals color so what some of you may say here now that we've defined the color in here is that what we should do is take this name and age right just copy it and paste it in here now that would be a correct answer but I'm gonna tell you why we shouldn't do that so the idea here is that sometimes in the initialization method of our parent other things are happening other than just redefining attributes right and in that instance it would not be correct for us to simply omit the fact that we're not gonna call this a net from the parent we're just gonna define the attributes because that could mean that we miss out on a very important you know function that's happening from inside of this initialization to give you an example like saying some web applications maybe this initialization actually calls a database right and an ask for some information for a database and it sets up the object using that it wouldn't necessarily be correct then for me to just you know take the attributes that we're in here and just redefine them as attributes here I would actually still need to call that initialization to make sure the object was set up properly so to ensure that that happens when we do an inheritance like this we do need to define the arguments that we need are the parameters that we need for the parents initialization so name age but there's a fancy way to call that so rather than you know rewriting this here I can actually explicitly call this and set up our object that way so to do that I'm gonna say self are super underscoring square net done underscore underscore name age now what this is saying is super stands for reference the superclass and the superclass is actually the pet class or the class that we inherit from here so that's what super stands for the class that we are have inherited from then underscore underscore net underscore underscore defines the method that we want to call right and then name and age are the arguments that we're going to pass to that so name and age notice I don't need to pass cell that's fine we don't self and it's gonna call that and what's gonna happen is it's gonna run whatever's inside this initialization then that's gonna set up the name and the age for our object so we will have those properties defined and then we will call self duck ah they're equals color or we will execute that line so now we have the cover right and if I just go ahead and want to define here show so I want to change this show method maybe for this cat object then what I can do is I say I am self that name and I'm self that age and I am and in this case self dot color right so we can change the show method in here and now let's go to cat let's change this to show let's add a color because we need to add a color now we have to find that in the Annette and let's run this and see what the issue is now that we're getting fish is not defined oh did I do I guess I've deleted fish or we got rid of it at some point I did not remember okay so anyways let's run this and we can see that we have I don't know what to say I'm Bill and I'm 34 years old and I am brown and then we get bark right so that is how that works for inheritance and this is how we call the super class or the upper level parent class right we need to call this initialization method before we just go ahead and do anything else because that parents initialization may be important it may do other things it may call another method right so we can't just simply skip that we need to call that explicitly by writing this line now this line is kind of complicated syntax you know it's easy to forget but try to remember it super again references the parent class pet and then we have an it and like that so I hope that gives you an idea on how inheritance works now it's hard to give really good inheritance examples without going more complex and more into detail so I'm gonna admit doing that for now but just remember that when you have classes that do a very similar thing they have almost everything identical except maybe a few attributes or a few methods it might be a good idea to what we call generalize and make a parent class that is a general class that defines functionality will be used in all of your child classes and that is a very common practice and objectoriented programming to use inheritance for example a very good example is for example a good example is something like person hierarchy so let's say you have you're working in an organization and the example we want to consider is we have managers and we have employees now managers have different access than employees but employees and managers have very similar properties they all have a name they'll have an age they'll have an ID they have a birthdate they have many different things that they are the same for both of them well if we were trying to model that system and we were gonna program that and make that what we would likely do is create an upper level general class called person that defines all of the attributes and all of the methods that are general to all people whether they are managers or employees and then we would create two child classes one for employee and one for manager and that would define the specific things that the manager can do and that the employee can do that are different from each other so that's the idea behind inheritance hopefully that makes sense and now let's move on to our next topic okay so now it's time to talk about static and class methods and class attributes and in fact we're actually going to start with class attributes now previously you would have seen that every time we defined an attribute for one of our objects we used self right and inside the class we had self every where self was referring to the instance in which we were talking about in that you know context right so here what we're gonna do now is talk about class attributes now class attributes are attributes that are specific to the class not to an instance or an object of that class so I'm gonna do a basic example where I just create a class person and I'm gonna say number of people equals 0 now in here I'm gonna define the NIT method and say to find an it like that and we're just gonna say each person will simply have a name keep it nice and simple like that so self that name equals name now let's make p1 person we'll talk about what I've done in a second here in case anyone's confused and let's say p2 equals person let's make this Jill okay so we have this number of people thing and I'm sure a lot of you're like what the heck is that well this is a class attribute and the reason it's not a regular attribute is because it does not use self so because it's not defined inside any method because it does not have access to an instance of the class it is defined for the entire class which means that this is not specific again to any instance it's not gonna change with from person to person whereas we know something except that name will be different for each instance of the person class this is not different for each instance of the person class in fact it's the same so what I can show you is that I can actually go ahead and print say you know p1 dot number of people and that gives me the value 0 but what I can also do because this is not specific to the instance of any class is right person dot number of people and the reason I can write personally because again this is specific to the class not to the instance so we can access it by just using the name of the class and that actually means that I can change it using the name of the class as well so person dot number of people equals 8 right and then if I go ahead and say okay P 2 dot number of people notice that we get 8 even though I didn't explicitly change it on P 2 it changed for P 2 because this was specific to the class and when I reference this all this says is when I say P 2 number of people the way that Python interprets this is what is the type of P 2 okay that's person notice you can see it's popping up here it says person then let's say does it have an attribute called number of people know this person itself does not does the class have an attribute called number of people yes it does let's display back and since we change that to 8 that's why we're getting that value and of course if we do this for P 1 like we've shown right we'll get the same number we'll get P 1 number people get 8 and if we decide to change this halfway through right so we do person equals 9 obviously that will become 9 now just because we changed it right before we printed the next value so that is the basics we be behind class attributes there's a lot of different uses for them now in this case what I want to do is have a number of people so what I was gonna do is inside of here say person number of people plus equals 1 so that we keep track of how many people or how many instances we have created of this class person so now if I decide to print P you know person dot number of people and we'll do that after we create the second person as well see we get one two and this automatically increments it so that's a basic example of one you would use a class attribute they're not extremely you but you know is something that you may want to consider and sometimes say you want to define a constant something like maybe gravity or something that's going to apply to every single person that you want to be a constant value then you define that as a class attribute so that if you ever decide to take this class and use it somewhere else that constant is still defined as opposed to putting it up here like as opposed to saying gravity up here and making it equal to you know negative 9.8 meters per second at the top what you would do is you would make that a constant inside as a class attribute so that now every time you want to access the gravity property for you know a person what you would do is you can reference directly the person's class constant of gravity rather than a global constant which may not be there if you put this class in a different file and that's the idea behind this these classes as well is that they are exportable I can write a class in one file and I can take it and move it to another file and hopefully it should continue to work assuming it does not depend on anything from the previous file so ideally you want to make your classes as robust as possible which means that they don't need anything outside of their initial class definition unless that's gonna be another class that maybe it's interacting with like in the example before we had course and we had student but that is the idea behind class attributes now let's talk about class methods so class methods are defined a little bit differently than regular methods and in fact I'll show you how they work we have a good example kind of set up here so I'm gonna say define and in this case we're gonna say number of people like that instead of saying actually self we're gonna say CLS then what we're gonna do right here is return CLS number of people and we're gonna use what's called a decorator to denote that this specific method is a class method and to do that we write act class method directly above the function or but yeah I guess function method whatever you want to call so I know this seems a little bit weird but the idea behind this is this method here is not going to be acting on behalf of one instance it's not gonna be specific to an instance and in fact you can call it on an instance if you want but that's not really going to be very effective what this is meant to do is be called on the class itself so that it can deal with something like you know returning the number of people that are associated with this class so these are class methods they that means they act on the class itself they do not have access to any instance and that's why I've written CLS here instead of self because there's no object what it's doing is just acting on this class so for example say we wanted to add to the number of people then what I could say is class method define add person like that CLS and we'd say CLS dot was it number of people like that plus equals one so that would be these are class methods we denote them with at class method just so we know that they're not referencing you know itself like that they're referencing the class so let's actually have a look at how we use that now sure need to necessarily print the number of people anymore what we can do is we can go down here and say person dot number of people and I don't know why there's so many brackets showing up there geez but if we look at this uh what we would need to print it out first we should hopefully get the value of 2 so let's look okay so we need to rename this so that this is not the same as the attribute because that's gonna be confusing so let's add an underscore there because I was realizing what the heck what's going on there and we can see that we get 0 oh so that is because I did not continue to add here so actually what I'm gonna do is and this actually be a good example so let's illustrate this here is I wanted to say too but I forgot that I forgot you know didn't continue adding this but what I can do is actually use the class method that I've defined here to add a person so I can say person dot add person like that inside of my in it and what that will do is call the class method on the class person and then it will add to the number of people so now when we run that we get two so that is how a class method works I don't need access to the instance to call it although I can use an instance to call it if I want I can simply reference the actual name of the class and this does not access any specific instance it only accesses these class attributes or anything specific to the class itself ok so that has big class methods now let's get rid of those and let's talk about static methods so sometimes I'm actually in delete the entire thing you want to create classes that kind of organize functions together so for example you know when you say like import math like that and then you get access to all these math functions like math dot abs or math dot square roots or whatever it is you're gonna use well what they sometimes end up doing in an objectoriented programming this is pretty common is when you have a bunch of functions that you would normally just define like you define like add one like this yeah I would do something you define add two like this well what you want to do is you want to actually organize them into a class and the reason you do that is just so it's a it stays a little bit structured you can move all those classes together to another module and continue to use them and to do something like this you want to use what's called a static method now let's make a class called math and what I'm gonna do in here is I'm gonna define some methods or some functions that I'd like to be able to use but that are not specific to an instance so I don't want them have to make an instance of this math class to be able to use these methods I want to be able to call them at any points and it doesn't matter if I have an instance of the math math class or not I would like to be able to use them so what I'm gonna do is actually create what's called a static method now static means not changing right it means staying the same and that is a really good way to describe what these methods do because they do not have access to an instance just like the class method all they do is something they do something but they don't change anything that's the idea behind a static method they don't change anything because they can't they don't have access to anything so in here what we're gonna do is just say define add five and in here I don't even need to put a cell for a CLS because this is not going to access anything all its gonna do is just act as a function that is defined inside of this class and again some of you I'm sure are yelling saying what's the point of doing that why don't I just define a function globally well it's more of an organizational thing and there's some more specific applications in which you would use a static method so I do need to show them to you so here we're gonna take a number and all we're gonna do in this method is return X plus five so now if I want to actually use this what I can do is I don't need to say like M equals math like that and make an instance that's not necessary I can simply write the name of the class and math dot add five let's put five in here let's have a look if I got rid of the s and we get the value ten so this is called a static method and we can make as many of these as we would like just as we can make as many class methods as we want so maybe we do add ten right and then we have bat like that and we can change this method to say add 10 and now if we run this we get 50 so that is a static method notice it doesn't need anything in fact what I can actually do is say define you know PR let's say that's gonna stand for print let's make this an @ static method and now let's just print run like I'm just showing that you that you don't need any attributes in there are arguments and let's just call PR and now you can see that we get run and since I printed the value of that it prints them none but there we go like that okay so that is static methods and class methods and to be honest with that that is pretty much everything you need to know about classes and objects at least at a beginner level now there is some more interesting things that we could talk about but in the idea of keeping this more for beginners and so that everyone can kind of understand doesn't get to confuse I'm number frame from discussing anything further but I hope this really gave you a fundamental knowledge of how classes and objects work in Python a little recap here is to remember that everything we work with is an object in some sense we have functions which are objects we have strings which are objects integers are objects and what an object does is it a in instance of some class and that class defines the properties and almost kind of the blueprint for that object it says okay so if we have a string we can use the method like upper lower if we have an INT we can add integers together and a class the type of an object is very important because it defines the behavior in which it can exhibit so that has been classes and objects in Python and introduction to objectoriented programming I hope you guys enjoyed if you did please make sure you leave a like these videos are not that easy to make and they are definitely time consuming so I would appreciate it subscribe to the channel and of course let me know if you have any questions or if there's anything you would like to see in the future
