With timestamps:

00:03 - foreign
00:08 - I'll be sharing with you intermediate
00:11 - git and GitHub features and
00:13 - demonstrating how to use this software
00:14 - in a professional environment
00:16 - specifically I'll be discussing the
00:18 - proper way to create a pull request and
00:20 - contribute to a repository how to fix
00:22 - conflicts the difference between a
00:24 - rebase and a merge how to pull and
00:26 - modify existing branches cherry picking
00:29 - different commits and then how to reset
00:31 - history and commit and more advanced git
00:34 - and GitHub features that are not
00:35 - typically shown now this video is
00:37 - designed for people that have some
00:39 - familiarity with Git but if you're a
00:41 - beginner or just need a refresher then
00:43 - feel free to check out the video that
00:44 - I'm going to put on the screen which
00:46 - will give you the fundamentals you need
00:47 - to then go through this video lastly I'm
00:50 - happy to mention that this video is
00:51 - sponsored by Microsoft who helped me
00:53 - develop this video and on May 9th we'll
00:55 - be hosting a 45 minute long webinar as a
00:58 - part of the developer digital Meetup
01:00 - tour this webinar will go much more in
01:02 - depth on this topic and teach you about
01:04 - Advanced developer workflows while also
01:06 - including a live q a session at the end
01:09 - to register for the webinar go to AKA
01:11 - dot Ms slash Tech with Tim or click the
01:14 - link in the description with that said
01:16 - let's dive into the video
01:18 - [Music]
01:22 - alright so let's go ahead and get
01:24 - started so in front of me I have a
01:26 - sample GitHub repository and what I'm
01:28 - going to do in this section of the video
01:30 - is demonstrate to you how to correctly
01:32 - create a pull request and contribute to
01:34 - a repository now this is going to be
01:36 - more applicable if you're working in a
01:37 - team environment with multiple
01:39 - developers or for a company if you're
01:41 - just working on your own kind of solo
01:43 - git repository or GitHub repository this
01:46 - isn't going to be super applicable and
01:47 - you don't need to follow these steps but
01:48 - whenever you're working with more than
01:50 - one developer you're going to want to do
01:51 - what I'm outlining here just to keep
01:53 - everything clean and kind of best
01:55 - practice
01:56 - so first thing to understand here when
01:58 - we're looking at this repository if I
01:59 - can open it back up is that we have a
02:01 - branch called main or in some instances
02:03 - it's going to be called Master now you
02:05 - can see this is the default Branch now
02:07 - your main branch in most instances is
02:10 - going to be the branch that you want to
02:12 - have clean reviewed and finalized
02:15 - functioning code on what that means is
02:17 - that you don't want to be directly
02:19 - contributing work that's not finished to
02:21 - the main or Master Branch you want to be
02:23 - doing essentially all of your Dev work
02:25 - on in a kind of additional Branch so a
02:27 - feature branch and then once you've
02:29 - finished a completed feature or bug fix
02:31 - or whatever it may be then you're going
02:33 - to merge that onto the main or Master
02:35 - Branch so in most repositories your main
02:38 - or Master branch is going to be locked
02:40 - which means unless you're a I guess you
02:43 - would call this an admin of the
02:44 - repository you're not able to actually
02:46 - directly contribute to this Branch
02:48 - instead what you need to do is work on
02:50 - an additional branch that is forked off
02:52 - of the main or Master branch and then
02:54 - merge it onto the master bedroom our
02:56 - main branch once it's been reviewed and
02:58 - your code is completed tested and
03:00 - functioning so just keep that in mind
03:02 - your main branch you want to always be
03:04 - kind of production ready to some extent
03:06 - and always fully functioning so that
03:09 - additional people can always revert back
03:11 - to the main branch and know this is kind
03:13 - of the current uh version of the
03:15 - repository the current up-to-date State
03:17 - whereas all these other branches are
03:19 - Works in progress that are eventually
03:21 - going to be contributed onto the main or
03:23 - Master Branch alright so with all that
03:25 - said let's actually get into an example
03:26 - of making a contribution then to this
03:28 - repository keeping in mind that we want
03:30 - to do our work on an additional branch
03:32 - and that eventually merge it into this
03:34 - main branch okay so I've opened this
03:36 - repository here in Visual Studio code
03:38 - and I want to start creating a feature I
03:41 - want to start adding some code now
03:42 - obviously I'll just do something simple
03:43 - for this video but what is the process
03:45 - to do this well the first thing I always
03:47 - do is I check what branch I'm currently
03:50 - on by typing git branch in this case I'm
03:53 - on the main branch that's what I want to
03:55 - be on and what what I like to do before
03:57 - I start working or creating a new Branch
03:58 - or feature is I like to make sure that
04:00 - my local repository is up to date with
04:03 - the remote repository this is just going
04:04 - to save me a ton of headaches in the
04:06 - future so what I do is I type A git pull
04:09 - when I do that that's going to pull all
04:11 - of the changes from the remote
04:13 - repository to my local repository and
04:16 - keep my local version of the main or
04:18 - massive Branch up to date so what I'm
04:20 - trying to do locally is always keep this
04:22 - main branch up to date with the remote
04:24 - repository you know every day I like to
04:26 - make a poll something along those lines
04:28 - so that whenever I decide to Fork off of
04:30 - Main I'm not forking too far kind of in
04:33 - the past and I have a very up-to-date
04:35 - version of the code base there's
04:36 - different ways to do this but this is
04:38 - what I'd like to do now you may have to
04:40 - actually fully type out git pull origin
04:42 - and then whatever the branch name is in
04:44 - this case it's going to be main it's
04:45 - going to do the same thing here in my
04:47 - case the get pull command is just
04:48 - automatically set up to pull from this
04:50 - main branch when I'm on that Branch okay
04:53 - so now I'm fully up to date with the
04:55 - remote Repository uh and what I'm going
04:57 - to do is create a new Branch so I'm
04:58 - going to type git checkout hyphen B
05:01 - standing for a new branch and I'm going
05:02 - to give this a name now when you name a
05:04 - branch it's typically a good idea to
05:06 - give it some kind of unique prefix that
05:08 - is specific to you so you don't
05:10 - accidentally name Branch the same thing
05:13 - that someone else has named that's
05:14 - eventually going to push it to the
05:16 - repository so what I'll do typically is
05:18 - something like get checkout hyphen B and
05:21 - then Tim
05:22 - and in this case I'll say feature now
05:24 - obviously whatever the feature name is
05:26 - like if this was a leaderboard or a
05:28 - scoring system or whatever I would name
05:29 - it that in this case we'll just do
05:30 - something generic which is feature now
05:32 - again the reason I use Tim is because if
05:34 - someone else is working on a branch
05:35 - called feature we could have kind of
05:37 - conflicts and be pushing to the same
05:39 - remote repository branch which could
05:42 - kind of cause some headaches so it's a
05:44 - good idea just to prefix your branches
05:45 - with your name or some unique ID that no
05:48 - one else is going to be using alright so
05:49 - I'm on my new branch and now that I'm on
05:51 - my new Branch I can go crazy I can
05:53 - create my new features so let's say my
05:54 - new feature is just a text file okay so
05:57 - we'll just say feature Dot txt and I'll
05:59 - say this is a great feature okay perfect
06:03 - I'm going to save that now obviously we
06:05 - can go through our standard gate
06:06 - commands we can also just use the
06:07 - interface here in vs code and I can add
06:10 - these changes to the staging area so git
06:12 - add dot then I can make my commit I'm
06:14 - going to do the commit message using
06:16 - hyphen M and I want to name this
06:17 - something meaningful it's going to be
06:19 - easy to review later on so I would say
06:21 - added a feature
06:25 - dot txt file and actually it's standard
06:29 - practice to write this in present tense
06:31 - not in past tense now it doesn't really
06:33 - matter I don't see many people actually
06:35 - follow this practice but you are
06:36 - supposed to write this in present tense
06:38 - uh not past tense so add a feature.txt
06:41 - file as if you're doing it kind of right
06:43 - now okay so I've done that I've now
06:45 - created my commit and now I'm at the
06:47 - point where I actually want to push this
06:48 - to GitHub I want to get my code reviewed
06:50 - and then I want to contribute this to
06:52 - the main branch so other developers can
06:54 - start using this so if I want to do this
06:56 - now what I need to do is I need to push
06:58 - this Branch so I'm going to type git
06:59 - push
07:00 - Tim Dash feature when I do that sorry I
07:04 - need to First specify the location I'm
07:06 - going to push to so get push origin Tim
07:08 - feature because origin is the remote
07:10 - repository I want to go to so we're
07:12 - going to push to this remote repository
07:13 - and now you can see it's created a new
07:15 - branch on the remote repository called
07:17 - Tim feature so by me simply doing this
07:20 - push because I had access rights to this
07:22 - GitHub repository I've now created this
07:24 - new branch and if I click on this button
07:26 - and I view all branches you can see that
07:28 - there's a Tim feature Branch right here
07:30 - and I have the option to manually click
07:32 - create new pull request I can also view
07:34 - this Branch by clicking on it and then
07:36 - view that this new file is here I also
07:38 - have the ability to just press this
07:40 - button which is automatically being
07:41 - generated by GitHub although sometimes
07:43 - it doesn't actually give that to you
07:45 - based on kind of when you contribute if
07:47 - you change something
07:48 - all kinds of reasons why you may not see
07:50 - this button so I wanted to show you
07:52 - manually you can go here and then click
07:53 - that okay so I'm going to go compare and
07:55 - pull request now we get to the pull
07:57 - request kind of template page now
07:59 - typically when you get to this page
08:00 - there's going to be some kind of
08:01 - template that you'll need to fill out
08:02 - depending on the organization that
08:04 - you're working for and it may tell you
08:05 - to upload some photos or to tick some
08:07 - boxes or to describe the feature
08:09 - whatever you got the idea you want to
08:10 - give a descriptive pull request name and
08:13 - the point is that through this pull
08:14 - request you may actually go back
08:16 - um kind of in the future and say okay
08:18 - what did I change here what were the
08:19 - changes and you just want to have a
08:21 - decent name so it's easy to find what
08:23 - this pull request is so in my case we've
08:25 - done a very simple thing which is just
08:26 - add a file that's about as much
08:28 - subscription as I need to add than if I
08:30 - wanted to I could add additional
08:31 - comments again in this case I don't need
08:33 - to do that but it is good practice to
08:35 - add as much detail as you possibly can
08:37 - so I'm going to click on create pull
08:38 - request and now what I've done is I've
08:40 - created my pull request now this pull
08:42 - request will typically need to be
08:44 - approved depending on the settings of
08:46 - the GitHub repository before it's able
08:48 - to be emerged into the main branch so in
08:52 - my case I can just directly merge it in
08:53 - here because I'm an admin of the GitHub
08:55 - repository however if someone who was
08:57 - not was working on this repository then
08:59 - someone like myself would have to review
09:01 - their pull request and then approve it
09:03 - before they'd be able to actually merge
09:05 - it in
09:06 - so if I go here to reviewers if there
09:08 - was other people on this repository I'd
09:10 - be able to select them and say request
09:12 - review so that's typically what you're
09:14 - going to do and then you're gonna have
09:15 - to wait for them to come here and review
09:17 - the pull request now in my case I can
09:19 - show you an example of doing that
09:20 - because you may also do that for other
09:22 - people's pull requests so here it says
09:24 - review changes I can obviously go and
09:25 - look through all the changes and tick
09:27 - the files that I've seen and if you had
09:28 - more files and directories it would show
09:30 - you that setup on the left hand side
09:31 - anyways it's quite simple here so I'll
09:33 - click on review changes maybe I leave a
09:35 - comment here and I ask them why they did
09:37 - something a certain way I also can
09:39 - select a line here click on this plus
09:41 - button and then directly add a comment
09:43 - on this line so I can add a single
09:46 - comment right here and now if you go to
09:48 - the conversation tab you'll see that
09:50 - there's a comment kind of discussing a
09:52 - specific line and then you could reply
09:54 - to that comment and kind of keep all
09:55 - your conversation on one pull request so
09:57 - that you have history of it and you can
09:59 - look at it later you can also resolve
10:00 - the conversation which means you've kind
10:02 - of fixed whatever they commented on now
10:04 - you'll see when I go here that it's tell
10:06 - telling me that I can't approve or
10:07 - request changes because I'm the author
10:09 - again that kind of makes sense but what
10:11 - I would do if this was someone else's
10:12 - pull request I would review it I would
10:13 - leave some comments and then I would
10:15 - approve it and then they would be able
10:16 - to merge so I just want you to
10:18 - understand that this is the process
10:19 - right you create this pull request and
10:21 - now I can merge this pull request into
10:23 - the repository I'm going to delete this
10:25 - branch which is typically good practice
10:27 - you want to keep your branches clean
10:28 - that you're not using I'm going to go
10:30 - back to code and now notice that I've
10:32 - created a merge commit here that has
10:34 - merged all of this content into the main
10:37 - branch so now I have my one branch I
10:39 - have feature.txt on here and everything
10:42 - is up to date and we can go and look at
10:44 - the three commits we have our initial
10:45 - commit this and then we have the merge
10:48 - commit which is actually merging all of
10:50 - my code from my Branch into this main
10:52 - repository okay we're almost done here
10:54 - now we go back here okay
10:56 - we're working on some other feature or
10:58 - maybe it's the next day we want to do
10:59 - some new code so now what I want to do
11:01 - is I want to get check out the main
11:05 - branch remember you always want to keep
11:07 - your main branch your local copy of the
11:09 - main branch up to date with the remote
11:11 - repository so I'm going to go to my main
11:12 - branch and then I'm going to type git
11:14 - pull and I'm going to pull down the
11:16 - remote changes now even though I've
11:18 - already made these changes locally I've
11:20 - only made them on my other Branch so on
11:23 - my Tim feature Branch not on the main
11:25 - branch so I go to main I pull that gives
11:28 - me the changes from the remote
11:29 - repository including that merge commit
11:31 - and now I can create new branches and
11:34 - work off this main branch to avoid any
11:36 - conflicts now you'll see that if I go
11:39 - get checkout so let's go here
11:42 - get check out Tim Dash feature and I try
11:46 - to push this up so get push origin and
11:50 - then Tim
11:51 - feature like this
11:54 - it's gonna create this new Branch okay
11:56 - so it creates a new Branch now I'm gonna
11:58 - go back to the GitHub repository and we
12:01 - are going to go here we're gonna go to
12:03 - Tim feature and it says this one commit
12:05 - behind main now the reason it's saying
12:07 - it's one commit behind main even though
12:09 - it has the same content is because the
12:11 - main branch has a merge uh merge commit
12:14 - sorry that merge these two things in
12:15 - whereas my current local copy doesn't
12:17 - have that merge commit so I don't want
12:20 - to keep working on this Branch because I
12:22 - could potentially be getting conflicts
12:23 - instead what I want to be doing is
12:25 - creating a new branch and then working
12:27 - off that hopefully that makes a little
12:29 - bit of sense of what I'm describing here
12:31 - I'm just going to go back to the main
12:32 - branch though so get checkout Main
12:34 - okay and now I would create a new Branch
12:37 - so git checkout hyphen B and then Tim
12:40 - feature two and this is where I would do
12:43 - any additional changes this branch is up
12:45 - to date with the main branch meaning
12:47 - that whenever I make a push I'm not
12:49 - going to have any conflicts at least I
12:51 - shouldn't have any conflicts based on
12:52 - how we're doing this right now and it
12:53 - should just be kind of smooth sailing to
12:55 - add new code to the code base
12:59 - [Music]
13:02 - alright so continuing here the next
13:04 - thing I'm going to go through is
13:05 - resolving conflicts and I'm going to
13:07 - kind of explain to you why a conflict
13:08 - occurs because this is a point where
13:10 - people get very frustrated and
13:12 - oftentimes kind of don't know how to
13:14 - deal with this in some kind of
13:15 - production environment or you know kind
13:17 - of workplace team environment so what
13:19 - I'm going to do here is essentially
13:20 - create a conflict now before I do that
13:23 - I'm just going to look at the current
13:25 - status of my repository so it says I'm
13:28 - on Tim feature two so what I'm going to
13:30 - do is check out the main branch again
13:32 - I'm going to pull to update everything's
13:34 - up to date okay and now I'm going to
13:37 - delete these two branches that I don't
13:39 - need just so that I don't get confused
13:41 - and accidentally use them throughout
13:42 - this section
13:43 - so I'm going to type git Branch hyphen
13:46 - capital D and then I'm going to go Tim
13:48 - feature that's going to delete that
13:49 - branch
13:50 - and I'll do the same thing with Tim
13:52 - feature two alright so now let's create
13:54 - a conflict so let's clear let's go get
13:57 - check out hyphen B Tim Dash and we'll
14:01 - just go C1 for conflict one and all I'm
14:04 - gonna do here is go to this file and I'm
14:06 - just going to delete this line okay so
14:08 - I've deleted that line here now I'm
14:09 - gonna go get add dot git commit hyphen m
14:12 - delete
14:14 - line
14:15 - in and then feature dot txt okay and
14:19 - then I'm going to push this up to GitHub
14:21 - now you'll see in a second kind of how I
14:23 - create the conflict for now though all
14:25 - I'm doing is just making a change the
14:26 - repository which is not going to cause a
14:28 - conflict okay so I've gone here uh and
14:31 - you can see
14:32 - then now I have Tim C1 and I can create
14:33 - a pull request so I'm going to do that
14:35 - create pull requests and I'm going to
14:37 - create that now for now I'll just leave
14:38 - this on the repository and we can merge
14:40 - it in later all right now what I'm going
14:42 - to do is go get checkout and then main
14:45 - now notice here that we still have the
14:47 - text inside of the file okay so now I'm
14:48 - going to create a new Branch now imagine
14:50 - that I was doing this as a different
14:52 - user so you know Tim me just created a
14:55 - branch that I uploaded for a pull
14:57 - request that Branch deleted a line now
14:59 - imagine some other developer is checking
15:01 - out a branch from their local main copy
15:03 - they don't have that deleted line
15:05 - because that was worked on on a separate
15:07 - branch and now what they're going to do
15:09 - is maybe modify this liner they're going
15:10 - to modify this file in some way this is
15:12 - kind of how a conflict will occur so I
15:14 - go get check out hyphen B I'm going to
15:16 - go Tim C2 for conflict two okay and here
15:19 - all I'm going to do is say this is a
15:20 - great feature Tim is the best uh just
15:23 - two true statements on one line okay so
15:26 - now that I've done this I'm going to do
15:27 - the same thing I'm going to push this up
15:28 - for a pull request I'm gonna go get push
15:31 - origin and then Tim C2 so essentially
15:34 - what I've done here is I've created two
15:36 - separate branches each branch has made a
15:39 - change on the same file and in this case
15:41 - on the same line so what that means is
15:44 - that there's conflicting changes on both
15:46 - of these branches so I'm going to go
15:47 - back here to pull requests let's go to
15:50 - code
15:51 - let's go to our branches Tim C2
15:54 - and let's create a pull request uh okay
15:58 - for some reason uh apologies for the cut
16:01 - here I realized I forgot to make my
16:02 - commit so I'm gonna go get add dot get
16:05 - commit hyphen m
16:07 - I'm just gonna go with a simple one like
16:09 - make changes and now I'm gonna push this
16:11 - again back up to the repository so that
16:15 - now I will see it here okay so Sim Tim
16:17 - C2 has changes so let's go here and make
16:20 - changes Okay so we've created two pull
16:22 - requests and you'll notice that on both
16:24 - of these pull requests right now
16:25 - everything's completely fine I can merge
16:27 - them in because all I've done is made a
16:29 - change to one of the lines in this case
16:31 - I've deleted the line okay and then on
16:32 - my other pull request here I have simply
16:35 - added to the line so what I'm going to
16:37 - do is just pick any of the pull requests
16:38 - it doesn't matter which one I pick here
16:39 - and I'm going to make a change
16:41 - okay so I'm going to confirm this uh now
16:43 - this is the file that is adding to the
16:46 - line okay so let's confirm this merge
16:48 - all right and check that okay now this
16:51 - is in I'm going to delete this branch
16:52 - and what you're going to see is when I
16:53 - go back here now all of a sudden it's
16:56 - going to show me that I have a conflict
16:57 - now the reason it's telling me I have a
16:59 - conflict is that the change that I've
17:01 - made here is trying to change the same
17:04 - line that was just changed in the
17:06 - previous pull request but on a different
17:08 - version of the file now I know this
17:11 - seems kind of strange but essentially
17:13 - both of these branches were kind of
17:15 - merged or sorry forked off of the main
17:18 - branch at the same time so two minutes
17:20 - ago I created these two new branches
17:22 - they both modified the same version of a
17:25 - file and now I've checked it's called
17:28 - checking in but I've merged one of these
17:31 - file changes into the main repository
17:33 - but this Branch was making a change to a
17:36 - previous version of that file so it was
17:38 - making a change to a version different
17:40 - than what is now inside side of the
17:42 - repository hopefully that makes a little
17:44 - bit of sense but the actual definition
17:46 - here of one emerge conflict occurs is
17:48 - when people make different changes to
17:50 - the same line or the same file or when
17:52 - one person edits a file and another
17:53 - person deletes the same file so that's
17:55 - exactly what's happening here we're
17:57 - editing the same line in the same file
17:59 - and git doesn't know what version of the
18:01 - file to take
18:03 - so we have to resolve these conflicts
18:04 - now we can do this in Visual Studio code
18:07 - or we can do this here on GitHub alright
18:10 - so now that I'm inside of this file I'll
18:11 - quickly explain what this syntax means
18:13 - so in between these two symbols here
18:15 - where it says Main and it shows all of
18:17 - the equal signs this is what's currently
18:19 - on the GitHub repository okay this is
18:21 - what's currently here and then this um
18:23 - kind of weird because I've deleted a
18:25 - line but this is what's on this Branch
18:27 - so essentially what it needs me to do
18:29 - here is delete all of these symbols that
18:31 - have been added in now I can put
18:33 - anything I want in this file but it
18:35 - needs these symbols to be removed before
18:36 - it's going to tell me that I've marked
18:38 - or before it's going to allow me sorry
18:39 - to mark this file as resolved so that's
18:42 - one way you can do this directly from
18:43 - the editor on GitHub or you can do this
18:46 - from vs code so I'll show you from vs
18:47 - code as well if I go back to visual
18:50 - studio code here now what I can do is I
18:52 - can try to update my C2 Branch with the
18:55 - main branch so the way I'll typically do
18:57 - this is I'll go get checkout main I'll
19:00 - pull main which is going to give me the
19:02 - fixes so or the updates now it's going
19:04 - to modify this file and now I'm going to
19:06 - go get chick checkout and then in this
19:08 - case it's C1 and now what I'll do is I
19:11 - will merge the main branch with this
19:13 - branch and when I do that you're going
19:15 - to see that I get a merge conflict
19:16 - Happening Here locally I can then fix
19:18 - that and then re-push to GitHub and then
19:21 - everything will be okay so what I'm
19:23 - going to do is go get
19:24 - and then this is going to be merge and
19:26 - I'm going to merge main now I could
19:28 - merge origin slash main or I can just
19:32 - merge mate now if I do main that's my
19:34 - local copy which in this case is fine
19:35 - because I know that's up to date with my
19:37 - origin or my remote repository
19:40 - alternatively if I knew it wasn't up to
19:42 - date then I would just do origin slash
19:43 - main in this case they're both going to
19:45 - give me the same result origin slash
19:47 - main by the way of course is the remote
19:48 - repository and then the version of the
19:50 - main branch on there okay so I'm going
19:53 - to hit enter here and notice it says
19:55 - automatic merge failed fix the conflicts
19:56 - and then commit the result now here we
19:58 - get some better kind of choices so we
20:00 - can accept the current change or the
20:02 - incoming change or both changes or
20:04 - alternatively we can just manually
20:06 - update this file now for clarity here
20:08 - the incoming change is what's coming
20:10 - from the remote repository or from the
20:13 - other branch and then the current change
20:14 - is what you currently have on your
20:16 - current Branch so what I can do is
20:18 - accept the current change if I actually
20:20 - want to delete this line then I'm going
20:23 - to save and then what I need to do is I
20:25 - need to commit the results so I'm going
20:26 - to fix the conflicts and commit the
20:28 - result my file is already added into the
20:30 - staging area so just type git commit
20:32 - hyphen M and I say fix
20:35 - dot txt file
20:38 - conflicts okay this is kind of my merge
20:40 - commit now
20:41 - I'm gonna do that uh and sorry actually
20:43 - I forgot I have to add this to the
20:44 - staging area I thought it was already
20:45 - there and then I commit okay so now that
20:48 - I've made my commit here what I can do
20:50 - is re-push this so I'm going to type get
20:52 - push origin Tim C1 and now that I
20:56 - re-push this to the remote repository
20:58 - with the conflicts fixed so we're gonna
21:01 - go here all right uh I should be able to
21:04 - just merge this directly in and you'll
21:06 - notice that now I have two commits so I
21:07 - deleted the line and then I have what's
21:09 - referred to as a merge commit which is
21:10 - what I made to merge the changes from
21:13 - the main branch onto my feature Branch
21:15 - so now when I merge my feature Branch
21:18 - back onto the main branch the history is
21:20 - correct and everything is up to date I
21:22 - know this can be a little bit confusing
21:24 - but what I just did to fix the conflict
21:26 - was I essentially merge my Branch with
21:28 - the main branch so that I integrated all
21:31 - of the changes from the main branch onto
21:33 - mine I then from that point forward
21:35 - created the change I wanted to put on
21:38 - the main branch which is what we've done
21:40 - by deleting the line and now I am able
21:42 - to merge this pull request in
21:45 - okay I again I apologize this stuff is
21:48 - not simple hence why this video is
21:49 - intermediate kind of GitHub topics but
21:51 - that is how you go about fixing a merge
21:53 - conflict now obviously the conflicts you
21:56 - can you get can be much nastier than
21:58 - what I just showed you here uh there is
22:00 - some more advanced tools that you can
22:01 - use to fix these however typically what
22:04 - you want to do to avoid getting too many
22:06 - conflicts is always be branching off of
22:09 - a clean version of the main repository
22:11 - if you're doing that or sorry off the
22:13 - main branch if you're doing that you're
22:15 - going to limit the amount of conflicts
22:16 - that you have and you know once in a
22:18 - while yes you will get them but what you
22:20 - need to do then is merge with the main
22:22 - branch and then you'll have to manually
22:24 - go through and fix all of those
22:25 - conflicts once you fix them then you can
22:27 - re-push and then you'll be able to merge
22:30 - back into the Repository
22:33 - [Music]
22:36 - all right so I've just moved to the
22:38 - drawing tablet here because I'm going to
22:39 - quickly explain to you the difference
22:41 - between a merge and a rebase which are
22:43 - two popular commands to integrate
22:45 - changes from different branches that
22:47 - many developers don't actually
22:48 - understand so it's helpful to view these
22:51 - visually they're actually not overly
22:52 - complicated but you just want to
22:54 - understand kind of the core difference
22:55 - between what emerge is doing uh compared
22:57 - to a rebase so let's just draw a simple
23:00 - example here of a git history so all of
23:04 - these circles are going to be commits
23:05 - and this white Branch here is going to
23:07 - be our main or our Master Branch now
23:10 - let's say at some point in time we
23:11 - decided we're going to start creating a
23:12 - feature and maybe we did that here okay
23:14 - so at this point we decided to Fork off
23:16 - and we created a new branch
23:19 - in this Branch maybe we called something
23:21 - like C1 now obviously that's a horrible
23:23 - name but we decided to call it C1 there
23:24 - we go we have our C1 feature wrench now
23:27 - let's say that we are here and we
23:30 - decided this point in time okay you know
23:31 - we finished our feature now we want to
23:33 - actually kind of combine this or merge
23:35 - this into the code base there's a few
23:38 - different ways to go about doing this we
23:40 - also may just want to update our current
23:42 - Branch to integrate all of the changes
23:44 - from Main so let's put put it in that
23:46 - scenario we want to update our current
23:48 - Branch with all the changes from Main so
23:50 - that way when we continue working we
23:51 - have an up-to-date code base
23:53 - everything's kind of you know updated
23:54 - nice and clean and ideally we're gonna
23:56 - kind of remove the riskiness or remove
23:59 - sorry the likelihood of having a
24:01 - conflict okay so we want to take changes
24:04 - from here that have happened since we've
24:05 - been working on this branch and
24:07 - integrate them here obviously what's
24:09 - happened is since we've branched off new
24:10 - code has been added to the main branch
24:12 - we want that code now in this Branch how
24:15 - do we get that well the First Command we
24:17 - can run is our merge now when we decide
24:20 - to run a merge what's going to happen is
24:22 - a new commit is going to be created this
24:25 - is called our merge commit and I'm going
24:27 - to put an asterisks here which means
24:29 - it's new now what this merge commit is
24:31 - going to do is it is going to
24:33 - essentially combine all of the changes
24:35 - since we branched off with the changes
24:38 - from this Branch so it's a brand new
24:40 - commit and it just combines well all of
24:43 - these different changes now a conflict
24:45 - could occur here if that's a case we
24:46 - need to fix that and then the kind of
24:48 - conflict fix will be involved in this
24:50 - merge commit alright so we create this
24:52 - merge commit it essentially combines
24:53 - everything together and now say I'm on
24:56 - my Branch C1 if I were to continue to
24:58 - work I would kind of add off of this
25:01 - merge commit and there we go now I have
25:04 - all the changes from my main branch and
25:06 - I'm continuing to work now the advantage
25:08 - here of creating this merge commit is
25:10 - that I keep the entire history of my git
25:13 - repo what I mean by that is I know still
25:17 - all of these different commits I know
25:19 - when I originally branched off and I
25:21 - know at what point in time I decided to
25:23 - do this merch now the disadvantage is
25:26 - that this merge commit is very messy
25:28 - oftentimes it kind of messes up the
25:30 - history you can see here now we have a
25:32 - non-linear history because we have
25:33 - different branches kind of being
25:35 - integrated together and it can make the
25:38 - history of the GitHub repository well
25:39 - just very messy right it's difficult for
25:42 - me if I'm reviewing this later on to
25:44 - understand if I should be looking down
25:45 - here if I should be looking up here if
25:47 - I'm looking after the merge commit it
25:48 - just kind of complicates things a little
25:50 - bit when you're going back and review it
25:52 - okay so that's a disadvantage but again
25:54 - the advantage is you're retaining all of
25:57 - this history and you know everything
25:58 - that's occurred you're not losing any
26:00 - information you've just added this
26:02 - additional merge commit which can make
26:03 - things a little bit messy now one thing
26:05 - to note here is that since I've
26:07 - integrated main with my C1 branch that
26:10 - doesn't mean that on my main branch I
26:13 - now have my C1 one changes only if I've
26:16 - actually made a pull request and kind of
26:18 - merged this into the main branch am I
26:20 - going to have that if I were to locally
26:22 - check out the main branch now as I
26:25 - continue to work I'm going to continue
26:26 - to Branch off of my main branch and then
26:29 - later maybe I integrate the changes of
26:31 - C1 but what I've done is I've taken the
26:33 - changes from Main and put those on my C1
26:35 - Branch not the other way around it's not
26:38 - going to happen on both branches it just
26:39 - happens on the branch you're currently
26:41 - on when you run the git rebase commit
26:44 - okay now let's talk about merge so I
26:47 - think actually will be easier if I just
26:48 - delete all of this so let's erase all
26:50 - the ink okay so now what happens when we
26:52 - do a rebase well what a rebase is doing
26:56 - is taking essentially this entire Branch
26:59 - here so all of the code that we've done
27:01 - and it's just moving it to be at the tip
27:04 - of our main branch so let's say I'm on
27:07 - to C1 right I want to integrate my main
27:08 - changes then all I do is I rebase it and
27:12 - when I rebase it it moves my brand inch
27:15 - over here now obviously it's a little
27:16 - bit more complicated than that but
27:17 - that's essentially what's happening
27:19 - rather than creating a new commit here
27:21 - which is a merge of these two branches
27:24 - together I am simply taking all of this
27:27 - code or all of these commits sorry from
27:29 - this branch and I'm moving them so that
27:32 - now they're going to be attached at the
27:35 - head of my main branch or whatever
27:36 - Branch I am merging or sorry rebasing
27:39 - with my
27:41 - what do you call it feature Branch now
27:44 - what actually happens here is this right
27:47 - so this new branch is going to contain
27:49 - entirely new
27:51 - commits all the asterisks are just new
27:53 - commits what happens is my original
27:55 - branch which I can kind of do like this
27:58 - so my original commits are going to be
28:01 - copied and added to the head so I'm not
28:04 - taking the same commit I'm actually kind
28:06 - of copying them and turning them into a
28:08 - brand new commit and then attaching them
28:10 - to the head of whatever Branch I'm
28:13 - rebasing with now the reason why this is
28:15 - nice is that we no longer have a merge
28:18 - commit and our history is fully linear
28:21 - so now it's very easy for me if I'm
28:23 - reviewing this later on to understand
28:24 - that okay I just go from here here down
28:27 - to here I don't have this kind of fork
28:29 - in the road where I have this merge
28:30 - commit that's combining the two
28:32 - different branches I have a full linear
28:34 - history the disadvantage of doing this
28:37 - is that I lost all of the history that I
28:39 - previously had when I decided to Branch
28:42 - off so again we originally had branched
28:45 - here and if we had done a merge we would
28:47 - have known that we branched here we
28:49 - would have known all the commits that
28:50 - were on this Branch versus here now when
28:53 - I do the rebase it becomes unclear I
28:55 - lose that history and instead I kind of
28:58 - trade that for this straight linear
29:00 - history so you might be asking yourself
29:03 - now okay I understand you know rebase is
29:05 - essentially attaching to the head and
29:07 - what actually occurs here is we apply
29:09 - every single one of the commits that are
29:11 - on our Branch to this Branch right so
29:14 - we're really just tacking them on that's
29:15 - all that's happening and these become
29:17 - new commits but you might be asking
29:19 - yourself well when do I use which right
29:21 - when do I use rebase first when do I use
29:23 - merch well the Golden Rule here is that
29:26 - you never want to use a rebase on a
29:29 - public Branch now what I mean by a
29:30 - public branch is a branch that someone
29:32 - else could potentially be working on the
29:35 - reason you don't want to do that is
29:36 - because if someone else has a copy of
29:38 - the branch that looks like this and then
29:41 - you rebase and you push that Branch when
29:44 - they pull this they're going to get all
29:46 - kinds of conflicts and they're going to
29:48 - have a completely different version of
29:49 - the branch locally than what you've
29:51 - pushed so you've now moved every single
29:54 - one of your commits over to the head of
29:56 - the main branch where theirs are still
29:58 - forked off and have not been rebased and
30:01 - when they decide to do a pull uh there's
30:03 - just kind of you know like a mini
30:04 - disaster that's going to occur so
30:05 - essentially it's referred to as the
30:07 - golden rule of rebase is you never use
30:09 - this on a public branch which is a
30:11 - branch that anyone else could be um kind
30:14 - of using now this is a little confusing
30:16 - because if I have a local branch it's
30:19 - fine for me if I'm working on kind of a
30:21 - local feature Branch to rebase that
30:23 - Branch against my main Bridge it's fine
30:25 - for me to put my C1 Branch like it is
30:27 - right now because I'm the only one
30:29 - working on this C1 Branch I can fix all
30:32 - of the conflicts and then I'm going to
30:33 - push that up to get I'm going to have my
30:35 - nice clean history I can then merge that
30:37 - in
30:38 - to my main branch and then anyone else
30:41 - can simply pull the main branch which
30:43 - will have its nice clean linear history
30:45 - and then allow uh allow them sorry to
30:48 - just continue working so the simple
30:50 - summary here on when to use rebase is
30:51 - when you're working on a private Branch
30:53 - so that means pretty much only you are
30:55 - working on the branch and you're trying
30:56 - to update essentially the state of your
30:58 - branch to match the state of a remote
31:00 - Branch or some other Branch you can use
31:02 - rebase however if you're working on any
31:04 - kind of public Branch then instead
31:06 - you're going to want to use merge that
31:08 - you don't lose any history and you're
31:10 - not going to mess anyone else up that is
31:12 - using that same Branch so just remember
31:14 - those two rules if it is a public Branch
31:16 - then you use merge if it is your own
31:19 - private Branch then you are fine to use
31:21 - the rebase command
31:24 - foreign
31:27 - switched back to the computer and for
31:29 - this next section in the video what I'm
31:31 - going to show you is how to check out
31:32 - and modify an existing Branch from
31:34 - GitHub that is not the main branch so
31:37 - you can see here that I've created a new
31:38 - branch called Tech with Tim patch one
31:40 - I've made a pull request using this
31:42 - branch and let's say that now I'm a new
31:45 - developer I'm looking at this code and I
31:47 - want to modify this Branch so maybe I
31:50 - want to push directly to this pull
31:51 - request or I just want to get access to
31:53 - the branch whatever I want it from this
31:55 - remote repository how do I get this well
31:57 - let's go to my local GitHub repo here
32:00 - and first I'm going to type git Branch
32:01 - notice I don't have this Branch even if
32:05 - I type git pull
32:06 - and this will actually give me all of
32:08 - the branches by the way from the remote
32:10 - repository if I didn't already have them
32:12 - even when I type this and I type git
32:14 - Branch again it's not going to show me
32:16 - this Branch now there is a way to view
32:18 - these kind of remote branches however if
32:20 - you know the name of the branch and you
32:22 - just want to it's directly go to the
32:24 - state of that Branch then what you can
32:26 - do is to follow it you can type git
32:28 - checkout and then you can just put the
32:31 - name of the branch in this case it's
32:32 - going to be Tech with Tim patch one now
32:34 - notice that I haven't put hyphen B I
32:36 - didn't put origin I didn't put anything
32:38 - special I'm not creating a new Branch
32:40 - I'm checking out a branch that exists on
32:43 - the remote repository so since I know
32:45 - the name I'm just going to put it here
32:46 - and when I hit enter it's going to say
32:48 - switch to a new Branch so it
32:49 - automatically creates one for me and
32:51 - this branch is tracking the remote repo
32:54 - now what that means is that I'm gonna
32:56 - have the same state as the remote
32:59 - repository Branch at the time that I ran
33:02 - this code and now any changes that I
33:05 - make are happening locally and I can and
33:07 - then push them to the remote repository
33:09 - so let's say I go here and create a new
33:11 - file
33:12 - okay new file.txt
33:15 - a new text all right perfect I can now
33:19 - type git add Dot
33:21 - get command hyphen m
33:24 - create file and then I can push this now
33:27 - to the remote repository so I'm going to
33:29 - type git push origin Tech with Tim Dash
33:35 - patch dash one
33:37 - okay I do that I'm now able to push my
33:41 - code I go here and refresh and notice
33:43 - that I've added this new commit to this
33:45 - Branch okay so that's something you can
33:47 - do fully valid I just want to show you
33:49 - that's how you do it you check out the
33:50 - branch name it's then going to
33:52 - essentially track that Branch from the
33:54 - remote repository if the branch exists
33:56 - on the remote repository and then you
33:59 - have that state and then you can do
34:00 - whatever you want now similarly someone
34:02 - else may change something on this Branch
34:04 - right so you go to Tech with Tim patch
34:05 - one maybe they go to feature uh go here
34:08 - and they edit this and they say
34:10 - another line okay so let's do this
34:12 - commit changes I'm just going to commit
34:15 - uh directly commit that to the branch
34:16 - okay now I'm here and you'll see that I
34:20 - don't have these changes so if I want to
34:21 - get those changes then I can type get
34:23 - pull now what might happen is I could
34:26 - maybe potentially have a conflict here
34:28 - right so like I edit this line and then
34:30 - I type get add dot get commit hyphen M
34:34 - okay I don't know fix whatever I'm just
34:36 - doing random commit messages and then I
34:38 - try to push this again get push origin I
34:41 - should already have this command okay so
34:43 - you can see here when I ran this command
34:45 - that now I'm getting an error message
34:46 - and it's saying the updates were
34:47 - rejected because the remote uh contains
34:50 - work that you do not have locally this
34:52 - is usually caused by another repository
34:53 - pushing to the same ref you may want to
34:55 - First integrate the remote changes with
34:56 - the git pull before pushing again so I'm
35:00 - just going to clear here and what I can
35:01 - do is type git pull and this will be
35:04 - connected to that Branch when I type git
35:06 - pull it will automatically pull those
35:07 - changes and then what I'll need to do is
35:09 - fix the conflict because I have edited
35:11 - the same line so I'm just going to
35:13 - accept the current change here and then
35:15 - I would go get add Dot
35:17 - get commit hyphen M fix
35:23 - conflict okay and now I can go get push
35:26 - origin Tech with Tim Dash hatch dash one
35:30 - and now I'm able to push the changes
35:32 - because I have integrated them with the
35:35 - remote Repository
35:38 - foreign
35:41 - so continuing here I'm now going to show
35:44 - you how you can use the cherry pick
35:46 - command and how you can reset your git
35:48 - branches and state now these are more
35:51 - advanced commands you want to actually
35:52 - know what you're doing when you're using
35:54 - them uh they're not overly complicated
35:55 - but they can mess things up quite badly
35:57 - if you don't know what you're doing so
35:58 - just kind of be careful with these
35:59 - commands if you are using them in your
36:01 - own GitHub repository anyways First
36:04 - Command I want to show you is the cherry
36:05 - pick command which is extremely useful
36:07 - when you have a few commands where just
36:09 - one commit that you want to apply onto a
36:11 - different branch
36:12 - so let's say I'm doing a ton of work on
36:14 - a feature Branch all of a sudden I come
36:16 - up with a pretty critical bug fix and I
36:18 - fix that in one commit now my feature
36:21 - isn't finished but my feature Branch
36:22 - contains the bug fix so rather than me
36:26 - trying to finish the feature bench
36:27 - really quickly or trying to kind of uh
36:29 - submit a half finished feature what I
36:32 - would do instead is I would simply
36:33 - cherry pick this commit off onto a new
36:35 - branch and then I would push that new
36:37 - Branch to GitHub and merge that with my
36:40 - main branch so that I got the bug fix in
36:42 - immediately but I could still continue
36:44 - to work on my feature Branch without
36:46 - pushing that kind of prematurely so this
36:49 - just allows you to take any work you do
36:50 - in a commit and apply it anywhere else
36:52 - use it however you see fit but it's a
36:54 - useful command so I want to show you how
36:55 - it works now when I uh kind of
36:57 - frequently use this command is when I
36:59 - accidentally make a commit on the wrong
37:01 - branch and then I want to move it to
37:03 - another one so let's say that I create
37:05 - this new feature Branch okay
37:07 - and I'm going to do all kinds of work on
37:09 - this feature Branch blah blah but in the
37:11 - meantime I check out the main branch and
37:13 - I pull it just to make sure I'm up to
37:14 - date okay great I'm up to date next day
37:16 - comes along all of a sudden I come to my
37:18 - git repository and I'm like all right
37:19 - I'm gonna start doing my work and I
37:21 - forget that I'm on this main branch
37:25 - so I do my work I add my critical file
37:27 - here and I add my commit so I go get dot
37:30 - get commit hyphen m
37:32 - add python file and all of a sudden I
37:35 - see Main and I go oh no I've made a
37:37 - mistake what do I do now well not to
37:40 - worry we can use the cherry pick command
37:42 - so first of all I don't want this on the
37:44 - main branch so I want to get rid of it
37:45 - from the main branch but I want the work
37:47 - still and I need to move that to another
37:48 - Branch so I'm going to type git log and
37:51 - I'm going to look at the commit hash so
37:54 - this is the hash of the commit that I
37:55 - just made there might be multiple
37:57 - commits by the way that you want to move
37:58 - over in that case you're just going to
38:00 - repeat this process but I grabbed the
38:02 - hash of the commit that I want to move
38:03 - so I'm going to copy that I'm going to
38:05 - quit here
38:07 - I'm going to check out the branch I want
38:08 - to move it to so git checkout in this
38:10 - case feature and then I'm going to type
38:12 - get Cherry Peck
38:15 - I'm going to paste the hash
38:16 - I'm going to cherry pick this commit
38:18 - over to this new bridge so easy as that
38:21 - I've now moved this commit over and if I
38:23 - go back to main now
38:26 - okay you see that I still have the code
38:28 - here so I haven't removed it from Main
38:30 - but I took the commit and I applied it
38:32 - onto the feature branch so now kind of
38:34 - step one of my problem is done I've
38:36 - saved this code and moved it over to a
38:38 - new Branch where it's supposed to be but
38:39 - now I need to get rid of it from this
38:41 - main branch so there's a few ways that I
38:43 - can get rid of it first of all I can
38:45 - just revert back by one commit
38:48 - second of all I can actually reset to
38:52 - the state of my remote repository so I'm
38:55 - going to show you a few different ways
38:56 - to do it the first one I'm going to show
38:57 - you is what I will typically use because
38:59 - I always want my main branch to be up to
39:02 - date with the remote repository main
39:05 - branch so if that's the case if that's
39:06 - all you care about you just want to be
39:07 - completely up to date you don't have any
39:09 - work on the main branch that you care
39:11 - about losing then what you're going to
39:12 - do is type this get reset hyphen hyphen
39:15 - hard this is a dangerous command I'm
39:17 - going to explain this but be careful
39:18 - when you use this and then origin slash
39:21 - make now what this means is I'm going to
39:24 - reset my current Branch to essentially
39:26 - just match origin main now what this
39:29 - dash dash hard means is that I'm going
39:31 - to reset the working tree as well as the
39:33 - get index that essentially means that
39:36 - any files that I've worked on but I
39:37 - haven't committed yet those are going to
39:40 - be deleted so if I've added them into
39:42 - the staging area like they're currently
39:44 - being tracked by git they're going to
39:45 - get deleted now I can kind of prove that
39:47 - to you if I create file
39:49 - txd or text.txt okay I go here and I
39:54 - just add it alright so I've added it to
39:56 - the staging area but I haven't deleted
39:58 - it now if I run git reset dash dash hard
40:00 - origin main you're going to see that
40:02 - that file gets deleted so that's what
40:04 - happens when you do hard all right now
40:07 - if you do soft which is the next one so
40:09 - let me show you this if I create a new
40:10 - file text Dot txt the same thing is
40:14 - going to happen but it's going to keep
40:15 - any that are in the staging area so if I
40:17 - go here and I add this into Stage
40:19 - changes now if I go get reset dash dash
40:22 - soft
40:24 - then what it's going to do is it's going
40:25 - to keep this text file it's not going to
40:27 - delete it because I did a soft reset
40:29 - which means yes the entire like git
40:31 - history this Branch got reseted uh I'll
40:33 - grab reset it sorry got reset but I keep
40:36 - any files that were in my staging area
40:38 - there's a few other options you can use
40:40 - here when it comes to resetting
40:41 - typically I just use hard and that will
40:43 - essentially do a clean kind of reset for
40:45 - you get rid of any changes and just make
40:47 - sure that your branch is up to date with
40:49 - the remote repository again a slightly
40:51 - dangerous command but something that I
40:53 - would keep in mind
40:56 - [Music]
40:59 - so with that said I'm going to start
41:00 - wrapping up this video as a reminder on
41:03 - May 9th I'm teaming up with Microsoft to
41:05 - host a 45 minute long webinar as a part
41:08 - of the developer digital Meetup tour
41:10 - this webinar will go much more in depth
41:12 - on git and GitHub talk about best
41:14 - practices Advanced developer workflows
41:16 - and also discuss vs code GitHub actions
41:19 - and many more topics if you want to
41:21 - register for that you can go to AKA dot
41:23 - Ms slash Tech with Tim and if you are
41:26 - watching this video after May 9th you
41:27 - can still click that link from the
41:29 - description to access the recording with
41:31 - that said I hope you enjoyed the video
41:33 - and I look forward to seeing you in
41:34 - another one
41:38 - foreign
41:42 - [Music]

Cleaned transcript:

foreign I'll be sharing with you intermediate git and GitHub features and demonstrating how to use this software in a professional environment specifically I'll be discussing the proper way to create a pull request and contribute to a repository how to fix conflicts the difference between a rebase and a merge how to pull and modify existing branches cherry picking different commits and then how to reset history and commit and more advanced git and GitHub features that are not typically shown now this video is designed for people that have some familiarity with Git but if you're a beginner or just need a refresher then feel free to check out the video that I'm going to put on the screen which will give you the fundamentals you need to then go through this video lastly I'm happy to mention that this video is sponsored by Microsoft who helped me develop this video and on May 9th we'll be hosting a 45 minute long webinar as a part of the developer digital Meetup tour this webinar will go much more in depth on this topic and teach you about Advanced developer workflows while also including a live q a session at the end to register for the webinar go to AKA dot Ms slash Tech with Tim or click the link in the description with that said let's dive into the video alright so let's go ahead and get started so in front of me I have a sample GitHub repository and what I'm going to do in this section of the video is demonstrate to you how to correctly create a pull request and contribute to a repository now this is going to be more applicable if you're working in a team environment with multiple developers or for a company if you're just working on your own kind of solo git repository or GitHub repository this isn't going to be super applicable and you don't need to follow these steps but whenever you're working with more than one developer you're going to want to do what I'm outlining here just to keep everything clean and kind of best practice so first thing to understand here when we're looking at this repository if I can open it back up is that we have a branch called main or in some instances it's going to be called Master now you can see this is the default Branch now your main branch in most instances is going to be the branch that you want to have clean reviewed and finalized functioning code on what that means is that you don't want to be directly contributing work that's not finished to the main or Master Branch you want to be doing essentially all of your Dev work on in a kind of additional Branch so a feature branch and then once you've finished a completed feature or bug fix or whatever it may be then you're going to merge that onto the main or Master Branch so in most repositories your main or Master branch is going to be locked which means unless you're a I guess you would call this an admin of the repository you're not able to actually directly contribute to this Branch instead what you need to do is work on an additional branch that is forked off of the main or Master branch and then merge it onto the master bedroom our main branch once it's been reviewed and your code is completed tested and functioning so just keep that in mind your main branch you want to always be kind of production ready to some extent and always fully functioning so that additional people can always revert back to the main branch and know this is kind of the current uh version of the repository the current uptodate State whereas all these other branches are Works in progress that are eventually going to be contributed onto the main or Master Branch alright so with all that said let's actually get into an example of making a contribution then to this repository keeping in mind that we want to do our work on an additional branch and that eventually merge it into this main branch okay so I've opened this repository here in Visual Studio code and I want to start creating a feature I want to start adding some code now obviously I'll just do something simple for this video but what is the process to do this well the first thing I always do is I check what branch I'm currently on by typing git branch in this case I'm on the main branch that's what I want to be on and what what I like to do before I start working or creating a new Branch or feature is I like to make sure that my local repository is up to date with the remote repository this is just going to save me a ton of headaches in the future so what I do is I type A git pull when I do that that's going to pull all of the changes from the remote repository to my local repository and keep my local version of the main or massive Branch up to date so what I'm trying to do locally is always keep this main branch up to date with the remote repository you know every day I like to make a poll something along those lines so that whenever I decide to Fork off of Main I'm not forking too far kind of in the past and I have a very uptodate version of the code base there's different ways to do this but this is what I'd like to do now you may have to actually fully type out git pull origin and then whatever the branch name is in this case it's going to be main it's going to do the same thing here in my case the get pull command is just automatically set up to pull from this main branch when I'm on that Branch okay so now I'm fully up to date with the remote Repository uh and what I'm going to do is create a new Branch so I'm going to type git checkout hyphen B standing for a new branch and I'm going to give this a name now when you name a branch it's typically a good idea to give it some kind of unique prefix that is specific to you so you don't accidentally name Branch the same thing that someone else has named that's eventually going to push it to the repository so what I'll do typically is something like get checkout hyphen B and then Tim and in this case I'll say feature now obviously whatever the feature name is like if this was a leaderboard or a scoring system or whatever I would name it that in this case we'll just do something generic which is feature now again the reason I use Tim is because if someone else is working on a branch called feature we could have kind of conflicts and be pushing to the same remote repository branch which could kind of cause some headaches so it's a good idea just to prefix your branches with your name or some unique ID that no one else is going to be using alright so I'm on my new branch and now that I'm on my new Branch I can go crazy I can create my new features so let's say my new feature is just a text file okay so we'll just say feature Dot txt and I'll say this is a great feature okay perfect I'm going to save that now obviously we can go through our standard gate commands we can also just use the interface here in vs code and I can add these changes to the staging area so git add dot then I can make my commit I'm going to do the commit message using hyphen M and I want to name this something meaningful it's going to be easy to review later on so I would say added a feature dot txt file and actually it's standard practice to write this in present tense not in past tense now it doesn't really matter I don't see many people actually follow this practice but you are supposed to write this in present tense uh not past tense so add a feature.txt file as if you're doing it kind of right now okay so I've done that I've now created my commit and now I'm at the point where I actually want to push this to GitHub I want to get my code reviewed and then I want to contribute this to the main branch so other developers can start using this so if I want to do this now what I need to do is I need to push this Branch so I'm going to type git push Tim Dash feature when I do that sorry I need to First specify the location I'm going to push to so get push origin Tim feature because origin is the remote repository I want to go to so we're going to push to this remote repository and now you can see it's created a new branch on the remote repository called Tim feature so by me simply doing this push because I had access rights to this GitHub repository I've now created this new branch and if I click on this button and I view all branches you can see that there's a Tim feature Branch right here and I have the option to manually click create new pull request I can also view this Branch by clicking on it and then view that this new file is here I also have the ability to just press this button which is automatically being generated by GitHub although sometimes it doesn't actually give that to you based on kind of when you contribute if you change something all kinds of reasons why you may not see this button so I wanted to show you manually you can go here and then click that okay so I'm going to go compare and pull request now we get to the pull request kind of template page now typically when you get to this page there's going to be some kind of template that you'll need to fill out depending on the organization that you're working for and it may tell you to upload some photos or to tick some boxes or to describe the feature whatever you got the idea you want to give a descriptive pull request name and the point is that through this pull request you may actually go back um kind of in the future and say okay what did I change here what were the changes and you just want to have a decent name so it's easy to find what this pull request is so in my case we've done a very simple thing which is just add a file that's about as much subscription as I need to add than if I wanted to I could add additional comments again in this case I don't need to do that but it is good practice to add as much detail as you possibly can so I'm going to click on create pull request and now what I've done is I've created my pull request now this pull request will typically need to be approved depending on the settings of the GitHub repository before it's able to be emerged into the main branch so in my case I can just directly merge it in here because I'm an admin of the GitHub repository however if someone who was not was working on this repository then someone like myself would have to review their pull request and then approve it before they'd be able to actually merge it in so if I go here to reviewers if there was other people on this repository I'd be able to select them and say request review so that's typically what you're going to do and then you're gonna have to wait for them to come here and review the pull request now in my case I can show you an example of doing that because you may also do that for other people's pull requests so here it says review changes I can obviously go and look through all the changes and tick the files that I've seen and if you had more files and directories it would show you that setup on the left hand side anyways it's quite simple here so I'll click on review changes maybe I leave a comment here and I ask them why they did something a certain way I also can select a line here click on this plus button and then directly add a comment on this line so I can add a single comment right here and now if you go to the conversation tab you'll see that there's a comment kind of discussing a specific line and then you could reply to that comment and kind of keep all your conversation on one pull request so that you have history of it and you can look at it later you can also resolve the conversation which means you've kind of fixed whatever they commented on now you'll see when I go here that it's tell telling me that I can't approve or request changes because I'm the author again that kind of makes sense but what I would do if this was someone else's pull request I would review it I would leave some comments and then I would approve it and then they would be able to merge so I just want you to understand that this is the process right you create this pull request and now I can merge this pull request into the repository I'm going to delete this branch which is typically good practice you want to keep your branches clean that you're not using I'm going to go back to code and now notice that I've created a merge commit here that has merged all of this content into the main branch so now I have my one branch I have feature.txt on here and everything is up to date and we can go and look at the three commits we have our initial commit this and then we have the merge commit which is actually merging all of my code from my Branch into this main repository okay we're almost done here now we go back here okay we're working on some other feature or maybe it's the next day we want to do some new code so now what I want to do is I want to get check out the main branch remember you always want to keep your main branch your local copy of the main branch up to date with the remote repository so I'm going to go to my main branch and then I'm going to type git pull and I'm going to pull down the remote changes now even though I've already made these changes locally I've only made them on my other Branch so on my Tim feature Branch not on the main branch so I go to main I pull that gives me the changes from the remote repository including that merge commit and now I can create new branches and work off this main branch to avoid any conflicts now you'll see that if I go get checkout so let's go here get check out Tim Dash feature and I try to push this up so get push origin and then Tim feature like this it's gonna create this new Branch okay so it creates a new Branch now I'm gonna go back to the GitHub repository and we are going to go here we're gonna go to Tim feature and it says this one commit behind main now the reason it's saying it's one commit behind main even though it has the same content is because the main branch has a merge uh merge commit sorry that merge these two things in whereas my current local copy doesn't have that merge commit so I don't want to keep working on this Branch because I could potentially be getting conflicts instead what I want to be doing is creating a new branch and then working off that hopefully that makes a little bit of sense of what I'm describing here I'm just going to go back to the main branch though so get checkout Main okay and now I would create a new Branch so git checkout hyphen B and then Tim feature two and this is where I would do any additional changes this branch is up to date with the main branch meaning that whenever I make a push I'm not going to have any conflicts at least I shouldn't have any conflicts based on how we're doing this right now and it should just be kind of smooth sailing to add new code to the code base alright so continuing here the next thing I'm going to go through is resolving conflicts and I'm going to kind of explain to you why a conflict occurs because this is a point where people get very frustrated and oftentimes kind of don't know how to deal with this in some kind of production environment or you know kind of workplace team environment so what I'm going to do here is essentially create a conflict now before I do that I'm just going to look at the current status of my repository so it says I'm on Tim feature two so what I'm going to do is check out the main branch again I'm going to pull to update everything's up to date okay and now I'm going to delete these two branches that I don't need just so that I don't get confused and accidentally use them throughout this section so I'm going to type git Branch hyphen capital D and then I'm going to go Tim feature that's going to delete that branch and I'll do the same thing with Tim feature two alright so now let's create a conflict so let's clear let's go get check out hyphen B Tim Dash and we'll just go C1 for conflict one and all I'm gonna do here is go to this file and I'm just going to delete this line okay so I've deleted that line here now I'm gonna go get add dot git commit hyphen m delete line in and then feature dot txt okay and then I'm going to push this up to GitHub now you'll see in a second kind of how I create the conflict for now though all I'm doing is just making a change the repository which is not going to cause a conflict okay so I've gone here uh and you can see then now I have Tim C1 and I can create a pull request so I'm going to do that create pull requests and I'm going to create that now for now I'll just leave this on the repository and we can merge it in later all right now what I'm going to do is go get checkout and then main now notice here that we still have the text inside of the file okay so now I'm going to create a new Branch now imagine that I was doing this as a different user so you know Tim me just created a branch that I uploaded for a pull request that Branch deleted a line now imagine some other developer is checking out a branch from their local main copy they don't have that deleted line because that was worked on on a separate branch and now what they're going to do is maybe modify this liner they're going to modify this file in some way this is kind of how a conflict will occur so I go get check out hyphen B I'm going to go Tim C2 for conflict two okay and here all I'm going to do is say this is a great feature Tim is the best uh just two true statements on one line okay so now that I've done this I'm going to do the same thing I'm going to push this up for a pull request I'm gonna go get push origin and then Tim C2 so essentially what I've done here is I've created two separate branches each branch has made a change on the same file and in this case on the same line so what that means is that there's conflicting changes on both of these branches so I'm going to go back here to pull requests let's go to code let's go to our branches Tim C2 and let's create a pull request uh okay for some reason uh apologies for the cut here I realized I forgot to make my commit so I'm gonna go get add dot get commit hyphen m I'm just gonna go with a simple one like make changes and now I'm gonna push this again back up to the repository so that now I will see it here okay so Sim Tim C2 has changes so let's go here and make changes Okay so we've created two pull requests and you'll notice that on both of these pull requests right now everything's completely fine I can merge them in because all I've done is made a change to one of the lines in this case I've deleted the line okay and then on my other pull request here I have simply added to the line so what I'm going to do is just pick any of the pull requests it doesn't matter which one I pick here and I'm going to make a change okay so I'm going to confirm this uh now this is the file that is adding to the line okay so let's confirm this merge all right and check that okay now this is in I'm going to delete this branch and what you're going to see is when I go back here now all of a sudden it's going to show me that I have a conflict now the reason it's telling me I have a conflict is that the change that I've made here is trying to change the same line that was just changed in the previous pull request but on a different version of the file now I know this seems kind of strange but essentially both of these branches were kind of merged or sorry forked off of the main branch at the same time so two minutes ago I created these two new branches they both modified the same version of a file and now I've checked it's called checking in but I've merged one of these file changes into the main repository but this Branch was making a change to a previous version of that file so it was making a change to a version different than what is now inside side of the repository hopefully that makes a little bit of sense but the actual definition here of one emerge conflict occurs is when people make different changes to the same line or the same file or when one person edits a file and another person deletes the same file so that's exactly what's happening here we're editing the same line in the same file and git doesn't know what version of the file to take so we have to resolve these conflicts now we can do this in Visual Studio code or we can do this here on GitHub alright so now that I'm inside of this file I'll quickly explain what this syntax means so in between these two symbols here where it says Main and it shows all of the equal signs this is what's currently on the GitHub repository okay this is what's currently here and then this um kind of weird because I've deleted a line but this is what's on this Branch so essentially what it needs me to do here is delete all of these symbols that have been added in now I can put anything I want in this file but it needs these symbols to be removed before it's going to tell me that I've marked or before it's going to allow me sorry to mark this file as resolved so that's one way you can do this directly from the editor on GitHub or you can do this from vs code so I'll show you from vs code as well if I go back to visual studio code here now what I can do is I can try to update my C2 Branch with the main branch so the way I'll typically do this is I'll go get checkout main I'll pull main which is going to give me the fixes so or the updates now it's going to modify this file and now I'm going to go get chick checkout and then in this case it's C1 and now what I'll do is I will merge the main branch with this branch and when I do that you're going to see that I get a merge conflict Happening Here locally I can then fix that and then repush to GitHub and then everything will be okay so what I'm going to do is go get and then this is going to be merge and I'm going to merge main now I could merge origin slash main or I can just merge mate now if I do main that's my local copy which in this case is fine because I know that's up to date with my origin or my remote repository alternatively if I knew it wasn't up to date then I would just do origin slash main in this case they're both going to give me the same result origin slash main by the way of course is the remote repository and then the version of the main branch on there okay so I'm going to hit enter here and notice it says automatic merge failed fix the conflicts and then commit the result now here we get some better kind of choices so we can accept the current change or the incoming change or both changes or alternatively we can just manually update this file now for clarity here the incoming change is what's coming from the remote repository or from the other branch and then the current change is what you currently have on your current Branch so what I can do is accept the current change if I actually want to delete this line then I'm going to save and then what I need to do is I need to commit the results so I'm going to fix the conflicts and commit the result my file is already added into the staging area so just type git commit hyphen M and I say fix dot txt file conflicts okay this is kind of my merge commit now I'm gonna do that uh and sorry actually I forgot I have to add this to the staging area I thought it was already there and then I commit okay so now that I've made my commit here what I can do is repush this so I'm going to type get push origin Tim C1 and now that I repush this to the remote repository with the conflicts fixed so we're gonna go here all right uh I should be able to just merge this directly in and you'll notice that now I have two commits so I deleted the line and then I have what's referred to as a merge commit which is what I made to merge the changes from the main branch onto my feature Branch so now when I merge my feature Branch back onto the main branch the history is correct and everything is up to date I know this can be a little bit confusing but what I just did to fix the conflict was I essentially merge my Branch with the main branch so that I integrated all of the changes from the main branch onto mine I then from that point forward created the change I wanted to put on the main branch which is what we've done by deleting the line and now I am able to merge this pull request in okay I again I apologize this stuff is not simple hence why this video is intermediate kind of GitHub topics but that is how you go about fixing a merge conflict now obviously the conflicts you can you get can be much nastier than what I just showed you here uh there is some more advanced tools that you can use to fix these however typically what you want to do to avoid getting too many conflicts is always be branching off of a clean version of the main repository if you're doing that or sorry off the main branch if you're doing that you're going to limit the amount of conflicts that you have and you know once in a while yes you will get them but what you need to do then is merge with the main branch and then you'll have to manually go through and fix all of those conflicts once you fix them then you can repush and then you'll be able to merge back into the Repository all right so I've just moved to the drawing tablet here because I'm going to quickly explain to you the difference between a merge and a rebase which are two popular commands to integrate changes from different branches that many developers don't actually understand so it's helpful to view these visually they're actually not overly complicated but you just want to understand kind of the core difference between what emerge is doing uh compared to a rebase so let's just draw a simple example here of a git history so all of these circles are going to be commits and this white Branch here is going to be our main or our Master Branch now let's say at some point in time we decided we're going to start creating a feature and maybe we did that here okay so at this point we decided to Fork off and we created a new branch in this Branch maybe we called something like C1 now obviously that's a horrible name but we decided to call it C1 there we go we have our C1 feature wrench now let's say that we are here and we decided this point in time okay you know we finished our feature now we want to actually kind of combine this or merge this into the code base there's a few different ways to go about doing this we also may just want to update our current Branch to integrate all of the changes from Main so let's put put it in that scenario we want to update our current Branch with all the changes from Main so that way when we continue working we have an uptodate code base everything's kind of you know updated nice and clean and ideally we're gonna kind of remove the riskiness or remove sorry the likelihood of having a conflict okay so we want to take changes from here that have happened since we've been working on this branch and integrate them here obviously what's happened is since we've branched off new code has been added to the main branch we want that code now in this Branch how do we get that well the First Command we can run is our merge now when we decide to run a merge what's going to happen is a new commit is going to be created this is called our merge commit and I'm going to put an asterisks here which means it's new now what this merge commit is going to do is it is going to essentially combine all of the changes since we branched off with the changes from this Branch so it's a brand new commit and it just combines well all of these different changes now a conflict could occur here if that's a case we need to fix that and then the kind of conflict fix will be involved in this merge commit alright so we create this merge commit it essentially combines everything together and now say I'm on my Branch C1 if I were to continue to work I would kind of add off of this merge commit and there we go now I have all the changes from my main branch and I'm continuing to work now the advantage here of creating this merge commit is that I keep the entire history of my git repo what I mean by that is I know still all of these different commits I know when I originally branched off and I know at what point in time I decided to do this merch now the disadvantage is that this merge commit is very messy oftentimes it kind of messes up the history you can see here now we have a nonlinear history because we have different branches kind of being integrated together and it can make the history of the GitHub repository well just very messy right it's difficult for me if I'm reviewing this later on to understand if I should be looking down here if I should be looking up here if I'm looking after the merge commit it just kind of complicates things a little bit when you're going back and review it okay so that's a disadvantage but again the advantage is you're retaining all of this history and you know everything that's occurred you're not losing any information you've just added this additional merge commit which can make things a little bit messy now one thing to note here is that since I've integrated main with my C1 branch that doesn't mean that on my main branch I now have my C1 one changes only if I've actually made a pull request and kind of merged this into the main branch am I going to have that if I were to locally check out the main branch now as I continue to work I'm going to continue to Branch off of my main branch and then later maybe I integrate the changes of C1 but what I've done is I've taken the changes from Main and put those on my C1 Branch not the other way around it's not going to happen on both branches it just happens on the branch you're currently on when you run the git rebase commit okay now let's talk about merge so I think actually will be easier if I just delete all of this so let's erase all the ink okay so now what happens when we do a rebase well what a rebase is doing is taking essentially this entire Branch here so all of the code that we've done and it's just moving it to be at the tip of our main branch so let's say I'm on to C1 right I want to integrate my main changes then all I do is I rebase it and when I rebase it it moves my brand inch over here now obviously it's a little bit more complicated than that but that's essentially what's happening rather than creating a new commit here which is a merge of these two branches together I am simply taking all of this code or all of these commits sorry from this branch and I'm moving them so that now they're going to be attached at the head of my main branch or whatever Branch I am merging or sorry rebasing with my what do you call it feature Branch now what actually happens here is this right so this new branch is going to contain entirely new commits all the asterisks are just new commits what happens is my original branch which I can kind of do like this so my original commits are going to be copied and added to the head so I'm not taking the same commit I'm actually kind of copying them and turning them into a brand new commit and then attaching them to the head of whatever Branch I'm rebasing with now the reason why this is nice is that we no longer have a merge commit and our history is fully linear so now it's very easy for me if I'm reviewing this later on to understand that okay I just go from here here down to here I don't have this kind of fork in the road where I have this merge commit that's combining the two different branches I have a full linear history the disadvantage of doing this is that I lost all of the history that I previously had when I decided to Branch off so again we originally had branched here and if we had done a merge we would have known that we branched here we would have known all the commits that were on this Branch versus here now when I do the rebase it becomes unclear I lose that history and instead I kind of trade that for this straight linear history so you might be asking yourself now okay I understand you know rebase is essentially attaching to the head and what actually occurs here is we apply every single one of the commits that are on our Branch to this Branch right so we're really just tacking them on that's all that's happening and these become new commits but you might be asking yourself well when do I use which right when do I use rebase first when do I use merch well the Golden Rule here is that you never want to use a rebase on a public Branch now what I mean by a public branch is a branch that someone else could potentially be working on the reason you don't want to do that is because if someone else has a copy of the branch that looks like this and then you rebase and you push that Branch when they pull this they're going to get all kinds of conflicts and they're going to have a completely different version of the branch locally than what you've pushed so you've now moved every single one of your commits over to the head of the main branch where theirs are still forked off and have not been rebased and when they decide to do a pull uh there's just kind of you know like a mini disaster that's going to occur so essentially it's referred to as the golden rule of rebase is you never use this on a public branch which is a branch that anyone else could be um kind of using now this is a little confusing because if I have a local branch it's fine for me if I'm working on kind of a local feature Branch to rebase that Branch against my main Bridge it's fine for me to put my C1 Branch like it is right now because I'm the only one working on this C1 Branch I can fix all of the conflicts and then I'm going to push that up to get I'm going to have my nice clean history I can then merge that in to my main branch and then anyone else can simply pull the main branch which will have its nice clean linear history and then allow uh allow them sorry to just continue working so the simple summary here on when to use rebase is when you're working on a private Branch so that means pretty much only you are working on the branch and you're trying to update essentially the state of your branch to match the state of a remote Branch or some other Branch you can use rebase however if you're working on any kind of public Branch then instead you're going to want to use merge that you don't lose any history and you're not going to mess anyone else up that is using that same Branch so just remember those two rules if it is a public Branch then you use merge if it is your own private Branch then you are fine to use the rebase command foreign switched back to the computer and for this next section in the video what I'm going to show you is how to check out and modify an existing Branch from GitHub that is not the main branch so you can see here that I've created a new branch called Tech with Tim patch one I've made a pull request using this branch and let's say that now I'm a new developer I'm looking at this code and I want to modify this Branch so maybe I want to push directly to this pull request or I just want to get access to the branch whatever I want it from this remote repository how do I get this well let's go to my local GitHub repo here and first I'm going to type git Branch notice I don't have this Branch even if I type git pull and this will actually give me all of the branches by the way from the remote repository if I didn't already have them even when I type this and I type git Branch again it's not going to show me this Branch now there is a way to view these kind of remote branches however if you know the name of the branch and you just want to it's directly go to the state of that Branch then what you can do is to follow it you can type git checkout and then you can just put the name of the branch in this case it's going to be Tech with Tim patch one now notice that I haven't put hyphen B I didn't put origin I didn't put anything special I'm not creating a new Branch I'm checking out a branch that exists on the remote repository so since I know the name I'm just going to put it here and when I hit enter it's going to say switch to a new Branch so it automatically creates one for me and this branch is tracking the remote repo now what that means is that I'm gonna have the same state as the remote repository Branch at the time that I ran this code and now any changes that I make are happening locally and I can and then push them to the remote repository so let's say I go here and create a new file okay new file.txt a new text all right perfect I can now type git add Dot get command hyphen m create file and then I can push this now to the remote repository so I'm going to type git push origin Tech with Tim Dash patch dash one okay I do that I'm now able to push my code I go here and refresh and notice that I've added this new commit to this Branch okay so that's something you can do fully valid I just want to show you that's how you do it you check out the branch name it's then going to essentially track that Branch from the remote repository if the branch exists on the remote repository and then you have that state and then you can do whatever you want now similarly someone else may change something on this Branch right so you go to Tech with Tim patch one maybe they go to feature uh go here and they edit this and they say another line okay so let's do this commit changes I'm just going to commit uh directly commit that to the branch okay now I'm here and you'll see that I don't have these changes so if I want to get those changes then I can type get pull now what might happen is I could maybe potentially have a conflict here right so like I edit this line and then I type get add dot get commit hyphen M okay I don't know fix whatever I'm just doing random commit messages and then I try to push this again get push origin I should already have this command okay so you can see here when I ran this command that now I'm getting an error message and it's saying the updates were rejected because the remote uh contains work that you do not have locally this is usually caused by another repository pushing to the same ref you may want to First integrate the remote changes with the git pull before pushing again so I'm just going to clear here and what I can do is type git pull and this will be connected to that Branch when I type git pull it will automatically pull those changes and then what I'll need to do is fix the conflict because I have edited the same line so I'm just going to accept the current change here and then I would go get add Dot get commit hyphen M fix conflict okay and now I can go get push origin Tech with Tim Dash hatch dash one and now I'm able to push the changes because I have integrated them with the remote Repository foreign so continuing here I'm now going to show you how you can use the cherry pick command and how you can reset your git branches and state now these are more advanced commands you want to actually know what you're doing when you're using them uh they're not overly complicated but they can mess things up quite badly if you don't know what you're doing so just kind of be careful with these commands if you are using them in your own GitHub repository anyways First Command I want to show you is the cherry pick command which is extremely useful when you have a few commands where just one commit that you want to apply onto a different branch so let's say I'm doing a ton of work on a feature Branch all of a sudden I come up with a pretty critical bug fix and I fix that in one commit now my feature isn't finished but my feature Branch contains the bug fix so rather than me trying to finish the feature bench really quickly or trying to kind of uh submit a half finished feature what I would do instead is I would simply cherry pick this commit off onto a new branch and then I would push that new Branch to GitHub and merge that with my main branch so that I got the bug fix in immediately but I could still continue to work on my feature Branch without pushing that kind of prematurely so this just allows you to take any work you do in a commit and apply it anywhere else use it however you see fit but it's a useful command so I want to show you how it works now when I uh kind of frequently use this command is when I accidentally make a commit on the wrong branch and then I want to move it to another one so let's say that I create this new feature Branch okay and I'm going to do all kinds of work on this feature Branch blah blah but in the meantime I check out the main branch and I pull it just to make sure I'm up to date okay great I'm up to date next day comes along all of a sudden I come to my git repository and I'm like all right I'm gonna start doing my work and I forget that I'm on this main branch so I do my work I add my critical file here and I add my commit so I go get dot get commit hyphen m add python file and all of a sudden I see Main and I go oh no I've made a mistake what do I do now well not to worry we can use the cherry pick command so first of all I don't want this on the main branch so I want to get rid of it from the main branch but I want the work still and I need to move that to another Branch so I'm going to type git log and I'm going to look at the commit hash so this is the hash of the commit that I just made there might be multiple commits by the way that you want to move over in that case you're just going to repeat this process but I grabbed the hash of the commit that I want to move so I'm going to copy that I'm going to quit here I'm going to check out the branch I want to move it to so git checkout in this case feature and then I'm going to type get Cherry Peck I'm going to paste the hash I'm going to cherry pick this commit over to this new bridge so easy as that I've now moved this commit over and if I go back to main now okay you see that I still have the code here so I haven't removed it from Main but I took the commit and I applied it onto the feature branch so now kind of step one of my problem is done I've saved this code and moved it over to a new Branch where it's supposed to be but now I need to get rid of it from this main branch so there's a few ways that I can get rid of it first of all I can just revert back by one commit second of all I can actually reset to the state of my remote repository so I'm going to show you a few different ways to do it the first one I'm going to show you is what I will typically use because I always want my main branch to be up to date with the remote repository main branch so if that's the case if that's all you care about you just want to be completely up to date you don't have any work on the main branch that you care about losing then what you're going to do is type this get reset hyphen hyphen hard this is a dangerous command I'm going to explain this but be careful when you use this and then origin slash make now what this means is I'm going to reset my current Branch to essentially just match origin main now what this dash dash hard means is that I'm going to reset the working tree as well as the get index that essentially means that any files that I've worked on but I haven't committed yet those are going to be deleted so if I've added them into the staging area like they're currently being tracked by git they're going to get deleted now I can kind of prove that to you if I create file txd or text.txt okay I go here and I just add it alright so I've added it to the staging area but I haven't deleted it now if I run git reset dash dash hard origin main you're going to see that that file gets deleted so that's what happens when you do hard all right now if you do soft which is the next one so let me show you this if I create a new file text Dot txt the same thing is going to happen but it's going to keep any that are in the staging area so if I go here and I add this into Stage changes now if I go get reset dash dash soft then what it's going to do is it's going to keep this text file it's not going to delete it because I did a soft reset which means yes the entire like git history this Branch got reseted uh I'll grab reset it sorry got reset but I keep any files that were in my staging area there's a few other options you can use here when it comes to resetting typically I just use hard and that will essentially do a clean kind of reset for you get rid of any changes and just make sure that your branch is up to date with the remote repository again a slightly dangerous command but something that I would keep in mind so with that said I'm going to start wrapping up this video as a reminder on May 9th I'm teaming up with Microsoft to host a 45 minute long webinar as a part of the developer digital Meetup tour this webinar will go much more in depth on git and GitHub talk about best practices Advanced developer workflows and also discuss vs code GitHub actions and many more topics if you want to register for that you can go to AKA dot Ms slash Tech with Tim and if you are watching this video after May 9th you can still click that link from the description to access the recording with that said I hope you enjoyed the video and I look forward to seeing you in another one foreign
