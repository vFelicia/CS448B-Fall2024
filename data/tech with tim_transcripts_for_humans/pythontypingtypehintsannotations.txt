With timestamps:

00:02 - [Music]
00:08 - hello everybody and welcome to another
00:10 - youtube video in today's video i'll be
00:13 - covering type hints and annotations in
00:15 - python along with a bunch of content
00:17 - from the typing module now what this
00:20 - will allow you to do is add types to
00:22 - your parameters to your variables to
00:24 - your return values from functions such
00:26 - that you can actually have better
00:27 - documentation of your python code your
00:30 - autocomplete works better and any other
00:32 - people that are reading your code can
00:34 - very easily see what types are expected
00:37 - of certain parameters method calls
00:40 - whatever it may be regardless you will
00:42 - see all of that as we get into the video
00:44 - after a quick word from our sponsor
00:46 - before we dive in i need to thank ltm
00:48 - designer for sponsoring this video
00:51 - ltm designer is the world's most trusted
00:53 - pcb design system that enables engineers
00:55 - to effortlessly connect with every facet
00:58 - of the electronics design process ltm
01:00 - designer has used 35 years of innovation
01:03 - and development to create a truly
01:04 - unifying design environment that makes
01:06 - it the most used pcb design solution on
01:09 - the market ltm designer provides an
01:11 - intuitive and powerful interface that
01:13 - lets you design pcbs rapidly while
01:16 - interacting and collaborating with your
01:17 - mechanical designers the interface
01:19 - provides a photo realistic 3d
01:21 - environment collaboration and
01:23 - synchronization with tools including
01:25 - solidworks ptc creo and autodesk
01:28 - inventor realistic rigid flex designs
01:31 - multi-board assembly and much more ltm
01:34 - designer is the most popular ecad tool
01:36 - and electronics design software and you
01:38 - can get started with it today for free
01:40 - by pressing the link in the description
01:42 - and registering for a free trial thanks
01:45 - again to ltm designer for sponsoring
01:47 - this video and now let's dive in alright
01:49 - so let's go ahead and get started in
01:52 - front of me i have the official
01:53 - documentation for the typing module in
01:55 - python this is a built-in module you
01:57 - don't need to install it and as it says
01:59 - here this is new in python version 3.5
02:02 - so you do have to use 3.5 or above for
02:04 - this to work for you now i'm going to be
02:07 - using python version 3.8 in this
02:09 - tutorial in python 3 9 which is the
02:11 - newest release of python they do have
02:14 - some very small differences and kind of
02:16 - additions to this module i'm not going
02:18 - to cover them because they're pretty
02:19 - insignificant but i just want to mention
02:21 - that in case any of you were wondering
02:23 - now what i've done for this video i've
02:25 - read through this documentation i've
02:26 - kind of picked out the most important
02:28 - and most common things that you would
02:29 - use and i'm just going to cover them
02:31 - here so if you want the full list of
02:33 - everything you can do which is very
02:35 - complicated in advance then you can feel
02:36 - free to read this i will link it in the
02:38 - description anyways with that said let
02:40 - me just quickly talk about why you would
02:42 - want to do some of the things that i'm
02:44 - going to show you so really all this is
02:46 - is documenting your code we're going to
02:48 - be adding types to our parameters adding
02:50 - types to our return values but this
02:52 - doesn't actually change the
02:54 - functionality of your python code it
02:56 - won't make it so that if i don't pass a
02:58 - string here the program crashes that's
03:00 - not going to happen all of this is just
03:02 - documentation you can kind of treat it
03:04 - as comments and the point of that is
03:06 - just to better document your python code
03:08 - make it easier for other developers to
03:10 - understand what to pass to your function
03:12 - or methods and to make it easier for
03:14 - your autocomplete or linter to do its
03:16 - job so if you do this you add types to
03:18 - all of the python code that you write
03:20 - your autocomplete will be way way better
03:23 - and lastly i'm going to show you
03:25 - actually pretty soon here how you can
03:27 - use what's known as a static code
03:29 - analysis tool
03:30 - with these types to tell you if you have
03:32 - type mismatching so this is a way that
03:34 - you can kind of catch errors before
03:36 - running your code it will tell you hey
03:38 - you passed a list of strings when it was
03:40 - expecting a list of floats anyways just
03:43 - wanted to mention all the stuff we're
03:45 - doing doesn't enforce that these are the
03:47 - types these values need to be it is
03:49 - simply for documentation purposes
03:51 - anyways let's get into it here and i
03:53 - will show you the first example of type
03:55 - annotations alright so what i'm going to
03:57 - do here is make a variable i'm going to
03:59 - call this x and i'm going to store a 1
04:01 - inside of here now in python this is
04:03 - obviously completely valid code we don't
04:05 - need to define the types of our
04:07 - variables of our parameters our
04:08 - functions whatever we can just write it
04:10 - like this x can store one and later on
04:13 - in my program x can store something like
04:15 - tim that's completely fine however in a
04:17 - lot of other programming languages that
04:19 - are statically and strongly typed you
04:21 - need to actually declare the type of a
04:22 - variable before you can assign a value
04:25 - to it and then that variable can only
04:27 - hold that type throughout the entire
04:29 - program execution so what you would have
04:31 - to do is maybe something like this and x
04:33 - equals one and this means x is storing
04:35 - an integer it can only ever store an
04:37 - integer and if i tried to store a string
04:40 - here then my program would actually
04:41 - crash or not even compile but in python
04:44 - since it's dynamically typed we can just
04:45 - do x equals one and then later on we can
04:47 - say x equals tim and this is fine
04:50 - however if we want to add a type
04:52 - annotation or a type hint to this we can
04:54 - do the following we can add a colon then
04:56 - we can add what type should be stored in
04:58 - this variable so i'm going to say x and
05:00 - then string now yes i know the correct
05:02 - type would be in but i'm just showing
05:04 - you that we can do this now watch when i
05:06 - run the code i don't get an error the
05:08 - reason i don't get an error is because
05:11 - this is not enforcing that x is going to
05:13 - store a string it's just saying hey x
05:15 - should store a string so that's what i
05:17 - meant with this is simply documentation
05:20 - this doesn't change any of your python
05:21 - code's behavior it just adds an
05:24 - annotation that's what it's called a
05:25 - type hint to this variable saying hey it
05:28 - should store a string
05:30 - great so now what i'm going to show you
05:31 - how to do is use a static code analysis
05:34 - tool to actually look at your python
05:36 - code examine the type annotations and
05:38 - see if you have mismatches with your
05:40 - types so the way you do this is you need
05:42 - to install the type annotation sorry you
05:45 - need to install the static code analysis
05:46 - tool so you have to go pip
05:48 - install and then my pi like this now you
05:50 - do this in terminal or in command prompt
05:53 - depending on your operating system
05:55 - and if pip doesn't work for you you can
05:57 - try pip three if that doesn't work for
05:59 - you i'll put two videos on the screen
06:01 - that hopefully should fix this command
06:02 - for you anyways i'm gonna do pip install
06:04 - my pi
06:05 - we can see i already have it installed
06:07 - and so all is good now if i want to use
06:11 - my pi to run a static code analysis
06:13 - check on this python file what i do is i
06:16 - type my pi and then i need to put the
06:18 - path to my file so mine's on my desktop
06:20 - and then slash and then this is going to
06:22 - be let's just type it out
06:24 - python underscore and then
06:27 - typing
06:28 - dot pi like that now when i run this
06:31 - give it a second here notice it shows me
06:33 - it found one error in one file it says
06:36 - incompatible types in assignment
06:38 - expression has int variable has type
06:41 - string so this is telling me hey on line
06:43 - one here we found a mismatch in types so
06:46 - you should go fix them so that's what
06:47 - the static code analysis tool is again
06:50 - another reason why you would actually
06:51 - add the types because you can use a tool
06:53 - like this there's a bunch of other ones
06:54 - as well i'm just showing you one example
06:56 - of them to tell you if you have any
06:58 - mismatches
06:59 - great so now that we've seen that that
07:00 - is the variable annotation i'm going to
07:02 - show you how we do this with functions
07:04 - which is much more useful so i'm going
07:05 - to say define a function let's just say
07:08 - add numbers like this and maybe we want
07:10 - to take a b and c and then we want to
07:13 - return the sum of a b and c so let's do
07:15 - a plus b
07:17 - plus c like this well now i want to add
07:19 - my types to this so just like i added
07:21 - the type for my variable for each of my
07:24 - parameters i will say that these should
07:25 - be an int so i'll go int
07:28 - and like that okay then i want to add
07:30 - the return type of my function so to do
07:33 - that i actually just do an arrow so this
07:34 - is going to be a hyphen and then i guess
07:37 - the greater than sign and then what i
07:39 - will do here is put int like that now
07:42 - this is saying this function is going to
07:43 - return an integer and there you go i
07:45 - have just added types to my add numbers
07:48 - function
07:49 - now let's do this
07:51 - add numbers one two three we can store
07:54 - this in x and print it out and i'll just
07:57 - prove to you that everything is working
07:59 - completely fine there you go that's
08:01 - really the basics on adding your
08:03 - annotations to functions and adding
08:06 - their return type now i will note if
08:08 - your function is not returning anything
08:09 - so maybe instead we're just printing
08:12 - a plus b plus c in that case we don't
08:14 - need to print x anymore then what we do
08:16 - for the return type is we just put none
08:19 - so all python functions by default
08:21 - return none if you don't return anything
08:23 - so you just put none here and then this
08:25 - is all good it continues to work all
08:27 - right so now that we've looked at the
08:29 - basics of function annotations i want to
08:31 - show you some more advanced types that
08:32 - we can use so a lot of times you have
08:35 - some well more advanced or more
08:37 - complicated types that you want to pass
08:39 - as an argument to a function for example
08:42 - maybe we want to have a list that has a
08:44 - bunch of lists in it or maybe it only
08:46 - has three lists in it exactly and these
08:48 - lists all have integers inside of them
08:50 - well what is the type for that well the
08:52 - type for that is actually list
08:55 - list and then inside of list you would
08:58 - put it that's what the type would be but
09:00 - i'm going to show you that this actually
09:02 - doesn't work the way it is right now so
09:04 - if i try to make this the type let's
09:05 - just go x colon equals that and let's
09:09 - just make this equal to a list
09:11 - and i run the code you're going to see
09:12 - we get type object is not subscriptable
09:15 - that pretty much means this here which
09:16 - is a type object i can't subscript it so
09:19 - what i need to instead is import the
09:21 - list object or the list type from the
09:23 - typing module so i'm going to say from
09:26 - typing
09:27 - import like this and then list with a
09:30 - capital l so now that i've done this i'm
09:32 - going to change this to be a capital l
09:34 - on my list and notice that this is now
09:36 - completely fine so if you want to use
09:38 - list as a type and you're using python
09:40 - version 3.8 or below then you need to
09:43 - have list with a capital l importing
09:46 - from typing now i'm saying again this is
09:48 - list list int which means we would have
09:50 - something like this one two
09:53 - three four and that is a valid type and
09:56 - in fact if we want to check that let's
09:57 - just say my pie and then this is going
09:59 - to be desktop like that slash and then
10:02 - python underscore
10:04 - typing dot pi uh let's see what we get
10:07 - no issues found in one source file great
10:10 - so now that we've looked at that let's
10:11 - look at a few other types with some
10:12 - different built-in python data types so
10:14 - we just covered list but let's change
10:16 - this now to use a dictionary so if i'm
10:18 - going to use a dictionary i need to
10:20 - specify the key and the value type so
10:22 - i'm going to say string and string like
10:24 - that and i'm going to make this equal to
10:26 - and let's just go with a
10:28 - colon
10:29 - and then b like so all right let's see
10:31 - if this is going to work actually if i
10:33 - run my code and notice we get the same
10:34 - error type object is not subscriptable i
10:37 - can't just do this so again what do i
10:39 - need to do
10:40 - i need to import dict like this from
10:42 - typing so now if i do this with a
10:44 - capital and i run the code all is good
10:47 - and if we run our my pi command let's
10:49 - see no issues found in one source file
10:51 - so that's how you would do it for dict
10:53 - now if you want to do it for set the
10:54 - same thing is going to happen so you
10:55 - need to import set like that now we
10:57 - would go with set and then we would just
10:59 - specify what type is in the set in this
11:01 - case it's just going to be strings so
11:03 - now we have a set and all is good
11:06 - perfect so that is set that is sticked
11:07 - we could also cover bool if you want to
11:09 - do bool then while you just write bool
11:11 - like that pretty straightforward and
11:13 - then string obviously we saw as that and
11:15 - we know is that and float we know is
11:17 - that great all right so now that we've
11:19 - looked at those let's look at an example
11:21 - of creating our own types so a lot of
11:24 - times what you want to do is have a very
11:26 - complicated kind of type like this and
11:29 - you want to simplify it by just giving
11:31 - it a name so a good example of this is
11:33 - something like a vector okay so what i
11:35 - can do is the following i can say vector
11:37 - it doesn't matter if i have a capital or
11:39 - not but this is kind of
11:40 - convention sorry is equal to and then
11:42 - this is going to be a list
11:44 - and this list is going to contain floats
11:47 - okay so i'm just going to say this is my
11:49 - vector type so now that i've done this i
11:51 - can use vector and wherever i use vector
11:54 - list float will kind of be replaced
11:56 - there right or we'll be substitute in
11:57 - for vector so if i go define let's just
12:00 - make our function foo let's say v colon
12:02 - vector this is completely fine and then
12:05 - this could return a vector like that
12:07 - let's just print out v okay now watch if
12:10 - i start typing foo notice it's giving me
12:12 - the type completion here right saying v
12:14 - list float gives me list float so i have
12:17 - vector here but it's replacing it with
12:19 - list flow so hopefully that kind of
12:21 - makes sense but you can do this right
12:22 - you can just store a type inside of a
12:24 - variable and then use that variable as
12:26 - that type this is very nice when you
12:28 - have super complicated types
12:30 - let's make another one
12:32 - let's say vectors maybe vectors is equal
12:34 - to a list of
12:36 - vector objects again this is now
12:39 - completely valid our vectors type is
12:41 - just a list that contains a bunch of
12:42 - vectors
12:43 - which is the type that we defined up
12:45 - here so we can use our own types in
12:47 - these now let's just do another example
12:49 - i probably should just left what we have
12:51 - before let's go v
12:52 - and then vectors like that and then
12:55 - we'll return a single vector
12:58 - and let's just go pass and let's call
13:00 - the function and notice it tells me list
13:02 - list float and then list float so there
13:05 - you go that is how you make your own
13:07 - custom types they can store whatever you
13:09 - want in fact you could even do something
13:10 - as simple as like vector equals float i
13:13 - don't know why you do that but you could
13:14 - do that all right so moving on from this
13:16 - i want to show you a few more types that
13:18 - we can use now these are kind of more
13:20 - special types or edge case types but you
13:22 - definitely do need to know them all
13:24 - right so let's make a function
13:25 - let's call this foo and let's have this
13:27 - function taken an optional keyword
13:29 - argument something like i don't know
13:31 - let's go with output is equal to false
13:34 - okay
13:35 - so if i was going to add the type for
13:36 - this then what i would do is the
13:37 - following i would just say output and
13:39 - then i would go with bool like that is
13:41 - equal to false if i run this everything
13:43 - is totally valid no errors at all that's
13:45 - fine now when i call this foo function i
13:47 - can call it with or without output the
13:49 - thing is this is optional and right now
13:51 - this type does not specify that this
13:53 - parameter is optional now if i do run my
13:55 - static code analysis tool you will see
13:57 - that it's not going to give me an error
13:59 - here if i were to try to call the foo
14:01 - function without this parameter without
14:04 - output this would be fine i wouldn't get
14:06 - an error but to make this the most
14:08 - correct type that it can be you need to
14:10 - specify that it's optional so the way
14:11 - you do that is you import optional from
14:14 - your typing module and then you specify
14:17 - optional and then the type this should
14:18 - be so optional and then bool this just
14:20 - says okay this is now an optional
14:22 - parameter you don't have to pass it when
14:23 - you call the function anyways that's the
14:25 - type i want to show you optional pretty
14:28 - straightforward now other than optional
14:30 - we have another type
14:31 - this is the any type now the any type is
14:34 - very straightforward but if you are
14:35 - willing to accept anything then you just
14:37 - use the any type so let's say output
14:39 - could be equal to anything let's now
14:41 - make it mandatory then i would just put
14:43 - any like this and now anything is
14:45 - accepted inside of there now writing
14:47 - this is the exact same thing as just
14:48 - doing this because if you don't give it
14:50 - a type it's assumed it could be anything
14:52 - but this is just being more explicit
14:54 - you're saying yes this is intended to
14:56 - actually accept anything i didn't just
14:58 - forget to add the type that's kind of
15:00 - why you would put it here
15:02 - great so now that we've looked at
15:03 - optional in any i want to talk to you
15:04 - about sequence so a lot of times when
15:06 - you're writing a function in python you
15:08 - want one of the parameters to be
15:10 - anything that's a sequence you don't
15:12 - care what type of sequence it is it
15:14 - could be a list it could be a tuple it
15:15 - could be a different type of sequence
15:17 - you don't care you just want it to be a
15:19 - sequence so if that's the case you can
15:21 - use this special type
15:22 - known as sequence now the reason you
15:24 - need this is because there's no way to
15:26 - specify oh this should be a list or this
15:28 - should be a tuple but if you use
15:31 - sequence you're saying okay both the
15:32 - tuple and the list count as a sequence
15:34 - and so i'll accept any sequence and i'll
15:36 - show you that with sequence you can also
15:38 - specify what type the sequence should be
15:40 - stored so let's go here and let's say
15:43 - maybe we have a let's just call it seq
15:45 - like that standing for sequence if i
15:47 - wanted to give this the correct type i
15:48 - would say sequence and then whatever is
15:50 - going to be in the sequence so like
15:52 - string okay then what would be valid to
15:54 - pass this would be something like a
15:56 - tuple so i could pass a tuple full of
15:57 - strings let's go a b
15:59 - c like that and then let's just do this
16:02 - exact same thing but let's change this
16:04 - to a list and then we'll run our static
16:06 - code analysis tool and we'll see if this
16:08 - is causing any problems so let's save
16:10 - that
16:11 - let's run my pi notice we are all good
16:13 - however watch what happens if i go and
16:16 - now i try to pass uh let's just pass a
16:19 - int pass foo with one actually i don't
16:22 - want to run the code i want to run the
16:23 - static code analysis notice we get this
16:25 - error it says foo has incompatible type
16:27 - int expected sequence string now let's
16:30 - actually just see what happens if we
16:31 - pass a string because a string might be
16:32 - considered a sequence i'm actually not
16:34 - sure about this one okay so a string
16:36 - actually is a sequence as well i believe
16:38 - this is anything that can be indexed
16:40 - that would count as a sequence to do one
16:42 - more test here let's try a set so one
16:45 - two three
16:46 - i'm not sure if this one will be a
16:47 - sequence or not yes okay so it's not a
16:49 - sequence the reason it wouldn't be a
16:51 - sequence is because we can't index this
16:53 - set and it is not ordered hopefully that
16:55 - kind of makes sense but that is the
16:56 - sequence type again you use that when
16:58 - you want to accept anything that can be
17:00 - indexed so you're looking for a string
17:02 - you're looking for a tuple you are
17:03 - looking for a list all right so now i
17:05 - just want to move on and quickly talk
17:06 - about the tuple type which is something
17:08 - we haven't covered and works a little
17:10 - bit different than list so if i want to
17:12 - give the correct typing for a tuple what
17:14 - i need to do is actually specify what is
17:16 - going to be stored at every single
17:18 - position in the tuple just watch if i
17:20 - say x colon tuple like this what i can
17:23 - do is say okay this is a general tuple
17:25 - object so in this case i can put
17:26 - anything inside of here and it's fine so
17:28 - if i go with like hello and then let's
17:30 - run our my pi here notice this is
17:32 - completely fine however if i do want to
17:34 - specify what's inside of the tuple then
17:37 - what i would need to do is import tuple
17:39 - like this and then go with tuple
17:42 - now usually if we just had ins inside of
17:45 - our tuple we might imagine we could do
17:46 - tuple ins like this and this would be
17:48 - fine however if i save this and run my
17:51 - pie notice we get an error it says that
17:53 - the expression has type tuple int int
17:55 - and it found tuple int so what that
17:58 - means is we actually need to specify
18:00 - what every single element in the tuple
18:02 - is so int like that and now if we run my
18:05 - pi that should be good all right just
18:07 - want to quickly cover tuples because
18:08 - they're a little bit different than
18:10 - lists and i showed those previously all
18:11 - right so now that i've covered the tuple
18:13 - type what i want to cover is callable
18:15 - now callable is what you use when you
18:17 - want to accept a function as a parameter
18:20 - this is actually very common especially
18:21 - if you're doing some more advanced like
18:23 - not beginner programming you want to
18:24 - accept functions as a parameter anyways
18:27 - the way you do that is using callable so
18:29 - we need to import callable like that
18:32 - from typing and let's say that we want
18:34 - this foo function to accept a function
18:37 - and it's just going to call this
18:38 - function with let's say values 1 2. well
18:41 - the proper type for this function would
18:43 - be callable
18:45 - and then what i would need to do here is
18:46 - to find another set of square brackets
18:49 - and define the parameters that the
18:51 - callable function is going to have as
18:53 - well as the return type so i would say
18:55 - int and then int like this
18:58 - now what this says is okay this callable
19:00 - function that you pass to me has to have
19:02 - two int parameters and has to have an
19:05 - int return type now let's say it had an
19:08 - optional in parameter then you would go
19:10 - optional
19:11 - ins like that right you would add that
19:13 - as the third value here inside of call
19:16 - so hopefully that kind of makes sense
19:17 - but let's look at an example so let me
19:19 - define some function let's just call
19:21 - this add
19:22 - let's take x y x is going to be an int
19:25 - y is going to be an int and then what is
19:27 - this function going to return well this
19:28 - is going to return an int like that and
19:30 - then what i would do here is oops that's
19:33 - not what i meant to do i would just
19:34 - return x plus y
19:37 - now i forgot i do need to specify the
19:39 - return type for this function as well so
19:41 - i will make that none and now if i call
19:43 - foo i can directly pass the add function
19:46 - and if i run my pi we shouldn't see any
19:49 - errors we are all good however let's see
19:51 - what happens if i remove one of these
19:52 - parameters so if i remove the y
19:54 - parameter and now i run my static code
19:56 - analysis notice we get an error because
19:58 - this function does not have the correct
20:00 - parameters inside of it great now in the
20:03 - same way that we can do this for a
20:04 - parameter we can do this for a return
20:06 - value so maybe what i do instead is
20:08 - actually this let's copy this let's
20:10 - define this function inside of here
20:13 - and then now we want to actually return
20:16 - a callable so i'm just going to copy
20:17 - this here and make this the return type
20:20 - so let's do this
20:22 - let's just make this empty and then
20:25 - return add like that
20:27 - so i'm sure this is a little bit complex
20:30 - but what i'm doing is adding a nested
20:31 - function inside of this function and now
20:34 - i'm saying okay i'm going to return a
20:36 - new function this function well it's
20:38 - callable it's going to have two
20:39 - parameters and its return type is going
20:41 - to be int and if i run
20:44 - my pi here notice we are all good great
20:47 - so now that we've looked at that i will
20:48 - quickly mention that this also works
20:50 - with the lambdas as well now you can't
20:52 - actually add type hints for lambdas at
20:53 - least not very easily but if you want to
20:55 - return a lambda function then you could
20:57 - just do this lambda x y and then let's
21:00 - just return x plus y now since i didn't
21:02 - specify the types and again it's very
21:04 - difficult to specify the types for the
21:05 - lambda uh what you could do is this i'll
21:08 - run my pi and notice all is good now if
21:10 - i wanted to specify the types of the
21:11 - lambda i'll actually just show you how
21:12 - you would do this you would make a
21:14 - variable so let's go with funk colon
21:16 - then you would specify its type as
21:18 - callable int int ins in this situation
21:22 - make it equal to the lambda and now you
21:24 - could just return function like that and
21:27 - this would be fine now you specify the
21:28 - types for your lambda function if this
21:30 - looks super complicated to you don't
21:32 - worry about it too much just for anyone
21:33 - wondering this is what you would do if
21:34 - you're going to return a lambda all
21:36 - right so now we are almost done the last
21:38 - thing i'm going to cover is generics now
21:40 - this gets a lot more advanced than what
21:42 - i'm about to show you here but i'm just
21:44 - going to give you a general introduction
21:45 - so let me import something called type
21:47 - var here now i'm just going to go
21:49 - through an example then i'll explain
21:50 - what has happened i'm going to say t is
21:53 - equal to and this is going to be type
21:55 - var with t now this is the actual name
21:58 - of the type so usually you just match it
22:00 - with the variable name but you could
22:01 - make this something different if you
22:02 - wanted to anyways what i'm saying is
22:04 - that this is going to be a generic type
22:06 - now a generic type is something that's
22:08 - kind of a placeholder i'm saying okay i
22:10 - don't know what this type is actually
22:11 - going to be but i'm going to call it t
22:13 - so that i can consistently reference it
22:15 - throughout a function or class or
22:18 - whatever it may be again i'm sure this
22:20 - makes no sense right now but let's just
22:21 - do an example i'm going to say define
22:23 - and let's say get underscore item okay
22:25 - now what this is going to take in is a
22:27 - list so i'll say lst is colon and then
22:29 - this is going to be list at and then t
22:32 - okay so a little bit weird but list add
22:34 - t
22:34 - and then we will take an index this will
22:37 - be an int and we will return t
22:41 - okay now let's just return
22:43 - lst at
22:45 - index all right so this is a good
22:46 - example of generics the way this works
22:48 - is t is a placeholder variable i'm
22:51 - saying i'm going to accept a list this
22:53 - list can have any element inside of it
22:56 - so it could be an int it could be a
22:57 - float could be a string and any number
22:59 - of ins float strings whatever but they
23:00 - have to be the same type that's the
23:03 - point of this t is i'm saying okay i
23:05 - don't know what type is going to be
23:06 - inside of the list but i'm going to
23:07 - represent it by t and i'm going to
23:09 - assume that everything inside of the
23:11 - list is the same type t
23:13 - then i'm going to return t so whatever
23:15 - was inside of the list wherever that
23:17 - type is that's the type that i'm going
23:19 - to return so that's the point of doing
23:20 - this is you're saying all right i want
23:22 - this to be a flexible function that
23:24 - works for any type so anything inside of
23:26 - a list but to properly do my typings
23:28 - here i need what's known as a generic
23:30 - again they go into much more depth than
23:32 - this in the documentation but i wanted
23:34 - to introduce this to you because for
23:36 - most of you this is probably all you
23:37 - need but you can actually create a
23:39 - generic class you can create all kinds
23:41 - of very complicated generic types and
23:44 - with that said i think that wraps up
23:46 - pretty much everything i need to cover
23:47 - in this video i apologize if this was
23:49 - kind of all over the place i'm
23:51 - definitely no master at this typing
23:53 - system but i wanted to give you guys an
23:54 - introduction and i feel like what i
23:56 - covered here is probably about you know
23:57 - 95 of the average use case of most
24:00 - people again the real advantage of doing
24:03 - this is that you have documentation for
24:05 - your code your autocomplete and your
24:07 - linters are going to be better and if
24:09 - you're working in a large code base it's
24:10 - going to be way easier for other people
24:12 - to determine what is accepted in your
24:15 - function and if that was intended or not
24:17 - right just like we had this any type
24:20 - we're specifying explicitly what we are
24:22 - accepting just so people know hey this
24:24 - was not a mistake i do actually want to
24:26 - accept say any value inside of here
24:28 - hopefully you're getting the point
24:30 - regardless with that said i am going to
24:31 - end the video here i hope you enjoyed if
24:34 - you did make sure to leave a like
24:35 - subscribe to the channel and i will see
24:36 - you in another one
24:39 - [Music]

Cleaned transcript:

hello everybody and welcome to another youtube video in today's video i'll be covering type hints and annotations in python along with a bunch of content from the typing module now what this will allow you to do is add types to your parameters to your variables to your return values from functions such that you can actually have better documentation of your python code your autocomplete works better and any other people that are reading your code can very easily see what types are expected of certain parameters method calls whatever it may be regardless you will see all of that as we get into the video after a quick word from our sponsor before we dive in i need to thank ltm designer for sponsoring this video ltm designer is the world's most trusted pcb design system that enables engineers to effortlessly connect with every facet of the electronics design process ltm designer has used 35 years of innovation and development to create a truly unifying design environment that makes it the most used pcb design solution on the market ltm designer provides an intuitive and powerful interface that lets you design pcbs rapidly while interacting and collaborating with your mechanical designers the interface provides a photo realistic 3d environment collaboration and synchronization with tools including solidworks ptc creo and autodesk inventor realistic rigid flex designs multiboard assembly and much more ltm designer is the most popular ecad tool and electronics design software and you can get started with it today for free by pressing the link in the description and registering for a free trial thanks again to ltm designer for sponsoring this video and now let's dive in alright so let's go ahead and get started in front of me i have the official documentation for the typing module in python this is a builtin module you don't need to install it and as it says here this is new in python version 3.5 so you do have to use 3.5 or above for this to work for you now i'm going to be using python version 3.8 in this tutorial in python 3 9 which is the newest release of python they do have some very small differences and kind of additions to this module i'm not going to cover them because they're pretty insignificant but i just want to mention that in case any of you were wondering now what i've done for this video i've read through this documentation i've kind of picked out the most important and most common things that you would use and i'm just going to cover them here so if you want the full list of everything you can do which is very complicated in advance then you can feel free to read this i will link it in the description anyways with that said let me just quickly talk about why you would want to do some of the things that i'm going to show you so really all this is is documenting your code we're going to be adding types to our parameters adding types to our return values but this doesn't actually change the functionality of your python code it won't make it so that if i don't pass a string here the program crashes that's not going to happen all of this is just documentation you can kind of treat it as comments and the point of that is just to better document your python code make it easier for other developers to understand what to pass to your function or methods and to make it easier for your autocomplete or linter to do its job so if you do this you add types to all of the python code that you write your autocomplete will be way way better and lastly i'm going to show you actually pretty soon here how you can use what's known as a static code analysis tool with these types to tell you if you have type mismatching so this is a way that you can kind of catch errors before running your code it will tell you hey you passed a list of strings when it was expecting a list of floats anyways just wanted to mention all the stuff we're doing doesn't enforce that these are the types these values need to be it is simply for documentation purposes anyways let's get into it here and i will show you the first example of type annotations alright so what i'm going to do here is make a variable i'm going to call this x and i'm going to store a 1 inside of here now in python this is obviously completely valid code we don't need to define the types of our variables of our parameters our functions whatever we can just write it like this x can store one and later on in my program x can store something like tim that's completely fine however in a lot of other programming languages that are statically and strongly typed you need to actually declare the type of a variable before you can assign a value to it and then that variable can only hold that type throughout the entire program execution so what you would have to do is maybe something like this and x equals one and this means x is storing an integer it can only ever store an integer and if i tried to store a string here then my program would actually crash or not even compile but in python since it's dynamically typed we can just do x equals one and then later on we can say x equals tim and this is fine however if we want to add a type annotation or a type hint to this we can do the following we can add a colon then we can add what type should be stored in this variable so i'm going to say x and then string now yes i know the correct type would be in but i'm just showing you that we can do this now watch when i run the code i don't get an error the reason i don't get an error is because this is not enforcing that x is going to store a string it's just saying hey x should store a string so that's what i meant with this is simply documentation this doesn't change any of your python code's behavior it just adds an annotation that's what it's called a type hint to this variable saying hey it should store a string great so now what i'm going to show you how to do is use a static code analysis tool to actually look at your python code examine the type annotations and see if you have mismatches with your types so the way you do this is you need to install the type annotation sorry you need to install the static code analysis tool so you have to go pip install and then my pi like this now you do this in terminal or in command prompt depending on your operating system and if pip doesn't work for you you can try pip three if that doesn't work for you i'll put two videos on the screen that hopefully should fix this command for you anyways i'm gonna do pip install my pi we can see i already have it installed and so all is good now if i want to use my pi to run a static code analysis check on this python file what i do is i type my pi and then i need to put the path to my file so mine's on my desktop and then slash and then this is going to be let's just type it out python underscore and then typing dot pi like that now when i run this give it a second here notice it shows me it found one error in one file it says incompatible types in assignment expression has int variable has type string so this is telling me hey on line one here we found a mismatch in types so you should go fix them so that's what the static code analysis tool is again another reason why you would actually add the types because you can use a tool like this there's a bunch of other ones as well i'm just showing you one example of them to tell you if you have any mismatches great so now that we've seen that that is the variable annotation i'm going to show you how we do this with functions which is much more useful so i'm going to say define a function let's just say add numbers like this and maybe we want to take a b and c and then we want to return the sum of a b and c so let's do a plus b plus c like this well now i want to add my types to this so just like i added the type for my variable for each of my parameters i will say that these should be an int so i'll go int and like that okay then i want to add the return type of my function so to do that i actually just do an arrow so this is going to be a hyphen and then i guess the greater than sign and then what i will do here is put int like that now this is saying this function is going to return an integer and there you go i have just added types to my add numbers function now let's do this add numbers one two three we can store this in x and print it out and i'll just prove to you that everything is working completely fine there you go that's really the basics on adding your annotations to functions and adding their return type now i will note if your function is not returning anything so maybe instead we're just printing a plus b plus c in that case we don't need to print x anymore then what we do for the return type is we just put none so all python functions by default return none if you don't return anything so you just put none here and then this is all good it continues to work all right so now that we've looked at the basics of function annotations i want to show you some more advanced types that we can use so a lot of times you have some well more advanced or more complicated types that you want to pass as an argument to a function for example maybe we want to have a list that has a bunch of lists in it or maybe it only has three lists in it exactly and these lists all have integers inside of them well what is the type for that well the type for that is actually list list and then inside of list you would put it that's what the type would be but i'm going to show you that this actually doesn't work the way it is right now so if i try to make this the type let's just go x colon equals that and let's just make this equal to a list and i run the code you're going to see we get type object is not subscriptable that pretty much means this here which is a type object i can't subscript it so what i need to instead is import the list object or the list type from the typing module so i'm going to say from typing import like this and then list with a capital l so now that i've done this i'm going to change this to be a capital l on my list and notice that this is now completely fine so if you want to use list as a type and you're using python version 3.8 or below then you need to have list with a capital l importing from typing now i'm saying again this is list list int which means we would have something like this one two three four and that is a valid type and in fact if we want to check that let's just say my pie and then this is going to be desktop like that slash and then python underscore typing dot pi uh let's see what we get no issues found in one source file great so now that we've looked at that let's look at a few other types with some different builtin python data types so we just covered list but let's change this now to use a dictionary so if i'm going to use a dictionary i need to specify the key and the value type so i'm going to say string and string like that and i'm going to make this equal to and let's just go with a colon and then b like so all right let's see if this is going to work actually if i run my code and notice we get the same error type object is not subscriptable i can't just do this so again what do i need to do i need to import dict like this from typing so now if i do this with a capital and i run the code all is good and if we run our my pi command let's see no issues found in one source file so that's how you would do it for dict now if you want to do it for set the same thing is going to happen so you need to import set like that now we would go with set and then we would just specify what type is in the set in this case it's just going to be strings so now we have a set and all is good perfect so that is set that is sticked we could also cover bool if you want to do bool then while you just write bool like that pretty straightforward and then string obviously we saw as that and we know is that and float we know is that great all right so now that we've looked at those let's look at an example of creating our own types so a lot of times what you want to do is have a very complicated kind of type like this and you want to simplify it by just giving it a name so a good example of this is something like a vector okay so what i can do is the following i can say vector it doesn't matter if i have a capital or not but this is kind of convention sorry is equal to and then this is going to be a list and this list is going to contain floats okay so i'm just going to say this is my vector type so now that i've done this i can use vector and wherever i use vector list float will kind of be replaced there right or we'll be substitute in for vector so if i go define let's just make our function foo let's say v colon vector this is completely fine and then this could return a vector like that let's just print out v okay now watch if i start typing foo notice it's giving me the type completion here right saying v list float gives me list float so i have vector here but it's replacing it with list flow so hopefully that kind of makes sense but you can do this right you can just store a type inside of a variable and then use that variable as that type this is very nice when you have super complicated types let's make another one let's say vectors maybe vectors is equal to a list of vector objects again this is now completely valid our vectors type is just a list that contains a bunch of vectors which is the type that we defined up here so we can use our own types in these now let's just do another example i probably should just left what we have before let's go v and then vectors like that and then we'll return a single vector and let's just go pass and let's call the function and notice it tells me list list float and then list float so there you go that is how you make your own custom types they can store whatever you want in fact you could even do something as simple as like vector equals float i don't know why you do that but you could do that all right so moving on from this i want to show you a few more types that we can use now these are kind of more special types or edge case types but you definitely do need to know them all right so let's make a function let's call this foo and let's have this function taken an optional keyword argument something like i don't know let's go with output is equal to false okay so if i was going to add the type for this then what i would do is the following i would just say output and then i would go with bool like that is equal to false if i run this everything is totally valid no errors at all that's fine now when i call this foo function i can call it with or without output the thing is this is optional and right now this type does not specify that this parameter is optional now if i do run my static code analysis tool you will see that it's not going to give me an error here if i were to try to call the foo function without this parameter without output this would be fine i wouldn't get an error but to make this the most correct type that it can be you need to specify that it's optional so the way you do that is you import optional from your typing module and then you specify optional and then the type this should be so optional and then bool this just says okay this is now an optional parameter you don't have to pass it when you call the function anyways that's the type i want to show you optional pretty straightforward now other than optional we have another type this is the any type now the any type is very straightforward but if you are willing to accept anything then you just use the any type so let's say output could be equal to anything let's now make it mandatory then i would just put any like this and now anything is accepted inside of there now writing this is the exact same thing as just doing this because if you don't give it a type it's assumed it could be anything but this is just being more explicit you're saying yes this is intended to actually accept anything i didn't just forget to add the type that's kind of why you would put it here great so now that we've looked at optional in any i want to talk to you about sequence so a lot of times when you're writing a function in python you want one of the parameters to be anything that's a sequence you don't care what type of sequence it is it could be a list it could be a tuple it could be a different type of sequence you don't care you just want it to be a sequence so if that's the case you can use this special type known as sequence now the reason you need this is because there's no way to specify oh this should be a list or this should be a tuple but if you use sequence you're saying okay both the tuple and the list count as a sequence and so i'll accept any sequence and i'll show you that with sequence you can also specify what type the sequence should be stored so let's go here and let's say maybe we have a let's just call it seq like that standing for sequence if i wanted to give this the correct type i would say sequence and then whatever is going to be in the sequence so like string okay then what would be valid to pass this would be something like a tuple so i could pass a tuple full of strings let's go a b c like that and then let's just do this exact same thing but let's change this to a list and then we'll run our static code analysis tool and we'll see if this is causing any problems so let's save that let's run my pi notice we are all good however watch what happens if i go and now i try to pass uh let's just pass a int pass foo with one actually i don't want to run the code i want to run the static code analysis notice we get this error it says foo has incompatible type int expected sequence string now let's actually just see what happens if we pass a string because a string might be considered a sequence i'm actually not sure about this one okay so a string actually is a sequence as well i believe this is anything that can be indexed that would count as a sequence to do one more test here let's try a set so one two three i'm not sure if this one will be a sequence or not yes okay so it's not a sequence the reason it wouldn't be a sequence is because we can't index this set and it is not ordered hopefully that kind of makes sense but that is the sequence type again you use that when you want to accept anything that can be indexed so you're looking for a string you're looking for a tuple you are looking for a list all right so now i just want to move on and quickly talk about the tuple type which is something we haven't covered and works a little bit different than list so if i want to give the correct typing for a tuple what i need to do is actually specify what is going to be stored at every single position in the tuple just watch if i say x colon tuple like this what i can do is say okay this is a general tuple object so in this case i can put anything inside of here and it's fine so if i go with like hello and then let's run our my pi here notice this is completely fine however if i do want to specify what's inside of the tuple then what i would need to do is import tuple like this and then go with tuple now usually if we just had ins inside of our tuple we might imagine we could do tuple ins like this and this would be fine however if i save this and run my pie notice we get an error it says that the expression has type tuple int int and it found tuple int so what that means is we actually need to specify what every single element in the tuple is so int like that and now if we run my pi that should be good all right just want to quickly cover tuples because they're a little bit different than lists and i showed those previously all right so now that i've covered the tuple type what i want to cover is callable now callable is what you use when you want to accept a function as a parameter this is actually very common especially if you're doing some more advanced like not beginner programming you want to accept functions as a parameter anyways the way you do that is using callable so we need to import callable like that from typing and let's say that we want this foo function to accept a function and it's just going to call this function with let's say values 1 2. well the proper type for this function would be callable and then what i would need to do here is to find another set of square brackets and define the parameters that the callable function is going to have as well as the return type so i would say int and then int like this now what this says is okay this callable function that you pass to me has to have two int parameters and has to have an int return type now let's say it had an optional in parameter then you would go optional ins like that right you would add that as the third value here inside of call so hopefully that kind of makes sense but let's look at an example so let me define some function let's just call this add let's take x y x is going to be an int y is going to be an int and then what is this function going to return well this is going to return an int like that and then what i would do here is oops that's not what i meant to do i would just return x plus y now i forgot i do need to specify the return type for this function as well so i will make that none and now if i call foo i can directly pass the add function and if i run my pi we shouldn't see any errors we are all good however let's see what happens if i remove one of these parameters so if i remove the y parameter and now i run my static code analysis notice we get an error because this function does not have the correct parameters inside of it great now in the same way that we can do this for a parameter we can do this for a return value so maybe what i do instead is actually this let's copy this let's define this function inside of here and then now we want to actually return a callable so i'm just going to copy this here and make this the return type so let's do this let's just make this empty and then return add like that so i'm sure this is a little bit complex but what i'm doing is adding a nested function inside of this function and now i'm saying okay i'm going to return a new function this function well it's callable it's going to have two parameters and its return type is going to be int and if i run my pi here notice we are all good great so now that we've looked at that i will quickly mention that this also works with the lambdas as well now you can't actually add type hints for lambdas at least not very easily but if you want to return a lambda function then you could just do this lambda x y and then let's just return x plus y now since i didn't specify the types and again it's very difficult to specify the types for the lambda uh what you could do is this i'll run my pi and notice all is good now if i wanted to specify the types of the lambda i'll actually just show you how you would do this you would make a variable so let's go with funk colon then you would specify its type as callable int int ins in this situation make it equal to the lambda and now you could just return function like that and this would be fine now you specify the types for your lambda function if this looks super complicated to you don't worry about it too much just for anyone wondering this is what you would do if you're going to return a lambda all right so now we are almost done the last thing i'm going to cover is generics now this gets a lot more advanced than what i'm about to show you here but i'm just going to give you a general introduction so let me import something called type var here now i'm just going to go through an example then i'll explain what has happened i'm going to say t is equal to and this is going to be type var with t now this is the actual name of the type so usually you just match it with the variable name but you could make this something different if you wanted to anyways what i'm saying is that this is going to be a generic type now a generic type is something that's kind of a placeholder i'm saying okay i don't know what this type is actually going to be but i'm going to call it t so that i can consistently reference it throughout a function or class or whatever it may be again i'm sure this makes no sense right now but let's just do an example i'm going to say define and let's say get underscore item okay now what this is going to take in is a list so i'll say lst is colon and then this is going to be list at and then t okay so a little bit weird but list add t and then we will take an index this will be an int and we will return t okay now let's just return lst at index all right so this is a good example of generics the way this works is t is a placeholder variable i'm saying i'm going to accept a list this list can have any element inside of it so it could be an int it could be a float could be a string and any number of ins float strings whatever but they have to be the same type that's the point of this t is i'm saying okay i don't know what type is going to be inside of the list but i'm going to represent it by t and i'm going to assume that everything inside of the list is the same type t then i'm going to return t so whatever was inside of the list wherever that type is that's the type that i'm going to return so that's the point of doing this is you're saying all right i want this to be a flexible function that works for any type so anything inside of a list but to properly do my typings here i need what's known as a generic again they go into much more depth than this in the documentation but i wanted to introduce this to you because for most of you this is probably all you need but you can actually create a generic class you can create all kinds of very complicated generic types and with that said i think that wraps up pretty much everything i need to cover in this video i apologize if this was kind of all over the place i'm definitely no master at this typing system but i wanted to give you guys an introduction and i feel like what i covered here is probably about you know 95 of the average use case of most people again the real advantage of doing this is that you have documentation for your code your autocomplete and your linters are going to be better and if you're working in a large code base it's going to be way easier for other people to determine what is accepted in your function and if that was intended or not right just like we had this any type we're specifying explicitly what we are accepting just so people know hey this was not a mistake i do actually want to accept say any value inside of here hopefully you're getting the point regardless with that said i am going to end the video here i hope you enjoyed if you did make sure to leave a like subscribe to the channel and i will see you in another one
