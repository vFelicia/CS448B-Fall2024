With timestamps:

00:00 - hey guys and welcome back to another
00:01 - online game tutorial with Python now I
00:04 - apologize for not having posted this for
00:07 - the past three days I guess but I've
00:09 - actually just been working on the code
00:10 - for what we're about to create and I
00:12 - want to make sure that there wasn't a
00:13 - massive bugs or error so that I didn't
00:15 - slow us down when I was teaching you
00:16 - guys how to do this and walking you
00:18 - through the code so like I mentioned in
00:20 - the last video I'm pretty much gonna be
00:22 - gutting everything we already did we'll
00:24 - keep a little bit of it but we're just
00:26 - gonna really add to a bunch of that and
00:28 - just yeah we're gonna be gutting most of
00:30 - it and we're actually working to create
00:32 - online rock-paper-scissors now I know
00:35 - this sounds a kind of a lame game but
00:36 - let me show you because it's actually
00:38 - pretty complex and if you can understand
00:41 - how to make this game then you're gonna
00:42 - be able to understand how to make any
00:44 - other kind of online game because the
00:45 - principles are the same in terms of
00:47 - sending information waiting for players
00:49 - to go and there's a lot of different
00:51 - things and you might not think about
00:52 - that we actually have to do to code
00:54 - something like online
00:55 - rock-paper-scissors
00:56 - okay so let's this is client number one
00:59 - I'm just running another PI game window
01:01 - or PyCharm window with the server
01:03 - running on it and you can see obviously
01:04 - it's been oversized but it says waiting
01:06 - for player okay so I'm gonna launch
01:07 - another client and then excuse me you
01:10 - can see when I launch that it loads both
01:12 - of them up into the game and it says
01:14 - your move opponents your move opponents
01:16 - and currently it's waiting so I believe
01:18 - this one's player two and this one's
01:19 - player one so if I make a move here on
01:21 - let's say rock it'll lock in my move it
01:24 - says your move is rock and then over
01:26 - here it says obviously the opponent's
01:29 - move is locked in because it's like
01:31 - looking for this guy's move and now if
01:32 - he makes a move like let's say scissors
01:34 - then it says you win you lost and then
01:37 - it just resets and you can keep playing
01:39 - games now I'm also gonna be adding more
01:41 - to this this is just like the beta
01:42 - version I wanted to make sure I get the
01:44 - tutorials out quickly to you guys I'm
01:45 - gonna have wins ties and losses keeping
01:48 - track and top hand corner and when you
01:50 - load in you're gonna be brought to a
01:52 - menu screen which will allow you to like
01:54 - start a new game or to leave or we'll
01:57 - add that later as we go but this is the
01:58 - main functioning game and you can see
02:00 - obviously it's working well tie game and
02:03 - it restarts this also allows for
02:05 - unlimited amount of clients to play so
02:07 - for example if I launch another two
02:09 - windows you can see these guys now have
02:11 - their own game
02:12 - it's kind of difficult cuz I can't
02:13 - really get four on the screen but
02:15 - anyways if I go like scissors paper that
02:18 - works independently of these games and
02:20 - these games can kind of play at their
02:22 - own time which is really interesting and
02:24 - really cool and if you disconnect one of
02:26 - them it automatically disconnects the
02:28 - pair and that's just because obviously
02:30 - you can't play against no one right so
02:32 - yeah okay sweet so that's that's let's
02:36 - start getting into the code and there is
02:38 - quite a bit of it so this is probably
02:39 - I'm probably just gonna code all of it
02:41 - in one video and then split it up into
02:44 - sections so if the sections are kind of
02:45 - like choppy in terms of I don't do an
02:47 - intro or an outro that's why cuz I'm
02:49 - just gonna code all of it and if it's
02:50 - too long I'll chop it up into a few
02:52 - videos okay so first thing we're gonna
02:54 - do is were actually gonna code a game
02:57 - class okay and this is just gonna be
02:59 - responsible for holding all the
03:00 - information for our game that we need so
03:02 - for example did player 1 go yet 2 player
03:04 - to go yet what move did player 1 make
03:07 - one move to player 2 make our both of
03:09 - them connected to the server information
03:10 - like that and you guys will see how much
03:12 - information we actually need it's also
03:14 - gonna store things like keeping track of
03:16 - who won or who lost how many ties how
03:19 - many wins so we're gonna do with this
03:21 - game class so let's start making it so
03:23 - class game I'm doing this in its own
03:25 - file by the way just called game you are
03:28 - gonna need to insan file because it's
03:30 - gonna have to be accessed by both the
03:31 - client and the server ok we're gonna
03:33 - define our initialization in here we're
03:36 - gonna take ID I'm gonna say self
03:38 - thoughts p1 wedge equals false self dot
03:43 - p2 went equals false and obviously you
03:48 - guys know what this is gonna do it's
03:49 - just gonna stand for if player 1 has
03:50 - made a move or not if player 2 is made a
03:52 - move we're gonna do self taught ready
03:54 - equals false if I could type that
03:57 - correctly we're also gonna add self
03:59 - thought ID so self that ID equals ID and
04:02 - this is just gonna stand for the current
04:03 - games ID so each game we create is gonna
04:05 - have its own unique numeric ID so that
04:08 - we can determine who is like what
04:10 - clients are a part of what game and what
04:12 - not we're gonna do self dot moves equals
04:15 - and then we'll just do none and not in
04:17 - here cuz currently the moves are none
04:19 - but we'll just store two positions so we
04:21 - can change that we'll say self thought
04:23 - wins equals and then
04:25 - zero-zero obviously this one is gonna
04:27 - stand for player one this one's gonna
04:29 - stand for player two will say self
04:30 - thought ties equals zero that's all we
04:33 - need for the anit so next one is gonna
04:35 - say get underscore player underscore
04:38 - move now what this is gonna do is
04:41 - exactly what it says is just gonna get I
04:43 - don't know how I added that there it's
04:45 - just gonna get the player move that we
04:46 - asked for so we're going to take P which
04:48 - is going to be either a 0 or 1 and we're
04:50 - gonna do is simply return self dot moves
04:54 - and P and just remind ourselves we'll
04:58 - say that P is in the range of 0 and 1 so
05:03 - we're only going to take value 0 or 1
05:04 - and then we're going to return a move so
05:07 - let's say move here ok and there's
05:09 - that's just to remind ourselves that we
05:10 - have to pass here or 1 obviously 0 is
05:12 - gonna represent player 1 and 1 is gonna
05:15 - represent player 2 okay next one play so
05:17 - this one's a bit more complicated not
05:19 - crazy we're gonna take play we're gonna
05:21 - take a player and we're gonna take a
05:23 - move and what this is gonna do is it's
05:25 - simply going to update our moves list
05:27 - with that players move pretty
05:29 - straightforward so what we're gonna do
05:31 - here is we're just gonna say if player
05:34 - equals equals 0 then what we'll do is
05:37 - we'll say self dot moves 0 equals move
05:42 - Oh actually you know what let's do this
05:47 - sorry I'm just looking at my other
05:48 - screen right now we'll say self dot
05:49 - moves player equals move but now what we
05:52 - have to do is based on the player we
05:54 - have to update if p1 went or p2 went ok
05:56 - so what we'll do in here is if it's
05:58 - player 1 obviously we'll do p1 went
06:02 - equals true I'm gonna need a self before
06:05 - that and then we'll call we'll just do a
06:07 - little else here because it's not player
06:09 - 0 must be player 1 which will say self
06:11 - dot Pichu want if I could spell went
06:14 - equals trip so that will just keep track
06:17 - of if we've gone or not sweet next
06:20 - method this one's really easy it's gonna
06:21 - be called connected and it's just gonna
06:23 - tell us if the two players are currently
06:25 - connected to the game if they are it'll
06:29 - allow us to load in and that's how we
06:30 - can determine whether we should show
06:32 - waiting for player or not on the screen
06:33 - right so we'll say return self dot ready
06:37 - and that's just going to tell us
06:39 - obviously if we're ready and that'll be
06:40 - updated from the server side which we'll
06:42 - do later next method define both went
06:46 - this is just simply gonna return if both
06:49 - of our players left so to do that we're
06:51 - just gonna say self thought p1 once and
06:54 - why can I not spell that word hand
06:57 - itself thought p2 went like that
07:00 - okay next one is winner this one is a
07:03 - bit more complicated but it's just gonna
07:05 - keep track of where it's actually gonna
07:06 - tell us who's won the game so if we call
07:09 - this method we're assuming that both
07:11 - players have gone we're gonna check
07:13 - their moves
07:14 - excuse me against one another and see if
07:17 - they want so we're actually gonna have
07:18 - to check nine possible cases cuz there's
07:21 - three moves each player could do three
07:22 - times three nine so what we'll start by
07:25 - doing is what I say p1 equals self dot
07:28 - moves 0 dot upper and that's here the
07:36 - reason we're doing this is because we
07:37 - just want to get the first letter of the
07:39 - move because the move is going to be
07:41 - stored as rock paper or scissors the
07:42 - string and it just gonna be easier for
07:45 - us to type out for example R or s or
07:48 - what do you call it or P to check the
07:50 - moves as opposed to having to check the
07:52 - entire word so we're just going to get
07:54 - that first letter by doing move 0 we're
07:56 - gonna upper it and then we're gonna take
07:57 - that first letter
07:58 - we're gonna do the exact same thing for
07:59 - p2 except obviously we're going to need
08:02 - oh I don't know what I did there you're
08:05 - going to need moves 1 dot upper and now
08:08 - we can start checking to see who's 1 so
08:11 - we're going to stay to start winner is
08:12 - equal to negative 1 now that's because
08:14 - there could be no winner there could be
08:16 - a tie so if it's tied we're gonna say
08:18 - negative 1 if player 1 is the winner
08:21 - it's gonna be 0 if player 2 is the
08:23 - winner it's gonna be 1
08:24 - okay so we're gonna do is going to say
08:26 - if p1 equals equals R and p2 equals
08:32 - equals Scissors what we'll do is we'll
08:34 - say winner equals 0 because player 1 1
08:37 - that will say L if p1 equals equals s
08:41 - and p2 equals equals R then we'll say
08:47 - winner equals 1 believe do another Elif
08:52 - and I know this
08:53 - tedious but this is the way you have to
08:54 - check for rock-paper-scissors I don't
08:55 - think there's an easier way to do it if
08:57 - you know an easier way let me know and
08:58 - p2 equals equals R and if you guys don't
09:02 - want to type this you can always copy it
09:03 - from my website check with Tim dotnet
09:05 - okay so say winner equals paper beats
09:09 - rock so beat winner equals 1 or 0 sorry
09:12 - we'll say L if p1 equals equals R and p2
09:17 - equals equals P then winner equals 1 and
09:22 - we've just got two last ones to check
09:24 - here so we'll say L if p1 equals equals
09:27 - s and p2 equals equals R and then p2 is
09:34 - the winner so winner equals 1 believe
09:38 - that's oh sorry I might have messed this
09:40 - up this should be P thanks so P rock
09:43 - rock paper scissors paper yeah
09:45 - when R equals 0 ok L if p1 equals equals
09:50 - paper and p2 equals equals scissors then
09:56 - winner equals 1 and I believe that
09:59 - should be correct 1 2 3 4 5 6 okay sweet
10:02 - and then the other cases are if it's a
10:03 - tie so if none of this is the case then
10:05 - they must have tied and then all we're
10:07 - gonna do is simply return winner like
10:09 - that ok
10:11 - and one very last method then we're
10:14 - actually done with this class we can
10:15 - move to something else is define reset
10:17 - went and all this is going to do is say
10:20 - self-thought p1 went equals false and
10:23 - self thought p2 went equals false
10:27 - pretty straightforward and this is the
10:30 - game class I know what kind of sped
10:31 - through this but it's pretty trivial how
10:32 - this works
10:33 - we just need to get this out of the way
10:34 - so we can start coding some other stuff
10:36 - okay sweets we've done this class next
10:40 - thing I think we want to work on is
10:41 - network so network actually you guys are
10:44 - gonna have to modify yours to look like
10:46 - mine now get P and what do you call it
10:50 - so this first half so an it and get P
10:53 - are gonna be the same as what we had
10:54 - previously the only thing that's changed
10:56 - is connect and this end so in connect
10:59 - instead of what he call it like
11:02 - unpicking an object so like pickled alt
11:04 - loads what we're simply doing
11:07 - we're gonna just connect to the client
11:08 - like we did before but instead of
11:09 - unpicking it we're just gonna decode it
11:11 - I'm gonna say self dot client receive
11:14 - 2048 dot decode would return that value
11:18 - and that's because when we initially
11:20 - connect to the server what we're gonna
11:21 - get from the server is our player number
11:23 - which means we're either player 0 or
11:25 - we're player 1 now that's important
11:27 - because that's going to determine where
11:28 - on the screen we're drawing certain
11:30 - things and how we're sending information
11:31 - back to the server and updating player 1
11:34 - player 2 right because technically each
11:36 - player thinks that their player 1 but
11:38 - each one needs to be assigned either a 0
11:40 - or 1 by the computer so we know where to
11:43 - store information right ok so that's how
11:46 - we modify that just do decode instead of
11:48 - pickling sending I believe is the same
11:50 - except what we're gonna do is instead of
11:53 - pickling an object to send we're simply
11:55 - gonna send a string and we're gonna load
11:58 - an object so that means we're gonna send
12:00 - string data to the server and we're
12:02 - gonna receive back object data so when
12:04 - we receive something we have to pickle
12:06 - that loads it in but when we're sending
12:07 - it we just have to encode the string ok
12:09 - so just make sure it looks like this I
12:11 - don't think I need to go through this
12:12 - we've already done this for the past two
12:14 - three videos and that's the network
12:16 - class so game and network are done the
12:19 - next things to do our server and client
12:21 - now server and client are a bit more
12:24 - complicated so inside of server I guess
12:27 - we could do this first because it
12:28 - doesn't really depend on the client to
12:31 - work where the client kind of depends on
12:32 - the server we're gonna change a bunch of
12:35 - things so this is what it mine looks
12:37 - like now I've kind of gutted the entire
12:38 - threaded client I got rid of most of the
12:41 - stuff like most of the other stuff I
12:42 - just left this beginning thing so the
12:44 - server IP the port the socket connecting
12:48 - listening waiting for connection so by
12:51 - the way some of you were saying you're
12:52 - having issues with FS don't listen you
12:54 - can just make this zero it doesn't
12:56 - really matter what's in here
12:58 - and some of you were saying like you're
13:00 - having issues just you can just delete
13:01 - it and type it in again and apparently
13:03 - that works that's what someone said so I
13:05 - don't know don't ask me about that but
13:07 - if you're writing it to issues do that
13:08 - okay so what we're gonna do now is we
13:12 - want to make it so you can have
13:13 - unlimited connections at once
13:14 - now that means we're gonna have to have
13:16 - unlimited games running at the same time
13:19 - so before what we're doing
13:20 - when we had those players moving around
13:22 - the screen we were just wearing like
13:23 - player 1 player 2 and we just had a list
13:25 - that had two entries that's how we were
13:28 - doing that what we're gonna do now is
13:30 - we're gonna have a list that contains a
13:32 - bunch of different games and those games
13:34 - actually you're sorry it's gonna be a
13:35 - dictionary those games will be accessed
13:37 - by their ID and you guys will see how
13:40 - this works it's a bit complicated but
13:42 - just follow along and yeah so I gotta
13:45 - just open up my other file so don't make
13:46 - any mistakes here okay so what we're
13:48 - gonna do is we're gonna do connected
13:51 - equals set we're gonna define some
13:53 - variables will talk about these two
13:55 - games equals a blank dictionary and ID
13:58 - count equals zero so the reason we're
14:01 - adding these is games this dictionary is
14:03 - going to store our games so it's gonna
14:05 - have an ID as a key and the game as like
14:08 - a game object like this okay as the
14:11 - value this connected is just gonna store
14:14 - the IP addresses of the connected
14:16 - clients we're starting to set just so
14:19 - it's easier to access later I don't
14:20 - actually know if we use this we might
14:23 - but we'll see you okay ID count
14:26 - obviously is just gonna keep track of
14:27 - our current ID so that means what game
14:30 - we should recreate so we don't override
14:32 - games and say like two games have the
14:34 - same ID because obviously we can't have
14:36 - that happening okay so that's fine for
14:38 - that we're not gonna deal with anything
14:39 - threaded client right now we're gonna go
14:41 - down to our while loop and this is where
14:44 - we're gonna create new games based on
14:45 - new people joining or possibly delete
14:48 - games actually will delete games from
14:49 - threaded client so we're gonna do right
14:51 - now is when someone connects this this
14:53 - runs right and we run a new so like once
14:56 - we accept a connection everything after
14:58 - this runs so what we're gonna do is
14:59 - we're gonna say ID count plus equals one
15:02 - if you notice me looking away I'm just
15:04 - looking at my other screen to make sure
15:05 - I don't make any mistakes on this now
15:07 - what id count plus equals one is gonna
15:08 - do obviously is it's gonna keep track of
15:10 - how many people are connected to the the
15:13 - server at once because obviously right
15:15 - like once this happened we can except
15:17 - then we go down the while loop we start
15:19 - a new thread and then we wait for
15:21 - another connection so we're just gonna
15:22 - keep track of that what we're gonna do
15:24 - is we're gonna say P equals zero just
15:25 - standing for the current player we're
15:27 - going to say game ID equals and this is
15:30 - gonna be weird but just follow along
15:32 - with me
15:33 - we could ID count - one integer division
15:37 - - now what this is gonna do is
15:39 - essentially every two people that
15:42 - connect to the server we're gonna
15:44 - increment game ID by one and what game
15:47 - ID is gonna be or every we'll say it's
15:50 - yeah well add it by one what game ID is
15:52 - gonna do is keep track of what ID our
15:54 - game is gonna be so like for example if
15:56 - we have ten people connected to the
15:57 - server we're gonna have five games right
16:00 - so that's what this line of code is
16:01 - doing for us it's keeping track of how
16:03 - many games or if we need to add a new
16:05 - game because obviously if we have like
16:07 - six people connected all of them are
16:09 - gonna be playing each other a seventh
16:10 - person connects well it doesn't have a
16:12 - game to join we have to create a new
16:14 - game for it to join hopefully that makes
16:17 - sense okay so what we'll do next and say
16:18 - if I D count modulus two equals equals
16:22 - one and what this is gonna stand for is
16:25 - if you're gonna be player one or player
16:27 - two and if this happens is actually we
16:29 - need to create a new game because this
16:31 - means that we don't have a pair for our
16:34 - new player so for example like say this
16:37 - numbers three that means two people are
16:38 - already playing so though it's one
16:40 - person just connected so we need to
16:41 - create a new game that's what this
16:42 - modulus two is getting okay so to do
16:45 - that we're gonna say games game ID
16:49 - equals game game ID okay and I believe
16:55 - this X J's to be capital so obviously I
16:59 - saw at the beginning of this I forgot to
17:00 - mention I import a game so from game
17:02 - import game that is important and yes
17:06 - actually what we're doing is we're just
17:07 - going to say that game ID which is that
17:12 - key in our dictionary is now equal to a
17:14 - new game so we can access that and add
17:16 - players to it and whatnot sweet so that
17:18 - works let's actually print out a message
17:20 - here and just say creating a new game
17:24 - dot dot just so that in our server we
17:27 - get some kind of output and we can have
17:29 - a look at that if something's going
17:30 - wrong so otherwise if there we don't
17:33 - need to create new game meaning we have
17:34 - let's say three people are connected so
17:36 - that second game already exists and
17:38 - another person connects well that person
17:40 - has to be a part of this new game so
17:43 - what we're gonna do then is we're inside
17:44 - game
17:45 - game ID dot ready equals true now what
17:50 - this means is that the second player
17:52 - connected so there's two players now
17:54 - connected to our game so now we can say
17:56 - that that game is ready to start playing
17:57 - because both the players are connected
17:59 - so that means that they can will
18:00 - obviously play against each other right
18:02 - so that's what we'll do we'll set that
18:03 - dot ready equal to true and obviously
18:06 - we're storing all the games on the
18:07 - server side as opposed to on the client
18:09 - side and then we're going to say is
18:11 - going to say P equals one and what this
18:13 - means is player equals one and you'll
18:15 - see why we need to do this in a second
18:17 - okay so now we're gonna do start new
18:19 - thread
18:20 - [Music]

Cleaned transcript:

hey guys and welcome back to another online game tutorial with Python now I apologize for not having posted this for the past three days I guess but I've actually just been working on the code for what we're about to create and I want to make sure that there wasn't a massive bugs or error so that I didn't slow us down when I was teaching you guys how to do this and walking you through the code so like I mentioned in the last video I'm pretty much gonna be gutting everything we already did we'll keep a little bit of it but we're just gonna really add to a bunch of that and just yeah we're gonna be gutting most of it and we're actually working to create online rockpaperscissors now I know this sounds a kind of a lame game but let me show you because it's actually pretty complex and if you can understand how to make this game then you're gonna be able to understand how to make any other kind of online game because the principles are the same in terms of sending information waiting for players to go and there's a lot of different things and you might not think about that we actually have to do to code something like online rockpaperscissors okay so let's this is client number one I'm just running another PI game window or PyCharm window with the server running on it and you can see obviously it's been oversized but it says waiting for player okay so I'm gonna launch another client and then excuse me you can see when I launch that it loads both of them up into the game and it says your move opponents your move opponents and currently it's waiting so I believe this one's player two and this one's player one so if I make a move here on let's say rock it'll lock in my move it says your move is rock and then over here it says obviously the opponent's move is locked in because it's like looking for this guy's move and now if he makes a move like let's say scissors then it says you win you lost and then it just resets and you can keep playing games now I'm also gonna be adding more to this this is just like the beta version I wanted to make sure I get the tutorials out quickly to you guys I'm gonna have wins ties and losses keeping track and top hand corner and when you load in you're gonna be brought to a menu screen which will allow you to like start a new game or to leave or we'll add that later as we go but this is the main functioning game and you can see obviously it's working well tie game and it restarts this also allows for unlimited amount of clients to play so for example if I launch another two windows you can see these guys now have their own game it's kind of difficult cuz I can't really get four on the screen but anyways if I go like scissors paper that works independently of these games and these games can kind of play at their own time which is really interesting and really cool and if you disconnect one of them it automatically disconnects the pair and that's just because obviously you can't play against no one right so yeah okay sweet so that's that's let's start getting into the code and there is quite a bit of it so this is probably I'm probably just gonna code all of it in one video and then split it up into sections so if the sections are kind of like choppy in terms of I don't do an intro or an outro that's why cuz I'm just gonna code all of it and if it's too long I'll chop it up into a few videos okay so first thing we're gonna do is were actually gonna code a game class okay and this is just gonna be responsible for holding all the information for our game that we need so for example did player 1 go yet 2 player to go yet what move did player 1 make one move to player 2 make our both of them connected to the server information like that and you guys will see how much information we actually need it's also gonna store things like keeping track of who won or who lost how many ties how many wins so we're gonna do with this game class so let's start making it so class game I'm doing this in its own file by the way just called game you are gonna need to insan file because it's gonna have to be accessed by both the client and the server ok we're gonna define our initialization in here we're gonna take ID I'm gonna say self thoughts p1 wedge equals false self dot p2 went equals false and obviously you guys know what this is gonna do it's just gonna stand for if player 1 has made a move or not if player 2 is made a move we're gonna do self taught ready equals false if I could type that correctly we're also gonna add self thought ID so self that ID equals ID and this is just gonna stand for the current games ID so each game we create is gonna have its own unique numeric ID so that we can determine who is like what clients are a part of what game and what not we're gonna do self dot moves equals and then we'll just do none and not in here cuz currently the moves are none but we'll just store two positions so we can change that we'll say self thought wins equals and then zerozero obviously this one is gonna stand for player one this one's gonna stand for player two will say self thought ties equals zero that's all we need for the anit so next one is gonna say get underscore player underscore move now what this is gonna do is exactly what it says is just gonna get I don't know how I added that there it's just gonna get the player move that we asked for so we're going to take P which is going to be either a 0 or 1 and we're gonna do is simply return self dot moves and P and just remind ourselves we'll say that P is in the range of 0 and 1 so we're only going to take value 0 or 1 and then we're going to return a move so let's say move here ok and there's that's just to remind ourselves that we have to pass here or 1 obviously 0 is gonna represent player 1 and 1 is gonna represent player 2 okay next one play so this one's a bit more complicated not crazy we're gonna take play we're gonna take a player and we're gonna take a move and what this is gonna do is it's simply going to update our moves list with that players move pretty straightforward so what we're gonna do here is we're just gonna say if player equals equals 0 then what we'll do is we'll say self dot moves 0 equals move Oh actually you know what let's do this sorry I'm just looking at my other screen right now we'll say self dot moves player equals move but now what we have to do is based on the player we have to update if p1 went or p2 went ok so what we'll do in here is if it's player 1 obviously we'll do p1 went equals true I'm gonna need a self before that and then we'll call we'll just do a little else here because it's not player 0 must be player 1 which will say self dot Pichu want if I could spell went equals trip so that will just keep track of if we've gone or not sweet next method this one's really easy it's gonna be called connected and it's just gonna tell us if the two players are currently connected to the game if they are it'll allow us to load in and that's how we can determine whether we should show waiting for player or not on the screen right so we'll say return self dot ready and that's just going to tell us obviously if we're ready and that'll be updated from the server side which we'll do later next method define both went this is just simply gonna return if both of our players left so to do that we're just gonna say self thought p1 once and why can I not spell that word hand itself thought p2 went like that okay next one is winner this one is a bit more complicated but it's just gonna keep track of where it's actually gonna tell us who's won the game so if we call this method we're assuming that both players have gone we're gonna check their moves excuse me against one another and see if they want so we're actually gonna have to check nine possible cases cuz there's three moves each player could do three times three nine so what we'll start by doing is what I say p1 equals self dot moves 0 dot upper and that's here the reason we're doing this is because we just want to get the first letter of the move because the move is going to be stored as rock paper or scissors the string and it just gonna be easier for us to type out for example R or s or what do you call it or P to check the moves as opposed to having to check the entire word so we're just going to get that first letter by doing move 0 we're gonna upper it and then we're gonna take that first letter we're gonna do the exact same thing for p2 except obviously we're going to need oh I don't know what I did there you're going to need moves 1 dot upper and now we can start checking to see who's 1 so we're going to stay to start winner is equal to negative 1 now that's because there could be no winner there could be a tie so if it's tied we're gonna say negative 1 if player 1 is the winner it's gonna be 0 if player 2 is the winner it's gonna be 1 okay so we're gonna do is going to say if p1 equals equals R and p2 equals equals Scissors what we'll do is we'll say winner equals 0 because player 1 1 that will say L if p1 equals equals s and p2 equals equals R then we'll say winner equals 1 believe do another Elif and I know this tedious but this is the way you have to check for rockpaperscissors I don't think there's an easier way to do it if you know an easier way let me know and p2 equals equals R and if you guys don't want to type this you can always copy it from my website check with Tim dotnet okay so say winner equals paper beats rock so beat winner equals 1 or 0 sorry we'll say L if p1 equals equals R and p2 equals equals P then winner equals 1 and we've just got two last ones to check here so we'll say L if p1 equals equals s and p2 equals equals R and then p2 is the winner so winner equals 1 believe that's oh sorry I might have messed this up this should be P thanks so P rock rock paper scissors paper yeah when R equals 0 ok L if p1 equals equals paper and p2 equals equals scissors then winner equals 1 and I believe that should be correct 1 2 3 4 5 6 okay sweet and then the other cases are if it's a tie so if none of this is the case then they must have tied and then all we're gonna do is simply return winner like that ok and one very last method then we're actually done with this class we can move to something else is define reset went and all this is going to do is say selfthought p1 went equals false and self thought p2 went equals false pretty straightforward and this is the game class I know what kind of sped through this but it's pretty trivial how this works we just need to get this out of the way so we can start coding some other stuff okay sweets we've done this class next thing I think we want to work on is network so network actually you guys are gonna have to modify yours to look like mine now get P and what do you call it so this first half so an it and get P are gonna be the same as what we had previously the only thing that's changed is connect and this end so in connect instead of what he call it like unpicking an object so like pickled alt loads what we're simply doing we're gonna just connect to the client like we did before but instead of unpicking it we're just gonna decode it I'm gonna say self dot client receive 2048 dot decode would return that value and that's because when we initially connect to the server what we're gonna get from the server is our player number which means we're either player 0 or we're player 1 now that's important because that's going to determine where on the screen we're drawing certain things and how we're sending information back to the server and updating player 1 player 2 right because technically each player thinks that their player 1 but each one needs to be assigned either a 0 or 1 by the computer so we know where to store information right ok so that's how we modify that just do decode instead of pickling sending I believe is the same except what we're gonna do is instead of pickling an object to send we're simply gonna send a string and we're gonna load an object so that means we're gonna send string data to the server and we're gonna receive back object data so when we receive something we have to pickle that loads it in but when we're sending it we just have to encode the string ok so just make sure it looks like this I don't think I need to go through this we've already done this for the past two three videos and that's the network class so game and network are done the next things to do our server and client now server and client are a bit more complicated so inside of server I guess we could do this first because it doesn't really depend on the client to work where the client kind of depends on the server we're gonna change a bunch of things so this is what it mine looks like now I've kind of gutted the entire threaded client I got rid of most of the stuff like most of the other stuff I just left this beginning thing so the server IP the port the socket connecting listening waiting for connection so by the way some of you were saying you're having issues with FS don't listen you can just make this zero it doesn't really matter what's in here and some of you were saying like you're having issues just you can just delete it and type it in again and apparently that works that's what someone said so I don't know don't ask me about that but if you're writing it to issues do that okay so what we're gonna do now is we want to make it so you can have unlimited connections at once now that means we're gonna have to have unlimited games running at the same time so before what we're doing when we had those players moving around the screen we were just wearing like player 1 player 2 and we just had a list that had two entries that's how we were doing that what we're gonna do now is we're gonna have a list that contains a bunch of different games and those games actually you're sorry it's gonna be a dictionary those games will be accessed by their ID and you guys will see how this works it's a bit complicated but just follow along and yeah so I gotta just open up my other file so don't make any mistakes here okay so what we're gonna do is we're gonna do connected equals set we're gonna define some variables will talk about these two games equals a blank dictionary and ID count equals zero so the reason we're adding these is games this dictionary is going to store our games so it's gonna have an ID as a key and the game as like a game object like this okay as the value this connected is just gonna store the IP addresses of the connected clients we're starting to set just so it's easier to access later I don't actually know if we use this we might but we'll see you okay ID count obviously is just gonna keep track of our current ID so that means what game we should recreate so we don't override games and say like two games have the same ID because obviously we can't have that happening okay so that's fine for that we're not gonna deal with anything threaded client right now we're gonna go down to our while loop and this is where we're gonna create new games based on new people joining or possibly delete games actually will delete games from threaded client so we're gonna do right now is when someone connects this this runs right and we run a new so like once we accept a connection everything after this runs so what we're gonna do is we're gonna say ID count plus equals one if you notice me looking away I'm just looking at my other screen to make sure I don't make any mistakes on this now what id count plus equals one is gonna do obviously is it's gonna keep track of how many people are connected to the the server at once because obviously right like once this happened we can except then we go down the while loop we start a new thread and then we wait for another connection so we're just gonna keep track of that what we're gonna do is we're gonna say P equals zero just standing for the current player we're going to say game ID equals and this is gonna be weird but just follow along with me we could ID count one integer division now what this is gonna do is essentially every two people that connect to the server we're gonna increment game ID by one and what game ID is gonna be or every we'll say it's yeah well add it by one what game ID is gonna do is keep track of what ID our game is gonna be so like for example if we have ten people connected to the server we're gonna have five games right so that's what this line of code is doing for us it's keeping track of how many games or if we need to add a new game because obviously if we have like six people connected all of them are gonna be playing each other a seventh person connects well it doesn't have a game to join we have to create a new game for it to join hopefully that makes sense okay so what we'll do next and say if I D count modulus two equals equals one and what this is gonna stand for is if you're gonna be player one or player two and if this happens is actually we need to create a new game because this means that we don't have a pair for our new player so for example like say this numbers three that means two people are already playing so though it's one person just connected so we need to create a new game that's what this modulus two is getting okay so to do that we're gonna say games game ID equals game game ID okay and I believe this X J's to be capital so obviously I saw at the beginning of this I forgot to mention I import a game so from game import game that is important and yes actually what we're doing is we're just going to say that game ID which is that key in our dictionary is now equal to a new game so we can access that and add players to it and whatnot sweet so that works let's actually print out a message here and just say creating a new game dot dot just so that in our server we get some kind of output and we can have a look at that if something's going wrong so otherwise if there we don't need to create new game meaning we have let's say three people are connected so that second game already exists and another person connects well that person has to be a part of this new game so what we're gonna do then is we're inside game game ID dot ready equals true now what this means is that the second player connected so there's two players now connected to our game so now we can say that that game is ready to start playing because both the players are connected so that means that they can will obviously play against each other right so that's what we'll do we'll set that dot ready equal to true and obviously we're storing all the games on the server side as opposed to on the client side and then we're going to say is going to say P equals one and what this means is player equals one and you'll see why we need to do this in a second okay so now we're gonna do start new thread
