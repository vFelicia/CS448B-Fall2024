With timestamps:

00:02 - [Music]
00:08 - hello everybody and welcome back so in
00:10 - today's video i'm going to be showing
00:12 - you five python bad practices that you
00:15 - should avoid now these are things that
00:16 - many people do not actually know are bad
00:19 - practices they seem normal or kind of
00:21 - usual or natural to do but can lead to a
00:24 - lot of complications errors or just
00:26 - messy and unreadable code so with that
00:28 - said let's go ahead and dive into the
00:30 - video after a quick word from our
00:32 - sponsor before we get started i need to
00:35 - thank vidyard for sponsoring this video
00:37 - vidyard provides video tools built for
00:39 - improving communication and making
00:40 - remote work easier vidyard's video
00:43 - creation tools let you create and stream
00:45 - videos seamlessly so that you can better
00:47 - communicate with your employees or
00:48 - co-workers vidyard provides a free
00:50 - chrome extension and a desktop
00:52 - application that lets you record your
00:54 - audio video screen and all combinations
00:56 - of the above you can also upload
00:58 - existing videos to vidyard a great
01:01 - feature of vidyard is once you stop your
01:02 - recording it's automatically uploaded to
01:04 - vidyard so you can attach an email slack
01:07 - channel or wherever else you'd like to
01:08 - share it vidyard can be used to quickly
01:10 - log a bug while providing a demo ask
01:12 - detailed questions about code and to get
01:14 - feedback quicker from your team vidyard
01:17 - is perfect for senior leaders employee
01:19 - communication and for creating training
01:20 - in hr videos not only do vidyard videos
01:23 - add a personal touch to communication
01:25 - but they also have detailed analytics
01:27 - and security settings so you can track
01:28 - engagement and limit access to sensitive
01:31 - content vidyard is also used for sas
01:33 - sales and marketing and has all kinds of
01:35 - solutions for any use case vidyard is
01:38 - used by microsoft shopify linkedin and
01:40 - thousands of other large companies and
01:42 - you can get started with it yourself for
01:43 - free today by clicking the link in the
01:46 - description all right so let's move on
01:48 - to our first python bad practice which
01:50 - is mutable default parameters so this
01:53 - bad practice involves using a mutable
01:55 - object as the default parameter for a
01:58 - parameter inside of a function or a
02:00 - method now before i go any further with
02:02 - the explanation just have a look at this
02:04 - code and take a guess at what you think
02:06 - the output is going to be so pause the
02:08 - video if you need to i'm going to
02:10 - explain it now so i'm assuming that most
02:12 - of you would guess that what the output
02:13 - of this should be is one and then inside
02:16 - of a list one and then two and inside of
02:18 - a list two
02:19 - now this is actually not what the output
02:21 - is but intuitively that's kind of what
02:23 - it looks like right so let me stop here
02:25 - and run the code and show you what the
02:27 - output actually is so the output is one
02:30 - inside of a list one two inside of a
02:32 - list one comma two so that's a little
02:35 - bit strange why are we getting one comma
02:37 - 2 as the second result here well the
02:40 - reason why we're getting that is because
02:41 - we're using a mutable default parameter
02:44 - so if this was not a mutable object or
02:46 - this operated in the way that we thought
02:48 - it should operate then what would happen
02:50 - is when we call this function a new
02:52 - empty list would be created and stored
02:54 - in the parameter numbers we would append
02:55 - the number that we passed here to that
02:57 - list we then print the number print that
02:59 - list and then return it but since this
03:02 - is a mutable object this is not being
03:04 - recreated every time we call this
03:07 - function and so on the first function
03:09 - call we have this list object and on the
03:11 - sec second function called surrey
03:13 - numbers is equal to the same list object
03:16 - but now we've appended a 1 into it and
03:18 - so numbers kind of looks like that so
03:20 - we're actually modifying the same object
03:23 - in both of these function calls and i'll
03:25 - just do it one more time to show you
03:26 - that if i do another function call oops
03:29 - meant to run the code here we get the
03:30 - exact same thing right three and then
03:32 - one two three the same pattern persists
03:35 - so these are the exact same objects so
03:37 - we're modifying in every single one of
03:39 - these function calls now just to prove
03:42 - this to you i'm going to show you that
03:44 - the return value which is this list here
03:47 - is the exact same for x y and z they are
03:49 - actually the exact same object so x
03:52 - is y
03:53 - and y
03:55 - is z so when you use is this tells you
03:57 - if two objects are identical if you're
03:59 - the same object and so assuming that x y
04:02 - and z are all the same object this
04:03 - should print true so let's run this and
04:05 - we see that it is indeed true
04:08 - so why is this the case well when you
04:10 - use a mutable value for the default
04:12 - parameter what happens is this parameter
04:14 - here points to kind of a little box in
04:17 - memory that stores this object and it
04:20 - keeps pointing to that box even when you
04:22 - call the function again and again so
04:24 - when i modify what's in that box in
04:26 - memory and i add a 1 to it and then i
04:29 - add a 2 to it it stays the same as the
04:32 - code runs these don't get removed and so
04:34 - that's why we're getting 1 2 1 2 3.
04:37 - hopefully that kind of makes sense but
04:38 - let me show you that the same problem
04:40 - does not occur if we have a
04:42 - non-immutable value here so let's make a
04:44 - string and let's just call this hello
04:46 - and rather than number let's just change
04:48 - this to i know s which will be some
04:51 - string
04:52 - and if i go and do something
04:54 - like okay i need to kind of change the
04:56 - entire thing here let's go s string
04:59 - let's go string plus equals s like that
05:02 - and then print s
05:04 - and print
05:06 - string and then return string and we
05:10 - might as well call this uh append
05:13 - string okay so let's change our example
05:15 - here
05:16 - let's go append
05:18 - underscore string
05:19 - hello or let's just go h
05:22 - oops and then append
05:26 - underscore string i
05:28 - okay so now if i run this code you're
05:30 - gonna see this works in the way that we
05:32 - think it should work so we get hello h
05:34 - and then hello i and that's because this
05:37 - is not a mutable object and that means
05:39 - we cannot modify this object in place so
05:42 - when i do string plus equals s what
05:44 - happens is a brand new string is created
05:47 - and assigned to the value string we
05:50 - print out that value string which is
05:51 - local to this function and then we
05:53 - return that new string object we don't
05:56 - modify what is being stored inside of
05:58 - this string parameter right here and so
06:01 - when we call the function again and
06:02 - string is equal to hello it's still
06:04 - equal to hello it's not been changed
06:06 - because of the fact that this created a
06:08 - brand new string and assigned it to the
06:10 - local variable string which is inside of
06:12 - this function it's a little bit
06:13 - confusing but just understand that you
06:15 - should not use a mutable default
06:17 - parameter for the reason that i just
06:19 - showed you you'll get all kinds of weird
06:21 - results and it's a very difficult thing
06:23 - to debug so moving on to the second bad
06:26 - practice we have not using a default
06:28 - dictionary now explain what that is in
06:30 - one second but first let's have a look
06:32 - at this code right here
06:34 - so we have this dictionary called counts
06:36 - we have a list of numbers we're looping
06:39 - through all of the numbers checking if
06:41 - the number that we're on is in our
06:42 - counts data structure in our dictionary
06:45 - if it's not then we create a new key
06:47 - with that value we set it equal to zero
06:50 - and then we append the value of that key
06:53 - what this is doing is just counting the
06:54 - frequency of all these numbers in the
06:56 - list pretty straight forward now this
06:58 - code is fine you can write this but
07:01 - technically this is considered a bad
07:03 - practice in python because there exists
07:05 - a data structure called a default
07:07 - dictionary which makes it so you do not
07:09 - need to do this check right here and
07:11 - that's kind of the more pythonic way or
07:13 - style of doing this so let me show that
07:15 - to you so to use the default dictionary
07:17 - you need to import it from a built-in
07:20 - module in python called collections so
07:22 - you need to say from
07:23 - collections and then instead of order
07:26 - dick you are going to import the default
07:29 - dictionary like that
07:31 - all right so from collections import
07:33 - default dictionary now to create a
07:35 - default dictionary what you need to do
07:37 - is use the default dict right here so
07:39 - you're going to say
07:40 - counts is equal to
07:42 - default dict and then you need to pass a
07:44 - callable object that returns what the
07:46 - default value for this dictionary should
07:49 - be so i'll kind of explain this in one
07:51 - second but let me just write this out so
07:53 - lambda and then 0 like that now if
07:55 - you're unfamiliar with the lambda this
07:57 - is completely equivalent to this so to
07:59 - find func
08:00 - return zero it's just kind of a
08:02 - shorthand way of doing this this is
08:04 - known as a one line anonymous function
08:07 - anyways what this is saying is if you
08:09 - try to access a key that does not exist
08:12 - in the dictionary it will automatically
08:14 - create one for you that has the value
08:16 - zero that's all it said so let me now
08:19 - show you how we can rewrite this here
08:21 - using the default dictionary so let me
08:23 - copy numbers here
08:25 - and let's say four key
08:28 - in numbers and now what i'm going to do
08:30 - is just say
08:31 - counts which that should be counts at
08:34 - key
08:36 - plus equals one and i'm going to print
08:38 - out counts like that
08:41 - so now if i run this code you're going
08:44 - to see everything works totally fine
08:47 - we don't get any errors this is just
08:50 - functioning properly and the reason for
08:51 - that is we're now using a default
08:53 - dictionary now you will notice that
08:55 - there is some minor differences between
08:57 - a regular dictionary and a default
08:59 - dictionary so you have to be a little
09:00 - bit careful when you're using a default
09:02 - dictionary because some of the methods
09:03 - might be a little bit different but the
09:05 - way you use it is practically the exact
09:07 - same but notice when i print out default
09:10 - dictionary it's giving me the default
09:11 - value and then it's giving me the
09:12 - dictionary it's not just giving me the
09:14 - dictionary so be careful in how you use
09:17 - it you will have to kind of look it up a
09:19 - little bit but it's not very complicated
09:20 - and it saves you you know some
09:22 - cleanliness and readability of your code
09:24 - if you do decide to use it now in the
09:26 - same way here there is another thing
09:28 - that you can use to avoid having to do
09:31 - this type of check when you're kind of
09:33 - trying to access a key or change a key
09:36 - value in dictionary let me just get rid
09:38 - of this example here and show you an
09:39 - example in which what i'm about to show
09:41 - you makes sense so let's say you have a
09:44 - dictionary let's just make it an empty
09:45 - dictionary called d and let's see if a
09:48 - key is in this dictionary so if list is
09:51 - not in d then what i want to do is go d
09:54 - list is equal to that and then i want to
09:57 - say d
09:58 - and sorry this should be at the key list
10:02 - dot append and i want to add maybe the
10:04 - value three into this list the list
10:06 - that's stored as the the value for the
10:09 - key list
10:10 - all right so the way that you can
10:11 - actually shorten these three lines of
10:13 - code right here into one single line is
10:16 - by doing the following without creating
10:18 - a default dictionary you can do this you
10:20 - can say d
10:22 - dot set default you can pass the key
10:24 - value you can pass what the default
10:26 - should be and then you can perform
10:28 - whatever operation you want to perform
10:29 - on this value so i can say dot append
10:32 - and then 3. now what set default does is
10:35 - it will set the default value for a key
10:37 - that you are trying to access if it
10:39 - doesn't exist and then return it but if
10:42 - the key does exist it will return its
10:44 - value so in this case what will happen
10:46 - is if the key list exists in the
10:48 - dictionary it will return the value of
10:50 - that key and then it would append three
10:52 - to it before it returns that story but
10:55 - if it doesn't exist it sets it equal to
10:57 - an empty list and then in this case it's
10:58 - appending three to that list so that is
11:00 - how you can avoid doing this kind of
11:02 - tedious check yours by using this set
11:04 - default method i know myself i didn't
11:06 - know this existed until probably a few
11:08 - months ago actually and it's not
11:10 - something that i used a lot in my python
11:12 - code but definitely saves a bit of time
11:14 - makes your code more readable and is a
11:16 - better practice doing something like
11:17 - this is kind of considered a bad python
11:19 - practice just because again it's not in
11:21 - that pythonic style if you have a method
11:24 - like this you might as well use it so
11:26 - now we're moving on to the next bad
11:27 - practice which is not using a context
11:30 - manager when opening files now in this
11:32 - case when i say context manager i'm
11:34 - referring to the with statement some of
11:36 - you may know what i'm talking about here
11:38 - but let me just show you an example of
11:39 - what the bad practice is and then how to
11:42 - fix it so if you want to work with a
11:44 - file specifically or really any resource
11:46 - that kind of needs cleaning up or
11:47 - closing when you're done working with it
11:49 - you really should use a context manager
11:51 - however not using a context manager
11:53 - would look something like this f equals
11:56 - open
11:57 - file.txt
11:58 - and then we're going to open it in write
12:00 - mode so let's say we want to open this
12:02 - new file called file.txt maybe we want
12:04 - to write some lines to it so f dot write
12:08 - i don't know let's write hello into it
12:10 - or something like that
12:11 - well
12:12 - what we need to do after we've opened
12:14 - this file and we've written lines into
12:15 - it is we need to make sure we close the
12:17 - file so we do something like f dot close
12:20 - now this is fine this code will work all
12:23 - right there won't be any issues here
12:24 - however we really need to make sure
12:26 - whenever we open a file that we close it
12:29 - so if you forget to write this close
12:31 - here that's going to lead to some
12:32 - problems for you i actually don't think
12:34 - this file will save or at least other
12:37 - programs won't be able to access this
12:39 - file this program that's currently
12:41 - running will be kind of the owner and
12:42 - have access to that file and there's
12:44 - just all kinds of issues that can occur
12:46 - if you forget to close a file after you
12:48 - open it so that's a really big deal so
12:50 - okay you might be saying all right i'll
12:51 - just remember to close the file well
12:53 - that's great if you do remember to close
12:55 - the file but another issue can happen if
12:57 - in between when you open the file and
12:59 - you close the file some type of error
13:01 - occurs or your program crashes or the
13:04 - user ends your program before you've
13:06 - closed the file so what you need to do
13:08 - when you're working with files is rather
13:10 - than doing it in this way and just
13:11 - praying that you're actually going to be
13:13 - able to close the file after is you need
13:14 - to use a context manager now a context
13:17 - manager is with and i'll explain kind of
13:19 - what that is but the way that this code
13:21 - would look in a context manager is the
13:22 - following open file.txt in right mode as
13:26 - f and then f dot write and then you
13:30 - would write hello and then you actually
13:32 - do not need to manually close the file
13:34 - when you open a file in this way so what
13:36 - this does right here is ensure that no
13:39 - matter what happens this file is going
13:41 - to be closed so when you open the file
13:44 - you open it as f you can then do all of
13:46 - your operations inside of this with
13:48 - statement and then as soon as this with
13:50 - statement is done it will automatically
13:52 - close the file and if an exception
13:54 - occurs it will close the file before the
13:56 - program terminates so that is why you
13:58 - use a context manager and really all the
14:01 - context manager is is something that
14:03 - enforces a cleanup operation
14:05 - after this with statement is done
14:07 - whether that be because the program
14:09 - crashed or because it just finished
14:11 - executing all of the statements so there
14:13 - are many other times in which using a
14:14 - context manager is very very important
14:16 - if you want to avoid a bunch of
14:18 - potential problems but really just think
14:20 - of using one whenever you have kind of a
14:22 - cleanup operation that needs to occur
14:24 - now the thing is you can't just use this
14:26 - context manager anywhere this cleanup
14:29 - operation needs to be implemented by
14:30 - something in this case when we use open
14:33 - like this
14:34 - it implements this cleanup operation so
14:36 - it knows okay once i'm done with this
14:38 - i'm going to close the file there's a
14:40 - lot of other things in python that have
14:42 - context managers built in but just
14:44 - wanted to show you here if you are
14:45 - working with files or any resource that
14:46 - needs to be cleaned up try to use a
14:48 - context manager or at least look and see
14:50 - if a context manager is available for
14:52 - the resource that you're trying to use
14:54 - so moving on to the next bad practice
14:56 - which is not using the enumerate
14:58 - function when it's applicable to use it
15:00 - now the enumerate function is something
15:02 - that allows you to get access to the
15:04 - item as well as the index of elements in
15:07 - a list so if we're looking at this
15:09 - example right here we have a list we
15:11 - want to loop through it and we want
15:12 - access to the index so maybe we want to
15:14 - print the index and then we want access
15:16 - to all of the different values all the
15:18 - elements in the list now the traditional
15:20 - way to do this in most programming
15:22 - languages is what you see right here we
15:24 - say 4i in range we go through whatever
15:27 - the length of the list is so loop
15:29 - through all of the indices
15:30 - we get access to the value of each of
15:32 - the items by indexing it in the list and
15:35 - then we print out whatever the index is
15:37 - and the value so let's have a look here
15:39 - we get you know
15:41 - let's
15:42 - scroll here come on zero one one two two
15:44 - three three four so on and so forth now
15:47 - this is fine you can do this it's not
15:49 - that bad but the best practice in python
15:52 - is to do the following for i
15:54 - comma val
15:56 - in enumerate lst
15:58 - print i
15:59 - comma val now you've eliminated this
16:01 - line right here and you've actually made
16:03 - it more readable and easier to find what
16:06 - variable is storing the value of the
16:08 - element and what variable is storing the
16:10 - index
16:11 - so let me just erase this for a second
16:13 - so as i said what enumerate will do is
16:15 - give you the index as well as the value
16:18 - the first item here the first variable
16:19 - here is going to be the index the second
16:22 - value here is going to be the actual
16:24 - value of the item so if i run this we
16:26 - get the exact same result as before and
16:29 - there you go use enumerate in a
16:31 - situation where it makes sense to use it
16:33 - now enumerate doesn't just work with
16:35 - lists it works with any iterable object
16:37 - so work with strings it will work with
16:39 - dictionaries it will work with sets i'll
16:41 - just show you an example with a
16:42 - dictionary so let's say we have hello
16:45 - comma 1
16:47 - name comma 2 and let's enumerate through
16:50 - i guess let's just call it d now
16:53 - okay and let's run this and now notice
16:56 - we get 0 hello one name
16:58 - we can do the same with a set so one two
17:00 - three
17:01 - okay save and run
17:03 - same thing that works and then finally
17:05 - of course we can do this with a string
17:07 - so hello my name is tim
17:09 - let's run this and notice we get it
17:12 - working as we would expect so that's all
17:14 - for this bad practice just remember this
17:16 - enumerate function exists and you should
17:17 - use it if it makes sense to do so
17:19 - alright so the last bad practice i have
17:21 - for you is another quick one and this is
17:23 - simply to not override built-in names in
17:26 - python what i mean by that is do not
17:28 - name variables things that are python
17:30 - keywords
17:31 - for example
17:32 - do not create a variable called id or a
17:35 - variable called zip you might be tempted
17:37 - to do zip because like a zip code or
17:39 - something right
17:40 - do not name a variable list you do not
17:42 - want to do this the reason why is if you
17:45 - do this you disable or kind of remove
17:47 - the ability to use what these built-in
17:49 - python keywords actually are so if i
17:52 - name a variable id i can now no longer
17:54 - use the id function and the id function
17:57 - gives you the memory address of a python
17:59 - object so if i do idx now you're going
18:02 - to see that i get an error the into
18:03 - object is not callable whereas if i
18:06 - comment this out now i'm still able to
18:08 - use the function so if i wanted to print
18:11 - the id
18:12 - this works it works as a variable as i
18:14 - would expect but again i can no longer
18:16 - use what the actual built-in python
18:18 - function is so you shouldn't name stuff
18:20 - like this you know same goes with zip
18:22 - same goes with list now let's say you
18:24 - really want to name your variable id zip
18:27 - or list or any other built-in python
18:29 - keyword if you really want to do that
18:31 - first of all i'd recommend just don't do
18:32 - it but what you can do is add a trailing
18:35 - underscore this is the convention if you
18:37 - really need to name something
18:39 - a built-in keyword in python then you
18:41 - just put an underscore after you could
18:43 - put an underscore before when you put an
18:45 - underscore before this is the python
18:47 - convention for make this a private
18:49 - attribute or make this a private
18:50 - variable so unless that's what you're
18:52 - intending then you should actually do a
18:54 - trailing underscore so that's all for
18:56 - this last bad practice seems pretty
18:58 - intuitive and straightforward but i
19:00 - cannot tell you how many people do this
19:02 - and it's really frustrating because the
19:03 - syntax highlighting gets all messed up
19:05 - for it and then of course you deactivate
19:07 - the ability to actually use what this
19:08 - built-in keyword is so with that said i
19:10 - think i'm going to end the video here i
19:12 - hope this was helpful if it was make
19:14 - sure to leave a like subscribe to the
19:16 - channel and i will see you in another
19:17 - youtube video
19:20 - [Music]
19:26 - you

Cleaned transcript:

hello everybody and welcome back so in today's video i'm going to be showing you five python bad practices that you should avoid now these are things that many people do not actually know are bad practices they seem normal or kind of usual or natural to do but can lead to a lot of complications errors or just messy and unreadable code so with that said let's go ahead and dive into the video after a quick word from our sponsor before we get started i need to thank vidyard for sponsoring this video vidyard provides video tools built for improving communication and making remote work easier vidyard's video creation tools let you create and stream videos seamlessly so that you can better communicate with your employees or coworkers vidyard provides a free chrome extension and a desktop application that lets you record your audio video screen and all combinations of the above you can also upload existing videos to vidyard a great feature of vidyard is once you stop your recording it's automatically uploaded to vidyard so you can attach an email slack channel or wherever else you'd like to share it vidyard can be used to quickly log a bug while providing a demo ask detailed questions about code and to get feedback quicker from your team vidyard is perfect for senior leaders employee communication and for creating training in hr videos not only do vidyard videos add a personal touch to communication but they also have detailed analytics and security settings so you can track engagement and limit access to sensitive content vidyard is also used for sas sales and marketing and has all kinds of solutions for any use case vidyard is used by microsoft shopify linkedin and thousands of other large companies and you can get started with it yourself for free today by clicking the link in the description all right so let's move on to our first python bad practice which is mutable default parameters so this bad practice involves using a mutable object as the default parameter for a parameter inside of a function or a method now before i go any further with the explanation just have a look at this code and take a guess at what you think the output is going to be so pause the video if you need to i'm going to explain it now so i'm assuming that most of you would guess that what the output of this should be is one and then inside of a list one and then two and inside of a list two now this is actually not what the output is but intuitively that's kind of what it looks like right so let me stop here and run the code and show you what the output actually is so the output is one inside of a list one two inside of a list one comma two so that's a little bit strange why are we getting one comma 2 as the second result here well the reason why we're getting that is because we're using a mutable default parameter so if this was not a mutable object or this operated in the way that we thought it should operate then what would happen is when we call this function a new empty list would be created and stored in the parameter numbers we would append the number that we passed here to that list we then print the number print that list and then return it but since this is a mutable object this is not being recreated every time we call this function and so on the first function call we have this list object and on the sec second function called surrey numbers is equal to the same list object but now we've appended a 1 into it and so numbers kind of looks like that so we're actually modifying the same object in both of these function calls and i'll just do it one more time to show you that if i do another function call oops meant to run the code here we get the exact same thing right three and then one two three the same pattern persists so these are the exact same objects so we're modifying in every single one of these function calls now just to prove this to you i'm going to show you that the return value which is this list here is the exact same for x y and z they are actually the exact same object so x is y and y is z so when you use is this tells you if two objects are identical if you're the same object and so assuming that x y and z are all the same object this should print true so let's run this and we see that it is indeed true so why is this the case well when you use a mutable value for the default parameter what happens is this parameter here points to kind of a little box in memory that stores this object and it keeps pointing to that box even when you call the function again and again so when i modify what's in that box in memory and i add a 1 to it and then i add a 2 to it it stays the same as the code runs these don't get removed and so that's why we're getting 1 2 1 2 3. hopefully that kind of makes sense but let me show you that the same problem does not occur if we have a nonimmutable value here so let's make a string and let's just call this hello and rather than number let's just change this to i know s which will be some string and if i go and do something like okay i need to kind of change the entire thing here let's go s string let's go string plus equals s like that and then print s and print string and then return string and we might as well call this uh append string okay so let's change our example here let's go append underscore string hello or let's just go h oops and then append underscore string i okay so now if i run this code you're gonna see this works in the way that we think it should work so we get hello h and then hello i and that's because this is not a mutable object and that means we cannot modify this object in place so when i do string plus equals s what happens is a brand new string is created and assigned to the value string we print out that value string which is local to this function and then we return that new string object we don't modify what is being stored inside of this string parameter right here and so when we call the function again and string is equal to hello it's still equal to hello it's not been changed because of the fact that this created a brand new string and assigned it to the local variable string which is inside of this function it's a little bit confusing but just understand that you should not use a mutable default parameter for the reason that i just showed you you'll get all kinds of weird results and it's a very difficult thing to debug so moving on to the second bad practice we have not using a default dictionary now explain what that is in one second but first let's have a look at this code right here so we have this dictionary called counts we have a list of numbers we're looping through all of the numbers checking if the number that we're on is in our counts data structure in our dictionary if it's not then we create a new key with that value we set it equal to zero and then we append the value of that key what this is doing is just counting the frequency of all these numbers in the list pretty straight forward now this code is fine you can write this but technically this is considered a bad practice in python because there exists a data structure called a default dictionary which makes it so you do not need to do this check right here and that's kind of the more pythonic way or style of doing this so let me show that to you so to use the default dictionary you need to import it from a builtin module in python called collections so you need to say from collections and then instead of order dick you are going to import the default dictionary like that all right so from collections import default dictionary now to create a default dictionary what you need to do is use the default dict right here so you're going to say counts is equal to default dict and then you need to pass a callable object that returns what the default value for this dictionary should be so i'll kind of explain this in one second but let me just write this out so lambda and then 0 like that now if you're unfamiliar with the lambda this is completely equivalent to this so to find func return zero it's just kind of a shorthand way of doing this this is known as a one line anonymous function anyways what this is saying is if you try to access a key that does not exist in the dictionary it will automatically create one for you that has the value zero that's all it said so let me now show you how we can rewrite this here using the default dictionary so let me copy numbers here and let's say four key in numbers and now what i'm going to do is just say counts which that should be counts at key plus equals one and i'm going to print out counts like that so now if i run this code you're going to see everything works totally fine we don't get any errors this is just functioning properly and the reason for that is we're now using a default dictionary now you will notice that there is some minor differences between a regular dictionary and a default dictionary so you have to be a little bit careful when you're using a default dictionary because some of the methods might be a little bit different but the way you use it is practically the exact same but notice when i print out default dictionary it's giving me the default value and then it's giving me the dictionary it's not just giving me the dictionary so be careful in how you use it you will have to kind of look it up a little bit but it's not very complicated and it saves you you know some cleanliness and readability of your code if you do decide to use it now in the same way here there is another thing that you can use to avoid having to do this type of check when you're kind of trying to access a key or change a key value in dictionary let me just get rid of this example here and show you an example in which what i'm about to show you makes sense so let's say you have a dictionary let's just make it an empty dictionary called d and let's see if a key is in this dictionary so if list is not in d then what i want to do is go d list is equal to that and then i want to say d and sorry this should be at the key list dot append and i want to add maybe the value three into this list the list that's stored as the the value for the key list all right so the way that you can actually shorten these three lines of code right here into one single line is by doing the following without creating a default dictionary you can do this you can say d dot set default you can pass the key value you can pass what the default should be and then you can perform whatever operation you want to perform on this value so i can say dot append and then 3. now what set default does is it will set the default value for a key that you are trying to access if it doesn't exist and then return it but if the key does exist it will return its value so in this case what will happen is if the key list exists in the dictionary it will return the value of that key and then it would append three to it before it returns that story but if it doesn't exist it sets it equal to an empty list and then in this case it's appending three to that list so that is how you can avoid doing this kind of tedious check yours by using this set default method i know myself i didn't know this existed until probably a few months ago actually and it's not something that i used a lot in my python code but definitely saves a bit of time makes your code more readable and is a better practice doing something like this is kind of considered a bad python practice just because again it's not in that pythonic style if you have a method like this you might as well use it so now we're moving on to the next bad practice which is not using a context manager when opening files now in this case when i say context manager i'm referring to the with statement some of you may know what i'm talking about here but let me just show you an example of what the bad practice is and then how to fix it so if you want to work with a file specifically or really any resource that kind of needs cleaning up or closing when you're done working with it you really should use a context manager however not using a context manager would look something like this f equals open file.txt and then we're going to open it in write mode so let's say we want to open this new file called file.txt maybe we want to write some lines to it so f dot write i don't know let's write hello into it or something like that well what we need to do after we've opened this file and we've written lines into it is we need to make sure we close the file so we do something like f dot close now this is fine this code will work all right there won't be any issues here however we really need to make sure whenever we open a file that we close it so if you forget to write this close here that's going to lead to some problems for you i actually don't think this file will save or at least other programs won't be able to access this file this program that's currently running will be kind of the owner and have access to that file and there's just all kinds of issues that can occur if you forget to close a file after you open it so that's a really big deal so okay you might be saying all right i'll just remember to close the file well that's great if you do remember to close the file but another issue can happen if in between when you open the file and you close the file some type of error occurs or your program crashes or the user ends your program before you've closed the file so what you need to do when you're working with files is rather than doing it in this way and just praying that you're actually going to be able to close the file after is you need to use a context manager now a context manager is with and i'll explain kind of what that is but the way that this code would look in a context manager is the following open file.txt in right mode as f and then f dot write and then you would write hello and then you actually do not need to manually close the file when you open a file in this way so what this does right here is ensure that no matter what happens this file is going to be closed so when you open the file you open it as f you can then do all of your operations inside of this with statement and then as soon as this with statement is done it will automatically close the file and if an exception occurs it will close the file before the program terminates so that is why you use a context manager and really all the context manager is is something that enforces a cleanup operation after this with statement is done whether that be because the program crashed or because it just finished executing all of the statements so there are many other times in which using a context manager is very very important if you want to avoid a bunch of potential problems but really just think of using one whenever you have kind of a cleanup operation that needs to occur now the thing is you can't just use this context manager anywhere this cleanup operation needs to be implemented by something in this case when we use open like this it implements this cleanup operation so it knows okay once i'm done with this i'm going to close the file there's a lot of other things in python that have context managers built in but just wanted to show you here if you are working with files or any resource that needs to be cleaned up try to use a context manager or at least look and see if a context manager is available for the resource that you're trying to use so moving on to the next bad practice which is not using the enumerate function when it's applicable to use it now the enumerate function is something that allows you to get access to the item as well as the index of elements in a list so if we're looking at this example right here we have a list we want to loop through it and we want access to the index so maybe we want to print the index and then we want access to all of the different values all the elements in the list now the traditional way to do this in most programming languages is what you see right here we say 4i in range we go through whatever the length of the list is so loop through all of the indices we get access to the value of each of the items by indexing it in the list and then we print out whatever the index is and the value so let's have a look here we get you know let's scroll here come on zero one one two two three three four so on and so forth now this is fine you can do this it's not that bad but the best practice in python is to do the following for i comma val in enumerate lst print i comma val now you've eliminated this line right here and you've actually made it more readable and easier to find what variable is storing the value of the element and what variable is storing the index so let me just erase this for a second so as i said what enumerate will do is give you the index as well as the value the first item here the first variable here is going to be the index the second value here is going to be the actual value of the item so if i run this we get the exact same result as before and there you go use enumerate in a situation where it makes sense to use it now enumerate doesn't just work with lists it works with any iterable object so work with strings it will work with dictionaries it will work with sets i'll just show you an example with a dictionary so let's say we have hello comma 1 name comma 2 and let's enumerate through i guess let's just call it d now okay and let's run this and now notice we get 0 hello one name we can do the same with a set so one two three okay save and run same thing that works and then finally of course we can do this with a string so hello my name is tim let's run this and notice we get it working as we would expect so that's all for this bad practice just remember this enumerate function exists and you should use it if it makes sense to do so alright so the last bad practice i have for you is another quick one and this is simply to not override builtin names in python what i mean by that is do not name variables things that are python keywords for example do not create a variable called id or a variable called zip you might be tempted to do zip because like a zip code or something right do not name a variable list you do not want to do this the reason why is if you do this you disable or kind of remove the ability to use what these builtin python keywords actually are so if i name a variable id i can now no longer use the id function and the id function gives you the memory address of a python object so if i do idx now you're going to see that i get an error the into object is not callable whereas if i comment this out now i'm still able to use the function so if i wanted to print the id this works it works as a variable as i would expect but again i can no longer use what the actual builtin python function is so you shouldn't name stuff like this you know same goes with zip same goes with list now let's say you really want to name your variable id zip or list or any other builtin python keyword if you really want to do that first of all i'd recommend just don't do it but what you can do is add a trailing underscore this is the convention if you really need to name something a builtin keyword in python then you just put an underscore after you could put an underscore before when you put an underscore before this is the python convention for make this a private attribute or make this a private variable so unless that's what you're intending then you should actually do a trailing underscore so that's all for this last bad practice seems pretty intuitive and straightforward but i cannot tell you how many people do this and it's really frustrating because the syntax highlighting gets all messed up for it and then of course you deactivate the ability to actually use what this builtin keyword is so with that said i think i'm going to end the video here i hope this was helpful if it was make sure to leave a like subscribe to the channel and i will see you in another youtube video you
