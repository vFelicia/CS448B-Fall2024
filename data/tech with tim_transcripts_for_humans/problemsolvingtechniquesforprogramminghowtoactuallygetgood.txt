With timestamps:

00:00 - today I'll be sharing with you my tips
00:02 - tricks and advice for getting better at
00:04 - solving problems now in my opinion
00:06 - problem solving is one of the most
00:08 - important skills that you can have
00:09 - especially as a programmer and actually
00:12 - I'm not the only one that agrees with
00:13 - this the largest tech companies in the
00:15 - world evaluate you almost entirely based
00:18 - on your problem solving ability and
00:20 - that's why we have the famous coding
00:22 - interviews so in this video I'm going to
00:24 - walk you through the entire process of
00:26 - breaking down a problem solving it right
00:28 - from the beginning until the very end
00:30 - we're going to start by understanding
00:32 - the problem we're then going to develop
00:33 - an algorithm to solve it and then I'm
00:35 - going to code this out live in front of
00:37 - you so you can see exactly how an
00:39 - experienced programmer goes about
00:40 - solving these types of problems the
00:43 - specific problem we'll look at will be a
00:44 - medium level question from leak code
00:46 - these are the type of problems you'll
00:48 - probably get during a coding interview
00:50 - it will make a good example so you can
00:52 - understand how to solve something that's
00:53 - not super easy yet not extremely
00:56 - complicated however before we get into
00:58 - that I know that the reason a lot of you
01:00 - are watching this video is because you
01:01 - want to land a software development
01:03 - position now I won't lie to you in 2024
01:06 - it's a lot different to land a role than
01:08 - it was even just a few years ago and it
01:10 - can be really really competitive now
01:13 - that's actually why I teamed up with
01:14 - HubSpot and wrote an entirely free guide
01:17 - called how to land a developer role in
01:19 - the world of AI drawing on my over a
01:21 - decade of experience this summary covers
01:24 - the best programming languages to master
01:26 - and the most effective ways to learn
01:28 - them it also goes over best practi
01:29 - practices for your resume how to create
01:32 - your portfolio and recommendations for
01:34 - YouTube channels and other resources to
01:36 - enhance your development skills you can
01:38 - check it out for free from the link in
01:40 - the description personally my favorite
01:42 - part is the long list of resources
01:44 - including YouTube channels and websites
01:47 - that showcase fantastic free ways to
01:49 - improve your skills this content is
01:51 - focused on helping you distinguish
01:52 - yourself as a programmer in this AI era
01:55 - offering essential insights and
01:57 - strategies to help you remain
01:58 - competitive in the developer industry
02:01 - I'm thrilled to collaborate with HubSpot
02:02 - on this resource and to have them
02:04 - sponsor this video enabling me to
02:06 - provide all kinds of free content like
02:08 - this video to you so let's begin here by
02:11 - going to the computer and having a look
02:13 - at a problem that I've selected now this
02:15 - problem is called rotate list it's a
02:17 - medium problem on Le code and again most
02:20 - of the time you'll be given medium type
02:22 - problems this one is not extremely
02:24 - difficult but it's actually a really
02:25 - good fit for this video because it won't
02:27 - take us super long to solve but you'll
02:29 - get an idea of how we go through the
02:31 - process so the first thing we want to do
02:33 - if we're in a coding interview situation
02:35 - or really just trying to break down any
02:36 - problem is we want to make sure we have
02:38 - a thorough understanding of what the
02:40 - problem is in a lot of situations the
02:42 - problem will be read to you in that case
02:44 - feel free to ask for clarification sorry
02:47 - ask them to repeat themselves and just
02:49 - make sure you really understand it
02:50 - before we start solving in this case
02:52 - I'll kind of read it to you as we go
02:54 - from the prompt on the Le hand side of
02:55 - the screen so it says given the head of
02:57 - a linked list rotate the list to the
02:59 - right by K places and it shows us a
03:02 - visual example which is quite helpful
03:04 - you can see the original list 1 2 3 4 5
03:06 - and if we're rotating by two which is
03:08 - the example right here then you'll see
03:10 - that the rotation ends up with 4 5 1 2 3
03:14 - so this is pretty straightforward we're
03:16 - taking the K elements from the end of
03:18 - the list and then rotating them to the
03:20 - front of the list or whatever way you
03:21 - want to look at it as but that's kind of
03:23 - the way that I see it I see 1 2 3 4 5 I
03:25 - see the first rotation five goes to the
03:27 - front and I see in the second rotation
03:29 - four goes before five k equals 2 so
03:31 - we've taken those two back elements and
03:33 - kind of just placed them at the front
03:35 - going down we can see we have example
03:37 - number two now this one's a bit more
03:38 - complicated where we have k equal 4
03:41 - that's the amount of rotations in this
03:42 - case I notice immediately that four
03:44 - rotations is more than the length of the
03:46 - list which is three and you can see that
03:48 - when we end up rotating this we get kind
03:50 - of a different result where we need to
03:53 - rotate multiple times and we end up
03:54 - eventually hitting the original list you
03:56 - can see we have 0 one2 we do one
03:59 - rotation two rotation three rotations
04:01 - which brings us back to the original
04:02 - list and then we have two 01 so we also
04:05 - see that we have some constraints here
04:07 - we can read through those if we want but
04:09 - overall a pretty easy problem to
04:11 - understand but I would want to make sure
04:13 - again that I'm clarifying this with my
04:14 - interviewer so if I was in the interview
04:16 - situation I would be asking them okay is
04:19 - there a maximum length for the linked
04:20 - list could you be sending me a linked
04:22 - list that maybe has no elements inside
04:24 - of it or just has one element can K be a
04:26 - negative value or does it have to be a
04:28 - positive value I know these might seem
04:30 - like silly questions but a lot of times
04:33 - interviewers really want to see that
04:34 - you're trying to narrow the problem down
04:36 - as much as possible and really make sure
04:38 - you account for all of the possible edge
04:40 - cases or different considerations you
04:43 - might assume something I'd say never
04:45 - assume instead just ask the interviewer
04:47 - no question is really a bad question and
04:49 - usually you spend the first few minutes
04:51 - kind of talking back and forth about the
04:53 - problem and just showing them that you
04:54 - do really want to make sure you
04:56 - understand it before you start solving
04:58 - it so now that we have kind of a
05:00 - somewhat decent understanding of the
05:01 - problem what I'm going to do is actually
05:03 - go over to the Whiteboard this is what I
05:05 - would always do when I'm solving a
05:06 - problem and I'm going to start drawing a
05:08 - few things out and kind of visualizing
05:10 - my thought process one because it's
05:12 - helpful for me but two because it's
05:14 - helpful for anyone else that's watching
05:15 - this like an interviewer to understand
05:18 - how I'm actually about to solve the
05:20 - problem I always find it a lot easier to
05:21 - kind of draw things out diagram it even
05:23 - if it's a bit messy so let's go ahead
05:25 - and do that so I'm on my iPad now and
05:27 - I'm going to start walking you through
05:28 - exactly what I would do to solve this
05:30 - problem now I would always start by just
05:32 - writing out some kind of case or example
05:36 - on my whiteboard or on my drawing tablet
05:38 - just so that I can walk through it
05:40 - slowly and really make sure I understand
05:42 - this and also just do a few different
05:44 - cases that maybe haven't been given to
05:45 - me it's always a good idea to take some
05:47 - inputs and just figure out what the
05:49 - output should be and if you can do this
05:51 - kind of visually by writing it out then
05:53 - it's going to help you actually devise
05:54 - an algorithm to solve this so when I
05:57 - look at this I see that I have 1 2 3 4 5
05:59 - I have K = 3 we know this is very
06:01 - similar to the other input that we were
06:03 - given and we know this is going to be 3
06:05 - 4 5 1 and two now when I look at this a
06:09 - few things come to my head the first
06:11 - thing that I realize is that I kind of
06:13 - have the beginning first two elements
06:15 - here and I have the ending three
06:17 - elements here now what this tells me is
06:20 - that actually there's kind of two ways I
06:21 - can approach this problem I can take the
06:24 - first two elements and I can move them
06:26 - to the back or I can take the back three
06:29 - elements and I can move them to the
06:31 - front just because it says rotate right
06:34 - doesn't mean that I actually can't
06:35 - rotate to the left and just do kind of a
06:37 - different approach or not really rotate
06:39 - to the left but I doesn't really dictate
06:41 - the order in which I need to rotate the
06:43 - elements and it's perfectly valid if I
06:44 - were to take these to and put them at
06:46 - the end because that's going to give me
06:48 - the same result so just something that's
06:49 - coming into my head this is what I would
06:51 - be kind of talking about with the
06:52 - interviewer even if it doesn't really
06:54 - make sense yet I'm kind of walking
06:56 - through how I'm going to reach the
06:57 - solution and this thought process this
06:59 - is what people want to see they want to
07:02 - understand how you're actually solving
07:03 - the problem okay so that's kind of an
07:05 - interesting note that we had and now
07:06 - that I've done that and this is pretty
07:08 - easy I'm going to start looking for a
07:09 - few different edge cases or things that
07:11 - might mess up potential Solutions so for
07:13 - example I'm going to go with something
07:15 - like k equals 7 now the first thing I
07:17 - notice when I see k equals 7 is that 7
07:20 - is greater than the length of my link
07:22 - list in this case I just have five
07:24 - elements now that kind of intuitively
07:26 - tells me that if I do this many
07:28 - rotations a eventually I'm going to
07:30 - reach a linked list that's the exact
07:32 - same as the starting linked list so it
07:35 - really doesn't make sense for me to do
07:36 - any rotations that are greater than the
07:39 - length of my link list which means I can
07:41 - probably simplify this K value and get a
07:44 - value that gives me the true number of
07:46 - rotations that will reach the end result
07:48 - for example k equal 7 is actually the
07:51 - exact same thing as k equals 2 if I do
07:55 - seven rotations or two rotations I'm
07:57 - actually going to get the exact same
07:58 - result if I wanted to I could verify
08:01 - that by walking through all of the
08:02 - rotations but that's very obvious to me
08:04 - and I know from the example they gave me
08:06 - that that's going to happen so this
08:08 - tells me that the first thing I probably
08:09 - want to do is I want to simplify this K
08:12 - value down so rather than having seven I
08:15 - need to get the length of this length
08:17 - list which in this case is five we can
08:19 - see that easily or visually and I'm just
08:21 - going to take the length I'm going to
08:24 - take K and I'm going to perform a
08:25 - modulus I'm going to say k mod length is
08:28 - equal to the true K or the real number
08:32 - of rotations that I actually need to
08:33 - perform in this case 7 mod 5 is equal to
08:38 - two and really the true K value that I'm
08:40 - going to use here is two so that's the
08:43 - first part of the algorithm that I
08:44 - figured out is I'm going to take part of
08:46 - my input and I'm going to simplify it to
08:48 - make my life easier so at this point I
08:50 - would start kind of writing down what I
08:52 - know even though we haven't solve the
08:53 - problem yet we know kind of the first
08:55 - step so let's write that down okay so
08:57 - Step One is written down simplify K and
09:00 - this involves taking K and just modulus
09:03 - by the length now actually when I write
09:05 - this I realize that in order for me to
09:07 - do this I need to know the length of the
09:09 - linked list and even though I can see it
09:11 - visually when I just write one out when
09:13 - we're given the linked list in our
09:15 - problem we're just given the head node
09:18 - we don't actually know what the length
09:19 - is so really the first step actually is
09:21 - to figure out what the length of the
09:23 - length list is so that we can simplify K
09:26 - so now that means I need to change this
09:27 - a little bit and rather than step one
09:29 - being to simplify K that's actually
09:31 - going to be step two step one will be to
09:33 - find the length of the linked list so we
09:35 - can do the simplification so now I've
09:37 - written my revised steps I'm going to
09:39 - start by finding the length I'm going to
09:40 - simplify the K value and then
09:42 - intuitively well I need to rotate the
09:44 - list now we don't know what's involved
09:45 - in doing that yet but we do know that
09:47 - will be step three and we're starting to
09:49 - work our way towards an algorithm so you
09:51 - can see how we're kind of breaking the
09:52 - problem down slowly solving small
09:54 - components of it and it makes it easier
09:56 - for our brain to kind of handle piece by
09:58 - piece we look at an observation we solve
10:00 - a small part we figure out one step of
10:02 - the algorithm we don't need to solve the
10:04 - entire thing at once in fact it's very
10:06 - difficult to do that you want to try to
10:07 - do it piece by piece so now we're at the
10:09 - rotation step so let's say we have our
10:12 - true K value right and we have maybe a
10:14 - simple length list like 1 2 3 for
10:17 - example purposes let's say our true K
10:19 - value is two meaning it could have been
10:21 - something larger but we simplified it
10:23 - down now what we need to do is actually
10:25 - perform the rotation now we want to
10:27 - start by kind of assumptions or facts
10:28 - that we no now with the linked list we
10:31 - know that this is singular what that
10:33 - means is that when I'm on some node here
10:35 - I don't have access to the parent node I
10:37 - only have access to the next node so I
10:41 - need to be careful in terms of how I'm
10:42 - storing these nodes and actually if I'm
10:45 - doing a rotation where I'm moving an
10:46 - element from the back to the front or
10:48 - from the front to the back what that is
10:50 - going to involve is me knowing both the
10:53 - tail and the head node so I know right
10:56 - away when I start solving this that I
10:58 - need to have reference to the head which
11:00 - is right here and to the tail which is
11:03 - right here I also know that as I perform
11:05 - these rotations The Head and the tail
11:07 - node is going to change because as I
11:09 - move elements to the front or to the
11:11 - back well we're going to have a new head
11:13 - and intuitively a new tail so we
11:15 - probably want to create some variables
11:17 - where we're storing the head and we're
11:19 - storing the tail so let me just kind of
11:21 - write some variables here I don't know
11:23 - if this is going to work but I'm going
11:24 - to start walking through this and see if
11:25 - I can come to a solution so I'm going to
11:28 - say head
11:29 - is equal to 1 and I'm going to say tail
11:33 - is equal to node 3 okay so I'm just kind
11:35 - of marking them down here so that we
11:37 - have them tracked now let's say I just
11:39 - want to rotate one element that's
11:41 - probably what we want to start by doing
11:43 - rather than rotating two let's figure
11:44 - out how we just rotate a single element
11:46 - and then we could just repeat that
11:48 - process as many times as we need to so
11:50 - if I want to rotate three to the front
11:53 - again we need a reference to the head
11:54 - and we need a reference to the tail so
11:57 - how do I do this well I need to two take
12:00 - three I need to move this to the front
12:03 - and to do that the first thing I can do
12:04 - is I can set the next pointer on three
12:07 - to go to one okay so that's good we can
12:10 - kind of say tail. next is going to be
12:12 - equal to the head and then I need to
12:15 - take maybe the next node so this pointer
12:18 - here and I need to remove this if I do
12:20 - that now three has really come to the
12:23 - front three is pointing to one and one
12:25 - is pointing to two the issue that I'm
12:27 - having immediately though is that if I
12:28 - just have a reference to the tail and I
12:31 - just have a reference to the head I
12:33 - don't actually have access to this Noe
12:36 - so how am I going to adjust the pointer
12:38 - behind to be equal to this next note so
12:41 - that tells me that this approach
12:43 - probably isn't going to work and I need
12:45 - to go with some other approach and find
12:47 - a better solution again to some of you
12:49 - what I just did may not have made sense
12:51 - that's fine it's me walking through and
12:53 - trying to understand how I can approach
12:55 - this and going through different Avenues
12:57 - until I find the correct approach I
12:59 - realize now that in order for me to do
13:01 - the rotation I need to have access to
13:02 - the previous node so there may be a
13:04 - different way that I need to go about
13:06 - doing this so what we can say here is
13:09 - that rather than maybe taking the back
13:10 - nodes and moving them to the front we
13:13 - could maybe take the front nodes and
13:15 - move them to the back now this solves
13:17 - our problem because if I have a front
13:19 - Noe and I move this to be behind three
13:21 - for example well I have access to the
13:24 - next node from the front node and from
13:26 - three I have access to its next pointer
13:29 - so I'm able to actually manipulate the
13:31 - two pointers I need to now what this is
13:33 - telling me is that rather than rotating
13:36 - the back elements I'm going to rotate
13:38 - the front elements but when I rotate the
13:40 - front elements my solution is going to
13:42 - look a little bit different so just look
13:44 - right when we have k equals 2 the
13:46 - official solution should be 3 2 and 1
13:50 - okay so we have 1 2 3 goes to 3 2 1 so
13:54 - if we were going to rotate the back
13:55 - elements to the front then yes K is
13:58 - equal to two we need to do two rotations
14:01 - but if we instead decide that we're
14:03 - going to take the front element and
14:05 - we're just going to remove move the
14:06 - front elements to the back the required
14:09 - amount actually K can just be equal to
14:13 - one because I just need to take one
14:15 - front element and move it to the back I
14:18 - know it seems a bit weird let me walk
14:19 - you through another example so I have an
14:21 - example on my screen and we'll start
14:23 - going through it now we started with K =
14:25 - 1 but we actually convert that to K = 3
14:28 - because we know we're actually going to
14:29 - shift elements from the front to the
14:31 - back so let's look at how we do a
14:33 - rotation one time now in order to rotate
14:36 - one to the back we simply take whatever
14:39 - the tail is and we point its next node
14:41 - to one so now we have what's known as a
14:44 - circular length list where the tail Noe
14:46 - is pointed to the Head node now if we're
14:48 - only rotating one time we could just
14:50 - remove this pointer and now we have a
14:52 - rotated list and we would have 2 3 4 and
14:55 - then one however that's not actually
14:58 - what we want we need to to do this three
15:00 - times so really we want to have four 1 2
15:03 - 3 so how do we know how to do that well
15:06 - once I do this and I go four equal to 1
15:09 - The Next Step would be just to repeat
15:11 - this process but now we need to adjust
15:13 - our head and our tail notes so really
15:16 - we're saying okay tail. next is equal to
15:21 - the head that's the first thing we do
15:22 - when we want to rotate something but now
15:24 - that we've done that our head and our
15:25 - tail nodes have kind of changed right
15:28 - now our new tail node is actually equal
15:31 - to one and our new head node is actually
15:34 - equal to two right this would be the
15:36 - head now we're going to leave this
15:37 - pointer because we actually don't need
15:39 - to remove it but we know that this now
15:41 - is the new head and this now is the new
15:43 - tail so now we can just really repeat
15:45 - this process and we can keep doing this
15:48 - three times okay so if we repeat the
15:50 - process we say the tail do next is equal
15:54 - to the Head well we already have that
15:56 - connection okay so that's made and then
15:58 - we just need to update The Head and the
15:59 - tail okay so let's go ahead and do that
16:02 - so we can say now the new tail would be
16:04 - two and the new head would be three we
16:07 - can do the same thing again okay so this
16:09 - now is our tail this is our head so
16:11 - we're going to say the tail dox is equal
16:13 - to the Head okay so again that that's
16:15 - already done we don't really need to do
16:16 - that and then we can adjust the head and
16:19 - the tail okay so as we adjust the head
16:21 - and the tail we now have the head is
16:22 - equal to 4 and the tail is equal to 3
16:26 - okay now we're done the rotation cuz we
16:28 - we've done this three times right head
16:30 - is four which is what we want tail is
16:32 - three which is what we want all we need
16:34 - to do now is we need to remove this link
16:37 - between the head and the tail so I can
16:39 - remove this link now we have four 1 2 3
16:43 - so the reason I just showed you that is
16:44 - that actually all we need to do to solve
16:47 - this problem and it seems stupidly easy
16:49 - is we just need to take whatever the
16:50 - tail Noe is we need to connect that to
16:53 - the Head node and then we just need to
16:55 - go and find whatever the kith node is in
16:59 - our linked list and just disconnect its
17:01 - next pointer that's actually the entire
17:04 - thing we need to do so again we begin we
17:06 - take whatever the current tail is we
17:08 - connect this next to the head all these
17:11 - links will remain and then we just go
17:13 - and find whatever the K node is and just
17:16 - disconnect this next pointer and point
17:18 - it to null so when K is three third node
17:21 - gets disconnected when K is 2 second
17:24 - node gets disconnected when K is one
17:27 - first node gets disconnected that's all
17:30 - we need that solves our problem okay so
17:33 - in my horrible handwriting I just wrote
17:35 - this out we find the length we simplify
17:37 - the K value we perform the rotation the
17:40 - rotation involves taking the tail. next
17:42 - simply pointing that to the Head value
17:44 - and then we disconnect the kith node and
17:46 - we're done that's actually all we need
17:48 - to do there's a few other small steps in
17:50 - between for example to find the length
17:52 - we need to know how to iterate through a
17:53 - linked list we're going to assume we
17:54 - know how to do that to simplify K
17:56 - there's a little bit of math again we
17:58 - can write that in in the code to do the
17:59 - rotation we need to find the tail node
18:01 - and find the head node pretty easy to do
18:04 - we should be able to do that without
18:05 - having to write out a complicated
18:06 - algorithm and then disconnecting the
18:08 - kith node well that just involves going
18:10 - through again and finding the kith node
18:12 - so we're just iterating through the
18:13 - length list 1 2 three four oh four okay
18:16 - disconnect that's it that's all we need
18:18 - to do so now what I want to do is go
18:20 - over to the computer and show you how it
18:22 - would code this out and again as I code
18:24 - it out I'll explain how I'm kind of
18:26 - coming up with that solution step by
18:28 - step but really this is the easy part
18:30 - now because we know what to do we've
18:32 - written it out we've diagrammed it we've
18:34 - visualized it we have a good in-depth
18:36 - understanding of not only the problem
18:37 - but the solution we're going to
18:38 - implement and now we just need to go to
18:40 - the code and write some kind of
18:42 - translation of this algorithm so I'm
18:44 - back on the computer now and we're going
18:45 - to start coding this out now step one
18:48 - was to find the length so let's find the
18:50 - length of this link list now to find the
18:52 - length we can do the following we can
18:54 - say length is equal to zero we can then
18:57 - Define a current node which will be
18:59 - equal to the head and we're going to say
19:01 - while the current. next is not none then
19:07 - what we're going to do is say length
19:08 - plus plus or plus equals 1 because I'm
19:11 - writing this in Python 3 and then we're
19:13 - going to say the current is equal to the
19:16 - current. next I'm not really going to
19:18 - explain this this is a very simple
19:19 - traversal of a linked list which most of
19:21 - you should know if you're going into
19:23 - these type of coding interviews now
19:25 - right away when I look at this I realize
19:27 - there's a potential for an error in my
19:29 - code the error is right here current as
19:32 - we see could potentially be none it may
19:35 - not be one of the list nodes to find
19:37 - here so before I can do this I just need
19:39 - to make sure that the head node is not
19:42 - none so I'm going to say if head is none
19:47 - then I'll just return that head because
19:49 - if there's no nodes in the linked list
19:51 - it doesn't matter what K is there's no
19:53 - rotation that we can perform okay so now
19:56 - we should have the length equals zero
19:58 - current equals head well the current
20:00 - next is not none length plus equals 1
20:03 - current equals current. next now what
20:06 - this actually does for us is at the end
20:08 - of this iteration we have access to the
20:10 - tail note the reason for that is when
20:13 - current. next is equal to none that
20:15 - means that we have the tail because
20:17 - there's no more pointers there's no more
20:19 - nodes in the list so not only has this
20:21 - found the length but it's also actually
20:23 - located the tail node for us which is
20:25 - important because we need that for the
20:26 - next step so once we find the length the
20:29 - next step is to simplify the K value so
20:32 - we're going to say our true K is equal
20:35 - to and we're going to perform our
20:36 - simplification now the first
20:38 - simplification is to take K and to
20:40 - modulus this by the length of our link
20:43 - list however remember that actually what
20:46 - we want to do is we want to kind of flip
20:48 - K around and we want to do that by
20:50 - taking the length and subtracting that
20:53 - from K so if we have a length of five
20:56 - and K is equal to 1 then we actually
20:58 - want to take the four elements from the
21:00 - front and move that to the back as
21:02 - opposed to taking the one element from
21:03 - the back and moving it to the front
21:05 - again it's effectively the same thing
21:06 - but the way that we are going to solve
21:08 - this problem is important so what we're
21:09 - going to do is we're going to put these
21:10 - in parenthesis and we're going to take
21:13 - the length and we're going to subtract
21:15 - that from K mod length that's going to
21:17 - give us the true K value or the number
21:19 - of rotations that we're going from the
21:21 - front to the back because we've flipped
21:23 - the order now that we have the true K
21:25 - value it's time to perform the rotation
21:27 - so remember that the first step is to
21:29 - Simply take the tail node and connect it
21:32 - to the head node however before I do
21:34 - that I'm kind of realizing that if we
21:36 - have a node or we have a linked list so
21:38 - we have length one this could
21:39 - potentially be problematic because we
21:41 - could be connecting the head node to
21:43 - itself and creating this kind of
21:44 - circular infinite list which we
21:47 - obviously don't want so what I'm going
21:48 - to do is just do a quick Edge case check
21:50 - here something you should always be
21:52 - considering when you're solving these
21:53 - problems and I'm going to say hey if the
21:55 - length is one it doesn't matter what K
21:57 - is again don't need to do any rotation
21:59 - so let's just return whatever the head
22:01 - is of this length list so I'm going to
22:03 - say if
22:05 - length is equal to one then just return
22:08 - the head just to make sure I'm not going
22:10 - to run into an issue here uh with a
22:12 - potential Edge case of length one so I'm
22:14 - kind of handle the edge case length zero
22:16 - length one these are typically the ones
22:18 - you want to consider where you have
22:19 - nothing or you just have one element so
22:21 - now that's handled now we can go and do
22:23 - the real rotations so remember we're
22:24 - connecting the tail to the head so we're
22:26 - just going to say the tail Dot next is
22:29 - going to be equal to the head but
22:32 - actually that reminds me we don't
22:34 - actually have the tail stored in a ver
22:36 - in a variable so what I'm going to do is
22:39 - instead I'm going to say current because
22:41 - this really is the head node next is
22:45 - equal to the head which was passed in
22:48 - okay now we're just going to go and
22:50 - iterate through the link list starting
22:52 - at the head and we're just going to
22:53 - remove the nth elements next pointer
22:57 - okay so to do that we're just going to
22:58 - say four and we can say actually we're
23:01 - going to use a w loop we're going to say
23:03 - current is equal to the Head we're going
23:06 - to say w and we need some kind of count
23:08 - here so maybe we're going to go with the
23:10 - for loop we're going to say 4 I in range
23:14 - and this is going to be let's go with
23:16 - the truecore
23:19 - K and we're going to say current is
23:22 - equal to current. next okay so now
23:25 - what's going to happen is we're going to
23:26 - go and we're going to find that k
23:28 - element and then we're just going to
23:30 - remove that pointer so I'm just going to
23:31 - say current. next is equal to none so I
23:34 - remove that kind of circular aspect I'm
23:36 - just getting rid of that one pointer
23:38 - that we don't need so before I run this
23:40 - code or before I would like submit this
23:42 - to my interviewer I just walk through it
23:44 - and make sure I don't have any mistakes
23:45 - totally fine if you do have a few
23:47 - mistakes by the way and that's normal
23:48 - especially if you're coding this out on
23:50 - a whiteboard but you do want to just do
23:51 - kind of a quick check just see if this
23:53 - makes sense so if the head is none okay
23:55 - so if that's none we're returning the
23:57 - head makes sense Define the length
23:59 - Define current okay we're going to say
24:01 - while current is not none length plus
24:03 - equals one current equals current. next
24:05 - okay itating through the length list if
24:07 - the length is one return the head makes
24:09 - sense true K value is equal to length
24:11 - minus K mod length Okay current next
24:14 - equals head so we're connecting that
24:15 - tail node which we have to the Head okay
24:17 - I think that makes sense current is
24:19 - equal to the head because we're now
24:21 - going to ITR through again for I in
24:23 - range true K because we need to find the
24:25 - K element good current equals current
24:28 - next so just iterating and then current.
24:29 - next equals none and then lastly return
24:33 - uh actually the new head note so this is
24:35 - the one thing that we're going to need
24:36 - to kind of have here is we need to know
24:39 - what the new head note is which I kind
24:40 - of missed so let's kind of go back in
24:42 - here and figure out how we would get
24:44 - that so if we're saying here that
24:45 - current. next is equal to none we're
24:47 - trying to disconnect the tail from the
24:50 - head which means current. next is the
24:53 - head so what we can do is say head is
24:56 - equal to current. next before we
24:58 - disconnect it and then when we
25:00 - disconnect it we still have access to
25:02 - the head and then we should be good so
25:04 - let's go for a sanity check here and
25:05 - let's run this uh and just see where is
25:09 - the Run button okay run up here okay so
25:13 - I just ran this code here and I realize
25:15 - that we have a small mistake that we
25:17 - need to fix so the first mistake here is
25:19 - with the length it says zero when
25:21 - actually we need to start the length
25:22 - that one the reason for this is that
25:25 - we're already accounting for the head in
25:27 - the fact that we say while current. next
25:29 - is not none because we're assuming that
25:31 - we have at least one node so we should
25:33 - start with the length equal to one now
25:35 - we also have a mistake here in this for
25:37 - Loop where I say 4 I and range true K I
25:40 - need to actually subtract one from True
25:42 - K and the reason for that is we've
25:44 - actually handled one of the rotations
25:46 - already by saying current. next is equal
25:48 - to the head so when I do this I'm
25:50 - rotating one too many times because I've
25:53 - already done one of the rotations with
25:54 - this manual line that we've written so
25:57 - that's kind of the change that we need
25:59 - to do here um that should hopefully fix
26:01 - this for us now there's maybe a more
26:03 - elegant way to write this solution keep
26:05 - in mind I'm doing this live in front of
26:06 - you I haven't seen this problem before
26:08 - so this is what happens right when when
26:09 - you're solving coding problems anyways
26:11 - let's run this now and hopefully this
26:13 - will work and there you go now we have
26:15 - case one and case two accepted now that
26:17 - doesn't mean that the solution is
26:19 - perfect yet what we can do now is we can
26:22 - submit this and uh let's see what our
26:24 - results are and if this actually passes
26:26 - all of the leak Code test cases okay so
26:28 - there we go we actually submitted this
26:30 - it was accepted it passed all of the
26:32 - different test cases and you can see
26:33 - that our runtime beat 76% of people I
26:37 - don't know if that's good or not uh we
26:39 - probably could have done better and
26:40 - improved the space and time complexity
26:42 - here just a little bit but overall I
26:44 - think this is a decent solution and
26:46 - hopefully kind of fulfilled the purpose
26:47 - of this video so there you go guys I'm
26:49 - going to wrap up the video here I hope
26:51 - you enjoyed and found this helpful if
26:53 - you did make sure you leave a like
26:54 - subscribe to the channel and I will see
26:56 - you in the next one
26:59 - [Music]

Cleaned transcript:

today I'll be sharing with you my tips tricks and advice for getting better at solving problems now in my opinion problem solving is one of the most important skills that you can have especially as a programmer and actually I'm not the only one that agrees with this the largest tech companies in the world evaluate you almost entirely based on your problem solving ability and that's why we have the famous coding interviews so in this video I'm going to walk you through the entire process of breaking down a problem solving it right from the beginning until the very end we're going to start by understanding the problem we're then going to develop an algorithm to solve it and then I'm going to code this out live in front of you so you can see exactly how an experienced programmer goes about solving these types of problems the specific problem we'll look at will be a medium level question from leak code these are the type of problems you'll probably get during a coding interview it will make a good example so you can understand how to solve something that's not super easy yet not extremely complicated however before we get into that I know that the reason a lot of you are watching this video is because you want to land a software development position now I won't lie to you in 2024 it's a lot different to land a role than it was even just a few years ago and it can be really really competitive now that's actually why I teamed up with HubSpot and wrote an entirely free guide called how to land a developer role in the world of AI drawing on my over a decade of experience this summary covers the best programming languages to master and the most effective ways to learn them it also goes over best practi practices for your resume how to create your portfolio and recommendations for YouTube channels and other resources to enhance your development skills you can check it out for free from the link in the description personally my favorite part is the long list of resources including YouTube channels and websites that showcase fantastic free ways to improve your skills this content is focused on helping you distinguish yourself as a programmer in this AI era offering essential insights and strategies to help you remain competitive in the developer industry I'm thrilled to collaborate with HubSpot on this resource and to have them sponsor this video enabling me to provide all kinds of free content like this video to you so let's begin here by going to the computer and having a look at a problem that I've selected now this problem is called rotate list it's a medium problem on Le code and again most of the time you'll be given medium type problems this one is not extremely difficult but it's actually a really good fit for this video because it won't take us super long to solve but you'll get an idea of how we go through the process so the first thing we want to do if we're in a coding interview situation or really just trying to break down any problem is we want to make sure we have a thorough understanding of what the problem is in a lot of situations the problem will be read to you in that case feel free to ask for clarification sorry ask them to repeat themselves and just make sure you really understand it before we start solving in this case I'll kind of read it to you as we go from the prompt on the Le hand side of the screen so it says given the head of a linked list rotate the list to the right by K places and it shows us a visual example which is quite helpful you can see the original list 1 2 3 4 5 and if we're rotating by two which is the example right here then you'll see that the rotation ends up with 4 5 1 2 3 so this is pretty straightforward we're taking the K elements from the end of the list and then rotating them to the front of the list or whatever way you want to look at it as but that's kind of the way that I see it I see 1 2 3 4 5 I see the first rotation five goes to the front and I see in the second rotation four goes before five k equals 2 so we've taken those two back elements and kind of just placed them at the front going down we can see we have example number two now this one's a bit more complicated where we have k equal 4 that's the amount of rotations in this case I notice immediately that four rotations is more than the length of the list which is three and you can see that when we end up rotating this we get kind of a different result where we need to rotate multiple times and we end up eventually hitting the original list you can see we have 0 one2 we do one rotation two rotation three rotations which brings us back to the original list and then we have two 01 so we also see that we have some constraints here we can read through those if we want but overall a pretty easy problem to understand but I would want to make sure again that I'm clarifying this with my interviewer so if I was in the interview situation I would be asking them okay is there a maximum length for the linked list could you be sending me a linked list that maybe has no elements inside of it or just has one element can K be a negative value or does it have to be a positive value I know these might seem like silly questions but a lot of times interviewers really want to see that you're trying to narrow the problem down as much as possible and really make sure you account for all of the possible edge cases or different considerations you might assume something I'd say never assume instead just ask the interviewer no question is really a bad question and usually you spend the first few minutes kind of talking back and forth about the problem and just showing them that you do really want to make sure you understand it before you start solving it so now that we have kind of a somewhat decent understanding of the problem what I'm going to do is actually go over to the Whiteboard this is what I would always do when I'm solving a problem and I'm going to start drawing a few things out and kind of visualizing my thought process one because it's helpful for me but two because it's helpful for anyone else that's watching this like an interviewer to understand how I'm actually about to solve the problem I always find it a lot easier to kind of draw things out diagram it even if it's a bit messy so let's go ahead and do that so I'm on my iPad now and I'm going to start walking you through exactly what I would do to solve this problem now I would always start by just writing out some kind of case or example on my whiteboard or on my drawing tablet just so that I can walk through it slowly and really make sure I understand this and also just do a few different cases that maybe haven't been given to me it's always a good idea to take some inputs and just figure out what the output should be and if you can do this kind of visually by writing it out then it's going to help you actually devise an algorithm to solve this so when I look at this I see that I have 1 2 3 4 5 I have K = 3 we know this is very similar to the other input that we were given and we know this is going to be 3 4 5 1 and two now when I look at this a few things come to my head the first thing that I realize is that I kind of have the beginning first two elements here and I have the ending three elements here now what this tells me is that actually there's kind of two ways I can approach this problem I can take the first two elements and I can move them to the back or I can take the back three elements and I can move them to the front just because it says rotate right doesn't mean that I actually can't rotate to the left and just do kind of a different approach or not really rotate to the left but I doesn't really dictate the order in which I need to rotate the elements and it's perfectly valid if I were to take these to and put them at the end because that's going to give me the same result so just something that's coming into my head this is what I would be kind of talking about with the interviewer even if it doesn't really make sense yet I'm kind of walking through how I'm going to reach the solution and this thought process this is what people want to see they want to understand how you're actually solving the problem okay so that's kind of an interesting note that we had and now that I've done that and this is pretty easy I'm going to start looking for a few different edge cases or things that might mess up potential Solutions so for example I'm going to go with something like k equals 7 now the first thing I notice when I see k equals 7 is that 7 is greater than the length of my link list in this case I just have five elements now that kind of intuitively tells me that if I do this many rotations a eventually I'm going to reach a linked list that's the exact same as the starting linked list so it really doesn't make sense for me to do any rotations that are greater than the length of my link list which means I can probably simplify this K value and get a value that gives me the true number of rotations that will reach the end result for example k equal 7 is actually the exact same thing as k equals 2 if I do seven rotations or two rotations I'm actually going to get the exact same result if I wanted to I could verify that by walking through all of the rotations but that's very obvious to me and I know from the example they gave me that that's going to happen so this tells me that the first thing I probably want to do is I want to simplify this K value down so rather than having seven I need to get the length of this length list which in this case is five we can see that easily or visually and I'm just going to take the length I'm going to take K and I'm going to perform a modulus I'm going to say k mod length is equal to the true K or the real number of rotations that I actually need to perform in this case 7 mod 5 is equal to two and really the true K value that I'm going to use here is two so that's the first part of the algorithm that I figured out is I'm going to take part of my input and I'm going to simplify it to make my life easier so at this point I would start kind of writing down what I know even though we haven't solve the problem yet we know kind of the first step so let's write that down okay so Step One is written down simplify K and this involves taking K and just modulus by the length now actually when I write this I realize that in order for me to do this I need to know the length of the linked list and even though I can see it visually when I just write one out when we're given the linked list in our problem we're just given the head node we don't actually know what the length is so really the first step actually is to figure out what the length of the length list is so that we can simplify K so now that means I need to change this a little bit and rather than step one being to simplify K that's actually going to be step two step one will be to find the length of the linked list so we can do the simplification so now I've written my revised steps I'm going to start by finding the length I'm going to simplify the K value and then intuitively well I need to rotate the list now we don't know what's involved in doing that yet but we do know that will be step three and we're starting to work our way towards an algorithm so you can see how we're kind of breaking the problem down slowly solving small components of it and it makes it easier for our brain to kind of handle piece by piece we look at an observation we solve a small part we figure out one step of the algorithm we don't need to solve the entire thing at once in fact it's very difficult to do that you want to try to do it piece by piece so now we're at the rotation step so let's say we have our true K value right and we have maybe a simple length list like 1 2 3 for example purposes let's say our true K value is two meaning it could have been something larger but we simplified it down now what we need to do is actually perform the rotation now we want to start by kind of assumptions or facts that we no now with the linked list we know that this is singular what that means is that when I'm on some node here I don't have access to the parent node I only have access to the next node so I need to be careful in terms of how I'm storing these nodes and actually if I'm doing a rotation where I'm moving an element from the back to the front or from the front to the back what that is going to involve is me knowing both the tail and the head node so I know right away when I start solving this that I need to have reference to the head which is right here and to the tail which is right here I also know that as I perform these rotations The Head and the tail node is going to change because as I move elements to the front or to the back well we're going to have a new head and intuitively a new tail so we probably want to create some variables where we're storing the head and we're storing the tail so let me just kind of write some variables here I don't know if this is going to work but I'm going to start walking through this and see if I can come to a solution so I'm going to say head is equal to 1 and I'm going to say tail is equal to node 3 okay so I'm just kind of marking them down here so that we have them tracked now let's say I just want to rotate one element that's probably what we want to start by doing rather than rotating two let's figure out how we just rotate a single element and then we could just repeat that process as many times as we need to so if I want to rotate three to the front again we need a reference to the head and we need a reference to the tail so how do I do this well I need to two take three I need to move this to the front and to do that the first thing I can do is I can set the next pointer on three to go to one okay so that's good we can kind of say tail. next is going to be equal to the head and then I need to take maybe the next node so this pointer here and I need to remove this if I do that now three has really come to the front three is pointing to one and one is pointing to two the issue that I'm having immediately though is that if I just have a reference to the tail and I just have a reference to the head I don't actually have access to this Noe so how am I going to adjust the pointer behind to be equal to this next note so that tells me that this approach probably isn't going to work and I need to go with some other approach and find a better solution again to some of you what I just did may not have made sense that's fine it's me walking through and trying to understand how I can approach this and going through different Avenues until I find the correct approach I realize now that in order for me to do the rotation I need to have access to the previous node so there may be a different way that I need to go about doing this so what we can say here is that rather than maybe taking the back nodes and moving them to the front we could maybe take the front nodes and move them to the back now this solves our problem because if I have a front Noe and I move this to be behind three for example well I have access to the next node from the front node and from three I have access to its next pointer so I'm able to actually manipulate the two pointers I need to now what this is telling me is that rather than rotating the back elements I'm going to rotate the front elements but when I rotate the front elements my solution is going to look a little bit different so just look right when we have k equals 2 the official solution should be 3 2 and 1 okay so we have 1 2 3 goes to 3 2 1 so if we were going to rotate the back elements to the front then yes K is equal to two we need to do two rotations but if we instead decide that we're going to take the front element and we're just going to remove move the front elements to the back the required amount actually K can just be equal to one because I just need to take one front element and move it to the back I know it seems a bit weird let me walk you through another example so I have an example on my screen and we'll start going through it now we started with K = 1 but we actually convert that to K = 3 because we know we're actually going to shift elements from the front to the back so let's look at how we do a rotation one time now in order to rotate one to the back we simply take whatever the tail is and we point its next node to one so now we have what's known as a circular length list where the tail Noe is pointed to the Head node now if we're only rotating one time we could just remove this pointer and now we have a rotated list and we would have 2 3 4 and then one however that's not actually what we want we need to to do this three times so really we want to have four 1 2 3 so how do we know how to do that well once I do this and I go four equal to 1 The Next Step would be just to repeat this process but now we need to adjust our head and our tail notes so really we're saying okay tail. next is equal to the head that's the first thing we do when we want to rotate something but now that we've done that our head and our tail nodes have kind of changed right now our new tail node is actually equal to one and our new head node is actually equal to two right this would be the head now we're going to leave this pointer because we actually don't need to remove it but we know that this now is the new head and this now is the new tail so now we can just really repeat this process and we can keep doing this three times okay so if we repeat the process we say the tail do next is equal to the Head well we already have that connection okay so that's made and then we just need to update The Head and the tail okay so let's go ahead and do that so we can say now the new tail would be two and the new head would be three we can do the same thing again okay so this now is our tail this is our head so we're going to say the tail dox is equal to the Head okay so again that that's already done we don't really need to do that and then we can adjust the head and the tail okay so as we adjust the head and the tail we now have the head is equal to 4 and the tail is equal to 3 okay now we're done the rotation cuz we we've done this three times right head is four which is what we want tail is three which is what we want all we need to do now is we need to remove this link between the head and the tail so I can remove this link now we have four 1 2 3 so the reason I just showed you that is that actually all we need to do to solve this problem and it seems stupidly easy is we just need to take whatever the tail Noe is we need to connect that to the Head node and then we just need to go and find whatever the kith node is in our linked list and just disconnect its next pointer that's actually the entire thing we need to do so again we begin we take whatever the current tail is we connect this next to the head all these links will remain and then we just go and find whatever the K node is and just disconnect this next pointer and point it to null so when K is three third node gets disconnected when K is 2 second node gets disconnected when K is one first node gets disconnected that's all we need that solves our problem okay so in my horrible handwriting I just wrote this out we find the length we simplify the K value we perform the rotation the rotation involves taking the tail. next simply pointing that to the Head value and then we disconnect the kith node and we're done that's actually all we need to do there's a few other small steps in between for example to find the length we need to know how to iterate through a linked list we're going to assume we know how to do that to simplify K there's a little bit of math again we can write that in in the code to do the rotation we need to find the tail node and find the head node pretty easy to do we should be able to do that without having to write out a complicated algorithm and then disconnecting the kith node well that just involves going through again and finding the kith node so we're just iterating through the length list 1 2 three four oh four okay disconnect that's it that's all we need to do so now what I want to do is go over to the computer and show you how it would code this out and again as I code it out I'll explain how I'm kind of coming up with that solution step by step but really this is the easy part now because we know what to do we've written it out we've diagrammed it we've visualized it we have a good indepth understanding of not only the problem but the solution we're going to implement and now we just need to go to the code and write some kind of translation of this algorithm so I'm back on the computer now and we're going to start coding this out now step one was to find the length so let's find the length of this link list now to find the length we can do the following we can say length is equal to zero we can then Define a current node which will be equal to the head and we're going to say while the current. next is not none then what we're going to do is say length plus plus or plus equals 1 because I'm writing this in Python 3 and then we're going to say the current is equal to the current. next I'm not really going to explain this this is a very simple traversal of a linked list which most of you should know if you're going into these type of coding interviews now right away when I look at this I realize there's a potential for an error in my code the error is right here current as we see could potentially be none it may not be one of the list nodes to find here so before I can do this I just need to make sure that the head node is not none so I'm going to say if head is none then I'll just return that head because if there's no nodes in the linked list it doesn't matter what K is there's no rotation that we can perform okay so now we should have the length equals zero current equals head well the current next is not none length plus equals 1 current equals current. next now what this actually does for us is at the end of this iteration we have access to the tail note the reason for that is when current. next is equal to none that means that we have the tail because there's no more pointers there's no more nodes in the list so not only has this found the length but it's also actually located the tail node for us which is important because we need that for the next step so once we find the length the next step is to simplify the K value so we're going to say our true K is equal to and we're going to perform our simplification now the first simplification is to take K and to modulus this by the length of our link list however remember that actually what we want to do is we want to kind of flip K around and we want to do that by taking the length and subtracting that from K so if we have a length of five and K is equal to 1 then we actually want to take the four elements from the front and move that to the back as opposed to taking the one element from the back and moving it to the front again it's effectively the same thing but the way that we are going to solve this problem is important so what we're going to do is we're going to put these in parenthesis and we're going to take the length and we're going to subtract that from K mod length that's going to give us the true K value or the number of rotations that we're going from the front to the back because we've flipped the order now that we have the true K value it's time to perform the rotation so remember that the first step is to Simply take the tail node and connect it to the head node however before I do that I'm kind of realizing that if we have a node or we have a linked list so we have length one this could potentially be problematic because we could be connecting the head node to itself and creating this kind of circular infinite list which we obviously don't want so what I'm going to do is just do a quick Edge case check here something you should always be considering when you're solving these problems and I'm going to say hey if the length is one it doesn't matter what K is again don't need to do any rotation so let's just return whatever the head is of this length list so I'm going to say if length is equal to one then just return the head just to make sure I'm not going to run into an issue here uh with a potential Edge case of length one so I'm kind of handle the edge case length zero length one these are typically the ones you want to consider where you have nothing or you just have one element so now that's handled now we can go and do the real rotations so remember we're connecting the tail to the head so we're just going to say the tail Dot next is going to be equal to the head but actually that reminds me we don't actually have the tail stored in a ver in a variable so what I'm going to do is instead I'm going to say current because this really is the head node next is equal to the head which was passed in okay now we're just going to go and iterate through the link list starting at the head and we're just going to remove the nth elements next pointer okay so to do that we're just going to say four and we can say actually we're going to use a w loop we're going to say current is equal to the Head we're going to say w and we need some kind of count here so maybe we're going to go with the for loop we're going to say 4 I in range and this is going to be let's go with the truecore K and we're going to say current is equal to current. next okay so now what's going to happen is we're going to go and we're going to find that k element and then we're just going to remove that pointer so I'm just going to say current. next is equal to none so I remove that kind of circular aspect I'm just getting rid of that one pointer that we don't need so before I run this code or before I would like submit this to my interviewer I just walk through it and make sure I don't have any mistakes totally fine if you do have a few mistakes by the way and that's normal especially if you're coding this out on a whiteboard but you do want to just do kind of a quick check just see if this makes sense so if the head is none okay so if that's none we're returning the head makes sense Define the length Define current okay we're going to say while current is not none length plus equals one current equals current. next okay itating through the length list if the length is one return the head makes sense true K value is equal to length minus K mod length Okay current next equals head so we're connecting that tail node which we have to the Head okay I think that makes sense current is equal to the head because we're now going to ITR through again for I in range true K because we need to find the K element good current equals current next so just iterating and then current. next equals none and then lastly return uh actually the new head note so this is the one thing that we're going to need to kind of have here is we need to know what the new head note is which I kind of missed so let's kind of go back in here and figure out how we would get that so if we're saying here that current. next is equal to none we're trying to disconnect the tail from the head which means current. next is the head so what we can do is say head is equal to current. next before we disconnect it and then when we disconnect it we still have access to the head and then we should be good so let's go for a sanity check here and let's run this uh and just see where is the Run button okay run up here okay so I just ran this code here and I realize that we have a small mistake that we need to fix so the first mistake here is with the length it says zero when actually we need to start the length that one the reason for this is that we're already accounting for the head in the fact that we say while current. next is not none because we're assuming that we have at least one node so we should start with the length equal to one now we also have a mistake here in this for Loop where I say 4 I and range true K I need to actually subtract one from True K and the reason for that is we've actually handled one of the rotations already by saying current. next is equal to the head so when I do this I'm rotating one too many times because I've already done one of the rotations with this manual line that we've written so that's kind of the change that we need to do here um that should hopefully fix this for us now there's maybe a more elegant way to write this solution keep in mind I'm doing this live in front of you I haven't seen this problem before so this is what happens right when when you're solving coding problems anyways let's run this now and hopefully this will work and there you go now we have case one and case two accepted now that doesn't mean that the solution is perfect yet what we can do now is we can submit this and uh let's see what our results are and if this actually passes all of the leak Code test cases okay so there we go we actually submitted this it was accepted it passed all of the different test cases and you can see that our runtime beat 76% of people I don't know if that's good or not uh we probably could have done better and improved the space and time complexity here just a little bit but overall I think this is a decent solution and hopefully kind of fulfilled the purpose of this video so there you go guys I'm going to wrap up the video here I hope you enjoyed and found this helpful if you did make sure you leave a like subscribe to the channel and I will see you in the next one
